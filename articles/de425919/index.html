<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïì ü§∂üèº üë®‚Äç‚öïÔ∏è Hexagon-Karten in Unity: Speichern und Laden, Texturen, Entfernungen ‚òùÔ∏è ‚ô®Ô∏è üë®‚Äçüëß‚Äçüë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Teile 1-3: Netz, Farben und Zellenh√∂hen 

 Teile 4-7: Unebenheiten, Fl√ºsse und Stra√üen 

 Teile 8-11: Wasser, Landformen und W√§lle 

 Teile 12-15: Spe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hexagon-Karten in Unity: Speichern und Laden, Texturen, Entfernungen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425919/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 1-3: Netz, Farben und Zellenh√∂hen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 4-7: Unebenheiten, Fl√ºsse und Stra√üen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 8-11: Wasser, Landformen und W√§lle</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 12-15: Speichern und Laden, Texturen, Entfernungen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 16-19: Weg finden, Spielerkader, Animationen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 20-23: Nebel des Krieges, Kartenforschung, Verfahrensgenerierung</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 24-27: Wasserkreislauf, Erosion, Biomes, zylindrische Karte</a> <br><br><h1>  Teil 12: Speichern und laden </h1><br><ul><li>  Verfolgen Sie die Art des Gel√§ndes anstelle der Farbe. </li><li>  Erstellen Sie eine Datei. </li><li>  Wir schreiben die Daten in eine Datei und lesen sie dann. </li><li>  Wir serialisieren die Zellendaten. </li><li>  Reduzieren Sie die Dateigr√∂√üe. </li></ul><br>  Wir wissen bereits, wie man interessante Karten erstellt.  Jetzt m√ºssen Sie lernen, wie Sie sie speichern. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bb/2ce/740/7bb2ce7409d37733e3b6f96c237ce1e9.jpg"></div><a name="habracut"></a><br>  <i><a href="">Wird aus der</a> Datei <a href="">test.map geladen</a> .</i> <br><br><h2>  Gel√§ndetyp </h2><br>  Beim Speichern einer Karte m√ºssen nicht alle Daten gespeichert werden, die wir w√§hrend der Ausf√ºhrung der Anwendung verfolgen.  Zum Beispiel m√ºssen wir uns nur die H√∂he der Zellen merken.  Die vertikale Position selbst wird diesen Daten entnommen, sodass Sie sie nicht speichern m√ºssen.  Eigentlich ist es besser, wenn wir diese berechneten Metriken nicht speichern.  Somit bleiben die Kartendaten korrekt, auch wenn wir sp√§ter entscheiden, den H√∂henversatz zu √§ndern.  Daten sind von ihrer Darstellung getrennt. <br><br>  Ebenso m√ºssen wir nicht die genaue Farbe der Zelle speichern.  Sie k√∂nnen schreiben, dass die Zelle gr√ºn ist.  Der genaue Gr√ºnton kann sich jedoch mit einer √Ñnderung des visuellen Stils √§ndern.  Dazu k√∂nnen wir den Farbindex speichern, nicht die Farben selbst.  Tats√§chlich kann es f√ºr uns ausreichen, diesen Index zur Laufzeit anstelle von echten Farben in den Zellen zu speichern.  Dies erm√∂glicht sp√§ter eine komplexere Visualisierung des Reliefs. <br><br><h3>  Verschieben einer Reihe von Farben </h3><br>  Wenn die Zellen keine Farbdaten mehr haben, sollten sie an einem anderen Ort gespeichert werden.  Es ist am bequemsten, es in <code>HexMetrics</code> zu speichern.  F√ºgen wir also eine Reihe von Farben hinzu. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color[] colors;</code> </pre> <br>  Wie alle anderen globalen Daten, wie z. B. Rauschen, k√∂nnen wir diese Farben mit <code>HexGrid</code> initialisieren. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color[] colors; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexMetrics.colors = colors; ‚Ä¶ } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HexMetrics.noiseSource) { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexMetrics.colors = colors; } }</code> </pre> <br>  Und da wir jetzt Zellen nicht direkt Farben zuweisen, werden wir die Standardfarbe entfernen. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Color defaultColor = Color.white; ‚Ä¶ void CreateCell (int x, int z, int i) { ‚Ä¶ HexCell cell = cells[i] = Instantiate&lt;HexCell&gt;(cellPrefab); cell.transform.localPosition = position; cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); // cell.Color = defaultColor; ‚Ä¶ }</span></span></code> </pre> <br>  Stellen Sie die neuen Farben so ein, dass sie dem allgemeinen Array des Sechseck-Karteneditors entsprechen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4bf/3cb/002/4bf3cb002342f9ab3aa482cf3a526042.png"></div><br>  <i>Dem Raster hinzugef√ºgte Farben.</i> <br><br><h3>  Zell-Refactoring </h3><br>  Entfernen Sie das Farbfeld von <code>HexCell</code> .  Stattdessen speichern wir den Index.  Anstelle eines Farbindex verwenden wir einen allgemeineren Reliefindex. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Color color; int terrainTypeIndex;</span></span></code> </pre> <br>  Die Farbeigenschaft kann diesen Index nur verwenden, um die entsprechende Farbe zu erhalten.  Jetzt ist es nicht direkt eingestellt, also l√∂schen Sie diesen Teil.  In diesem Fall erhalten wir einen Kompilierungsfehler, den wir bald beheben werden. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color Color { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HexMetrics.colors[terrainTypeIndex]; } <span class="hljs-comment"><span class="hljs-comment">// set { // ‚Ä¶ // } }</span></span></code> </pre> <br>  F√ºgen Sie eine neue Eigenschaft hinzu, um einen neuen H√∂henindex abzurufen und festzulegen. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TerrainTypeIndex { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> terrainTypeIndex; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (terrainTypeIndex != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { terrainTypeIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Refresh(); } } }</code> </pre> <br><h3>  Editor Refactoring </h3><br>  In <code>HexMapEditor</code> l√∂schen <code>HexMapEditor</code> gesamten Code bez√ºglich der Farben.  Dadurch wird der Kompilierungsfehler behoben. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Color[] colors; ‚Ä¶ // Color activeColor; ‚Ä¶ // bool applyColor; ‚Ä¶ // public void SelectColor (int index) { // applyColor = index &gt;= 0; // if (applyColor) { // activeColor = colors[index]; // } // } ‚Ä¶ // void Awake () { // SelectColor(0); // } ‚Ä¶ void EditCell (HexCell cell) { if (cell) { // if (applyColor) { // cell.Color = activeColor; // } ‚Ä¶ } }</span></span></code> </pre> <br>  F√ºgen Sie nun ein Feld und eine Methode hinzu, um den aktiven H√∂henindex zu steuern. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> activeTerrainTypeIndex; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainTypeIndex</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span> { activeTerrainTypeIndex = index; }</code> </pre> <br>  Wir verwenden diese Methode als Ersatz f√ºr die jetzt fehlende <code>SelectColor</code> Methode.  Verbinden Sie die Farb-Widgets in der Benutzeroberfl√§che mit <code>SetTerrainTypeIndex</code> , und lassen Sie alles andere unver√§ndert.  Dies bedeutet, dass noch ein negativer Index verwendet wird und sich die Farbe nicht √§ndern sollte. <br><br>  √Ñndern Sie <code>EditCell</code> so, dass der Elevationstypindex der zu bearbeitenden Zelle zugewiesen wird. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (activeTerrainTypeIndex &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.TerrainTypeIndex = activeTerrainTypeIndex; } ‚Ä¶ } }</code> </pre> <br>  Obwohl wir die Farbdaten aus den Zellen entfernt haben, sollte die Karte genauso funktionieren wie zuvor.  Der einzige Unterschied besteht darin, dass die Standardfarbe jetzt die erste im Array ist.  In meinem Fall ist es gelb. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cc/e7e/6ac/8cce7e6acb202e119a6e7d5cdae2db74.png"></div><br>  <i>Gelb ist die neue Standardfarbe.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Einheitspaket</a> <br><br><h2>  Daten in einer Datei speichern </h2><br>  Um das Speichern und Laden der Karte zu steuern, verwenden wir <code>HexMapEditor</code> .  Wir werden zwei Methoden erstellen, die dies tun, und sie vorerst leer lassen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { }</code> </pre> <br>  F√ºgen Sie der Benutzeroberfl√§che zwei Schaltfl√§chen hinzu ( <em>GameObject / UI / Button</em> ).  Verbinden Sie sie mit den Tasten und geben Sie die entsprechenden Beschriftungen.  Ich habe sie unten im rechten Bereich platziert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ec/eba/96b/6eceba96bb5ff18fd0b4ad9472a19695.png"></div><br>  <i>Schaltfl√§chen zum Speichern und Laden.</i> <br><br><h3>  Speicherort der Datei </h3><br>  Um eine Karte zu speichern, m√ºssen Sie sie irgendwo speichern.  Wie in den meisten Spielen werden Daten in einer Datei gespeichert.  Aber wo soll diese Datei im Dateisystem abgelegt werden?  Die Antwort h√§ngt davon ab, auf welchem ‚Äã‚ÄãBetriebssystem das Spiel ausgef√ºhrt wird.  Jedes Betriebssystem hat seine eigenen Standards zum Speichern von Dateien, die sich auf Anwendungen beziehen. <br><br>  Wir m√ºssen diese Standards nicht kennen.  Unity kennt den richtigen Pfad, den wir mit <code>Application.persistentDataPath</code> .  Sie k√∂nnen √ºberpr√ºfen, wie es mit Ihnen sein wird, indem Sie es <code>Save</code> , in der Konsole anzeigen und die Taste im Wiedergabemodus dr√ºcken. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Debug.Log(Application.persistentDataPath); }</code> </pre> <br>  Auf Desktop-Systemen enth√§lt der Pfad den Namen des Unternehmens und des Produkts.  Dieser Pfad wird sowohl vom Editor als auch von der Assembly verwendet.  Namen k√∂nnen unter <em>Bearbeiten / Projekteinstellungen / Player</em> konfiguriert werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/656/a60/056/656a60056f9d51c5a5f3d81762135b87.png"></div><br>  <i>Name des Unternehmens und des Produkts.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Warum kann ich den Bibliotheksordner auf dem Mac nicht finden?</b> <div class="spoiler_text">  Der <em>Bibliotheksordner</em> wird h√§ufig ausgeblendet.  Die Art und Weise, wie es angezeigt werden kann, h√§ngt von der Version von OS X ab. Wenn Sie keine √§ltere Version haben, w√§hlen Sie den Home-Ordner im Finder aus und gehen Sie zu <em>Ansichtsoptionen anzeigen</em> .  Es gibt ein Kontrollk√§stchen f√ºr den <em>Bibliotheksordner</em> . </div></div><br><div class="spoiler">  <b class="spoiler_title">Was ist mit WebGL?</b> <div class="spoiler_text">  WebGL-Spiele k√∂nnen nicht auf das Dateisystem des Benutzers zugreifen.  Stattdessen werden alle Dateivorg√§nge in ein Dateisystem im Speicher umgeleitet.  Sie ist f√ºr uns transparent.  Um die Daten zu speichern, m√ºssen Sie die Webseite jedoch manuell bestellen, um die Daten in den Browserspeicher zu kopieren. </div></div><br><h3>  Dateierstellung </h3><br>  Um eine Datei zu erstellen, m√ºssen Klassen aus dem <code>System.IO</code> Namespace verwendet werden.  Daher f√ºgen wir eine <code>using</code> Anweisung f√ºr die <code>HexMapEditor</code> Klasse hinzu. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.EventSystems; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexMapEditor</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ }</code> </pre> <br>  Zuerst m√ºssen wir den vollst√§ndigen Pfad zur Datei erstellen.  Wir verwenden <em>test.map</em> als Dateinamen.  Es muss dem Pfad der gespeicherten Daten hinzugef√ºgt werden.  Ob Sie einen Forward- oder Backslash (Slash oder Backslash) einf√ºgen m√ºssen, h√§ngt von der Plattform ab.  Die <code>Path.Combine</code> Methode f√ºhrt <code>Path.Combine</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); }</code> </pre> <br>  Als n√§chstes m√ºssen wir an dieser Stelle auf die Datei zugreifen.  Wir tun dies mit der <code>File.Open</code> Methode.  Da wir Daten in diese Datei schreiben m√∂chten, m√ºssen wir den Erstellungsmodus verwenden.  In diesem Fall wird entweder eine neue Datei auf dem angegebenen Pfad erstellt oder eine vorhandene Datei ersetzt. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); File.Open(path, FileMode.Create);</code> </pre> <br>  Das Ergebnis des Aufrufs dieser Methode ist ein offener Datenstrom, der dieser Datei zugeordnet ist.  Wir k√∂nnen es verwenden, um Daten in eine Datei zu schreiben.  Und wir d√ºrfen nicht vergessen, den Strom zu schlie√üen, wenn wir ihn nicht mehr brauchen. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); Stream fileStream = File.Open(path, FileMode.Create); fileStream.Close();</code> </pre> <br>  Wenn Sie zu diesem Zeitpunkt auf die Schaltfl√§che <em>Speichern</em> klicken, wird die Datei <em>test.map</em> in dem Ordner erstellt, der als Pfad zu den gespeicherten Daten angegeben ist.  Wenn Sie diese Datei studieren, ist sie leer und hat eine Gr√∂√üe von 0 Byte, da wir bisher nichts darauf geschrieben haben. <br><br><h3>  In Datei schreiben </h3><br>  Um Daten in eine Datei zu schreiben, ben√∂tigen wir eine M√∂glichkeit, Daten in diese Datei zu streamen.  Der einfachste Weg, dies zu tun, ist mit <code>BinaryWriter</code> .  Mit diesen Objekten k√∂nnen Sie primitive Daten in einen beliebigen Stream schreiben. <br><br>  Erstellen Sie ein neues <code>BinaryWriter</code> Objekt, und unser Dateistream wird sein Argument sein.  Closing Writer schlie√üt den verwendeten Stream.  Daher m√ºssen wir keinen direkten Link mehr zum Stream speichern. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)); writer.Close();</code> </pre> <br>  Um Daten in einen Stream zu √ºbertragen, k√∂nnen wir die <code>BinaryWriter.Write</code> Methode verwenden.  Es gibt eine Variante der <code>Write</code> Methode f√ºr alle primitiven Typen wie Integer und Float.  Es k√∂nnen auch Zeilen aufgezeichnet werden.  Versuchen wir, eine Ganzzahl 123 zu schreiben. <br><br><pre> <code class="cs hljs"> BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)); writer.Write(<span class="hljs-number"><span class="hljs-number">123</span></span>); writer.Close();</code> </pre> <br>  Klicken <em>Sie auf die</em> Schaltfl√§che <em>Speichern</em> und √ºberpr√ºfen Sie <em>test.map</em> erneut.  Jetzt betr√§gt seine Gr√∂√üe 4 Bytes, da die Ganzzahlgr√∂√üe 4 Bytes betr√§gt. <br><br><div class="spoiler">  <b class="spoiler_title">Warum zeigt mein Dateimanager an, dass die Datei mehr Speicherplatz beansprucht?</b> <div class="spoiler_text">  Weil Dateisysteme den Speicherplatz in Bytebl√∂cke unterteilen.  Sie verfolgen keine einzelnen Bytes.  Da <em>test.map bisher</em> nur vier Bytes ben√∂tigt, wird ein Block Speicherplatz ben√∂tigt. </div></div><br>  Beachten Sie, dass wir Bin√§rdaten speichern, keinen f√ºr Menschen lesbaren Text.  Wenn wir die Datei in einem Texteditor √∂ffnen, sehen wir daher eine Reihe undeutlicher Zeichen.  Sie werden wahrscheinlich das Symbol <em>{</em> gefolgt von nichts oder ein paar Platzhaltern sehen. <br><br>  Sie k√∂nnen die Datei in einem Hex-Editor √∂ffnen.  In diesem Fall sehen wir <em>7b 00 00 00</em> .  Dies sind vier Bytes unserer Ganzzahl, die in hexadezimaler Notation abgebildet sind.  In gew√∂hnlichen Dezimalzahlen ist dies <em>123 0 0 0</em> .  In der Bin√§rdatei sieht das erste Byte wie <em>01111011 aus</em> . <br><br>  Der ASCII-Code f√ºr <em>{</em> ist 123, sodass dieses Zeichen in einem Texteditor angezeigt werden kann.  ASCII 0 ist ein Nullzeichen, das keinen sichtbaren Zeichen entspricht. <br><br>  Die verbleibenden drei Bytes sind gleich Null, da wir eine Zahl kleiner als 256 geschrieben haben. Wenn wir 256 schreiben w√ºrden, w√ºrden wir <em>00 01 00 00</em> im Hex-Editor sehen. <br><br><div class="spoiler">  <b class="spoiler_title">Sollte 123 nicht als 00 00 00 7b gespeichert werden?</b> <div class="spoiler_text">  <code>BinaryWriter</code> verwendet das Little-Endian-Format zum Speichern von Zahlen.  Dies bedeutet, dass die niedrigstwertigen Bytes zuerst geschrieben werden.  Dieses Format wurde von Microsoft bei der Entwicklung des .NET-Frameworks verwendet.  Es wurde wahrscheinlich gew√§hlt, weil die Intel-CPU das Little-Endian-Format verwendet. <br><br>  Eine Alternative dazu ist Big-Endian, bei dem die h√∂chstwertigen Bytes zuerst gespeichert werden.  Dies entspricht der √ºblichen Reihenfolge von Zahlen in Zahlen.  123 ist einhundertdreiundzwanzig, weil wir den Big-Endian-Rekord meinen.  Wenn es ein Little-Endian w√§re, w√ºrde 123 dreihunderteinundzwanzig bedeuten. </div></div><br><h3>  Wir machen Ressourcen frei </h3><br>  Es ist wichtig, dass wir den Schriftsteller schlie√üen.  W√§hrend es ge√∂ffnet ist, sperrt das Dateisystem die Datei und verhindert, dass andere Prozesse darauf schreiben.  Wenn wir vergessen, es zu schlie√üen, werden wir uns auch blockieren.  Wenn wir zweimal auf die Schaltfl√§che Speichern klicken, k√∂nnen wir den Stream beim zweiten Mal nicht √∂ffnen. <br><br>  Anstatt den Writer manuell zu schlie√üen, k√∂nnen wir hierf√ºr einen <code>using</code> Block erstellen.  Es definiert den Bereich, in dem der Writer g√ºltig ist.  Wenn der ausf√ºhrbare Code diesen Bereich √ºberschreitet, wird der Writer gel√∂scht und der Thread geschlossen. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(<span class="hljs-number"><span class="hljs-number">123</span></span>); } <span class="hljs-comment"><span class="hljs-comment">// writer.Close();</span></span></code> </pre> <br>  Dies funktioniert, da die <code>IDisposable</code> und File-Stream-Klassen die <code>IDisposable</code> Schnittstelle implementieren.  Diese Objekte verf√ºgen √ºber eine <code>Dispose</code> Methode, die indirekt aufgerufen wird, wenn sie √ºber den <code>using</code> hinausgehen. <br><br>  Der gro√üe Vorteil der <code>using</code> ist, dass sie funktioniert, unabh√§ngig davon, wie das Programm keinen Umfang mehr hat.  Fr√ºhe R√ºcksendungen, Ausnahmen und Fehler st√∂ren ihn nicht.  Au√üerdem ist er sehr pr√§gnant. <br><br><h3>  Datenabruf </h3><br>  Um zuvor geschriebene Daten zu lesen, m√ºssen wir den Code in die <code>Load</code> Methode einf√ºgen.  Wie beim Speichern m√ºssen wir einen Pfad erstellen und den Dateistream √∂ffnen.  Der Unterschied ist, dass wir jetzt die Datei zum Lesen √∂ffnen, nicht zum Schreiben.  Und statt Schriftsteller brauchen wir <code>BinaryReader</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.Open(path, FileMode.Open)) ) { } }</code> </pre> <br>  In diesem Fall k√∂nnen wir die <code>File.OpenRead</code> Methode verwenden, um die Datei zum Lesen zu √∂ffnen. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Warum k√∂nnen wir File.OpenWrite beim Schreiben nicht verwenden?</b> <div class="spoiler_text">  Diese Methode erstellt einen Stream, der Daten zu vorhandenen Dateien hinzuf√ºgt, anstatt sie zu ersetzen. </div></div><br>  Beim Lesen m√ºssen wir den Typ der empfangenen Daten explizit angeben.  Um eine Ganzzahl aus einem Stream zu lesen, m√ºssen wir <code>BinaryReader.ReadInt32</code> .  Diese Methode liest eine 32-Bit-Ganzzahl, d. H. Vier Bytes. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { Debug.Log(reader.ReadInt32()); }</code> </pre> <br>  Es ist zu beachten, dass es beim Empfang von <em>123</em> ausreicht, ein Byte zu lesen.  Gleichzeitig verbleiben jedoch drei zu dieser Ganzzahl geh√∂rende Bytes im Stream.  Dar√ºber hinaus funktioniert dies nicht f√ºr Zahlen au√üerhalb des Intervalls 0‚Äì255.  Tun Sie dies daher nicht. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Einheitspaket</a> <br><br><h2>  Kartendaten schreiben und lesen </h2><br>  Eine wichtige Frage beim Speichern von Daten ist, ob ein f√ºr Menschen lesbares Format verwendet werden soll.  In der Regel sind lesbare Formate JSON, XML und einfaches ASCII mit einer bestimmten Struktur.  Solche Dateien k√∂nnen in Texteditoren ge√∂ffnet, interpretiert und bearbeitet werden.  Dar√ºber hinaus vereinfachen sie den Datenaustausch zwischen verschiedenen Anwendungen. <br><br>  Solche Formate haben jedoch ihre eigenen Anforderungen.  Dateien belegen mehr Speicherplatz (manchmal viel mehr) als die Verwendung von Bin√§rdaten.  Sie k√∂nnen auch die Kosten f√ºr das Codieren und Decodieren von Daten sowohl hinsichtlich der Laufzeit als auch des Speicherbedarfs erheblich erh√∂hen. <br><br>  Im Gegensatz dazu sind Bin√§rdaten kompakt und schnell.  Dies ist wichtig, wenn Sie gro√üe Datenmengen aufzeichnen.  Zum Beispiel, wenn in jeder Spielrunde automatisch eine gro√üe Karte gespeichert wird.  Deshalb <br>  Wir werden das Bin√§rformat verwenden.  Wenn Sie damit umgehen k√∂nnen, k√∂nnen Sie mit detaillierteren Formaten arbeiten. <br><br><div class="spoiler">  <b class="spoiler_title">Was ist mit der automatischen Serialisierung?</b> <div class="spoiler_text">  Unmittelbar w√§hrend des Serialisierens von Unity-Daten k√∂nnen wir serialisierte Klassen direkt in den Stream schreiben.  Details zur Erfassung einzelner Felder werden uns verborgen bleiben.  Wir k√∂nnen die Zellen jedoch nicht direkt serialisieren.  Dies sind <code>MonoBehaviour</code> Klassen, die Daten enthalten, die wir nicht speichern m√ºssen.  Daher m√ºssen wir eine separate Hierarchie von Objekten verwenden, was die Einfachheit der automatischen Serialisierung zerst√∂rt.  Dar√ºber hinaus wird es schwieriger sein, zuk√ºnftige Code√§nderungen zu unterst√ºtzen.  Daher behalten wir die volle Kontrolle √ºber die manuelle Serialisierung.  Au√üerdem werden wir wirklich verstehen, was passiert. </div></div><br>  Um die Karte zu serialisieren, m√ºssen wir die Daten jeder Zelle speichern.  <code>HexCell</code> Methoden <code>Save</code> und <code>Load</code> hinzu, um eine einzelne Zelle zu <code>Save</code> und zu <code>HexCell</code> .  Da sie einen Schreiber oder Leser ben√∂tigen, um zu arbeiten, werden wir sie als Parameter hinzuf√ºgen. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCell</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { } }</code> </pre> <br>  F√ºgen <code>Save</code> <code>HexGrid</code> Methoden zum <code>Save</code> und <code>Load</code> <code>HexGrid</code> .  Diese Methoden umgehen einfach alle Zellen, indem sie ihre <code>Load</code> und <code>Save</code> Methoden aufrufen. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexGrid</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Save(writer); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Load(reader); } } }</code> </pre> <br>  Wenn wir eine Karte herunterladen, muss sie aktualisiert werden, nachdem die Zellendaten ge√§ndert wurden.  Aktualisieren Sie dazu einfach alle Fragmente. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Load(reader); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunks.Length; i++) { chunks[i].Refresh(); } }</code> </pre> <br>  Schlie√ülich ersetzen wir unseren <code>HexMapEditor</code> in <code>HexMapEditor</code> durch Aufrufe der <code>Save</code> and <code>Load</code> Methoden des Grids, wobei wir den Writer oder Reader damit √ºbergeben. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { hexGrid.Save(writer); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { hexGrid.Load(reader); } }</code> </pre> <br><h3>  Relieftyp speichern </h3><br>  Beim erneuten Speichern wird derzeit eine leere Datei erstellt, und beim Herunterladen wird nichts ausgef√ºhrt.  Beginnen wir schrittweise, indem wir nur den <code>HexCell</code> H√∂henindex aufzeichnen und laden. <br><br>  Weisen Sie den Wert direkt dem Feld TerrainTypeIndex zu.  Wir werden keine Eigenschaften verwenden.  Da wir alle Fragmente explizit aktualisieren, sind keine Aufrufe der Aktualisierungseigenschaften erforderlich.  Da wir nur die richtigen Karten speichern, gehen wir au√üerdem davon aus, dass alle heruntergeladenen Karten auch korrekt sind.  Daher werden wir beispielsweise nicht pr√ºfen, ob der Fluss oder die Stra√üe zul√§ssig ist. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(terrainTypeIndex); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadInt32(); }</code> </pre> <br>  Beim Speichern in dieser Datei wird nacheinander der Index des Relieftyps aller Zellen geschrieben.  Da der Index eine Ganzzahl ist, betr√§gt seine Gr√∂√üe vier Bytes.  Meine Karte enth√§lt 300 Zellen, d. H. Die Dateigr√∂√üe betr√§gt 1200 Byte. <br><br>  Das Laden liest die Indizes in derselben Reihenfolge, in der sie geschrieben wurden.  Wenn Sie die Farben der Zellen nach dem Speichern ge√§ndert haben, werden beim Laden der Karte die Farben beim Speichern in den Status zur√ºckgesetzt.  Da wir nichts mehr speichern, bleiben die restlichen Zellendaten gleich.  Das hei√üt, durch das Laden wird die Art des Gel√§ndes ge√§ndert, nicht jedoch die H√∂he, der Wasserstand, die Gel√§ndemerkmale usw. <br><br><h3>  Alle Ganzzahlen speichern </h3><br>  Das Speichern eines Relief-Index reicht uns nicht aus.  Sie m√ºssen alle anderen Daten speichern.  Beginnen wir mit allen ganzzahligen Feldern.  Dies ist ein Index der Art des Reliefs, der Zellh√∂he, des Wasserspiegels, des Stadtspiegels, des Bauernhofniveaus, des Vegetationsniveaus und des Index spezieller Objekte.  Sie m√ºssen in derselben Reihenfolge gelesen werden, in der sie aufgezeichnet wurden. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(terrainTypeIndex); writer.Write(elevation); writer.Write(waterLevel); writer.Write(urbanLevel); writer.Write(farmLevel); writer.Write(plantLevel); writer.Write(specialIndex); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadInt32(); elevation = reader.ReadInt32(); waterLevel = reader.ReadInt32(); urbanLevel = reader.ReadInt32(); farmLevel = reader.ReadInt32(); plantLevel = reader.ReadInt32(); specialIndex = reader.ReadInt32(); }</code> </pre> <br>  Versuchen Sie jetzt, die Karte zu speichern und zu laden, und nehmen Sie zwischen diesen Vorg√§ngen √Ñnderungen vor.  Alles, was wir in die gespeicherten Daten aufgenommen haben, wurde so gut wie m√∂glich wiederhergestellt, mit Ausnahme der H√∂he der Zelle.  Dies geschah, weil Sie beim √Ñndern der H√∂henstufe die vertikale Position der Zelle aktualisieren m√ºssen.  Dies kann erreicht werden, indem der Eigenschaft und nicht dem Feld der Wert der geladenen H√∂he zugewiesen wird.  Diese Eigenschaft erledigt jedoch zus√§tzliche Arbeiten, die wir nicht ben√∂tigen.  Extrahieren wir daher den Code, der die <code>RefreshPosition</code> aktualisiert, aus dem <code>Elevation</code> Setter und f√ºgen ihn in eine separate <code>RefreshPosition</code> Methode ein.  Die einzige √Ñnderung, die Sie hier vornehmen m√ºssen, besteht darin, den <code>value</code> Verweis auf das <code>elevation</code> zu ersetzen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 position = transform.localPosition; position.y = elevation * HexMetrics.elevationStep; position.y += (HexMetrics.SampleNoise(position).y * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * HexMetrics.elevationPerturbStrength; transform.localPosition = position; Vector3 uiPosition = uiRect.localPosition; uiPosition.z = -position.y; uiRect.localPosition = uiPosition; }</code> </pre> <br>  Jetzt k√∂nnen wir die Methode beim Festlegen der Eigenschaft sowie nach dem Laden der H√∂hendaten aufrufen. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevation == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } elevation = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; RefreshPosition(); ValidateRivers(); ‚Ä¶ } } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadInt32(); elevation = reader.ReadInt32(); RefreshPosition(); ‚Ä¶ }</code> </pre> <br>  Nach dieser √Ñnderung √§ndern die Zellen beim Laden korrekt ihre scheinbare H√∂he. <br><br><h3>  Alle Daten speichern </h3><br>  Das Vorhandensein von Mauern und ein- und ausgehenden Fl√ºssen in der Zelle wird in Booleschen Feldern gespeichert.  Wir k√∂nnen sie einfach als ganze Zahl schreiben.  Au√üerdem sind Stra√üendaten ein Array von sechs Booleschen Werten, die wir mit einer Schleife schreiben k√∂nnen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(terrainTypeIndex); writer.Write(elevation); writer.Write(waterLevel); writer.Write(urbanLevel); writer.Write(farmLevel); writer.Write(plantLevel); writer.Write(specialIndex); writer.Write(walled); writer.Write(hasIncomingRiver); writer.Write(hasOutgoingRiver); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { writer.Write(roads[i]); } }</code> </pre> <br>  <code>HexDirection</code> f√ºr eingehende und ausgehende Fl√ºsse werden in <code>HexDirection</code> Feldern gespeichert.  Der <code>HexDirection</code> Typ ist eine Aufz√§hlung, die intern als mehrere ganzzahlige Werte gespeichert wird.  Daher k√∂nnen wir sie auch als Ganzzahl mithilfe einer expliziten Konvertierung serialisieren. <br><br><pre> <code class="cs hljs"> writer.Write(hasIncomingRiver); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)incomingRiver); writer.Write(hasOutgoingRiver); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)outgoingRiver);</code> </pre> <br>  Boolesche Werte werden mit der <code>BinaryReader.ReadBoolean</code> Methode gelesen.  Die Richtungen der Fl√ºsse sind ganzzahlig, die wir zur√ºck in <code>HexDirection</code> konvertieren <code>HexDirection</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadInt32(); elevation = reader.ReadInt32(); RefreshPosition(); waterLevel = reader.ReadInt32(); urbanLevel = reader.ReadInt32(); farmLevel = reader.ReadInt32(); plantLevel = reader.ReadInt32(); specialIndex = reader.ReadInt32(); walled = reader.ReadBoolean(); hasIncomingRiver = reader.ReadBoolean(); incomingRiver = (HexDirection)reader.ReadInt32(); hasOutgoingRiver = reader.ReadBoolean(); outgoingRiver = (HexDirection)reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { roads[i] = reader.ReadBoolean(); } }</code> </pre> <br>  Jetzt speichern wir alle Zellendaten, die zum vollst√§ndigen Speichern und Wiederherstellen der Karte erforderlich sind.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies erfordert neun Ganzzahlen und neun Boolesche Werte pro Zelle. </font><font style="vertical-align: inherit;">Jeder Boolesche Wert ben√∂tigt ein Byte, daher verwenden wir insgesamt 45 Bytes pro Zelle. </font><font style="vertical-align: inherit;">Das hei√üt, eine Karte mit 300 Zellen ben√∂tigt insgesamt 13.500 Bytes. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dateigr√∂√üe reduzieren </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl es den Anschein hat, dass 13.500 Bytes f√ºr 300 Zellen nicht sehr viel sind, k√∂nnen wir vielleicht mit einer geringeren Menge fertig werden. </font><font style="vertical-align: inherit;">Am Ende haben wir die volle Kontrolle dar√ºber, wie Daten serialisiert werden. </font><font style="vertical-align: inherit;">Mal sehen, ob es eine kompaktere M√∂glichkeit gibt, sie zu speichern.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Numerische Intervallreduzierung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verschiedene Zellebenen und Indizes werden als Ganzzahl gespeichert. </font><font style="vertical-align: inherit;">Sie verwenden jedoch nur einen kleinen Wertebereich. </font><font style="vertical-align: inherit;">Jeder von ihnen wird definitiv im Bereich von 0 bis 255 bleiben. </font><font style="vertical-align: inherit;">Dies bedeutet, dass nur das erste Byte jeder Ganzzahl verwendet wird. </font><font style="vertical-align: inherit;">Die restlichen drei sind immer Null. </font><font style="vertical-align: inherit;">Es macht keinen Sinn, diese leeren Bytes zu speichern. </font><font style="vertical-align: inherit;">Wir k√∂nnen sie verwerfen, indem wir Ganzzahl zu Byte schreiben, bevor wir in den Stream schreiben.</font></font><br><br><pre> <code class="cs hljs"> writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)terrainTypeIndex); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)elevation); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)waterLevel); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)urbanLevel); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)farmLevel); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)plantLevel); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)specialIndex); writer.Write(walled); writer.Write(hasIncomingRiver); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)incomingRiver); writer.Write(hasOutgoingRiver); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)outgoingRiver);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um diese Zahlen zur√ºckzugeben, m√ºssen wir verwenden </font></font><code>BinaryReader.ReadByte</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die Konvertierung von Byte in Ganzzahl erfolgt implizit, sodass keine expliziten Konvertierungen hinzugef√ºgt werden m√ºssen.</font></font><br><br><pre> <code class="cs hljs"> terrainTypeIndex = reader.ReadByte(); elevation = reader.ReadByte(); RefreshPosition(); waterLevel = reader.ReadByte(); urbanLevel = reader.ReadByte(); farmLevel = reader.ReadByte(); plantLevel = reader.ReadByte(); specialIndex = reader.ReadByte(); walled = reader.ReadBoolean(); hasIncomingRiver = reader.ReadBoolean(); incomingRiver = (HexDirection)reader.ReadByte(); hasOutgoingRiver = reader.ReadBoolean(); outgoingRiver = (HexDirection)reader.ReadByte();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden also drei Bytes pro Ganzzahl los, was 27 Bytes pro Zelle spart. Jetzt geben wir 18 Bytes pro Zelle und nur 5.400 Bytes pro 300 Zellen aus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist erw√§hnenswert, dass die alten Kartendaten zu diesem Zeitpunkt bedeutungslos werden. Beim Laden des alten Speichers werden die Daten verwechselt und es entstehen verwirrende Zellen. Dies liegt daran, dass wir jetzt weniger Daten lesen. Wenn wir mehr Daten als zuvor lesen, wird beim Versuch, √ºber das Ende der Datei hinaus zu lesen, eine Fehlermeldung angezeigt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Unf√§higkeit, alte Daten zu verarbeiten, passt zu uns, da wir gerade dabei sind, das Format zu bestimmen. </font><font style="vertical-align: inherit;">Wenn wir uns jedoch f√ºr das Speicherformat entscheiden, m√ºssen wir sicherstellen, dass zuk√ºnftiger Code es immer lesen kann. </font><font style="vertical-align: inherit;">Selbst wenn wir das Format √§ndern, sollten wir im Idealfall das alte Format lesen k√∂nnen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> River Byte Union </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In dieser Phase verwenden wir vier Bytes zum Speichern von Flussdaten, zwei pro Richtung. </font><font style="vertical-align: inherit;">F√ºr jede Richtung speichern wir das Vorhandensein des Flusses und die Richtung, in die er flie√üt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es scheint offensichtlich, dass wir die Richtung des Flusses nicht speichern m√ºssen, wenn dies nicht der Fall ist. </font><font style="vertical-align: inherit;">Dies bedeutet, dass Zellen ohne Fluss zwei Bytes weniger ben√∂tigen. </font><font style="vertical-align: inherit;">Tats√§chlich wird ein Byte in Richtung des Flusses f√ºr uns ausreichen, unabh√§ngig von seiner Existenz.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben sechs m√∂gliche Richtungen, die als Zahlen im Intervall 0‚Äì5 gespeichert sind. </font><font style="vertical-align: inherit;">Daf√ºr reichen drei Bits aus, denn in bin√§rer Form sehen Zahlen von 0 bis 5 wie 000, 001, 010, 011, 100, 101 und 110 aus. Das hei√üt, f√ºnf weitere Bits bleiben in einem Byte unbenutzt. </font><font style="vertical-align: inherit;">Wir k√∂nnen einen davon verwenden, um anzuzeigen, ob ein Fluss existiert. </font><font style="vertical-align: inherit;">Sie k√∂nnen beispielsweise das achte Bit verwenden, das der Zahl 128 entspricht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dazu addieren wir 128, bevor wir die Richtung in Bytes umwandeln. Wenn also ein Fluss nach Nordwesten flie√üt, schreiben wir 133, was in bin√§rer Form 10000101 ist. Und wenn es keinen Fluss gibt, schreiben wir einfach ein Null-Byte.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gleichzeitig bleiben vier weitere Bits unbenutzt, dies ist jedoch normal. </font><font style="vertical-align: inherit;">Wir k√∂nnen beide Richtungen des Flusses in einem Byte kombinieren, aber das wird schon zu verwirrend sein.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// writer.Write(hasIncomingRiver); // writer.Write((byte)incomingRiver); if (hasIncomingRiver) { writer.Write((byte)(incomingRiver + 128)); } else { writer.Write((byte)0); } // writer.Write(hasOutgoingRiver); // writer.Write((byte)outgoingRiver); if (hasOutgoingRiver) { writer.Write((byte)(outgoingRiver + 128)); } else { writer.Write((byte)0); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um Flussdaten zu dekodieren, m√ºssen wir zuerst das Byte zur√ºcklesen. </font><font style="vertical-align: inherit;">Wenn sein Wert nicht weniger als 128 betr√§gt, bedeutet dies, dass es einen Fluss gibt. </font><font style="vertical-align: inherit;">Subtrahieren Sie 128 und konvertieren Sie dann zu </font></font><code>HexDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// hasIncomingRiver = reader.ReadBoolean(); // incomingRiver = (HexDirection)reader.ReadByte(); byte riverData = reader.ReadByte(); if (riverData &gt;= 128) { hasIncomingRiver = true; incomingRiver = (HexDirection)(riverData - 128); } else { hasIncomingRiver = false; } // hasOutgoingRiver = reader.ReadBoolean(); // outgoingRiver = (HexDirection)reader.ReadByte(); riverData = reader.ReadByte(); if (riverData &gt;= 128) { hasOutgoingRiver = true; outgoingRiver = (HexDirection)(riverData - 128); } else { hasOutgoingRiver = false; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als Ergebnis haben wir 16 Bytes pro Zelle. </font><font style="vertical-align: inherit;">Die Verbesserung scheint nicht gro√ü zu sein, aber dies ist einer dieser Tricks, mit denen die Gr√∂√üe von Bin√§rdaten reduziert wird.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Speichern Sie Stra√üen in einem Byte </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen einen √§hnlichen Trick verwenden, um Stra√üendaten zu komprimieren. </font><font style="vertical-align: inherit;">Wir haben sechs boolesche Werte, die in den ersten sechs Bits eines Bytes gespeichert werden k√∂nnen. </font><font style="vertical-align: inherit;">Das hei√üt, jede Richtung der Stra√üe wird durch eine Zahl dargestellt, die eine Zweierpotenz ist. </font><font style="vertical-align: inherit;">Dies sind 1, 2, 4, 8, 16 und 32 oder in bin√§rer Form 1, 10, 100, 1000, 10000 und 100000. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um ein fertiges Byte zu erstellen, m√ºssen wir die Bits setzen, die den verwendeten Richtungen der Stra√üen entsprechen. </font><font style="vertical-align: inherit;">Um die richtige Richtung f√ºr die Richtung zu erhalten, k√∂nnen wir den Operator verwenden </font></font><code>&lt;&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kombinieren Sie sie dann mit dem bitweisen ODER-Operator. </font><font style="vertical-align: inherit;">Wenn beispielsweise die erste, zweite, dritte und sechste Stra√üe verwendet werden, lautet das fertige Byte 100111.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> roadFlags = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { <span class="hljs-comment"><span class="hljs-comment">// writer.Write(roads[i]); if (roads[i]) { roadFlags |= 1 &lt;&lt; i; } } writer.Write((byte)roadFlags);</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie funktioniert &lt;&lt;?</font></font></b> <div class="spoiler_text">     .   integer      .  .     integer .    ,          .   <code>1 &lt;&lt; n</code>  2 <sup>n</sup> ,    . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um den Booleschen Wert der Stra√üe zur√ºck zu erhalten, m√ºssen Sie √ºberpr√ºfen, ob das Bit gesetzt ist. </font><font style="vertical-align: inherit;">Wenn ja, maskieren Sie alle anderen Bits mit dem bitweisen UND-Operator mit der entsprechenden Nummer. </font><font style="vertical-align: inherit;">Wenn das Ergebnis nicht gleich Null ist, wird das Bit gesetzt und die Stra√üe existiert.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> roadFlags = reader.ReadByte(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { roads[i] = (roadFlags &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; i)) != <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir sechs Bytes zu einem zusammengedr√ºckt hatten, erhielten wir 11 Bytes pro Zelle. </font><font style="vertical-align: inherit;">Bei 300 Zellen sind dies nur 3.300 Bytes. </font><font style="vertical-align: inherit;">Nachdem wir ein wenig mit Bytes gearbeitet haben, haben wir die Dateigr√∂√üe um 75% reduziert.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Immer bereit f√ºr die Zukunft </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevor wir unser Speicherformat f√ºr vollst√§ndig erkl√§ren, f√ºgen wir noch ein Detail hinzu. </font><font style="vertical-align: inherit;">Vor dem Speichern der Kartendaten wird erzwungen </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, eine ganzzahlige Null </font><font style="vertical-align: inherit;">zu </font><font style="vertical-align: inherit;">schreiben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(<span class="hljs-number"><span class="hljs-number">0</span></span>); hexGrid.Save(writer); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dadurch werden am Anfang unserer Daten vier leere Bytes hinzugef√ºgt. </font><font style="vertical-align: inherit;">Das hei√üt, bevor wir die Karte laden, m√ºssen wir diese vier Bytes lesen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { reader.ReadInt32(); hexGrid.Load(reader); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl diese Bytes bisher unbrauchbar sind, werden sie als Header verwendet, der in Zukunft Abw√§rtskompatibilit√§t bietet. </font><font style="vertical-align: inherit;">Wenn wir diese Null-Bytes nicht hinzugef√ºgt hatten, hing der Inhalt der ersten paar Bytes von der ersten Zelle der Karte ab. </font><font style="vertical-align: inherit;">Daher w√§re es f√ºr uns in Zukunft schwieriger herauszufinden, mit welcher Version des Sicherungsformats wir es zu tun haben. </font><font style="vertical-align: inherit;">Jetzt k√∂nnen wir nur die ersten vier Bytes √ºberpr√ºfen. </font><font style="vertical-align: inherit;">Wenn sie leer sind, handelt es sich um eine Version des Formats 0. In zuk√ºnftigen Versionen wird es m√∂glich sein, dort etwas anderes hinzuzuf√ºgen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das hei√üt, wenn der Titel nicht Null ist, handelt es sich um eine unbekannte Version. </font><font style="vertical-align: inherit;">Da wir nicht herausfinden k√∂nnen, welche Daten vorhanden sind, m√ºssen wir das Herunterladen der Karte verweigern.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> header = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header == <span class="hljs-number"><span class="hljs-number">0</span></span>) { hexGrid.Load(reader); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Unknown map format "</span></span> + header); } }</code> </pre> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil 13: Kartenverwaltung </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir erstellen neue Karten im Spielmodus. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unterst√ºtzung f√ºr verschiedene Kartengr√∂√üen hinzuf√ºgen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> F√ºgen Sie den gespeicherten Daten die Gr√∂√üe der Karte hinzu. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Speichern und laden Sie beliebige Karten. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeigen Sie eine Liste der Karten an. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Teil werden wir Unterst√ºtzung f√ºr verschiedene Kartengr√∂√üen sowie das Speichern verschiedener Dateien hinzuf√ºgen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ab diesem Teil werden Tutorials in Unity 5.5.0 erstellt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/abd/9e2/1e4/abd9e21e467d0b291c33f4ad31e96c51.jpg"></div><br> <i><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Anfang</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der Kartenbibliothek.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Neue Karten erstellen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bis zu diesem Punkt haben wir das Sechseckraster nur einmal erstellt - beim Laden der Szene. </font><font style="vertical-align: inherit;">Jetzt k√∂nnen Sie jederzeit eine neue Karte erstellen. </font><font style="vertical-align: inherit;">Die neue Karte ersetzt einfach die aktuelle. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Awake </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden einige Metriken initialisiert, und dann wird die Anzahl der Zellen bestimmt und die erforderlichen Fragmente und Zellen erstellt. </font><font style="vertical-align: inherit;">Wenn wir einen neuen Satz von Fragmenten und Zellen erstellen, erstellen wir eine neue Karte. </font></font><code>HexGrid.Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teilen </font><font style="vertical-align: inherit;">wir uns </font><font style="vertical-align: inherit;">in zwei Teile auf - den Initialisierungsquellcode und die allgemeine Methode </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexMetrics.colors = colors; CreateMap(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { cellCountX = chunkCountX * HexMetrics.chunkSizeX; cellCountZ = chunkCountZ * HexMetrics.chunkSizeZ; CreateChunks(); CreateCells(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie der Benutzeroberfl√§che eine Schaltfl√§che hinzu, um eine neue Karte zu erstellen. </font><font style="vertical-align: inherit;">Ich habe es gro√ü gemacht und es unter die Schaltfl√§chen Speichern und Laden gelegt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/203/c02/ff4/203c02ff4ca668836064c72ad770328c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neue Kartenschaltfl√§che. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbinden wir das </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On Click-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ereignis </font><font style="vertical-align: inherit;">dieser Schaltfl√§che mit der Methode </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unseres Objekts </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Das hei√üt, wir werden nicht den </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Map Editor</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> durchlaufen </font><font style="vertical-align: inherit;">, sondern direkt die </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objektmethode aufrufen </font><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36a/d04/a3e/36ad04a3ebf94b00faf7aebe8c783b2f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie eine Karte, indem Sie auf klicken.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alte Daten l√∂schen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie nun auf die Schaltfl√§che </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neue Karte</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> klicken </font><font style="vertical-align: inherit;">, wird ein neuer Satz von Fragmenten und Zellen erstellt. </font><font style="vertical-align: inherit;">Die alten werden jedoch nicht automatisch gel√∂scht. </font><font style="vertical-align: inherit;">Als Ergebnis erhalten wir mehrere √ºbereinanderliegende Kartennetze. </font><font style="vertical-align: inherit;">Um dies zu vermeiden, m√ºssen wir zuerst alte Objekte entfernen. </font><font style="vertical-align: inherit;">Dies kann erreicht werden, indem zu Beginn alle aktuellen Fragmente zerst√∂rt werden </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (chunks != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunks.Length; i++) { Destroy(chunks[i].gameObject); } } ‚Ä¶ }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">K√∂nnen wir vorhandene Objekte wiederverwenden?</font></font></b> <div class="spoiler_text">  ,         .     ,       .  ,    ‚Äî    ,      . </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ist es m√∂glich, untergeordnete Elemente wie diese in einer Schleife zu zerst√∂ren?</font></font></b> <div class="spoiler_text">  Nat√ºrlich.         . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Geben Sie die Gr√∂√üe in Zellen anstelle von Fragmenten an </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W√§hrend wir die Gr√∂√üe der Karte durch die Felder </font></font><code>chunkCountX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und das </font></font><code>chunkCountZ</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objekt </font><font style="vertical-align: inherit;">einstellen </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es ist jedoch viel bequemer, die Gr√∂√üe der Karte in Zellen anzugeben. </font><font style="vertical-align: inherit;">Gleichzeitig k√∂nnen wir in Zukunft sogar die Gr√∂√üe des Fragments √§ndern, ohne die Gr√∂√üe der Karten zu √§ndern. </font><font style="vertical-align: inherit;">Lassen Sie uns daher die Rollen der Anzahl der Zellen und der Anzahl der Fragmentfelder vertauschen.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public int chunkCountX = 4, chunkCountZ = 3; public int cellCountX = 20, cellCountZ = 15; ‚Ä¶ // int cellCountX, cellCountZ; int chunkCountX, chunkCountZ; ‚Ä¶ public void CreateMap () { ‚Ä¶ // cellCountX = chunkCountX * HexMetrics.chunkSizeX; // cellCountZ = chunkCountZ * HexMetrics.chunkSizeZ; chunkCountX = cellCountX / HexMetrics.chunkSizeX; chunkCountZ = cellCountZ / HexMetrics.chunkSizeZ; CreateChunks(); CreateCells(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies f√ºhrt zu einem Kompilierungsfehler, da </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragmentgr√∂√üen verwendet werden </font><font style="vertical-align: inherit;">, um die Position zu begrenzen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">√Ñndern Sie dies </font></font><code>HexMapCamera.ClampPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so, dass er direkt die Anzahl der Zellen verwendet, die er noch ben√∂tigt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = (grid.cellCountX - <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * (<span class="hljs-number"><span class="hljs-number">2f</span></span> * HexMetrics.innerRadius); position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zMax = (grid.cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (<span class="hljs-number"><span class="hljs-number">1.5f</span></span> * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zMax); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Fragment hat eine Gr√∂√üe von 5 x 5 Zellen, und Karten haben standardm√§√üig eine Gr√∂√üe von 4 x 3 Fragmenten. </font><font style="vertical-align: inherit;">Um die Karten gleich zu halten, m√ºssen wir daher eine Gr√∂√üe von 20 x 15 Zellen verwenden. </font><font style="vertical-align: inherit;">Und obwohl wir im Code Standardwerte zugewiesen haben, werden diese vom Rasterobjekt immer noch nicht automatisch verwendet, da die Felder bereits vorhanden und standardm√§√üig auf 0 gesetzt waren.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/399/2e3/da6/3992e3da66fb278c396e15a3d339707a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standardm√§√üig hat die Karte eine Gr√∂√üe von 20 x 15.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Benutzerdefinierte Kartengr√∂√üen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der n√§chste Schritt ist die Unterst√ºtzung f√ºr das Erstellen von Karten jeder Gr√∂√üe, nicht nur der Standardgr√∂√üe. </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie </font><font style="vertical-align: inherit;">dazu den </font><font style="vertical-align: inherit;">Parametern X und Z hinzu. Sie ersetzen die vorhandene Anzahl von Zellen. </font><font style="vertical-align: inherit;">Im Inneren werden </font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir sie nur mit der aktuellen Anzahl von Zellen aufrufen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexMetrics.colors = colors; CreateMap(cellCountX, cellCountZ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ cellCountX = x; cellCountZ = z; chunkCountX = cellCountX / HexMetrics.chunkSizeX; chunkCountZ = cellCountZ / HexMetrics.chunkSizeZ; CreateChunks(); CreateCells(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies funktioniert jedoch nur mit der Anzahl der Zellen, die ein Vielfaches der Fragmentgr√∂√üe betr√§gt, korrekt. </font><font style="vertical-align: inherit;">Andernfalls werden durch die Ganzzahldivision zu wenige Fragmente erstellt. </font><font style="vertical-align: inherit;">Obwohl wir Unterst√ºtzung f√ºr Fragmente hinzuf√ºgen k√∂nnen, die teilweise mit Zellen gef√ºllt sind, verbieten wir einfach die Verwendung von Gr√∂√üen, die nicht Fragmenten entsprechen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen den Operator verwenden </font></font><code>%</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um den Rest der Division der Anzahl der Zellen durch die Anzahl der Fragmente zu berechnen. </font><font style="vertical-align: inherit;">Wenn es nicht gleich Null ist, gibt es eine Diskrepanz und wir werden keine neue Karte erstellen. </font><font style="vertical-align: inherit;">Und w√§hrend wir dies tun, f√ºgen wir Schutz vor Null und negativen Gr√∂√üen hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( x &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || x % HexMetrics.chunkSizeX != <span class="hljs-number"><span class="hljs-number">0</span></span> || z &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || z % HexMetrics.chunkSizeZ != <span class="hljs-number"><span class="hljs-number">0</span></span> ) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"Unsupported map size."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Neues Kartenmen√º </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der aktuellen Phase </font><font style="vertical-align: inherit;">funktioniert die </font><font style="vertical-align: inherit;">Schaltfl√§che </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neue Karte</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht mehr, da die Methode </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jetzt zwei Parameter hat. Wir k√∂nnen Unity-Ereignisse nicht direkt mit solchen Methoden verbinden. Um verschiedene Kartengr√∂√üen zu unterst√ºtzen, ben√∂tigen wir au√üerdem einige Schaltfl√§chen. Anstatt alle diese Schaltfl√§chen zur Hauptbenutzeroberfl√§che hinzuzuf√ºgen, erstellen wir ein separates Popup-Men√º. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie der Szene eine neue Leinwand hinzu ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameObject / UI / Canvas</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Wir werden die gleichen Einstellungen wie die vorhandene Zeichenfl√§che verwenden, au√üer dass die </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sortierreihenfolge</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gleich 1 sein sollte. Dank dieser </font><em><font style="vertical-align: inherit;">Option</font></em><font style="vertical-align: inherit;"> befindet sie sich √ºber der Benutzeroberfl√§che des Haupteditors. Ich habe sowohl die Zeichenfl√§che als auch das Ereignissystem zu einem untergeordneten Element des neuen UI-Objekts gemacht, damit die Szenenhierarchie sauber bleibt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c91/6c5/c2c/c916c5c2cee3f58576b12ac1a052bd64.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3be/a8b/79b/3bea8b79bae11a493aea43590394b0a3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Canvas-Men√º Neue Karte. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie dem </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Men√º "Neue Karte"</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ein </font><font style="vertical-align: inherit;">Bedienfeld hinzu </font><font style="vertical-align: inherit;">, das </font><font style="vertical-align: inherit;">den gesamten Bildschirm schlie√üt. </font><font style="vertical-align: inherit;">Es ist erforderlich, um den Hintergrund abzudunkeln und dem Cursor nicht zu erlauben, mit allem anderen zu interagieren, wenn das Men√º ge√∂ffnet ist. </font><font style="vertical-align: inherit;">Ich gab ihm eine einheitliche Farbe, l√∂schte sein </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quellbild</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font><font style="vertical-align: inherit;">stellte (0, 0, 0, 200) </font><font style="vertical-align: inherit;">als </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Farbe ein</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16c/1f0/a4f/16c1f0a4f31e0769099b845794a83b4a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hintergrundbildeinstellungen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie in der Mitte der Leinwand eine Men√ºleiste hinzu, √§hnlich wie in den </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Map Editor-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bedienfeldern </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Lassen Sie uns ein klares Etikett und Schaltfl√§chen f√ºr ihre kleinen, mittleren und gro√üen Karten erstellen. </font><font style="vertical-align: inherit;">Wir werden ihr auch eine Schaltfl√§che zum Abbrechen hinzuf√ºgen, falls der Spieler seine Meinung √§ndert. </font><font style="vertical-align: inherit;">Deaktivieren Sie nach Abschluss der Erstellung des Designs das gesamte </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Men√º "Neue Karte"</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0a/0d9/584/c0a0d95847337d91b97a823312c98a43.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/917/3a1/7c3/9173a17c38f4c6e35f258c407b44d710.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neues Kartenmen√º. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um das Men√º zu verwalten, erstellen Sie eine Komponente </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und f√ºgen Sie sie dem Canvas </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New Map Menu-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objekt hinzu </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Um eine neue Karte zu erstellen, ben√∂tigen wir Zugriff auf das </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objekt </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Daher f√ºgen wir ein gemeinsames Feld hinzu und verbinden es.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">NewMapMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid hexGrid; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7d/a25/c3e/f7da25c3ed3ebf12ba9f4785b19ec8e1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komponente des neuen Kartenmen√ºs.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √ñffnen und Schlie√üen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen das Popup-Men√º √∂ffnen und schlie√üen, indem wir einfach das Canvas-Objekt aktivieren und deaktivieren. </font><font style="vertical-align: inherit;">F√ºgen wir dazu </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zwei g√§ngige Methoden hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Close</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbinden Sie nun die Schaltfl√§che </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New Map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UI </font><font style="vertical-align: inherit;">des </font><font style="vertical-align: inherit;">Editors mit der Methode </font></font><code>Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New Map Menu-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objekt </font><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b84/100/590/b841005902c164f5eb1dcab4f39c4221.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√ñffnen Sie das Men√º durch Dr√ºcken von. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbinden Sie auch die Schaltfl√§che </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbrechen</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit der Methode </font></font><code>Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dadurch k√∂nnen wir das Popup-Men√º √∂ffnen und schlie√üen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Neue Karten erstellen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um neue Karten zu erstellen, m√ºssen wir die </font><font style="vertical-align: inherit;">Methode </font><font style="vertical-align: inherit;">im </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objekt aufrufen </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Au√üerdem m√ºssen wir danach das Popup-Men√º schlie√üen. </font><font style="vertical-align: inherit;">F√ºgen Sie der </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode, die dies behandelt, unter Ber√ºcksichtigung einer beliebigen Gr√∂√üe hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { hexGrid.CreateMap(x, z); Close(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Methode sollte nicht allgemein sein, da wir sie immer noch nicht direkt mit Schaltfl√§chenereignissen verbinden k√∂nnen. </font><font style="vertical-align: inherit;">Erstellen Sie stattdessen eine Methode pro Schaltfl√§che, die </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit der angegebenen Gr√∂√üe </font><font style="vertical-align: inherit;">aufgerufen wird </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">F√ºr eine kleine Karte habe ich eine Gr√∂√üe von 20 x 15 verwendet, die der Standardgr√∂√üe der Karte entspricht. </font><font style="vertical-align: inherit;">F√ºr die mittlere Karte habe ich beschlossen, diese Gr√∂√üe zu verdoppeln, 40 mal 30 zu erhalten und sie f√ºr die gro√üe Karte erneut zu verdoppeln. </font><font style="vertical-align: inherit;">Verbinden Sie die Tasten mit den entsprechenden Methoden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateSmallMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CreateMap(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMediumMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CreateMap(<span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLargeMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CreateMap(<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kamerasperre </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir das Popup-Men√º verwenden, um neue Karten mit drei verschiedenen Gr√∂√üen zu erstellen! Alles funktioniert gut, aber wir m√ºssen uns um ein kleines Detail k√ºmmern. Wenn das </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Men√º "Neue Karte"</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aktiv ist, k√∂nnen wir nicht mehr mit der Benutzeroberfl√§che des Editors interagieren und Zellen bearbeiten. Wir k√∂nnen die Kamera jedoch weiterhin steuern. Idealerweise sollte die Kamera bei ge√∂ffnetem Men√º gesperrt sein. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir nur eine Kamera haben, besteht eine schnelle und pragmatische L√∂sung darin, einfach eine statische Eigenschaft hinzuzuf√ºgen </font></font><code>Locked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. F√ºr den weit verbreiteten Einsatz ist diese L√∂sung nicht sehr geeignet, aber f√ºr unsere einfache Benutzeroberfl√§che reicht sie aus. Dies erfordert, dass wir die statische Instanz im Inneren verfolgen </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die bei der Awake-Kamera eingestellt wird.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> HexMapCamera instance; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { instance = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; swivel = transform.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>); stick = swivel.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Eigenschaft </font></font><code>Locked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann nur mit einem Setter eine einfache statische boolesche Eigenschaft sein. </font><font style="vertical-align: inherit;">Alles, was es tut, ist, die Instanz auszuschalten, </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn sie gesperrt ist, und sie einzuschalten, wenn sie entsperrt ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Locked { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { instance.enabled = !<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt </font></font><code>NewMapMenu.Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann es die Kamera blockieren und </font></font><code>NewMapMenu.Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- entsperren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Close</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beibehaltung der richtigen Kameraposition </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt ein weiteres wahrscheinliches Problem mit der Kamera. </font><font style="vertical-align: inherit;">Wenn Sie eine neue Karte erstellen, die kleiner als die aktuelle ist, wird die Kamera m√∂glicherweise au√üerhalb der Kartenr√§nder angezeigt. </font><font style="vertical-align: inherit;">Sie bleibt dort, bis der Spieler versucht, die Kamera zu bewegen. </font><font style="vertical-align: inherit;">Und nur dann wird es durch die Grenzen der neuen Karte begrenzt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um dieses Problem zu l√∂sen, k√∂nnen wir die </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">statische Methode </font><font style="vertical-align: inherit;">erg√§nzen </font></font><code>ValidatePosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wenn Sie eine </font></font><code>AdjustPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instanzmethode mit einem Versatz von Null aufrufen, wird die Kamera gezwungen, sich an die R√§nder der Karte zu bewegen. </font><font style="vertical-align: inherit;">Befindet sich die Kamera bereits innerhalb der Grenzen der neuen Karte, bleibt sie an Ort und Stelle.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidatePosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { instance.AdjustPosition(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rufen Sie die darin enthaltene Methode auf, </font></font><code>NewMapMenu.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nachdem Sie eine neue Karte erstellt haben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { hexGrid.CreateMap(x, z); HexMapCamera.ValidatePosition(); Close(); }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kartengr√∂√üe speichern </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl wir Karten unterschiedlicher Gr√∂√üe erstellen k√∂nnen, wird dies beim Speichern und Laden nicht ber√ºcksichtigt. </font><font style="vertical-align: inherit;">Dies bedeutet, dass das Laden einer Karte zu einem Fehler oder einer falschen Karte f√ºhrt, wenn die Gr√∂√üe der aktuellen Karte nicht mit der Gr√∂√üe der geladenen Karte √ºbereinstimmt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um dieses Problem zu l√∂sen, m√ºssen wir vor dem Laden der Zellendaten eine neue Karte mit der entsprechenden Gr√∂√üe erstellen. </font><font style="vertical-align: inherit;">Nehmen wir an, wir haben eine kleine Karte gespeichert. </font><font style="vertical-align: inherit;">In diesem Fall ist alles in Ordnung, wenn wir zu Beginn </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine 20 x 15-Karte </font><font style="vertical-align: inherit;">erstellen </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { CreateMap(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Load(reader); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunks.Length; i++) { chunks[i].Refresh(); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Speicher in Kartengr√∂√üe </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nat√ºrlich k√∂nnen wir eine Karte jeder Gr√∂√üe aufbewahren. </font><font style="vertical-align: inherit;">Daher besteht eine verallgemeinerte L√∂sung darin, die Gr√∂√üe der Karte vor diesen Zellen zu speichern.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(cellCountX); writer.Write(cellCountZ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Save(writer); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dann k√∂nnen wir die wahre Gr√∂√üe ermitteln und daraus eine Karte mit den richtigen Gr√∂√üen erstellen. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { CreateMap(reader.ReadInt32(), reader.ReadInt32()); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir jetzt Karten unterschiedlicher Gr√∂√üe laden k√∂nnen, stehen wir erneut vor dem Problem der Kameraposition. </font><font style="vertical-align: inherit;">Wir werden es l√∂sen, indem wir seine Position </font></font><code>HexMapEditor.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nach dem Laden der Karte </font><font style="vertical-align: inherit;">einchecken </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> header = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header == <span class="hljs-number"><span class="hljs-number">0</span></span>) { hexGrid.Load(reader, header); HexMapCamera.ValidatePosition(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Unknown map format "</span></span> + header); } } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Neues Dateiformat </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl dieser Ansatz mit Karten funktioniert, die wir in Zukunft behalten werden, funktioniert er nicht mit alten. </font><font style="vertical-align: inherit;">Und umgekehrt - der Code aus dem vorherigen Teil des Tutorials kann neue Kartendateien nicht korrekt laden. </font><font style="vertical-align: inherit;">Um zwischen alten und neuen Formaten zu unterscheiden, erh√∂hen wir den ganzzahligen Wert des Headers. </font><font style="vertical-align: inherit;">Das alte Speicherformat ohne Kartengr√∂√üe hatte Version 0. Das neue Format mit Kartengr√∂√üe hat Version 1. Daher sollte bei der Aufnahme </font></font><code>HexMapEditor.Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 anstelle von 0 geschrieben werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(<span class="hljs-number"><span class="hljs-number">1</span></span>); hexGrid.Save(writer); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Von nun an werden die Karten als Version 1 gespeichert. Wenn wir versuchen, sie in der Assembly aus dem vorherigen Lernprogramm zu √∂ffnen, lehnen sie es ab, ein unbekanntes Kartenformat zu laden und zu melden. </font><font style="vertical-align: inherit;">In der Tat wird dies passieren, wenn wir bereits versuchen, eine solche Karte zu laden. </font><font style="vertical-align: inherit;">Sie m√ºssen die Methode </font></font><code>HexMapEditor.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so </font><font style="vertical-align: inherit;">√§ndern </font><font style="vertical-align: inherit;">, dass sie die neue Version akzeptiert.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> header = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header == <span class="hljs-number"><span class="hljs-number">1</span></span>) { hexGrid.Load(reader); HexMapCamera.ValidatePosition(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Unknown map format "</span></span> + header); } } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Abw√§rtskompatibilit√§t </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir m√∂chten, k√∂nnen wir weiterhin Karten der Version 0 herunterladen, vorausgesetzt, sie haben alle die gleiche Gr√∂√üe von 20 x 15. Das hei√üt, der Titel muss nicht 1 sein, sondern kann auch Null sein. </font><font style="vertical-align: inherit;">Da jede Version ihren eigenen Ansatz erfordert, </font></font><code>HexMapEditor.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muss der Header an die Methode √ºbergeben werden </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { hexGrid.Load(reader, header); HexMapCamera.ValidatePosition(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie dem </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameter </font><font style="vertical-align: inherit;">einen </font><font style="vertical-align: inherit;">Titel hinzu und treffen Sie damit Entscheidungen √ºber weitere Aktionen. </font><font style="vertical-align: inherit;">Wenn der Header nicht kleiner als 1 ist, m√ºssen Sie die Daten zur Kartengr√∂√üe lesen. </font><font style="vertical-align: inherit;">Andernfalls verwenden wir die alte feste Kartengr√∂√üe von 20 x 15 und √ºberspringen das Lesen der Gr√∂√üendaten.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">20</span></span>, z = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { x = reader.ReadInt32(); z = reader.ReadInt32(); } CreateMap(x, z); ‚Ä¶ }</code> </pre> <br> <a href="" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kartendatei Version 0</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kartengr√∂√üenpr√ºfung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie beim Erstellen einer neuen Karte ist es theoretisch m√∂glich, dass wir eine Karte laden m√ºssen, die mit der Fragmentgr√∂√üe nicht kompatibel ist. </font><font style="vertical-align: inherit;">In diesem Fall m√ºssen wir den Download der Karte unterbrechen. </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">weigert sich bereits, eine Karte zu erstellen und zeigt einen Fehler in der Konsole an. </font><font style="vertical-align: inherit;">Um dies dem Aufrufer der Methode mitzuteilen, geben wir einen Bool zur√ºck, der angibt, ob die Map erstellt wurde.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( x &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || x % HexMetrics.chunkSizeX != <span class="hljs-number"><span class="hljs-number">0</span></span> || z &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || z % HexMetrics.chunkSizeZ != <span class="hljs-number"><span class="hljs-number">0</span></span> ) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"Unsupported map size."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann die Ausf√ºhrung auch gestoppt werden, wenn die Kartenerstellung fehlschl√§gt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">20</span></span>, z = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { x = reader.ReadInt32(); z = reader.ReadInt32(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateMap(x, z)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da beim Laden alle Daten in vorhandenen Zellen √ºberschrieben werden, m√ºssen wir keine neue Karte erstellen, wenn eine Karte derselben Gr√∂√üe geladen wird. </font><font style="vertical-align: inherit;">Daher kann dieser Schritt √ºbersprungen werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x != cellCountX || z != cellCountZ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateMap(x, z)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dateiverwaltung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen Karten unterschiedlicher Gr√∂√üe speichern und laden, aber immer </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">test.map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> schreiben und lesen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jetzt werden wir Unterst√ºtzung f√ºr verschiedene Dateien hinzuf√ºgen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anstatt die Karte direkt zu speichern oder zu laden, verwenden wir ein anderes Popup-Men√º, das eine erweiterte Dateiverwaltung bietet. </font><font style="vertical-align: inherit;">Erstellen Sie eine weitere Zeichenfl√§che, wie im </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Men√º "Neue Karte"</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , aber dieses Mal nennen wir sie " </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Men√º" Laden laden "</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In diesem Men√º werden Karten gespeichert und geladen, je nachdem, welche Taste zum √ñffnen gedr√ºckt wurde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden das Design zum </font><em><font style="vertical-align: inherit;">Speichern des Lademen√ºs</font></em><font style="vertical-align: inherit;"> erstellen.</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">als w√§re es ein Speichermen√º. Sp√§ter werden wir es dynamisch in ein Boot-Men√º verwandeln. Wie ein anderes Men√º sollte es einen Hintergrund und eine Men√ºleiste, eine Men√ºbezeichnung und eine Abbrechen-Schaltfl√§che haben. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dann dem Men√º eine </font><em><font style="vertical-align: inherit;">Bildlaufansicht</font></em><font style="vertical-align: inherit;"> ( </font><em><font style="vertical-align: inherit;">GameObject / UI / Bildlaufansicht</font></em><font style="vertical-align: inherit;"> ) hinzu, um eine Liste der Dateien anzuzeigen. Unten f√ºgen wir das Eingabefeld ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameObject / UI / Eingabefeld</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) ein, um die Namen der neuen Karten anzugeben. Wir brauchen auch eine Aktionsschaltfl√§che, um die Karte zu speichern. Und endlich. F√ºgen Sie eine Schaltfl√§che </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L√∂schen hinzu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um unn√∂tige Karten zu l√∂schen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c73/279/198/c732791989e1eb6fa53e73ec3435bc74.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/176/485/3da/1764853da66092443c0327638dc1803a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Design Save Load-Men√º.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Standardm√§√üig erlaubt die Bildlaufansicht sowohl horizontales als auch vertikales Scrollen, wir ben√∂tigen jedoch nur eine Liste mit vertikalem Bildlauf. Daher deaktivieren Scrollen </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">horizontal</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und ziehen Sie </font><font style="vertical-align: inherit;">die horizontale Bildlaufleiste. Wir setzen au√üerdem den </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bewegungstyp</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf "Klemmen" und deaktivieren die </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tr√§gheit</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , damit die Liste restriktiver erscheint.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43f/3a9/e36/43f3a9e36202f436772f54eedcd96c76.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dateilistenoptionen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entfernen Sie </font><font style="vertical-align: inherit;">das Kind Element </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scrollbar Horizontal</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von dem Objekt von </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Datei einer Liste</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , weil es nicht ben√∂tigt werden. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ñndern Sie</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dann die Gr√∂√üe der </font><em><font style="vertical-align: inherit;">Bildlaufleiste vertikal,</font></em><font style="vertical-align: inherit;"> sodass sie </font><em><font style="vertical-align: inherit;">am</font></em><font style="vertical-align: inherit;"> Ende der Liste </font><em><font style="vertical-align: inherit;">ankommt</font></em><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Platzhalter Textobjekt </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Name Eingabe</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kann in seine Kinder ge√§ndert werden </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Platzhalter</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ich habe beschreibenden Text verwendet, aber Sie k√∂nnen ihn einfach leer lassen und den Platzhalter entfernen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed5/7d5/d17/ed57d5d17dfb0695fc4b2f5f3f9dc8a5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Men√ºgestaltung ge√§ndert. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir sind mit dem Design fertig und deaktivieren jetzt das Men√º, sodass es standardm√§√üig ausgeblendet ist.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Men√ºverwaltung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit das Men√º funktioniert, ben√∂tigen wir in diesem Fall ein anderes Skript - </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wie </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es erfordert einen Verweis auf das Gitter, sowie Methoden </font></font><code>Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid hexGrid; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Close</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie diese Komponente zu </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SaveLoadMenu hinzu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und verkn√ºpfen Sie sie mit dem </font><em><font style="vertical-align: inherit;">Rasterobjekt</font></em><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/974/86f/440/97486f440f44d4db9c744cfa9b6acec0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komponente SaveLoadMenu. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Men√º zum Speichern oder Laden wird ge√∂ffnet. </font><font style="vertical-align: inherit;">F√ºgen Sie der Methode einen </font></font><code>Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">booleschen Parameter hinzu </font><font style="vertical-align: inherit;">, um die Arbeit zu vereinfachen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es bestimmt, ob sich das Men√º im Speichermodus befinden soll. </font><font style="vertical-align: inherit;">Wir werden diesen Modus vor Ort verfolgen, um zu wissen, welche Aktion sp√§ter ausgef√ºhrt werden soll.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> saveMode; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> saveMode</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.saveMode = saveMode; gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verbinden Sie </font><font style="vertical-align: inherit;">nun die Tasten </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">speichern</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">laden</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objekt </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Map Editor</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit der Methode </font></font><code>Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des Objekts </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speichern Sie </font><font style="vertical-align: inherit;">das Men√º laden</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">√úberpr√ºfen Sie den booleschen Parameter nur f√ºr die Schaltfl√§che </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speichern</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38c/59c/44f/38c59c44fa001e97128532d7c7d92168.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√ñffnen des Men√ºs im Speichermodus. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie dies noch nicht getan haben, verbinden Sie das Ereignis </font><font style="vertical-align: inherit;">der </font><font style="vertical-align: inherit;">Schaltfl√§che </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbrechen</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit der Methode </font></font><code>Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jetzt </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speicher Laden Men√º</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kann ge√∂ffnet und geschlossen werden.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ver√§nderung des Aussehens </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben das Men√º als Speichermen√º erstellt, aber sein Modus wird durch die zum √ñffnen gedr√ºckte Taste bestimmt. </font><font style="vertical-align: inherit;">Wir m√ºssen das Erscheinungsbild des Men√ºs je nach Modus √§ndern. </font><font style="vertical-align: inherit;">Insbesondere m√ºssen wir die Men√ºbezeichnung und die Bezeichnung der Aktionsschaltfl√§che √§ndern. </font><font style="vertical-align: inherit;">Dies bedeutet, dass wir Links zu diesen Tags ben√∂tigen.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Text menuLabel, actionButtonLabel; ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7c/4d3/b8d/e7c4d3b8d55ce8c333d38be996a3ebc1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbindung mit Tags. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn das Men√º im Speichermodus ge√∂ffnet wird, verwenden wir die vorhandenen Beschriftungen, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dh Karte</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> f√ºr das Men√º </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">speichern</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font><em><font style="vertical-align: inherit;">Speichern</font></em><font style="vertical-align: inherit;"> f√ºr die Aktionsschaltfl√§che. </font><font style="vertical-align: inherit;">Andernfalls befinden wir uns im Lademodus, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dh</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir verwenden </font><em><font style="vertical-align: inherit;">Load Map</font></em><font style="vertical-align: inherit;"> und </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Load</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> saveMode</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.saveMode = saveMode; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (saveMode) { menuLabel.text = <span class="hljs-string"><span class="hljs-string">"Save Map"</span></span>; actionButtonLabel.text = <span class="hljs-string"><span class="hljs-string">"Save"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { menuLabel.text = <span class="hljs-string"><span class="hljs-string">"Load Map"</span></span>; actionButtonLabel.text = <span class="hljs-string"><span class="hljs-string">"Load"</span></span>; } gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kartennamen eingeben </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen wir die Liste der Dateien f√ºr jetzt. </font><font style="vertical-align: inherit;">Der Benutzer kann die gespeicherte oder heruntergeladene Datei angeben, indem er den Namen der Karte in das Eingabefeld eingibt. </font><font style="vertical-align: inherit;">Um diese Daten zu erhalten, ben√∂tigen wir einen Verweis auf die Komponente </font></font><code>InputField</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Name Input-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objekts </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> InputField nameInput;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e49/8e0/021/e498e002162a42103571cfac7cf91221.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbindung zum Eingabefeld. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Benutzer muss nicht gezwungen werden, den vollst√§ndigen Pfad zur Kartendatei einzugeben. </font><font style="vertical-align: inherit;">Es reicht nur der Name der Karte ohne die Erweiterung </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">F√ºgen wir eine Methode hinzu, die Benutzereingaben verwendet und den richtigen Pfad daf√ºr erstellt. </font><font style="vertical-align: inherit;">Dies ist nicht m√∂glich, wenn die Eingabe leer ist. In diesem Fall kehren wir zur√ºck </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSelectedPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> mapName = nameInput.text; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mapName.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Path.Combine(Application.persistentDataPath, mapName + <span class="hljs-string"><span class="hljs-string">".map"</span></span>); } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was passiert, wenn der Benutzer ung√ºltige Zeichen eingibt?</font></font></b> <div class="spoiler_text">        ,       .  ,      ,         . <br><br>         <em>Content Type</em>  . ,       - ,     .      ,    ,    . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Speichern und laden </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt wird es mit dem Speichern und Laden besch√§ftigt </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Deshalb haben wir die Methoden bewegen </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sie m√ºssen nicht mehr gemeinsam genutzt werden und arbeiten mit dem Pfadparameter anstelle des festen Pfads.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// string path = Path.Combine(Application.persistentDataPath, "test.map"); using ( BinaryWriter writer = new BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(1); hexGrid.Save(writer); } } void Load (string path) { // string path = Path.Combine(Application.persistentDataPath, "test.map"); using (BinaryReader reader = new BinaryReader(File.OpenRead(path))) { int header = reader.ReadInt32(); if (header &lt;= 1) { hexGrid.Load(reader, header); HexMapCamera.ValidatePosition(); } else { Debug.LogWarning("Unknown map format " + header); } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir jetzt beliebige Dateien hochladen, w√§re es sch√∂n zu √ºberpr√ºfen, ob die Datei tats√§chlich vorhanden ist, und erst dann zu versuchen, sie zu lesen. </font><font style="vertical-align: inherit;">Ist dies nicht der Fall, geben wir einen Fehler aus und beenden den Vorgang.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!File.Exists(path)) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"File does not exist "</span></span> + path); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie nun die allgemeine Methode hinzu </font></font><code>Action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es beginnt damit, den vom Benutzer ausgew√§hlten Pfad abzurufen. </font><font style="vertical-align: inherit;">Wenn es einen Pfad gibt, speichern oder laden Sie ihn. </font><font style="vertical-align: inherit;">Schlie√üen Sie dann das Men√º.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Action</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = GetSelectedPath(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (saveMode) { Save(path); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Load(path); } Close(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durch Anh√§ngen eines </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktionsschaltfl√§chenereignisses</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> an diese Methode </font><font style="vertical-align: inherit;">k√∂nnen wir mit beliebigen Kartennamen speichern und laden. </font><font style="vertical-align: inherit;">Da wir das Eingabefeld nicht zur√ºcksetzen, bleibt der ausgew√§hlte Name bis zum n√§chsten Speichern oder Laden erhalten. </font><font style="vertical-align: inherit;">Dies ist praktisch, um eine Datei mehrmals hintereinander zu speichern oder zu laden, sodass wir nichts √§ndern.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kartenlistenelemente </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als n√§chstes f√ºllen wir die Dateiliste mit allen Karten aus, die sich im Datenspeicherpfad befinden. </font><font style="vertical-align: inherit;">Wenn Sie auf eines der Elemente in der Liste klicken, wird es als Text in der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namenseingabe verwendet</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">F√ºgen Sie dazu eine </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allgemeine Methode hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelectItem</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { nameInput.text = name; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir brauchen etwas, das ein Listenelement ist. </font><font style="vertical-align: inherit;">Die √ºbliche Taste reicht aus. </font><font style="vertical-align: inherit;">Erstellen Sie es und reduzieren Sie die H√∂he auf 20 Einheiten, damit es vertikal nicht viel Platz einnimmt. </font><font style="vertical-align: inherit;">Es sollte nicht wie eine Schaltfl√§che aussehen, daher wird der Link " </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quellbild"</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bildkomponente</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gel√∂scht </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In diesem Fall wird es vollst√§ndig wei√ü. </font><font style="vertical-align: inherit;">Au√üerdem stellen wir sicher, dass die Beschriftung nach links ausgerichtet ist und zwischen dem Text und der linken Seite der Schaltfl√§che Platz ist. </font><font style="vertical-align: inherit;">Nachdem wir mit dem Design des Knopfes fertig sind, verwandeln wir ihn in ein Fertighaus.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/501/0f0/6e5/5010f06e5b380440bca024ffb8c0e307.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/67b/60b/21f/67b60b21f34e4ae69846c35ed5583fae.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Schaltfl√§che ist ein Listenelement. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen das Schaltfl√§chenereignis nicht direkt mit dem </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Men√º "Neue Karte" verbinden</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , da es sich um ein Fertighaus handelt und es in der Szene noch nicht vorhanden ist. </font><font style="vertical-align: inherit;">Daher ben√∂tigt ein Men√ºelement einen Link zum Men√º, damit es beim Klicken eine Methode aufrufen kann </font></font><code>SelectItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Er muss auch den Namen der Karte, die er repr√§sentiert, im Auge behalten und seinen Text festlegen. </font><font style="vertical-align: inherit;">Erstellen wir hierf√ºr eine kleine Komponente </font></font><code>SaveLoadItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadItem</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SaveLoadMenu menu; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> MapName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mapName; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { mapName = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; transform.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>).GetComponent&lt;Text&gt;().text = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> mapName; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Select</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { menu.SelectItem(mapName); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie dem Men√ºelement eine Komponente hinzu und lassen Sie die Schaltfl√§che ihre Methode aufrufen </font></font><code>Select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/249/172/7a0/2491727a0c07b0b92e89db0e3c02fe67.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikelkomponente.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Listenf√ºllung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Liste zu </font><font style="vertical-align: inherit;">f√ºllen, </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√ºssen Sie einen Verweis auf den </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inhalt</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> innerhalb des </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ansichtsfenster</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Objekt </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Datei eine Liste</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Er ben√∂tigt auch einen Link zum Artikel Fertighaus.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RectTransform listContent; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SaveLoadItem itemPrefab;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b6/22a/0eb/4b622a0eb5cf47422ce591dcd5c120e8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mischen Sie den Inhalt einer Liste und eines Fertighauses. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir verwenden eine neue Methode, um diese Liste zu f√ºllen. </font><font style="vertical-align: inherit;">Der erste Schritt besteht darin, vorhandene Kartendateien zu identifizieren. </font><font style="vertical-align: inherit;">Um ein Array aller Dateipfade innerhalb des Verzeichnisses zu erhalten, k√∂nnen wir die Methode verwenden </font></font><code>Directory.GetFiles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Diese Methode verf√ºgt √ºber einen zweiten Parameter, mit dem Sie Dateien filtern k√∂nnen. </font><font style="vertical-align: inherit;">In unserem Fall sind nur Dateien erforderlich, die mit der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* .map-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maske √ºbereinstimmen </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FillList</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] paths = Directory.GetFiles(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"*.map"</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leider ist die Reihenfolge der Dateien nicht garantiert. </font><font style="vertical-align: inherit;">Um sie in alphabetischer Reihenfolge anzuzeigen, m√ºssen wir das Array mit sortieren </font></font><code>System.Array.Sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FillList</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] paths = Directory.GetFiles(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"*.map"</span></span>); Array.Sort(paths); } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als N√§chstes erstellen wir vorgefertigte Instanzen f√ºr jedes Element des Arrays. </font><font style="vertical-align: inherit;">Binden Sie das Element an das Men√º, legen Sie seinen Kartennamen fest und machen Sie es zu einem untergeordneten Element des Listeninhalts.</font></font><br><br><pre> <code class="cs hljs"> Array.Sort(paths); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; paths.Length; i++) { SaveLoadItem item = Instantiate(itemPrefab); item.menu = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; item.MapName = paths[i]; item.transform.SetParent(listContent, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da </font></font><code>Directory.GetFiles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die vollst√§ndigen Pfade zu Dateien zur√ºckgegeben werden, m√ºssen diese gel√∂scht werden. </font><font style="vertical-align: inherit;">Gl√ºcklicherweise ist dies genau das, was die bequeme Methode ausmacht </font></font><code>Path.GetFileNameWithoutExtension</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> item.MapName = Path.GetFileNameWithoutExtension(paths[i]);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevor wir das Men√º anzeigen, m√ºssen wir eine Liste ausf√ºllen. </font><font style="vertical-align: inherit;">Und da sich die Dateien wahrscheinlich √§ndern, m√ºssen wir dies jedes Mal tun, wenn wir das Men√º √∂ffnen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> saveMode</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ FillList(); gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beim erneuten Ausf√ºllen der Liste m√ºssen alle alten gel√∂scht werden, bevor neue Elemente hinzugef√ºgt werden. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FillList</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; listContent.childCount; i++) { Destroy(listContent.GetChild(i).gameObject); } ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c83/4ff/fc3/c834fffc34b03b0d39de0056796fa199.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel ohne Vereinbarung.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anordnung der Punkte </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt werden in der Liste Elemente angezeigt, die sich jedoch √ºberlappen und sich in einer schlechten Position befinden. Damit sie eine vertikale Liste werden, f√ºgen Sie die Objekt </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inhalt</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Listenkomponente </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des Vertical Group ist </font><font style="vertical-align: inherit;">das Layout</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Komponente / das Layout / die Vertical Group ist das Layout</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktivieren Sie die </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Breite</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untergeordneten Steuerelementgr√∂√üe</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untergeordneten Force-Erweiterung</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , damit die Anordnung ordnungsgem√§√ü funktioniert </font><font style="vertical-align: inherit;">. Beide </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H√∂henoptionen</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sollten deaktiviert sein.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/392/32e/aac/39232eaac1c1741718d8993aae992bb4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7dd/aba/ce4/7ddabace4df7d61a274544889de9a3c2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vertikale Layoutgruppe verwenden. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben eine sch√∂ne Liste von Artikeln. </font><font style="vertical-align: inherit;">Die Gr√∂√üe des Inhalts der Liste passt sich jedoch nicht der tats√§chlichen Anzahl der Elemente an. </font><font style="vertical-align: inherit;">Daher √§ndert die Bildlaufleiste niemals die Gr√∂√üe. </font><font style="vertical-align: inherit;">Wir k√∂nnen </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> automatische Gr√∂√üen√§nderung von </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inhalten</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erzwingen </font><em><font style="vertical-align: inherit;">,</font></em><font style="vertical-align: inherit;"> indem </font><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">eine </font><em><font style="vertical-align: inherit;">Content Size Fitter-</font></em><font style="vertical-align: inherit;"> Komponente </font><font style="vertical-align: inherit;">( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komponente / Layout / Content Size Fitter</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font><font style="vertical-align: inherit;">hinzuf√ºgen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vertikale Anpassungsmodus</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sollte auf </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevorzugte Gr√∂√üe eingestellt sein</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/34e/c56/fdb/34ec56fdb61e1d3a2bc71989333a7a8a.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/acb/a17/bf1/acba17bf1387ddb89b00ea48c9e31035.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden des Inhaltsgr√∂√üen-Monteurs. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit einer kleinen Anzahl von Punkten verschwindet die Bildlaufleiste. </font><font style="vertical-align: inherit;">Wenn die Liste zu viele Elemente enth√§lt, die nicht in das Ansichtsfenster passen, wird die Bildlaufleiste angezeigt und hat eine geeignete Gr√∂√üe.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/327/460/6d8/3274606d8e5831f783d282d5122e55cc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Bildlaufleiste wird angezeigt.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L√∂schen der Karte </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir bequem mit vielen Kartendateien arbeiten. </font><font style="vertical-align: inherit;">Manchmal ist es jedoch notwendig, einige Karten loszuwerden. </font><font style="vertical-align: inherit;">Dazu k√∂nnen Sie die Schaltfl√§che </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L√∂schen verwenden</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Lassen Sie uns eine Methode daf√ºr erstellen und die Schaltfl√§che dazu bringen, sie aufzurufen. </font><font style="vertical-align: inherit;">Wenn ein Pfad ausgew√§hlt ist, l√∂schen Sie ihn einfach mit </font></font><code>File.Delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delete</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = GetSelectedPath(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } File.Delete(path); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier sollten wir auch √ºberpr√ºfen, ob wir mit einer wirklich vorhandenen Datei arbeiten. </font><font style="vertical-align: inherit;">Wenn dies nicht der Fall ist, sollten wir nicht versuchen, es zu entfernen, aber dies f√ºhrt nicht zu einem Fehler.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (File.Exists(path)) { File.Delete(path); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach dem Entfernen der Karte m√ºssen wir das Men√º nicht schlie√üen. </font><font style="vertical-align: inherit;">Dies erleichtert das gleichzeitige L√∂schen mehrerer Dateien. </font><font style="vertical-align: inherit;">Doch nach der Entfernung, m√ºssen wir klar </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Namen der Eingabe</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , und die Liste der Dateien zu </font><font style="vertical-align: inherit;">aktualisieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (File.Exists(path)) { File.Delete(path); } nameInput.text = <span class="hljs-string"><span class="hljs-string">""</span></span>; FillList();</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil 14: Reliefstrukturen </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verwenden Sie Scheitelpunktfarben, um eine Splat-Karte zu erstellen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erstellen eines Array-Textur-Assets. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hinzuf√ºgen von H√∂henindizes zu Netzen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √úberg√§nge zwischen Relieftexturen. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bis zu diesem Moment haben wir Volltonfarben zum Ausmalen von Karten verwendet. </font><font style="vertical-align: inherit;">Jetzt werden wir die Textur anwenden.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4da/9e8/4fa/4da9e84faf824fdcf3933310de58ff9c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texturen zeichnen.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eine Mischung aus drei Typen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl einheitliche Farben klar unterscheidbar sind und die Aufgabe recht gut bew√§ltigen, sehen sie nicht sehr interessant aus. </font><font style="vertical-align: inherit;">Die Verwendung von Texturen erh√∂ht die Attraktivit√§t von Karten erheblich. </font><font style="vertical-align: inherit;">Dazu m√ºssen wir nat√ºrlich Texturen mischen, nicht nur Farben. </font><font style="vertical-align: inherit;">Im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendering 3-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tutorial </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">, Kombinieren von Texturen, habe</font></a><font style="vertical-align: inherit;"> ich dar√ºber gesprochen, wie mehrere Texturen mithilfe der Splat-Map gemischt werden. </font><font style="vertical-align: inherit;">In unseren Sechseckkarten k√∂nnen Sie einen √§hnlichen Ansatz verwenden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Rendering 3-</font></a><font style="vertical-align: inherit;"> Tutorial</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es werden nur vier Texturen gemischt, und mit einer Splat-Map k√∂nnen bis zu f√ºnf Texturen unterst√ºtzt werden. </font><font style="vertical-align: inherit;">Im Moment verwenden wir f√ºnf verschiedene Farben, daher ist dies f√ºr uns sehr gut geeignet. </font><font style="vertical-align: inherit;">Sp√§ter k√∂nnen wir jedoch andere Typen hinzuf√ºgen. </font><font style="vertical-align: inherit;">Daher ist die Unterst√ºtzung einer beliebigen Anzahl von Entlastungstypen erforderlich. </font><font style="vertical-align: inherit;">Wenn Sie explizit festgelegte Textureigenschaften verwenden, ist dies nicht m√∂glich. Sie m√ºssen daher ein Array von Texturen verwenden. </font><font style="vertical-align: inherit;">Sp√§ter werden wir es schaffen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei der Verwendung von Textur-Arrays m√ºssen wir dem Shader irgendwie mitteilen, welche Texturen gemischt werden sollen. </font><font style="vertical-align: inherit;">Das schwierigste Mischen ist f√ºr eckige Dreiecke erforderlich, die zwischen drei Zellen mit ihrem eigenen Gel√§ndetyp liegen k√∂nnen. </font><font style="vertical-align: inherit;">Daher ben√∂tigen wir eine Mischunterst√ºtzung zwischen den drei Typen pro Dreieck.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verwenden von Scheitelpunktfarben als Splat-Karten </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angenommen, wir k√∂nnen Ihnen sagen, welche Texturen gemischt werden sollen, k√∂nnen wir Scheitelpunktfarben verwenden, um eine Splat-Map f√ºr jedes Dreieck zu erstellen. </font><font style="vertical-align: inherit;">Da jeweils maximal drei Texturen verwendet werden, ben√∂tigen wir nur drei Farbkan√§le. </font><font style="vertical-align: inherit;">Rot steht f√ºr die erste Textur, Gr√ºn f√ºr die zweite und Blau f√ºr die dritte.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf1/3fb/603/cf13fb603f1d7ab8e83d9290b483b9ee.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dreieck Splat Karte.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ist die Summe der Dreiecks-Splat-Map immer gleich eins?</font></font></b> <div class="spoiler_text">  Ja         .     . ,        (1, 0, 0)  ,  (¬Ω, ¬Ω, 0)     (&amp;frac13;, &amp;frac13;, &amp;frac13;)  . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn ein Dreieck nur eine Textur ben√∂tigt, verwenden wir nur den ersten Kanal. </font><font style="vertical-align: inherit;">Das hei√üt, seine Farbe wird vollst√§ndig rot sein. </font><font style="vertical-align: inherit;">Beim Mischen zwischen zwei verschiedenen Typen verwenden wir den ersten und den zweiten Kanal. </font><font style="vertical-align: inherit;">Das hei√üt, die Farbe des Dreiecks ist eine Mischung aus Rot und Gr√ºn. </font><font style="vertical-align: inherit;">Und wenn alle drei Typen gefunden sind, ist es eine Mischung aus Rot, Gr√ºn und Blau.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa3/364/890/aa33648906f62a94be8a45aba4bd80de.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drei Splat-Map-Konfigurationen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden diese Splat-Map-Konfigurationen verwenden, unabh√§ngig davon, welche Texturen tats√§chlich gemischt werden. </font><font style="vertical-align: inherit;">Das hei√üt, die Splat-Karte ist immer dieselbe. </font><font style="vertical-align: inherit;">Nur Texturen √§ndern sich. </font><font style="vertical-align: inherit;">Wie das geht, erfahren wir sp√§ter. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir m√ºssen √Ñnderungen </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vornehmen, damit diese Splat-Maps erstellt werden, anstatt Zellenfarben zu verwenden. </font><font style="vertical-align: inherit;">Da wir h√§ufig drei Farben verwenden, erstellen wir statische Felder f√ºr diese.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color color1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color color2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color color3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zellzentren </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beginnen wir damit, standardm√§√üig die Farbe der Mitte der Zellen zu ersetzen. </font><font style="vertical-align: inherit;">Hier wird nicht gemischt, daher verwenden wir nur die erste Farbe, d. H. Rot.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithoutRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { TriangulateEdgeFan(center, e, color1); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e9/44b/f10/3e944bf109bb387ab6a620ea680c2772.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rote Zellzentren. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zellzentren werden jetzt rot. </font><font style="vertical-align: inherit;">Sie alle verwenden die erste der drei Texturen, unabh√§ngig von der Textur. </font><font style="vertical-align: inherit;">Ihre Splat-Maps sind unabh√§ngig von der Farbe, mit der wir die Zellen einf√§rben, gleich.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flussviertel </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben Segmente nur innerhalb von Zellen ge√§ndert, ohne dass Fl√ºsse entlang dieser flie√üen. </font><font style="vertical-align: inherit;">Wir m√ºssen dasselbe f√ºr die Segmente neben den Fl√ºssen tun. </font><font style="vertical-align: inherit;">In unserem Fall ist dies sowohl ein Rippenstreifen als auch ein F√§cher aus Rippendreiecken. </font><font style="vertical-align: inherit;">Auch hier reicht uns nur Rot.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ TriangulateEdgeStrip(m, color1, e, color1); TriangulateEdgeFan(center, m, color1); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b7c/846/a8a/b7c846a8a2a4b5a2670b77359d55f9f6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rote Segmente neben Fl√ºssen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fl√ºsse </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als n√§chstes m√ºssen wir uns um die Geometrie der Fl√ºsse in den Zellen k√ºmmern. </font><font style="vertical-align: inherit;">Alle sollten auch rot werden. </font><font style="vertical-align: inherit;">Schauen wir uns zun√§chst den Anfang und das Ende von Fl√ºssen an.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiverBeginOrEnd</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ TriangulateEdgeStrip(m, color1, e, color1); TriangulateEdgeFan(center, m, color1); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und dann die Geometrie, aus der die Ufer und das Flussbett bestehen. </font><font style="vertical-align: inherit;">Ich habe die Farbmethodenaufrufe gruppiert, um das Lesen des Codes zu erleichtern.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ TriangulateEdgeStrip(m, color1, e, color1); terrain.AddTriangle(centerL, m.v1, m.v2); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(cell.Color); terrain.AddQuad(centerL, center, m.v2, m.v3); // terrain.AddQuadColor(cell.Color); terrain.AddQuad(center, centerR, m.v3, m.v4); // terrain.AddQuadColor(cell.Color); terrain.AddTriangle(centerR, m.v4, m.v5); // terrain.AddTriangleColor(cell.Color); terrain.AddTriangleColor(color1); terrain.AddQuadColor(color1); terrain.AddQuadColor(color1); terrain.AddTriangleColor(color1); ‚Ä¶ }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da8/46a/455/da846a455aa262ddff54429faa207267.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rote Fl√ºsse entlang der Zellen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rippen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle Kanten sind unterschiedlich, da sie sich zwischen Zellen befinden, die unterschiedliche Gel√§ndetypen haben k√∂nnen. </font><font style="vertical-align: inherit;">Wir verwenden die erste Farbe f√ºr den aktuellen Zelltyp und die zweite Farbe f√ºr den Nachbartyp. </font><font style="vertical-align: inherit;">Infolgedessen wird die Splat-Karte zu einem rot-gr√ºnen Farbverlauf, selbst wenn beide Zellen vom gleichen Typ sind. </font><font style="vertical-align: inherit;">Wenn beide Zellen dieselbe Textur verwenden, wird auf beiden Seiten nur eine Mischung aus derselben Textur.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(e1, cell, e2, neighbor, hasRoad); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateEdgeStrip(e1, color1, e2, color2, hasRoad); } ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/368/42b/88c/36842b88cd626359ef4adfd4c3b99b13.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rot-gr√ºne Rippen ohne Leisten.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W√ºrde der scharfe √úbergang zwischen Rot und Gr√ºn nicht Probleme verursachen?</font></font></b> <div class="spoiler_text">   ,         ,      .        .     splat map,         .            . <br><br>  ,           . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Kanten mit den Leisten sind etwas komplizierter, da sie zus√§tzliche Eckpunkte haben. </font><font style="vertical-align: inherit;">Gl√ºcklicherweise funktioniert der vorhandene Interpolationscode hervorragend mit Splat-Map-Farben. </font><font style="vertical-align: inherit;">Verwenden Sie einfach die erste und die zweite Farbe, nicht die Farben der Zellen am Anfang und am Ende.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices begin, HexCell beginCell, EdgeVertices end, HexCell endCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e2 = EdgeVertices.TerraceLerp(begin, end, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(color1, color2, <span class="hljs-number"><span class="hljs-number">1</span></span>); TriangulateEdgeStrip(begin, color1, e2, c2, hasRoad); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { EdgeVertices e1 = e2; Color c1 = c2; e2 = EdgeVertices.TerraceLerp(begin, end, i); c2 = HexMetrics.TerraceLerp(color1, color2, i); TriangulateEdgeStrip(e1, c1, e2, c2, hasRoad); } TriangulateEdgeStrip(e2, c2, end, color2, hasRoad); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/450/635/fe1/450635fe13e41a888046f2f7e0cce830.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rot-gr√ºne Rippenleisten.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Winkel </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zellwinkel sind am schwierigsten, da sie drei verschiedene Texturen mischen m√ºssen. </font><font style="vertical-align: inherit;">Wir verwenden Rot f√ºr den unteren Peak, Gr√ºn f√ºr den linken und Blau f√ºr den rechten. </font><font style="vertical-align: inherit;">Beginnen wir mit den Ecken eines Dreiecks.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangle(bottom, left, right); terrain.AddTriangleColor(color1, color2, color3); } features.AddWall(bottom, bottomCell, left, leftCell, right, rightCell); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/10a/d9c/218/10ad9c21858e48e059c92bbed08c779f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rot-Gr√ºn-Blau-Ecken, au√üer Leisten. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier k√∂nnen wir wieder den vorhandenen Farbinterpolationscode f√ºr Ecken mit Leisten verwenden. </font><font style="vertical-align: inherit;">Es wird nur zwischen drei und nicht zwischen zwei Farben interpoliert. </font><font style="vertical-align: inherit;">Betrachten Sie zun√§chst die Felsvorspr√ºnge, die sich nicht in der N√§he der Klippen befinden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { Vector3 v3 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 v4 = HexMetrics.TerraceLerp(begin, right, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c3 = HexMetrics.TerraceLerp(color1, color2, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c4 = HexMetrics.TerraceLerp(color1, color3, <span class="hljs-number"><span class="hljs-number">1</span></span>); terrain.AddTriangle(begin, v3, v4); terrain.AddTriangleColor(color1, c3, c4); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v3; Vector3 v2 = v4; Color c1 = c3; Color c2 = c4; v3 = HexMetrics.TerraceLerp(begin, left, i); v4 = HexMetrics.TerraceLerp(begin, right, i); c3 = HexMetrics.TerraceLerp(color1, color2, i); c4 = HexMetrics.TerraceLerp(color1, color3, i); terrain.AddQuad(v1, v2, v3, v4); terrain.AddQuadColor(c1, c2, c3, c4); } terrain.AddQuad(v3, v4, left, right); terrain.AddQuadColor(c3, c4, color2, color3); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/504/d1d/6b3/504d1d6b3997b321e0a6e7bf5aa253f2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rot-Gr√ºn-Blau-Eckleisten, mit Ausnahme von Vorspr√ºngen entlang der Klippen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn es um Klippen geht, m√ºssen wir eine Methode anwenden </font></font><code>TriangulateBoundaryTriangle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Diese Methode erhielt die Start- und linken Zellen als Parameter. </font><font style="vertical-align: inherit;">Jetzt ben√∂tigen wir jedoch die entsprechenden Splat-Farben, die je nach Topologie variieren k√∂nnen. </font><font style="vertical-align: inherit;">Daher ersetzen wir diese Parameter durch Farben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateBoundaryTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, Color beginColor, Vector3 left, Color leftColor, Vector3 boundary, Color boundaryColor </span></span></span><span class="hljs-function">)</span></span> { Vector3 v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>)); Color c2 = HexMetrics.TerraceLerp(beginColor, leftColor, <span class="hljs-number"><span class="hljs-number">1</span></span>); terrain.AddTriangleUnperturbed(HexMetrics.Perturb(begin), v2, boundary); terrain.AddTriangleColor(beginColor, c2, boundaryColor); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color c1 = c2; v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, i)); c2 = HexMetrics.TerraceLerp(beginColor, leftColor, i); terrain.AddTriangleUnperturbed(v1, v2, boundary); terrain.AddTriangleColor(c1, c2, boundaryColor); } terrain.AddTriangleUnperturbed(v2, HexMetrics.Perturb(left), boundary); terrain.AddTriangleColor(c2, leftColor, boundaryColor); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ñndern Sie es </font></font><code>TriangulateCornerTerracesCliff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so, dass es die richtigen Farben verwendet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Color boundaryColor = Color.Lerp(color1, color3, b); TriangulateBoundaryTriangle( begin, color1, left, color2, boundary, boundaryColor ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, color2, right, color3, boundary, boundaryColor ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleColor(color2, color3, boundaryColor); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und mach das gleiche f√ºr </font></font><code>TriangulateCornerCliffTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerCliffTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Color boundaryColor = Color.Lerp(color1, color2, b); TriangulateBoundaryTriangle( right, color3, begin, color1, boundary, boundaryColor ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, color2, right, color3, boundary, boundaryColor ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleColor(color2, color3, boundaryColor); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f89/7e0/e40/f897e0e408335e1e7b198ced5e1dc8ad.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Volle Splat-Reliefkarte. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Textur-Arrays </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem unser Gel√§nde eine Splat-Karte hat, k√∂nnen wir die Textur-Sammlung an den Shader √ºbergeben. </font><font style="vertical-align: inherit;">Wir k√∂nnen einem Array von C # -Texturen nicht einfach einen Shader zuweisen, da das Array als einzelne Entit√§t im GPU-Speicher vorhanden sein muss. </font><font style="vertical-align: inherit;">Wir m√ºssen ein spezielles Objekt verwenden </font></font><code>Texture2DArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, das seit Version 5.4 in Unity unterst√ºtzt wird.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterst√ºtzen alle GPUs Textur-Arrays?</font></font></b> <div class="spoiler_text">  GPU  ,         .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> Unity</a> . <br><ul><li> Direct3D 11/12 (Windows, Xbox One) </li><li> OpenGL Core (Mac OS X, Linux) </li><li> Metal (iOS, Mac OS X) </li><li> OpenGL ES 3.0 (Android, iOS, WebGL 2.0) </li><li>  Playstation 4 </li></ul></div></div><br><br><h3>  Der Meister </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leider ist die Unterst√ºtzung von Unity f√ºr Textur-Arrays in Version 5.5 minimal. </font><font style="vertical-align: inherit;">Wir k√∂nnen nicht einfach ein Texturarray-Asset erstellen und ihm Texturen zuweisen. </font><font style="vertical-align: inherit;">Wir m√ºssen es manuell machen. </font><font style="vertical-align: inherit;">Wir k√∂nnen entweder ein Array von Texturen im Wiedergabemodus erstellen oder ein Asset im Editor erstellen. </font><font style="vertical-align: inherit;">Lassen Sie uns einen Verm√∂genswert erstellen.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum einen Verm√∂genswert erstellen?</font></font></b> <div class="spoiler_text">     ,         Play    .        ,        . <br><br>     ,    . Unity            .            ,    . ,       . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um eine Reihe von Texturen zu erstellen, werden wir unseren eigenen Master zusammenstellen. </font><font style="vertical-align: inherit;">Erstellen Sie ein Skript </font></font><code>TextureArrayWizard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und legen Sie es im </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Editor-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ordner ab </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Stattdessen </font></font><code>MonoBehaviour</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sollte der Typ </font></font><code>ScriptableWizard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aus dem Namespace erweitert werden </font></font><code>UnityEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEditor; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TextureArrayWizard</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableWizard</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen den Assistenten √ºber eine verallgemeinerte statische Methode √∂ffnen </font></font><code>ScriptableWizard.DisplayWizard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Seine Parameter sind die Namen des Assistentenfensters und seiner Schaltfl√§che zum Erstellen. </font><font style="vertical-align: inherit;">Wir werden diese Methode in einer statischen Methode aufrufen </font></font><code>CreateWizard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateWizard</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ScriptableWizard.DisplayWizard&lt;TextureArrayWizard&gt;( <span class="hljs-string"><span class="hljs-string">"Create Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"Create"</span></span> ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um √ºber den Editor auf den Assistenten zuzugreifen, m√ºssen Sie diese Methode zum Unity-Men√º hinzuf√ºgen. </font><font style="vertical-align: inherit;">Dies kann durch Hinzuf√ºgen eines Attributs zur Methode erfolgen </font></font><code>MenuItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">F√ºgen wir es dem Men√º " </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assets"</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und insbesondere dem </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Array "Assets / Create / Texture" hinzu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">MenuItem(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Assets/Create/Texture Array"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateWizard</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7d/2b4/433/f7d2b44333870be6838dcd48ea3a697f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unser benutzerdefinierter Assistent. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit dem neuen Men√ºpunkt k√∂nnen Sie das Popup-Men√º unseres benutzerdefinierten Assistenten √∂ffnen. </font><font style="vertical-align: inherit;">Es ist nicht sehr sch√∂n, aber zur L√∂sung des Problems geeignet. </font><font style="vertical-align: inherit;">Es ist jedoch noch leer. </font><font style="vertical-align: inherit;">Um ein Array von Texturen zu erstellen, ben√∂tigen wir ein Array von Texturen. </font><font style="vertical-align: inherit;">F√ºgen Sie ein allgemeines Feld f√ºr den Master hinzu. </font><font style="vertical-align: inherit;">Die Standard-GUI des Assistenten zeigt sie wie ein Standardinspektor an.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Texture2D[] textures;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/beb/aa7/d6d/bebaa7d6dd8e0d995ea485d670ea5a0a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meister mit Texturen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lassen Sie uns etwas schaffen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie auf die Schaltfl√§che </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> des </font><font style="vertical-align: inherit;">Assistenten </font><font style="vertical-align: inherit;">klicken </font><font style="vertical-align: inherit;">, wird dieser ausgeblendet. </font><font style="vertical-align: inherit;">Dar√ºber hinaus beschwert sich Unity, dass es keine Methode gibt </font></font><code>OnWizardCreate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies ist die Methode, die aufgerufen wird, wenn auf die Schaltfl√§che "Erstellen" geklickt wird. Daher m√ºssen wir sie dem Assistenten hinzuf√ºgen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnWizardCreate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier erstellen wir unser Texturarray. </font><font style="vertical-align: inherit;">Zumindest wenn der Benutzer dem Master Texturen hinzugef√ºgt hat. </font><font style="vertical-align: inherit;">Wenn nicht, gibt es nichts zu erstellen und die Arbeit muss gestoppt werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnWizardCreate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (textures.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der n√§chste Schritt besteht darin, den Speicherort zum Speichern des Texturarray-Assets anzufordern. </font><font style="vertical-align: inherit;">Das Dateispeicherfenster kann mit dieser Methode ge√∂ffnet werden </font></font><code>EditorUtility.SaveFilePanelInProject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Seine Parameter definieren den Panel-Namen, den Standard-Dateinamen, die Dateierweiterung und die Beschreibung. </font><font style="vertical-align: inherit;">Textur-Arrays verwenden die allgemeine </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asset-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dateierweiterung </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (textures.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } EditorUtility.SaveFilePanelInProject( <span class="hljs-string"><span class="hljs-string">"Save Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"asset"</span></span>, <span class="hljs-string"><span class="hljs-string">"Save Texture Array"</span></span> );</code> </pre> <br> <code>SaveFilePanelInProject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gibt den vom Benutzer ausgew√§hlten Dateipfad zur√ºck. </font><font style="vertical-align: inherit;">Wenn der Benutzer in diesem Bereich auf Abbrechen geklickt hat, ist der Pfad eine leere Zeichenfolge. </font><font style="vertical-align: inherit;">Daher m√ºssen wir in diesem Fall die Arbeit unterbrechen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = EditorUtility.SaveFilePanelInProject( <span class="hljs-string"><span class="hljs-string">"Save Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"asset"</span></span>, <span class="hljs-string"><span class="hljs-string">"Save Texture Array"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erstellen eines Arrays von Texturen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir den richtigen Weg haben, k√∂nnen wir weitermachen und ein neues Objekt erstellen </font></font><code>Texture2DArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Seine Konstruktormethode erfordert die Angabe der Breite und H√∂he der Textur, der L√§nge des Arrays, des Formats der Texturen und der Notwendigkeit der Mip-Texturierung. </font><font style="vertical-align: inherit;">Diese Parameter sollten f√ºr alle Texturen im Array gleich sein. </font><font style="vertical-align: inherit;">Um das Objekt zu konfigurieren, verwenden wir die erste Textur. </font><font style="vertical-align: inherit;">Der Benutzer muss √ºberpr√ºfen, ob alle Texturen das gleiche Format haben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Texture2D t = textures[<span class="hljs-number"><span class="hljs-number">0</span></span>]; Texture2DArray textureArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2DArray( t.width, t.height, textures.Length, t.format, t.mipmapCount &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da es sich bei dem Texturarray um eine einzelne GPU-Ressource handelt, werden f√ºr alle Texturen dieselben Filter- und Faltmodi verwendet. </font><font style="vertical-align: inherit;">Hier verwenden wir wieder die erste Textur, um alles einzurichten.</font></font><br><br><pre> <code class="cs hljs"> Texture2DArray textureArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2DArray( t.width, t.height, textures.Length, t.format, t.mipmapCount &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ); textureArray.anisoLevel = t.anisoLevel; textureArray.filterMode = t.filterMode; textureArray.wrapMode = t.wrapMode;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir die Texturen mit der Methode in ein Array kopieren </font></font><code>Graphics.CopyTexture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die Methode kopiert rohe Texturdaten nacheinander. </font><font style="vertical-align: inherit;">Daher m√ºssen wir alle Texturen und ihre Mip-Levels durchlaufen. </font><font style="vertical-align: inherit;">Die Methodenparameter sind zwei S√§tze, die aus einer Texturressource, einem Index und einer Mip-Ebene bestehen. </font><font style="vertical-align: inherit;">Da die urspr√ºnglichen Texturen keine Arrays sind, ist ihr Index immer Null.</font></font><br><br><pre> <code class="cs hljs"> textureArray.wrapMode = t.wrapMode; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; textures.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = <span class="hljs-number"><span class="hljs-number">0</span></span>; m &lt; t.mipmapCount; m++) { Graphics.CopyTexture(textures[i], <span class="hljs-number"><span class="hljs-number">0</span></span>, m, textureArray, i, m); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu diesem Zeitpunkt haben wir die richtige Anordnung von Texturen im Speicher, aber es ist noch kein Aktivposten. </font><font style="vertical-align: inherit;">Der letzte Schritt besteht darin, </font></font><code>AssetDatabase.CreateAsset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit dem Array und seinem Pfad </font><font style="vertical-align: inherit;">aufzurufen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In diesem Fall werden die Daten in eine Datei in unserem Projekt geschrieben und im Projektfenster angezeigt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; textures.Length; i++) { ‚Ä¶ } AssetDatabase.CreateAsset(textureArray, path);</code> </pre> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Texturen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um eine echte Reihe von Texturen zu erstellen, ben√∂tigen wir die Originaltexturen. Hier sind f√ºnf Texturen, die den bisher verwendeten Farben entsprechen. Gelb wird Sand, Gr√ºn wird Gras, Blau wird Erde, Orange wird Stein und Wei√ü wird Schnee.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/195/104/a40/195104a4070bfa42e6c4e0eaff218d42.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d7/777/f86/0d7777f865b086c46a1c95a06380c66a.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f8/30b/55f/0f830b55ffdbc729bc02d013805bb2c3.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/347/4eb/37b/3474eb37b3a5404866a6fd384e9c6352.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6de/0eb/fa3/6de0ebfa32b5b0b04c8c082e6cce0c01.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texturen aus Sand, Gras, Erde, Stein und Schnee. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie, dass diese Texturen keine Fotos dieses Reliefs sind. </font><font style="vertical-align: inherit;">Dies sind die einfachen Pseudozufallsmuster, die ich mit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NumberFlow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erstellt </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">habe</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ich bem√ºhte mich, erkennbare Relieftypen und Details zu schaffen, die nicht mit abstrakten polygonalen Reliefs in Konflikt stehen. </font><font style="vertical-align: inherit;">Der Fotorealismus erwies sich daf√ºr als ungeeignet. </font><font style="vertical-align: inherit;">Obwohl Muster die Variabilit√§t erh√∂hen, enthalten sie nur wenige unterschiedliche Merkmale, die Wiederholungen sofort wahrnehmbar machen w√ºrden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie diese Texturen dem Master-Array hinzu und stellen Sie sicher, dass ihre Reihenfolge mit den Farben √ºbereinstimmt. </font><font style="vertical-align: inherit;">Das hei√üt, zuerst Sand, dann Gras, Erde, Stein und schlie√ülich Schnee.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ec/511/2a1/5ec5112a1bdaa4f170ec382b2549ad9d.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a54/4e8/1f0/a544e81f0c74fa36290553a6c6a328df.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen eines Arrays von Texturen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem Sie das Texturarray-Asset erstellt haben, w√§hlen Sie es aus und untersuchen Sie es im Inspektor.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e1/8f3/8d6/6e18f38d6682f71b3c8a999823642cd4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texturarray-Inspektor.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies ist die einfachste Anzeige eines Teils der Texturarraydaten. Beachten Sie, dass es einen </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is Readable-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schalter </font><font style="vertical-align: inherit;">gibt, der anf√§nglich eingeschaltet ist. Deaktivieren Sie diese Option, da Sie keine Pixeldaten aus dem Array lesen m√ºssen. Dies ist im Assistenten nicht m√∂glich, da </font></font><code>Texture2DArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">keine Methoden oder Eigenschaften f√ºr den Zugriff auf diesen Parameter vorhanden sind. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(In Unity 5.6 gibt es einen Fehler, der Textur-Arrays in Assemblys auf mehreren Plattformen </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">besch√§digt</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Sie k√∂nnen ihn umgehen, ohne </font><em><font style="vertical-align: inherit;">Is Readable</font></em><font style="vertical-align: inherit;"> zu deaktivieren </font><font style="vertical-align: inherit;">.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie auch, dass ein </font><em><font style="vertical-align: inherit;">Farbraumfeld</font></em><font style="vertical-align: inherit;"> vorhanden ist</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies bedeutet, dass angenommen wird, dass sich die Texturen im Gammaraum befinden, was wahr ist. </font><font style="vertical-align: inherit;">Wenn sie sich im linearen Raum befinden sollten, musste das Feld auf 0 gesetzt werden. Der Designer </font></font><code>Texture2DArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verf√ºgt zwar √ºber einen zus√§tzlichen Parameter zum Festlegen des Farbraums, zeigt </font></font><code>Texture2D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jedoch nicht an, ob er sich im linearen Raum befindet oder nicht. Daher m√ºssen Sie in jedem Fall einen Wert festlegen Wert manuell.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt, da wir eine Reihe von Texturen haben, m√ºssen wir dem Shader beibringen, wie man damit arbeitet. </font><font style="vertical-align: inherit;">Im </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moment verwenden</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir den </font><em><font style="vertical-align: inherit;">VertexColors-</font></em><font style="vertical-align: inherit;"> Shader, um das Gel√§nde zu rendern </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Da wir jetzt Texturen anstelle von Farben verwenden, benennen Sie sie in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain um</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dann verwandeln wir den Parameter </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_MainTex</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in ein Array von Texturen und weisen ihm ein Asset zu.</font></font><br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">Shader</span></span> <span class="hljs-string"><span class="hljs-string">"Custom/Terrain"</span></span> { <span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_Color</span></span> (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Terrain Texture Array"</span></span>, 2DArray) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_Glossiness</span></span> (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> _Metallic (<span class="hljs-string"><span class="hljs-string">"Metallic"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> } ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/878/0b2/3de/8780b23ded3ced3ab980a039d0f5753d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reliefmaterial mit einer Reihe von Texturen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um Textur-Arrays auf allen Plattformen zu aktivieren, die sie unterst√ºtzen, m√ºssen Sie die Zielstufe des Shaders von 3.0 auf 3.5 erh√∂hen.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> target 3.5</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da sich die Variable </font></font><code>_MainTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jetzt auf ein Array von Texturen bezieht, m√ºssen wir ihren Typ √§ndern. </font><font style="vertical-align: inherit;">Der Typ h√§ngt von der Zielplattform ab und das Makro k√ºmmert sich darum </font></font><code>UNITY_DECLARE_TEX2DARRAY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// sampler2D _MainTex; UNITY_DECLARE_TEX2DARRAY(_MainTex);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie bei anderen Shadern ben√∂tigen wir die Koordinaten der XZ-Welt, um die Textur des Reliefs abzutasten. </font><font style="vertical-align: inherit;">Daher werden wir der Eingabestruktur des Surface Shader eine Position in der Welt hinzuf√ºgen. </font><font style="vertical-align: inherit;">Wir l√∂schen auch die Standard-UV-Koordinaten, da wir sie nicht ben√∂tigen.</font></font><br><br><pre> <code class="hljs swift"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// float2 uv_MainTex; float4 color : COLOR; float3 worldPos; };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um ein Array von Texturen abzutasten, m√ºssen wir ein Makro verwenden </font></font><code>UNITY_SAMPLE_TEX2DARRAY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Zum Abtasten eines Arrays werden drei Koordinaten ben√∂tigt. </font><font style="vertical-align: inherit;">Die ersten beiden sind regul√§re UV-Koordinaten. </font><font style="vertical-align: inherit;">Wir werden die XZ-Weltkoordinaten verwenden, die auf 0,02 skaliert sind. </font><font style="vertical-align: inherit;">So erhalten wir eine gute Texturaufl√∂sung bei voller Vergr√∂√üerung. </font><font style="vertical-align: inherit;">Texturen werden ungef√§hr alle vier Zellen wiederholt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die dritte Koordinate wird wie in einem regul√§ren Array als Index des Texturarrays verwendet. </font><font style="vertical-align: inherit;">Da die Koordinaten float sind, werden sie vor dem Indizieren durch das GPU-Array gerundet. </font><font style="vertical-align: inherit;">Da wir, bis wir wissen, welche Textur ben√∂tigt wird, immer die erste verwenden. </font><font style="vertical-align: inherit;">Au√üerdem hat die Farbe des Scheitelpunkts keinen Einfluss auf das Endergebnis, da es sich um eine Splat-Karte handelt.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.02</span></span>; fixed4 c = UNITY_SAMPLE_TEX2DARRAY(_MainTex, float3(uv, <span class="hljs-number"><span class="hljs-number">0</span></span>)); Albedo = c.rgb * _Color; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c08/a19/df0/c08a19df0f6c0674406e4922b6595585.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alles ist Sand geworden. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Texturauswahl </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir brauchen eine Relief-Splat-Karte, die die drei Typen zu einem Dreieck mischt. </font><font style="vertical-align: inherit;">Wir haben eine Reihe von Texturen mit einer Textur f√ºr jeden Gel√§ndetyp. </font><font style="vertical-align: inherit;">Wir haben einen Shader, der eine Reihe von Texturen abtastet. </font><font style="vertical-align: inherit;">Derzeit k√∂nnen wir dem Shader jedoch nicht mitteilen, welche Texturen f√ºr jedes Dreieck ausgew√§hlt werden sollen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da jedes Dreieck bis zu drei Typen mischt, m√ºssen wir jedem Dreieck drei Indizes zuordnen. </font><font style="vertical-align: inherit;">Wir k√∂nnen keine Informationen f√ºr Dreiecke speichern, daher m√ºssen wir Indizes f√ºr Scheitelpunkte speichern. </font><font style="vertical-align: inherit;">Alle drei Eckpunkte des Dreiecks speichern einfach die gleichen Indizes wie bei der Volltonfarbe.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vernetzt Daten </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen einen der S√§tze des UV-Netzes zum Speichern von Indizes verwenden. </font><font style="vertical-align: inherit;">Da auf jedem Scheitelpunkt drei Indizes gespeichert sind, reichen die vorhandenen 2D-UV-S√§tze nicht aus. </font><font style="vertical-align: inherit;">Gl√ºcklicherweise k√∂nnen UV-Sets bis zu vier Koordinaten enthalten. </font><font style="vertical-align: inherit;">Daher f√ºgen wir der </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zweiten Liste hinzu </font></font><code>Vector3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, auf die wir als Relieftypen verweisen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useCollider, useColors, useUVCoordinates, useUV2Coordinates; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useTerrainTypes; [NonSerialized] List&lt;Vector3&gt; vertices, terrainTypes;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktivieren Sie Gel√§ndetypen f√ºr das </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kind des </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid Chunk-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fertighauses </font><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/728/0c5/4eb/7280c54ebcd1a6063fb3df9f0328cc5b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir verwenden Reliefarten. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei Bedarf erstellen wir </font></font><code>Vector3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w√§hrend der Netzreinigung </font><font style="vertical-align: inherit;">eine weitere Liste </font><font style="vertical-align: inherit;">der Entlastungsarten.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useTerrainTypes) { terrainTypes = ListPool&lt;Vector3&gt;.Get(); } triangles = ListPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Get(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Anwenden der Netzdaten speichern wir die Relieftypen im dritten UV-Satz. </font><font style="vertical-align: inherit;">Aus diesem Grund werden sie nicht mit zwei anderen Sets in Konflikt geraten, wenn wir uns jemals dazu entschlie√üen, sie zusammen zu verwenden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useTerrainTypes) { hexMesh.SetUVs(<span class="hljs-number"><span class="hljs-number">2</span></span>, terrainTypes); ListPool&lt;Vector3&gt;.Add(terrainTypes); } hexMesh.SetTriangles(triangles, <span class="hljs-number"><span class="hljs-number">0</span></span>); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Relieftypen des Dreiecks festzulegen, verwenden wir </font></font><code>Vector3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Da die f√ºr das gesamte Dreieck gleich sind, f√ºgen wir nur dreimal dieselben Daten hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleTerrainTypes</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 types</span></span></span><span class="hljs-function">)</span></span> { terrainTypes.Add(types); terrainTypes.Add(types); terrainTypes.Add(types); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Mischen im Quad funktioniert genauso. </font><font style="vertical-align: inherit;">Alle vier Eckpunkte sind vom gleichen Typ.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadTerrainTypes</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 types</span></span></span><span class="hljs-function">)</span></span> { terrainTypes.Add(types); terrainTypes.Add(types); terrainTypes.Add(types); terrainTypes.Add(types); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fans von Triangles of Ribs </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt m√ºssen wir den Netzdaten in Typen hinzuf√ºgen </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Beginnen wir mit </font></font><code>TriangulateEdgeFan</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Lassen Sie uns zur besseren Lesbarkeit zun√§chst die Vertex- und Color-Methodenaufrufe aufteilen. </font><font style="vertical-align: inherit;">Denken Sie daran, dass wir sie bei jedem Aufruf dieser Methode an ihn √ºbergeben </font></font><code>color1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, damit wir diese Farbe direkt verwenden und den Parameter nicht anwenden k√∂nnen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeFan</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, EdgeVertices edge, Color color</span></span></span><span class="hljs-function">)</span></span> { terrain.AddTriangle(center, edge.v1, edge.v2); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(color); terrain.AddTriangle(center, edge.v2, edge.v3); // terrain.AddTriangleColor(color); terrain.AddTriangle(center, edge.v3, edge.v4); // terrain.AddTriangleColor(color); terrain.AddTriangle(center, edge.v4, edge.v5); // terrain.AddTriangleColor(color); terrain.AddTriangleColor(color1); terrain.AddTriangleColor(color1); terrain.AddTriangleColor(color1); terrain.AddTriangleColor(color1); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach den Farben f√ºgen wir Reliefarten hinzu. </font><font style="vertical-align: inherit;">Da die Typen im Dreieck unterschiedlich sein k√∂nnen, sollte dies ein Parameter sein, der die Farbe ersetzt. </font><font style="vertical-align: inherit;">Verwenden Sie diesen einfachen Typ zum Erstellen </font></font><code>Vector3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nur die ersten vier Kan√§le sind uns wichtig, da in diesem Fall die Splat-Map immer rot ist. </font><font style="vertical-align: inherit;">Da alle drei Komponenten des Vektors zugewiesen werden m√ºssen, weisen wir ihnen einen Typ zu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeFan</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, EdgeVertices edge, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Vector3 types; types.x = types.y = types.z = type; terrain.AddTriangleTerrainTypes(types); terrain.AddTriangleTerrainTypes(types); terrain.AddTriangleTerrainTypes(types); terrain.AddTriangleTerrainTypes(types); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt m√ºssen wir alle Aufrufe dieser Methode √§ndern und das Farbargument durch einen Index des Gel√§ndetyps der Zelle ersetzen. </font><font style="vertical-align: inherit;">Vnesom diese √Ñnderung </font></font><code>TriangulateWithoutRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>TriangulateAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>TriangulateWithRiverBeginOrEnd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// TriangulateEdgeFan(center, e, color1); TriangulateEdgeFan(center, e, cell.TerrainTypeIndex);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu diesem Zeitpunkt, wenn Sie den Wiedergabemodus starten, werden Fehler angezeigt, die Sie dar√ºber informieren, dass dritte S√§tze von UV-Netzen au√üerhalb der Grenzen liegen. </font><font style="vertical-align: inherit;">Dies geschah, weil wir noch nicht jedem Dreieck und Quad Relieftypen hinzuf√ºgen. </font><font style="vertical-align: inherit;">Also lasst uns weiter √§ndern </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rippenstreifen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir nun einen Randstreifen erstellen, m√ºssen wir wissen, welche Gel√§ndetypen sich auf beiden Seiten befinden. </font><font style="vertical-align: inherit;">Daher f√ºgen wir sie als Parameter hinzu und erstellen dann einen Vektor von Typen, deren zwei Kan√§len diese Typen zugewiesen sind. </font><font style="vertical-align: inherit;">Der dritte Kanal ist nicht wichtig, also setzen Sie ihn einfach dem ersten gleich. </font><font style="vertical-align: inherit;">F√ºgen Sie nach dem Hinzuf√ºgen der Farben die Typen zum Quad hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color c1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type1, EdgeVertices e2, Color c2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span> { terrain.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); terrain.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); terrain.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); terrain.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); terrain.AddQuadColor(c1, c2); terrain.AddQuadColor(c1, c2); terrain.AddQuadColor(c1, c2); terrain.AddQuadColor(c1, c2); Vector3 types; types.x = types.z = type1; types.y = type2; terrain.AddQuadTerrainTypes(types); terrain.AddQuadTerrainTypes(types); terrain.AddQuadTerrainTypes(types); terrain.AddQuadTerrainTypes(types); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRoad) { TriangulateRoadSegment(e1.v2, e1.v3, e1.v4, e2.v2, e2.v3, e2.v4); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt m√ºssen wir die Herausforderungen √§ndern </font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Erstens </font></font><code>TriangulateAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>TriangulateWithRiverBeginOrEnd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie m√ºssen den Zelltyp f√ºr beiden Seiten des Rippenstreifens verwenden.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// TriangulateEdgeStrip(m, color1, e, color1); TriangulateEdgeStrip( m, color1, cell.TerrainTypeIndex, e, color1, cell.TerrainTypeIndex );</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als n√§chstes muss der einfachste Fall einer Kante </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Zelltyp f√ºr die n√§chste Kante und den Nachbartyp f√ºr die entfernte Kante verwenden. </font><font style="vertical-align: inherit;">Sie k√∂nnen gleich oder verschieden sein.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(e1, cell, e2, neighbor, hasRoad); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">// TriangulateEdgeStrip(e1, color1, e2, color2, hasRoad); TriangulateEdgeStrip( e1, color1, cell.TerrainTypeIndex, e2, color2, neighbor.TerrainTypeIndex, hasRoad ); } ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gleiches gilt f√ºr das </font></font><code>TriangulateEdgeTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, was dreimal ausl√∂st </font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die Typen f√ºr die Leisten sind gleich.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices begin, HexCell beginCell, EdgeVertices end, HexCell endCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e2 = EdgeVertices.TerraceLerp(begin, end, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(color1, color2, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t1 = beginCell.TerrainTypeIndex; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t2 = endCell.TerrainTypeIndex; TriangulateEdgeStrip(begin, color1, t1, e2, c2, t2, hasRoad); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { EdgeVertices e1 = e2; Color c1 = c2; e2 = EdgeVertices.TerraceLerp(begin, end, i); c2 = HexMetrics.TerraceLerp(color1, color2, i); TriangulateEdgeStrip(e1, c1, t1, e2, c2, t2, hasRoad); } TriangulateEdgeStrip(e2, c2, t1, end, color2, t2, hasRoad); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Winkel </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der einfachste Fall eines Winkels ist ein einfaches Dreieck. </font><font style="vertical-align: inherit;">Die untere Zelle √ºbertr√§gt den ersten Typ, der linke den zweiten und den rechten den dritten. </font><font style="vertical-align: inherit;">Erstellen Sie mit ihnen einen Vektor von Typen und f√ºgen Sie ihn dem Dreieck hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangle(bottom, left, right); terrain.AddTriangleColor(color1, color2, color3); Vector3 types; types.x = bottomCell.TerrainTypeIndex; types.y = leftCell.TerrainTypeIndex; types.z = rightCell.TerrainTypeIndex; terrain.AddTriangleTerrainTypes(types); } features.AddWall(bottom, bottomCell, left, leftCell, right, rightCell); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir verwenden den gleichen Ansatz in </font></font><code>TriangulateCornerTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nur dass wir hier eine Gruppe von Quads erstellen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { Vector3 v3 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 v4 = HexMetrics.TerraceLerp(begin, right, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c3 = HexMetrics.TerraceLerp(color1, color2, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c4 = HexMetrics.TerraceLerp(color1, color3, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 types; types.x = beginCell.TerrainTypeIndex; types.y = leftCell.TerrainTypeIndex; types.z = rightCell.TerrainTypeIndex; terrain.AddTriangle(begin, v3, v4); terrain.AddTriangleColor(color1, c3, c4); terrain.AddTriangleTerrainTypes(types); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v3; Vector3 v2 = v4; Color c1 = c3; Color c2 = c4; v3 = HexMetrics.TerraceLerp(begin, left, i); v4 = HexMetrics.TerraceLerp(begin, right, i); c3 = HexMetrics.TerraceLerp(color1, color2, i); c4 = HexMetrics.TerraceLerp(color1, color3, i); terrain.AddQuad(v1, v2, v3, v4); terrain.AddQuadColor(c1, c2, c3, c4); terrain.AddQuadTerrainTypes(types); } terrain.AddQuad(v3, v4, left, right); terrain.AddQuadColor(c3, c4, color2, color3); terrain.AddQuadTerrainTypes(types); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir Felsvorspr√ºnge und Klippen mischen, m√ºssen wir verwenden </font></font><code>TriangulateBoundaryTriangle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Geben Sie ihm einfach einen Typvektorparameter und f√ºgen Sie ihn allen Dreiecken hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateBoundaryTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, Color beginColor, Vector3 left, Color leftColor, Vector3 boundary, Color boundaryColor, Vector3 types </span></span></span><span class="hljs-function">)</span></span> { Vector3 v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>)); Color c2 = HexMetrics.TerraceLerp(beginColor, leftColor, <span class="hljs-number"><span class="hljs-number">1</span></span>); terrain.AddTriangleUnperturbed(HexMetrics.Perturb(begin), v2, boundary); terrain.AddTriangleColor(beginColor, c2, boundaryColor); terrain.AddTriangleTerrainTypes(types); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color c1 = c2; v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, i)); c2 = HexMetrics.TerraceLerp(beginColor, leftColor, i); terrain.AddTriangleUnperturbed(v1, v2, boundary); terrain.AddTriangleColor(c1, c2, boundaryColor); terrain.AddTriangleTerrainTypes(types); } terrain.AddTriangleUnperturbed(v2, HexMetrics.Perturb(left), boundary); terrain.AddTriangleColor(c2, leftColor, boundaryColor); terrain.AddTriangleTerrainTypes(types); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das </font></font><code>TriangulateCornerTerracesCliff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">schafft Vektor basierend auf den √ºbertragenen Zelltypen. </font><font style="vertical-align: inherit;">F√ºgen Sie es dann zu einem Dreieck hinzu und geben Sie es ein </font></font><code>TriangulateBoundaryTriangle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (rightCell.Elevation - beginCell.Elevation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { b = -b; } Vector3 boundary = Vector3.Lerp( HexMetrics.Perturb(begin), HexMetrics.Perturb(right), b ); Color boundaryColor = Color.Lerp(color1, color3, b); Vector3 types; types.x = beginCell.TerrainTypeIndex; types.y = leftCell.TerrainTypeIndex; types.z = rightCell.TerrainTypeIndex; TriangulateBoundaryTriangle( begin, color1, left, color2, boundary, boundaryColor, types ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, color2, right, color3, boundary, boundaryColor, types ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleColor(color2, color3, boundaryColor); terrain.AddTriangleTerrainTypes(types); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das gilt auch f√ºr </font></font><code>TriangulateCornerCliffTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerCliffTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (leftCell.Elevation - beginCell.Elevation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { b = -b; } Vector3 boundary = Vector3.Lerp( HexMetrics.Perturb(begin), HexMetrics.Perturb(left), b ); Color boundaryColor = Color.Lerp(color1, color2, b); Vector3 types; types.x = beginCell.TerrainTypeIndex; types.y = leftCell.TerrainTypeIndex; types.z = rightCell.TerrainTypeIndex; TriangulateBoundaryTriangle( right, color3, begin, color1, boundary, boundaryColor, types ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, color2, right, color3, boundary, boundaryColor, types ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleColor(color2, color3, boundaryColor); terrain.AddTriangleTerrainTypes(types); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fl√ºsse </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die letzte Methode, die ge√§ndert werden muss, ist diese </font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Da wir uns hier in der Mitte der Zelle befinden, haben wir es nur mit dem Typ der aktuellen Zelle zu tun. </font><font style="vertical-align: inherit;">Erstellen Sie daher einen Vektor daf√ºr und f√ºgen Sie ihn Dreiecken und Quadraten hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ terrain.AddTriangleColor(color1); terrain.AddQuadColor(color1); terrain.AddQuadColor(color1); terrain.AddTriangleColor(color1); Vector3 types; types.x = types.y = types.z = cell.TerrainTypeIndex; terrain.AddTriangleTerrainTypes(types); terrain.AddQuadTerrainTypes(types); terrain.AddQuadTerrainTypes(types); terrain.AddTriangleTerrainTypes(types); ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Typ mix </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu diesem Zeitpunkt enthalten die Netze die erforderlichen H√∂henindizes. </font><font style="vertical-align: inherit;">Wir m√ºssen nur den </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader zwingen, </font><font style="vertical-align: inherit;">sie </font><font style="vertical-align: inherit;">zu </font><font style="vertical-align: inherit;">verwenden. </font><font style="vertical-align: inherit;">Damit die Indizes in den Fragment-Shader fallen, m√ºssen sie zuerst durch den Vertex-Shader geleitet werden. </font><font style="vertical-align: inherit;">Wir k√∂nnen dies in unserer eigenen Scheitelpunktfunktion tun, wie wir es im </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estuary-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader getan haben </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In diesem Fall f√ºgen wir der Eingabestruktur ein Feld hinzu </font></font><code>float3 terrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und kopieren es in diese </font></font><code>v.texcoord2.xyz</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs pgsql"> #pragma surface surf Standard fullforwardshadows vertex:vert #pragma target <span class="hljs-number"><span class="hljs-number">3.5</span></span> ‚Ä¶ struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { <span class="hljs-type"><span class="hljs-type">float4</span></span> color : COLOR; float3 worldPos; float3 terrain; }; <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); data.terrain = v.texcoord2.xyz; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir m√ºssen das Texturarray dreimal pro Fragment abtasten. </font><font style="vertical-align: inherit;">Erstellen wir daher eine praktische Funktion zum Erstellen von Texturkoordinaten, zum Abtasten eines Arrays und zum Modulieren eines Samples mit einer Splat-Map f√ºr einen Index.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float4</span></span> GetTerrainColor (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { float3 uvw = float3(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.terrain[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]); <span class="hljs-type"><span class="hljs-type">float4</span></span> c = UNITY_SAMPLE_TEX2DARRAY(_MainTex, uvw); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.color[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]; } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { ‚Ä¶ }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">K√∂nnen wir mit einem Vektor als Array arbeiten?</font></font></b> <div class="spoiler_text">  Ja   - <code>color[0]</code>  <code>color.r</code> .  <code>color[1]</code>  <code>color.g</code> ,   . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mit dieser Funktion k√∂nnen wir das Texturarray einfach dreimal abtasten und die Ergebnisse kombinieren. </font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { // float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.02</span></span>; fixed4 c = GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) + GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) + GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); o.Albedo = c.rgb * _Color; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da9/2fa/577/da92fa577510b38d4d0cdb99db83aea0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strukturiertes Relief. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir das Relief mit Texturen bemalen. </font><font style="vertical-align: inherit;">Sie mischen sich wie Volltonfarben. </font><font style="vertical-align: inherit;">Da wir die Weltkoordinaten als UV-Koordinaten verwenden, √§ndern sie sich nicht mit der H√∂he. </font><font style="vertical-align: inherit;">Infolgedessen werden die Texturen entlang scharfer Klippen gedehnt. </font><font style="vertical-align: inherit;">Wenn die Texturen ziemlich neutral und sehr variabel sind, sind die Ergebnisse akzeptabel. </font><font style="vertical-align: inherit;">Ansonsten bekommen wir gro√üe h√§ssliche Dehnungsstreifen. </font><font style="vertical-align: inherit;">Sie k√∂nnen versuchen, es mit zus√§tzlicher Geometrie oder Textur von Klippen auszublenden, aber im Tutorial werden wir dies nicht tun.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fegen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir nun Texturen anstelle von Farben verwenden, ist es logisch, das Editorfenster zu √§ndern. </font><font style="vertical-align: inherit;">Wir k√∂nnen eine sch√∂ne Oberfl√§che erstellen, die sogar Relieftexturen anzeigen kann, aber ich werde mich auf Abk√ºrzungen konzentrieren, die dem Stil des vorhandenen Schemas entsprechen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/263/c52/c81/263c52c812c97de2b8095b6ca80a8f5d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entlastungsoptionen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au√üerdem wird die </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Farbeigenschaft nicht mehr ben√∂tigt. L√∂schen Sie sie daher.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Color Color { // get { // return HexMetrics.colors[terrainTypeIndex]; // } // }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k√∂nnen auch ein Array von Farben und den dazugeh√∂rigen Code entfernen.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Color[] colors; ‚Ä¶ void Awake () { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); // HexMetrics.colors = colors; CreateMap(cellCountX, cellCountZ); } ‚Ä¶ ‚Ä¶ void OnEnable () { if (!HexMetrics.noiseSource) { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); // HexMetrics.colors = colors; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlie√ülich wird auch eine Reihe von Farben in nicht ben√∂tigt </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public static Color[] colors;</span></span></code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil 15: Entfernungen </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeigen Sie die Gitterlinien an. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wechseln Sie zwischen Bearbeitungs- und Navigationsmodus. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Berechnen Sie den Abstand zwischen den Zellen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir finden Wege um Hindernisse herum. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir ber√ºcksichtigen die variablen Umzugskosten. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachdem wir hochwertige Karten erstellt haben, beginnen wir mit der Navigation. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15b/b5d/65d/15bb5d65de19358da88e581cedad71cb.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der k√ºrzeste Weg ist nicht immer gerade.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rasteranzeige </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Navigation auf der Karte erfolgt durch Bewegen von Zelle zu Zelle. </font><font style="vertical-align: inherit;">Um irgendwohin zu gelangen, m√ºssen Sie eine Reihe von Zellen durchlaufen. </font><font style="vertical-align: inherit;">Um die Sch√§tzung von Entfernungen zu vereinfachen, f√ºgen wir die Option hinzu, das Sechseckgitter anzuzeigen, auf dem unsere Karte basiert.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maschentextur </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trotz der Unregelm√§√üigkeiten des Kartennetzes ist das darunter liegende Netz vollkommen flach. </font><font style="vertical-align: inherit;">Wir k√∂nnen dies zeigen, indem wir ein Gittermuster auf eine Karte projizieren. </font><font style="vertical-align: inherit;">Dies kann unter Verwendung einer sich wiederholenden Maschentextur erreicht werden.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a7/74c/76e/3a774c76e29b57018450a8e21f5bf1fb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wiederholte Netzstruktur. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die oben gezeigte Textur enth√§lt einen kleinen Teil des Sechseckgitters, der 2 mal 2 Zellen bedeckt. </font><font style="vertical-align: inherit;">Dieser Bereich ist rechteckig und nicht quadratisch. </font><font style="vertical-align: inherit;">Da die Textur selbst ein Quadrat ist, sieht das Muster gestreckt aus. </font><font style="vertical-align: inherit;">Bei der Probenahme m√ºssen wir dies kompensieren.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gitterprojektion </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um ein Netzmuster zu projizieren, m√ºssen wir </font><font style="vertical-align: inherit;">dem </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font><font style="vertical-align: inherit;">eine Textur-Eigenschaft </font><font style="vertical-align: inherit;">hinzuf√ºgen </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_Color</span></span> (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Terrain Texture Array"</span></span>, 2DArray) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_GridTex</span></span> (<span class="hljs-string"><span class="hljs-string">"Grid Texture"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_Glossiness</span></span> (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> _Metallic (<span class="hljs-string"><span class="hljs-string">"Metallic"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/283/708/6de/2837086dedff939d3380396c9146ddfc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reliefmaterial mit Netzstruktur. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Probieren Sie die Textur mit den XZ-Koordinaten der Welt aus und multiplizieren Sie sie dann mit Albedo. </font><font style="vertical-align: inherit;">Da die Gitterlinien auf der Textur grau sind, wird das Muster in das Relief verwoben.</font></font><br><br><pre> <code class="hljs pgsql"> sampler2D _GridTex; ‚Ä¶ <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) + GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) + GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); fixed4 grid = tex2D(_GridTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz); o.Albedo = c.rgb * grid * _Color; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/972/a3e/432/972a3e4323541d1195904c9777a29e07.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Albedo multipliziert mit feinmaschigem. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir m√ºssen das Muster so skalieren, dass es mit den Zellen in der Karte √ºbereinstimmt. </font><font style="vertical-align: inherit;">Der Abstand zwischen den Zentren benachbarter Zellen betr√§gt 15, er muss verdoppelt werden, um zwei Zellen nach oben zu bewegen. </font><font style="vertical-align: inherit;">Das hei√üt, wir m√ºssen die Koordinaten des V-Gitters durch 30 teilen. Der Innenradius der Zellen betr√§gt 5‚àö3, und um zwei Zellen nach rechts zu verschieben, ben√∂tigen wir viermal so viel. </font><font style="vertical-align: inherit;">Daher ist es notwendig, die Koordinaten des U-Gitters durch 20‚àö3 zu teilen.</font></font><br><br><pre> <code class="hljs markdown"> float2 gridUV = IN.worldPos.xz; gridUV.x <span class="hljs-emphasis"><span class="hljs-emphasis">*= 1 / (4 *</span></span> 8.66025404); gridUV.y <span class="hljs-emphasis"><span class="hljs-emphasis">*= 1 / (2 *</span></span> 15.0); fixed4 grid = tex2D(_GridTex, gridUV);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/454/1ba/191/4541ba19123145c27422e2b90b52aa6f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die richtige Maschenweite. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt entsprechen die Gitterlinien den Zellen der Karte. </font><font style="vertical-align: inherit;">Wie Relief-Texturen ignorieren sie die H√∂he, sodass die Linien entlang der Klippen gespannt werden.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98a/708/906/98a7089069b6d04bc708851045c9fe7a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Projektion auf Zellen mit H√∂he. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Netzverformung ist normalerweise nicht so schlimm, insbesondere wenn Sie eine Karte aus gro√üer Entfernung betrachten.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/287/5ac/690/2875ac690eb796bf00a86b48d193aec8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mesh in der Ferne.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Netzeinschluss </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Anzeigen eines Rasters ist zwar praktisch, aber nicht immer erforderlich. </font><font style="vertical-align: inherit;">Sie sollten es beispielsweise deaktivieren, wenn Sie einen Screenshot machen. </font><font style="vertical-align: inherit;">Dar√ºber hinaus zieht es nicht jeder vor, das Raster st√§ndig zu sehen. </font><font style="vertical-align: inherit;">Machen wir es also optional. </font><font style="vertical-align: inherit;">Wir werden dem Shader die Anweisung multi_compile hinzuf√ºgen, um Optionen mit und ohne Raster zu erstellen. </font><font style="vertical-align: inherit;">Dazu verwenden wir das Schl√ºsselwort </font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die bedingte Shader-Kompilierung wird im Tutorial </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendering 5, Mehrere Lichter, beschrieben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs css"> <span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">surface</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">surf</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Standard</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">fullforwardshadows</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vertex</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:vert</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">target</span></span> 3<span class="hljs-selector-class"><span class="hljs-selector-class">.5</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">multi_compile</span></span> _ <span class="hljs-selector-tag"><span class="hljs-selector-tag">GRID_ON</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie eine Variable deklarieren, </font></font><code>grid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">weisen Sie ihr zuerst den Wert 1 zu. Infolgedessen wird das Raster deaktiviert. </font><font style="vertical-align: inherit;">Dann werden wir die Gittertextur nur f√ºr die Variante mit einem bestimmten Schl√ºsselwort abtasten </font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs mel"> fixed4 <span class="hljs-keyword"><span class="hljs-keyword">grid</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined(GRID_ON) float2 gridUV = IN.worldPos.xz; gridUV.x *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-number"><span class="hljs-number">8.66025404</span></span>); gridUV.y *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">15.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">grid</span></span> = tex2D(_GridTex, gridUV); #endif o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">grid</span></span> * _Color;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da das Schl√ºsselwort </font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht im Terrain-Shader enthalten ist, wird das Raster ausgeblendet. </font><font style="vertical-align: inherit;">Um es wieder zu aktivieren, f√ºgen wir der Benutzeroberfl√§che des Karteneditors einen Schalter hinzu. </font><font style="vertical-align: inherit;">Um dies zu erm√∂glichen, </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muss ich einen Link zum </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Material </font><font style="vertical-align: inherit;">und eine Methode zum Aktivieren oder Deaktivieren des Schl√ºsselworts erhalten </font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Material terrainMaterial; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowGrid</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> visible</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (visible) { terrainMaterial.EnableKeyword(<span class="hljs-string"><span class="hljs-string">"GRID_ON"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrainMaterial.DisableKeyword(<span class="hljs-string"><span class="hljs-string">"GRID_ON"</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d0/d53/873/7d0d53873a0aace69be804dcbf22d7ce.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Editor M√§rz Sechsecke mit Bezug auf das Material. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie der Benutzeroberfl√§che einen </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grid-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schalter hinzu </font><font style="vertical-align: inherit;">und verbinden Sie ihn mit der Methode </font></font><code>ShowGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56b/38a/6b6/56b38a6b6792eb8b89fb3936a55e9194.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gitterschalter.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Status speichern </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt im Wiedergabemodus k√∂nnen wir die Anzeige des Gitters umschalten. </font><font style="vertical-align: inherit;">Beim ersten Test wird das Gitter zun√§chst ausgeschaltet und wird sichtbar, wenn wir den Schalter einschalten. </font><font style="vertical-align: inherit;">Wenn Sie es ausschalten, verschwindet das Raster wieder. </font><font style="vertical-align: inherit;">Wenn wir jedoch den Wiedergabemodus verlassen, wenn das Raster sichtbar ist, wird es beim n√§chsten Start des Wiedergabemodus wieder eingeschaltet, obwohl der Schalter ausgeschaltet ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies liegt daran, dass wir das Schl√ºsselwort f√ºr das allgemeine </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Material √§ndern </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir bearbeiten das Material-Asset, sodass die √Ñnderung im Unity-Editor gespeichert wird. </font><font style="vertical-align: inherit;">Es wird nicht in der Baugruppe gespeichert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um das Spiel immer ohne Raster zu starten, deaktivieren wir das Schl√ºsselwort </font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Awake </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrainMaterial.DisableKeyword(<span class="hljs-string"><span class="hljs-string">"GRID_ON"</span></span>); }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bearbeitungsmodus </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir die Bewegung auf der Karte steuern m√∂chten, m√ºssen wir mit ihr interagieren. </font><font style="vertical-align: inherit;">Zumindest m√ºssen wir die Zelle als Startpunkt des Pfades ausw√§hlen. </font><font style="vertical-align: inherit;">Wenn Sie jedoch auf eine Zelle klicken, wird diese bearbeitet. </font><font style="vertical-align: inherit;">Wir k√∂nnen alle Bearbeitungsoptionen manuell deaktivieren, dies ist jedoch unpraktisch. </font><font style="vertical-align: inherit;">Au√üerdem m√∂chten wir nicht, dass Verschiebungsberechnungen w√§hrend der Kartenbearbeitung durchgef√ºhrt werden. </font><font style="vertical-align: inherit;">F√ºgen wir also einen Schalter hinzu, der bestimmt, ob wir uns im Bearbeitungsmodus befinden.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schalter bearbeiten </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie dem </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Booleschen Feld </font></font><code>editMode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Methode hinzu, die es definiert. </font><font style="vertical-align: inherit;">F√ºgen Sie dann der Benutzeroberfl√§che einen weiteren Schalter hinzu, um sie zu steuern. </font><font style="vertical-align: inherit;">Beginnen wir mit dem Navigationsmodus, dh der Bearbeitungsmodus ist standardm√§√üig deaktiviert.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> editMode; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEditMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { editMode = toggle; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1bf/19b/ace/1bf19baceed0ecfa766dbe0386ed38d3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bearbeitungsmodusschalter. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Bearbeitung wirklich zu deaktivieren, machen Sie den Anruf </font></font><code>EditCells</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">abh√§ngig von </font></font><code>editMode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { HexCell currentCell = hexGrid.GetCell(hit.point); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousCell &amp;&amp; previousCell != currentCell) { ValidateDrag(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { isDrag = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } previousCell = currentCell; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { previousCell = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Debuggen von Labels </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher haben wir keine Einheiten, um uns auf der Karte zu bewegen. </font><font style="vertical-align: inherit;">Stattdessen visualisieren wir Bewegungsentfernungen. </font><font style="vertical-align: inherit;">Dazu k√∂nnen Sie vorhandene Zellenbezeichnungen verwenden. </font><font style="vertical-align: inherit;">Daher werden sie sichtbar gemacht, wenn der Bearbeitungsmodus deaktiviert ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEditMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { editMode = toggle; hexGrid.ShowUI(!toggle); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir mit dem Navigationsmodus beginnen, sollten die Standardbezeichnungen aktiviert sein. </font><font style="vertical-align: inherit;">Derzeit </font></font><code>HexGridChunk.Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deaktiviert sie, aber er sollte dies nicht mehr tun.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); cells = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCell[HexMetrics.chunkSizeX * HexMetrics.chunkSizeZ]; <span class="hljs-comment"><span class="hljs-comment">// ShowUI(false); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/730/666/90c/73066690c998f0715fb22356a0374fed.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beschriftungen koordinieren. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Zellkoordinaten werden jetzt sofort nach dem Starten des Wiedergabemodus sichtbar. </font><font style="vertical-align: inherit;">Wir brauchen aber keine Koordinaten, wir verwenden Beschriftungen, um Entfernungen anzuzeigen. </font><font style="vertical-align: inherit;">Da hierf√ºr nur eine Zahl pro Zelle erforderlich ist, k√∂nnen Sie die Schriftgr√∂√üe erh√∂hen, damit sie besser gelesen werden k√∂nnen. </font><font style="vertical-align: inherit;">√Ñndern Sie das Fertighaus von </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Cell Label</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> so, dass Fettdruck mit der Gr√∂√üe 8 verwendet wird.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ea/008/aa0/8ea008aa075686891f8815148c70ba06.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tags mit fetter Schriftgr√∂√üe 8.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachdem Sie den Wiedergabemodus gestartet haben, werden gro√üe Tags angezeigt. </font><font style="vertical-align: inherit;">Es sind nur die ersten Koordinaten der Zelle sichtbar, der Rest wird nicht in die Beschriftung eingef√ºgt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/745/baf/016/745baf0160c2f9cf8aaae974ff285d16.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gro√üe Tags. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir die Koordinaten nicht mehr ben√∂tigen, l√∂schen wir den </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wert </font><font style="vertical-align: inherit;">in der </font><font style="vertical-align: inherit;">Zuordnung </font></font><code>label.text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Text label = Instantiate&lt;Text&gt;(cellLabelPrefab); label.rectTransform.anchoredPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(position.x, position.z); <span class="hljs-comment"><span class="hljs-comment">// label.text = cell.coordinates.ToStringOnSeparateLines(); cell.uiRect = label.rectTransform; ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen den </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Labels-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schalter </font><font style="vertical-align: inherit;">und die zugeh√∂rige Methode auch </font><font style="vertical-align: inherit;">von der Benutzeroberfl√§che entfernen </font></font><code>HexMapEditor.ShowUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public void ShowUI (bool visible) { // hexGrid.ShowUI(visible); // }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e0/4d4/652/6e04d46522e65937a9324e0f3498d480.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Methodenwechsel ist nicht mehr. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entfernungen finden </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir den markierten Navigationsmodus haben, k√∂nnen wir Entfernungen anzeigen. </font><font style="vertical-align: inherit;">Wir werden eine Zelle ausw√§hlen und dann den Abstand von dieser Zelle zu allen Zellen auf der Karte anzeigen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entfernungsanzeige </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie dem </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ganzzahlfeld </font><font style="vertical-align: inherit;">hinzu, um die Entfernung zur Zelle zu verfolgen </font></font><code>distance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es zeigt den Abstand zwischen dieser Zelle und der ausgew√§hlten an. </font><font style="vertical-align: inherit;">Daher ist sie f√ºr die ausgew√§hlte Zelle selbst Null, f√ºr den unmittelbaren Nachbarn 1 und so weiter.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn der Abstand eingestellt ist, m√ºssen wir die Zellenbezeichnung aktualisieren, um ihren Wert anzuzeigen. </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hat einen Verweis auf das </font></font><code>RectTransform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UI-Objekt. </font><font style="vertical-align: inherit;">Wir m√ºssen ihn anrufen </font></font><code>GetComponent&lt;Text&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um in die Zelle zu gelangen. </font><font style="vertical-align: inherit;">√úberlegen Sie, was </font></font><code>Text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sich im Namespace </font></font><code>UnityEngine.UI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">befindet. Verwenden Sie ihn daher am Anfang des Skripts.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateDistanceLabel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Text label = uiRect.GetComponent&lt;Text&gt;(); label.text = distance.ToString(); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sollten wir nicht einen direkten Link zur Textkomponente behalten?</font></font></b> <div class="spoiler_text"> ,   .     ,       ,  ,    .   ,      . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Legen Sie die allgemeine Eigenschaft f√ºr den Empfang und die Entfernung zur Zelle sowie die Aktualisierung ihrer Beschriftung fest. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Distance { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distance; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { distance = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; UpdateDistanceLabel(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie der </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allgemeinen Methode </font></font><code>FindDistancesTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Zellenparameter hinzu. </font><font style="vertical-align: inherit;">Im Moment setzen wir einfach den Nullabstand zu jeder Zelle.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindDistancesTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn der Bearbeitungsmodus nicht aktiviert ist, </font></font><code>HexMapEditor.HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rufen </font><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">eine neue Methode mit der aktuellen Zelle auf.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { hexGrid.FindDistancesTo(currentCell); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Abst√§nde zwischen Koordinaten </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Navigationsmodus zeigen alle Zellen nach dem Ber√ºhren einer von ihnen Null an. </font><font style="vertical-align: inherit;">Aber nat√ºrlich sollten sie den wahren Abstand zur Zelle anzeigen. </font><font style="vertical-align: inherit;">Um den Abstand zu ihnen zu berechnen, k√∂nnen wir die Koordinaten der Zelle verwenden. </font><font style="vertical-align: inherit;">Nehmen Sie daher an, dass es </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine Methode hat </font></font><code>DistanceTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und verwenden Sie sie in </font></font><code>HexGrid.FindDistancesTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindDistancesTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = cell.coordinates.DistanceTo(cells[i].coordinates); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie nun der </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode hinzu </font></font><code>DistanceTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Er muss seine eigenen Koordinaten mit den Koordinaten eines anderen Satzes vergleichen. </font><font style="vertical-align: inherit;">Beginnen wir nur mit der Messung von X und subtrahieren die X-Koordinaten voneinander.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DistanceTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCoordinates other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x - other.x; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als Ergebnis erhalten wir einen Versatz entlang X relativ zur ausgew√§hlten Zelle. </font><font style="vertical-align: inherit;">Die Abst√§nde k√∂nnen jedoch nicht negativ sein, daher m√ºssen Sie die Koordinatendifferenz X modulo zur√ºckgeben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x &lt; other.x ? other.x - x : x - other.x;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fdb/c62/16c/fdbc6216c12ae4a38ff7edaba203116e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entfernungen entlang X.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir erhalten also nur dann die richtigen Entfernungen, wenn wir nur eine Dimension ber√ºcksichtigen. </font><font style="vertical-align: inherit;">Es gibt jedoch drei Dimensionen in einem Sechseckgitter. </font><font style="vertical-align: inherit;">Addieren wir also die Abst√§nde f√ºr alle drei Dimensionen und sehen, was es uns gibt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y) + (z &lt; other.z ? other.z - z : z - other.z);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffd/170/ac0/ffd170ac0b133a9b589e3dea9d6fd2b3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Summe der XYZ-Entfernungen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es stellt sich heraus, dass wir die doppelte Entfernung bekommen. </font><font style="vertical-align: inherit;">Das hei√üt, um den richtigen Abstand zu erhalten, muss dieser Betrag in zwei H√§lften geteilt werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y) + (z &lt; other.z ? other.z - z : z - other.z)) / <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9bd/37d/353/9bd37d3535471f748d31be64ce897c17.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Echte Entfernungen.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum ist die Summe doppelt so gro√ü wie die Entfernung?</font></font></b> <div class="spoiler_text">  ,       .      ,  (1, ‚àí3, 2).       .      ,       .      .   ,            .         . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09e/533/197/09e533197dfc487db1c5b91f92fd6ba8.png"></div><br> <i> .</i> </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arbeite mit Hindernissen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die von uns berechneten Abst√§nde entsprechen den k√ºrzesten Wegen von der ausgew√§hlten Zelle zu jeder anderen Zelle. </font><font style="vertical-align: inherit;">Wir k√∂nnen keinen k√ºrzeren Weg finden. </font><font style="vertical-align: inherit;">Diese Pfade sind jedoch garantiert korrekt, wenn die Route nichts blockiert. </font><font style="vertical-align: inherit;">Klippen, Wasser und andere Hindernisse k√∂nnen uns herumlaufen lassen. </font><font style="vertical-align: inherit;">Vielleicht k√∂nnen einige Zellen √ºberhaupt nicht erreicht werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um Hindernisse zu umgehen, m√ºssen wir einen anderen Ansatz verwenden, anstatt einfach den Abstand zwischen den Koordinaten zu berechnen. </font><font style="vertical-align: inherit;">Wir k√∂nnen nicht mehr jede Zelle einzeln untersuchen. </font><font style="vertical-align: inherit;">Wir m√ºssen die Karte durchsuchen, bis wir jede Zelle gefunden haben, die erreicht werden kann.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suchvisualisierung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Kartensuche ist ein iterativer Prozess. </font><font style="vertical-align: inherit;">Um zu verstehen, was wir tun, w√§re es hilfreich, jede Phase der Suche zu sehen. </font><font style="vertical-align: inherit;">Wir k√∂nnen dies tun, indem wir den Suchalgorithmus in eine Coroutine verwandeln, f√ºr die wir einen Suchraum ben√∂tigen </font></font><code>System.Collections</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die Aktualisierungsrate von 60 Iterationen pro Sekunde ist klein genug, um zu sehen, was passiert, und die Suche auf einer kleinen Karte hat nicht allzu viel Zeit in Anspruch genommen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindDistancesTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { StartCoroutine(Search(cell)); } <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { WaitForSeconds delay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">60f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; cells[i].Distance = cell.coordinates.DistanceTo(cells[i].coordinates); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir m√ºssen sicherstellen, dass jeweils nur eine Suche aktiv ist. </font><font style="vertical-align: inherit;">Bevor wir eine neue Suche starten, stoppen wir daher alle Coroutinen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindDistancesTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { StopAllCoroutines(); StartCoroutine(Search(cell)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Au√üerdem m√ºssen wir die Suche abschlie√üen, wenn wir eine neue Karte laden. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { StopAllCoroutines(); ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Breitensuche </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Noch bevor wir mit der Suche beginnen, wissen wir, dass der Abstand zur ausgew√§hlten Zelle Null ist. Und nat√ºrlich betr√§gt die Entfernung zu allen Nachbarn 1, wenn sie erreichbar sind. Dann k√∂nnen wir uns einen dieser Nachbarn ansehen. Diese Zelle hat h√∂chstwahrscheinlich ihre eigenen Nachbarn, die erreicht werden k√∂nnen und f√ºr die die Entfernung noch nicht berechnet wurde. Wenn ja, sollte der Abstand zu diesen Nachbarn 2 betragen. Wir k√∂nnen diesen Vorgang f√ºr alle Nachbarn in einem Abstand von 1 wiederholen. Danach wiederholen wir ihn f√ºr alle Nachbarn in einem Abstand von 2. Und so weiter, bis wir alle Zellen erreichen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das hei√üt, zuerst finden wir alle Zellen in einem Abstand von 1, dann finden wir alles in einem Abstand von 2, dann in einem Abstand von 3 und so weiter, bis wir fertig sind. </font><font style="vertical-align: inherit;">Dies stellt sicher, dass wir den kleinsten Abstand zu jeder erreichbaren Zelle finden. </font><font style="vertical-align: inherit;">Dieser Algorithmus wird als Breitensuche bezeichnet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit es funktioniert, m√ºssen wir wissen, ob wir den Abstand zur Zelle bereits bestimmt haben. </font><font style="vertical-align: inherit;">Zu diesem Zweck werden Zellen h√§ufig in einer Sammlung abgelegt, die als fertige oder beiliegende Gruppe bezeichnet wird. </font><font style="vertical-align: inherit;">Wir k√∂nnen jedoch den Abstand zur Zelle festlegen, </font></font><code>int.MaxValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um anzuzeigen, dass wir sie noch nicht besucht haben. </font><font style="vertical-align: inherit;">Wir m√ºssen dies f√ºr alle Zellen tun, bevor wir eine Suche durchf√ºhren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen dies auch verwenden, um alle nicht besuchten Zellen durch √Ñndern auszublenden </font></font><code>HexCell.UpdateDistanceLabel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Danach beginnen wir jede Suche auf einer leeren Karte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateDistanceLabel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Text label = uiRect.GetComponent&lt;Text&gt;(); label.text = distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue ? <span class="hljs-string"><span class="hljs-string">""</span></span> : distance.ToString(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als n√§chstes m√ºssen wir die Zellen verfolgen, die besucht werden m√ºssen, und die Reihenfolge, in der sie besucht werden. </font><font style="vertical-align: inherit;">Eine solche Sammlung wird oft als Grenze oder offene Menge bezeichnet. </font><font style="vertical-align: inherit;">Wir m√ºssen nur die Zellen in der Reihenfolge verarbeiten, in der wir sie getroffen haben. </font><font style="vertical-align: inherit;">Dazu k√∂nnen Sie die Warteschlange verwenden </font></font><code>Queue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die Teil des Namespace ist </font></font><code>System.Collections.Generic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die ausgew√§hlte Zelle wird als erste in diese Warteschlange gestellt und hat einen Abstand von 0.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } WaitForSeconds delay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">60f</span></span>); Queue&lt;HexCell&gt; frontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Queue&lt;HexCell&gt;(); cell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; frontier.Enqueue(cell); <span class="hljs-comment"><span class="hljs-comment">// for (int i = 0; i &lt; cells.Length; i++) { // yield return delay; // cells[i].Distance = // cell.coordinates.DistanceTo(cells[i].coordinates); // } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Von diesem Moment an f√ºhrt der Algorithmus die Schleife aus, w√§hrend sich etwas in der Warteschlange befindet. </font><font style="vertical-align: inherit;">Bei jeder Iteration wird die vorderste Zelle aus der Warteschlange abgerufen.</font></font><br><br><pre> <code class="cs hljs"> frontier.Enqueue(cell); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (frontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; HexCell current = frontier.Dequeue(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt haben wir die aktuelle Zelle, die sich in beliebiger Entfernung befinden kann. </font><font style="vertical-align: inherit;">Als n√§chstes m√ºssen wir alle Nachbarn einen Schritt weiter von der ausgew√§hlten Zelle entfernt zur Warteschlange hinzuf√ºgen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (frontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; HexCell current = frontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { neighbor.Distance = current.Distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; frontier.Enqueue(neighbor); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir sollten jedoch nur die Zellen hinzuf√ºgen, denen noch kein Abstand zugewiesen wurde. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = current.Distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; frontier.Enqueue(neighbor); }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Breite Suche.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vermeiden Sie Wasser </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir sichergestellt haben, dass die Breitensuche die richtigen Entfernungen auf der monotonen Karte findet, k√∂nnen wir beginnen, Hindernisse hinzuzuf√ºgen. </font><font style="vertical-align: inherit;">Dies kann erreicht werden, indem das Hinzuf√ºgen von Zellen zur Warteschlange verweigert wird, wenn bestimmte Bedingungen erf√ºllt sind. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tats√§chlich √ºberspringen wir bereits einige Zellen: diejenigen, die nicht existieren, und diejenigen, zu denen wir bereits die Entfernung angegeben haben. </font><font style="vertical-align: inherit;">Schreiben wir den Code neu, sodass wir in diesem Fall die Nachbarn explizit √ºberspringen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.Distance != <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } neighbor.Distance = current.Distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; frontier.Enqueue(neighbor); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns auch alle Zellen √ºberspringen, die sich unter Wasser befinden. </font><font style="vertical-align: inherit;">Dies bedeutet, dass wir bei der Suche nach den k√ºrzesten Entfernungen nur Bewegungen am Boden ber√ºcksichtigen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.Distance != <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entfernungen ohne Bewegung durch Wasser. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Algorithmus findet immer noch die k√ºrzesten Entfernungen, vermeidet jetzt jedoch alles Wasser. </font><font style="vertical-align: inherit;">Daher gewinnen Unterwasserzellen niemals Abstand, wie isolierte Landfl√§chen. </font><font style="vertical-align: inherit;">Die Unterwasserzelle erh√§lt nur dann eine Entfernung, wenn sie ausgew√§hlt ist.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vermeiden Sie Klippen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die M√∂glichkeit eines Besuchs bei einem Nachbarn zu bestimmen, k√∂nnen wir auch die Art der Rippe verwenden. </font><font style="vertical-align: inherit;">Zum Beispiel k√∂nnen Sie Klippen den Weg blockieren lassen. </font><font style="vertical-align: inherit;">Wenn Sie Bewegung an H√§ngen zulassen, k√∂nnen die Zellen auf der anderen Seite der Klippe nur auf anderen Pfaden erreicht werden. </font><font style="vertical-align: inherit;">Daher k√∂nnen sie sich in sehr unterschiedlichen Abst√§nden befinden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.GetEdgeType(neighbor) == HexEdgeType.Cliff) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entfernungen ohne Klippen zu √ºberqueren. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reisekosten </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen Zellen und Kanten vermeiden, aber diese Optionen sind bin√§r. </font><font style="vertical-align: inherit;">Man kann sich vorstellen, dass es einfacher ist, in einige Richtungen zu navigieren als in andere. </font><font style="vertical-align: inherit;">In diesem Fall wird die Entfernung in Arbeit oder Zeit gemessen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schnelle Stra√üen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist logisch, dass das Fahren auf Stra√üen einfacher und schneller ist. Lassen Sie uns also die Kreuzung von Kanten mit Stra√üen kosteng√ºnstiger gestalten. </font><font style="vertical-align: inherit;">Da wir ganzzahlige Werte verwenden, um die Bewegungsentfernung festzulegen, belaufen sich die Kosten f√ºr das Bewegen entlang der Stra√üen auf 1, und die Kosten f√ºr das √úberqueren anderer Kanten steigen auf 10. Dies ist ein gro√üer Unterschied, sodass wir sofort feststellen k√∂nnen, ob wir die richtigen Ergebnisse erzielen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += <span class="hljs-number"><span class="hljs-number">10</span></span>; } neighbor.Distance = distance;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/899/225/6e3/8992256e34fef206c7282bc31a72a573.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stra√üen mit falschen Entfernungen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rahmensortierung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leider stellt sich heraus, dass die Breitensuche nicht mit variablen Umzugskosten funktionieren kann. </font><font style="vertical-align: inherit;">Er geht davon aus, dass Zellen in der Reihenfolge zunehmender Entfernung zur Grenze hinzugef√ºgt werden, und f√ºr uns ist dies nicht mehr relevant. </font><font style="vertical-align: inherit;">Wir brauchen eine Priorit√§tswarteschlange, dh eine Warteschlange, die sich selbst sortiert. </font><font style="vertical-align: inherit;">Es gibt keine Warteschlangen mit Standardpriorit√§t, da Sie sie nicht so programmieren k√∂nnen, dass sie f√ºr alle Situationen geeignet sind. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen unsere eigene Priorit√§tswarteschlange erstellen, diese jedoch f√ºr das zuk√ºnftige Lernprogramm optimieren. </font><font style="vertical-align: inherit;">Im Moment ersetzen wir einfach die Warteschlange durch eine Liste mit einer Methode </font></font><code>Sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> List&lt;HexCell&gt; frontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexCell&gt;(); cell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; frontier.Add(cell); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (frontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; HexCell current = frontier[<span class="hljs-number"><span class="hljs-number">0</span></span>]; frontier.RemoveAt(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ neighbor.Distance = distance; frontier.Add(neighbor); } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kann ich ListPool &lt;HexCell&gt; nicht verwenden?</font></font></b> <div class="spoiler_text"> , ,  .       ,  ,        . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit der Rand korrekt ist, m√ºssen wir ihn sortieren, nachdem wir ihm eine Zelle hinzugef√ºgt haben. </font><font style="vertical-align: inherit;">Tats√§chlich k√∂nnen wir die Sortierung verschieben, bis alle Nachbarn der Zelle hinzugef√ºgt wurden, aber ich wiederhole, bis uns Optimierungen nicht mehr interessieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir wollen die Zellen nach Entfernung sortieren. </font><font style="vertical-align: inherit;">Dazu m√ºssen wir die Listensortierungsmethode mit einem Link zu der Methode aufrufen, die diesen Vergleich durchf√ºhrt.</font></font><br><br><pre> <code class="cs hljs"> frontier.Add(neighbor); frontier.Sort((x, y) =&gt; x.Distance.CompareTo(y.Distance));</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie funktioniert diese Sortiermethode?</font></font></b> <div class="spoiler_text">     .     ,       .        . <br><br><pre> <code class="cs hljs"> frontier.Sort(CompareDistances); ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareDistances</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell x, HexCell y</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x.Distance.CompareTo(y.Distance); }</code> </pre> </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ca/f5d/f85/2caf5df85335f7997694522b7885d882.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der sortierte Rand ist immer noch falsch.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Grenzaktualisierung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir mit dem Sortieren der Grenze begonnen hatten, erzielten wir bessere Ergebnisse, aber es gibt immer noch Fehler. Dies liegt daran, dass beim Hinzuf√ºgen einer Zelle zum Rand nicht unbedingt der k√ºrzeste Abstand zu dieser Zelle gefunden wird. Dies bedeutet, dass wir jetzt keine Nachbarn mehr √ºberspringen k√∂nnen, denen bereits eine Entfernung zugewiesen wurde. Stattdessen m√ºssen wir pr√ºfen, ob wir einen k√ºrzeren Weg gefunden haben. Wenn ja, m√ºssen wir den Abstand zum Nachbarn √§ndern, anstatt ihn an der Grenze hinzuzuf√ºgen.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.GetEdgeType(neighbor) == HexEdgeType.Cliff) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += <span class="hljs-number"><span class="hljs-number">10</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; frontier.Add(neighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance &lt; neighbor.Distance) { neighbor.Distance = distance; } frontier.Sort((x, y) =&gt; x.Distance.CompareTo(y.Distance));</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die richtigen Abst√§nde. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt, da wir die richtigen Entfernungen haben, werden wir anfangen, die Kosten f√ºr den Umzug zu ber√ºcksichtigen. </font><font style="vertical-align: inherit;">M√∂glicherweise stellen Sie fest, dass die Abst√§nde zu einigen Zellen anfangs zu gro√ü sind, aber korrigiert werden, wenn sie vom Rand entfernt werden. </font><font style="vertical-align: inherit;">Dieser Ansatz wird als Dijkstra-Algorithmus bezeichnet und ist nach dem ersten von Edsger Dijkstra erfundenen benannt.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pisten </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir wollen uns nicht nur auf unterschiedliche Kosten f√ºr Stra√üen beschr√§nken. </font><font style="vertical-align: inherit;">Beispielsweise k√∂nnen Sie die Kosten f√ºr das √úberqueren flacher Kanten ohne Stra√üen auf 5 reduzieren, sodass H√§nge ohne Stra√üen einen Wert von 10 haben.</font></font><br><br><pre> <code class="cs hljs"> HexEdgeType edgeType = current.GetEdgeType(neighbor); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edgeType == HexEdgeType.Cliff) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fd/8e1/1b5/8fd8e11b5a95d0e35ce03d1eb8bc32a0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Pisten zu √ºberwinden, m√ºssen Sie mehr arbeiten, und die Stra√üen sind immer schnell.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reliefobjekte </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei Vorhandensein von Reliefobjekten k√∂nnen wir Kosten hinzuf√ºgen. </font><font style="vertical-align: inherit;">In vielen Spielen ist es beispielsweise schwieriger, durch W√§lder zu navigieren. </font><font style="vertical-align: inherit;">In diesem Fall f√ºgen wir einfach alle Objektebenen zur Entfernung hinzu. </font><font style="vertical-align: inherit;">Und auch hier beschleunigt die Stra√üe alles.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; distance += neighbor.UrbanLevel + neighbor.FarmLevel + neighbor.PlantLevel; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f6e/ef4/b2b/f6eef4b2bba378bd83daf9377f9a1603.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objekte werden langsamer, wenn keine Stra√üe vorhanden ist.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die W√§nde </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns zum Schluss die W√§nde ber√ºcksichtigen. </font><font style="vertical-align: inherit;">W√§nde sollten die Bewegung blockieren, wenn die Stra√üe nicht durch sie f√ºhrt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.Walled != neighbor.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; distance += neighbor.UrbanLevel + neighbor.FarmLevel + neighbor.PlantLevel; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b3/9cd/7a9/1b39cd7a97483749c25474622ed8326b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die W√§nde lassen uns nicht passieren, Sie m√ºssen nach dem Tor suchen. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425919/">https://habr.com/ru/post/de425919/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425905/index.html">So schreiben Sie Assembler-Code mit √ºberlappenden Anweisungen (eine andere Technik zum Verschleiern von Bytecode)</a></li>
<li><a href="../de425907/index.html">Wir machen ein maschinelles Lernprojekt in Python. Teil 2</a></li>
<li><a href="../de425911/index.html">√úbertragen Sie Cloud CRM in die Box-Version</a></li>
<li><a href="../de425915/index.html">Wie grenz√ºberschreitende Kommunikation Ampeln ersetzen und den Weg zur Arbeit verk√ºrzen kann</a></li>
<li><a href="../de425917/index.html">Der Justizk√§mpfer verhindert, dass Waymo die Schl√ºssel-Lidar-Technologie patentiert</a></li>
<li><a href="../de425921/index.html">.NET Community-Meeting auf CLRium # 4 + online</a></li>
<li><a href="../de425923/index.html">25 Jahre altes Schicksal</a></li>
<li><a href="../de425925/index.html">3D-Druck bei der Erstellung von Layouts am Beispiel des STUDIO 911</a></li>
<li><a href="../de425927/index.html">Wetterstation auf Arduino von A bis Z. Teil 2</a></li>
<li><a href="../de425929/index.html">Google hat den Kampf um den milliardsten Pentagon-Vertrag aufgegeben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>