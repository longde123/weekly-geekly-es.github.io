<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🤝‍👨🏿 🍨 👨🏾‍🎓 Pengumpul Sampah Homemade untuk OpenJDK 🐍 🕴🏼 😨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ini adalah terjemahan dari artikel oleh Alexey Shipilev "Do It Yourself (OpenJDK) Pengumpul Sampah" , yang diterbitkan dengan persetujuan penulis. Lap...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengumpul Sampah Homemade untuk OpenJDK</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/443250/"><blockquote>  Ini adalah terjemahan dari artikel oleh Alexey Shipilev <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Do It Yourself (OpenJDK) Pengumpul Sampah"</a> , yang diterbitkan dengan persetujuan penulis.  Laporkan kesalahan ketik dan bug lain di PM - kami akan memperbaikinya. </blockquote><p>  Proses menciptakan sesuatu dalam runtime adalah latihan yang menyenangkan.  Setidaknya pembuatan versi pertama!  Untuk membangun subsistem runtime yang andal, berkinerja tinggi, gagal-aman, perilaku yang dapat dengan mudah diamati dan didebug, adalah tugas yang sangat, sangat sulit. </p><br><p>  Membuat pengumpul sampah sederhana itu sangat sederhana, dan sekarang saya ingin melakukan ini di artikel ini.  Roman Kennke di FOSDEM 2019 membuat ceramah dan demo berjudul <a href="">"Menulis GC dalam 20 Menit,"</a> menggunakan versi tambalan ini sebelumnya.  Terlepas dari kenyataan bahwa kode yang diterapkan di sana menunjukkan banyak dan banyak dikomentari, ada kebutuhan untuk deskripsi tingkat tinggi yang baik tentang apa yang terjadi - ini adalah bagaimana artikel ini muncul. </p><br><p>  Pemahaman dasar tentang pekerjaan pemulung akan sangat membantu dalam memahami apa yang ditulis di sini.  Artikel ini akan menggunakan spesifik dan ide dalam implementasi spesifik dari HotSpot, tetapi tidak akan ada kursus pengantar tentang desain GC di sini.  Ambil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Buku Pegangan GC</a> dan bacalah bab-bab pertama tentang dasar-dasar GC, dan bahkan lebih cepat akan memulai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel Wikipedia</a> . </p><br><p><img src="https://habrastorage.org/webt/4v/1i/4y/4v1i4yrxpcef-vvvkknzfuhmt-w.jpeg"></p><a name="habracut"></a><br><h1 id="soderzhanie">  Isi </h1><br><div class="spoiler">  <b class="spoiler_title">Teks tersembunyi</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1. Terdiri dari apa GC</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Epsilon gc</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1.1.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alokasi memori</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1.1.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hambatan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1.1.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memantau koneksi</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rantime dan GC</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1.2.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Elemen root</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1.2.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penjelajahan Objek</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1.2.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemindahan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1.2.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Data penanda</a> </li></ul></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2. Rencana umum</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3. Implementasi inti GC</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Prolog</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menandai</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hitung alamat baru</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perbaiki pointer</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kami memindahkan objek</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3.6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Epilog</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4. Hubungkan GC ke VM</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Root Traversal</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Titik aman dan menghentikan dunia</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kesalahan Alokasi Memori</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">5. Majelis</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">6. Pengujian</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">7. Kinerja</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">8. Apa selanjutnya?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">9. Kesimpulan</a> </li></ul></div></div><br><a name="1"></a><br><h1 id="1-iz-chego-sostoit-gc">  1. Terdiri dari apa GC </h1><br><p>  Sekarang setelah banyak GC yang berbeda telah ditulis, cukup mudah untuk membuatnya sendiri - banyak elemen yang sudah ditulis dapat (kembali) digunakan untuk mengalihkan beberapa kekhawatiran tentang detail implementasi ke kode yang terbukti dan teruji. </p><br><a name="11"></a><br>
<h2 id="11-epsilon-gc">  1.1.  Epsilon gc </h2><br><p>  OpenJDK 11 memperkenalkan JEP 318 baru: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Epsilon: Seorang Kolektor Sampah No-Op (Eksperimental)</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"</a>  Tugasnya adalah untuk menyediakan implementasi minimal untuk kasus ketika membebaskan memori tidak diperlukan atau bahkan dilarang.  JEP membahas secara lebih rinci mengapa ini mungkin berguna. </p><br><p>  Dari sudut pandang implementasi, "pengumpul sampah" adalah nama yang buruk, akan lebih tepat untuk menggunakan istilah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"manajer memori otomatis"</a> , yang bertanggung jawab untuk mengalokasikan dan membebaskan memori.  Epsilon GC hanya mengimplementasikan "alokasi", dan tidak berurusan dengan "rilis" sama sekali.  Oleh karena itu, Anda dapat mengambil Epsilon GC dan mulai menerapkan algoritma "rilis" dari awal. </p><br><a name="111"></a><br><h3 id="111-vydelenie-pamyati">  1.1.1.  Alokasi memori </h3><br><p>  Bagian yang paling berkembang dari Epsilon GC <a href="">bertanggung jawab untuk mengalokasikan memori</a> .  Ini melayani permintaan eksternal untuk mengalokasikan memori ukuran sewenang-wenang dan membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Thread-Local Allocation Buffer (TLAB) dari</a> ukuran yang diinginkan.  Implementasi itu sendiri berusaha untuk tidak memperpanjang TLAB terlalu banyak, karena tidak akan ada memori bebas dan tidak ada yang akan mengembalikan byte yang hilang. </p><br><a name="112"></a><br><h3 id="112-barery">  1.1.2.  Hambatan </h3><br><p>  Beberapa pengumpul sampah memerlukan interaksi dengan aplikasi untuk mempertahankan invarian GC, memaksa runtime dan aplikasi untuk membuat <em>hambatan yang</em> disebut ketika mencoba mengakses heap.  Ini berlaku untuk semua kolektor multi-utas, serta bagi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">banyak kolektor dari generasi ke generasi</a> dan menghentikan dunia. </p><br><p>  Epsilon tidak memerlukan penghalang, tetapi runtime dan kompiler masih ingin <em>tahu</em> bahwa penghalang tidak melakukan apa-apa.  Penanganannya setiap saat di mana saja bisa melelahkan.  Untungnya, dimulai dengan OpenJDK 11, ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JEP-304 baru: "Garbage Collection Interface"</a> , yang membuatnya jauh, jauh lebih mudah untuk memasukkan hambatan.  Secara khusus, <a href="">penghalang yang ditetapkan dalam Epsilon kosong</a> , dan semua pekerjaan sepele - save, load, CAS, arraycopy - dapat didelegasikan ke implementasi hambatan sepele dari superclass yang ada.  Jika Anda membuat GC yang juga tidak memerlukan penghalang, Anda bisa menggunakan kembali kode dari Epsilon. </p><br><a name="113"></a><br><h3 id="113-podklyuchenie-k-monitoringu">  1.1.3.  Memantau koneksi </h3><br><p>  Bagian membosankan terakhir dari implementasi GC adalah kaitan dengan sekelompok mekanisme pemantauan di dalam JVM: MX-bins, perintah diagnostik, dll. Harus bekerja.  Epsilon <a href="">sudah melakukan</a> semua ini untukmu. </p><br><a name="12"></a><br><h2 id="12-rantaym-i-gc">  1.2.  Rantime dan GC </h2><br><a name="121"></a><br><h3 id="121-kornevye-elementy">  1.2.1.  Elemen root </h3><br><p>  Pengumpul sampah, dalam kasus umum, perlu tahu apa tepatnya di runtime Java yang memiliki referensi tumpukan.  Elemen-elemen root ini, disebut root <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GC</a> , dapat menjadi slot pada stream stream dan variabel lokal (termasuk yang ditemukan dalam kode yang dikompilasi JIT!), Kelas asli dan pemuat kelas, referensi di JNI, dan sebagainya.  Upaya untuk mengidentifikasi elemen-elemen ini bisa sangat kompleks dan membosankan.  Tetapi di Hotspot, mereka semua dilacak menggunakan subsistem VM yang sesuai, sehingga Anda bisa belajar bagaimana implementasi GC yang ada bekerja dengannya.  Lebih jauh dalam teks kita akan melihatnya. </p><br><a name="122"></a><br><h3 id="122-obhod-obektov">  1.2.2.  Penjelajahan Objek </h3><br><p> Pengumpul sampah harus memotong tautan keluar di objek Java.  Operasi ini ditemukan di mana-mana, jadi bagian umum dari runtime menyediakan solusi yang sudah jadi, Anda tidak perlu menulis apa pun sendiri.  Di bawah ini akan ada bagian dengan implementasi spesifik, dan di sana Anda dapat menemukan, misalnya, memanggil <code>obj→oop_iterate</code> . </p><br><a name="123"></a><br><h3 id="123-peremescheniya">  1.2.3.  Pemindahan </h3><br><p>  Pengumpul sampah yang bergerak perlu menuliskan alamat baru dari objek yang dipindahkan di suatu tempat.  Ada beberapa tempat di mana Anda dapat menulis <em>data penerusan</em> ini. </p><br><ol><li>  Anda dapat menggunakan kembali <a href="">"kata penanda" pada objek itu sendiri</a> (Serial, Paralel, dll.).  Setelah dunia berhenti, semua akses ke objek dikendalikan, dan dijamin bahwa tidak ada utas Java yang dapat melihat data sementara yang kami putuskan untuk dimasukkan dalam kata penanda.  Anda dapat menggunakannya kembali untuk menyimpan data penerusan. </li><li>  Anda dapat mempertahankan tabel gerakan asli yang terpisah ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ZGC</a> , C4, dan lainnya).  Ini sepenuhnya mengisolasi GC dari runtime dan sisa aplikasi, karena hanya GC yang tahu tentang keberadaan tabel seperti itu.  Perakit yang kompetitif biasanya hanya menggunakan skema seperti itu - mereka tidak ingin menderita dengan banyak masalah yang tidak perlu. </li><li>  Anda dapat menambahkan kata lain ke objek ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Shenandoah</a> dan lainnya).  Kombinasi dari dua pendekatan sebelumnya tidak hanya memungkinkan runtime dan aplikasi untuk bekerja dengan header yang ada tanpa masalah, tetapi juga menyimpan data penerusan. </li></ol><br><a name="124"></a><br><h3 id="124-markernye-dannye">  1.2.4.  Data penanda </h3><br><p>  Pengumpul sampah perlu menulis <em>data penandaan di</em> suatu tempat.  Dan lagi, ada beberapa cara untuk menyelamatkan mereka: </p><br><ol><li>  Anda dapat menggunakan kembali kata penanda di objek itu sendiri (Serial, Paralel, dll.).  Sekali lagi, dalam mode berhenti dunia, Anda dapat menggunakan bit dalam kata penanda untuk menyandikan fakta label.  Lebih lanjut, jika Anda perlu berkeliling semua benda hidup, kita pergi bersama tumpukan, objek demi objek - ini dimungkinkan karena fakta bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tumpukan itu dapat diuraikan</a> . </li><li>  Anda dapat mempertahankan struktur terpisah untuk menyimpan data penandaan (G1, Shenandoah, dll.).  Ini biasanya dilakukan dengan menggunakan <a href="">bitmap terpisah</a> , yang memetakan setiap N byte dari heap ke 1 bit kartu.  Biasanya, objek Java <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">disejajarkan oleh 8 byte</a> , sehingga kartu memetakan setiap 64 bit dari tumpukan ke 1 bit kartu, menempati 1/64 dari ukuran tumpukan di memori asli.  Overhead ini terbayar dengan baik ketika memindai tumpukan untuk keberadaan benda hidup, terutama yang jarang: melewati peta seringkali jauh lebih cepat daripada memotong tumpukan yang dibongkar objek demi objek. </li><li>  Encode label menjadi tautan sendiri (ZGC, C4 dan lainnya).  Ini membutuhkan koordinasi dengan aplikasi, maka Anda perlu memotong semua label ini dari tautan atau melakukan beberapa trik lain untuk menjaga kebenaran.  Dengan kata lain, kita membutuhkan penghalang atau pekerjaan tambahan dari GC. </li></ol><br><a name="2"></a><br><h1 id="2-obschiy-plan">  2. Rencana umum </h1><br><p>  Kemungkinan besar, yang paling mudah diterapkan di atas Epsilon adalah Mark-Compact, dengan gaya LISP2.  Ide dasar dari GC ini dijelaskan baik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di Wikipedia</a> maupun <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam GC Handbook</a> (bab 3.2).  Sketsa algoritme akan ada di bagian dengan implementasi di bawah ini, tetapi saya sangat menyarankan membaca sedikit Wikipedia atau Buku Pegangan GC untuk memahami apa yang akan kita lakukan. </p><br><p>  Algoritma yang dimaksud adalah GC <em>penggeser</em> : objek bergerak bergerak dalam larik ke awal tumpukan.  Ini memiliki pro dan kontra: </p><br><ul><li>  Ini mempertahankan urutan alokasi memori.  Ini sangat baik untuk mengendalikan tata letak dalam memori, jika itu penting bagi Anda (control freaks, saatnya Anda!).  Kelemahannya adalah Anda tidak akan mendapatkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lokasi tautan otomatis</a> seperti ini. </li><li>  Kompleksitasnya adalah O (N) dari jumlah objek.  Namun, linearitas ada harganya: GC diperlukan untuk mem-bypass sekelompok 4 kali untuk setiap siklus build. </li><li>  Tidak memerlukan memori bebas di heap!  Tidak perlu menyimpan memori pada heap untuk mengevakuasi objek hidup, sehingga Anda bahkan dapat bekerja dengan heap yang dilampaui 99. (9)%.  Jika kita mengambil ide-ide lain dari pengumpul sederhana, misalnya, seorang pemulung dengan semi-ruang (semi-space scavenger), kita harus sedikit menulis ulang presentasi tumpukan dan menyimpan sedikit ruang untuk evakuasi, tetapi ini berada di luar cakupan latihan ini. </li><li>  Jika Anda bekerja sedikit tentang masalah ini, Anda dapat mencapai nol memori dan konsumsi waktu selama periode ketika GC tidak aktif.  Itu dimulai pada memori dalam keadaan acak, dan berhenti, secara signifikan memadatkannya.  Ini sangat cocok dengan cara kerja Epsilon: ia hanya menyorot tepat setelah objek terakhir.  Ini juga minus: beberapa benda mati di awal tumpukan menyebabkan sejumlah besar gerakan. </li><li>  Hanya saja tidak memerlukan hambatan baru, Anda dapat menggunakan kembali <code>EpsilonBarrierSet</code> apa adanya. </li></ul><br><p>  Untuk kesederhanaan, implementasi GC akan menggunakan perhentian penuh dunia (stop-the-world, STW), ia tidak akan memiliki generasi atau multithreading.  Untuk kasus ini, masuk akal untuk menggunakan bitmap untuk menyimpan tanda dan menggunakan kembali kata penanda untuk menyimpan data pergerakan. </p><br><a name="3"></a><br><h1 id="3-realizaciya-yadra-gc">  3. Implementasi inti GC </h1><br><p>  Membaca dan memahami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">keseluruhan implementasi</a> mungkin terlalu rumit untuk orang yang tidak tahu apa-apa.  Di bagian ini, kita akan memahaminya langkah demi langkah. </p><br><a name="31"></a><br><h2 id="31-prolog">  3.1.  Prolog </h2><br><p>  Pengumpul sampah biasanya perlu melakukan beberapa hal untuk mempersiapkan pengumpulannya.  Baca komentar, mereka harus berbicara sendiri: </p><br><pre> <code class="cpp hljs">{ GCTraceTime(Info, gc) time(<span class="hljs-string"><span class="hljs-string">"Step 0: Prologue"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      .      //   :   ,   ,  // «»   ,      //   ,     . if (!os::commit_memory((char*)_bitmap_region.start(), _bitmap_region.byte_size(), false)) { log_warning(gc)("Could not commit native memory for marking bitmap, GC failed"); return; } //        ,  , //       TLAB-. ensure_parsability(true); //      ,    GC. CodeCache::gc_prologue(); BiasedLocking::preserve_marks(); //        . //       . DerivedPointerTable::clear(); }</span></span></code> </pre> <br><p>  Karena kita menggunakan bitmap untuk melacak jangkauan objek, kita perlu menghapusnya sebelum digunakan.  Atau dalam kasus kami, karena kami bertujuan untuk tidak pernah meminta sumber daya sebelum memulai siklus GC, kami harus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memasukkan bitmap ke memori</a> terlebih dahulu.  Ini memberikan beberapa keuntungan menarik, setidaknya di Linux, di mana sebagian besar bitmap akan mengarah ke halaman nol, terutama untuk tumpukan yang jarang. </p><br><p>  Utas harus membebaskan TLAB mereka dan meminta GC untuk yang baru setelah build selesai. </p><br><blockquote>  Jangan bingung TLAB dan <code>java.lang.ThreadLocal</code> .  Dari sudut pandang GC, ThreadLocal adalah objek biasa, dan mereka tidak akan dikompilasi oleh GC kecuali secara khusus diminta sebaliknya dalam kode Java. </blockquote><p>  Beberapa bagian runtime, terutama yang menahan tautan ke Java heap, akan rusak saat pengumpulan sampah, jadi Anda perlu memperingatkan mereka bahwa GC akan segera mulai bekerja.  Ini akan memungkinkan masing-masing subsistem untuk menyiapkan dan menyimpan bagian dari negara mereka sebelum GC mengambil langkah. </p><br><a name="32"></a><br><h2 id="32-markirovka">  3.2.  Menandai </h2><br><p>  Menandai dalam mode berhenti dunia menjadi sangat sederhana ketika hampir semuanya telah dilakukan untuk kita.  Pelabelan cukup standar, dan kemungkinan besar, dalam banyak implementasi, GC adalah langkah pertama. </p><br><pre> <code class="cpp hljs">{ GCTraceTime(Info, gc) time(<span class="hljs-string"><span class="hljs-string">"Step 1: Mark"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    ,     .  //   ,  ,    //      . EpsilonMarkStack stack; EpsilonScanOopClosure cl(&amp;stack, &amp;_bitmap); //      . process_roots(&amp;cl); stat_reachable_roots = stack.size(); //    ,    . //    ,   , //      . while (!stack.is_empty()) { oop obj = stack.pop(); obj-&gt;oop_iterate(&amp;cl); stat_reachable_heap++; } //       . DerivedPointerTable::set_active(false); }</span></span></code> </pre> <br><p>  Ini berfungsi persis sama dengan untuk grafik lain: Anda memulai traversal dengan set awal dari simpul yang dapat dijangkau, berjalan di sepanjang tepi keluar dan merekam semua simpul yang dikunjungi.  Traversal berlanjut hingga semua puncak yang belum dikunjungi berakhir.  Dalam GC, "simpul" adalah objek, dan "ujung" adalah tautan di antara mereka. </p><br><p>  Secara teknis, kita bisa secara rekursif menelusuri grafik objek, tetapi ini adalah ide yang buruk untuk grafik arbitrer yang dapat memiliki diameter sangat besar.  Bayangkan daftar tertaut dari satu miliar puncak!  Oleh karena itu, untuk membatasi kedalaman rekursi, kami menggunakan tumpukan penandaan yang merekam objek yang terdeteksi. </p><br><p>  Set awal objek yang dapat dijangkau adalah akar GC.  Sekarang jangan memikirkan apa itu <code>process_roots</code> , lebih lanjut tentang itu nanti.  Untuk saat ini, anggap saja ia mem-bypass semua tautan yang dapat dijangkau dari sisi VM. </p><br><p>  Bitmap dengan tanda berfungsi baik sebagai alat untuk merekam <em>muka gelombang penandaan</em> (banyak objek sudah dikunjungi), dan pada akhirnya - sebagai repositori dari hasil yang diinginkan, satu set semua objek yang dapat dijangkau.  Pekerjaan nyata berlangsung di <code>EpsilonScanOopClosure</code> , ini diterapkan ke semua objek yang menarik dan diulangi di semua tautan dari objek yang dipilih. </p><br><blockquote>  Lihat, Jawa tahu cara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menutup (closure)</a> sebelum menjadi modis! </blockquote><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EpsilonScanOopClosure</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> BasicOopIterateClosure { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: EpsilonMarkStack* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _stack; MarkBitMap* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _bitmap; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">do_oop_work</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-comment"><span class="hljs-comment">// p -     ,   oop,   //      ,  : T o = RawAccess&lt;&gt;::oop_load(p); if (!CompressedOops::is_null(o)) { oop obj = CompressedOops::decode_not_null(o); //  . ,   .  , //        . //    +, //       . if (!_bitmap-&gt;is_marked(obj)) { _bitmap-&gt;mark((HeapWord*)obj); _stack-&gt;push(obj); } } } };</span></span></code> </pre> <br><p>  Setelah menyelesaikan langkah ini, <code>_bitmap</code> berisi bit yang menunjukkan lokasi objek langsung.  Berkat ini, dimungkinkan untuk mem-bypass semua benda hidup, misalnya: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//           . //   ,    ( )  ,  //       1/64  . void EpsilonHeap::walk_bitmap(ObjectClosure* cl) { HeapWord* limit = _space-&gt;top(); HeapWord* addr = _bitmap.get_next_marked_addr(_space-&gt;bottom(), limit); while (addr &lt; limit) { oop obj = oop(addr); assert(_bitmap.is_marked(obj), "sanity"); cl-&gt;do_object(obj); addr += 1; if (addr &lt; limit) { addr = _bitmap.get_next_marked_addr(addr, limit); } } }</span></span></code> </pre> <br><a name="33"></a><br><h2 id="33-vychislyaem-novye-adresa">  3.3.  Hitung alamat baru </h2><br><p>  Ini juga merupakan langkah yang cukup sederhana, dan mengimplementasikan persis apa yang dikatakan algoritma. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ab3/406/5e6/ab34065e6397d39413057358b45247a3.jpg"></p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    forwarding data (,    ) //   .        . //          . PreservedMarks preserved_marks; //     GC. HeapWord* new_top; { GCTraceTime(Info, gc) time("Step 2: Calculate new locations", NULL); //    ,        //    . ,  - . EpsilonCalcNewLocationObjectClosure cl(_space-&gt;bottom(), &amp;preserved_marks); walk_bitmap(&amp;cl); //         . //       ,    //      ,      "" //  . new_top = cl.compact_point(); stat_preserved_marks = preserved_marks.size(); }</span></span></code> </pre> <br><p>  Satu-satunya hal yang menarik perhatian Anda adalah bahwa kami memutuskan untuk menyimpan alamat baru di kata menandai objek Java, dan kata ini sudah dapat ditempati oleh sesuatu yang penting, misalnya, informasi tentang kunci.  Untungnya, kata-kata yang menandai nontrivial semacam itu cukup langka, dan kita dapat menyimpannya secara terpisah, jika memang diperlukan: inilah yang digunakan untuk <code>PreservedMarks</code> . </p><br><p>  Pekerjaan algoritmik nyata dilakukan oleh <code>EpsilonCalcNewLocationObjectClosure</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EpsilonCalcNewLocationObjectClosure</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ObjectClosure { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: HeapWord* _compact_point; PreservedMarks* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _preserved_marks; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: EpsilonCalcNewLocationObjectClosure(HeapWord* start, PreservedMarks* pm) : _compact_point(start), _preserved_marks(pm) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_object</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(oop obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    :    . //        (      , //    ),      , //     . if ((HeapWord*)obj != _compact_point) { markOop mark = obj-&gt;mark_raw(); if (mark-&gt;must_be_preserved(obj)) { _preserved_marks-&gt;push(obj, mark); } obj-&gt;forward_to(oop(_compact_point)); } _compact_point += obj-&gt;size(); } HeapWord* compact_point() { return _compact_point; } };</span></span></code> </pre> <br><p>  <code>forward_to</code> adalah bagian terpenting karena ia menyimpan "pindahkan alamat" pada kata marker objek.  Ini akan diperlukan pada langkah selanjutnya. </p><br><a name="34"></a><br><h2 id="34-ispravlyaem-ukazateli">  3.4.  Perbaiki pointer </h2><br><p>  Sekarang Anda harus melalui tumpukan lagi dan menulis ulang semua tautan dengan alamat baru mereka sesuai dengan algoritma berikut: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/25f/c82/1dc/25fc821dc95d2f9d50fe40653eb845ff.jpg"></p><br><pre> <code class="cpp hljs">{ GCTraceTime(Info, gc) time(<span class="hljs-string"><span class="hljs-string">"Step 3: Adjust pointers"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     _   _,     // « ».      forwarding data, //    .      . EpsilonAdjustPointersObjectClosure cl; walk_bitmap(&amp;cl); //     ,      VM,  //     :      . EpsilonAdjustPointersOopClosure cli; process_roots(&amp;cli); //   ,      , //     . preserved_marks.adjust_during_full_gc(); }</span></span></code> </pre> <br><p>  Ada dua jenis referensi untuk objek bergeser: keluar baik dari objek di heap itu sendiri, atau dari akar GC.  Anda perlu memperbarui kedua kelas tautan.  Beberapa label yang disimpan juga menyimpan referensi ke objek, jadi Anda perlu meminta mereka untuk memperbarui.  <code>PreservedMarks</code> tahu bagaimana melakukan ini karena mengharapkan "meneruskan data" di tempat yang sama tempat kita menyimpannya, dalam kata penandaan objek. </p><br><p>  Penutupan dibagi menjadi dua jenis: beberapa mengambil objek dan memotong isinya, yang lain memperbarui alamat ini.  Di sini Anda dapat membuat optimasi kinerja kecil: jika objek tidak bergerak, Anda dapat menyimpan beberapa catatan dalam banyak: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EpsilonAdjustPointersOopClosure</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> BasicOopIterateClosure { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">do_oop_work</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-comment"><span class="hljs-comment">// p -     ,   oop. //        ,  : T o = RawAccess&lt;&gt;::oop_load(p); if (!CompressedOops::is_null(o)) { oop obj = CompressedOops::decode_not_null(o); //         . //  ,    . if (obj-&gt;is_forwarded()) { oop fwd = obj-&gt;forwardee(); assert(fwd != NULL, "just checking"); RawAccess&lt;&gt;::oop_store(p, fwd); } } } }; class EpsilonAdjustPointersObjectClosure : public ObjectClosure { private: EpsilonAdjustPointersOopClosure _cl; public: void do_object(oop obj) { //    ,    : obj-&gt;oop_iterate(&amp;_cl); } };</span></span></code> </pre> <br><p>  Setelah menyelesaikan langkah ini, kami pada dasarnya memecah tumpukan: tautan menunjuk ke alamat "salah" di mana objek belum berbohong.  Mari kita perbaiki! </p><br><a name="35"></a><br><h2 id="35-dvigaem-obekty">  3.5.  Kami memindahkan objek </h2><br><p>  Saatnya memindahkan objek ke alamat baru, sesuai dengan algoritma: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/01c/5b8/db8/01c5b8db85781c82b89bbed730c8aecc.jpg"></p><br><p>  <code>EpsilonMoveObjectsObjectClosure</code> berkeliling tumpukan lagi dan menerapkan penutupan <code>EpsilonMoveObjectsObjectClosure</code> untuk semua objek hidup: </p><br><pre> <code class="cpp hljs">{ GCTraceTime(Info, gc) time(<span class="hljs-string"><span class="hljs-string">"Step 4: Move objects"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">//       . //          . EpsilonMoveObjectsObjectClosure cl; walk_bitmap(&amp;cl); stat_moved = cl.moved(); //         ,   // «»      . _space-&gt;set_top(new_top); }</span></span></code> </pre> <br><p>  Segera setelah itu, Anda dapat menarik tumpukan tumpukan titik pemadatan, memungkinkan untuk mengalokasikan memori langsung dari tempat ini, segera setelah siklus pengumpulan sampah berakhir. </p><br><p>  Perhatikan bahwa dalam rakitan pemindahan kita dapat menimpa konten objek yang ada, tetapi karena pemindaian berjalan ke arah yang sama, objek yang ditimpa telah disalin ke tempat yang tepat. </p><br><blockquote>  Lokasi lama dan baru dari fasilitas yang sama dapat berpotongan.  Misalnya, jika Anda menggeser objek 100-byte dengan 8 byte.  Prosedur penyalinan harus berhasil dengan sendirinya, dan konten yang berpotongan harus disalin dengan benar, perhatikan <code>Copy::aligned_*conjoint*_words</code> . </blockquote><p>  Penutupan itu sendiri hanya akan memindahkan objek yang dipindahkan ke alamat baru: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EpsilonMoveObjectsObjectClosure</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ObjectClosure { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_object</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(oop obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     ,  .   - , //   -  mark word, //      forwarding data. if (obj-&gt;is_forwarded()) { oop fwd = obj-&gt;forwardee(); assert(fwd != NULL, "just checking"); Copy::aligned_conjoint_words((HeapWord*)obj, (HeapWord*)fwd, obj-&gt;size()); fwd-&gt;init_mark_raw(); } } };</span></span></code> </pre> <br><a name="36"></a><br><h2 id="36-epilog">  3.6.  Epilog </h2><br><p>  Pengumpulan sampah selesai, tumpukan sekali lagi hampir konsisten, sentuhan terakhir yang tersisa: </p><br><pre> <code class="cpp hljs">{ GCTraceTime(Info, gc) time(<span class="hljs-string"><span class="hljs-string">"Step 5: Epilogue"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    . preserved_marks.restore(); //   ,    . DerivedPointerTable::update_pointers(); BiasedLocking::restore_marks(); CodeCache::gc_epilogue(); JvmtiExport::gc_epilogue(); //     . if (!os::uncommit_memory((char*)_bitmap_region.start(), _bitmap_region.byte_size())) { log_warning(gc)("Could not uncommit native memory for marking bitmap"); } //    ,  . //        . if (EpsilonUncommit) { _virtual_space.shrink_by((_space-&gt;end() - new_top) * HeapWordSize); _space-&gt;set_end((HeapWord*)_virtual_space.high()); } }</span></span></code> </pre> <br><p>  Kami memberi tahu sisa runtime bahwa mereka harus memulai prosedur pasca-perakitan.  Kami mengembalikan kata-kata penanda khusus yang kami simpan sebelumnya.  Ciuman perpisahan untuk kartu penanda kami - itu tidak lagi diperlukan. </p><br><p>  Dan, jika Anda benar-benar ingin, Anda dapat mengurangi memori untuk alokasi ke ukuran baru, sehingga mengembalikan memori ke sistem operasi! </p><br><a name="4"></a><br><h1 id="4-podklyuchaem-gc-k-vm">  4. Hubungkan GC ke VM </h1><br><a name="41"></a><br><h2 id="41-obhod-kornevyh-elementov">  4.1.  Root Traversal </h2><br><p>  Ingat, Anda perlu mem-bypass tautan khusus yang dapat dijangkau dari VM?  Anda dapat meminta setiap subsistem VM khusus untuk memotong tautan yang tersembunyi dari objek Java lainnya.  Daftar lengkap elemen-elemen root tersebut di Hotspot saat ini terlihat seperti ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> EpsilonHeap::do_roots(OopClosure* cl) { <span class="hljs-comment"><span class="hljs-comment">//   ,        1 . StrongRootsScope scope(1); //         . CLDToOopClosure clds(cl, ClassLoaderData::_claim_none); MarkingCodeBlobClosure blobs(cl, CodeBlobToOopClosure::FixRelocations); //      . //        . { MutexLockerEx lock(CodeCache_lock, Mutex::_no_safepoint_check_flag); CodeCache::blobs_do(&amp;blobs); } { MutexLockerEx lock(ClassLoaderDataGraph_lock); ClassLoaderDataGraph::cld_do(&amp;clds); } Universe::oops_do(cl); Management::oops_do(cl); JvmtiExport::oops_do(cl); JNIHandles::oops_do(cl); WeakProcessor::oops_do(cl); ObjectSynchronizer::oops_do(cl); SystemDictionary::oops_do(cl); Threads::possibly_parallel_oops_do(false, cl, &amp;blobs); }</span></span></code> </pre> <br><p>  ,        .    GC    . </p><br><a name="42"></a><br><h2 id="42-seyfpointy-i-ostanovka-mira"> 4.2.     </h2><br><p>   GC     ,   VM      .  Hotspot     <code>VM_Operation</code> ,     GC    VM-  : </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// VM_operation,      class VM_EpsilonCollect: public VM_Operation { private: const GCCause::Cause _cause; EpsilonHeap* const _heap; static size_t _last_used; public: VM_EpsilonCollect(GCCause::Cause cause) : VM_Operation(), _cause(cause), _heap(EpsilonHeap::heap()) {}; VM_Operation::VMOp_Type type() const { return VMOp_EpsilonCollect; } const char* name() const { return "Epsilon Collection"; } virtual bool doit_prologue() { //     ,     . //         GC, //          . //   ,         //  .     , //       1%, ,  , //     . Heap_lock-&gt;lock(); size_t used = _heap-&gt;used(); size_t capacity = _heap-&gt;capacity(); size_t allocated = used &gt; _last_used ? used - _last_used : 0; if (_cause != GCCause::_allocation_failure || allocated &gt; capacity / 100) { return true; } else { Heap_lock-&gt;unlock(); return false; } } virtual void doit() { _heap-&gt;entry_collect(_cause); } virtual void doit_epilogue() { _last_used = _heap-&gt;used(); Heap_lock-&gt;unlock(); } }; size_t VM_EpsilonCollect::_last_used = 0; void EpsilonHeap::vmentry_collect(GCCause::Cause cause) { VM_EpsilonCollect vmop(cause); VMThread::execute(&amp;vmop); }</span></span></code> </pre> <br><p>       ,       GC —    ,     . </p><br><a name="43"></a><br><h2 id="43-oshibki-vydeleniya-pamyati">  4.3.    </h2><br><p> ,     GC  ,   ,  GC    ,     .   ,      <code>allocate_work</code>     ,   GC     : </p><br><pre> <code class="cpp hljs">HeapWord* EpsilonHeap::allocate_or_collect_work(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size) { HeapWord* res = allocate_work(size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> &amp;&amp; EpsilonSlidingGC) { vmentry_collect(GCCause::_allocation_failure); res = allocate_work(size); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre> <br><p>   ! </p><br><a name="5"></a><br><h1 id="5-sborka"> 5.  </h1><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a>        OpenJDK. </p><br><pre> <code class="bash hljs">$ hg <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://hg.openjdk.java.net/jdk/jdk/ jdk-jdk $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> jdk-jdk $ curl https://shipilev.net/jvm/diy-gc/webrev/jdk-jdk-epsilon.changeset | patch -p1</code> </pre> <br><p>     OpenJDK  : </p><br><pre> <code class="bash hljs">$ ./configure --with-debug-level=fastdebug $ make images</code> </pre> <br><p>    : </p><br><pre> <code class="bash hljs">$ build/linux-x86_64-server-fastdebug/images/jdk/bin/java -XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC -XX:+EpsilonSlidingGC -version openjdk version <span class="hljs-string"><span class="hljs-string">"13-internal"</span></span> 2019-09-17 OpenJDK Runtime Environment (build 13-internal+0-adhoc.shade.jdk-jdk-epsilon) OpenJDK 64-Bit Server VM (build 13-internal+0-adhoc.shade.jdk-jdk-epsilon, mixed mode, sharing</code> </pre> <br><a name="6"></a><br><h1 id="6-testirovanie"> 6.  </h1><br><p>  ,    GC  ?    : </p><br><ol><li> .  .   Hotspot    ,   JVM   <em>fastdebug</em>        ,        GC. </li><li>  .        ,          . ,        ( )   ,          . </li><li>  Tes.    ,  ,   ,   .     -   ,        . </li></ol><br><p> ,    ,       : </p><br><pre> <code class="plaintext hljs">$ CONF=linux-x86_64-server-fastdebug make images run-test TEST=gc/epsilon/ Building targets 'images run-test' in configuration 'linux-x86_64-server-fastdebug' Test selection 'gc/epsilon/', will run: * jtreg:test/hotspot/jtreg/gc/epsilon Running test 'jtreg:test/hotspot/jtreg/gc/epsilon' Passed: gc/epsilon/TestAlwaysPretouch.java Passed: gc/epsilon/TestAlignment.java Passed: gc/epsilon/TestElasticTLAB.java Passed: gc/epsilon/TestEpsilonEnabled.java Passed: gc/epsilon/TestHelloWorld.java Passed: gc/epsilon/TestLogTrace.java Passed: gc/epsilon/TestDieDefault.java Passed: gc/epsilon/TestDieWithOnError.java Passed: gc/epsilon/TestMemoryPools.java Passed: gc/epsilon/TestMaxTLAB.java Passed: gc/epsilon/TestPrintHeapSteps.java Passed: gc/epsilon/TestArraycopyCheckcast.java Passed: gc/epsilon/TestClasses.java Passed: gc/epsilon/TestUpdateCountersSteps.java Passed: gc/epsilon/TestDieWithHeapDump.java Passed: gc/epsilon/TestByteArrays.java Passed: gc/epsilon/TestManyThreads.java Passed: gc/epsilon/TestRefArrays.java Passed: gc/epsilon/TestObjects.java Passed: gc/epsilon/TestElasticTLABDecay.java Passed: gc/epsilon/TestSlidingGC.java Test results: passed: 21 TEST SUCCESS</code> </pre> <br><p> ?       <em>fastdebug</em>    .  ?    - . </p><br><a name="7"></a><br><h1 id="7-proizvoditelnost"> 7.  </h1><br><p> -  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">spring-petclinic</a> ,  Apache Bench     GC!        ,  ,     GC . </p><br><p>    : <code>-Xlog:gc -XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC -XX:+EpsilonSlidingGC</code> : </p><br><p> : </p><br><pre> <code class="plaintext hljs">Heap: 20480M reserved, 20480M (100.00%) committed, 19497M (95.20%) used GC(2) Step 0: Prologue 2.085ms GC(2) Step 1: Mark 51.005ms GC(2) Step 2: Calculate new locations 71.207ms GC(2) Step 3: Adjust pointers 49.671ms GC(2) Step 4: Move objects 22.839ms GC(2) Step 5: Epilogue 1.008ms GC(2) GC Stats: 70561 (8.63%) reachable from roots, 746676 (91.37%) reachable from heap, 91055 (11.14%) moved, 2237 (0.27%) markwords preserved GC(2) Heap: 20480M reserved, 20480M (100.00%) committed, 37056K (0.18%) used GC(2) Lisp2-style Mark-Compact (Allocation Failure) 20479M-&gt;36M(20480M) 197.940ms</code> </pre> <br><p> 200 ?        GC!   ,         .   ,          ,   :         (      —  ,    ).       - (                ). </p><br><p>  , GC          . ,   <code>-Xlog:gc -XX:+UseSerialGC</code> —  ,  ,  : </p><br><pre> <code class="plaintext hljs">GC(46) Pause Young (Allocation Failure) 575M-&gt;39M(1943M) 2.603ms GC(47) Pause Young (Allocation Failure) 575M-&gt;39M(1943M) 2.606ms GC(48) Pause Young (Allocation Failure) 575M-&gt;39M(1943M) 2.747ms GC(49) Pause Young (Allocation Failure) 575M-&gt;39M(1943M) 2.578ms</code> </pre> <br><p> , 2 .  ,        ,   GC   .      <code>-Xlog:gc -XX:+UseSerialGC</code> ,       ,      : </p><br><pre> <code class="plaintext hljs">GC(3) Pause Full (Allocation Failure) 16385M-&gt;34M(18432M) 1969.694ms GC(4) Pause Full (Allocation Failure) 16385M-&gt;34M(18432M) 2261.405ms GC(5) Pause Full (Allocation Failure) 16385M-&gt;34M(18432M) 2327.577ms GC(6) Pause Full (Allocation Failure) 16385M-&gt;34M(18432M) 2328.976ms</code> </pre> <br><p>     ,    .    . </p><br><a name="8"></a><br><h1 id="8-chto-dalshe"> 8.  ? </h1><br><p>     .       ,    GC  OpenJDK —  ,    ,          . </p><br><p>   : </p><br><ol><li><p>    .     ,   // .      .     ,       ,    « »       ,        ,   . <br></p><blockquote>    GC, <code>java.lang.ref.Reference.referent</code> —     Java-,  ,   ,     -  .       <code>FinalReference</code> ,    . </blockquote>         <code>ReferenceProcessor</code>     /  /     . <br></li><li><p>        VM.              VM,   ,   ,       .       <em></em>  <em></em>  .  ,    <em></em>  ,  ,     -  <em></em>   ,    . </p><br></li><li><p>  .      —    ,    GC,          .  ,    ,      ,       . <br></p><blockquote>    mark-compact GC   Full GC fallbacks  Shenandoah (  OpenJDK 8)  G1 (  OpenJDK 10,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JEP 307: «Parallel Full GC for G1»</a> ). </blockquote><br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a> .  ,        «»     ,     , ,  -     .           .   ,          . </p><br></li><li><p>        .     ,  ,     ,           .   ,     «» —    «»        «» ,      . </p><br></li><li><p>  -   GC Handbook     . </p><br></li></ol><br><a name="9"></a><br><h1 id="9-vyvody"> 9.  </h1><br><p>       ?   GC —  , ,  ,        GC. </p><br><p>         ,    -  GC   . ,     ,            GC (, Serial GC  Parallel GC),         . </p><br><blockquote>  Menit periklanan.  , 5-6  2019,  JPoint —    Java-.           — OpenJDK, GraalVM, Kotlin  .        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id443250/">https://habr.com/ru/post/id443250/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id443240/index.html">Memahami Q-learning, masalah "Berjalan di atas batu"</a></li>
<li><a href="../id443242/index.html">Quarkus adalah Jawa subatom supersonik. Tinjauan singkat kerangka kerja</a></li>
<li><a href="../id443244/index.html">Tugas pembekalan. Beanpoisk_1</a></li>
<li><a href="../id443246/index.html">Bagaimana kami menciptakan kembali Askozia IP PBX setelah proyek dijual dan ditutup oleh pengembang</a></li>
<li><a href="../id443248/index.html">Protokol reservasi mulus PRP dan HSR</a></li>
<li><a href="../id443252/index.html">Bot Ant Modular dengan Memori</a></li>
<li><a href="../id443254/index.html">Triton adalah virus paling mematikan</a></li>
<li><a href="../id443256/index.html">PowerShell, dump dari pengalaman saya</a></li>
<li><a href="../id443258/index.html">Gotify - proyek sumber terbuka untuk mengirimkan pemberitahuan dan mengirim pesan ke server</a></li>
<li><a href="../id443260/index.html">Bermigrasi ke Zimbra tanpa mempertaruhkan bisnis dengan domain umum</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>