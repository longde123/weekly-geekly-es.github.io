<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕴🏻 🚌 🦃 Warum habe ich eine CD 300 Mal gerippt? 🏯 👩🏽 💇🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich sammle Musik: Ich kaufe CDs, digitalisiere sie mit Exact Audio Copy und scanne Cover und Beilagen. Manchmal ist es nicht einfach, wenn die CD vor ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Warum habe ich eine CD 300 Mal gerippt?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418995/"> Ich sammle Musik: Ich kaufe CDs, digitalisiere sie mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Exact Audio Copy</a> und scanne Cover und Beilagen.  Manchmal ist es nicht einfach, wenn die CD vor 10 Jahren in einer limitierten Auflage im Ausland veröffentlicht wurde.  Das Schwierigste ist, wenn die CD einen Herstellungsfehler aufweist - und einige Titel nicht gelesen werden können. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6f5/e32/a86/6f5e32a86569ad14e42c0ea28a8de301.jpg" align="left">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Altneulands</a> Klavierarrangement-Album <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">帰 る べ き 城</a> wurde 2005 veröffentlicht.  Ich fand es drei Jahre später (wahrscheinlich auf YouTube), lud das beste Exemplar herunter - und setzte es auf die Liste der zukünftigen Einkäufe.  Die jüngsten Fortschritte in der internationalen Mail-Technologie haben es im vergangenen Jahr ermöglicht, eine gebrauchte Festplatte zu kaufen.  Leider konnte keines meiner CD-Laufwerke Titel 3 lesen. Dies passiert häufig beim Kauf alter Discs, insbesondere wenn sie das internationale USPS-Versandzentrum durchlaufen haben.  Ich legte es beiseite und suchte nach einem anderen Exemplar, das ich letzten Monat gefunden hatte.  Er kam am Freitag an - und ich versuchte sofort, ihn zu zerreißen.  Aber mit <i>genau dem gleichen Fehler</i> gedrückt.  Es scheint, dass dies keine Frage von Verschleiß oder Beschädigung ist - die Disc ist wahrscheinlich direkt ab Werk defekt herausgekommen. <br><br>  ZUSATZ: Nach der Untersuchung glaube ich nicht mehr, dass dies ein Fabrikfehler ist.  Wenn ich den Anfang oder das Ende eines fehlerhaften Titels auf eine leere CD-R schreibe und kopiere, erzeugt der Ripper den gleichen Fehler!  Probieren Sie es selbst mit der Datei <a href="">minimal.flac aus</a> . <br><a name="habracut"></a><br>  Es gibt noch zwei Möglichkeiten: Versuchen Sie entweder eines Tages, eine andere Kopie zu finden, die erfolgreich kopiert wird (unwahrscheinlich), oder stellen Sie die ursprünglichen Sounddaten von beschädigten Festplatten wieder her.  Sie wissen bereits, welche Option ich gewählt habe. <br><br><h1>  Wie Ripper funktioniert </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/69e/9b0/ff6/69e9b0ff62e391da0701a6a4cd02b57d.png"><br>  <i><font color="gray">EAC konnte Titel Nr. 3 nicht von Disc [帰 る べ き 城] lesen.</font></i> <br><br>  CDs speichern digitale Daten, es gibt jedoch eine vollständig analoge Schnittstelle zwischen Discs, Lasern und optischen Dioden.  Lesefehler treten aus verschiedenen Gründen auf: verschmutzte Medien, Kratzer auf der Schutzschicht aus Polycarbonat, Vibrationen des Laufwerks.  Primitive Fehlerkorrekturcodes im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CDDA-Standard tragen</a> dazu bei, die Klangverzerrung auf selten verwendeten Discs zu minimieren, können jedoch den Bitstrom auf einer CD mit einer großen Anzahl von Fehlern nicht vollständig wiederherstellen.  Moderne Ripper lösen das Problem mit zwei wichtigen Methoden zur Fehlererkennung: redundantes Lesen und AccurateRip. <br><br>  Auf der Seite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">EAC: Extraktionstechnologie wird</a> beschrieben, wie die EAC redundante Lesevorgänge erzeugt: <br><br><blockquote>  Im abgesicherten Modus liest das Programm jeden Sektor mindestens zweimal [...] Wenn ein Fehler auftritt (Lesen oder Synchronisieren), liest das Programm diesen Sektor weiter, bis 8 von 16 Versuchen identisch sind.  Ein solches Verfahren wird höchstens einmal, drei- oder fünfmal durchgeführt (entsprechend der gewählten Qualität der Fehlerbehebung).  Im schlimmsten Fall werden schlechte Sektoren 82 Mal gelesen! </blockquote><br>  Alles ist einfach.  Wenn eine Leseanforderung manchmal falsche Daten zurückgibt, lesen Sie sie erneut und seien Sie dann besonders vorsichtig, wenn die ersten beiden Lesevorgänge unterschiedliche Ergebnisse liefern.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AccurateRip</a> verwendet dasselbe Prinzip, jedoch auf verteilte Weise: Ripper senden Prüfsummen kopierter Audiodateien an diesen Dienst.  Die Idee ist, dass wenn tausend Leute einen Track mit den gleichen Bits kopieren, dies wahrscheinlich der richtige Rip ist. <br><br>  In diesem Artikel erfahren Sie, was zu tun ist, wenn beide Methoden nicht helfen können.  EAC liefert kein Ergebnis, wenn jeder Messwert unterschiedliche Daten zurückgibt, und in der AccurateRip-Datenbank gibt es nur einen Datensatz über eine seltene Festplatte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[1]</a> <a name="1_1"></a>  . <br><br><h1>  "Ich habe zehntausend Passagen passiert, zehntausend Passagen, um dich zu sehen" </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/44a/1ab/850/44a1ab850b96409640f45e9425f73652.jpg"><br>  <i><font color="gray">Optische Laufwerke Asus, LG, Lite-On, Pioneer und unbekannter OEM</font></i> <br><br>  Wenn die CD nicht kopiert wird, ist es logisch, ein anderes Laufwerk zu verwenden.  Manchmal ist ein bestimmtes Modell den CDDA-Spezifikationen herablassender, oder es gibt eine bessere Firmware zum Beheben von Fehlern oder etwas anderes.  Das DBpoweramp-Forum verfügt über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine Genauigkeitsbewertung</a> für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CD / DVD-Laufwerke</a> , um das am besten geeignete Rip-Laufwerk auszuwählen. <br><br>  Am Samstagmorgen kaufte ich fünf neue CD-Laufwerke von verschiedenen Herstellern <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[2]</a> <a name="2_2"></a>  Ich habe sie alle ausprobiert - und eine gefunden, die die Synchronisation auf einem Beat-Track aufrechterhalten konnte.  Leider konnte keine Rip-Bestätigung erhalten werden - zwischen allen Rips befanden sich ungefähr 20.000 verschiedene Bytes. <br><br>  Aber jetzt hatte ich WAV-Dateien auf der Festplatte, und Sie können davon profitieren.  Ich bin zu dem Schluss gekommen, dass Lesefehler auf einer schlechten Spur in der Nähe der „richtigen“ liegen.  Daher ist es sinnvoll, mehrere Rips zu erstellen und einen "Konsens" -Wert für instabile Bytes zu finden.  Dieser Ansatz war letztendlich erfolgreich, erforderte aber viel mehr Arbeit als ich erwartet hatte. <br><br><h1>  "Quantität geht in Qualität" </h1><br>  Ich begann damit, die Festplatte wiederholt auf eines der Laufwerke zu kopieren, alle Werte für jedes Byte zu schreiben und den Fehler als "korrigierbar" zu deklarieren, wenn mehr als die Hälfte der Rips einen bestimmten Bytewert für diese Position ergibt.  Der Anfang war gut: Die Anzahl der nicht korrigierbaren Fehler verringerte sich von fast ~ 6900 Bytes bei N = 4 auf ~ 5000 Bytes bei N = 10.  Der Nutzen jedes zusätzlichen Risses nahm mit der Zeit ab, bis sich die Anzahl der nicht korrigierbaren Fehler bei etwa N = 80 bei ~ 3700 stabilisierte.  Ich hörte bei N = 100 auf zu rippen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b87/aaa/809/b87aaa809a043eaeaa2d049258fe0cb9.png"><br>  <i><font color="gray">Behobene und schwerwiegende Fehler bei der Anzahl der Rips</font></i> <br><br>  Dann habe ich 100 Mal versucht, die Festplatte auf das zweite Laufwerk zu kopieren und mit zwei Korrekturkarten die nicht korrigierbaren Fehlerpositionen des ersten Laufwerks zu „füllen“.  Aber es hat nicht funktioniert: Auf jedem Laufwerk gab es Tausende von Korrekturen, die nicht den Korrekturen auf dem anderen entsprachen!  Es stellt sich heraus, dass Rauschen nicht durch Kombination mit einer anderen, aber verwandten Rauschquelle beseitigt werden kann. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/911/6d5/c33/9116d5c339461cb286edc4537c712a71.png"><br>  <i><font color="gray">Das Gleiche, aber für zwei Cross-Validating-Discs</font></i> <br><br><h1>  Handwerkliche Kunst </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/ec7/829/554/ec78295544b0a161b472598114e2be2d.jpg"><br><br>  Auf der EAC-Website gibt es eine weitere gute Ressource: den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DAE-Qualitätstest</a> , bei dem die Qualität der Firmware eines Laufwerks anhand der Anzahl der zu behebenden Fehler ermittelt wird.  Dies ist eine Fehlerbehandlung auf niedrigerer Ebene, wenn das Laufwerk Lesefehler korrigiert und nicht nur meldet.  Der Haken ist, dass der „abgesicherte Modus“ der EAC nur verfügbar ist, wenn Sie diesen integrierten Fehlerkorrekturcode deaktivieren, was darauf hindeutet, dass er nicht richtig funktioniert. <br><br>  Ich bereitete den Test vor, indem ich die WAV-Datei auf CD-R brannte, den genauen Sektor auf der Datenoberfläche hervorhob und ihn sorgfältig mit einem schwarzen Marker malte.  Dies sind garantiert schwerwiegende Fehler in einem deterministischen Muster. <br><br>  Ich habe alle Laufwerke getestet und zwei interessante Ergebnisse erzielt: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/11f/4c6/f55/11f4c6f554062ec91d1f5d4160b40a43.png"><br><br>  Ich habe das Lite-On-Laufwerk verwendet, um Synchronisierungsfehler zu umgehen.  Er kaute vor Vergnügen auf dem magischen Marker, war aber durch die geraden Linien auf der Datenoberfläche sehr verwirrt.  Sie können sehen, dass anstelle von drei separaten Gipfeln rechts ein riesiger fehlgeschlagener Blob angezeigt wird. <br><br> <code>Errors total Num : 206645159 <br> Errors (Loudness) Num : 965075 - Avg : -21.7 dB(A) - Max : -5.5 dB(A) <br> Error Muting Num : 154153 - Avg : 99.1 Samples - Max : 3584 Samples <br> Skips Num : 103 - Avg : 417.3 Samples - Max : 2939 Samples <br> <br> Total Test Result : 45.3 points (of 100.0 maximum)</code> <br> <br><img src="https://habrastorage.org/getpro/habr/post_images/07b/beb/2d7/07bbeb2d7534a3eb062e176c8b059182.png"><br><br>  Das Pioneer-Laufwerk erhielt die höchste DAE-Punktzahl.  Meiner Meinung nach sieht das Diagramm nicht besonders aus, aber das Analysetool sagte, dass dies die beste Firmware zur Behebung von Fehlern in meinem kleinen Satz ist. <br><br> <code>Errors total Num : 2331952 <br> Errors (Loudness) Num : 147286 - Avg : -77.2 dB(A) - Max : -13.2 dB(A) <br> Error Muting Num : 8468 - Avg : 1.5 Samples - Max : 273 Samples <br> Skips Num : 50 - Avg : 6.5 Samples - Max : 30 Samples <br> <br> Total Test Result : 62.7 points (of 100.0 maximum)</code> <br> <br><h1>  "Ab einem bestimmten Moment sind Zahlen wichtig" </h1><br>  Wie verwende ich die Pioneer-Firmware mit guter Fehlerkorrektur, wenn die EAC im abgesicherten Modus diese ignoriert?  Ganz einfach: Schalten Sie die EAC in den „Burst-Modus“ und schreiben Sie den Bitstrom in der Form auf die Festplatte, in der die Firmware ihn meldet.  Wie kann man dann aus dieser Gruppe nicht verifizierter WAV-Dateien eine Datei von guter Qualität machen, wie im "abgesicherten Modus"?  Ja, dasselbe Fehleranalysetool, das wir bei Rips mit Lite-On verwendet haben! <br><br>  Nach ein paar EAC-Konfigurationseinstellungen und nach hundert Rips erhalten wir ein so schönes Diagramm. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/405/323/e9f/405323e9fad21af9069c1983e25a7025.png"><br>  <i><font color="gray">Behobene und nicht korrigierbare Fehler bei der Anzahl der Risse (Pioneer)</font></i> <br><br>  Was ist zu beachten: <br><br><ul><li>  Schwerwiegende Bitfehler tendieren schnell zu Null, erreichen sie jedoch nie. </li><li>  Ein riesiger Sprung in die Fehlerbehebung bei 53-54 Rissen. </li><li>  Die Anzahl der Fehler vor und nach diesem großen Sprung ändert sich praktisch nicht, was auf Stabilitätsbereiche in den kopierten Daten hinweist. </li></ul><br><h1>  0xA595BC09 </h1><br>  Mit einer nahezu perfekten Fehlerkorrektur von Pioneer habe ich eine Best-Guess-Datei erstellt und mit Pioneer-Rips verglichen.  Wie erwartet wurden mehrere Abschnitte von geringer Qualität entdeckt, die ich durch weitere 10 Risse korrigierte: <br><br> <code>$ for RIP_ID in $(seq -w 1 100); do echo -n "rip$RIP_ID: "; cmp -l analysis-out.wav rips-cd1-pioneer/rip${RIP_ID}/*.wav | wc -l ; done | sort -rgk2 | head -n 10 <br> rip054: 2865 <br> rip099: 974 <br> rip007: 533 <br> rip037: 452 <br> rip042: 438 <br> rip035: 404 <br> rip006: 392 <br> rip059: 381 <br> rip043: 327 <br> rip014: 323</code> <br> <br>  Ich fand auch etwas wirklich Interessantes: Mehrere Rips produzierten <i>genau den</i> gleichen Inhalt!  Denken Sie daran, dass dies genau das Erfolgskriterium für die EAC im "abgesicherten Modus" ist.  <code>shncat -q -e | rhash --print="%C"</code> Befehl <code>shncat -q -e | rhash --print="%C"</code>  <code>shncat -q -e | rhash --print="%C"</code> verwendet, um die CRC32-Prüfsumme der Audio-Rohdaten zu berechnen <code>shncat -q -e | rhash --print="%C"</code> wird von der EAC verwendet. <br><br> <code>$ for wav in rips-cd1-pioneer/*/*.wav; do shncat "$wav" -q -e | rhash --printf="%C $wav\n" - ; done | sort -k1 <br> [...] <br> 9DD05FFF rips-cd1-pioneer/rip059/rip.wav <br> 9F8D1B53 rips-cd1-pioneer/rip072/rip.wav <br> A2EA0283 rips-cd1-pioneer/rip082/rip.wav <br> A595BC09 rips-cd1-pioneer/rip021/rip.wav <br> A595BC09 rips-cd1-pioneer/rip022/rip.wav <br> A595BC09 rips-cd1-pioneer/rip023/rip.wav <br> A595BC09 rips-cd1-pioneer/rip024/rip.wav <br> A595BC09 rips-cd1-pioneer/rip025/rip.wav <br> A595BC09 rips-cd1-pioneer/rip026/rip.wav <br> A595BC09 rips-cd1-pioneer/rip027/rip.wav <br> A595BC09 rips-cd1-pioneer/rip028/rip.wav <br> A595BC09 rips-cd1-pioneer/rip030/rip.wav <br> A595BC09 rips-cd1-pioneer/rip031/rip.wav <br> A595BC09 rips-cd1-pioneer/rip040/rip.wav <br> A595BC09 rips-cd1-pioneer/rip055/rip.wav <br> A595BC09 rips-cd1-pioneer/rip058/rip.wav <br> AA3B5929 rips-cd1-pioneer/rip043/rip.wav <br> ABAAE784 rips-cd1-pioneer/rip033/rip.wav <br> [...]</code> <br> <br>  Durch wiederholtes Zerreißen von Abschnitten mit geringer Qualität konnten wir die Analyse ohne schwerwiegende Fehler abschließen.  Und als ich diese Datei überprüfte, gab es genau den gleichen Audioinhalt wie beim "normalen" Rippen!  Dies reicht aus, um den Sieg zu erklären. <br><br>  Ich bin zu 99% sicher, dass ich diese problematische CD erfolgreich kopiert habe, und 0xA595BC09 ist der richtige CRC-Betrag für Titel 3. <br><br><h1>  Anhang A: vergleich.rs </h1><br>  Ich habe dieses Tool verwendet, um wahrscheinliche Bytefehler zu berechnen.  Es ist nicht für den Langzeitgebrauch gedacht, daher ist es etwas hässlich, aber es kann für diejenigen interessant sein, die auf diese Seite gestoßen sind und das gleiche Problem gelöst haben. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> memmap; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::cmp; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::collections::HashMap; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::env; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::fs; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::sync; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::sync::mpsc; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::thread; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> memmap::Mmap; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CHUNK_SIZE: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">suspect_positions</span></span></span></span>( mmaps: &amp;HashMap&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, Mmap&gt;, start_idx: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, end_idx: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, ) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> positions = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ii <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> start_idx..end_idx { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> first = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> byte: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (_file_name, file_content) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> mmaps { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> first { byte = file_content[ii]; first = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> byte != file_content[ii] { positions.push(ii); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } positions } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> args: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; = env::args().collect(); args.remove(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> first = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> size: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> files: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;fs::File&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> mmaps: HashMap&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, Mmap&gt; = HashMap::new(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> filename <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> args { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> file = fs::File::open(&amp;filename).unwrap(); files.push(file); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mmap = <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { Mmap::map(files.last().unwrap()).unwrap() }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> first { first = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; size = mmap.len(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(size == mmap.len()); } mmaps.insert(filename, mmap); } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (suspects_tx, suspects_rx) = mpsc::channel(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> start_idx = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mmaps_ref = sync::Arc::new(mmaps); <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> t_start_idx = start_idx; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> t_end_idx = cmp::min(start_idx + CHUNK_SIZE, size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> start_idx == t_end_idx { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mmaps_ref = mmaps_ref.clone(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> suspects_tx = suspects_tx.clone(); thread::spawn(<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> || { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> suspects = suspect_positions(mmaps_ref.as_ref(), t_start_idx, t_end_idx); suspects_tx.send(suspects).unwrap(); }); start_idx = t_end_idx; } <span class="hljs-built_in"><span class="hljs-built_in">drop</span></span>(suspects_tx); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> suspects: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::with_capacity(size); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> suspects_chunk <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> suspects_rx { suspects.append(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> suspects_chunk); } suspects.sort(); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{{\"files\": ["</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> first_file = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (file_name, file_content) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> mmaps_ref.iter() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> file_comma = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> first_file { <span class="hljs-string"><span class="hljs-string">""</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-string"><span class="hljs-string">","</span></span> }; first_file = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}{{\"name\": \"{}\", \"suspect_bytes\": ["</span></span>, file_comma, file_name); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (ii, position) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> suspects.iter().enumerate() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> comma = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ii == suspects.len() - <span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-string"><span class="hljs-string">""</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-string"><span class="hljs-string">","</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"[{}, {}]{}"</span></span>, position, file_content[*position], comma); } <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"]}}"</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"]}}"</span></span>); }</code> </pre> <br>  1. <a name="1"></a>  In diesem einzelnen AccurateRip-Datensatz stimmt die CRC für alle Titel mit Ausnahme von Titel 3 mit meiner Disc überein: Die Summe ist 0x84B9DD1A, und ich habe 0xA595BC09.  Ich vermute, dass der Ripper nicht verstanden hat, dass er einen schlechten Antrieb hat.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[zurück]</a> <br><br>  2. <a name="2"></a>  Die offensichtliche Frage beim Kauf eines CD- oder DVD-Laufwerks im Jahr 2018 lautet: „Verdammt, wo kann ich sie kaufen?“  Und ich brauchte nicht eine, sondern <i>mehrere</i> von <i>verschiedenen Marken</i> .  Ich kenne nur ein Geschäft in der Nähe, in dem 5,25-Zoll-DVD-Laufwerke verfügbar sind. Nur ein Geschäft ist groß genug, um den Regalplatz für solche Laufwerke nicht zu bereuen, und seltsam genug, um dort nicht fehl am Platz zu sein. Natürlich, ich über Frys Electronics sprechen. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[zurück]</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418995/">https://habr.com/ru/post/de418995/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418979/index.html">Als ich durch das Land flog, implementierte ich ein Projekt für mehrere tausend Jobs</a></li>
<li><a href="../de418981/index.html">Numerische Methoden zur Lösung elliptischer Gleichungen</a></li>
<li><a href="../de418985/index.html">Analytik und Design als Ganzes</a></li>
<li><a href="../de418987/index.html">Firefox umgeht den Schutz in der neuen Google Mail-Oberfläche problemlos</a></li>
<li><a href="../de418991/index.html">Mikrofilm wird für ein halbes Jahrtausend existieren</a></li>
<li><a href="../de418997/index.html">Echter Beitrag zu Real Open Source</a></li>
<li><a href="../de418999/index.html">[Ankündigung, Peter] JUG.ru-Treffen mit Andrei Belyaev und Alexei Stukalov - Troll unterdrückt KUBA: FAQ</a></li>
<li><a href="../de419001/index.html">5 „Super Skills“, die für die Arbeit der Zukunft notwendig sind</a></li>
<li><a href="../de419003/index.html">Blockchain News Digest</a></li>
<li><a href="../de419005/index.html">Ausflug zum Umspannwerk 220/110/20</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>