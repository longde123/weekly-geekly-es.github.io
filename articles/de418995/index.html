<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï¥üèª üöå ü¶É Warum habe ich eine CD 300 Mal gerippt? üèØ üë©üèΩ üíáüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich sammle Musik: Ich kaufe CDs, digitalisiere sie mit Exact Audio Copy und scanne Cover und Beilagen. Manchmal ist es nicht einfach, wenn die CD vor ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Warum habe ich eine CD 300 Mal gerippt?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418995/"> Ich sammle Musik: Ich kaufe CDs, digitalisiere sie mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Exact Audio Copy</a> und scanne Cover und Beilagen.  Manchmal ist es nicht einfach, wenn die CD vor 10 Jahren in einer limitierten Auflage im Ausland ver√∂ffentlicht wurde.  Das Schwierigste ist, wenn die CD einen Herstellungsfehler aufweist - und einige Titel nicht gelesen werden k√∂nnen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6f5/e32/a86/6f5e32a86569ad14e42c0ea28a8de301.jpg" align="left">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Altneulands</a> Klavierarrangement-Album <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Â∏∞ „Çã „Åπ „Åç Âüé</a> wurde 2005 ver√∂ffentlicht.  Ich fand es drei Jahre sp√§ter (wahrscheinlich auf YouTube), lud das beste Exemplar herunter - und setzte es auf die Liste der zuk√ºnftigen Eink√§ufe.  Die j√ºngsten Fortschritte in der internationalen Mail-Technologie haben es im vergangenen Jahr erm√∂glicht, eine gebrauchte Festplatte zu kaufen.  Leider konnte keines meiner CD-Laufwerke Titel 3 lesen. Dies passiert h√§ufig beim Kauf alter Discs, insbesondere wenn sie das internationale USPS-Versandzentrum durchlaufen haben.  Ich legte es beiseite und suchte nach einem anderen Exemplar, das ich letzten Monat gefunden hatte.  Er kam am Freitag an - und ich versuchte sofort, ihn zu zerrei√üen.  Aber mit <i>genau dem gleichen Fehler</i> gedr√ºckt.  Es scheint, dass dies keine Frage von Verschlei√ü oder Besch√§digung ist - die Disc ist wahrscheinlich direkt ab Werk defekt herausgekommen. <br><br>  ZUSATZ: Nach der Untersuchung glaube ich nicht mehr, dass dies ein Fabrikfehler ist.  Wenn ich den Anfang oder das Ende eines fehlerhaften Titels auf eine leere CD-R schreibe und kopiere, erzeugt der Ripper den gleichen Fehler!  Probieren Sie es selbst mit der Datei <a href="">minimal.flac aus</a> . <br><a name="habracut"></a><br>  Es gibt noch zwei M√∂glichkeiten: Versuchen Sie entweder eines Tages, eine andere Kopie zu finden, die erfolgreich kopiert wird (unwahrscheinlich), oder stellen Sie die urspr√ºnglichen Sounddaten von besch√§digten Festplatten wieder her.  Sie wissen bereits, welche Option ich gew√§hlt habe. <br><br><h1>  Wie Ripper funktioniert </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/69e/9b0/ff6/69e9b0ff62e391da0701a6a4cd02b57d.png"><br>  <i><font color="gray">EAC konnte Titel Nr. 3 nicht von Disc [Â∏∞ „Çã „Åπ „Åç Âüé] lesen.</font></i> <br><br>  CDs speichern digitale Daten, es gibt jedoch eine vollst√§ndig analoge Schnittstelle zwischen Discs, Lasern und optischen Dioden.  Lesefehler treten aus verschiedenen Gr√ºnden auf: verschmutzte Medien, Kratzer auf der Schutzschicht aus Polycarbonat, Vibrationen des Laufwerks.  Primitive Fehlerkorrekturcodes im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CDDA-Standard tragen</a> dazu bei, die Klangverzerrung auf selten verwendeten Discs zu minimieren, k√∂nnen jedoch den Bitstrom auf einer CD mit einer gro√üen Anzahl von Fehlern nicht vollst√§ndig wiederherstellen.  Moderne Ripper l√∂sen das Problem mit zwei wichtigen Methoden zur Fehlererkennung: redundantes Lesen und AccurateRip. <br><br>  Auf der Seite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">EAC: Extraktionstechnologie wird</a> beschrieben, wie die EAC redundante Lesevorg√§nge erzeugt: <br><br><blockquote>  Im abgesicherten Modus liest das Programm jeden Sektor mindestens zweimal [...] Wenn ein Fehler auftritt (Lesen oder Synchronisieren), liest das Programm diesen Sektor weiter, bis 8 von 16 Versuchen identisch sind.  Ein solches Verfahren wird h√∂chstens einmal, drei- oder f√ºnfmal durchgef√ºhrt (entsprechend der gew√§hlten Qualit√§t der Fehlerbehebung).  Im schlimmsten Fall werden schlechte Sektoren 82 Mal gelesen! </blockquote><br>  Alles ist einfach.  Wenn eine Leseanforderung manchmal falsche Daten zur√ºckgibt, lesen Sie sie erneut und seien Sie dann besonders vorsichtig, wenn die ersten beiden Lesevorg√§nge unterschiedliche Ergebnisse liefern.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AccurateRip</a> verwendet dasselbe Prinzip, jedoch auf verteilte Weise: Ripper senden Pr√ºfsummen kopierter Audiodateien an diesen Dienst.  Die Idee ist, dass wenn tausend Leute einen Track mit den gleichen Bits kopieren, dies wahrscheinlich der richtige Rip ist. <br><br>  In diesem Artikel erfahren Sie, was zu tun ist, wenn beide Methoden nicht helfen k√∂nnen.  EAC liefert kein Ergebnis, wenn jeder Messwert unterschiedliche Daten zur√ºckgibt, und in der AccurateRip-Datenbank gibt es nur einen Datensatz √ºber eine seltene Festplatte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[1]</a> <a name="1_1"></a>  . <br><br><h1>  "Ich habe zehntausend Passagen passiert, zehntausend Passagen, um dich zu sehen" </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/44a/1ab/850/44a1ab850b96409640f45e9425f73652.jpg"><br>  <i><font color="gray">Optische Laufwerke Asus, LG, Lite-On, Pioneer und unbekannter OEM</font></i> <br><br>  Wenn die CD nicht kopiert wird, ist es logisch, ein anderes Laufwerk zu verwenden.  Manchmal ist ein bestimmtes Modell den CDDA-Spezifikationen herablassender, oder es gibt eine bessere Firmware zum Beheben von Fehlern oder etwas anderes.  Das DBpoweramp-Forum verf√ºgt √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine Genauigkeitsbewertung</a> f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CD / DVD-Laufwerke</a> , um das am besten geeignete Rip-Laufwerk auszuw√§hlen. <br><br>  Am Samstagmorgen kaufte ich f√ºnf neue CD-Laufwerke von verschiedenen Herstellern <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[2]</a> <a name="2_2"></a>  Ich habe sie alle ausprobiert - und eine gefunden, die die Synchronisation auf einem Beat-Track aufrechterhalten konnte.  Leider konnte keine Rip-Best√§tigung erhalten werden - zwischen allen Rips befanden sich ungef√§hr 20.000 verschiedene Bytes. <br><br>  Aber jetzt hatte ich WAV-Dateien auf der Festplatte, und Sie k√∂nnen davon profitieren.  Ich bin zu dem Schluss gekommen, dass Lesefehler auf einer schlechten Spur in der N√§he der ‚Äûrichtigen‚Äú liegen.  Daher ist es sinnvoll, mehrere Rips zu erstellen und einen "Konsens" -Wert f√ºr instabile Bytes zu finden.  Dieser Ansatz war letztendlich erfolgreich, erforderte aber viel mehr Arbeit als ich erwartet hatte. <br><br><h1>  "Quantit√§t geht in Qualit√§t" </h1><br>  Ich begann damit, die Festplatte wiederholt auf eines der Laufwerke zu kopieren, alle Werte f√ºr jedes Byte zu schreiben und den Fehler als "korrigierbar" zu deklarieren, wenn mehr als die H√§lfte der Rips einen bestimmten Bytewert f√ºr diese Position ergibt.  Der Anfang war gut: Die Anzahl der nicht korrigierbaren Fehler verringerte sich von fast ~ 6900 Bytes bei N = 4 auf ~ 5000 Bytes bei N = 10.  Der Nutzen jedes zus√§tzlichen Risses nahm mit der Zeit ab, bis sich die Anzahl der nicht korrigierbaren Fehler bei etwa N = 80 bei ~ 3700 stabilisierte.  Ich h√∂rte bei N = 100 auf zu rippen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b87/aaa/809/b87aaa809a043eaeaa2d049258fe0cb9.png"><br>  <i><font color="gray">Behobene und schwerwiegende Fehler bei der Anzahl der Rips</font></i> <br><br>  Dann habe ich 100 Mal versucht, die Festplatte auf das zweite Laufwerk zu kopieren und mit zwei Korrekturkarten die nicht korrigierbaren Fehlerpositionen des ersten Laufwerks zu ‚Äûf√ºllen‚Äú.  Aber es hat nicht funktioniert: Auf jedem Laufwerk gab es Tausende von Korrekturen, die nicht den Korrekturen auf dem anderen entsprachen!  Es stellt sich heraus, dass Rauschen nicht durch Kombination mit einer anderen, aber verwandten Rauschquelle beseitigt werden kann. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/911/6d5/c33/9116d5c339461cb286edc4537c712a71.png"><br>  <i><font color="gray">Das Gleiche, aber f√ºr zwei Cross-Validating-Discs</font></i> <br><br><h1>  Handwerkliche Kunst </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/ec7/829/554/ec78295544b0a161b472598114e2be2d.jpg"><br><br>  Auf der EAC-Website gibt es eine weitere gute Ressource: den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DAE-Qualit√§tstest</a> , bei dem die Qualit√§t der Firmware eines Laufwerks anhand der Anzahl der zu behebenden Fehler ermittelt wird.  Dies ist eine Fehlerbehandlung auf niedrigerer Ebene, wenn das Laufwerk Lesefehler korrigiert und nicht nur meldet.  Der Haken ist, dass der ‚Äûabgesicherte Modus‚Äú der EAC nur verf√ºgbar ist, wenn Sie diesen integrierten Fehlerkorrekturcode deaktivieren, was darauf hindeutet, dass er nicht richtig funktioniert. <br><br>  Ich bereitete den Test vor, indem ich die WAV-Datei auf CD-R brannte, den genauen Sektor auf der Datenoberfl√§che hervorhob und ihn sorgf√§ltig mit einem schwarzen Marker malte.  Dies sind garantiert schwerwiegende Fehler in einem deterministischen Muster. <br><br>  Ich habe alle Laufwerke getestet und zwei interessante Ergebnisse erzielt: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/11f/4c6/f55/11f4c6f554062ec91d1f5d4160b40a43.png"><br><br>  Ich habe das Lite-On-Laufwerk verwendet, um Synchronisierungsfehler zu umgehen.  Er kaute vor Vergn√ºgen auf dem magischen Marker, war aber durch die geraden Linien auf der Datenoberfl√§che sehr verwirrt.  Sie k√∂nnen sehen, dass anstelle von drei separaten Gipfeln rechts ein riesiger fehlgeschlagener Blob angezeigt wird. <br><br> <code>Errors total Num : 206645159 <br> Errors (Loudness) Num : 965075 - Avg : -21.7 dB(A) - Max : -5.5 dB(A) <br> Error Muting Num : 154153 - Avg : 99.1 Samples - Max : 3584 Samples <br> Skips Num : 103 - Avg : 417.3 Samples - Max : 2939 Samples <br> <br> Total Test Result : 45.3 points (of 100.0 maximum)</code> <br> <br><img src="https://habrastorage.org/getpro/habr/post_images/07b/beb/2d7/07bbeb2d7534a3eb062e176c8b059182.png"><br><br>  Das Pioneer-Laufwerk erhielt die h√∂chste DAE-Punktzahl.  Meiner Meinung nach sieht das Diagramm nicht besonders aus, aber das Analysetool sagte, dass dies die beste Firmware zur Behebung von Fehlern in meinem kleinen Satz ist. <br><br> <code>Errors total Num : 2331952 <br> Errors (Loudness) Num : 147286 - Avg : -77.2 dB(A) - Max : -13.2 dB(A) <br> Error Muting Num : 8468 - Avg : 1.5 Samples - Max : 273 Samples <br> Skips Num : 50 - Avg : 6.5 Samples - Max : 30 Samples <br> <br> Total Test Result : 62.7 points (of 100.0 maximum)</code> <br> <br><h1>  "Ab einem bestimmten Moment sind Zahlen wichtig" </h1><br>  Wie verwende ich die Pioneer-Firmware mit guter Fehlerkorrektur, wenn die EAC im abgesicherten Modus diese ignoriert?  Ganz einfach: Schalten Sie die EAC in den ‚ÄûBurst-Modus‚Äú und schreiben Sie den Bitstrom in der Form auf die Festplatte, in der die Firmware ihn meldet.  Wie kann man dann aus dieser Gruppe nicht verifizierter WAV-Dateien eine Datei von guter Qualit√§t machen, wie im "abgesicherten Modus"?  Ja, dasselbe Fehleranalysetool, das wir bei Rips mit Lite-On verwendet haben! <br><br>  Nach ein paar EAC-Konfigurationseinstellungen und nach hundert Rips erhalten wir ein so sch√∂nes Diagramm. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/405/323/e9f/405323e9fad21af9069c1983e25a7025.png"><br>  <i><font color="gray">Behobene und nicht korrigierbare Fehler bei der Anzahl der Risse (Pioneer)</font></i> <br><br>  Was ist zu beachten: <br><br><ul><li>  Schwerwiegende Bitfehler tendieren schnell zu Null, erreichen sie jedoch nie. </li><li>  Ein riesiger Sprung in die Fehlerbehebung bei 53-54 Rissen. </li><li>  Die Anzahl der Fehler vor und nach diesem gro√üen Sprung √§ndert sich praktisch nicht, was auf Stabilit√§tsbereiche in den kopierten Daten hinweist. </li></ul><br><h1>  0xA595BC09 </h1><br>  Mit einer nahezu perfekten Fehlerkorrektur von Pioneer habe ich eine Best-Guess-Datei erstellt und mit Pioneer-Rips verglichen.  Wie erwartet wurden mehrere Abschnitte von geringer Qualit√§t entdeckt, die ich durch weitere 10 Risse korrigierte: <br><br> <code>$ for RIP_ID in $(seq -w 1 100); do echo -n "rip$RIP_ID: "; cmp -l analysis-out.wav rips-cd1-pioneer/rip${RIP_ID}/*.wav | wc -l ; done | sort -rgk2 | head -n 10 <br> rip054: 2865 <br> rip099: 974 <br> rip007: 533 <br> rip037: 452 <br> rip042: 438 <br> rip035: 404 <br> rip006: 392 <br> rip059: 381 <br> rip043: 327 <br> rip014: 323</code> <br> <br>  Ich fand auch etwas wirklich Interessantes: Mehrere Rips produzierten <i>genau den</i> gleichen Inhalt!  Denken Sie daran, dass dies genau das Erfolgskriterium f√ºr die EAC im "abgesicherten Modus" ist.  <code>shncat -q -e | rhash --print="%C"</code> Befehl <code>shncat -q -e | rhash --print="%C"</code>  <code>shncat -q -e | rhash --print="%C"</code> verwendet, um die CRC32-Pr√ºfsumme der Audio-Rohdaten zu berechnen <code>shncat -q -e | rhash --print="%C"</code> wird von der EAC verwendet. <br><br> <code>$ for wav in rips-cd1-pioneer/*/*.wav; do shncat "$wav" -q -e | rhash --printf="%C $wav\n" - ; done | sort -k1 <br> [...] <br> 9DD05FFF rips-cd1-pioneer/rip059/rip.wav <br> 9F8D1B53 rips-cd1-pioneer/rip072/rip.wav <br> A2EA0283 rips-cd1-pioneer/rip082/rip.wav <br> A595BC09 rips-cd1-pioneer/rip021/rip.wav <br> A595BC09 rips-cd1-pioneer/rip022/rip.wav <br> A595BC09 rips-cd1-pioneer/rip023/rip.wav <br> A595BC09 rips-cd1-pioneer/rip024/rip.wav <br> A595BC09 rips-cd1-pioneer/rip025/rip.wav <br> A595BC09 rips-cd1-pioneer/rip026/rip.wav <br> A595BC09 rips-cd1-pioneer/rip027/rip.wav <br> A595BC09 rips-cd1-pioneer/rip028/rip.wav <br> A595BC09 rips-cd1-pioneer/rip030/rip.wav <br> A595BC09 rips-cd1-pioneer/rip031/rip.wav <br> A595BC09 rips-cd1-pioneer/rip040/rip.wav <br> A595BC09 rips-cd1-pioneer/rip055/rip.wav <br> A595BC09 rips-cd1-pioneer/rip058/rip.wav <br> AA3B5929 rips-cd1-pioneer/rip043/rip.wav <br> ABAAE784 rips-cd1-pioneer/rip033/rip.wav <br> [...]</code> <br> <br>  Durch wiederholtes Zerrei√üen von Abschnitten mit geringer Qualit√§t konnten wir die Analyse ohne schwerwiegende Fehler abschlie√üen.  Und als ich diese Datei √ºberpr√ºfte, gab es genau den gleichen Audioinhalt wie beim "normalen" Rippen!  Dies reicht aus, um den Sieg zu erkl√§ren. <br><br>  Ich bin zu 99% sicher, dass ich diese problematische CD erfolgreich kopiert habe, und 0xA595BC09 ist der richtige CRC-Betrag f√ºr Titel 3. <br><br><h1>  Anhang A: vergleich.rs </h1><br>  Ich habe dieses Tool verwendet, um wahrscheinliche Bytefehler zu berechnen.  Es ist nicht f√ºr den Langzeitgebrauch gedacht, daher ist es etwas h√§sslich, aber es kann f√ºr diejenigen interessant sein, die auf diese Seite gesto√üen sind und das gleiche Problem gel√∂st haben. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> memmap; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::cmp; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::collections::HashMap; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::env; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::fs; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::sync; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::sync::mpsc; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::thread; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> memmap::Mmap; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CHUNK_SIZE: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">suspect_positions</span></span></span></span>( mmaps: &amp;HashMap&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, Mmap&gt;, start_idx: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, end_idx: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, ) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> positions = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ii <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> start_idx..end_idx { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> first = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> byte: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (_file_name, file_content) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> mmaps { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> first { byte = file_content[ii]; first = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> byte != file_content[ii] { positions.push(ii); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } positions } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> args: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; = env::args().collect(); args.remove(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> first = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> size: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> files: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;fs::File&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> mmaps: HashMap&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, Mmap&gt; = HashMap::new(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> filename <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> args { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> file = fs::File::open(&amp;filename).unwrap(); files.push(file); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mmap = <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { Mmap::map(files.last().unwrap()).unwrap() }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> first { first = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; size = mmap.len(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(size == mmap.len()); } mmaps.insert(filename, mmap); } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (suspects_tx, suspects_rx) = mpsc::channel(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> start_idx = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mmaps_ref = sync::Arc::new(mmaps); <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> t_start_idx = start_idx; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> t_end_idx = cmp::min(start_idx + CHUNK_SIZE, size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> start_idx == t_end_idx { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mmaps_ref = mmaps_ref.clone(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> suspects_tx = suspects_tx.clone(); thread::spawn(<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> || { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> suspects = suspect_positions(mmaps_ref.as_ref(), t_start_idx, t_end_idx); suspects_tx.send(suspects).unwrap(); }); start_idx = t_end_idx; } <span class="hljs-built_in"><span class="hljs-built_in">drop</span></span>(suspects_tx); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> suspects: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::with_capacity(size); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> suspects_chunk <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> suspects_rx { suspects.append(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> suspects_chunk); } suspects.sort(); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{{\"files\": ["</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> first_file = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (file_name, file_content) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> mmaps_ref.iter() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> file_comma = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> first_file { <span class="hljs-string"><span class="hljs-string">""</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-string"><span class="hljs-string">","</span></span> }; first_file = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}{{\"name\": \"{}\", \"suspect_bytes\": ["</span></span>, file_comma, file_name); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (ii, position) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> suspects.iter().enumerate() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> comma = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ii == suspects.len() - <span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-string"><span class="hljs-string">""</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-string"><span class="hljs-string">","</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"[{}, {}]{}"</span></span>, position, file_content[*position], comma); } <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"]}}"</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"]}}"</span></span>); }</code> </pre> <br>  1. <a name="1"></a>  In diesem einzelnen AccurateRip-Datensatz stimmt die CRC f√ºr alle Titel mit Ausnahme von Titel 3 mit meiner Disc √ºberein: Die Summe ist 0x84B9DD1A, und ich habe 0xA595BC09.  Ich vermute, dass der Ripper nicht verstanden hat, dass er einen schlechten Antrieb hat.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[zur√ºck]</a> <br><br>  2. <a name="2"></a>  Die offensichtliche Frage beim Kauf eines CD- oder DVD-Laufwerks im Jahr 2018 lautet: ‚ÄûVerdammt, wo kann ich sie kaufen?‚Äú  Und ich brauchte nicht eine, sondern <i>mehrere</i> von <i>verschiedenen Marken</i> .  Ich kenne nur ein Gesch√§ft in der N√§he, in dem 5,25-Zoll-DVD-Laufwerke verf√ºgbar sind. Nur ein Gesch√§ft ist gro√ü genug, um den Regalplatz f√ºr solche Laufwerke nicht zu bereuen, und seltsam genug, um dort nicht fehl am Platz zu sein. Nat√ºrlich, ich √ºber Frys Electronics sprechen. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[zur√ºck]</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418995/">https://habr.com/ru/post/de418995/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418979/index.html">Als ich durch das Land flog, implementierte ich ein Projekt f√ºr mehrere tausend Jobs</a></li>
<li><a href="../de418981/index.html">Numerische Methoden zur L√∂sung elliptischer Gleichungen</a></li>
<li><a href="../de418985/index.html">Analytik und Design als Ganzes</a></li>
<li><a href="../de418987/index.html">Firefox umgeht den Schutz in der neuen Google Mail-Oberfl√§che problemlos</a></li>
<li><a href="../de418991/index.html">Mikrofilm wird f√ºr ein halbes Jahrtausend existieren</a></li>
<li><a href="../de418997/index.html">Echter Beitrag zu Real Open Source</a></li>
<li><a href="../de418999/index.html">[Ank√ºndigung, Peter] JUG.ru-Treffen mit Andrei Belyaev und Alexei Stukalov - Troll unterdr√ºckt KUBA: FAQ</a></li>
<li><a href="../de419001/index.html">5 ‚ÄûSuper Skills‚Äú, die f√ºr die Arbeit der Zukunft notwendig sind</a></li>
<li><a href="../de419003/index.html">Blockchain News Digest</a></li>
<li><a href="../de419005/index.html">Ausflug zum Umspannwerk 220/110/20</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>