<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚶🏿 🤚🏾 🎓 Travailler avec des arbres de syntaxe JavaScript abstraits 💅🏾 🐟 🤓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pourquoi analyser votre code? Par exemple, afin de trouver le fichier console.log oublié avant de valider. Mais que faire si vous devez modifier la si...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Travailler avec des arbres de syntaxe JavaScript abstraits</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/428628/">  Pourquoi analyser votre code?  Par exemple, afin de trouver le fichier console.log oublié avant de valider.  Mais que faire si vous devez modifier la signature de la fonction en centaines d'entrées dans le code?  Les expressions régulières vont-elles y faire face?  Cet article vous montrera quelles possibilités les arbres de syntaxe abstraite offrent à un développeur. <br><br><img src="https://habrastorage.org/webt/l6/7k/fh/l67kfhnakjfo3vquzkyvklpwrns.png"><br><br>  Under the cut - une vidéo et une transcription textuelle d'un rapport de Kirill Cherkashin ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">z6Dabrata</a> ) de la conférence <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HolyJS 2018 Piter</a> . <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ILSpvViUlPU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i><b>À propos de l'auteur</b></i> <i><br></i>  <i>Cyril est né à Moscou, vit maintenant à New York et travaille chez Firebase.</i>  <i>Enseigne Angular non seulement chez Google, mais partout dans le monde.</i>  <i>L'organisateur du plus grand mitap angulaire au monde est AngularNYC (ainsi que VueNYC et ReactNYC).</i>  <i>Dans ses temps libres consacrés à la programmation, il aime le tango, les livres et les conversations agréables.</i> <br><br><h2>  Scie à métaux ou bois? </h2><br>  Commençons par un exemple: disons que vous avez débogué un programme et envoyé les modifications apportées à git, après quoi vous vous êtes couché tranquillement.  Le matin, il s'est avéré que vos collègues ont téléchargé vos modifications et, puisque vous avez oublié de supprimer la sortie des informations de débogage vers la console la veille, il l'affiche et bouche la sortie.  Beaucoup ont été confrontés à ce problème. <br><br>  Il existe des outils, comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">EsLint</a> , pour corriger la situation, mais à des fins éducatives, essayons de trouver une solution par nous-mêmes. <br>  Quel outil dois-je utiliser pour supprimer tous les <code>console.log()</code> du code? <br>  Nous choisissons entre les expressions régulières et l'utilisation d'arbres Sitax abstraits (ASD).  Essayons de résoudre ce problème avec des expressions régulières en écrivant une fonction <code>findConsoleLog</code> .  À l'entrée, il recevra le code du programme en tant qu'argument et affichera true si console.log () se trouve quelque part dans le texte du programme. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findConsoleLog</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">code</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !!code.match(<span class="hljs-regexp"><span class="hljs-regexp">/console.log/</span></span>); }</code> </pre><br>  J'ai écrit 17 tests, essayant de trouver différentes façons de briser notre fonction.  Cette liste est loin d'être complète. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c28/d83/9c4/c28d839c4c1450db0e7d752667ffd4c8.png"><br><br>  Le test le plus simple a réussi. <br>  Et si une fonction contient la chaîne «console.log» dans son nom? <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findConsoleLog</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">code</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !!code.match(<span class="hljs-regexp"><span class="hljs-regexp">/\bconsole.log/</span></span>); }</code> </pre><br>  Ajout d'un caractère qui indique que <code>console.log</code> doit apparaître au début du mot. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3cf/d71/598/3cfd715980aec5c9ead2421d87679fe8.jpg"><br><br>  Seuls deux tests ont réussi, mais que faire si <code>console.log</code> est dans le commentaire et n'a pas besoin d'être supprimé? <br><br>  Nous le réécrivons pour que l'analyseur ne touche pas les commentaires. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findConsoleLog</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">code</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !!code   .replace(<span class="hljs-regexp"><span class="hljs-regexp">/\/\/.*/</span></span>)   .match(<span class="hljs-regexp"><span class="hljs-regexp">/\bconsole.log/</span></span>); }</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/a24/518/df4/a24518df4bd82e31257e50f4723083da.jpg"><br><br>  Nous excluons la suppression de "console.log" des lignes: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findConsoleLog</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">code</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !!code   .replace(<span class="hljs-regexp"><span class="hljs-regexp">/\/\/.*|'.*'/</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>)   .match(<span class="hljs-regexp"><span class="hljs-regexp">/\bconsole.log/</span></span>); }</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/832/c81/94b/832c8194b5e62d995d939e798fc9f2af.jpg"><br><br>  N'oubliez pas que nous avons encore des espaces et d'autres caractères qui peuvent empêcher certains tests de passer: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/077/793/86c/07779386cbd54babe9f0aff7db1c35f3.jpg"><br><br>  Malgré le fait que l'idée n'était pas assez simple, les 17 tests utilisant des expressions régulières peuvent être réussis.  Ici donc, dans ce cas, le code de la solution ressemblera: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findConsoleLog</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">code</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> code   .replace(<span class="hljs-regexp"><span class="hljs-regexp">/\/\/.*|'.*?[^\\]'|".*?"|`[\s\S]*`|\/\*[\s\S]*\*\//</span></span>)   .match(<span class="hljs-regexp"><span class="hljs-regexp">/\bconsole\s*.log\(/</span></span>); }</code> </pre><br><br>  Le problème est que ce code ne couvre pas tous les cas possibles, et il est assez difficile à maintenir. <br><br>  Considérez comment résoudre ce problème en utilisant ASD. <br><br><h2>  Comment les arbres poussent-ils? </h2><br>  L'arborescence de syntaxe abstraite est obtenue grâce à l'analyseur syntaxique travaillant avec le code de votre application.  L'analyseur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@ babel / parser a</a> été utilisé pour la démonstration <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">.</a> <br>  À titre d'exemple, prenez la chaîne <code>console.log('holy')</code> , passez-la dans l'analyseur. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { parse } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'babylon'</span></span>; parse(<span class="hljs-string"><span class="hljs-string">"console.log('holy')"</span></span>);</code> </pre><br>  Grâce à son travail, un fichier JSON d'environ 300 lignes est obtenu.  Nous excluons de leurs lignes numériques les informations de service.  Nous nous intéressons à la section corps.  La méta-information ne nous intéresse pas non plus.  Le résultat est d'environ 100 lignes.  Comparé à la structure que le navigateur génère pour une variable de corps (environ 300 lignes), ce n'est pas beaucoup. <br><br>  Examinons quelques exemples de la façon dont divers littéraux sont représentés dans le code dans un arbre de syntaxe: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0d1/ca2/867/0d1ca286756a8f61b77edcff73ed95c1.jpg"><br><br>  C'est une expression dans laquelle il y a Numeric Literal, un littéral numérique. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4bd/c34/419/4bdc34419216b4a39c3636cee741cbab.png"><br><br>  L'expression console.log déjà familière.  Il a un objet qui a une propriété. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/11e/860/609/11e8606097dc09b48bf993c0be5dbdff.jpg"><br><br>  Si log est un appel de fonction, la description est la suivante: il existe une expression d'appel, elle a des arguments - des littéraux numériques.  En même temps, l'expression appelante a un journal de noms. <br><br>  Les littéraux peuvent être différents: nombres, chaînes, expressions régulières, booléens, null. <br>  Retour à l'appel console.log <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e1/4cb/2f2/9e14cb2f2efccc2fb7a43c4fa1945fd9.jpg"><br><br>  Il s'agit d'une expression d'appel qui contient une expression de membre.  De là, il est clair que l'objet console à l'intérieur possède une propriété appelée log. <br><br><h2>  Contournement ASD </h2><br>  Essayons maintenant de travailler avec cette structure dans le code.  La bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">babel-traverse</a> sera utilisée pour parcourir l'arbre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">.</a> <br><br>  Les mêmes 17 tests sont donnés.  Un tel code est obtenu en analysant l'arbre de syntaxe du programme et en recherchant les entrées de "console.log": <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traverseConsoleLog</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">code, {babylon, babelTraverse, types, log}</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ast = babylon.parse(code); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hasConsoleLog = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; babelTraverse(ast, {   MemberExpression(path){     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (       path.node.property.type === <span class="hljs-string"><span class="hljs-string">'Identifier'</span></span> &amp;&amp;       path.node.property.name === <span class="hljs-string"><span class="hljs-string">'log'</span></span> &amp;&amp;       path.node.object.type === <span class="hljs-string"><span class="hljs-string">'Identifier'</span></span> &amp;&amp;       path.node.object.name === <span class="hljs-string"><span class="hljs-string">'console'</span></span> &amp;&amp;       path.parent.type === <span class="hljs-string"><span class="hljs-string">'CallExpression'</span></span> &amp;&amp;       path.Parentkey === <span class="hljs-string"><span class="hljs-string">'callee'</span></span>     ) {       hasConsoleLog = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;     }   } }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasConsoleLog; }</code> </pre><br>  Analysons ce qui est écrit ici. <code>const ast = babylon.parse(code);</code>  dans la variable ast, nous analysons l'arbre de syntaxe du code.  Ensuite, nous donnons à la bibliothèque babel-parse cet arbre pour le traitement.  Nous recherchons des nœuds et des propriétés avec des noms correspondants dans les expressions d'appel.  Définissez la variable hasConsoleLog sur true si la combinaison requise de nœuds et de leurs noms est trouvée. <br><br>  Nous pouvons nous déplacer dans l'arbre, prendre les parents des nœuds, des descendants, chercher quels arguments et propriétés ils ont, regarder les noms de ces propriétés, types - c'est très pratique. <br><br>  Il y a une nuance désagréable qui peut être facilement corrigée en utilisant la bibliothèque babel-types.  Afin d'éviter les erreurs lors de la recherche dans l'arborescence en raison d'un nom incorrect, par exemple, au lieu de <code>path.parent.type === 'CallExpression'</code> vous avez accidentellement écrit <code>path.parent.type === 'callExpression'</code> , avec les types babel, vous pouvez écrire comme ceci : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Before path.node.property.type === 'Identifier' path.node.property.name === 'log' // with babel types import {isIdentifier} from 'babel-types'; isIdentifier(path.node.property, {name: log}) //         ,  ,    isIdentifier,     </span></span></code> </pre><br>  Nous réécrivons le code précédent à l'aide de babel-types: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traverseConsoleLogSolved2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">code, {babylon, babelTraverse, types}</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ast = babylon.parse(code); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hasConsoleLog = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; babelTraverse(ast, {   MemberExpression(path) {     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (       types.isIdentifier(path.node.object, { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'console'</span></span>}) &amp;&amp;       types.isIdentifier(path.node.property, { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'log'</span></span>}) &amp;&amp;       types.isCallExpression(path.parent) &amp;&amp;       path.parentKey === <span class="hljs-string"><span class="hljs-string">'callee'</span></span>     ) {       hasConsoleLog = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;     }   } }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasConsoleLog; }</code> </pre><br><h2>  Transformer l'ASD en utilisant babel-traverse </h2><br>  Pour réduire les coûts de main-d'œuvre, nous avons besoin que <code>console.log</code> immédiatement supprimé du code - au lieu d'un signal indiquant qu'il se trouve dans le code. <br><br>  Puisque nous devons supprimer non pas le MemberExpression lui-même, mais son parent, en place <code>hasConsoleLog = true;</code>  nous écrivons <code>path.parentPath.remove();</code>  . <br><br>  De la fonction <code>removeConsoleLog</code> , nous <code>removeConsoleLog</code> toujours une valeur booléenne.  Nous remplaçons sa sortie par le code qui va générer le générateur de babel, comme ceci: <br>  <code>hasConsoleLog</code> =&gt; <code>babelGenerator(ast).code</code> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Babel-generator</a> reçoit l'arborescence de syntaxe abstraite modifiée en tant que paramètre, renvoie un objet avec la propriété de code, à l'intérieur de cet objet se trouve du code régénéré sans <code>console.log</code> .  Soit dit en passant, si nous voulons obtenir une carte de code, nous pouvons appeler la propriété sourceMaps pour cet objet. <br><br><h2>  Et si vous avez besoin de trouver un débogueur? </h2><br>  Cette fois, nous utiliserons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ASTexplorer</a> pour terminer la tâche.  Le débogueur est un type de nœud d'instruction de débogueur.  Nous n'avons pas besoin de regarder toute la structure, car il s'agit d'un type spécial de nœud, il suffit de trouver l'instruction de débogage.  Nous allons écrire un plugin pour ESLint (sur ASTexplorer). <br><br>  ASTexplorer est conçu de telle manière que vous écrivez le code à gauche et à droite vous obtenez le TSA fini.  Vous pouvez choisir dans quel format vous souhaitez le recevoir: JSON ou sous forme d'arborescence. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e91/ee0/ecc/e91ee0ecc1d31ec006dcb4e99fa04d49.jpg"><br><br>  Puisque nous utilisons ESLint, il fera tout le travail de recherche de fichiers pour nous et nous donnera le fichier souhaité afin que nous puissions y trouver la ligne de débogage.  Cet outil utilise un analyseur ASD différent.  Cependant, il existe plusieurs types de TSA en JavaScript.  Quelque chose qui rappelle le passé, lorsque différents navigateurs implémentaient la spécification de différentes manières.  Ainsi, nous implémentons la recherche du débogueur: <br><br><pre> <code class="hljs lua">export default <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {   DebuggerStatement(node) { // ,     console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>    <span class="hljs-built_in"><span class="hljs-built_in">path</span></span>,    -  ,     <span class="hljs-built_in"><span class="hljs-built_in">path</span></span>         context.report(node, <span class="hljs-string"><span class="hljs-string">'LOL Debugger!!!'</span></span>); //   ESLint ,   debugger, node     ,    ,    debugger   } } }</code> </pre><br>  Vérification du travail d'un plugin écrit: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/90e/334/3fe/90e3343fe59bb834c9725beeb925598b.jpg"><br><br>  De même, vous pouvez supprimer le débogueur du code. <br><br><h2>  Quelles sont les autres TSA utiles </h2><br>  Personnellement, j'utilise ASD pour simplifier le travail avec Angular et d'autres cadres frontaux.  Vous pouvez importer, développer, ajouter une interface, une méthode, un décorateur et tout le reste en cliquant sur un bouton.  Bien que nous parlions de Javascript dans ce cas, cependant, TypeScript a également ses propres ASD, la seule différence est la différence entre les noms des types de nœuds et la structure.  Dans le même ASTExplorer peut être sélectionné comme langage TypeScript. <br><br>  Donc: <br><br><ul><li>  Nous avons plus de contrôle sur le code, une refactorisation plus facile, des codemods.  Par exemple, avant de valider, vous pouvez appuyer sur une seule touche pour formater l'intégralité du code conformément aux directives.  Codemods implique une correspondance automatique du code selon la version requise du framework. <br></li><li>  Moins de conflits sur la conception du code. <br></li><li>  Vous pouvez créer des projets de jeux.  Par exemple, donnez automatiquement au programmeur des commentaires sur le code qu'il écrit. <br></li><li>  Meilleure compréhension de JavaScript. <br></li></ul><br><h2>  Quelques liens utiles pour Babel </h2><br><ol><li>  Toutes les transformations Babel utilisent cette API: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plugins et presets</a> . <br></li><li>  Une partie du processus d'ajout de nouvelles fonctionnalités à ECMAScript consiste à créer un plugin pour Babel.  Cela est nécessaire pour que les utilisateurs puissent tester la nouvelle fonctionnalité.  Si vous suivez le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lien</a> , vous pouvez voir qu'à l'intérieur de la même manière les capacités de l'ASD sont utilisées.  Par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">opérateur d'affectation logique</a> . <br></li><li>  Babel Generator perd le formatage lors de la génération de code.  C'est en partie bien, car si cet outil est utilisé dans l'équipe de développement, après avoir généré le code à partir de l'ASD, il aura la même apparence pour tout le monde.  Mais si vous souhaitez conserver votre mise en forme, vous pouvez utiliser l'un de ces outils: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Refonte</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Babel CodeMod</a> . <br></li><li>  À partir de ce lien, vous pouvez trouver une mine d'informations sur Babel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Awesome Babel</a> . <br></li><li>  Babel est un projet open source et une équipe de bénévoles y travaille.  Tu peux aider.  Il y a trois façons de le faire: une aide financière, vous pouvez soutenir le site Web de Patreon, sur lequel travaille Henry Zhu, l'un des principaux contributeurs de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Babel</a> , aider avec le code sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">opencollective.com/babel</a> . <br></li></ol><br><h2>  Bonus </h2><br>  Sinon, comment trouver notre <code>console.log</code> dans le code?  Utilisez votre IDE!  Utilisation de l'outil Rechercher et remplacer, après avoir sélectionné où rechercher le code. <br>  Intellij IDEA dispose également d'un outil de «recherche structurelle» qui peut vous aider à trouver les bons endroits dans votre code, en passant, il utilise un ASD. <br><br><blockquote>  <b>Du 24 au 25 novembre,</b> Kirill fera une présentation sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les données binaires JavaScript * LOVES *</a> à <b>Moscou HolyJS</b> : nous allons descendre au niveau des données binaires, creuser dans des fichiers binaires en utilisant des fichiers * .gif à titre d'exemple, et traiter des cadres de sérialisation tels que Protobuf ou Thrift.  Après le rapport, il sera possible de parler avec Cyril et de discuter de toutes les questions d'intérêt dans la zone de discussion. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr428628/">https://habr.com/ru/post/fr428628/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr428614/index.html">Vendredi. Les délires du programmeur 4.2</a></li>
<li><a href="../fr428616/index.html">Convertissez des fichiers XLS en feuille de calcul Google à l'aide de Google Apps Script</a></li>
<li><a href="../fr428620/index.html">Comment créer Roguelike</a></li>
<li><a href="../fr428624/index.html">Jeffrey Richter, Pavel Yosifovich, Greg Young et tout-tout. Hardcore et architecture à DotNext 2018 Moscou</a></li>
<li><a href="../fr428626/index.html">Comment rendre l'extension en PHP7 plus difficile que "bonjour, monde", et ne pas devenir aux yeux rouges. Partie 1</a></li>
<li><a href="../fr428630/index.html">Non, le Bitcoin ne détruira pas notre climat d'ici 2033.</a></li>
<li><a href="../fr428632/index.html">Gérer les intercepteurs dans React</a></li>
<li><a href="../fr428634/index.html">Portage de Quake3</a></li>
<li><a href="../fr428636/index.html">Roskomnadzor va récupérer une amende de Google</a></li>
<li><a href="../fr428638/index.html">Hearts Flame Motor: examen du moniteur cardiaque QardioCore</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>