<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🤝‍👨🏼 🤘🏼 🚊 Optimalisasi permintaan basis data pada contoh layanan B2B untuk pembangun 📼 👩‍👩‍👦‍👦 🤫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagaimana cara tumbuh 10 kali di bawah jumlah permintaan basis data tanpa pindah ke server yang lebih efisien dan menjaga sistem tetap berfungsi? Saya...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimalisasi permintaan basis data pada contoh layanan B2B untuk pembangun</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461071/"> Bagaimana cara tumbuh 10 kali di bawah jumlah permintaan basis data tanpa pindah ke server yang lebih efisien dan menjaga sistem tetap berfungsi?  Saya akan memberi tahu Anda bagaimana kami berjuang dengan penurunan kinerja basis data kami, bagaimana kami mengoptimalkan permintaan SQL untuk melayani sebanyak mungkin pengguna dan tidak menambah biaya sumber daya komputasi. <br><a name="habracut"></a><br>  Saya membuat layanan untuk mengelola proses bisnis di perusahaan konstruksi.  Sekitar 3 ribu perusahaan bekerja bersama kami.  Lebih dari 10 ribu orang bekerja dengan sistem kami selama 4-10 jam setiap hari.  Ini memecahkan berbagai tugas perencanaan, peringatan, peringatan, validasi ... Kami menggunakan PostgreSQL 9.6.  Kami memiliki sekitar 300 tabel dalam database dan setiap hari hingga 200 juta permintaan (10 ribu berbeda) dikirim ke sana.  Rata-rata, kami memiliki 3-4 ribu permintaan per detik, pada saat-saat paling aktif lebih dari 10 ribu permintaan per detik.  Sebagian besar permintaan adalah OLAP.  Ada penambahan yang jauh lebih sedikit, modifikasi dan penghapusan, yaitu, beban OLTP relatif kecil.  Saya memberikan semua angka ini sehingga Anda dapat mengevaluasi ruang lingkup proyek kami dan memahami bagaimana pengalaman kami dapat berguna bagi Anda. <br><br><h3>  Gambar pertama.  Liris </h3><br>  Ketika kami memulai pengembangan, kami tidak benar-benar berpikir tentang jenis muatan apa yang akan ada di database dan apa yang akan kami lakukan jika server berhenti menarik.  Saat merancang basis data, kami mengikuti rekomendasi umum dan berusaha untuk tidak menembak diri sendiri, tetapi di luar kiat umum seperti “jangan gunakan pola <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nilai Atribut Entitas</a> , kami tidak melakukannya.  Dirancang berdasarkan prinsip normalisasi, menghindari redundansi data dan tidak peduli mempercepat pertanyaan tertentu.  Segera setelah pengguna pertama tiba, kami mengalami masalah kinerja.  Seperti biasa, kami benar-benar tidak siap untuk ini.  Masalah pertama sederhana.  Sebagai aturan, semuanya diputuskan dengan menambahkan indeks baru.  Tetapi ada saatnya ketika tambalan sederhana berhenti bekerja.  Setelah menyadari bahwa tidak ada pengalaman yang cukup dan menjadi semakin sulit untuk memahami apa penyebab masalah, kami mempekerjakan spesialis yang membantu kami mengatur server dengan benar, menghubungkan pemantauan, menunjukkan ke mana harus mencari untuk mendapatkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">statistik</a> . <br><br><h3>  Gambar kedua.  Statistik </h3><br>  Jadi kami memiliki sekitar 10 ribu kueri berbeda yang dijalankan pada basis data kami per hari.  Dari 10 ribu ini, ada monster yang berlari 2-3 juta kali dengan waktu lari rata-rata 0,1-0,3 ms dan ada pertanyaan dengan waktu lari rata-rata 30 detik yang disebut 100 kali sehari. <br><br>  Itu tidak mungkin untuk mengoptimalkan semua 10 ribu kueri, jadi kami memutuskan untuk mencari tahu di mana harus mengarahkan upaya untuk meningkatkan kinerja database dengan benar.  Setelah beberapa iterasi, kami mulai membagi permintaan menjadi beberapa tipe. <br><br><h4>  Kueri TOP </h4><br>  Ini adalah pertanyaan yang paling sulit yang membutuhkan waktu paling lama (total waktu).  Ini adalah query yang disebut sangat sering atau query yang membutuhkan waktu sangat lama (query yang panjang dan sering dioptimalkan bahkan pada iterasi pertama dari perjuangan untuk kecepatan).  Akibatnya, server menghabiskan waktu paling banyak pada eksekusi mereka secara total.  Selain itu, penting untuk memisahkan permintaan teratas dengan total waktu pelaksanaan dan secara terpisah oleh waktu IO.  Cara untuk mengoptimalkan pertanyaan semacam itu sedikit berbeda. <br><br>  Praktik yang biasa dilakukan semua perusahaan adalah bekerja dengan permintaan TOP.  Ada beberapa dari mereka, optimasi bahkan satu permintaan dapat membebaskan 5-10% sumber daya.  Namun, seiring dengan bertambahnya proyek, mengoptimalkan kueri TOP menjadi tugas yang semakin tidak sepele.  Semua metode sederhana telah berhasil, dan bahkan permintaan yang paling “sulit” menghilangkan “hanya” 3-5% sumber daya.  Jika total permintaan TOP membutuhkan waktu kurang dari 30-40%, maka kemungkinan besar Anda telah melakukan upaya untuk membuatnya bekerja dengan cepat dan inilah saatnya untuk beralih ke mengoptimalkan permintaan dari grup berikutnya. <br>  Tetap menjawab pertanyaan berapa banyak kueri teratas untuk disertakan dalam grup ini.  Saya biasanya mengambil tidak kurang dari 10, tetapi tidak lebih dari 20. Saya mencoba untuk memastikan bahwa waktu yang pertama dan terakhir dalam kelompok TOP berbeda tidak lebih dari 10 kali.  Artinya, jika waktu eksekusi permintaan turun tajam dari 1 tempat ke 10, maka saya mengambil TOP-10, jika musim gugur lebih lancar, maka saya meningkatkan ukuran grup menjadi 15 atau 20. <br><img src="https://habrastorage.org/webt/y5/j5/yx/y5j5yxa6u4kxlpahplsaprh07ro.png" alt="gambar"><br><br><h4>  Petani menengah (menengah) </h4><br>  Ini semua permintaan yang langsung muncul setelah TOP, dengan pengecualian 5-10% terakhir.  Biasanya, dalam mengoptimalkan permintaan khusus ini terletak kemampuan untuk sangat meningkatkan kinerja server.  Pertanyaan ini dapat "menimbang" hingga 80%.  Tetapi bahkan jika bagian mereka telah melebihi 50%, maka sudah saatnya untuk melihat mereka lebih dekat. <br><br><h4>  Buntut </h4><br>  Seperti yang dikatakan, permintaan ini berjalan pada akhirnya dan mereka mengambil 5-10% dari waktu.  Anda dapat melupakannya hanya jika Anda tidak menggunakan alat analisis kueri otomatis, maka pengoptimalannya juga bisa murah. <br><br>  Bagaimana cara mengevaluasi setiap kelompok? <br><br>  Saya menggunakan kueri SQL yang membantu membuat penilaian untuk PostgreSQL (saya yakin bahwa untuk banyak DBMS lainnya Anda dapat menulis kueri yang sama) <br><br><div class="spoiler">  <b class="spoiler_title">Permintaan SQL untuk memperkirakan ukuran grup TOP-MEDIUM-TAIL</b> <div class="spoiler_text"><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(time_top) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> sum_top, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(time_medium) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> sum_medium, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(time_tail) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> sum_tail <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> rn &lt;= <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> tt_percent <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> time_top, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> rn &gt; <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> rn &lt;= <span class="hljs-number"><span class="hljs-number">800</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> tt_percent <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> time_medium, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> rn &gt; <span class="hljs-number"><span class="hljs-number">800</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> tt_percent <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> time_tail <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> total_time / (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(total_time) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_statements) * <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> tt_percent, <span class="hljs-keyword"><span class="hljs-keyword">query</span></span>, ROW_NUMBER () <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> total_time <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> rn <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_statements <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> total_time <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> t ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ts</code> </pre> <br></div></div><br>  Hasil kueri adalah tiga kolom, yang masing-masing berisi persentase waktu yang dihabiskan untuk memproses permintaan dari grup ini.  Di dalam kueri, ada dua angka (dalam kasus saya, 20 dan 800) yang memisahkan permintaan dari satu grup dari yang lain. <br><br>  Ini adalah bagaimana proporsi permintaan pada saat dimulainya pekerjaan optimasi sekarang secara kasar berkorelasi. <br><br><img src="https://habrastorage.org/webt/db/at/i_/dbati_rdn49yulwdicigqdvrgew.png"><br><br>  Diagram menunjukkan bahwa bagian permintaan TOP telah menurun tajam, tetapi "petani menengah" telah tumbuh. <br>  Awalnya, TOP blunder memukul kueri TOP.  Seiring waktu, penyakit pada masa anak-anak hilang, bagian permintaan TOP berkurang, dan lebih banyak upaya harus dilakukan untuk mempercepat permintaan yang sulit. <br><br><div class="spoiler">  <b class="spoiler_title">Untuk mendapatkan teks dari permintaan kami menggunakan permintaan tersebut</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ROW_NUMBER () <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> total_time <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> rn, total_time / (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(total_time) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_statements) * <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> tt_percent, <span class="hljs-keyword"><span class="hljs-keyword">query</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_statements <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> total_time <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> T <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> rn &lt;= <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-comment"><span class="hljs-comment">-- TOP -- rn &gt; 20 AND rn &lt;= 800 -- MEDIUM -- rn &gt; 800 -- TAIL</span></span></code> </pre><br></div></div><br>  Berikut adalah daftar trik yang paling umum digunakan yang membantu kami mempercepat kueri TOP: <br><br><ul><li>  Mendesain ulang sistem, misalnya, memproses logika pemberitahuan pada pialang pesan alih-alih permintaan basis data berkala </li><li>  Menambah atau Memodifikasi Indeks </li><li>  Menulis ulang permintaan ORM dalam SQL murni </li><li>  Menulis ulang logika pemuatan data malas </li><li>  Caching melalui denormalisasi data.  Misalnya, kami memiliki tautan antara tabel Pengiriman -&gt; Faktur -&gt; Permintaan -&gt; Permintaan.  Artinya, setiap pengiriman dikaitkan dengan aplikasi melalui tabel lain.  Agar tidak menautkan semua tabel di setiap permintaan, kami menggandakan tautan ke aplikasi di tabel Pengiriman. </li><li>  Caching tabel statis dengan direktori dan jarang mengubah tabel dalam memori program. </li></ul><br>  Terkadang perubahan menyeret pada desain ulang yang mengesankan, tetapi mereka memberikan 5-10% dari bongkar sistem dan dibenarkan.  Seiring waktu, knalpot menjadi semakin berkurang, dan desain ulang menjadi semakin serius. <br><br>  Lalu kami menarik perhatian pada kelompok permintaan kedua - kelompok petani menengah.  Ini memiliki lebih banyak permintaan dan tampaknya akan membutuhkan banyak waktu untuk menganalisis seluruh grup.  Namun, sebagian besar pertanyaan ternyata sangat sederhana untuk optimasi, dan banyak masalah diulang puluhan kali dalam variasi yang berbeda.  Berikut adalah beberapa contoh optimisasi khas yang kami terapkan pada lusinan kueri serupa dan setiap grup kueri yang dioptimalkan menurunkan database sebesar 3-5%. <br><br><ul><li>  Alih-alih memeriksa keberadaan catatan dengan COUNT dan pemindaian tabel penuh, EXISTS mulai digunakan. <br></li><li>  Kami menyingkirkan DISTINCT (tidak ada resep umum, tetapi kadang-kadang Anda dapat dengan mudah menyingkirkannya dengan mempercepat permintaan 10-100 kali). <br><br>  Misalnya, alih-alih meminta untuk memilih semua driver pada tabel pengiriman yang besar (PENGIRIMAN) <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DISTINCT</span></span> P.ID, P.FIRST_NAME, P.LAST_NAME <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> DELIVERY D <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> PERSON P <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> D.DRIVER_ID = P.ID</code> </pre><br>  membuat permintaan untuk tabel PERSON yang relatif kecil <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> P.ID, P.FIRST_NAME, P.LAST_NAME <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> PERSON <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> D.ID <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> DELIVERY <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> D.DRIVER_ID = P.ID)</code> </pre><br>  Tampaknya kami menggunakan subquery yang berkorelasi, tetapi memberikan percepatan lebih dari 10 kali. <br></li><li>  Dalam banyak kasus, COUNT dan <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diganti dengan perhitungan nilai perkiraan</a> <br></li><li>  bukannya <br><br><pre> <code class="sql hljs">UPPER(s) LIKE JOHN%'</code> </pre><br>  gunakan <br><br><pre> <code class="sql hljs">s ILIKE “John%”</code> </pre><br></li></ul><br>  Setiap permintaan khusus terkadang dipercepat sebanyak 3-1000 kali.  Terlepas dari kinerja yang mengesankan, pada awalnya kami merasa bahwa tidak ada gunanya mengoptimalkan kueri, yang dieksekusi selama 10 ms, termasuk dalam ke-3 dari kueri terberat dan dalam total waktu pemuatan basis data, butuh ratusan persen.  Tetapi dengan menerapkan resep yang sama pada sekelompok permintaan serupa, kami memenangkan beberapa persen.  Agar tidak membuang waktu secara manual untuk melihat ratusan kueri, kami menulis beberapa skrip sederhana yang, menggunakan ekspresi reguler, menemukan kueri yang serupa.  Akibatnya, pencarian otomatis untuk grup kueri memungkinkan kami untuk lebih meningkatkan kinerja kami dengan menghabiskan upaya sederhana. <br><br>  Sebagai hasilnya, kami telah mengerjakan perangkat keras yang sama selama tiga tahun sekarang.  Beban harian rata-rata sekitar 30%, pada puncaknya mencapai 70%.  Jumlah permintaan serta jumlah pengguna telah meningkat sekitar 10 kali lipat.  Dan semua ini berkat pemantauan terus-menerus dari kelompok-kelompok kueri TOP-MEDIUM ini.  Segera setelah permintaan baru muncul di grup TOP, kami segera menganalisanya dan mencoba mempercepatnya.  Kami meninjau grup MENENGAH seminggu sekali menggunakan skrip analisis kueri.  Jika Anda menemukan permintaan baru yang telah kami ketahui cara mengoptimalkannya, maka kami segera mengubahnya.  Terkadang kami menemukan metode optimasi baru yang dapat diterapkan ke beberapa kueri sekaligus. <br><br>  Menurut perkiraan kami, server saat ini akan menahan peningkatan jumlah pengguna sebanyak 3-5 kali.  Benar, kami memiliki satu kartu truf lagi di lengan, kami masih belum menerjemahkan pertanyaan SELECT ke cermin, seperti yang disarankan.  Tapi kami tidak melakukan ini secara sadar, karena kami pertama-tama ingin sepenuhnya menguras kemungkinan optimasi "pintar" sebelum menyalakan "artileri berat". <br>  Pandangan kritis pada pekerjaan yang dilakukan mungkin menyarankan menggunakan penskalaan vertikal.  Beli server yang lebih kuat, daripada menghabiskan waktu para spesialis.  Server mungkin tidak terlalu mahal, terutama karena batas penskalaan vertikal belum habis.  Namun, hanya jumlah permintaan meningkat 10 kali lipat.  Selama beberapa tahun, fungsi sistem telah meningkat dan sekarang ada lebih banyak jenis permintaan.  Fungsionalitas yang disebabkan oleh caching dilakukan oleh lebih sedikit permintaan, apalagi permintaan yang lebih efisien.  Jadi, Anda dapat dengan aman mengalikan 5 dengan yang lain untuk mendapatkan koefisien akselerasi yang sebenarnya.  Jadi, menurut perkiraan paling konservatif, kita dapat mengatakan bahwa akselerasi adalah 50 kali atau lebih.  Mengguncang server secara vertikal 50 kali lebih mahal.  Terutama mengingat bahwa begitu optimasi dilakukan sepanjang waktu, dan tagihan untuk server sewaan datang setiap bulan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id461071/">https://habr.com/ru/post/id461071/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id461059/index.html">Menulis Aplikasi Android untuk Penggemar Film - Bagian 1 (Prototyping)</a></li>
<li><a href="../id461061/index.html">Paduan magnesium, batas kembar, dan pemisahan</a></li>
<li><a href="../id461063/index.html">Interaksi R dengan database pada contoh Microsoft SQL Server dan DBMS lainnya</a></li>
<li><a href="../id461067/index.html">65 pertanyaan SQL teratas dari wawancara kerja yang harus Anda persiapkan di tahun 2019. Bagian I</a></li>
<li><a href="../id461069/index.html">Kamera IP Luar Ruangan Nobelic: Tes, Teknologi, dan Kemampuan Sistem Pengawasan Video Ivideon</a></li>
<li><a href="../id461073/index.html">Kami menghubungkan peta online ke navigator di smartphone. Bagian 3 - OverpassTurbo</a></li>
<li><a href="../id461075/index.html">Kecerdasan bisnis. Objek IT, komponen, alat</a></li>
<li><a href="../id461077/index.html">Bagaimana pentester dimasak? Pengujian Pintu Masuk untuk Interns Keamanan Digital</a></li>
<li><a href="../id461079/index.html">Kota tanpa kemacetan lalu lintas</a></li>
<li><a href="../id461081/index.html">Hari ketika Dodo berhenti. Skrip asinkron</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>