<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ÜòÔ∏è üîå üßï (Est√°tico) Sele√ß√£o de cont√™ineres ideais em programas C ++ üìÆ ü¶ç üà≤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√°. Hoje eu gostaria de falar novamente sobre an√°lise est√°tica. E novamente sobre C ++. Somente, diferentemente do PVS-Studio, n√£o procuraremos erros...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>(Est√°tico) Sele√ß√£o de cont√™ineres ideais em programas C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455379/">  Ol√°.  Hoje eu gostaria de falar novamente sobre an√°lise est√°tica.  E novamente sobre C ++.  Somente, diferentemente do PVS-Studio, n√£o procuraremos erros em nossos programas (embora eles procurem n√£o apenas erros), mas tamb√©m por locais que n√£o foram escritos da maneira ideal.  E um desses lugares √© escolher um cont√™iner para os dados no programa.  Se eu sou do seu interesse, bem-vindo ao gato! <br><a name="habracut"></a><br><h3>  O problema </h3><br>  No CoreHard 2018 Autumn (uma confer√™ncia muito boa, venha), falei sobre como os compiladores C ++ n√£o otimizam bem no momento.  E <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uma</a> das minhas queixas foi que os compiladores n√£o podem otimizar o uso de cont√™ineres em nossos programas.  Vejamos alguns exemplos de c√≥digo. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v(<span class="hljs-number"><span class="hljs-number">42</span></span>); }</code> </pre> <br>  Parece que, em um caso t√£o simples, o compilador deve ser capaz de otimizar essa fun√ß√£o e simplesmente lan√ßar uma declara√ß√£o vari√°vel do tipo std :: vector, j√° que a partir do C ++ 14, o compilador pode remover aloca√ß√µes din√¢micas de mem√≥ria, mas o compilador n√£o.  A raz√£o para isso √© que, no momento, apenas um compilador C ++ implementa otimiza√ß√£o para remover aloca√ß√µes din√¢micas - Clang.  Todos os outros compiladores at√© agora n√£o sabem como fazer isso.  Mas mesmo Clang pode fazer isso em um n√∫mero limitado de casos. <br><br>  Nesse caso, poder√≠amos substituir std :: vector por std :: array, desde que o tamanho do vetor selecionado n√£o seja muito grande, pois podemos n√£o ter pilha suficiente para essa substitui√ß√£o.  Essa substitui√ß√£o remover√° uma aloca√ß√£o de mem√≥ria bastante cara para o heap, e a vantagem √© que, ao usar std :: array, o compilador j√° pode lan√ßar std :: array completamente da fun√ß√£o! <br><br>  Se estamos falando sobre otimiza√ß√£o de desempenho, propomos considerar o seguinte exemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">42</span></span>; ++i) { v.insert(v.begin(), <span class="hljs-number"><span class="hljs-number">42</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> val : v) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; val &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; } }</code> </pre> <br>  Nesse caso, vemos o uso de uma opera√ß√£o extremamente ineficaz no caso da inser√ß√£o std :: vector no in√≠cio do cont√™iner.  Todos os programadores de C ++ sabem que isso √© extremamente ruim de fazer, pois faz com que todos os elementos sejam alterados todas as vezes, o que leva a grandes custos de c√≥pia / movimenta√ß√£o.  Seria muito melhor nesse caso substitu√≠-lo por std :: list, que n√£o importa onde a inser√ß√£o ocorre, ou std :: deque (embora seja nesse caso que voc√™ possa ver claramente que n√£o precisa apenas usar insert. Mas este √© apenas um exemplo, n√£o mais :) <br><br>  Vejamos outro exemplo de c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; ++i) { v.push_front(i); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> val : v) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; val &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; } }</code> </pre> <br>  Nesse caso, podemos notar que podemos substituir std :: list sem problemas (sim, eu sei que poucas pessoas o usam) por std :: forward_list.  Nesse caso, nesse caso, n√£o perderemos absolutamente nada, mas obteremos economia de mem√≥ria.  Naturalmente, o compilador n√£o faz essa otimiza√ß√£o agora. <br><br>  Um truque semelhante pode ser feito no seguinte exemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">deque</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; ++i) { v.push_back(i); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; ++i) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; v.back() &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; v.pop_back(); } }</code> </pre> <br>  Aqui podemos ver que o que realmente precisamos n√£o √© std :: deque, mas std :: stack.  Isso n√£o pode ser chamado de otimiza√ß√£o, pois std :: stack √© um adaptador e, por padr√£o, ele usa std :: deque dentro (a menos que o usu√°rio especifique o contr√°rio).  Aqui, podemos falar mais sobre otimiza√ß√£o sem√¢ntica, ou seja,  simplificando o c√≥digo para entender.  Do meu ponto de vista, isso tamb√©m √© importante.  Se voc√™ perguntar: "Talvez essa substitui√ß√£o tamb√©m traga um ganho de desempenho?", Responderei: "Talvez.  Veja os detalhes da implementa√ß√£o em sua vers√£o da biblioteca padr√£o. ‚Äù <br><br>  Bem, acho que existem exemplos suficientes.  Cada um de voc√™s tamb√©m pode criar muitos deles. <br><br><h3>  Ferramentas usadas </h3><br>  Para implementar o analisador est√°tico, usei o Clang Static Analzyer (CSA) e o Clang Tidy, que fazem parte do pacote LLVM.  Escolhi essas ferramentas, pois as considero as mais promissoras entre as ferramentas abertas para an√°lise est√°tica.  Al√©m disso, o Clang fornece um dos analisadores de C ++ da mais alta qualidade dos quais outros analisadores est√°ticos n√£o podem se gabar (a n√£o ser, √© claro, que eles usem libclang). <br><br>  O CSA e o Clang Tidy s√£o analisadores est√°ticos, ambos parte do LLVM.  Qual a diferen√ßa?  A diferen√ßa √© que o Clang Tidy foi projetado para escrever verifica√ß√µes simples, que consistem basicamente em encontrar algum tipo de padr√£o na √°rvore de sintaxe abstrata, exibindo algum tipo de aviso e possivelmente substituindo-o automaticamente por outro.  Voc√™ pode aprender mais sobre Clang Tidy <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  O CSA foi projetado para escrever verifica√ß√µes mais "s√©rias" e com uso intensivo de recursos (do ponto de vista da implementa√ß√£o e do ponto de vista do tempo de execu√ß√£o / mem√≥ria gasta).  L√°, por exemplo, um mecanismo de execu√ß√£o simb√≥lico est√° dispon√≠vel. <br><br>  Decidi implementar a verifica√ß√£o no CSA, uma vez que n√£o me parece comum, al√©m disso, no futuro, ser√° cada vez mais dif√≠cil.  E foi decidido executar o Clang Tidy, pois esse analisador est√°tico tem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">muitas</a> integra√ß√µes com v√°rios IDEs. <br><br><h3>  Como vamos (tentar) resolver problemas </h3><br>  Para come√ßar, vale a pena introduzir algumas restri√ß√µes bastante fortes, relacionadas principalmente ao fato de que este √© apenas um prot√≥tipo: <br><br><ul><li>  An√°lise apenas no n√≠vel de fun√ß√µes;  Essa limita√ß√£o significa que n√£o haver√° an√°lise entre fun√ß√µes, bem como entre unidades de convers√£o.  A restri√ß√£o na an√°lise entre fun√ß√µes foi imposta para simplificar a implementa√ß√£o dessa an√°lise e, no futuro, pode ser corrigida com relativa facilidade, executando uma an√°lise est√°tica para toda a unidade de tradu√ß√£o, e n√£o apenas para cada fun√ß√£o.  A restri√ß√£o na an√°lise entre unidades de tradu√ß√£o √© imposta pelas restri√ß√µes existentes no CSA, que ser√£o corrigidas em breve (confirma√ß√µes j√° est√£o sendo lan√ßadas no upstream); </li><li>  Suporte apenas para um n√∫mero limitado de cont√™ineres.  Isso √© relativamente f√°cil de corrigir no futuro, adicionando novas regras para novos cont√™ineres. </li><li>  Use para an√°lise apenas uma √°rvore de sintaxe abstrata.  J√° que para a prototipagem, esse √© o tipo mais simples de an√°lise.  Para resultados mais precisos, √© claro, voc√™ pode tentar usar pelo menos a execu√ß√£o simb√≥lica, mas esse m√©todo tem suas desvantagens.  Voc√™ pode ler mais sobre m√©todos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </li></ul><br>  Agora, o prot√≥tipo implementa o seguinte algoritmo simples: <br><br><ul><li>  Primeiro, na √°rvore de sintaxe abstrata, encontramos os v√©rtices respons√°veis ‚Äã‚Äãpor declarar as vari√°veis ‚Äã‚Äãde tipo de cont√™iner que suportamos. </li><li>  Em seguida, encontramos as opera√ß√µes relacionadas a esses cont√™ineres, classificamos e salvamos essas informa√ß√µes em um cache tempor√°rio. </li><li>  Ap√≥s chegar ao final da fun√ß√£o, analisamos as estat√≠sticas coletadas e, com base em regras predefinidas, emitimos uma recomenda√ß√£o sobre o uso de um cont√™iner. </li></ul><br>  A classifica√ß√£o das opera√ß√µes de cont√™ineres no momento √© a seguinte (ser√° expandida no futuro): <br><br><ul><li>  Adicione um item √† parte superior do cont√™iner. </li><li>  Adicionando um item ao meio do cont√™iner. </li><li>  Adicionando um item ao final do cont√™iner. </li><li>  Removendo um item do in√≠cio do cont√™iner. </li><li>  Removendo um item do meio do cont√™iner. </li><li>  Removendo um item do final do cont√™iner. </li></ul><br>  A classifica√ß√£o no momento est√° incompleta e mesmo nesta lista n√£o funciona corretamente.  Por exemplo, a opera√ß√£o de inser√ß√£o, mesmo que seja realizada no in√≠cio, o analisador classifica como inser√ß√£o no meio, embora na verdade n√£o seja. <br><br><h3>  Combate a falsos positivos </h3><br>  Em qualquer an√°lise est√°tica, os falsos positivos s√£o a principal dor de cabe√ßa.  Se houver muitos deles, as mensagens √∫teis ser√£o perdidas no lixo.  Portanto, nesse caso, voc√™ deve agir de maneira muito conservadora e emitir avisos somente nos casos em que estivermos realmente confiantes em nossos diagn√≥sticos e poderemos dizer que algo est√° realmente errado em algum lugar do c√≥digo. <br><br>  Se estamos falando sobre otimiza√ß√£o de compilador, ainda √© mais triste - a otimiza√ß√£o adequada n√£o pode alterar o comportamento do programa de acordo com o padr√£o C ++ (caso contr√°rio, esse otimizador n√£o vale nada).  E a otimiza√ß√£o tamb√©m n√£o deve introduzir pessimiza√ß√£o :) Ent√£o, voc√™ deve ter muito mais cuidado com suas decis√µes. <br><br>  Nesse analisador, essa luta resultou no fato de que, se o analisador perceber que alguma opera√ß√£o n√£o suportada est√° sendo executada no momento, a an√°lise desse cont√™iner ser√° desativada. <br><br><h3>  Desvantagens e poss√≠veis solu√ß√µes </h3><br>  Existem v√°rios problemas com este m√©todo. <br><br>  O primeiro problema √© que, para o analisador no momento, todas as ramifica√ß√µes do c√≥digo s√£o igualmente prov√°veis.  Mais precisamente, ele nem conhece ramos diferentes da execu√ß√£o de c√≥digo. <br>  Isso se traduz em problemas com a an√°lise para algo como este c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* ptr, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ptr == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { v.insert(v.begin(), <span class="hljs-number"><span class="hljs-number">42</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { v.push_back(<span class="hljs-number"><span class="hljs-number">84</span></span>); } }</code> </pre> <br>  Muito provavelmente, em nossa aplica√ß√£o, essas ramifica√ß√µes de c√≥digo n√£o t√™m probabilidades iguais de execu√ß√£o, pois no mundo real um ponteiro geralmente indica algo normal, e n√£o nullptr.  No mesmo LLVM existem heur√≠sticas est√°ticas nesse escore.  Por exemplo, ele leva em considera√ß√£o o caso acima ao comparar ponteiros com nullptr e comparar entre si a igualdade de valores de duas vari√°veis ‚Äã‚Äãcom um ponto flutuante e alguns outros casos interessantes.  Mas isso √© cada vez mais parecido com muletas e, do meu ponto de vista, a solu√ß√£o real para esse problema √© adicionar an√°lise ou instrumenta√ß√£o din√¢mica. <br><br>  O segundo problema √© a falta de suporte para cont√™ineres personalizados.  Vivemos no mundo do C ++, eles gostam de andar aqui (vamos deixar a discuss√£o dos motivos desse fen√¥meno nem sempre ruim fora do escopo deste artigo) de tudo, incluindo nossos cont√™ineres.  Exemplos incluem o mesmo LLVM, LibreOffice e muitos outros.  Nesse sentido, surge a quest√£o - como analisar cont√™ineres que n√£o s√£o da biblioteca STL?  Afinal, eu gostaria de incluir an√°lises para o maior n√∫mero poss√≠vel de cont√™ineres. <br><br>  Existem diferentes maneiras de resolver o problema. <br><br>  A primeira √© que o usu√°rio anota seus cont√™ineres de alguma forma (um tipo especial de coment√°rio, atributos C ++, outra coisa).  O problema com esse m√©todo √© que precisamos entender como anotar em geral, quais informa√ß√µes precisamos para uma an√°lise qualitativa.  Outro problema pode ser a modifica√ß√£o do c√≥digo dos cont√™ineres, o que nem sempre √© poss√≠vel. <br><br>  O segundo m√©todo oferece ao usu√°rio um mecanismo para escrever suas pr√≥prias regras.  No momento, as regras no analisador s√£o costuradas no c√≥digo-fonte do pr√≥prio analisador e, se o usu√°rio quiser adicionar suas pr√≥prias regras, ele precisar√° fazer o download do c√≥digo-fonte do analisador, mont√°-lo, descobrir como escrever verifica√ß√µes, escrever, reconstruir etc.  Voc√™ pode fornecer ao usu√°rio uma maneira de definir suas verifica√ß√µes em algumas DSL, nas quais o usu√°rio grava apenas verifica√ß√µes de seus cont√™ineres e o analisador est√° envolvido em toda a rotina.  Considero esse m√©todo mais promissor que o anterior. <br><br>  Al√©m disso, a substitui√ß√£o autom√°tica de cont√™iner n√£o √© suportada, pois essa funcionalidade n√£o est√° no CSA (mas est√° no Clang Tidy).  Mas, em casos dif√≠ceis, executar a AutoCorre√ß√£o nem sempre √© uma tarefa trivial, e o analisador funciona mais provavelmente no modo semi-manual. <br><br><h3>  Poss√≠veis aplica√ß√µes </h3><br>  Vejo v√°rias aplica√ß√µes para esse tipo de an√°lise: <br><br><ol><li>  Como um analisador est√°tico.  Tudo √© simples aqui - outro teste de an√°lise est√°tica, que voc√™ executa como seu cora√ß√£o deseja (com as m√£os, no IDE automaticamente durante o desenvolvimento, no IC, etc.), onde voc√™ provavelmente ter√° uma dica de que em algum lugar poderia pegar um recipiente e melhor. </li><li>  Como otimiza√ß√£o no compilador.  Em alguns casos, podemos garantir que a substitui√ß√£o do cont√™iner definitivamente n√£o afetar√° negativamente o desempenho.  Por exemplo, substituindo std :: vector por tamanhos pequenos conhecidos em tempo de compila√ß√£o por std :: array ou substituindo std :: list por std :: forward_list quando n√£o precisamos de conex√£o dupla e n√£o tiramos o tamanho da lista.  O compilador pode substituir cont√™ineres por outros mais ideais, sem o nosso conhecimento, como j√° acontece em um grande n√∫mero de coisas. </li><li>  Como um analisador din√¢mico.  Essa √© a dire√ß√£o que me parece mais promissora para esse tipo de an√°lise.  De fato, com a ajuda do conhecimento sobre o perfil de execu√ß√£o do programa, podemos, por exemplo, obter informa√ß√µes t√£o importantes para n√≥s quanto as probabilidades de cada execu√ß√£o de ramifica√ß√£o de c√≥digo.  E isso √© necess√°rio para uma avalia√ß√£o mais precisa.  E com essa an√°lise, voc√™ j√° pode pensar na dire√ß√£o da integra√ß√£o com o PGO ... </li></ol><br>  Tamb√©m √© importante notar que esse m√©todo √© aplic√°vel, √© claro, n√£o apenas para programas em C ++.  Eu realmente gostaria de ver esse tipo de an√°lise / otimiza√ß√£o est√°tica no compilador e em outras linguagens de programa√ß√£o.  Por exemplo, o analisador est√°tico SAP para ABAP j√° sabe como realizar an√°lises est√°ticas de otimiza√ß√£o em um n√≠vel b√°sico, o que √© uma boa not√≠cia.  Se voc√™ conhece projetos similares para outras linguagens de programa√ß√£o - escreva nos coment√°rios e adicionarei ao artigo! <br><br><h3>  Trabalhe em dire√ß√µes semelhantes </h3><br>  Para o mundo C ++, n√£o encontrei esses analisadores em lugar algum.  Para o mundo ABAP, mencionei o analisador acima, que pode encontrar opera√ß√µes ineficientes para uma parte dos cont√™ineres padr√£o, mas at√© onde eu sei, uma an√°lise est√°tica muito simples √© implementada l√°. <br><br>  Um trabalho muito mais interessante √© o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Chameleon</a> - um analisador din√¢mico para Java, que √© muito inteligente.  Eles ajustaram um pouco a JVM e, durante a opera√ß√£o, coletam v√°rias estat√≠sticas sobre o uso de cont√™ineres e, dependendo do perfil de carga atual, selecionam determinados cont√™ineres e os substituem automaticamente durante a opera√ß√£o.  Infelizmente, as fontes est√£o fechadas e n√£o h√° chance de obt√™-las (tentei). <br><br>  Eu tamb√©m recomendo olhar para v√°rios trabalhos (existem muitos) no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SETL</a> .  Neles, os autores tamb√©m costumavam levantar quest√µes sobre a sele√ß√£o autom√°tica do cont√™iner. <br><br><h3>  Refer√™ncias </h3><br><ol><li>  Implementa√ß√£o atual no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">C ++ R√∫ssia 2017: Yuri Efimochev, clang-tidy: uma jornada dentro da √°rvore de sintaxe abstrata do C ++</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Camale√£o: Sele√ß√£o Adaptativa de Cole√ß√µes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Guia do analisador est√°tico de clang</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bate-papo</a> em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">russo</a> sobre o desenvolvimento de compiladores no Telegram.  Se voc√™ estiver interessado, entre, √© muito interessante l√°.  Apenas tome cuidado com o dil√∫vio - eles o punir√£o imediatamente :) </li></ol><br>  Em vez de uma conclus√£o, eu gostaria de focar no fato de que ele √© apenas um prot√≥tipo at√© agora e tem muitos "buracos" na implementa√ß√£o.  Neste artigo, s√≥ quero compartilhar com voc√™ a ideia de uma an√°lise e sua populariza√ß√£o.  Bem, talvez algu√©m esteja interessado neste t√≥pico e haver√° um desejo de se conectar ao projeto - eu ficarei feliz apenas!  Al√©m disso, voc√™ sempre pode coletar este analisador em seu pr√≥prio local para experiment√°-lo nos seus exemplos de teste. <br><br>  Se voc√™ tem algo para complementar o material, encontrou um problema semelhante ou simplesmente possui algumas informa√ß√µes que podem ser √∫teis sobre esse t√≥pico - n√£o hesite em compartilhar essas informa√ß√µes nos coment√°rios. <br><br>  Obrigado pela aten√ß√£o! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt455379/">https://habr.com/ru/post/pt455379/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt455369/index.html">Certifica√ß√£o de administradores de banco de dados e muito mais no anivers√°rio do DevConfX (21 a 22 de junho em Moscou)</a></li>
<li><a href="../pt455371/index.html">Fonte de corrente est√°vel de 5 ŒºA a 20 mA</a></li>
<li><a href="../pt455373/index.html">Como ajustar a lei da Primavera para que ela se torne uma eleva√ß√£o para pequenos fornecedores? Cancele</a></li>
<li><a href="../pt455375/index.html">Escrevendo UDR em Pascal</a></li>
<li><a href="../pt455377/index.html">Arquitetura IoT</a></li>
<li><a href="../pt455381/index.html">O suporte t√©cnico da 3CX responde: captura o tr√°fego SIP no servidor PBX</a></li>
<li><a href="../pt455387/index.html">Compreendendo o aprendizado de m√°quina no Elastic Stack (aka Elasticsearch, aka ELK)</a></li>
<li><a href="../pt455389/index.html">Haxe 4: O que h√° de novo?</a></li>
<li><a href="../pt455391/index.html">Parte 1: RISC-V / RocketChip em um habitat n√£o natural</a></li>
<li><a href="../pt455393/index.html">Sobre o uso de m√©todos param√©tricos de estimativa espectral em radar - o m√©todo MUSIC. Adi√ß√£o ao artigo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>