<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚷 🧘🏼 ☃️ Cara Kerja JS: Pohon Sintaksis Abstrak, Parsing, dan Optimalisasi 🌨️ Ⓜ️ 👷</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[Nasihat membaca] 19 bagian siklus lainnya  Bagian 1: Tinjauan umum mesin, mekanisme runtime, panggilan stack 
 Bagian 2: Tentang V8 internal dan opti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara Kerja JS: Pohon Sintaksis Abstrak, Parsing, dan Optimalisasi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/415269/"><div class="spoiler">  <b class="spoiler_title">[Nasihat membaca] 19 bagian siklus lainnya</b> <div class="spoiler_text">  Bagian 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tinjauan umum mesin, mekanisme runtime, panggilan stack</a> <br>  Bagian 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tentang V8 internal dan optimasi kode</a> <br>  Bagian 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengelola memori, empat jenis memori bocor dan berurusan dengannya</a> <br>  Bagian 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Event Loop, Async, dan Five Ways untuk Meningkatkan Kode Anda dengan async / menunggu</a> <br>  Bagian 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WebSocket dan HTTP / 2 + SSE.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa yang harus dipilih?</a> <br>  Bagian 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fitur dan ruang lingkup WebAssembly</a> <br>  Bagian 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pekerja Web dan Lima Skenario Penggunaan</a> <br>  Bagian 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pekerja Layanan</a> <br>  Bagian 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemberitahuan push web</a> <br>  Bagian 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lacak perubahan di DOM dengan MutationObserver</a> <br>  Bagian 11: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mesin rendering halaman web dan tip untuk mengoptimalkan kinerja mereka</a> <br>  Bagian 12: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Subsistem jaringan browser, mengoptimalkan kinerja dan keamanannya</a> <br>  Bagian 12: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Subsistem jaringan browser, mengoptimalkan kinerja dan keamanannya</a> <br>  Bagian 13: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Animasi dengan CSS dan JavaScript</a> <br>  Bagian 14: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana JS Bekerja: Pohon Sintaks Abstrak, Parsing dan Optimalisasi nya</a> <br>  Bagian 15: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara kerja JS: kelas dan warisan, transpilasi dalam Babel dan TypeScript</a> <br>  Bagian 16: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara Kerja JS: Penyimpanan</a> <br>  Bagian 17: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana JS Bekerja: Shadow DOM Technology dan Komponen Web</a> <br>  Bagian 18: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana JS Bekerja: Mekanisme Komunikasi WebRTC dan P2P</a> <br>  Bagian 19: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara Kerja JS: Elemen Kustom</a> </div></div><br>  Kita semua tahu bahwa kode JavaScript untuk proyek web dapat tumbuh hingga sangat besar.  Dan semakin besar kode, semakin lama browser memuatnya.  Namun masalahnya di sini bukan hanya waktu pengiriman data melalui jaringan.  Setelah program dimuat, masih perlu diuraikan, dikompilasi menjadi bytecode, dan akhirnya dieksekusi.  Hari ini kami menyampaikan kepada Anda terjemahan bagian 14 dari seri ekosistem JavaScript.  Yaitu, kita akan berbicara tentang penguraian kode JS, bagaimana pohon sintaksis abstrak dibangun, dan bagaimana seorang programmer dapat memengaruhi proses ini, mencapai peningkatan kecepatan aplikasi mereka. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/68b/b2c/231/68bb2c231dd5b82bd35e97ceb36becef.jpg" alt="gambar"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Bagaimana bahasa pemrogramannya</font> </h2><br>  Sebelum berbicara tentang pohon sintaksis abstrak, mari kita memikirkan bagaimana bahasa pemrograman bekerja.  Terlepas dari bahasa yang Anda gunakan, Anda selalu harus menggunakan program tertentu yang mengambil kode sumber dan mengubahnya menjadi sesuatu yang berisi perintah khusus untuk mesin.  Penerjemah atau kompiler bertindak sebagai program tersebut.  Tidak masalah apakah Anda menulis dalam bahasa yang ditafsirkan (JavaScript, Python, Ruby), atau dikompilasi (C #, Java, Rust), kode Anda, yang merupakan teks biasa, akan selalu melalui tahap parsing, yaitu, mengubah teks biasa menjadi struktur data disebut Pohon Sintaksis Abstrak (AST). <br><br>  Pohon sintaksis abstrak tidak hanya menyediakan representasi terstruktur dari kode sumber, mereka juga memainkan peran penting dalam analisis semantik, di mana kompiler memverifikasi kebenaran konstruk perangkat lunak dan penggunaan elemen-elemennya secara benar.  Setelah membentuk AST dan melakukan pemeriksaan, struktur ini digunakan untuk menghasilkan bytecode atau kode mesin. <br><br><h2>  <font color="#3AC1EF">Menggunakan pohon sintaksis abstrak</font> </h2><br>  Pohon sintaksis abstrak digunakan tidak hanya dalam interpreter dan kompiler.  Mereka, di dunia komputer, berguna di banyak bidang lain.  Salah satu aplikasi yang paling umum adalah analisis kode statis.  Analisis statis tidak mengeksekusi kode yang diberikan kepada mereka.  Namun, meskipun demikian, mereka perlu memahami struktur program. <br><br>  Misalkan Anda ingin mengembangkan alat yang menemukan struktur yang sering terjadi dalam kode Anda.  Laporan alat semacam itu akan membantu dalam refactoring dan akan mengurangi duplikasi kode.  Ini dapat dilakukan dengan menggunakan perbandingan string yang biasa, tetapi pendekatan ini akan sangat primitif, kemampuannya akan terbatas.  Bahkan, jika Anda ingin membuat alat serupa, Anda tidak perlu menulis parser Anda sendiri untuk JavaScript.  Ada banyak implementasi open source dari program-program semacam itu yang sepenuhnya kompatibel dengan spesifikasi ECMAScript.  Misalnya - Esprima dan Acorn.  Ada juga alat yang dapat membantu dalam bekerja dengan apa yang dihasilkan parser, yaitu, dalam bekerja dengan pohon sintaksis abstrak. <br><br>  Pohon sintaksis abstrak, di samping itu, banyak digunakan dalam pengembangan transpiler.  Misalkan Anda memutuskan untuk mengembangkan transpiler yang mengubah kode Python ke kode JavaScript.  Proyek serupa dapat didasarkan pada gagasan bahwa transpiler digunakan untuk membuat pohon sintaksis abstrak berdasarkan kode Python, yang, pada gilirannya, dikonversi ke kode JavaScript.  Mungkin di sini Anda akan bertanya-tanya bagaimana ini mungkin.  Masalahnya adalah bahwa pohon sintaksis abstrak hanyalah cara alternatif untuk mewakili kode dalam beberapa bahasa pemrograman.  Sebelum kode dikonversi ke AST, itu terlihat seperti teks biasa, ketika ditulis yang mengikuti aturan tertentu yang membentuk bahasa.  Setelah parsing, kode ini berubah menjadi struktur pohon yang berisi informasi yang sama dengan kode sumber program.  Akibatnya, dimungkinkan untuk melakukan tidak hanya transisi dari kode sumber ke AST, tetapi juga transformasi terbalik, mengubah pohon sintaksis abstrak menjadi representasi teks dari kode program. <br><br><h2>  <font color="#3AC1EF">Memilah JavaScript</font> </h2><br>  Mari kita bicara tentang bagaimana pohon sintaksis abstrak dibangun.  Sebagai contoh, pertimbangkan fungsi JavaScript sederhana: <br><br><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">10</span></span>) {        <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">2</span></span>;        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a * x;    }    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + <span class="hljs-number"><span class="hljs-number">10</span></span>; }</code> </pre> <br>  Parser akan membuat pohon sintaksis abstrak, yang secara skematis direpresentasikan dalam gambar berikut. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/631/4f0/bc1/6314f0bc14439c74d13d0aa21f2e63c7.png"></div><br>  <i><font color="#999999">Pohon sintaksis abstrak</font></i> <br><br>  Harap dicatat bahwa ini adalah representasi hasil parser yang disederhanakan.  Pohon sintaksis abstrak yang sebenarnya terlihat jauh lebih rumit.  Dalam hal ini, tujuan utama kami adalah untuk mendapatkan ide tentang apa, di tempat pertama, kode sumber berubah sebelum dieksekusi.  Jika Anda tertarik untuk melihat seperti apa struktur sintaksis abstrak nyata, gunakan situs web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AST Explorer</a> .  Untuk menghasilkan AST untuk fragmen JS-code tertentu, cukup menempatkannya di bidang yang sesuai pada halaman. <br><br>  Mungkin di sini Anda akan memiliki pertanyaan tentang mengapa programmer perlu tahu cara kerja parser JS.  Pada akhirnya, parsing dan mengeksekusi kode adalah tugas browser.  Di satu sisi, Anda benar.  Gambar di bawah ini menunjukkan waktu yang diperlukan untuk beberapa proyek web terkenal untuk melakukan berbagai langkah dalam proses mengeksekusi kode JS. <br><br>  Lihatlah gambar ini lebih dekat, mungkin Anda akan melihat sesuatu yang menarik di sana. <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/5c5/448/f14/5c5448f14dc1ec31ed7b2e89bb5a48a4.png"></a> </div><br>  <i><font color="#999999">Waktu yang dihabiskan untuk mengeksekusi kode JS</font></i> <br><br>  Lihat?  Jika tidak, lihat lagi.  Sebenarnya, kita berbicara tentang fakta bahwa, rata-rata, browser menghabiskan 15-20% dari waktu mem-parsing kode JS.  Dan ini bukan data bersyarat.  Berikut adalah informasi statistik tentang pekerjaan proyek web nyata yang menggunakan JavaScript dengan satu atau lain cara.  Mungkin angka 15% mungkin tidak terlalu besar bagi Anda, tapi percayalah, ini banyak.  Aplikasi satu halaman biasanya memuat sekitar 0,4 MB kode JavaScript, dan browser membutuhkan sekitar 370 ms untuk menguraikan kode ini.  Sekali lagi, Anda dapat mengatakan bahwa tidak ada yang perlu dikhawatirkan.  Dan ya, itu saja tidak banyak.  Namun, jangan lupa bahwa ini hanya waktu yang diperlukan untuk mengurai kode dan mengubahnya menjadi AST.  Ini tidak termasuk waktu yang diperlukan untuk mengeksekusi kode, atau waktu yang diperlukan untuk menyelesaikan tugas-tugas lain yang menyertai pemuatan halaman, misalnya, tugas-tugas pemrosesan HTML dan CSS dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rendering halaman</a> .  Selain itu, kami hanya berbicara tentang browser desktop.  Dalam kasus sistem seluler masih lebih buruk.  Secara khusus, waktu penguraian untuk kode yang sama pada perangkat seluler dapat 2-5 kali lebih lama daripada di desktop.  Lihatlah gambar berikut. <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/8ba/4e0/530/8ba4e0530a7420a96458b00963587380.jpg"></a> </div><br>  <i><font color="#999999">Parsing waktu 1 MB JS-code pada berbagai perangkat</font></i> <br><br>  Inilah waktu yang diperlukan untuk mengurai 1 MB kode JS pada berbagai perangkat seluler dan desktop. <br><br>  Selain itu, aplikasi web terus menjadi semakin kompleks, dan semakin banyak tugas yang ditransfer ke sisi klien.  Semua ini bertujuan untuk meningkatkan pengalaman pengguna bekerja dengan situs web, untuk membawa perasaan ini lebih dekat dengan perasaan yang dialami pengguna saat berinteraksi dengan aplikasi tradisional.  Sangat mudah untuk mengetahui seberapa besar ini mempengaruhi proyek web.  Untuk melakukan ini, cukup buka alat pengembang di browser, buka beberapa situs modern dan lihat berapa banyak waktu yang dihabiskan untuk mem-parsing kode, kompilasi, dan segala sesuatu yang terjadi di browser saat menyiapkan halaman untuk bekerja. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/469/77c/26b/46977c26b690fe60b485f732f43afba8.jpg"></div><br>  <i><font color="#999999">Analisis situs web menggunakan alat pengembang di browser</font></i> <br><br>  Sayangnya, peramban seluler tidak memiliki alat tersebut.  Namun, ini tidak berarti bahwa versi situs seluler tidak dapat dianalisis.  Di sini alat seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DeviceTiming</a> akan membantu kami.  Dengan DeviceTiming, Anda dapat mengukur waktu yang diperlukan untuk mem-parsing dan mengeksekusi skrip di lingkungan yang dikelola.  Ini berfungsi berkat penempatan skrip lokal di lingkungan yang dibentuk oleh kode tambahan, yang mengarah pada fakta bahwa setiap kali halaman dimuat dari berbagai perangkat, kami memiliki kesempatan untuk mengukur waktu penguraian dan eksekusi kode secara lokal. <br><br><h2>  <font color="#3AC1EF">Optimasi parsing dan mesin JS</font> </h2><br>  Mesin JS melakukan banyak hal berguna untuk menghindari pekerjaan yang tidak perlu dan mengoptimalkan proses pemrosesan kode.  Berikut ini beberapa contohnya. <br><br>  Mesin V8 mendukung skrip streaming dan caching kode.  Dalam hal ini, streaming berarti bahwa sistem mem-parsing skrip yang memuat secara tidak sinkron dan skrip yang tertunda di utas terpisah, mulai melakukan ini sejak kode mulai memuat.  Ini mengarah pada fakta bahwa parsing berakhir hampir bersamaan dengan selesainya memuat skrip, yang memberikan sekitar 10% pengurangan waktu yang diperlukan untuk menyiapkan halaman untuk bekerja. <br><br>  Kode JavaScript biasanya dikompilasi menjadi bytecode setiap kali halaman dikunjungi.  Namun bytecode ini hilang setelah pengguna menavigasi ke halaman lain.  Ini disebabkan oleh fakta bahwa kode yang dikompilasi sangat tergantung pada keadaan dan konteks sistem pada waktu kompilasi.  Untuk memperbaiki situasi, Chrome 42 memperkenalkan dukungan untuk caching bytecode.  Berkat inovasi ini, kode yang dikompilasi disimpan secara lokal, sebagai akibatnya, ketika pengguna kembali ke halaman yang telah dikunjungi, tidak perlu mengunduh, mengurai dan menyusun skrip untuk mempersiapkannya untuk bekerja.  Ini menghemat Chrome sekitar 40% dari waktu penguraian dan kompilasi.  Selain itu, dalam hal perangkat seluler, ini mengarah pada penghematan daya baterai. <br><br>  Mesin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Carakan</a> , yang digunakan dalam browser Opera dan telah diganti dengan V8 untuk waktu yang lama, dapat menggunakan kembali hasil kompilasi dari skrip yang sudah diproses.  Tidak perlu skrip ini dihubungkan ke halaman yang sama atau bahkan diambil dari domain yang sama.  Teknik caching ini, sebenarnya, sangat efektif dan memungkinkan Anda untuk sepenuhnya meninggalkan langkah kompilasi.  Dia mengandalkan skenario perilaku pengguna biasa, pada bagaimana orang bekerja dengan sumber daya web.  Yaitu, ketika pengguna mengikuti urutan tindakan tertentu, saat bekerja dengan aplikasi web, kode yang sama dimuat. <br><br>  Penerjemah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SpiderMonkey yang</a> digunakan oleh FireFox tidak menembolok segala sesuatu dalam satu baris.  Ini mendukung sistem pemantauan yang menghitung jumlah panggilan ke skrip tertentu.  Berdasarkan indikator-indikator ini, bagian dari kode yang perlu optimasi ditentukan, yaitu mereka yang memiliki beban maksimum. <br><br>  Tentu saja, beberapa pengembang browser mungkin memutuskan bahwa produk mereka tidak perlu di-cache sama sekali.  Jadi, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Masei Stachovyak</a> , pengembang terkemuka peramban Safari, mengatakan bahwa Safari tidak terlibat dalam caching yang disusun oleh bytecode.  Kemungkinan caching dipertimbangkan, tetapi belum diimplementasikan, karena pembuatan kode membutuhkan kurang dari 2% dari total waktu pelaksanaan program. <br><br>  Optimalisasi ini tidak secara langsung mempengaruhi penguraian kode sumber di JS.  Dalam perjalanan aplikasi mereka, segala kemungkinan dilakukan untuk, dalam kasus-kasus tertentu, sepenuhnya lewati langkah ini.  Tidak peduli seberapa cepat penguraian, masih membutuhkan waktu, dan ketiadaan penguraian mungkin merupakan contoh optimalisasi sempurna. <br><br><h2>  <font color="#3AC1EF">Kurangi waktu persiapan aplikasi web</font> </h2><br>  Seperti yang kami temukan di atas, akan lebih baik untuk meminimalkan kebutuhan untuk mem-parsing skrip, tetapi Anda tidak dapat sepenuhnya menghilangkannya, jadi mari kita bicara tentang bagaimana mengurangi waktu yang diperlukan untuk menyiapkan aplikasi web untuk bekerja.  Bahkan, banyak yang bisa dilakukan untuk ini.  Misalnya, Anda dapat meminimalkan jumlah kode JS yang termasuk dalam aplikasi.  Kode kecil yang menyiapkan halaman untuk pekerjaan dapat diurai lebih cepat, dan kemungkinan besar akan membutuhkan waktu lebih sedikit untuk dieksekusi daripada kode yang lebih produktif. <br><br>  Untuk mengurangi jumlah kode, Anda dapat mengatur pemuatan pada halaman hanya apa yang benar-benar dibutuhkan, dan bukan sepotong besar kode, yang mencakup segala sesuatu yang benar-benar diperlukan untuk proyek web secara keseluruhan.  Jadi, misalnya, pola <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PRPL</a> mempromosikan pendekatan semacam itu untuk memuat kode.  Sebagai alternatif, Anda dapat memeriksa dependensi dan melihat apakah ada sesuatu yang berlebihan di dalamnya, sehingga hanya mengarah pada pertumbuhan basis kode yang tidak dapat dibenarkan.  Bahkan, di sini kami menyinggung topik besar yang layak untuk materi terpisah.  Kembali ke penguraian. <br><br>  Jadi, tujuan dari bahan ini adalah untuk membahas teknik yang memungkinkan pengembang web untuk membantu parser melakukan tugasnya dengan lebih cepat.  Teknik seperti itu ada.  Parser JS modern menggunakan algoritma heuristik untuk menentukan apakah akan diperlukan untuk mengeksekusi sepotong kode sesegera mungkin, atau jika perlu dieksekusi nanti.  Berdasarkan prediksi ini, pengurai sepenuhnya menganalisis fragmen kode menggunakan algoritma penguraian yang bersemangat atau menggunakan algoritma penguraian malas.  Dengan analisis lengkap, Anda memahami fungsi yang harus dikompilasi sesegera mungkin.  Selama proses ini, tiga tugas utama diselesaikan: membangun AST, membuat hierarki area visibilitas, dan menemukan kesalahan sintaksis.  Analisis malas, di sisi lain, hanya digunakan untuk fungsi yang belum perlu dikompilasi.  Ini tidak membuat AST dan tidak mencari kesalahan.  Dengan pendekatan ini, hanya hierarki area visibilitas yang dibuat, yang menghemat sekitar separuh waktu dibandingkan dengan fungsi pemrosesan yang perlu dijalankan sesegera mungkin. <br><br>  Padahal, konsepnya bukan hal baru.  Bahkan browser yang sudah ketinggalan zaman seperti IE9 mendukung pendekatan optimasi seperti itu, walaupun, tentu saja, sistem modern telah melangkah jauh ke depan. <br><br>  Mari kita periksa contoh yang menggambarkan operasi mekanisme ini.  Misalkan kita memiliki kode JS berikut: <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + <span class="hljs-number"><span class="hljs-number">10</span></span>;   }   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">baz</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y;   }   console.log(baz(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>)); }</code> </pre> <br>  Seperti pada contoh sebelumnya, kode jatuh ke parser, yang melakukan parsing dan membentuk AST.  Akibatnya, parser mewakili kode yang terdiri dari bagian-bagian utama berikut (kami tidak akan memperhatikan fungsi <code>foo</code> ): <br><br><ul><li>  Mendeklarasikan fungsi <code>bar</code> yang membutuhkan satu argumen ( <code>x</code> ).  Fungsi ini memiliki satu perintah pengembalian, mengembalikan hasil dari penambahan <code>x</code> dan 10. </li><li>  Mendeklarasikan fungsi <code>baz</code> yang membutuhkan dua argumen ( <code>x</code> dan <code>y</code> ).  Dia juga memiliki satu perintah pengembalian, dia mengembalikan hasil penambahan <code>x</code> dan <code>y</code> . </li><li>  Melakukan panggilan ke fungsi <code>baz</code> dengan dua argumen - 100 dan 200. </li><li>  Melakukan panggilan ke fungsi <code>console.log</code> dengan satu argumen, yang merupakan nilai yang dikembalikan oleh fungsi yang sebelumnya disebut. </li></ul><br>  Ini tampilannya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6df/ba5/f7b/6dfba5f7b7e40d5067424ada6a1c9855.png"></div><br>  <i><font color="#999999">Hasil penguraian kode sampel tanpa menerapkan optimasi</font></i> <br><br>  Mari kita bicarakan apa yang terjadi di sini.  Pengurai melihat deklarasi fungsi <code>bar</code> , deklarasi fungsi <code>baz</code> , panggilan ke fungsi <code>baz</code> , dan panggilan ke fungsi <code>console.log</code> .  Jelas, parsing potongan kode ini, parser akan menghadapi tugas yang pelaksanaannya tidak akan mempengaruhi hasil program ini.  Ini tentang menganalisis <code>bar</code> fungsi.  Mengapa analisis fungsi ini tidak praktis?  Masalahnya adalah bahwa fungsi <code>bar</code> , setidaknya dalam fragmen kode yang disajikan, tidak pernah dipanggil.  Contoh sederhana ini mungkin tampak tidak masuk akal, tetapi banyak aplikasi nyata memiliki sejumlah besar fungsi yang tidak pernah dipanggil. <br><br>  Dalam situasi seperti itu, alih-alih mem-parsing fungsi <code>bar</code> , kita bisa mencatat bahwa itu dinyatakan, tetapi tidak digunakan di mana pun.  Pada saat yang sama, penguraian sebenarnya dari fungsi ini dilakukan ketika menjadi perlu, tepat sebelum pelaksanaannya.  Tentu saja, ketika melakukan parsing malas, Anda perlu mendeteksi tubuh fungsi dan membuat catatan deklarasi, tetapi di sinilah pekerjaan berakhir.  Untuk fungsi seperti itu, tidak perlu membentuk pohon sintaksis abstrak, karena sistem tidak memiliki informasi bahwa fungsi ini direncanakan untuk dilakukan.  Selain itu, memori tumpukan tidak dialokasikan, yang biasanya membutuhkan sumber daya sistem yang cukup besar.  Singkatnya, penolakan untuk mem-parsing fungsi yang tidak perlu mengarah pada peningkatan kinerja kode yang signifikan. <br><br>  Akibatnya, dalam contoh sebelumnya, pengurai nyata akan membentuk struktur yang menyerupai skema berikut. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3bb/202/a4d/3bb202a4de7b21c31cff3648403096ac.png"></div><br>  <i><font color="#999999">Hasil parsing kode contoh dengan optimasi</font></i> <br><br>  Perhatikan bahwa parser membuat catatan tentang deklarasi <code>bar</code> fungsi, tetapi tidak berurusan dengan analisis lebih lanjut.  Sistem tidak berusaha menganalisis kode fungsi.  Dalam hal ini, badan fungsi adalah perintah untuk mengembalikan hasil perhitungan sederhana.  Namun, di sebagian besar aplikasi dunia nyata, kode fungsi bisa lebih lama dan lebih kompleks, berisi banyak perintah pengembalian, kondisi, loop, perintah deklarasi variabel, dan fungsi bersarang.  Mem-parsing semua ini, asalkan fungsi-fungsi seperti itu tidak pernah dipanggil, adalah buang-buang waktu. <br><br>  Tidak ada yang rumit dalam konsep yang dijelaskan di atas, tetapi implementasi praktisnya bukanlah tugas yang mudah.  Di sini kami memeriksa contoh yang sangat sederhana, dan, pada kenyataannya, ketika memutuskan apakah suatu kode tertentu akan diminati dalam suatu program, perlu untuk menganalisis fungsi, dan loop, dan operator kondisional, dan objek.  Secara umum, kita dapat mengatakan bahwa parser perlu memproses dan menganalisis sepenuhnya semua yang ada dalam program. <br><br>  Di sini, misalnya, adalah pola yang sangat umum untuk menerapkan modul dalam JavaScript: <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myModule = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-comment"><span class="hljs-comment">//      //    })();</span></span></code> </pre> <br>  Kebanyakan parser JS modern mengenali pola ini, bagi mereka itu adalah sinyal bahwa kode yang terletak di dalam modul perlu dianalisis secara penuh. <br><br>  Tetapi bagaimana jika parser selalu menggunakan parsing malas?  Sayangnya, ini bukan ide yang baik.  Faktanya adalah bahwa dengan pendekatan ini, jika beberapa kode perlu dieksekusi sesegera mungkin, kita akan menghadapi perlambatan dalam sistem.  Parser akan melakukan satu pass parsing malas, setelah itu ia akan segera mulai sepenuhnya menganalisis apa yang perlu dilakukan sesegera mungkin.  Ini akan menyebabkan sekitar 50% perlambatan dibandingkan dengan pendekatan ketika parser segera mulai sepenuhnya mem-parsing kode yang paling penting. <br><br><h2>  <font color="#3AC1EF">Optimasi kode, dengan mempertimbangkan fitur analisisnya</font> </h2><br>  Sekarang kami telah menemukan sedikit tentang apa yang terjadi di dalam parser, sekarang saatnya untuk memikirkan apa yang dapat dilakukan untuk membantu mereka.  Kita dapat menulis kode sehingga fungsi parsing dilakukan pada saat yang kita butuhkan.  Ada satu pola yang dipahami sebagian besar parser.  Ini dinyatakan dalam fakta bahwa fungsi terlampir dalam tanda kurung.  Desain seperti itu hampir selalu memberi tahu parser bahwa fungsi perlu segera dibongkar.  Jika parser mendeteksi braket pembuka, segera setelah itu deklarasi fungsi berikut, itu akan segera mulai parsing fungsi.  Kami dapat membantu parser dengan menerapkan teknik ini saat menjelaskan fungsi yang perlu dilakukan sesegera mungkin. <br><br>  Misalkan kita memiliki fungsi <code>foo</code> : <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * <span class="hljs-number"><span class="hljs-number">10</span></span>; }</code> </pre> <br>  Karena tidak ada indikasi eksplisit dalam fragmen kode ini bahwa fungsi ini dijadwalkan untuk segera dieksekusi, browser hanya akan melakukan parsing malasnya.  Namun, kami yakin bahwa kami akan membutuhkan fungsi ini segera, sehingga kami dapat menggunakan trik berikutnya. <br><br>  Pertama, simpan fungsi dalam variabel: <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * <span class="hljs-number"><span class="hljs-number">10</span></span>; };</code> </pre> <br>  Harap perhatikan bahwa kami meninggalkan nama fungsi awal antara kata kunci <code>function</code> dan braket pembuka.  Tidak dapat dikatakan bahwa ini benar-benar diperlukan, tetapi disarankan untuk melakukan hal itu, karena jika pengecualian dilemparkan ketika fungsi sedang berjalan, Anda dapat melihat nama fungsi dalam data jejak tumpukan, bukan <code>&lt;anonymous&gt;</code> . <br><br>  Setelah perubahan di atas, parser akan terus menggunakan parsing malas.  Untuk mengubah ini, satu detail kecil sudah cukup.  Fungsi harus dilampirkan dalam tanda kurung: <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * <span class="hljs-number"><span class="hljs-number">10</span></span>; });</code> </pre> <br>  Sekarang, ketika parser menemukan braket pembuka di depan kata kunci <code>function</code> , ia akan segera mulai menguraikan fungsi ini. <br><br>  Mungkin tidak mudah untuk melakukan optimasi seperti itu secara manual, karena untuk ini Anda perlu tahu dalam kasus mana parser akan melakukan parsing malas, dan di mana penuh.  Selain itu, untuk melakukan ini, Anda perlu meluangkan waktu untuk memutuskan apakah fungsi tertentu harus siap untuk bekerja secepat mungkin atau tidak. <br><br>  Pemrogram, tentu saja, tidak akan mau memikul semua pekerjaan tambahan ini.  Selain itu, yang tidak kalah penting dari semua yang telah dikatakan, kode yang diproses dengan cara ini akan lebih sulit dibaca dan dipahami.  Dalam situasi ini, paket perangkat lunak khusus seperti Optimize.js siap membantu kami.  Tujuan utama mereka adalah untuk mengoptimalkan waktu boot awal untuk kode sumber JS.  Mereka melakukan analisis kode statis dan memodifikasinya sehingga fungsi-fungsi yang perlu dijalankan sesegera mungkin terlampir dalam tanda kurung, yang mengarah pada fakta bahwa browser segera mem-parsing mereka dan menyiapkannya untuk dieksekusi. <br><br>  Jadi, misalkan kita memprogram, tanpa benar-benar memikirkan apa pun, dan kita memiliki fragmen kode berikut: <br><br><pre> <code class="hljs matlab">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> {   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">('Hello, World!')</span></span></span><span class="hljs-function">; })</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>  Ini terlihat cukup normal, berfungsi seperti yang diharapkan, dieksekusi dengan cepat, karena parser menemukan braket pembuka di depan <code>function</code> kata kunci.  Sejauh ini bagus. ,       ,     ,    : <br><br><pre> <code class="hljs matlab">!<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">{</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">('Hello, World!')</span></span></span><span class="hljs-function">}</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>     ,    ,   .   ,   -        . <br><br>   ,      ,      .  ,     , ,         .  ,  ,    ,        .     ,        ,    .         Optimize.js.       Optimize.js,    : <br><br><pre> <code class="hljs matlab">!(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">{</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">('Hello, World!')</span></span></span><span class="hljs-function">})</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>      ,   .    ,   .       ,   ,         ,   —     . <br><br><h2> <font color="#3AC1EF"> </font> </h2><br>  ,  JS-   — ,    .        ?   ,           ,  , ,          .   ,    ,  ,    ,    JS-      ,          .  ,    ,       ,   -,        .       -  .       ,   ,    .          ,     , , ,              .  , JS-     ,  ,   V8     ,   ,     .                 . <br><br><h2> <font color="#3AC1EF">  </font> </h2><br>   ,       -: <br><br><ul><li>   .    . </li><li>       ,       . </li><li> ,   ,   ,  JS-.          ,     ,   . </li><li>       DeviceTiming  ,      . </li><li>    Optimize.js  ,      ,         . </li></ul><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>    ,    ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SessionStack</a> ,      ,    -,       .     ,         .     —       . ,     —    ,      -,  ,       ,       . <br><br>  <b>Pembaca yang budiman!</b>     -        JavaScript-? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id415269/">https://habr.com/ru/post/id415269/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id415257/index.html">8 Cara untuk Meningkatkan Visualisasi Data</a></li>
<li><a href="../id415259/index.html">pilih / poll / epoll: perbedaan praktis</a></li>
<li><a href="../id415261/index.html">VFX-artist dalam pengembangan game: fitur, karier, pengembangan</a></li>
<li><a href="../id415263/index.html">Bagaimana kami menambahkan pintu masuk ke peta dan mengurangi ukuran pangkalan sebesar 10%</a></li>
<li><a href="../id415265/index.html">Mencari penerus KL-7: RACE dan AROFLEX</a></li>
<li><a href="../id415271/index.html">Bagaimana Gantt Charts Menyederhanakan Manajemen Proyek</a></li>
<li><a href="../id415273/index.html">Mempelajari dasar-dasar pemrograman</a></li>
<li><a href="../id415275/index.html">Buku "C # 7 dan .NET Core. Pengembangan lintas platform untuk para profesional. Edisi ke-3</a></li>
<li><a href="../id415277/index.html">Apa yang Baru di ARKit 2.0</a></li>
<li><a href="../id415279/index.html">Mengapa memalu paku dengan mikroskop jika Anda memiliki Alpine Linux?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>