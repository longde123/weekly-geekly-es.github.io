<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª‚Äçüç≥ üëêüèæ üêê X86 Assembler-Handbuch f√ºr Anf√§nger üë®‚Äçüè≠ üë® üàµ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heutzutage ist es selten notwendig, in einem reinen Assembler zu schreiben, aber ich empfehle dies definitiv jedem, der sich f√ºr Programmierung intere...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>X86 Assembler-Handbuch f√ºr Anf√§nger</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423077/"> Heutzutage ist es selten notwendig, in einem reinen Assembler zu schreiben, aber ich empfehle dies definitiv jedem, der sich f√ºr Programmierung interessiert.  Sie werden die Dinge aus einem anderen Blickwinkel sehen und F√§higkeiten werden n√ºtzlich sein, wenn Sie Code in anderen Sprachen debuggen. <br><br>  In diesem Artikel werden wir einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RPN-</a> Rechner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(Reverse Polish Notation)</a> in einem reinen x86-Assembler von Grund auf neu schreiben.  Wenn wir fertig sind, k√∂nnen wir es so verwenden: <br><br><pre><code class="bash hljs">$ ./calc <span class="hljs-string"><span class="hljs-string">"32+6*"</span></span> <span class="hljs-comment"><span class="hljs-comment"># "(3+2)*6"    30</span></span></code> </pre> <br>  Der gesamte Code f√ºr den Artikel ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Es ist reichlich auskommentiert und kann als Lehrmaterial f√ºr diejenigen dienen, die Assembler bereits kennen. <br><br>  Beginnen wir mit dem Schreiben des grundlegenden <i>Hello World-Programms!</i>  um die Umgebungseinstellungen zu √ºberpr√ºfen.  Fahren wir dann mit Systemaufrufen, dem Aufrufstapel, den Stapelrahmen und der x86-Aufrufkonvention fort.  Zum √úben werden wir dann einige grundlegende Funktionen in x86 Assembler schreiben - und beginnen, einen RPN-Rechner zu schreiben. <br><a name="habracut"></a><br>  Es wird davon ausgegangen, dass der Leser √ºber Programmiererfahrung in C und Grundkenntnisse der Computerarchitektur verf√ºgt (z. B. ein Prozessorregister).  Da wir Linux verwenden, sollten Sie auch die Linux-Befehlszeile verwenden k√∂nnen. <br><br><h1>  Umgebungseinstellung </h1><br>  Wie bereits erw√§hnt, verwenden wir Linux (64-Bit oder 32-Bit).  Der obige Code funktioniert nicht unter Windows oder Mac OS X. <br><br>  F√ºr die Installation ben√∂tigen Sie nur den GNU <code>ld</code> Linker von <code>binutils</code> , der auf den meisten Distributionen vorinstalliert ist, und den NASM-Assembler.  Unter Ubuntu und Debian k√∂nnen Sie beide mit einem Befehl installieren: <br><br><pre> <code class="bash hljs">$ sudo apt-get install binutils nasm</code> </pre> <br>  Ich w√ºrde auch empfehlen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine ASCII-Tabelle</a> griffbereit zu halten. <br><br><h1>  Hallo Welt! </h1><br>  Speichern Sie den folgenden Code in der Datei <code>calc.asm</code> um die Umgebung zu √ºberpr√ºfen: <br><br><pre> <code class="hljs 1c">;   <span class="hljs-built_in"><span class="hljs-built_in"></span></span> _start     ; . global _start ;   .rodata  <span class="hljs-built_in"><span class="hljs-built_in"></span></span> ( <span class="hljs-keyword"><span class="hljs-keyword"></span></span> ) ;   <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  ,       section .rodata ;     hello_world.   NASM ;   ,   <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  , ;  . <span class="hljs-number"><span class="hljs-number">0</span></span>xA =  <span class="hljs-built_in"><span class="hljs-built_in"></span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>x0 =    hello_world: db <span class="hljs-string"><span class="hljs-string">"Hello world!"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>xA, <span class="hljs-number"><span class="hljs-number">0</span></span>x0 ;   .text,     section .text _start: mov eax, <span class="hljs-number"><span class="hljs-number">0</span></span>x04 ;  <span class="hljs-built_in"><span class="hljs-built_in"></span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>   eax (<span class="hljs-number"><span class="hljs-number">0</span></span>x04 = write()) mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span>x1 ;   (<span class="hljs-number"><span class="hljs-number">1</span></span> =  , <span class="hljs-number"><span class="hljs-number">2</span></span> =  ) mov ecx, hello_world ;     mov edx, <span class="hljs-number"><span class="hljs-number">14</span></span> ;   int <span class="hljs-number"><span class="hljs-number">0</span></span>x80 ;  <span class="hljs-built_in"><span class="hljs-built_in"></span></span>  <span class="hljs-number"><span class="hljs-number">0</span></span>x80,   ;     mov eax, <span class="hljs-number"><span class="hljs-number">0</span></span>x01 ; <span class="hljs-number"><span class="hljs-number">0</span></span>x01 = exit() mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span> =   int <span class="hljs-number"><span class="hljs-number">0</span></span>x80</code> </pre> <br>  Kommentare erl√§utern die allgemeine Struktur.  Eine Liste der Register und allgemeinen Anweisungen finden Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">x86 Assembler-Handbuch</a> der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">University of Virginia</a> .  Bei einer weiteren Diskussion der Systemaufrufe wird dies umso notwendiger. <br><br>  Die folgenden Befehle sammeln die Assembler-Datei in einer Objektdatei und kompilieren dann die ausf√ºhrbare Datei: <br><br><pre> <code class="bash hljs">$ nasm -f elf_i386 calc.asm -o calc $ ld -m elf_i386 calc.o -o calc</code> </pre> <br>  Nach dem Start sollten Sie sehen: <br><br><pre> <code class="bash hljs">$ ./calc Hello world!</code> </pre> <br><h3>  Makefile </h3><br>  Dies ist ein optionaler Teil, aber Sie k√∂nnen ein <code>Makefile</code> erstellen, um die Erstellung und das Layout in Zukunft zu vereinfachen.  Speichern Sie es im selben Verzeichnis wie <code>calc.asm</code> : <br><br><pre> <code class="hljs powershell">CFLAGS= <span class="hljs-operator"><span class="hljs-operator">-f</span></span> elf32 LFLAGS= <span class="hljs-literal"><span class="hljs-literal">-m</span></span> elf_i386 all: calc calc: calc.o ld <span class="hljs-variable"><span class="hljs-variable">$</span></span>(LFLAGS) calc.o <span class="hljs-literal"><span class="hljs-literal">-o</span></span> calc calc.o: calc.asm nasm <span class="hljs-variable"><span class="hljs-variable">$</span></span>(CFLAGS) calc.asm <span class="hljs-literal"><span class="hljs-literal">-o</span></span> calc.o clean: rm <span class="hljs-operator"><span class="hljs-operator">-f</span></span> calc.o calc .INTERMEDIATE: calc.o</code> </pre> <br>  F√ºhren Sie dann anstelle der obigen Anweisungen einfach make aus. <br><br><h1>  Systemaufrufe </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Linux-Systemaufrufe</a> weisen das Betriebssystem an, etwas f√ºr uns zu tun.  In diesem Artikel verwenden wir nur zwei Systemaufrufe: <code>write()</code> , um eine Zeile in eine Datei oder einen Stream zu schreiben (in unserem Fall ist dies ein Standardausgabeger√§t und ein Standardfehler) und <code>exit()</code> , um das Programm zu beenden: <br><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">syscall</span></span> <span class="hljs-number"><span class="hljs-number">0x01</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> error_code) error_code -  <span class="hljs-number"><span class="hljs-number">0</span></span>         (  <span class="hljs-number"><span class="hljs-number">1</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">syscall</span></span> <span class="hljs-number"><span class="hljs-number">0x04</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd, char *string, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">length</span></span>) fd ‚Äî  <span class="hljs-number"><span class="hljs-number">1</span></span>   , <span class="hljs-number"><span class="hljs-number">2</span></span>      string ‚Äî      <span class="hljs-keyword"><span class="hljs-keyword">length</span></span> ‚Äî    </code> </pre> <br>  Systemaufrufe werden konfiguriert, indem die Systemaufrufnummer im <code>eax</code> Register und dann die Argumente in <code>ebx</code> , <code>ecx</code> , <code>edx</code> in dieser Reihenfolge <code>edx</code> werden.  M√∂glicherweise stellen Sie fest, dass <code>exit()</code> nur ein Argument hat - in diesem Fall spielen ecx und edx keine Rolle. <br><br><table><tbody><tr><th>  eax </th><th>  ebx </th><th>  ecx </th><th>  edx </th></tr><tr><td align="center">  Systemrufnummer </td><td align="center">  arg1 </td><td align="center">  arg2 </td><td align="center">  arg3 </td></tr></tbody></table><br><br><h1>  Stapel aufrufen </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/2b0/574/ea2/2b0574ea20054a1e428d6f0518a80388.png"><br><br>  Ein Aufrufstapel ist eine Datenstruktur, in der Informationen zu jedem Aufruf einer Funktion gespeichert werden.  Jeder Aufruf hat einen eigenen Abschnitt im Stapel - den "Frame".  Es speichert einige Informationen √ºber den aktuellen Aufruf: die lokalen Variablen dieser Funktion und die R√ºcksprungadresse (wohin das Programm gehen soll, nachdem die Funktion ausgef√ºhrt wurde). <br><br>  Sofort stelle ich eine nicht offensichtliche Sache fest: Der Stapel vergr√∂√üert <i>den</i> Speicher.  Wenn Sie etwas oben im Stapel hinzuf√ºgen, wird es an einer Speicheradresse eingef√ºgt, die niedriger als die des vorherigen Elements ist.  Mit anderen Worten, wenn der Stapel w√§chst, nimmt die Speicheradresse am oberen Rand des Stapels ab.  Um Verwirrung zu vermeiden, werde ich Sie immer daran erinnern. <br><br>  Die <code>push</code> Anweisung <code>push</code> etwas oben auf dem Stapel ab und die Daten von dort werden eingeblendet.  Wenn Sie beispielsweise <code>push </code> wird ein Platz oben im Stapel zugewiesen und der Wert aus dem <code>eax</code> Register dort platziert. <code>pop </code> √ºbertr√§gt alle Daten vom oberen <code>eax</code> des Stapels an <code>eax</code> und gibt diesen Speicherbereich frei. <br><br>  Der Zweck des <code>esp</code> Registers besteht darin, auf die Oberseite des Stapels zu zeigen.  Alle Daten √ºber <code>esp</code> als nicht auf dem Stapel, dies sind M√ºlldaten.  Das Ausf√ºhren einer <code>push</code> (oder <code>pop</code> ) Anweisung verschiebt sich <code>esp</code> .  Sie k√∂nnen <code>esp</code> direkt manipulieren, wenn Sie Ihren Aktionen einen Bericht geben. <br><br>  Das <code>ebp</code> Register √§hnelt <code>esp</code> , nur zeigt es immer ungef√§hr in die Mitte des aktuellen Stapelrahmens, unmittelbar vor den lokalen Variablen der aktuellen Funktion (wir werden sp√§ter darauf <code>ebp</code> ).  Das Aufrufen einer anderen Funktion verschiebt <code>ebp</code> jedoch nicht automatisch, sondern muss jedes Mal manuell erfolgen. <br><br><h1>  Aufrufkonvention f√ºr X86-Architektur </h1><br>  In x86 gibt es kein integriertes Funktionskonzept wie in Hochsprachen.  Die <code>call</code> <code>goto</code> Grunde nur <code>jmp</code> ( <code>goto</code> ) an eine andere Speicheradresse.  Um Routinen als Funktionen in anderen Sprachen zu verwenden (die Argumente aufnehmen und Daten zur√ºckgeben k√∂nnen), m√ºssen Sie die aufrufende Konvention befolgen (es gibt viele Konventionen, aber wir verwenden CDECL, die beliebteste Konvention f√ºr x86 unter C-Compilern und Assembler-Programmierern).  Es stellt auch sicher, dass Routine-Register beim Aufrufen einer anderen Funktion nicht verwechselt werden. <br><br><h3>  Anruferregeln </h3><br>  Vor dem Aufruf der Funktion muss der Aufrufer: <br><br><ol><li>  Speichern Sie die Register, die der Aufrufer auf dem Stapel speichern muss.  Die aufgerufene Funktion kann einige Register √§ndern: Um keine Daten zu verlieren, muss der Aufrufer diese im Speicher speichern, bis sie auf den Stapel verschoben werden.  Dies sind die <code>edx</code> <code>eax</code> , <code>ecx</code> und <code>edx</code> .  Wenn Sie keine davon verwenden, k√∂nnen Sie sie nicht speichern. </li><li>  Schreiben Sie Funktionsargumente in umgekehrter Reihenfolge in den Stapel (erstes letztes Argument, erstes erstes Argument am Ende).  Diese Reihenfolge stellt sicher, dass die aufgerufene Funktion ihre Argumente vom Stapel in der richtigen Reihenfolge empf√§ngt. </li><li>  Rufen Sie das Unterprogramm auf. </li></ol><br>  Wenn m√∂glich, speichert die Funktion das Ergebnis in <code>eax</code> .  Unmittelbar nach dem <code>call</code> Anrufer: <br><br><ol><li>  Entfernen Sie Funktionsargumente vom Stapel.  Dies geschieht normalerweise durch einfaches Hinzuf√ºgen der Anzahl der Bytes zu <code>esp</code> .  Vergessen Sie nicht, dass der Stapel kleiner wird. Um ihn aus dem Stapel zu entfernen, m√ºssen Sie Bytes hinzuf√ºgen. </li><li>  Stellen Sie gespeicherte Register wieder her, indem Sie sie in umgekehrter Reihenfolge vom Stapel entfernen.  Die aufgerufene Funktion √§ndert keine anderen Register. </li></ol><br>  Das folgende Beispiel zeigt, wie diese Regeln gelten.  Angenommen, die Funktion <code>_subtract</code> verwendet zwei ganzzahlige Argumente (4 Byte) und gibt das erste Argument minus das zweite zur√ºck.  <code>_mysubroutine</code> Unterroutine <code>_subtract</code> mit den Argumenten <code>10</code> und <code>2</code> : <br><br><pre> <code class="hljs perl">_mysubroutine: ; ... ;  -  ; ... <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx ;   (    eax) <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> edx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> ;  ,      <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> call _subtract ; eax   <span class="hljs-number"><span class="hljs-number">10</span></span>-<span class="hljs-number"><span class="hljs-number">2</span></span>=<span class="hljs-number"><span class="hljs-number">8</span></span> add esp, <span class="hljs-number"><span class="hljs-number">8</span></span> ;  <span class="hljs-number"><span class="hljs-number">8</span></span>    (   <span class="hljs-number"><span class="hljs-number">4</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> edx ;    <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ecx ; ... ;  - ,        eax ; ...</code> </pre> <br><h3>  Regeln der aufgerufenen Routine </h3><br>  Vor dem Aufruf muss das Unterprogramm: <br><br><ol><li>  Speichern Sie den <code>ebp</code> Basisregisterzeiger des vorherigen Frames, indem Sie ihn in den Stapel schreiben. </li><li>  <code>ebp</code> vom vorherigen Frame an den aktuellen an (aktueller <code>esp</code> Wert). </li><li>  Weisen Sie mehr Platz auf dem Stapel f√ºr lokale Variablen zu. Bewegen Sie gegebenenfalls den <code>esp</code> Zeiger.  Wenn der Stapel kleiner wird, m√ºssen Sie den fehlenden Speicher von <code>esp</code> subtrahieren. </li><li>  Speichern Sie die Register der aufgerufenen Routine auf dem Stapel.  Dies sind <code>ebx</code> , <code>edi</code> und <code>esi</code> .  Es ist nicht erforderlich, Register zu speichern, deren √Ñnderung nicht geplant ist. </li></ol><br>  Aufrufstapel nach Schritt 1: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d15/55e/4c4/d1555e4c4d0851f1f8ddec2b527e4877.png"><br><br>  Der Aufrufstapel nach Schritt 2: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2ba/e1a/9bc/2bae1a9bc4aff273c6badbd5ec94d2c8.png"><br><br>  Aufrufstapel nach Schritt 4: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8c4/4bf/a7b/8c44bfa7bfb67546110925a9606e27cd.png"><br><br>  In diesen Diagrammen ist in jedem Stapelrahmen eine R√ºcksprungadresse angegeben.  Es wird automatisch von einer Aufrufanweisung auf den Stapel geschoben.  Die <code>ret</code> ruft die Adresse vom oberen Rand des Stapels ab und springt dorthin.  Wir brauchen diese Anweisung nicht, ich habe nur gezeigt, warum die lokalen Variablen der Funktion 4 Bytes √ºber <code>ebp</code> , aber die Argumente der Funktion sind 8 Bytes unter <code>ebp</code> . <br><br>  Im letzten Diagramm k√∂nnen Sie auch feststellen, dass die lokalen Variablen der Funktion immer 4 Bytes √ºber <code>ebp</code> von der <code>ebp-4</code> Adresse beginnen (Subtraktion hier, weil wir den Stapel nach oben verschieben) und die Argumente der Funktion immer 8 Bytes unter <code>ebp</code> von der <code>ebp+8</code> (zus√§tzlich, weil wir uns den Stapel hinunter bewegen).  Wenn Sie die Regeln dieser Konvention befolgen, gilt dies auch f√ºr die Variablen und Argumente einer Funktion. <br><br>  Wenn die Funktion abgeschlossen ist und Sie zur√ºckkehren m√∂chten, m√ºssen Sie bei Bedarf zuerst <code>eax</code> auf den R√ºckgabewert der Funktion setzen.  Dar√ºber hinaus ben√∂tigen Sie: <br><br><ol><li>  Stellen Sie gespeicherte Register wieder her, indem Sie sie in umgekehrter Reihenfolge vom Stapel entfernen. </li><li>  Geben Sie bei Bedarf Speicherplatz auf dem Stapel frei, der von der lokalen Variablen in Schritt 3 zugewiesen wurde: Installieren Sie einfach <code>esp</code> in ebp </li><li>  <code>ebp</code> den <code>ebp</code> des vorherigen Frames wieder her, indem Sie ihn vom Stapel <code>ebp</code> . </li><li>  R√ºckkehr mit <code>ret</code> </li></ol><br>  Jetzt implementieren wir die <code>_subtract</code> Funktion aus unserem Beispiel: <br><br><pre> <code class="hljs perl">_subtract: <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ebp ;      mov ebp, esp ;  ebp ;          ,      ;       ,     ;   ;    mov eax, [ebp+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;      eax.  ;       ebp+<span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eax</span></span></span><span class="hljs-function">, [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ebp</span></span></span><span class="hljs-function">+12] </span></span>;      ebp+<span class="hljs-number"><span class="hljs-number">12</span></span>   ;  ;   , eax     ;     ,     ;       ,       <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ebp ;      ret</code> </pre> <br><h3>  Ein- und Ausstieg </h3><br>  Im obigen Beispiel k√∂nnen Sie feststellen, dass die Funktion immer auf die gleiche Weise ausgef√ºhrt wird: <code>push ebp</code> , <code>mov ebp</code> , <code>esp</code> und Speicherzuordnung f√ºr lokale Variablen.  Der x86-Satz verf√ºgt √ºber eine praktische Anweisung, die all dies erledigt: <code>enter ab</code> , wobei <code>a</code> die Anzahl der Bytes ist, die Sie f√ºr lokale Variablen zuweisen m√∂chten, <code>b</code> die "Verschachtelungsebene" ist, die wir immer auf <code>0</code> .  Au√üerdem endet die Funktion immer mit den Anweisungen <code>pop ebp</code> und <code>mov esp</code> , <code>ebp</code> (obwohl sie nur erforderlich sind, wenn Speicher f√ºr lokale Variablen <code>ebp</code> wird, aber auf keinen Fall Schaden anrichten).  Dies kann auch durch eine einzige Aussage ersetzt werden: <code>leave</code> .  Wir nehmen √Ñnderungen vor: <br><br><pre> <code class="hljs perl">_subtract: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ;        ebp ;       ,     ;   ;    mov eax, [ebp+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;      eax.  ;       ebp+<span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eax</span></span></span><span class="hljs-function">, [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ebp</span></span></span><span class="hljs-function">+12] </span></span>;      ebp+<span class="hljs-number"><span class="hljs-number">12</span></span>  ;   ;   , eax     ;     ,     leave ;      ret</code> </pre> <br><h1>  Einige grundlegende Funktionen schreiben </h1><br>  Nachdem Sie die Aufrufkonvention beherrschen, k√∂nnen Sie mit dem Schreiben einiger Routinen beginnen.  Verallgemeinern Sie den Code, der "Hallo Welt!" <code>_print_msg</code> . So geben Sie Zeilen aus: die Funktion <code>_print_msg</code> . <br><br>  Hier ben√∂tigen wir eine weitere <code>_strlen</code> Funktion, um die L√§nge des Strings zu z√§hlen.  In C k√∂nnte es so aussehen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *s) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> length = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (*s != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//   length++; s++; } //   return length; }</span></span></code> </pre> <br>  Mit anderen Worten, vom Anfang der Zeile an addieren wir 1 zum R√ºckgabewert f√ºr jedes Zeichen au√üer Null.  Sobald das Nullzeichen bemerkt wird, geben wir den in der Schleife akkumulierten Wert zur√ºck.  In Assembler ist dies ebenfalls recht einfach: Sie k√∂nnen die zuvor geschriebene <code>_subtract</code> Funktion als Basis verwenden: <br><br><pre> <code class="hljs 1c">_strlen: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ;        ebp ;       ,    <span class="hljs-keyword"><span class="hljs-keyword"></span></span> ;   ;   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mov</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eax</span></span></span><span class="hljs-function">, 0 ; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length</span></span></span><span class="hljs-function"> = 0 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mov</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ecx</span></span></span><span class="hljs-function">, [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ebp</span></span></span><span class="hljs-function">+8] ; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">   ;  </span></span></span></span>)   ecx (   ; ,      ) _strlen_loop_start: ;  ,   <span class="hljs-keyword"><span class="hljs-keyword"></span></span> cmp byte [ecx], <span class="hljs-number"><span class="hljs-number">0</span></span> ;       . <span class="hljs-keyword"><span class="hljs-keyword"></span></span> ;    <span class="hljs-keyword"><span class="hljs-keyword"></span></span> <span class="hljs-number"><span class="hljs-number">32</span></span>  (<span class="hljs-number"><span class="hljs-number">4</span></span> ). ;    .    ;     ( <span class="hljs-built_in"><span class="hljs-built_in"></span></span>) je _strlen_loop_end ;  <span class="hljs-keyword"><span class="hljs-keyword"></span></span>     inc eax ;    ,  <span class="hljs-number"><span class="hljs-number">1</span></span>    add ecx, <span class="hljs-number"><span class="hljs-number">1</span></span> ;       jmp _strlen_loop_start ;      _strlen_loop_end: ;  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eax</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> ; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function">  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leave</span></span></span><span class="hljs-function"> ; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ret</span></span></span></span></code> </pre> <br>  Schon nicht schlecht, oder?  Das erste Schreiben von C-Code kann hilfreich sein, da das meiste davon direkt in Assembler konvertiert wird.  Jetzt k√∂nnen Sie diese Funktion in <code>_print_msg</code> , wo wir alle gewonnenen Erkenntnisse anwenden: <br><br><pre> <code class="hljs perl">_print_msg: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ;    mov eax, <span class="hljs-number"><span class="hljs-number">0x04</span></span> ; <span class="hljs-number"><span class="hljs-number">0x04</span></span> =   <span class="hljs-keyword"><span class="hljs-keyword">write</span></span>() mov ebx, <span class="hljs-number"><span class="hljs-number">0x1</span></span> ; <span class="hljs-number"><span class="hljs-number">0x1</span></span> =   mov ecx, [ebp+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;       , ;   edx   .    _strlen <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax ;     (    edx) <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> dword [ebp+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;   _strlen  _print_msg.  NASM ; ,    ,  , . ;      dword (<span class="hljs-number"><span class="hljs-number">4</span></span> , <span class="hljs-number"><span class="hljs-number">32</span></span> ) call _strlen ; eax     mov edx, eax ;     edx,     add esp, <span class="hljs-number"><span class="hljs-number">4</span></span> ;  <span class="hljs-number"><span class="hljs-number">4</span></span>    ( <span class="hljs-number"><span class="hljs-number">4</span></span>-  char*) <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ecx ;     <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> eax ;      _strlen,     <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> leave ret</code> </pre> <br>  Und sehen Sie die Fr√ºchte unserer harten Arbeit, indem Sie diese Funktion im vollst√§ndigen Programm ‚ÄûHallo Welt!‚Äú Verwenden. <br><br><pre> <code class="hljs pgsql">_start: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ;     (    ) push hello_world ;    _print_msg <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> _print_msg mov eax, <span class="hljs-number"><span class="hljs-number">0x01</span></span> ; <span class="hljs-number"><span class="hljs-number">0x01</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>() mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span> =   <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span></code> </pre> <br>  Ob Sie es glauben oder nicht, wir haben alle Hauptthemen behandelt, die zum Schreiben grundlegender x86-Assembler-Programme erforderlich sind!  Jetzt haben wir das gesamte Einf√ºhrungsmaterial und die Theorie, sodass wir uns vollst√§ndig auf den Code konzentrieren und das erworbene Wissen anwenden, um unseren RPN-Rechner zu schreiben.  Die Funktionen sind viel l√§nger und verwenden sogar einige lokale Variablen.  Wenn Sie das fertige Programm sofort sehen m√∂chten, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">finden Sie es hier</a> . <br><br>  F√ºr diejenigen unter Ihnen, die mit der umgekehrten polnischen Notation (manchmal auch als umgekehrte polnische Notation oder Postfix-Notation bezeichnet) nicht vertraut sind, werden hier Ausdr√ºcke mithilfe des Stapels ausgewertet.  Daher m√ºssen Sie einen Stapel sowie die <code>_push</code> <code>_pop</code> und <code>_push</code> , um diesen Stapel zu <code>_push</code> .  Sie <code>_print_answer</code> Funktion <code>_print_answer</code> , die am Ende der Berechnung eine Zeichenfolgendarstellung des numerischen Ergebnisses ausgibt. <br><br><h1>  Stapelerstellung </h1><br>  Zun√§chst definieren wir den Speicherplatz f√ºr unseren Stack sowie die globale Variable <code>stack_size</code> .  Es ist ratsam, diese Variablen so zu √§ndern, dass sie nicht in den Abschnitt <code>.rodata</code> , sondern in <code>.data</code> . <br><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">section</span></span> .<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> stack_size: dd 0 ;   dword (4 )   0 stack: times 256 dd 0 ;   </span></span></code> </pre> <br>  Jetzt k√∂nnen Sie die <code>_pop</code> <code>_push</code> und <code>_pop</code> implementieren: <br><br><pre> <code class="hljs powershell">_push: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ;    ,    push eax push edx mov eax, [<span class="hljs-type"><span class="hljs-type">stack_size</span></span>] mov edx, [<span class="hljs-type"><span class="hljs-type">ebp</span></span>+<span class="hljs-number"><span class="hljs-number">8</span></span>] mov [<span class="hljs-type"><span class="hljs-type">stack</span></span> + <span class="hljs-number"><span class="hljs-number">4</span></span>*<span class="hljs-type"><span class="hljs-type">eax</span></span>], edx ;    .   ;       dword inc dword [<span class="hljs-type"><span class="hljs-type">stack_size</span></span>] ;  <span class="hljs-number"><span class="hljs-number">1</span></span>  stack_size ;     pop edx pop eax leave ret _pop: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ;     dec dword [<span class="hljs-type"><span class="hljs-type">stack_size</span></span>] ;   <span class="hljs-number"><span class="hljs-number">1</span></span>  stack_size mov eax, [<span class="hljs-type"><span class="hljs-type">stack_size</span></span>] mov eax, [<span class="hljs-type"><span class="hljs-type">stack</span></span> + <span class="hljs-number"><span class="hljs-number">4</span></span>*<span class="hljs-type"><span class="hljs-type">eax</span></span>] ;       eax ;     ,     leave ret</code> </pre> <br><h1>  Zahlenausgabe </h1><br>  <code>_print_answer</code> viel komplizierter: Sie m√ºssen Zahlen in Zeichenfolgen konvertieren und mehrere andere Funktionen verwenden.  Sie <code>_putc</code> Funktion <code>_putc</code> , die ein Zeichen ausgibt, die Funktion <code>mod</code> , um den Rest der Division (Modul) der beiden Argumente zu <code>_pow_10</code> , und <code>_pow_10</code> , um die Potenz von 10 zu erh√∂hen. Sp√§ter werden Sie verstehen, warum sie ben√∂tigt werden.  Das ist ziemlich einfach, hier ist der Code: <br><br><pre> <code class="hljs powershell">_pow_10: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> mov ecx, [<span class="hljs-type"><span class="hljs-type">ebp</span></span>+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;  ecx (  )  ;  mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> ;   <span class="hljs-number"><span class="hljs-number">10</span></span> (<span class="hljs-number"><span class="hljs-number">10</span></span>**<span class="hljs-number"><span class="hljs-number">0</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>) _pow_10_loop_start: ;  eax  <span class="hljs-number"><span class="hljs-number">10</span></span>,  ecx   <span class="hljs-number"><span class="hljs-number">0</span></span> cmp ecx, <span class="hljs-number"><span class="hljs-number">0</span></span> je _pow_10_loop_end imul eax, <span class="hljs-number"><span class="hljs-number">10</span></span> sub ecx, <span class="hljs-number"><span class="hljs-number">1</span></span> jmp _pow_10_loop_start _pow_10_loop_end: leave ret _mod: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> push ebx mov edx, <span class="hljs-number"><span class="hljs-number">0</span></span> ;   mov eax, [<span class="hljs-type"><span class="hljs-type">ebp</span></span>+<span class="hljs-number"><span class="hljs-number">8</span></span>] mov ebx, [<span class="hljs-type"><span class="hljs-type">ebp</span></span>+<span class="hljs-number"><span class="hljs-number">12</span></span>] idiv ebx ;  <span class="hljs-number"><span class="hljs-number">64</span></span>-  [<span class="hljs-type"><span class="hljs-type">edx</span></span>:<span class="hljs-type"><span class="hljs-type">eax</span></span>]  ebx.    ;  <span class="hljs-number"><span class="hljs-number">32</span></span>-  eax,    edx  ; . ;    eax,   edx.  ,  ;       , ;    . mov eax, edx ;     () pop ebx leave ret _putc: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> mov eax, <span class="hljs-number"><span class="hljs-number">0</span></span>x04 ; write() mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> ;   lea ecx, [<span class="hljs-type"><span class="hljs-type">ebp</span></span>+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;   mov edx, <span class="hljs-number"><span class="hljs-number">1</span></span> ;   <span class="hljs-number"><span class="hljs-number">1</span></span>  int <span class="hljs-number"><span class="hljs-number">0</span></span>x80 leave ret</code> </pre> <br>  Wie leiten wir also einzelne Zahlen in einer Zahl ab?  Beachten Sie zun√§chst, dass die letzte Ziffer der Zahl der Rest der Division durch 10 ist (z. B. <code>123 % 10 = 3</code> ), und die n√§chste Ziffer der Rest der Division durch 100, geteilt durch 10 (z. B. <code>(123 % 100)/10 = 2</code> ).  Im Allgemeinen k√∂nnen Sie eine bestimmte Ziffer einer Zahl (von rechts nach links) finden, indem Sie <code>( % 10**n) / 10**(n-1)</code> suchen, wobei die Anzahl der Einheiten <code>n = 1</code> , die Anzahl der Zehner <code>n = 2</code> und so weiter. <br><br>  Mit diesem Wissen k√∂nnen Sie alle Ziffern einer Zahl von <code>n = 1</code> bis <code>n = 10</code> (dies ist die maximale Anzahl von Bits in einer vorzeichenbehafteten 4-Byte-Ganzzahl).  Es ist jedoch viel einfacher, von links nach rechts zu wechseln. So k√∂nnen wir jedes Zeichen drucken, sobald wir es finden, und die Nullen auf der linken Seite entfernen.  Daher sortieren wir die Zahlen von <code>n = 10</code> bis <code>n = 1</code> . <br><br>  In C sieht das Programm ungef√§hr so ‚Äã‚Äãaus: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAX_DIGITS 10 void print_answer(int a) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (a </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; 0) { //    putc('-'); //   ¬´¬ª a = -a; //     } int started = 0; for (int i = MAX_DIGITS; i &gt; 0; i--) { int digit = (a % pow_10(i)) / pow_10(i-1); if (digit == 0 &amp;&amp; started == 0) continue; //     started = 1; putc(digit + '0'); } }</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt verstehen Sie, warum wir diese drei Funktionen ben√∂tigen. </font><font style="vertical-align: inherit;">Lassen Sie uns dies in Assembler implementieren:</font></font><br><br><pre> <code class="hljs perl">%define MAX_DIGITS <span class="hljs-number"><span class="hljs-number">10</span></span> _print_answer: enter <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ;  <span class="hljs-number"><span class="hljs-number">1</span></span>    <span class="hljs-string"><span class="hljs-string">"started"</span></span>   C <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ebx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> edi <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> esi mov eax, [ebp+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;   <span class="hljs-string"><span class="hljs-string">"a"</span></span> cmp eax, <span class="hljs-number"><span class="hljs-number">0</span></span> ;    ,    ;  jge _print_answer_negate_end ; call putc <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-string"><span class="hljs-string">'-'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> <span class="hljs-number"><span class="hljs-number">0x2d</span></span> ;  <span class="hljs-string"><span class="hljs-string">'-'</span></span> call _putc add esp, <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> eax neg eax ;     _print_answer_negate_end: mov byte [ebp-<span class="hljs-number"><span class="hljs-number">4</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span> ; started = <span class="hljs-number"><span class="hljs-number">0</span></span> mov ecx, MAX_DIGITS ;  i _print_answer_loop_start: cmp ecx, <span class="hljs-number"><span class="hljs-number">0</span></span> je _print_answer_loop_end ;  pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>  ecx.   ebx   <span class="hljs-string"><span class="hljs-string">"digit"</span></span>   C. ;    edx = pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i-<span class="hljs-number"><span class="hljs-number">1</span></span>),  ebx = pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i) <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx dec ecx ; i-<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx ;    _pow_1<span class="hljs-number"><span class="hljs-number">0</span></span> call _pow_1<span class="hljs-number"><span class="hljs-number">0</span></span> mov edx, eax ; edx = pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i-<span class="hljs-number"><span class="hljs-number">1</span></span>) add esp, <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ecx ;   i  ecx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> eax ; end pow_1<span class="hljs-number"><span class="hljs-number">0</span></span> call mov ebx, edx ; digit = ebx = pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i-<span class="hljs-number"><span class="hljs-number">1</span></span>) imul ebx, <span class="hljs-number"><span class="hljs-number">10</span></span> ; digit = ebx = pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i) ;  _mod  (a % pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i)),   (eax mod ebx) <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> edx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ebx ; arg2, ebx = digit = pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i) <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax ; arg1, eax = a call _mod mov ebx, eax ; digit = ebx = a % pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i+<span class="hljs-number"><span class="hljs-number">1</span></span>), almost there add esp, <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> edx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> eax ;   mod ;  ebx ( <span class="hljs-string"><span class="hljs-string">"digit"</span></span> )  pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i) (edx).    ; ,   idiv     edx, eax.  ; edx   ,    - ;   <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> esi mov esi, edx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax mov eax, ebx mov edx, <span class="hljs-number"><span class="hljs-number">0</span></span> idiv esi ; eax   () mov ebx, eax ; ebx = (a % pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i)) / pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i-<span class="hljs-number"><span class="hljs-number">1</span></span>),  <span class="hljs-string"><span class="hljs-string">"digit"</span></span>   C <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> eax <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> esi ; end division cmp ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> ;  digit == <span class="hljs-number"><span class="hljs-number">0</span></span> jne _print_answer_trailing_zeroes_check_end cmp byte [ebp-<span class="hljs-number"><span class="hljs-number">4</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span> ;  started == <span class="hljs-number"><span class="hljs-number">0</span></span> jne _print_answer_trailing_zeroes_check_end jmp _print_answer_loop_continue ; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> _print_answer_trailing_zeroes_check_end: mov byte [ebp-<span class="hljs-number"><span class="hljs-number">4</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span> ; started = <span class="hljs-number"><span class="hljs-number">1</span></span> add ebx, <span class="hljs-number"><span class="hljs-number">0x30</span></span> ; digit + <span class="hljs-string"><span class="hljs-string">'0'</span></span> ;  putc <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> edx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ebx call _putc add esp, <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> edx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> eax ;   putc _print_answer_loop_continue: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ecx</span></span></span><span class="hljs-function">, 1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jmp</span></span></span><span class="hljs-function"> _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_answer_loop_start</span></span></span><span class="hljs-function"> _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_answer_loop_end</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">esi</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">edi</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ebx</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leave</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ret</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es war ein schwieriger Test! </font><font style="vertical-align: inherit;">Hoffe, die Kommentare helfen, es zu kl√§ren. </font><font style="vertical-align: inherit;">Wenn Sie jetzt denken: "Warum k√∂nnen Sie nicht einfach schreiben </font></font><code>printf("%d")</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?", Dann wird Ihnen das Ende des Artikels gefallen, in dem wir die Funktion durch genau das ersetzen werden! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt haben wir alle notwendigen Funktionen, es bleibt die Grundlogik zu implementieren </font></font><code>_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- und das ist alles!</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reverse polnische Notationsberechnung </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie bereits erw√§hnt, wird die umgekehrte polnische Notation mithilfe des Stapels berechnet. </font><font style="vertical-align: inherit;">Beim Lesen wird die Zahl auf den Stapel geschoben, und beim Lesen wird der Operator auf zwei Objekte oben im Stapel angewendet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir beispielsweise berechnen m√∂chten </font></font><code>84/3+6*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(dieser Ausdruck kann auch in der Form geschrieben werden </font></font><code>6384/+*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), ist der Prozess wie folgt:</font></font><br><br><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schritt </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Symbol </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vorher stapeln </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stapel nach </font></font></th></tr><tr><td align="center">  1 </td><td align="center"> <code>8</code> </td> <td align="center"> <code>[]</code> </td> <td align="center"> <code>[8]</code> </td> </tr><tr><td align="center">  2 </td><td align="center"> <code>4</code> </td> <td align="center"> <code>[8]</code> </td> <td align="center"> <code>[8, 4]</code> </td> </tr><tr><td align="center">  3 </td><td align="center"> <code>/</code> </td> <td align="center"> <code>[8, 4]</code> </td> <td align="center"> <code>[2]</code> </td> </tr><tr><td align="center">  4 </td><td align="center"> <code>3</code> </td> <td align="center"> <code>[2]</code> </td> <td align="center"> <code>[2, 3]</code> </td> </tr><tr><td align="center">  5 </td><td align="center"> <code>+</code> </td> <td align="center"> <code>[2, 3]</code> </td> <td align="center"> <code>[5]</code> </td> </tr><tr><td align="center">  6 </td><td align="center"> <code>6</code> </td> <td align="center"> <code>[5]</code> </td> <td align="center"> <code>[5, 6]</code> </td> </tr><tr><td align="center">  7 </td><td align="center"> <code>*</code> </td> <td align="center"> <code>[5, 6]</code> </td> <td align="center"> <code>[30]</code> </td> </tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Eingabe ein g√ºltiger Postfix-Ausdruck ist, befindet sich am Ende der Berechnungen nur noch ein Element auf dem Stapel - dies ist die Antwort, das Ergebnis der Berechnungen. </font><font style="vertical-align: inherit;">In unserem Fall ist die Zahl 30. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Assembler m√ºssen Sie so etwas wie diesen Code in C implementieren:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>[<span class="hljs-number"><span class="hljs-number">256</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// , 256      int stack_size = 0; int main(int argc, char *argv[]) { char *input = argv[0]; size_t input_length = strlen(input); for (int i = 0; i &lt; input_length; i++) { char c = input[i]; if (c &gt;= '0' &amp;&amp; c &lt;= '9') { //   ‚Äî   push(c - '0'); //          } else { int b = pop(); int a = pop(); if (c == '+') { push(a+b); } else if (c == '-') { push(ab); } else if (c == '*') { push(a*b); } else if (c == '/') { push(a/b); } else { error("Invalid input\n"); exit(1); } } } if (stack_size != 1) { error("Invalid input\n"); exit(1); } print_answer(stack[0]); exit(0); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt haben wir alle Funktionen, um dies zu implementieren. Beginnen wir. </font></font><br><br><pre> <code class="hljs perl">_start: ;  _start   ,    . ;   esp    argc ( ),  ; esp+<span class="hljs-number"><span class="hljs-number">4</span></span>   argv. , esp+<span class="hljs-number"><span class="hljs-number">4</span></span>    ; , esp+<span class="hljs-number"><span class="hljs-number">8</span></span> -       mov esi, [esp+<span class="hljs-number"><span class="hljs-number">8</span></span>] ; esi = <span class="hljs-string"><span class="hljs-string">"input"</span></span> = argv[<span class="hljs-number"><span class="hljs-number">0</span></span>] ;  _strlen      <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> esi call _strlen mov ebx, eax ; ebx = input_length add esp, <span class="hljs-number"><span class="hljs-number">4</span></span> ; end _strlen call mov ecx, <span class="hljs-number"><span class="hljs-number">0</span></span> ; ecx = <span class="hljs-string"><span class="hljs-string">"i"</span></span> _main_loop_start: cmp ecx, ebx ;  (i &gt;= input_length) jge _main_loop_end mov edx, <span class="hljs-number"><span class="hljs-number">0</span></span> mov dl, [esi + ecx] ;          ; edx.   edx . ; edx =  c = input[i] cmp edx, <span class="hljs-string"><span class="hljs-string">'0'</span></span> jl _check_operator cmp edx, <span class="hljs-string"><span class="hljs-string">'9'</span></span> jg _print_error <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">edx</span></span></span><span class="hljs-function">, '0' </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mov</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eax</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">edx</span></span></span><span class="hljs-function"> </span></span>; eax =  c - <span class="hljs-string"><span class="hljs-string">'0'</span></span> (,  ) jmp _push_eax_and_continue _check_operator: ;   _pop    b  edi, a  b -  eax <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ebx call _pop mov edi, eax ; edi = b call _pop ; eax = a <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ebx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ecx ; end call _pop cmp edx, <span class="hljs-string"><span class="hljs-string">'+'</span></span> jne _subtract add eax, edi ; eax = a+b jmp _push_eax_and_continue _subtract: cmp edx, <span class="hljs-string"><span class="hljs-string">'-'</span></span> jne _multiply <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eax</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">edi</span></span></span><span class="hljs-function"> </span></span>; eax = ab jmp _push_eax_and_continue _multiply: cmp edx, <span class="hljs-string"><span class="hljs-string">'*'</span></span> jne _divide imul eax, edi ; eax = a*b jmp _push_eax_and_continue _divide: cmp edx, <span class="hljs-string"><span class="hljs-string">'/'</span></span> jne _print_error <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> edx ;  edx,      idiv mov edx, <span class="hljs-number"><span class="hljs-number">0</span></span> idiv edi ; eax = a/b <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> edx ;   eax     _push_eax_and_continue: ;  _push <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> edx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax ;   call _push add esp, <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> edx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> eax ;  call _push inc ecx jmp _main_loop_start _main_loop_end: cmp byte [stack_size], <span class="hljs-number"><span class="hljs-number">1</span></span> ;  (stack_size != <span class="hljs-number"><span class="hljs-number">1</span></span>),   jne _print_error mov eax, [stack] <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax call _print_answer ; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> a final newline <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> <span class="hljs-number"><span class="hljs-number">0xA</span></span> call _putc ; <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span> successfully mov eax, <span class="hljs-number"><span class="hljs-number">0x01</span></span> ; <span class="hljs-number"><span class="hljs-number">0x01</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>() mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span> =   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> ;    _print_error: <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> error_msg call _print_msg mov eax, <span class="hljs-number"><span class="hljs-number">0x01</span></span> mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie m√ºssen </font></font><code>error_msg</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dem Abschnitt </font><font style="vertical-align: inherit;">auch eine Zeile hinzuf√ºgen </font></font><code>.rodata</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="hljs 1c">section .rodata ;     error_msg.  db  NASM ;    ,   <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  ; . <span class="hljs-number"><span class="hljs-number">0</span></span>xA =  <span class="hljs-built_in"><span class="hljs-built_in"></span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>x0 =    error_msg: db <span class="hljs-string"><span class="hljs-string">"Invalid input"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>xA, <span class="hljs-number"><span class="hljs-number">0</span></span>x0</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und wir sind fertig! </font><font style="vertical-align: inherit;">√úberraschen Sie alle Ihre Freunde, wenn Sie sie haben. </font><font style="vertical-align: inherit;">Ich hoffe, dass Sie jetzt besser auf Hochsprachen reagieren, besonders wenn Sie sich daran erinnern, dass viele alte Programme vollst√§ndig oder fast vollst√§ndig in Assembler geschrieben wurden, zum Beispiel der urspr√ºngliche RollerCoaster Tycoon! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der gesamte Code ist </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Danke f√ºrs Lesen! </font><font style="vertical-align: inherit;">Ich kann fortfahren, wenn Sie interessiert sind.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Weitere Aktionen </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie k√∂nnen √ºben, indem Sie mehrere zus√§tzliche Funktionen implementieren: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Geben Sie eine Fehlermeldung anstelle von segfault zur√ºck, wenn das Programm kein Argument erh√§lt. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unterst√ºtzung f√ºr zus√§tzliche Leerzeichen zwischen Operanden und Operatoren in der Eingabe hinzuf√ºgen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unterst√ºtzung f√ºr Multi-Bit-Operanden hinzuf√ºgen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Negative Zahlen zulassen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durch </font></font><code>_strlen</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine Funktion aus der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standard-C-Bibliothek</font></font></a><font style="vertical-align: inherit;"></font><code>_print_answer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ersetzen </font><font style="vertical-align: inherit;">und </font><font style="vertical-align: inherit;">durch einen Aufruf ersetzen </font></font><code>printf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li></ol><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zus√§tzliche Materialien </font></font></h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das x86-Assembler-Handbuch der Virginia University enth√§lt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eine detailliertere Darstellung vieler der von uns behandelten Themen, einschlie√ülich zus√§tzlicher Informationen zu allen g√§ngigen x86-Anweisungen.</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">¬´   Intel¬ª</a> .    x86 ‚Äî   ,      .        ,    ,      . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NASM: Intel x86 Instruction Reference</a> ‚Äî       x86. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de423077/">https://habr.com/ru/post/de423077/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de423067/index.html">Python Developer Tools von Microsoft. Erste Schritte</a></li>
<li><a href="../de423069/index.html">Apple Special Event, September 2018 [Text√ºbersetzungsarchiv]</a></li>
<li><a href="../de423071/index.html">Ich habe keine Angst vor deiner NDA</a></li>
<li><a href="../de423073/index.html">Interplanetares Dateisystem - trivialer Hash (Identit√§t), DAG-Block und Protokollpuffer</a></li>
<li><a href="../de423075/index.html">Warum sind CFOs so bem√ºht, IT-Investitionen in Betrieb umzusetzen?</a></li>
<li><a href="../de423079/index.html">Wichtige Punkte aus einem Interview mit Elon Musk bei Joe Rogan</a></li>
<li><a href="../de423083/index.html">Wie ich Entwickler bei ABBYY wurde</a></li>
<li><a href="../de423085/index.html">Feineinstellung des Lastausgleichs</a></li>
<li><a href="../de423087/index.html">Dr√ºck mir nicht ins Auge</a></li>
<li><a href="../de423089/index.html">Programmierer bei MBLT DEV 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>