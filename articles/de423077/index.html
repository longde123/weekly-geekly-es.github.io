<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🍳 👐🏾 🐐 X86 Assembler-Handbuch für Anfänger 👨‍🏭 👨 🈵</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heutzutage ist es selten notwendig, in einem reinen Assembler zu schreiben, aber ich empfehle dies definitiv jedem, der sich für Programmierung intere...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>X86 Assembler-Handbuch für Anfänger</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423077/"> Heutzutage ist es selten notwendig, in einem reinen Assembler zu schreiben, aber ich empfehle dies definitiv jedem, der sich für Programmierung interessiert.  Sie werden die Dinge aus einem anderen Blickwinkel sehen und Fähigkeiten werden nützlich sein, wenn Sie Code in anderen Sprachen debuggen. <br><br>  In diesem Artikel werden wir einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RPN-</a> Rechner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(Reverse Polish Notation)</a> in einem reinen x86-Assembler von Grund auf neu schreiben.  Wenn wir fertig sind, können wir es so verwenden: <br><br><pre><code class="bash hljs">$ ./calc <span class="hljs-string"><span class="hljs-string">"32+6*"</span></span> <span class="hljs-comment"><span class="hljs-comment"># "(3+2)*6"    30</span></span></code> </pre> <br>  Der gesamte Code für den Artikel ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Es ist reichlich auskommentiert und kann als Lehrmaterial für diejenigen dienen, die Assembler bereits kennen. <br><br>  Beginnen wir mit dem Schreiben des grundlegenden <i>Hello World-Programms!</i>  um die Umgebungseinstellungen zu überprüfen.  Fahren wir dann mit Systemaufrufen, dem Aufrufstapel, den Stapelrahmen und der x86-Aufrufkonvention fort.  Zum Üben werden wir dann einige grundlegende Funktionen in x86 Assembler schreiben - und beginnen, einen RPN-Rechner zu schreiben. <br><a name="habracut"></a><br>  Es wird davon ausgegangen, dass der Leser über Programmiererfahrung in C und Grundkenntnisse der Computerarchitektur verfügt (z. B. ein Prozessorregister).  Da wir Linux verwenden, sollten Sie auch die Linux-Befehlszeile verwenden können. <br><br><h1>  Umgebungseinstellung </h1><br>  Wie bereits erwähnt, verwenden wir Linux (64-Bit oder 32-Bit).  Der obige Code funktioniert nicht unter Windows oder Mac OS X. <br><br>  Für die Installation benötigen Sie nur den GNU <code>ld</code> Linker von <code>binutils</code> , der auf den meisten Distributionen vorinstalliert ist, und den NASM-Assembler.  Unter Ubuntu und Debian können Sie beide mit einem Befehl installieren: <br><br><pre> <code class="bash hljs">$ sudo apt-get install binutils nasm</code> </pre> <br>  Ich würde auch empfehlen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine ASCII-Tabelle</a> griffbereit zu halten. <br><br><h1>  Hallo Welt! </h1><br>  Speichern Sie den folgenden Code in der Datei <code>calc.asm</code> um die Umgebung zu überprüfen: <br><br><pre> <code class="hljs 1c">;   <span class="hljs-built_in"><span class="hljs-built_in"></span></span> _start     ; . global _start ;   .rodata  <span class="hljs-built_in"><span class="hljs-built_in"></span></span> ( <span class="hljs-keyword"><span class="hljs-keyword"></span></span> ) ;   <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  ,       section .rodata ;     hello_world.   NASM ;   ,   <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  , ;  . <span class="hljs-number"><span class="hljs-number">0</span></span>xA =  <span class="hljs-built_in"><span class="hljs-built_in"></span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>x0 =    hello_world: db <span class="hljs-string"><span class="hljs-string">"Hello world!"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>xA, <span class="hljs-number"><span class="hljs-number">0</span></span>x0 ;   .text,     section .text _start: mov eax, <span class="hljs-number"><span class="hljs-number">0</span></span>x04 ;  <span class="hljs-built_in"><span class="hljs-built_in"></span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>   eax (<span class="hljs-number"><span class="hljs-number">0</span></span>x04 = write()) mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span>x1 ;   (<span class="hljs-number"><span class="hljs-number">1</span></span> =  , <span class="hljs-number"><span class="hljs-number">2</span></span> =  ) mov ecx, hello_world ;     mov edx, <span class="hljs-number"><span class="hljs-number">14</span></span> ;   int <span class="hljs-number"><span class="hljs-number">0</span></span>x80 ;  <span class="hljs-built_in"><span class="hljs-built_in"></span></span>  <span class="hljs-number"><span class="hljs-number">0</span></span>x80,   ;     mov eax, <span class="hljs-number"><span class="hljs-number">0</span></span>x01 ; <span class="hljs-number"><span class="hljs-number">0</span></span>x01 = exit() mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span> =   int <span class="hljs-number"><span class="hljs-number">0</span></span>x80</code> </pre> <br>  Kommentare erläutern die allgemeine Struktur.  Eine Liste der Register und allgemeinen Anweisungen finden Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">x86 Assembler-Handbuch</a> der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">University of Virginia</a> .  Bei einer weiteren Diskussion der Systemaufrufe wird dies umso notwendiger. <br><br>  Die folgenden Befehle sammeln die Assembler-Datei in einer Objektdatei und kompilieren dann die ausführbare Datei: <br><br><pre> <code class="bash hljs">$ nasm -f elf_i386 calc.asm -o calc $ ld -m elf_i386 calc.o -o calc</code> </pre> <br>  Nach dem Start sollten Sie sehen: <br><br><pre> <code class="bash hljs">$ ./calc Hello world!</code> </pre> <br><h3>  Makefile </h3><br>  Dies ist ein optionaler Teil, aber Sie können ein <code>Makefile</code> erstellen, um die Erstellung und das Layout in Zukunft zu vereinfachen.  Speichern Sie es im selben Verzeichnis wie <code>calc.asm</code> : <br><br><pre> <code class="hljs powershell">CFLAGS= <span class="hljs-operator"><span class="hljs-operator">-f</span></span> elf32 LFLAGS= <span class="hljs-literal"><span class="hljs-literal">-m</span></span> elf_i386 all: calc calc: calc.o ld <span class="hljs-variable"><span class="hljs-variable">$</span></span>(LFLAGS) calc.o <span class="hljs-literal"><span class="hljs-literal">-o</span></span> calc calc.o: calc.asm nasm <span class="hljs-variable"><span class="hljs-variable">$</span></span>(CFLAGS) calc.asm <span class="hljs-literal"><span class="hljs-literal">-o</span></span> calc.o clean: rm <span class="hljs-operator"><span class="hljs-operator">-f</span></span> calc.o calc .INTERMEDIATE: calc.o</code> </pre> <br>  Führen Sie dann anstelle der obigen Anweisungen einfach make aus. <br><br><h1>  Systemaufrufe </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Linux-Systemaufrufe</a> weisen das Betriebssystem an, etwas für uns zu tun.  In diesem Artikel verwenden wir nur zwei Systemaufrufe: <code>write()</code> , um eine Zeile in eine Datei oder einen Stream zu schreiben (in unserem Fall ist dies ein Standardausgabegerät und ein Standardfehler) und <code>exit()</code> , um das Programm zu beenden: <br><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">syscall</span></span> <span class="hljs-number"><span class="hljs-number">0x01</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> error_code) error_code -  <span class="hljs-number"><span class="hljs-number">0</span></span>         (  <span class="hljs-number"><span class="hljs-number">1</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">syscall</span></span> <span class="hljs-number"><span class="hljs-number">0x04</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd, char *string, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">length</span></span>) fd —  <span class="hljs-number"><span class="hljs-number">1</span></span>   , <span class="hljs-number"><span class="hljs-number">2</span></span>      string —      <span class="hljs-keyword"><span class="hljs-keyword">length</span></span> —    </code> </pre> <br>  Systemaufrufe werden konfiguriert, indem die Systemaufrufnummer im <code>eax</code> Register und dann die Argumente in <code>ebx</code> , <code>ecx</code> , <code>edx</code> in dieser Reihenfolge <code>edx</code> werden.  Möglicherweise stellen Sie fest, dass <code>exit()</code> nur ein Argument hat - in diesem Fall spielen ecx und edx keine Rolle. <br><br><table><tbody><tr><th>  eax </th><th>  ebx </th><th>  ecx </th><th>  edx </th></tr><tr><td align="center">  Systemrufnummer </td><td align="center">  arg1 </td><td align="center">  arg2 </td><td align="center">  arg3 </td></tr></tbody></table><br><br><h1>  Stapel aufrufen </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/2b0/574/ea2/2b0574ea20054a1e428d6f0518a80388.png"><br><br>  Ein Aufrufstapel ist eine Datenstruktur, in der Informationen zu jedem Aufruf einer Funktion gespeichert werden.  Jeder Aufruf hat einen eigenen Abschnitt im Stapel - den "Frame".  Es speichert einige Informationen über den aktuellen Aufruf: die lokalen Variablen dieser Funktion und die Rücksprungadresse (wohin das Programm gehen soll, nachdem die Funktion ausgeführt wurde). <br><br>  Sofort stelle ich eine nicht offensichtliche Sache fest: Der Stapel vergrößert <i>den</i> Speicher.  Wenn Sie etwas oben im Stapel hinzufügen, wird es an einer Speicheradresse eingefügt, die niedriger als die des vorherigen Elements ist.  Mit anderen Worten, wenn der Stapel wächst, nimmt die Speicheradresse am oberen Rand des Stapels ab.  Um Verwirrung zu vermeiden, werde ich Sie immer daran erinnern. <br><br>  Die <code>push</code> Anweisung <code>push</code> etwas oben auf dem Stapel ab und die Daten von dort werden eingeblendet.  Wenn Sie beispielsweise <code>push </code> wird ein Platz oben im Stapel zugewiesen und der Wert aus dem <code>eax</code> Register dort platziert. <code>pop </code> überträgt alle Daten vom oberen <code>eax</code> des Stapels an <code>eax</code> und gibt diesen Speicherbereich frei. <br><br>  Der Zweck des <code>esp</code> Registers besteht darin, auf die Oberseite des Stapels zu zeigen.  Alle Daten über <code>esp</code> als nicht auf dem Stapel, dies sind Mülldaten.  Das Ausführen einer <code>push</code> (oder <code>pop</code> ) Anweisung verschiebt sich <code>esp</code> .  Sie können <code>esp</code> direkt manipulieren, wenn Sie Ihren Aktionen einen Bericht geben. <br><br>  Das <code>ebp</code> Register ähnelt <code>esp</code> , nur zeigt es immer ungefähr in die Mitte des aktuellen Stapelrahmens, unmittelbar vor den lokalen Variablen der aktuellen Funktion (wir werden später darauf <code>ebp</code> ).  Das Aufrufen einer anderen Funktion verschiebt <code>ebp</code> jedoch nicht automatisch, sondern muss jedes Mal manuell erfolgen. <br><br><h1>  Aufrufkonvention für X86-Architektur </h1><br>  In x86 gibt es kein integriertes Funktionskonzept wie in Hochsprachen.  Die <code>call</code> <code>goto</code> Grunde nur <code>jmp</code> ( <code>goto</code> ) an eine andere Speicheradresse.  Um Routinen als Funktionen in anderen Sprachen zu verwenden (die Argumente aufnehmen und Daten zurückgeben können), müssen Sie die aufrufende Konvention befolgen (es gibt viele Konventionen, aber wir verwenden CDECL, die beliebteste Konvention für x86 unter C-Compilern und Assembler-Programmierern).  Es stellt auch sicher, dass Routine-Register beim Aufrufen einer anderen Funktion nicht verwechselt werden. <br><br><h3>  Anruferregeln </h3><br>  Vor dem Aufruf der Funktion muss der Aufrufer: <br><br><ol><li>  Speichern Sie die Register, die der Aufrufer auf dem Stapel speichern muss.  Die aufgerufene Funktion kann einige Register ändern: Um keine Daten zu verlieren, muss der Aufrufer diese im Speicher speichern, bis sie auf den Stapel verschoben werden.  Dies sind die <code>edx</code> <code>eax</code> , <code>ecx</code> und <code>edx</code> .  Wenn Sie keine davon verwenden, können Sie sie nicht speichern. </li><li>  Schreiben Sie Funktionsargumente in umgekehrter Reihenfolge in den Stapel (erstes letztes Argument, erstes erstes Argument am Ende).  Diese Reihenfolge stellt sicher, dass die aufgerufene Funktion ihre Argumente vom Stapel in der richtigen Reihenfolge empfängt. </li><li>  Rufen Sie das Unterprogramm auf. </li></ol><br>  Wenn möglich, speichert die Funktion das Ergebnis in <code>eax</code> .  Unmittelbar nach dem <code>call</code> Anrufer: <br><br><ol><li>  Entfernen Sie Funktionsargumente vom Stapel.  Dies geschieht normalerweise durch einfaches Hinzufügen der Anzahl der Bytes zu <code>esp</code> .  Vergessen Sie nicht, dass der Stapel kleiner wird. Um ihn aus dem Stapel zu entfernen, müssen Sie Bytes hinzufügen. </li><li>  Stellen Sie gespeicherte Register wieder her, indem Sie sie in umgekehrter Reihenfolge vom Stapel entfernen.  Die aufgerufene Funktion ändert keine anderen Register. </li></ol><br>  Das folgende Beispiel zeigt, wie diese Regeln gelten.  Angenommen, die Funktion <code>_subtract</code> verwendet zwei ganzzahlige Argumente (4 Byte) und gibt das erste Argument minus das zweite zurück.  <code>_mysubroutine</code> Unterroutine <code>_subtract</code> mit den Argumenten <code>10</code> und <code>2</code> : <br><br><pre> <code class="hljs perl">_mysubroutine: ; ... ;  -  ; ... <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx ;   (    eax) <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> edx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> ;  ,      <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> call _subtract ; eax   <span class="hljs-number"><span class="hljs-number">10</span></span>-<span class="hljs-number"><span class="hljs-number">2</span></span>=<span class="hljs-number"><span class="hljs-number">8</span></span> add esp, <span class="hljs-number"><span class="hljs-number">8</span></span> ;  <span class="hljs-number"><span class="hljs-number">8</span></span>    (   <span class="hljs-number"><span class="hljs-number">4</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> edx ;    <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ecx ; ... ;  - ,        eax ; ...</code> </pre> <br><h3>  Regeln der aufgerufenen Routine </h3><br>  Vor dem Aufruf muss das Unterprogramm: <br><br><ol><li>  Speichern Sie den <code>ebp</code> Basisregisterzeiger des vorherigen Frames, indem Sie ihn in den Stapel schreiben. </li><li>  <code>ebp</code> vom vorherigen Frame an den aktuellen an (aktueller <code>esp</code> Wert). </li><li>  Weisen Sie mehr Platz auf dem Stapel für lokale Variablen zu. Bewegen Sie gegebenenfalls den <code>esp</code> Zeiger.  Wenn der Stapel kleiner wird, müssen Sie den fehlenden Speicher von <code>esp</code> subtrahieren. </li><li>  Speichern Sie die Register der aufgerufenen Routine auf dem Stapel.  Dies sind <code>ebx</code> , <code>edi</code> und <code>esi</code> .  Es ist nicht erforderlich, Register zu speichern, deren Änderung nicht geplant ist. </li></ol><br>  Aufrufstapel nach Schritt 1: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d15/55e/4c4/d1555e4c4d0851f1f8ddec2b527e4877.png"><br><br>  Der Aufrufstapel nach Schritt 2: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2ba/e1a/9bc/2bae1a9bc4aff273c6badbd5ec94d2c8.png"><br><br>  Aufrufstapel nach Schritt 4: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8c4/4bf/a7b/8c44bfa7bfb67546110925a9606e27cd.png"><br><br>  In diesen Diagrammen ist in jedem Stapelrahmen eine Rücksprungadresse angegeben.  Es wird automatisch von einer Aufrufanweisung auf den Stapel geschoben.  Die <code>ret</code> ruft die Adresse vom oberen Rand des Stapels ab und springt dorthin.  Wir brauchen diese Anweisung nicht, ich habe nur gezeigt, warum die lokalen Variablen der Funktion 4 Bytes über <code>ebp</code> , aber die Argumente der Funktion sind 8 Bytes unter <code>ebp</code> . <br><br>  Im letzten Diagramm können Sie auch feststellen, dass die lokalen Variablen der Funktion immer 4 Bytes über <code>ebp</code> von der <code>ebp-4</code> Adresse beginnen (Subtraktion hier, weil wir den Stapel nach oben verschieben) und die Argumente der Funktion immer 8 Bytes unter <code>ebp</code> von der <code>ebp+8</code> (zusätzlich, weil wir uns den Stapel hinunter bewegen).  Wenn Sie die Regeln dieser Konvention befolgen, gilt dies auch für die Variablen und Argumente einer Funktion. <br><br>  Wenn die Funktion abgeschlossen ist und Sie zurückkehren möchten, müssen Sie bei Bedarf zuerst <code>eax</code> auf den Rückgabewert der Funktion setzen.  Darüber hinaus benötigen Sie: <br><br><ol><li>  Stellen Sie gespeicherte Register wieder her, indem Sie sie in umgekehrter Reihenfolge vom Stapel entfernen. </li><li>  Geben Sie bei Bedarf Speicherplatz auf dem Stapel frei, der von der lokalen Variablen in Schritt 3 zugewiesen wurde: Installieren Sie einfach <code>esp</code> in ebp </li><li>  <code>ebp</code> den <code>ebp</code> des vorherigen Frames wieder her, indem Sie ihn vom Stapel <code>ebp</code> . </li><li>  Rückkehr mit <code>ret</code> </li></ol><br>  Jetzt implementieren wir die <code>_subtract</code> Funktion aus unserem Beispiel: <br><br><pre> <code class="hljs perl">_subtract: <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ebp ;      mov ebp, esp ;  ebp ;          ,      ;       ,     ;   ;    mov eax, [ebp+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;      eax.  ;       ebp+<span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eax</span></span></span><span class="hljs-function">, [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ebp</span></span></span><span class="hljs-function">+12] </span></span>;      ebp+<span class="hljs-number"><span class="hljs-number">12</span></span>   ;  ;   , eax     ;     ,     ;       ,       <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ebp ;      ret</code> </pre> <br><h3>  Ein- und Ausstieg </h3><br>  Im obigen Beispiel können Sie feststellen, dass die Funktion immer auf die gleiche Weise ausgeführt wird: <code>push ebp</code> , <code>mov ebp</code> , <code>esp</code> und Speicherzuordnung für lokale Variablen.  Der x86-Satz verfügt über eine praktische Anweisung, die all dies erledigt: <code>enter ab</code> , wobei <code>a</code> die Anzahl der Bytes ist, die Sie für lokale Variablen zuweisen möchten, <code>b</code> die "Verschachtelungsebene" ist, die wir immer auf <code>0</code> .  Außerdem endet die Funktion immer mit den Anweisungen <code>pop ebp</code> und <code>mov esp</code> , <code>ebp</code> (obwohl sie nur erforderlich sind, wenn Speicher für lokale Variablen <code>ebp</code> wird, aber auf keinen Fall Schaden anrichten).  Dies kann auch durch eine einzige Aussage ersetzt werden: <code>leave</code> .  Wir nehmen Änderungen vor: <br><br><pre> <code class="hljs perl">_subtract: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ;        ebp ;       ,     ;   ;    mov eax, [ebp+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;      eax.  ;       ebp+<span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eax</span></span></span><span class="hljs-function">, [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ebp</span></span></span><span class="hljs-function">+12] </span></span>;      ebp+<span class="hljs-number"><span class="hljs-number">12</span></span>  ;   ;   , eax     ;     ,     leave ;      ret</code> </pre> <br><h1>  Einige grundlegende Funktionen schreiben </h1><br>  Nachdem Sie die Aufrufkonvention beherrschen, können Sie mit dem Schreiben einiger Routinen beginnen.  Verallgemeinern Sie den Code, der "Hallo Welt!" <code>_print_msg</code> . So geben Sie Zeilen aus: die Funktion <code>_print_msg</code> . <br><br>  Hier benötigen wir eine weitere <code>_strlen</code> Funktion, um die Länge des Strings zu zählen.  In C könnte es so aussehen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *s) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> length = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (*s != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//   length++; s++; } //   return length; }</span></span></code> </pre> <br>  Mit anderen Worten, vom Anfang der Zeile an addieren wir 1 zum Rückgabewert für jedes Zeichen außer Null.  Sobald das Nullzeichen bemerkt wird, geben wir den in der Schleife akkumulierten Wert zurück.  In Assembler ist dies ebenfalls recht einfach: Sie können die zuvor geschriebene <code>_subtract</code> Funktion als Basis verwenden: <br><br><pre> <code class="hljs 1c">_strlen: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ;        ebp ;       ,    <span class="hljs-keyword"><span class="hljs-keyword"></span></span> ;   ;   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mov</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eax</span></span></span><span class="hljs-function">, 0 ; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length</span></span></span><span class="hljs-function"> = 0 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mov</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ecx</span></span></span><span class="hljs-function">, [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ebp</span></span></span><span class="hljs-function">+8] ; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">   ;  </span></span></span></span>)   ecx (   ; ,      ) _strlen_loop_start: ;  ,   <span class="hljs-keyword"><span class="hljs-keyword"></span></span> cmp byte [ecx], <span class="hljs-number"><span class="hljs-number">0</span></span> ;       . <span class="hljs-keyword"><span class="hljs-keyword"></span></span> ;    <span class="hljs-keyword"><span class="hljs-keyword"></span></span> <span class="hljs-number"><span class="hljs-number">32</span></span>  (<span class="hljs-number"><span class="hljs-number">4</span></span> ). ;    .    ;     ( <span class="hljs-built_in"><span class="hljs-built_in"></span></span>) je _strlen_loop_end ;  <span class="hljs-keyword"><span class="hljs-keyword"></span></span>     inc eax ;    ,  <span class="hljs-number"><span class="hljs-number">1</span></span>    add ecx, <span class="hljs-number"><span class="hljs-number">1</span></span> ;       jmp _strlen_loop_start ;      _strlen_loop_end: ;  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eax</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> ; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function">  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leave</span></span></span><span class="hljs-function"> ; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ret</span></span></span></span></code> </pre> <br>  Schon nicht schlecht, oder?  Das erste Schreiben von C-Code kann hilfreich sein, da das meiste davon direkt in Assembler konvertiert wird.  Jetzt können Sie diese Funktion in <code>_print_msg</code> , wo wir alle gewonnenen Erkenntnisse anwenden: <br><br><pre> <code class="hljs perl">_print_msg: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ;    mov eax, <span class="hljs-number"><span class="hljs-number">0x04</span></span> ; <span class="hljs-number"><span class="hljs-number">0x04</span></span> =   <span class="hljs-keyword"><span class="hljs-keyword">write</span></span>() mov ebx, <span class="hljs-number"><span class="hljs-number">0x1</span></span> ; <span class="hljs-number"><span class="hljs-number">0x1</span></span> =   mov ecx, [ebp+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;       , ;   edx   .    _strlen <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax ;     (    edx) <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> dword [ebp+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;   _strlen  _print_msg.  NASM ; ,    ,  , . ;      dword (<span class="hljs-number"><span class="hljs-number">4</span></span> , <span class="hljs-number"><span class="hljs-number">32</span></span> ) call _strlen ; eax     mov edx, eax ;     edx,     add esp, <span class="hljs-number"><span class="hljs-number">4</span></span> ;  <span class="hljs-number"><span class="hljs-number">4</span></span>    ( <span class="hljs-number"><span class="hljs-number">4</span></span>-  char*) <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ecx ;     <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> eax ;      _strlen,     <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> leave ret</code> </pre> <br>  Und sehen Sie die Früchte unserer harten Arbeit, indem Sie diese Funktion im vollständigen Programm „Hallo Welt!“ Verwenden. <br><br><pre> <code class="hljs pgsql">_start: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ;     (    ) push hello_world ;    _print_msg <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> _print_msg mov eax, <span class="hljs-number"><span class="hljs-number">0x01</span></span> ; <span class="hljs-number"><span class="hljs-number">0x01</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>() mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span> =   <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span></code> </pre> <br>  Ob Sie es glauben oder nicht, wir haben alle Hauptthemen behandelt, die zum Schreiben grundlegender x86-Assembler-Programme erforderlich sind!  Jetzt haben wir das gesamte Einführungsmaterial und die Theorie, sodass wir uns vollständig auf den Code konzentrieren und das erworbene Wissen anwenden, um unseren RPN-Rechner zu schreiben.  Die Funktionen sind viel länger und verwenden sogar einige lokale Variablen.  Wenn Sie das fertige Programm sofort sehen möchten, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">finden Sie es hier</a> . <br><br>  Für diejenigen unter Ihnen, die mit der umgekehrten polnischen Notation (manchmal auch als umgekehrte polnische Notation oder Postfix-Notation bezeichnet) nicht vertraut sind, werden hier Ausdrücke mithilfe des Stapels ausgewertet.  Daher müssen Sie einen Stapel sowie die <code>_push</code> <code>_pop</code> und <code>_push</code> , um diesen Stapel zu <code>_push</code> .  Sie <code>_print_answer</code> Funktion <code>_print_answer</code> , die am Ende der Berechnung eine Zeichenfolgendarstellung des numerischen Ergebnisses ausgibt. <br><br><h1>  Stapelerstellung </h1><br>  Zunächst definieren wir den Speicherplatz für unseren Stack sowie die globale Variable <code>stack_size</code> .  Es ist ratsam, diese Variablen so zu ändern, dass sie nicht in den Abschnitt <code>.rodata</code> , sondern in <code>.data</code> . <br><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">section</span></span> .<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> stack_size: dd 0 ;   dword (4 )   0 stack: times 256 dd 0 ;   </span></span></code> </pre> <br>  Jetzt können Sie die <code>_pop</code> <code>_push</code> und <code>_pop</code> implementieren: <br><br><pre> <code class="hljs powershell">_push: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ;    ,    push eax push edx mov eax, [<span class="hljs-type"><span class="hljs-type">stack_size</span></span>] mov edx, [<span class="hljs-type"><span class="hljs-type">ebp</span></span>+<span class="hljs-number"><span class="hljs-number">8</span></span>] mov [<span class="hljs-type"><span class="hljs-type">stack</span></span> + <span class="hljs-number"><span class="hljs-number">4</span></span>*<span class="hljs-type"><span class="hljs-type">eax</span></span>], edx ;    .   ;       dword inc dword [<span class="hljs-type"><span class="hljs-type">stack_size</span></span>] ;  <span class="hljs-number"><span class="hljs-number">1</span></span>  stack_size ;     pop edx pop eax leave ret _pop: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ;     dec dword [<span class="hljs-type"><span class="hljs-type">stack_size</span></span>] ;   <span class="hljs-number"><span class="hljs-number">1</span></span>  stack_size mov eax, [<span class="hljs-type"><span class="hljs-type">stack_size</span></span>] mov eax, [<span class="hljs-type"><span class="hljs-type">stack</span></span> + <span class="hljs-number"><span class="hljs-number">4</span></span>*<span class="hljs-type"><span class="hljs-type">eax</span></span>] ;       eax ;     ,     leave ret</code> </pre> <br><h1>  Zahlenausgabe </h1><br>  <code>_print_answer</code> viel komplizierter: Sie müssen Zahlen in Zeichenfolgen konvertieren und mehrere andere Funktionen verwenden.  Sie <code>_putc</code> Funktion <code>_putc</code> , die ein Zeichen ausgibt, die Funktion <code>mod</code> , um den Rest der Division (Modul) der beiden Argumente zu <code>_pow_10</code> , und <code>_pow_10</code> , um die Potenz von 10 zu erhöhen. Später werden Sie verstehen, warum sie benötigt werden.  Das ist ziemlich einfach, hier ist der Code: <br><br><pre> <code class="hljs powershell">_pow_10: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> mov ecx, [<span class="hljs-type"><span class="hljs-type">ebp</span></span>+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;  ecx (  )  ;  mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> ;   <span class="hljs-number"><span class="hljs-number">10</span></span> (<span class="hljs-number"><span class="hljs-number">10</span></span>**<span class="hljs-number"><span class="hljs-number">0</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>) _pow_10_loop_start: ;  eax  <span class="hljs-number"><span class="hljs-number">10</span></span>,  ecx   <span class="hljs-number"><span class="hljs-number">0</span></span> cmp ecx, <span class="hljs-number"><span class="hljs-number">0</span></span> je _pow_10_loop_end imul eax, <span class="hljs-number"><span class="hljs-number">10</span></span> sub ecx, <span class="hljs-number"><span class="hljs-number">1</span></span> jmp _pow_10_loop_start _pow_10_loop_end: leave ret _mod: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> push ebx mov edx, <span class="hljs-number"><span class="hljs-number">0</span></span> ;   mov eax, [<span class="hljs-type"><span class="hljs-type">ebp</span></span>+<span class="hljs-number"><span class="hljs-number">8</span></span>] mov ebx, [<span class="hljs-type"><span class="hljs-type">ebp</span></span>+<span class="hljs-number"><span class="hljs-number">12</span></span>] idiv ebx ;  <span class="hljs-number"><span class="hljs-number">64</span></span>-  [<span class="hljs-type"><span class="hljs-type">edx</span></span>:<span class="hljs-type"><span class="hljs-type">eax</span></span>]  ebx.    ;  <span class="hljs-number"><span class="hljs-number">32</span></span>-  eax,    edx  ; . ;    eax,   edx.  ,  ;       , ;    . mov eax, edx ;     () pop ebx leave ret _putc: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> mov eax, <span class="hljs-number"><span class="hljs-number">0</span></span>x04 ; write() mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> ;   lea ecx, [<span class="hljs-type"><span class="hljs-type">ebp</span></span>+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;   mov edx, <span class="hljs-number"><span class="hljs-number">1</span></span> ;   <span class="hljs-number"><span class="hljs-number">1</span></span>  int <span class="hljs-number"><span class="hljs-number">0</span></span>x80 leave ret</code> </pre> <br>  Wie leiten wir also einzelne Zahlen in einer Zahl ab?  Beachten Sie zunächst, dass die letzte Ziffer der Zahl der Rest der Division durch 10 ist (z. B. <code>123 % 10 = 3</code> ), und die nächste Ziffer der Rest der Division durch 100, geteilt durch 10 (z. B. <code>(123 % 100)/10 = 2</code> ).  Im Allgemeinen können Sie eine bestimmte Ziffer einer Zahl (von rechts nach links) finden, indem Sie <code>( % 10**n) / 10**(n-1)</code> suchen, wobei die Anzahl der Einheiten <code>n = 1</code> , die Anzahl der Zehner <code>n = 2</code> und so weiter. <br><br>  Mit diesem Wissen können Sie alle Ziffern einer Zahl von <code>n = 1</code> bis <code>n = 10</code> (dies ist die maximale Anzahl von Bits in einer vorzeichenbehafteten 4-Byte-Ganzzahl).  Es ist jedoch viel einfacher, von links nach rechts zu wechseln. So können wir jedes Zeichen drucken, sobald wir es finden, und die Nullen auf der linken Seite entfernen.  Daher sortieren wir die Zahlen von <code>n = 10</code> bis <code>n = 1</code> . <br><br>  In C sieht das Programm ungefähr so ​​aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAX_DIGITS 10 void print_answer(int a) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (a </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; 0) { //    putc('-'); //   «» a = -a; //     } int started = 0; for (int i = MAX_DIGITS; i &gt; 0; i--) { int digit = (a % pow_10(i)) / pow_10(i-1); if (digit == 0 &amp;&amp; started == 0) continue; //     started = 1; putc(digit + '0'); } }</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt verstehen Sie, warum wir diese drei Funktionen benötigen. </font><font style="vertical-align: inherit;">Lassen Sie uns dies in Assembler implementieren:</font></font><br><br><pre> <code class="hljs perl">%define MAX_DIGITS <span class="hljs-number"><span class="hljs-number">10</span></span> _print_answer: enter <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ;  <span class="hljs-number"><span class="hljs-number">1</span></span>    <span class="hljs-string"><span class="hljs-string">"started"</span></span>   C <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ebx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> edi <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> esi mov eax, [ebp+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;   <span class="hljs-string"><span class="hljs-string">"a"</span></span> cmp eax, <span class="hljs-number"><span class="hljs-number">0</span></span> ;    ,    ;  jge _print_answer_negate_end ; call putc <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-string"><span class="hljs-string">'-'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> <span class="hljs-number"><span class="hljs-number">0x2d</span></span> ;  <span class="hljs-string"><span class="hljs-string">'-'</span></span> call _putc add esp, <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> eax neg eax ;     _print_answer_negate_end: mov byte [ebp-<span class="hljs-number"><span class="hljs-number">4</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span> ; started = <span class="hljs-number"><span class="hljs-number">0</span></span> mov ecx, MAX_DIGITS ;  i _print_answer_loop_start: cmp ecx, <span class="hljs-number"><span class="hljs-number">0</span></span> je _print_answer_loop_end ;  pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>  ecx.   ebx   <span class="hljs-string"><span class="hljs-string">"digit"</span></span>   C. ;    edx = pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i-<span class="hljs-number"><span class="hljs-number">1</span></span>),  ebx = pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i) <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx dec ecx ; i-<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx ;    _pow_1<span class="hljs-number"><span class="hljs-number">0</span></span> call _pow_1<span class="hljs-number"><span class="hljs-number">0</span></span> mov edx, eax ; edx = pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i-<span class="hljs-number"><span class="hljs-number">1</span></span>) add esp, <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ecx ;   i  ecx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> eax ; end pow_1<span class="hljs-number"><span class="hljs-number">0</span></span> call mov ebx, edx ; digit = ebx = pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i-<span class="hljs-number"><span class="hljs-number">1</span></span>) imul ebx, <span class="hljs-number"><span class="hljs-number">10</span></span> ; digit = ebx = pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i) ;  _mod  (a % pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i)),   (eax mod ebx) <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> edx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ebx ; arg2, ebx = digit = pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i) <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax ; arg1, eax = a call _mod mov ebx, eax ; digit = ebx = a % pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i+<span class="hljs-number"><span class="hljs-number">1</span></span>), almost there add esp, <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> edx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> eax ;   mod ;  ebx ( <span class="hljs-string"><span class="hljs-string">"digit"</span></span> )  pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i) (edx).    ; ,   idiv     edx, eax.  ; edx   ,    - ;   <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> esi mov esi, edx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax mov eax, ebx mov edx, <span class="hljs-number"><span class="hljs-number">0</span></span> idiv esi ; eax   () mov ebx, eax ; ebx = (a % pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i)) / pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i-<span class="hljs-number"><span class="hljs-number">1</span></span>),  <span class="hljs-string"><span class="hljs-string">"digit"</span></span>   C <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> eax <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> esi ; end division cmp ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> ;  digit == <span class="hljs-number"><span class="hljs-number">0</span></span> jne _print_answer_trailing_zeroes_check_end cmp byte [ebp-<span class="hljs-number"><span class="hljs-number">4</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span> ;  started == <span class="hljs-number"><span class="hljs-number">0</span></span> jne _print_answer_trailing_zeroes_check_end jmp _print_answer_loop_continue ; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> _print_answer_trailing_zeroes_check_end: mov byte [ebp-<span class="hljs-number"><span class="hljs-number">4</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span> ; started = <span class="hljs-number"><span class="hljs-number">1</span></span> add ebx, <span class="hljs-number"><span class="hljs-number">0x30</span></span> ; digit + <span class="hljs-string"><span class="hljs-string">'0'</span></span> ;  putc <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> edx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ebx call _putc add esp, <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> edx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> eax ;   putc _print_answer_loop_continue: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ecx</span></span></span><span class="hljs-function">, 1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jmp</span></span></span><span class="hljs-function"> _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_answer_loop_start</span></span></span><span class="hljs-function"> _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_answer_loop_end</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">esi</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">edi</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ebx</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leave</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ret</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es war ein schwieriger Test! </font><font style="vertical-align: inherit;">Hoffe, die Kommentare helfen, es zu klären. </font><font style="vertical-align: inherit;">Wenn Sie jetzt denken: "Warum können Sie nicht einfach schreiben </font></font><code>printf("%d")</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?", Dann wird Ihnen das Ende des Artikels gefallen, in dem wir die Funktion durch genau das ersetzen werden! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt haben wir alle notwendigen Funktionen, es bleibt die Grundlogik zu implementieren </font></font><code>_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- und das ist alles!</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reverse polnische Notationsberechnung </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie bereits erwähnt, wird die umgekehrte polnische Notation mithilfe des Stapels berechnet. </font><font style="vertical-align: inherit;">Beim Lesen wird die Zahl auf den Stapel geschoben, und beim Lesen wird der Operator auf zwei Objekte oben im Stapel angewendet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir beispielsweise berechnen möchten </font></font><code>84/3+6*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(dieser Ausdruck kann auch in der Form geschrieben werden </font></font><code>6384/+*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), ist der Prozess wie folgt:</font></font><br><br><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schritt </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Symbol </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vorher stapeln </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stapel nach </font></font></th></tr><tr><td align="center">  1 </td><td align="center"> <code>8</code> </td> <td align="center"> <code>[]</code> </td> <td align="center"> <code>[8]</code> </td> </tr><tr><td align="center">  2 </td><td align="center"> <code>4</code> </td> <td align="center"> <code>[8]</code> </td> <td align="center"> <code>[8, 4]</code> </td> </tr><tr><td align="center">  3 </td><td align="center"> <code>/</code> </td> <td align="center"> <code>[8, 4]</code> </td> <td align="center"> <code>[2]</code> </td> </tr><tr><td align="center">  4 </td><td align="center"> <code>3</code> </td> <td align="center"> <code>[2]</code> </td> <td align="center"> <code>[2, 3]</code> </td> </tr><tr><td align="center">  5 </td><td align="center"> <code>+</code> </td> <td align="center"> <code>[2, 3]</code> </td> <td align="center"> <code>[5]</code> </td> </tr><tr><td align="center">  6 </td><td align="center"> <code>6</code> </td> <td align="center"> <code>[5]</code> </td> <td align="center"> <code>[5, 6]</code> </td> </tr><tr><td align="center">  7 </td><td align="center"> <code>*</code> </td> <td align="center"> <code>[5, 6]</code> </td> <td align="center"> <code>[30]</code> </td> </tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Eingabe ein gültiger Postfix-Ausdruck ist, befindet sich am Ende der Berechnungen nur noch ein Element auf dem Stapel - dies ist die Antwort, das Ergebnis der Berechnungen. </font><font style="vertical-align: inherit;">In unserem Fall ist die Zahl 30. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Assembler müssen Sie so etwas wie diesen Code in C implementieren:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>[<span class="hljs-number"><span class="hljs-number">256</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// , 256      int stack_size = 0; int main(int argc, char *argv[]) { char *input = argv[0]; size_t input_length = strlen(input); for (int i = 0; i &lt; input_length; i++) { char c = input[i]; if (c &gt;= '0' &amp;&amp; c &lt;= '9') { //   —   push(c - '0'); //          } else { int b = pop(); int a = pop(); if (c == '+') { push(a+b); } else if (c == '-') { push(ab); } else if (c == '*') { push(a*b); } else if (c == '/') { push(a/b); } else { error("Invalid input\n"); exit(1); } } } if (stack_size != 1) { error("Invalid input\n"); exit(1); } print_answer(stack[0]); exit(0); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt haben wir alle Funktionen, um dies zu implementieren. Beginnen wir. </font></font><br><br><pre> <code class="hljs perl">_start: ;  _start   ,    . ;   esp    argc ( ),  ; esp+<span class="hljs-number"><span class="hljs-number">4</span></span>   argv. , esp+<span class="hljs-number"><span class="hljs-number">4</span></span>    ; , esp+<span class="hljs-number"><span class="hljs-number">8</span></span> -       mov esi, [esp+<span class="hljs-number"><span class="hljs-number">8</span></span>] ; esi = <span class="hljs-string"><span class="hljs-string">"input"</span></span> = argv[<span class="hljs-number"><span class="hljs-number">0</span></span>] ;  _strlen      <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> esi call _strlen mov ebx, eax ; ebx = input_length add esp, <span class="hljs-number"><span class="hljs-number">4</span></span> ; end _strlen call mov ecx, <span class="hljs-number"><span class="hljs-number">0</span></span> ; ecx = <span class="hljs-string"><span class="hljs-string">"i"</span></span> _main_loop_start: cmp ecx, ebx ;  (i &gt;= input_length) jge _main_loop_end mov edx, <span class="hljs-number"><span class="hljs-number">0</span></span> mov dl, [esi + ecx] ;          ; edx.   edx . ; edx =  c = input[i] cmp edx, <span class="hljs-string"><span class="hljs-string">'0'</span></span> jl _check_operator cmp edx, <span class="hljs-string"><span class="hljs-string">'9'</span></span> jg _print_error <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">edx</span></span></span><span class="hljs-function">, '0' </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mov</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eax</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">edx</span></span></span><span class="hljs-function"> </span></span>; eax =  c - <span class="hljs-string"><span class="hljs-string">'0'</span></span> (,  ) jmp _push_eax_and_continue _check_operator: ;   _pop    b  edi, a  b -  eax <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ebx call _pop mov edi, eax ; edi = b call _pop ; eax = a <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ebx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ecx ; end call _pop cmp edx, <span class="hljs-string"><span class="hljs-string">'+'</span></span> jne _subtract add eax, edi ; eax = a+b jmp _push_eax_and_continue _subtract: cmp edx, <span class="hljs-string"><span class="hljs-string">'-'</span></span> jne _multiply <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eax</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">edi</span></span></span><span class="hljs-function"> </span></span>; eax = ab jmp _push_eax_and_continue _multiply: cmp edx, <span class="hljs-string"><span class="hljs-string">'*'</span></span> jne _divide imul eax, edi ; eax = a*b jmp _push_eax_and_continue _divide: cmp edx, <span class="hljs-string"><span class="hljs-string">'/'</span></span> jne _print_error <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> edx ;  edx,      idiv mov edx, <span class="hljs-number"><span class="hljs-number">0</span></span> idiv edi ; eax = a/b <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> edx ;   eax     _push_eax_and_continue: ;  _push <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> edx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax ;   call _push add esp, <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> edx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> eax ;  call _push inc ecx jmp _main_loop_start _main_loop_end: cmp byte [stack_size], <span class="hljs-number"><span class="hljs-number">1</span></span> ;  (stack_size != <span class="hljs-number"><span class="hljs-number">1</span></span>),   jne _print_error mov eax, [stack] <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax call _print_answer ; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> a final newline <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> <span class="hljs-number"><span class="hljs-number">0xA</span></span> call _putc ; <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span> successfully mov eax, <span class="hljs-number"><span class="hljs-number">0x01</span></span> ; <span class="hljs-number"><span class="hljs-number">0x01</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>() mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span> =   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> ;    _print_error: <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> error_msg call _print_msg mov eax, <span class="hljs-number"><span class="hljs-number">0x01</span></span> mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie müssen </font></font><code>error_msg</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dem Abschnitt </font><font style="vertical-align: inherit;">auch eine Zeile hinzufügen </font></font><code>.rodata</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="hljs 1c">section .rodata ;     error_msg.  db  NASM ;    ,   <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  ; . <span class="hljs-number"><span class="hljs-number">0</span></span>xA =  <span class="hljs-built_in"><span class="hljs-built_in"></span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>x0 =    error_msg: db <span class="hljs-string"><span class="hljs-string">"Invalid input"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>xA, <span class="hljs-number"><span class="hljs-number">0</span></span>x0</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und wir sind fertig! </font><font style="vertical-align: inherit;">Überraschen Sie alle Ihre Freunde, wenn Sie sie haben. </font><font style="vertical-align: inherit;">Ich hoffe, dass Sie jetzt besser auf Hochsprachen reagieren, besonders wenn Sie sich daran erinnern, dass viele alte Programme vollständig oder fast vollständig in Assembler geschrieben wurden, zum Beispiel der ursprüngliche RollerCoaster Tycoon! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der gesamte Code ist </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Danke fürs Lesen! </font><font style="vertical-align: inherit;">Ich kann fortfahren, wenn Sie interessiert sind.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Weitere Aktionen </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie können üben, indem Sie mehrere zusätzliche Funktionen implementieren: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Geben Sie eine Fehlermeldung anstelle von segfault zurück, wenn das Programm kein Argument erhält. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unterstützung für zusätzliche Leerzeichen zwischen Operanden und Operatoren in der Eingabe hinzufügen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unterstützung für Multi-Bit-Operanden hinzufügen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Negative Zahlen zulassen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durch </font></font><code>_strlen</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine Funktion aus der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standard-C-Bibliothek</font></font></a><font style="vertical-align: inherit;"></font><code>_print_answer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ersetzen </font><font style="vertical-align: inherit;">und </font><font style="vertical-align: inherit;">durch einen Aufruf ersetzen </font></font><code>printf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li></ol><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zusätzliche Materialien </font></font></h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das x86-Assembler-Handbuch der Virginia University enthält</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eine detailliertere Darstellung vieler der von uns behandelten Themen, einschließlich zusätzlicher Informationen zu allen gängigen x86-Anweisungen.</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">«   Intel»</a> .    x86 —   ,      .        ,    ,      . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NASM: Intel x86 Instruction Reference</a> —       x86. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de423077/">https://habr.com/ru/post/de423077/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de423067/index.html">Python Developer Tools von Microsoft. Erste Schritte</a></li>
<li><a href="../de423069/index.html">Apple Special Event, September 2018 [Textübersetzungsarchiv]</a></li>
<li><a href="../de423071/index.html">Ich habe keine Angst vor deiner NDA</a></li>
<li><a href="../de423073/index.html">Interplanetares Dateisystem - trivialer Hash (Identität), DAG-Block und Protokollpuffer</a></li>
<li><a href="../de423075/index.html">Warum sind CFOs so bemüht, IT-Investitionen in Betrieb umzusetzen?</a></li>
<li><a href="../de423079/index.html">Wichtige Punkte aus einem Interview mit Elon Musk bei Joe Rogan</a></li>
<li><a href="../de423083/index.html">Wie ich Entwickler bei ABBYY wurde</a></li>
<li><a href="../de423085/index.html">Feineinstellung des Lastausgleichs</a></li>
<li><a href="../de423087/index.html">Drück mir nicht ins Auge</a></li>
<li><a href="../de423089/index.html">Programmierer bei MBLT DEV 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>