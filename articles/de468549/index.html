<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôçüèø üêâ üïî GPU gebunden. So √ºbertragen Sie alles auf die Grafikkarte und ein bisschen mehr. Animationen ‚òùÔ∏è üåê üë¥üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es war einmal ein gro√ües Ereignis, als eine Multitexturing-Einheit oder Hardware Transformation & Lighting (T & L) auf der GPU erschien. Das Festlegen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>GPU gebunden. So √ºbertragen Sie alles auf die Grafikkarte und ein bisschen mehr. Animationen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468549/">  Es war einmal ein gro√ües Ereignis, als eine Multitexturing-Einheit oder Hardware Transformation &amp; Lighting (T &amp; L) auf der GPU erschien.  Das Festlegen einer Pipeline mit festen Funktionen war magischer Schamanismus.  Und diejenigen, die wussten, wie man die erweiterten Funktionen bestimmter Chips √ºber die D3D9-API-Hacks aktiviert und nutzt, gaben an, Zen gelernt zu haben.  Aber die Zeit verging, Shader erschienen.  Zun√§chst stark eingeschr√§nkt in Funktionalit√§t und L√§nge.  Weiter, immer mehr Funktionen, mehr Anweisungen, mehr Geschwindigkeit.  Compute (CUDA, OpenCL, DirectCompute) erschien und der Umfang der Grafikkartenkapazit√§ten begann sich rasch zu erweitern. <br><br>  In dieser Reihe von (hoffentlich) Artikeln werde ich versuchen zu erkl√§ren und zu zeigen, wie ‚Äûungew√∂hnlich‚Äú Sie die Funktionen der modernen GPU bei der Entwicklung von Spielen zus√§tzlich zu Grafikeffekten anwenden k√∂nnen.  Der erste Teil ist dem Animationssystem gewidmet.  Alles, was beschrieben wird, basiert auf praktischen Erfahrungen, implementiert und funktioniert in realen Spielprojekten. <br><a name="habracut"></a><br>  Oooo, wieder die Animation.  Dar√ºber hundertmal schon geschrieben und beschrieben.  Was ist so kompliziert?  Wir packen die Knochenmatrix in den Puffer / die Textur und verwenden sie zum Enth√§uten im Vertex-Shader.  Dies wurde bereits in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GPU Gems 3 (Kapitel 2. Animiertes Crowd-Rendering) beschrieben</a> .  Und implementiert in der j√ºngsten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unite Tech Presentation</a> .  Ist es anders m√∂glich? <br><br><h4>  Technodemka von Unity </h4><br>  Viel Hype, aber ist es wirklich cool?  Auf dem Hub gibt es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Artikel,</a> der ausf√ºhrlich beschreibt, wie Skelettanimationen erstellt werden und in dieser Techno-Demo funktionieren.  Parallelarbeit ist alles gut, wir betrachten sie nicht.  Aber wir m√ºssen herausfinden, was und wie es in Bezug auf das Rendern gibt. <br><br>  In einer gro√ü angelegten Schlacht k√§mpfen zwei Armeen, die jeweils aus einem Einheitentyp bestehen.  Skelette links, Ritter rechts.  Abwechslung ist so lala.  Jede Einheit besteht aus 3 LODs (jeweils ~ 300, ~ 1000, ~ 4000 Scheitelpunkte), und nur 2 Knochen beeinflussen den Scheitelpunkt.  Das Animationssystem besteht nur aus 7 Animationen f√ºr jeden Einheitentyp (ich erinnere mich, dass es bereits 2 davon gibt).  Animationen f√ºgen sich nicht ein, sondern wechseln diskret von einfachem Code, der in job'ax ausgef√ºhrt wird, was in der Pr√§sentation hervorgehoben wird.  Es gibt keine Zustandsmaschine.  Wenn wir zwei Arten von Maschen haben, k√∂nnen Sie diese ganze Menge in zwei Instanzen zeichnen.  Die Skelettanimation basiert, wie ich bereits schrieb, auf der 2009 beschriebenen Technologie. <br>  Innovativ?  Hmm ... ein Durchbruch?  √Ñhm ... Geeignet f√ºr moderne Spiele?  Nun, vielleicht r√ºhmt sich das Verh√§ltnis von FPS zur Anzahl der Einheiten. <br><br>  Die Hauptnachteile dieses Ansatzes (Vormatrix in Texturen): <br><br><ol><li>  Bildrate abh√§ngig.  Wollte doppelt so viele Animationsbilder - geben Sie doppelt so viel Speicher. </li><li>  Fehlende Mischanimationen.  Sie k√∂nnen sie nat√ºrlich erstellen, aber im Skin-Shader bildet sich aus der Mischlogik ein komplexes Durcheinander. </li><li>  Fehlende Bindung an die Unity Animator-Zustandsmaschine.  Ein praktisches Werkzeug zum Anpassen des Verhaltens des Charakters, das mit jedem Skinning-System verbunden werden kann. In unserem Fall wird jedoch aufgrund von Punkt 2 alles sehr schwierig (stellen Sie sich vor, wie Sie den verschachtelten BlendTree mischen). </li></ol><br><h4>  GPAS </h4><br>  GPU-basiertes Animationssystem.  Der Name ist gerade aufgetaucht. <br>  Das neue Animationssystem hatte mehrere Anforderungen: <br><br><ol><li>  Arbeiten Sie schnell (gut, verst√§ndlich).  Sie m√ºssen Zehntausende verschiedener Einheiten animieren. </li><li>  Seien Sie ein vollst√§ndiges (oder fast) Analogon des Unity-Animationssystems.  Wenn dort die Animation so aussieht, sollte sie im neuen System genauso aussehen.  M√∂glichkeit zum Umschalten zwischen integrierten CPU- und GPU-Systemen.  Dies ist h√§ufig zum Debuggen erforderlich.  Wenn Animationen ‚Äûfehlerhaft‚Äú sind, k√∂nnen Sie durch Umschalten auf den klassischen Animator verstehen: Dies sind die Pannen des neuen Systems oder der Zustandsmaschine / Animation selbst. </li><li>  Alle Animationen k√∂nnen in Unity Animator angepasst werden.  Ein praktisches, getestetes und vor allem gebrauchsfertiges Tool.  Wir werden woanders Fahrr√§der bauen. </li></ol><br>  √úberdenken wir die Vorbereitung und das Backen von Animationen.  Wir werden keine Matrizen verwenden.  Moderne Grafikkarten funktionieren gut mit Schleifen, unterst√ºtzen nativ zus√§tzlich zu float nativ, sodass wir mit Keyframes wie auf einer CPU arbeiten werden. <br><br>  Schauen wir uns ein Beispiel f√ºr eine Animation im Animations-Viewer an: <br><br><img src="https://habrastorage.org/webt/_4/yw/bg/_4ywbgkzw8frqb3pjng98db5zwm.jpeg"><br><br>  Es ist ersichtlich, dass die Keyframes f√ºr Position, Skalierung und Drehung separat eingestellt sind.  F√ºr einige Bones ben√∂tigen Sie viele, f√ºr einige nur wenige, und f√ºr die Bones, die nicht separat animiert werden, werden nur der erste und der letzte Keyframe festgelegt. <br><br>  Position - Vektor3, Quaternion - Vektor4, Skala - Vektor3.  Die Keyframe-Struktur hat eines gemeinsam (zur Vereinfachung), daher ben√∂tigen wir 4 float, um zu einem der oben genannten Typen zu passen.  Wir ben√∂tigen auch InTangent und OutTangent f√ºr die korrekte Interpolation zwischen Keyframes entsprechend der Kr√ºmmung.  Oh ja, und die normalisierte Zeit vergisst nicht: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyFrame</span></span></span><span class="hljs-class"> {</span></span> float4 v; float4 inTan, outTan; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> time; };</code> </pre> <br>  Verwenden Sie AnimationUtility.GetEditorCurve (), um alle Keyframes abzurufen. <br>  Au√üerdem m√ºssen wir uns die Namen der Knochen merken, da die Knochen der Animation in den Knochen des Skeletts (und m√∂glicherweise nicht √ºbereinstimmen) in der Phase der Vorbereitung der GPU-Daten neu zugeordnet werden m√ºssen. <br><br>  Wenn wir lineare Puffer mit Arrays von Keyframes f√ºllen, werden wir uns an die Offsets in ihnen erinnern, um diejenigen zu finden, die sich auf die Animation beziehen, die wir ben√∂tigen. <br><br>  Jetzt interessant.  GPU-Skelettanimation. <br><br>  Wir bereiten einen gro√üen Puffer ("Anzahl der animierten Skelette" X "Anzahl der Knochen im Skelett" X "empirischer Koeffizient der maximalen Anzahl von Animationsmischungen") vor.  Darin speichern wir die Position, Rotation und Skalierung des Knochens zum Zeitpunkt der Animation.  F√ºhren Sie f√ºr alle geplanten animierten Bones in diesem Frame den Compute Shader aus.  Jeder Thread animiert seinen Knochen. <br><br>  Jeder Keyframe, unabh√§ngig von seiner Gr√∂√üe (√úbersetzen, Drehen, Skalieren), wird auf genau dieselbe Weise interpoliert (Suche durch lineare Suche, verzeihen Sie mir, Knuth): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InterpolateKeyFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout float4 rv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> startIdx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> endIdx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = startIdx; i &lt; endIdx; ++i) { KeyFrame k0 = keyFrames[i + <span class="hljs-number"><span class="hljs-number">0</span></span>]; KeyFrame k1 = keyFrames[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lerpFactor = (t - k0.time) / (k1.time - k0.time); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lerpFactor &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || lerpFactor &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; rv = CurveInterpoate(k0, k1, lerpFactor); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre><br>  Die Kurve ist eine kubische Bezier-Kurve, daher lautet die Interpolationsfunktion wie folgt: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CurveInterpoate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(KeyFrame v0, KeyFrame v1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dt = v1.time - v0.time; float4 m0 = v0.outTan * dt; float4 m1 = v1.inTan * dt; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t2 = t * t; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t3 = t2 * t; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a = <span class="hljs-number"><span class="hljs-number">2</span></span> * t3 - <span class="hljs-number"><span class="hljs-number">3</span></span> * t2 + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = t3 - <span class="hljs-number"><span class="hljs-number">2</span></span> * t2 + t; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> c = t3 - t2; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d = <span class="hljs-number"><span class="hljs-number">-2</span></span> * t3 + <span class="hljs-number"><span class="hljs-number">3</span></span> * t2; float4 rv = a * v0.v + b * m0 + c * m1 + d * v1.v; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rv; }</code> </pre><br>  Die lokale Haltung (TRS) des Knochens wurde berechnet.  Als N√§chstes mischen wir mit einem separaten Compute-Shader alle erforderlichen Animationen f√ºr diesen Bone.  Zu diesem Zweck haben wir einen Puffer mit Animationsindizes und Gewichten jeder Animation in der endg√ºltigen Mischung.  Wir erhalten diese Informationen von der Zustandsmaschine.  Die Situation von BlendTree in BlendTree wird wie folgt gel√∂st.  Zum Beispiel gibt es einen Baum: <br><br><img src="https://habrastorage.org/webt/yg/n6/_4/ygn6_4arygdkgbnigucbv0tz0fe.jpeg"><br><br>  BlendTree Walk hat ein Gewicht von 0,35, Run - 0,65.  Dementsprechend sollte die endg√ºltige Position der Knochen durch 4 Animationen bestimmt werden: Walk1, Walk2, Run1 und Run2.  Ihre Gewichte haben Werte (0,35 ¬∑ 0,92, 0,35 ¬∑ 0,08, 0,65 ¬∑ 0,92, 0,65 ¬∑ 0,08) = (0,322, 0,028, 0,598, 0,052).  Es sollte beachtet werden, dass die Summe der Gewichte immer gleich eins sein sollte, oder es werden magische Fehler bereitgestellt. <br><br>  Das "Herz" der Mischfunktion: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bw = animDef.blendWeight; BoneXForm boneToBlend = animatedBones[srcBoneIndex]; float4 q = boneToBlend.quat; float3 t = boneToBlend.translate; float3 s = boneToBlend.scale; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dot(resultBone.quat, q) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) q = -q; resultBone.translate += t * bw; resultBone.quat += q * bw; resultBone.scale += s * bw;</code> </pre><br>  Jetzt k√∂nnen Sie in eine Transformationsmatrix √ºbersetzen.  H√∂r auf  √úber die Hierarchie der Knochen v√∂llig vergessen. <br>  Basierend auf den Daten aus dem Skelett konstruieren wir ein Array von Indizes, wobei die Zelle mit dem Knochenindex den Index ihres Elternteils enth√§lt.  Schreiben Sie in root -1. <br><br>  Ein Beispiel: <br><br><img src="https://habrastorage.org/webt/c0/8v/tl/c08vtlrw1w80dsczyczusebox34.jpeg"><br><br><pre> <code class="cpp hljs">float4x4 animMat = IdentityMatrix(); float4x4 mat = initialPoses[boneId]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (boneId &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { BoneXForm b = blendedBones[boneId]; float4x4 xform = MakeTransformMatrix(b.translate, b.quat, b.scale); animMat = mul(animMat, xform); boneId = bonesHierarchyIndices[boneId]; } mat = mul(mat, animMat); resultSkeletons[id] = mat;</code> </pre><br>  Hier im Prinzip alle Hauptpunkte des Renderns und Mischens von Animationen. <br><br><h4>  GPSM </h4><br>  GPU Powered State Machine (Sie haben es richtig erraten).  Das oben beschriebene Animationssystem w√ºrde perfekt mit der Unity Animation State Machine funktionieren, aber dann w√§ren alle Bem√ºhungen nutzlos.  Mit der M√∂glichkeit, Zehntausende (wenn nicht Hunderttausende) Animationen pro Frame zu berechnen, zieht UnityAnimator nicht Tausende von gleichzeitig funktionierenden Zustandsmaschinen heraus.  Hmm ... <br>  Was ist eine Zustandsmaschine in Unity?  Dies ist ein geschlossenes System von Zust√§nden und √úberg√§ngen, das durch einfache numerische Eigenschaften gesteuert wird.  Jede Zustandsmaschine arbeitet unabh√§ngig voneinander und f√ºr denselben Satz von Eingabedaten.  Warte eine Minute.  Dies ist eine ideale Aufgabe f√ºr die GPU und Compute Shader! <br><br>  <u>Backphase</u> <br><br>  Zun√§chst m√ºssen wir alle Zustandsmaschinendaten sammeln und in einer GPU-freundlichen Struktur platzieren.  Und das: Zust√§nde (Zust√§nde), √úberg√§nge (√úberg√§nge) und Parameter (Parameter). <br>  Alle diese Daten werden in linearen Puffern abgelegt und durch Indizes adressiert. <br>  Jeder Rechenthread ber√ºcksichtigt seine Zustandsmaschine.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AnimatorController</a> bietet eine Schnittstelle zu allen erforderlichen internen Zustandsmaschinenstrukturen. <br><br>  Die Hauptstrukturen der Zustandsmaschine: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> firstTransition; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numTransitions; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> animDefId; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Transition</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> exitTime; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> duration; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sourceStateId; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> targetStateId; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> firstCondition; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endCondition; uint properties; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StateData</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> timeInState; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> animationLoop; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TransitionData</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> timeInTransition; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CurrentState</span></span></span><span class="hljs-class"> {</span></span> StateData srcState, dstState; TransitionData transition; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnimationDef</span></span></span><span class="hljs-class"> {</span></span> uint animId; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nextAnimInTree; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> parameterIdx; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lengthInSec; uint numBones; uint loop; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParameterDef</span></span></span><span class="hljs-class"> {</span></span> float2 line0ab, line1ab; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> runtimeParamId; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nextParameterId; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Condition</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> checkMode; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> runtimeParamIndex; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> referenceValue; };</code> </pre><br><ul><li>  Der Status enth√§lt die Geschwindigkeit, mit der der Status abgespielt wird, und die Indizes der Bedingungen f√ºr den √úbergang zu anderen gem√§√ü der Statusmaschine. </li><li>  Der √úbergang enth√§lt Zustandsindizes ‚Äûvon‚Äú und ‚Äûbis‚Äú.  √úbergangszeit, Austrittszeit und eine Verkn√ºpfung zu einer Reihe von Bedingungen f√ºr den Eintritt in diesen Zustand. </li><li>  CurrentState ist ein Laufzeitdatenblock mit Daten zum aktuellen Status der Zustandsmaschine. </li><li>  AnimationDef enth√§lt eine Beschreibung der Animation mit Links zu anderen von BlendTree verwandten Animationen. </li><li>  ParameterDef ist eine Beschreibung des Parameters, der das Verhalten der Zustandsautomaten steuert.  Line0ab und Line1ab sind die Koeffizienten der Liniengleichung, um das Gewicht der Animation anhand des Werts des Parameters zu bestimmen.  Von hier aus: <br><br><img src="https://habrastorage.org/webt/ge/dl/wd/gedlwdz-u4iiyqciuy-lewx8xnm.jpeg"><br></li><li>  Bedingung - Angabe der Bedingung zum Vergleichen des Laufzeitwerts des Parameters und des Referenzwerts. </li></ul><br>  <u>Laufzeitphase</u> <br><br>  Der Hauptzyklus jeder Zustandsmaschine kann mit dem folgenden Algorithmus angezeigt werden: <br><br><img src="https://habrastorage.org/webt/q_/cu/gc/q_cugcb1tr2krdkztmuxbr1yds8.jpeg"><br><br>  Es gibt 4 Arten von Parametern im Unity-Animator: float, int, bool und trigger (das ist bool).  Wir werden sie alle als Float pr√§sentieren.  Beim Einrichten der Bedingungen kann einer von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sechs</a> Vergleichstypen ausgew√§hlt werden.  Wenn == gleich.  IfNot == NotEqual.  Wir werden also nur 4 verwenden. Der Operatorindex wird an das Feld checkMode der Bedingungsstruktur √ºbergeben. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = t.firstCondition; i &lt; t.endCondition; ++i) { Condition c = allConditions[i]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> paramValue = runtimeParameters[c.runtimeParamIndex]; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (c.checkMode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (paramValue &lt; c.referenceValue) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (paramValue &gt; c.referenceValue) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(paramValue - c.referenceValue) &gt; <span class="hljs-number"><span class="hljs-number">0.001f</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(paramValue - c.referenceValue) &lt; <span class="hljs-number"><span class="hljs-number">0.001f</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre><br>  Um den √úbergang zu starten, m√ºssen alle Bedingungen erf√ºllt sein.  Die seltsamen Fallbezeichnungen sind nur (int) AnimatorConditionMode.  Die Unterbrechungslogik ist eine schwierige Logik zum Unterbrechen und Zur√ºcksetzen von √úberg√§ngen. <br><br>  Nachdem wir den Status der Zustandsmaschine aktualisiert und die Zeitstempel im Delta-t-Frame gescrollt haben, ist es Zeit, Daten dar√ºber vorzubereiten, welche Animationen in diesem Frame gelesen werden sollen, und die entsprechenden Gewichte.  Dieser Schritt wird √ºbersprungen, wenn sich das Ger√§temodell nicht im Rahmen befindet (Frustum gekeult).  Warum sollten wir Animationen von dem betrachten, was nicht sichtbar ist?  Wir gehen den Quellstatus des Mischbaums und den Zielstatus des Mischbaums durch, f√ºgen alle Animationen daraus hinzu und berechnen die Gewichte anhand der normalisierten √úbergangszeit von der Quelle zum Ziel (Zeit f√ºr den √úbergang).  Mit vorbereiteten Daten kommt GPAS ins Spiel und z√§hlt Animationen f√ºr jede animierte Entit√§t im Spiel. <br><br>  Die Ger√§testeuerungsparameter stammen aus der Ger√§testeuerungslogik.  Sie m√ºssen beispielsweise das Laufen aktivieren, den Parameter CharSpeed ‚Äã‚Äãfestlegen und eine korrekt konfigurierte Zustandsmaschine mischt √úbergangsanimationen von ‚ÄûGehen‚Äú zu ‚ÄûLaufen‚Äú reibungslos. <br><br>  Nat√ºrlich hat die vollst√§ndige Analogie zu Unity Animator nicht funktioniert.  Interne Arbeitsprinzipien mussten, sofern sie nicht in der Dokumentation beschrieben sind, umgekehrt und analog gemacht werden.  Einige Funktionen wurden noch nicht abgeschlossen (m√∂glicherweise nicht).  Beispielsweise unterst√ºtzt BlendType in BlendTree nur 1D.  Andere Typen herzustellen ist im Prinzip nicht schwierig, gerade jetzt ist es nicht notwendig.  Es gibt keine Animationsereignisse, da ein R√ºcklesen mit der GPU erforderlich ist und das ‚Äûrichtige‚Äú Zur√ºcklesen mehrere Frames zur√ºckliegt, was nicht immer akzeptabel ist.  Es ist aber auch m√∂glich. <br><br><h4>  Rendern </h4><br>  Das Rendern von Einheiten erfolgt durch Instanziieren.  Gem√§√ü SV_InstanceID erhalten wir im Vertex-Shader die Matrix aller Bones, die den Vertex beeinflussen, und transformieren sie.  Absolut nichts Ungew√∂hnliches: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ApplySkin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 v, uint vertexID, uint instanceID)</span></span></span><span class="hljs-function"> </span></span>{ BoneInfoPacked bip = boneInfos[vertexID]; BoneInfo bi = UnpackBoneInfo(bip); SkeletonInstance skelInst = skeletonInstances[instanceID]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bonesOffset = skelInst.boneOffset; float4x4 animMat = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bw = bi.boneWeights[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bw &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { uint boneId = bi.boneIDs[i]; float4x4 boneMat = boneMatrices[boneId + bonesOffset]; animMat += boneMat * bw; } } float4 rv = float4(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); rv = mul(rv, animMat); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rv; }</code> </pre><br><h4>  Zusammenfassung </h4><br>  Funktioniert diese Farm schnell?  Offensichtlich langsamer als das Abtasten der Textur mit Matrizen, aber dennoch kann ich einige Zahlen anzeigen (GTX 970). <br><br>  Hier sind 50.000 Zustandsautomaten: <br><br><img src="https://habrastorage.org/webt/cw/bv/4o/cwbv4oww0dles0lwgt-xlsqxg5m.jpeg"><br><br>  Hier sind 280.000 animierte Knochen: <br><br><img src="https://habrastorage.org/webt/pe/lt/pv/peltpvbyztjsutrkxmhxyjbimbs.jpeg"><br><br>  Das Entwerfen und Debuggen all dessen ist ein echtes Problem.  Eine Reihe von Puffern und Offsets.  Eine Reihe von Komponenten und ihre Wechselwirkungen.  Es gab Zeiten, in denen H√§nde fielen, als Sie sich mehrere Tage lang wegen eines Problems den Kopf schlugen, aber Sie k√∂nnen das Problem nicht finden.  Es ist besonders "sch√∂n", wenn bei den Testdaten alles so funktioniert, wie es sollte, aber in einer echten "Kampf" -Situation gibt es keinen Animationsfehler.  Diskrepanzen zwischen dem Betrieb von Unity-Zustandsautomaten und ihren eigenen sind ebenfalls nicht sofort sichtbar.  Wenn Sie sich entscheiden, ein Analogon f√ºr sich selbst zu erstellen, beneide ich Sie im Allgemeinen nicht.  Eigentlich ist die ganze Entwicklung f√ºr die GPU so, warum sich beschweren. <br><br>  <b>PS</b> Ich m√∂chte einen Stein in den Garten der Unite TechDemo-Entwickler werfen.  Sie haben eine gro√üe Anzahl identischer Modelle von Ruinen und Br√ºcken auf der B√ºhne und sie haben ihr Rendering in keiner Weise optimiert.  Vielmehr versuchten sie es mit ‚Äûstatisch‚Äú.  Erst jetzt k√∂nnen Sie in 16-Bit-Indizes nicht viel Geometrie √ºberf√ºllen (dreimal haha, 2017), und es ist nichts zusammengekommen, da die Modelle stark polygonal sind.  Ich habe "Instanz aktivieren" f√ºr alle Shader aktiviert und "Statisch" deaktiviert.  Es gab keinen sp√ºrbaren Schub, aber verdammt noch mal, du machst eine Techno-Demo und k√§mpfst um jeden FPS.  Das kannst du nicht machen. <br><br><div class="spoiler">  <b class="spoiler_title">War</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">*** Summary *** Draw calls: 2553 Dispatch calls: 0 API calls: 8378 Index/vertex bind calls: 2992 Constant bind calls: 648 Sampler bind calls: 395 Resource bind calls: 805 Shader set calls: 682 Blend set calls: 230 Depth/stencil set calls: 92 Rasterization set calls: 238 Resource update calls: 1017 Output set calls: 74 API:Draw/Dispatch call ratio: 3.28163 298 Textures - 1041.01 MB (1039.95 MB over 32x32), 42 RTs - 306.94 MB. Avg. tex dimension: 1811.77x1810.21 (2016.63x2038.98 over 32x32) 216 Buffers - 180.11 MB total 17.54 MB IBs 159.81 MB VBs. 1528.06 MB - Grand total GPU buffer + texture load. *** Draw Statistics *** Total calls: 2553, instanced: 2, indirect: 2 Instance counts: 1: 2: 3: 4: 5: 6: 7: 8: 9: 10: 11: 12: 13: 14: &gt;=15: ******************************************************************************************************************************** (2)</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Ist geworden</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">*** Summary *** Draw calls: 1474 Dispatch calls: 0 API calls: 11106 Index/vertex bind calls: 3647 Constant bind calls: 1039 Sampler bind calls: 348 Resource bind calls: 718 Shader set calls: 686 Blend set calls: 230 Depth/stencil set calls: 110 Rasterization set calls: 258 Resource update calls: 1904 Output set calls: 74 API:Draw/Dispatch call ratio: 7.5346 298 Textures - 1041.01 MB (1039.95 MB over 32x32), 42 RTs - 306.94 MB. Avg. tex dimension: 1811.77x1810.21 (2016.63x2038.98 over 32x32) 427 Buffers - 93.30 MB total 9.81 MB IBs 80.51 MB VBs. 1441.25 MB - Grand total GPU buffer + texture load. *** Draw Statistics *** Total calls: 1474, instanced: 391, indirect: 2 Instance counts: 1: 2: ******************************************************************************************************************************** (104) 3: ************************************************* (40) 4: ********************** (18) 5: ****************************** (25) 6: ********************************************************************************************* (76) 7: *********************************** (29) 8: ************************************************** (41) 9: ********* (8) 10: ************** (12) 11: 12: ****** (5) 13: ******* (6) 14: ** (2) &gt;=15: ****************************** (25)</code> </pre><br></div></div><br>  <b>PPS</b> Zu allen Zeiten waren Spiele haupts√§chlich CPU-gebunden, d. H.  Die CPU konnte mit der GPU nicht mithalten.  Zu viel Logik und Physik.  Wenn wir einen Teil der Spielelogik von der CPU auf die GPU √ºbertragen, entladen wir die erste und die zweite, d. H.  machen die Situation der GPU gebunden wahrscheinlicher.  Daher der Titel des Artikels. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468549/">https://habr.com/ru/post/de468549/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468537/index.html">Grundlagen von DevOps. Einstieg in das Projekt von Grund auf neu</a></li>
<li><a href="../de468541/index.html">Drag & Drop-Komponenten f√ºr blinde Benutzer? Sie machen Witze?</a></li>
<li><a href="../de468543/index.html">Wochentags Programmkomitee FrontendConf. Interview mit Sergey Popov</a></li>
<li><a href="../de468545/index.html">"Alice, lass uns zum Frontend gehen!"</a></li>
<li><a href="../de468547/index.html">Englisch sprechend, CSS, Grid und Barrierefreiheit bei FrontendConf</a></li>
<li><a href="../de468553/index.html">Parameterverwaltung in Gesch√§ftsanwendungen √§hnlich einem Versionskontrollsystem</a></li>
<li><a href="../de468555/index.html">Einf√ºhrung in deterministische Assemblys in C / C ++. Teil 2</a></li>
<li><a href="../de468557/index.html">WEB 3.0 - der zweite Ansatz f√ºr das Projektil</a></li>
<li><a href="../de468559/index.html">Sichern Sie die Cloud, Freunde</a></li>
<li><a href="../de468561/index.html">Sicherheitswoche 39: Sicherheit und allt√§gliche Fehler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>