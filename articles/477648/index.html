<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úãüèΩ üå≤ üëßüèΩ MVCC en PostgreSQL-3. Versiones de fila üïí ü§ôüèª üöÜ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bueno, ya hemos discutido el aislamiento y hemos hecho una digresi√≥n sobre la estructura de datos de bajo nivel . Y finalmente hemos llegado a lo m√°s ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC en PostgreSQL-3. Versiones de fila</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/477648/">  Bueno, ya hemos discutido el <a href="https://habr.com/ru/company/postgrespro/blog/467437/">aislamiento</a> y hemos hecho una digresi√≥n sobre <a href="https://habr.com/ru/company/postgrespro/blog/469087/">la estructura de datos de bajo nivel</a> .  Y finalmente hemos llegado a lo m√°s fascinante, es decir, las versiones de fila (tuplas). <br><br><h1>  Encabezado de tupla </h1><br>  Como ya se mencion√≥, varias versiones de cada fila pueden estar disponibles simult√°neamente en la base de datos.  Y tenemos que distinguir de alguna manera una versi√≥n de otra.  Para este fin, cada versi√≥n est√° etiquetada con su "tiempo" <code>xmin</code> ( <code>xmin</code> ) y su "tiempo" de vencimiento ( <code>xmax</code> ).  Las comillas indican que se utiliza un contador incremental especial en lugar del tiempo en s√≠.  Y este contador es <em>el identificador de la transacci√≥n</em> . <br><br>  (Como de costumbre, en realidad esto es m√°s complicado: el ID de la transacci√≥n no siempre puede incrementarse debido a una profundidad limitada del contador. Pero exploraremos m√°s detalles de esto cuando nuestra discusi√≥n llegue a congelarse). <br><a name="habracut"></a><br>  Cuando se crea una fila, el valor de <code>xmin</code> se establece igual al ID de la transacci√≥n que realiz√≥ el comando INSERT, mientras que <code>xmax</code> no se completa. <br><br>  Cuando se elimina una fila, el valor <code>xmax</code> de la versi√≥n actual se etiqueta con el ID de la transacci√≥n que realiz√≥ DELETE. <br><br>  Un comando UPDATE realmente realiza dos operaciones posteriores: DELETE e INSERT.  En la versi√≥n actual de la fila, <code>xmax</code> se establece igual al ID de la transacci√≥n que realiz√≥ ACTUALIZACI√ìN.  Luego se crea una nueva versi√≥n de la misma fila, en la que el valor de <code>xmin</code> es el mismo que <code>xmax</code> de la versi√≥n anterior. <br><br>  <code>xmin</code> campos <code>xmin</code> y <code>xmax</code> se incluyen en el encabezado de una versi√≥n de fila.  Adem√°s de estos campos, el encabezado de tupla contiene otros, como: <br><br><ul><li>  <code>infomask</code> : varios bits que determinan las propiedades de una tupla dada.  Hay bastantes de ellos, y discutiremos cada uno con el tiempo. </li><li>  <code>ctid</code> : una referencia a la siguiente versi√≥n, m√°s reciente, de la misma fila.  <code>ctid</code> de la versi√≥n de fila m√°s nueva y actualizada hace referencia a esa misma versi√≥n.  El n√∫mero est√° en la forma <code>(x,y)</code> , donde <code>x</code> es el n√∫mero de la p√°gina e <code>y</code> es el n√∫mero de orden del puntero en la matriz. </li><li>  El mapa de bits NULL, que marca las columnas de una versi√≥n dada que contienen un NULL.  NULL no es un valor regular de los tipos de datos y, por lo tanto, tenemos que almacenar esta caracter√≠stica por separado. </li></ul><br>  Como resultado, el encabezado parece bastante grande: 23 bytes por cada tupla como m√≠nimo, pero generalmente m√°s grande debido al mapa de bits NULL.  Si una tabla es "estrecha" (es decir, contiene pocas columnas), los bytes superiores pueden ocupar m√°s espacio que la informaci√≥n √∫til. <br><br><h1>  Insertar </h1><br>  Veamos con m√°s detalle c√≥mo se realizan las operaciones en filas en un nivel bajo, y comenzamos con una inserci√≥n. <br><br>  Para experimentar, crearemos una nueva tabla con dos columnas y un √≠ndice en una de ellas: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> t( id <span class="hljs-type"><span class="hljs-type">serial</span></span>, s <span class="hljs-type"><span class="hljs-type">text</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> t(s);</code> </pre><br>  Comenzamos una transacci√≥n para insertar una fila. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'FOO'</span></span>);</code> </pre><br>  Esta es la identificaci√≥n de nuestra transacci√≥n actual: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3664 (1 row)</code> </pre><br>  Veamos el contenido de la p√°gina.  La funci√≥n <code>heap_page_items</code> de la extensi√≥n "pageinspect" nos permite obtener informaci√≥n sobre los punteros y las versiones de fila: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------------------- lp | 1 lp_off | 8160 lp_flags | 1 lp_len | 32 t_xmin | 3664 t_xmax | 0 t_field3 | 0 t_ctid | (0,1) t_infomask2 | 2 t_infomask | 2050 t_hoff | 24 t_bits | t_oid | t_data | \x0100000009464f4f</code> </pre><br>  Tenga en cuenta que la palabra "mont√≥n" en PostgreSQL denota tablas.  Este es un uso extra√±o m√°s de un t√©rmino: un mont√≥n es una <a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">estructura de datos</a> conocida, que no tiene nada que ver con una tabla.  Esta palabra se usa aqu√≠ en el sentido de que "todo est√° lleno", a diferencia de los √≠ndices ordenados. <br><br>  Esta funci√≥n muestra los datos "tal cual", en un formato que es dif√≠cil de comprender.  Para aclarar las cosas, dejamos solo una parte de la informaci√≥n y la interpretamos: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'(0,'</span></span>||lp||<span class="hljs-string"><span class="hljs-string">')'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ctid, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> lp_flags <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'unused'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'normal'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'redirect to '</span></span>||lp_off <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'dead'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> state, t_xmin <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> xmin, t_xmax <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> xmax, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">256</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmin_commited, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">512</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmin_aborted, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">1024</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmax_commited, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">2048</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmax_aborted, t_ctid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]-+------- ctid | (0,1) state | normal xmin | 3664 xmax | 0 xmin_commited | f xmin_aborted | f xmax_commited | f xmax_aborted | t t_ctid | (0,1)</code> </pre><br>  Hicimos lo siguiente: <br><br><ul><li>  Se agreg√≥ un cero al n√∫mero de puntero para que parezca un <code>t_ctid</code> : (n√∫mero de p√°gina, n√∫mero de puntero). </li><li>  Interpret√≥ el estado del puntero <code>lp_flags</code> .  Aqu√≠ es "normal", lo que significa que el puntero realmente hace referencia a una versi√≥n de fila.  Discutiremos otros valores m√°s adelante. </li><li>  De todos los bits de informaci√≥n, hemos seleccionado solo dos pares hasta ahora.  <code>xmin_committed</code> bits <code>xmin_committed</code> y <code>xmin_aborted</code> muestran si la transacci√≥n con el ID <code>xmin</code> est√° confirmada (revertida).  Un par de bits similares se relaciona con la transacci√≥n con el ID <code>xmax</code> . </li></ul><br>  ¬øQu√© observamos?  Cuando se inserta una fila, en la p√°gina de la tabla aparece un puntero que tiene el n√∫mero 1 y hace referencia a la primera y √∫nica versi√≥n de la fila. <br><br>  El campo <code>xmin</code> en la tupla se llena con la ID de la transacci√≥n actual.  Debido a que la transacci√≥n todav√≠a est√° activa, los bits <code>xmin_committed</code> y <code>xmin_aborted</code> est√°n sin establecer. <br><br>  El campo <code>ctid</code> de la versi√≥n de la fila hace referencia a la misma fila.  Significa que no hay una versi√≥n m√°s nueva disponible. <br><br>  El campo <code>xmax</code> se llena con el n√∫mero convencional 0 ya que la tupla no se elimina, es decir, est√° actualizada.  Las transacciones ignorar√°n este n√∫mero debido al <code>xmax_aborted</code> bits <code>xmax_aborted</code> . <br><br>  Avancemos un paso m√°s para mejorar la legibilidad agregando bits de informaci√≥n a las ID de transacciones.  Y creemos la funci√≥n ya que necesitaremos la consulta m√°s de una vez: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> heap_page(relname <span class="hljs-type"><span class="hljs-type">text</span></span>, pageno <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span>(ctid tid, state <span class="hljs-type"><span class="hljs-type">text</span></span>, xmin <span class="hljs-type"><span class="hljs-type">text</span></span>, xmax <span class="hljs-type"><span class="hljs-type">text</span></span>, t_ctid tid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> (pageno,lp)::</span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">text</span></span></span><span class="pgsql">::tid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> ctid, </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> lp_flags </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'unused'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'normal'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'redirect to '</span></span></span><span class="pgsql">||lp_off </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">3</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'dead'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> state, t_xmin || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">256</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">512</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmin, t_xmax || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1024</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2048</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmax, t_ctid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> heap_page_items(get_raw_page(relname,pageno)) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ORDER</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BY</span></span></span><span class="pgsql"> lp; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span>;</code> </pre><br>  Lo que est√° sucediendo en el encabezado de la versi√≥n de fila es mucho m√°s claro en esta forma: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3664 | 0 (a) | (0,1) (1 row)</code> </pre><br>  Podemos obtener informaci√≥n similar, pero mucho menos detallada, de la tabla en s√≠ usando <code>xmin</code> y <code>xmax</code> : <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3664 | 0 | 1 | FOO (1 row)</code> </pre><br><h1>  Comprometerse </h1><br>  Cuando una transacci√≥n es exitosa, su estado debe recordarse, es decir, la transacci√≥n debe marcarse como confirmada.  Para este fin, se utiliza la estructura XACT.  (Antes de la versi√≥n 10 se llamaba CLOG (commit log), y a√∫n es probable que encuentre este nombre). <br><br>  XACT no es una tabla del cat√°logo del sistema, sino archivos en el directorio PGDATA / pg_xact.  Se asignan dos bits en estos archivos para cada transacci√≥n, "comprometido" y "abortado", exactamente de la misma manera que en el encabezado de tupla.  Esta informaci√≥n se distribuye en varios archivos solo por conveniencia;  Volveremos a esto cuando discutamos el congelamiento.  PostgreSQL funciona con estos archivos p√°gina por p√°gina, como con todos los dem√°s. <br><br>  Entonces, cuando se confirma una transacci√≥n, el bit "comprometido" se establece para esta transacci√≥n en XACT.  Y esto es todo lo que sucede cuando se confirma la transacci√≥n (aunque todav√≠a no mencionamos el registro de escritura anticipada). <br><br>  Cuando alguna otra transacci√≥n accede a la p√°gina de la tabla que est√°bamos viendo, la primera tendr√° que responder algunas preguntas. <br><br><ol><li>  ¬ø <code>xmin</code> complet√≥ la transacci√≥n <code>xmin</code> ?  De lo contrario, la tupla creada no debe ser visible. <br>  Esto se verifica mirando a trav√©s de otra estructura, que se encuentra en la memoria compartida de la instancia y se llama ProcArray.  Esta estructura contiene una lista de todos los procesos activos, junto con el ID de la transacci√≥n actual (activa) para cada uno. </li><li>  Si la transacci√≥n se complet√≥, ¬øse confirm√≥ o se reverti√≥?  Si se hizo retroceder, la tupla tampoco debe ser visible. <br>  Esto es justo para lo que se necesita XACT.  Pero es costoso verificar XACT cada vez, aunque las √∫ltimas p√°ginas de XACT se almacenan en buffers en la memoria compartida.  Por lo tanto, una vez descubierto, el estado de la transacci√≥n se escribe en los bits <code>xmin_committed</code> y <code>xmin_aborted</code> de la tupla.  Si se establece alguno de estos bits, el estado de la transacci√≥n se trata como conocido y la pr√≥xima transacci√≥n no necesitar√° verificar XACT. </li></ol><br>  ¬øPor qu√© la transacci√≥n que realiza la inserci√≥n no establece estos bits?  Cuando se realiza una inserci√≥n, la transacci√≥n a√∫n desconoce si se completar√° con √©xito.  Y en el momento de la confirmaci√≥n ya no est√° claro qu√© filas y en qu√© p√°ginas se cambiaron.  Puede haber muchas de esas p√°ginas, y no es pr√°ctico hacer un seguimiento de ellas.  Adem√°s, algunas de las p√°ginas pueden ser expulsadas al disco de la memoria cach√© del b√∫fer;  leerlos nuevamente para cambiar los bits significar√≠a una desaceleraci√≥n significativa de la confirmaci√≥n. <br><br>  El reverso del ahorro de costos es que despu√©s de las actualizaciones, cualquier transacci√≥n (incluso la que realiza SELECT) puede comenzar a cambiar las p√°ginas de datos en la memoria cach√© del b√∫fer. <br><br>  Entonces, cometemos el cambio. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Nada ha cambiado en la p√°gina (pero sabemos que el estado de las transacciones ya est√° escrito en XACT): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3664 | 0 (a) | (0,1) (1 row)</code> </pre><br>  Ahora, una transacci√≥n que primero accede a la p√°gina necesitar√° determinar el estado de la transacci√≥n <code>xmin</code> y la escribir√° en los bits de informaci√≥n: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 1 | FOO (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3664 (c) | 0 (a) | (0,1) (1 row)</code> </pre><br><h1>  Eliminar </h1><br>  Cuando se elimina una fila, el ID de la transacci√≥n de eliminaci√≥n actual se escribe en el campo <code>xmax</code> de la versi√≥n actualizada y se restablece el bit <code>xmax_aborted</code> . <br><br>  Tenga en cuenta que el valor de <code>xmax</code> correspondiente a la transacci√≥n activa funciona como un bloqueo de fila.  Si otra transacci√≥n va a actualizar o eliminar esta fila, tendr√° que esperar hasta que se complete la transacci√≥n <code>xmax</code> .  Hablaremos sobre las cerraduras con m√°s detalle m√°s adelante.  En este punto, solo tenga en cuenta que el n√∫mero de bloqueos de fila no est√° limitado en absoluto.  No ocupan memoria, y el rendimiento del sistema no se ve afectado por ese n√∫mero.  Sin embargo, las transacciones duraderas tienen otros inconvenientes, que tambi√©n se discutir√°n m√°s adelante. <br><br>  Borremos una fila. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3665 (1 row)</code> </pre><br>  Vemos que la ID de la transacci√≥n se escribe en el campo <code>xmax</code> , pero los bits de informaci√≥n no est√°n establecidos: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+------+-------- (0,1) | normal | 3664 (c) | 3665 | (0,1) (1 row)</code> </pre><br><h1>  Abortar </h1><br>  La cancelaci√≥n de una transacci√≥n funciona de manera similar a la confirmaci√≥n, excepto que el bit "abortado" se establece en XACT.  Un aborto se realiza tan r√°pido como un commit.  Aunque el comando se llama ROLLBACK, los cambios no se revierten: todo lo que la transacci√≥n ya ha cambiado, permanece intacto. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+------+-------- (0,1) | normal | 3664 (c) | 3665 | (0,1) (1 row)</code> </pre><br>  Al acceder a la p√°gina, se comprobar√° el estado y se establecer√° el bit de sugerencia <code>xmax_aborted</code> .  Aunque el n√∫mero <code>xmax</code> s√≠ seguir√° en la p√°gina, no se ver√°. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 1 | FOO (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+----------+-------- (0,1) | normal | 3664 (c) | 3665 (a) | (0,1) (1 row)</code> </pre><br><h1>  Actualizaci√≥n </h1><br>  Una actualizaci√≥n funciona como si la versi√≥n actual se elimina primero y luego se inserta una nueva. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'BAR'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3666 (1 row)</code> </pre><br>  La consulta devuelve una fila (la nueva versi√≥n): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 1 | BAR (1 row)</code> </pre><br>  Pero podemos ver ambas versiones en la p√°gina: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3664 (c) | 3666 | (0,2) (0,2) | normal | 3666 | 0 (a) | (0,2) (2 rows)</code> </pre><br>  La versi√≥n eliminada est√° etiquetada con el ID de la transacci√≥n actual en el campo <code>xmax</code> .  Adem√°s, este valor ha sobrescrito el anterior desde que se revierte la transacci√≥n anterior.  Y el bit <code>xmax_aborted</code> se restablece ya que el estado de la transacci√≥n actual a√∫n se desconoce. <br><br>  La primera versi√≥n de la fila ahora hace referencia a la segunda, como una m√°s nueva. <br><br>  La p√°gina de √≠ndice ahora contiene el segundo puntero y la segunda fila, que hace referencia a la segunda versi√≥n en la p√°gina de la tabla. <br><br>  De la misma manera que para una eliminaci√≥n, el valor de <code>xmax</code> en la primera versi√≥n indica que la fila est√° bloqueada. <br><br>  Por √∫ltimo, comprometemos la transacci√≥n. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h1>  √çndices </h1><br>  Hasta ahora solo habl√°bamos de p√°ginas de tablas.  ¬øPero qu√© pasa dentro de los √≠ndices? <br><br>  La informaci√≥n en las p√°ginas de √≠ndice depende en gran medida del tipo de √≠ndice espec√≠fico.  Adem√°s, incluso un tipo de √≠ndices puede tener diferentes tipos de p√°ginas.  Por ejemplo: un √°rbol B tiene la p√°gina de metadatos y las p√°ginas "normales". <br><br>  Sin embargo, una p√°gina de √≠ndice generalmente tiene una matriz de punteros a las filas y a las filas mismas (al igual que las p√°ginas de la tabla).  Adem√°s, se asigna algo de espacio al final de una p√°gina para datos especiales. <br><br>  Las filas en los √≠ndices tambi√©n pueden tener diferentes estructuras seg√∫n el tipo de √≠ndice.  Por ejemplo: en un √°rbol B, las filas pertinentes a las p√°ginas de hoja contienen el valor de la clave de indexaci√≥n y una referencia ( <code>ctid</code> ) a la fila de tabla adecuada.  En general, un √≠ndice puede estructurarse de una manera bastante diferente. <br><br>  El punto principal es que en los √≠ndices de cualquier tipo no hay <em>versiones de</em> fila.  O podemos considerar que cada fila est√° representada por una sola versi√≥n.  En otras palabras, el encabezado de la fila de √≠ndice no contiene los campos <code>xmin</code> y <code>xmax</code> .  Por ahora podemos suponer que las referencias del √≠ndice apuntan a todas las versiones de las filas de la tabla.  Entonces, para determinar cu√°les de las versiones de fila son visibles para una transacci√≥n, PostgreSQL debe buscar en la tabla.  (Como de costumbre, esta no es toda la historia. A veces, el mapa de visibilidad permite optimizar el proceso, pero lo discutiremos m√°s adelante). <br><br>  Aqu√≠, en la p√°gina de √≠ndice, encontramos punteros a ambas versiones: la actualizada y la anterior: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> itemoffset, ctid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bt_page_items(<span class="hljs-string"><span class="hljs-string">'t_s_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,2) 2 | (0,1) (2 rows)</code> </pre><br><h1>  Transacciones virtuales </h1><br>  En la pr√°ctica, PostgreSQL aprovecha una optimizaci√≥n que permite gastar "con moderaci√≥n" los ID de transacci√≥n. <br><br>  Si una transacci√≥n solo lee datos, no afecta la visibilidad de la tupla en absoluto.  Por lo tanto, primero el proceso de backend asigna una ID virtual (xid virtual) a la transacci√≥n.  Esta identificaci√≥n consta del identificador de proceso y un n√∫mero secuencial. <br><br>  La asignaci√≥n de esta ID virtual no requiere sincronizaci√≥n entre todos los procesos y, por lo tanto, se realiza muy r√°pidamente.  Aprenderemos otra raz√≥n para usar ID virtuales cuando hablemos sobre la congelaci√≥n. <br><br>  Las instant√°neas de datos no tienen en cuenta la identificaci√≥n virtual en absoluto. <br><br>  En diferentes momentos, el sistema puede tener transacciones virtuales con ID que ya se usaron, y esto est√° bien.  Pero esta ID no se puede escribir en las p√°ginas de datos, ya que cuando se accede a la p√°gina la pr√≥xima vez, la ID puede dejar de tener sentido. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current_if_assigned();</code> </pre><pre> <code class="plaintext hljs"> txid_current_if_assigned -------------------------- (1 row)</code> </pre><br>  Pero si una transacci√≥n comienza a cambiar datos, recibe una identificaci√≥n de transacci√≥n verdadera y √∫nica. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">1.00</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current_if_assigned();</code> </pre><pre> <code class="plaintext hljs"> txid_current_if_assigned -------------------------- 3667 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h1>  Subtransacciones </h1><br><h2>  Guardar puntos </h2><br>  En SQL, se definen los <em>puntos de guardado</em> , que permiten revertir algunas operaciones de la transacci√≥n sin su aborto completo.  Pero esto es incompatible con el modelo anterior ya que el estado de la transacci√≥n es uno para todos los cambios y no se revierten f√≠sicamente los datos. <br><br>  Para implementar esta funcionalidad, una transacci√≥n con un punto de rescate se divide en varias <em>subtransacciones</em> separadas cuyos estados se pueden administrar por separado. <br><br>  Las subtransacciones tienen sus propios ID (mayores que el ID de la transacci√≥n principal).  Los estados de las subtransacciones se escriben en XACT de la manera habitual, pero el estado final depende del estado de la transacci√≥n principal: si se revierte, todas las subtransacciones tambi√©n se revierten. <br><br>  La informaci√≥n sobre el anidamiento de subtransacciones se almacena en archivos del directorio PGDATA / pg_subtrans.  Se accede a estos archivos mediante buffers en la memoria compartida de la instancia, que est√°n estructurados de la misma manera que los buffers XACT. <br><br>  No confunda las subtransacciones con transacciones aut√≥nomas.  Las transacciones aut√≥nomas de ninguna manera dependen unas de otras, mientras que las subtransacciones s√≠ dependen.  No hay transacciones aut√≥nomas en el PostgreSQL regular, lo cual es, quiz√°s, para mejor: en realidad se necesitan extremadamente raramente, y su disponibilidad en otros DBMS invita al abuso, que todos sufren. <br><br>  Vamos a limpiar la tabla, comenzar una transacci√≥n e insertar una fila: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> t; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'FOO'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3669 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (1 row)</code> </pre><br>  Ahora establecemos un punto de guardado e insertamos otra fila. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SAVEPOINT</span></span> sp; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'XYZ'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3669 (1 row)</code> </pre><br>  Tenga en cuenta que la funci√≥n <code>txid_current</code> devuelve el ID de la transacci√≥n principal en lugar de la subtransacci√≥n. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3670 | 0 | 3 | XYZ (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (0,2) | normal | 3670 | 0 (a) | (0,2) (2 rows)</code> </pre><br>  Retrocedamos al punto de guardado e insertemos la tercera fila. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> sp; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'BAR'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3671 | 0 | 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 | 0 (a) | (0,3) (3 rows)</code> </pre><br>  En la p√°gina, seguimos viendo la fila que agreg√≥ la subtransacci√≥n revertida. <br><br>  Cometer los cambios. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3671 | 0 | 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 (c) | 0 (a) | (0,1) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 (c) | 0 (a) | (0,3) (3 rows)</code> </pre><br>  Ahora se ve claramente que cada subtransacci√≥n tiene su propio estado. <br><br>  Tenga en cuenta que SQL no permite el uso expl√≠cito de subtransacciones, es decir, no puede iniciar una nueva transacci√≥n antes de completar la actual.  Esta t√©cnica se involucra impl√≠citamente cuando se usan puntos de guardado y tambi√©n cuando se manejan excepciones PL / pgSQL, as√≠ como en otras situaciones m√°s ex√≥ticas. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>;</code> </pre><pre> <code class="plaintext hljs">BEGIN</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>;</code> </pre><pre> <code class="plaintext hljs">WARNING: there is already a transaction in progress BEGIN</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">COMMIT</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">WARNING: there is no transaction in progress COMMIT</code> </pre><br><h2>  Errores y atomicidad de operaci√≥n </h2><br>  ¬øQu√© sucede si se produce un error mientras se realiza la operaci√≥n?  Por ejemplo, as√≠: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = repeat(<span class="hljs-string"><span class="hljs-string">'X'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>/(id<span class="hljs-number"><span class="hljs-number">-4</span></span>));</code> </pre><pre> <code class="plaintext hljs">ERROR: division by zero</code> </pre><br>  Se produjo un error  Ahora la transacci√≥n se trata como abortada y no se permiten operaciones en ella: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs">ERROR: current transaction is aborted, commands ignored until end of transaction block</code> </pre><br>  E incluso si tratamos de confirmar los cambios, PostgreSQL informar√° la reversi√≥n: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">ROLLBACK</code> </pre><br>  ¬øPor qu√© es imposible continuar la ejecuci√≥n de la transacci√≥n despu√©s de una falla?  La cuesti√≥n es que el error podr√≠a ocurrir para que tengamos acceso a parte de los cambios, es decir, la atomicidad se romper√≠a no solo para la transacci√≥n, sino incluso para un solo operador.  Por ejemplo, en nuestro ejemplo, el operador podr√≠a haber actualizado una fila antes de que ocurriera el error: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 (c) | 3672 | (0,4) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 (c) | 0 (a) | (0,3) (0,4) | normal | 3672 | 0 (a) | (0,4) (4 rows)</code> </pre><br>  Vale la pena se√±alar que psql tiene un modo que permite continuar la transacci√≥n despu√©s de la falla, como si los efectos del operador err√≥neo fueran revertidos. <br><br><pre> <code class="pgsql hljs">=&gt; \<span class="hljs-keyword"><span class="hljs-keyword">set</span></span> ON_ERROR_ROLLBACK <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = repeat(<span class="hljs-string"><span class="hljs-string">'X'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>/(id<span class="hljs-number"><span class="hljs-number">-4</span></span>));</code> </pre><pre> <code class="plaintext hljs">ERROR: division by zero</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Es f√°cil darse cuenta de que en este modo, psql en realidad establece un punto de guardado impl√≠cito antes de cada comando e inicia un retroceso en caso de falla.  Este modo no se usa de manera predeterminada, ya que establecer puntos de guardado (incluso sin una reversi√≥n a ellos) conlleva una sobrecarga significativa. <br><br>  <a href="https://habr.com/ru/company/postgrespro/blog/479512/">Sigue leyendo</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/477648/">https://habr.com/ru/post/477648/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../477634/index.html">Microservicios y estructura organizacional. ¬øQu√© tipos de equipos asegurar√°n el √©xito?</a></li>
<li><a href="../477638/index.html">Bought! = Yours: John Deere le roba a los agricultores el derecho a reparar sus propios tractores</a></li>
<li><a href="../477642/index.html">La visi√≥n de la m√°quina (radio) ve a trav√©s de las paredes.</a></li>
<li><a href="../477644/index.html">Restauraci√≥n de UNIX v0 a PDP-7: detalles de la trastienda</a></li>
<li><a href="../477646/index.html">Los matem√°ticos cortan formas en busca de partes de ecuaciones</a></li>
<li><a href="../477650/index.html">Cifrado del tr√°fico TLS seg√∫n los algoritmos GOST-2012 con Stunnel</a></li>
<li><a href="../477654/index.html">Probar el operador mejorado instanceof en Java 14</a></li>
<li><a href="../477656/index.html">A√∫n as√≠, ¬øpor qu√© necesitas hacer?</a></li>
<li><a href="../477658/index.html">Restauraci√≥n activa: ¬øpuede la recuperaci√≥n ante desastres ser m√°s r√°pida? Mucho mas rapido?</a></li>
<li><a href="../477662/index.html">Acceso a neum√°ticos Redd en puentes FTDI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>