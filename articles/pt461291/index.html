<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëàüèº üçÉ ü§µüèº Golang: problemas espec√≠ficos de desempenho üî¨ üë®üèΩ‚Äçüé® ‚ö∞Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O idioma Go est√° ganhando popularidade. T√£o confiante que h√° cada vez mais confer√™ncias, por exemplo, GolangConf , e o idioma est√° entre as dez tecnol...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Golang: problemas espec√≠ficos de desempenho</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/461291/">  O idioma Go est√° ganhando popularidade.  T√£o confiante que h√° cada vez mais confer√™ncias, por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GolangConf</a> , e o idioma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">est√° entre as dez</a> tecnologias mais bem pagas.  Portanto, j√° faz sentido falar sobre seus problemas espec√≠ficos, por exemplo, desempenho.  Al√©m de problemas comuns para todos os idiomas compilados, o Go tem seus pr√≥prios.  Eles est√£o associados ao otimizador, pilha, sistema de tipos e modelo de multitarefa.  Maneiras de resolv√™-los e solu√ß√µes alternativas √†s vezes s√£o muito espec√≠ficas. <br><br>  <strong>Daniel Podolsky</strong> , embora o evangelista de Go, tamb√©m encontre muitas coisas estranhas nele.  Tudo estranho e, mais importante, interessante, coleta e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">testa</a> e depois fala sobre isso no HighLoad ++.  A transcri√ß√£o do relat√≥rio incluir√° n√∫meros, gr√°ficos, exemplos de c√≥digo, resultados de cria√ß√£o de perfil, uma compara√ß√£o do desempenho dos mesmos algoritmos em diferentes idiomas - e tudo mais, para o qual odiamos a palavra "otimiza√ß√£o".  N√£o haver√° revela√ß√µes na transcri√ß√£o - de onde elas vieram em uma linguagem t√£o simples - e tudo o que pode ser lido nos jornais. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/8UESXMJwTpc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><br>  <strong>Sobre os alto-falantes.</strong>  <b>Daniil Podolsky</b> : 26 anos de experi√™ncia, 20 em opera√ß√£o, incluindo o l√≠der do grupo, 5 anos de programa√ß√£o no Go.  <b>Kirill Danshin</b> : criador do Gramework, Mantenedor, HTTP R√°pido, Black Go-mage. <br><br>  <em>O relat√≥rio foi preparado em conjunto por Daniel Podolsky e Kirill Danshin, mas Daniel fez um relat√≥rio, e Kirill ajudou mentalmente.</em> <br><br><h2>  Constru√ß√µes lingu√≠sticas </h2><br>  Temos um padr√£o de desempenho - <code>direct</code> .  Essa √© uma fun√ß√£o que incrementa uma vari√°vel e n√£o faz mais nada. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//   var testInt64 int64 func BenchmarkDirect(b *testing.B) { for i := 0; i &lt; bN; i++ { incDirect() } } func incDirect() { testInt64++ }</span></span></code> </pre> <br>  O resultado da fun√ß√£o √© <b>1,46 ns por opera√ß√£o</b> .  Esta √© a op√ß√£o m√≠nima.  Mais r√°pido que 1,5 ns por opera√ß√£o, provavelmente n√£o funcionar√°. <br><br><h3>  Adie como o amamos </h3><br>  Muitos sabem e gostam de usar a constru√ß√£o de adiamento da linguagem.  Muitas vezes usamos assim. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkDefer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { incDefer() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incDefer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> incDirect() }</code> </pre> <br>  Mas voc√™ n√£o pode us√°-lo assim!  Cada adiado come 40 ns por opera√ß√£o. <br><br><pre> <code class="plaintext hljs">//   BenchmarkDirect-4 2000000000 1.46 / // defer BenchmarkDefer-4 30000000 40.70 /</code> </pre> <br>  Eu pensei que talvez isso seja por causa de inline?  Talvez o inline seja t√£o r√°pido? <br><br>  Direto est√° embutido e a fun√ß√£o de adiamento n√£o pode embutir.  Portanto, compilou uma fun√ß√£o de teste separada sem embutir. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkDirectNoInline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { incDirectNoInline() } } <span class="hljs-comment"><span class="hljs-comment">//go:noinline func incDirectNoInline() { testInt64++ }</span></span></code> </pre> <br>  Nada mudou, o adiamento levou os mesmos 40 ns.  Adie querido, mas n√£o catastr√≥fico. <br><br><blockquote>  Onde uma fun√ß√£o leva menos de 100 ns, voc√™ pode fazer isso sem adiar. </blockquote><br>  Mas onde a fun√ß√£o leva mais de um microssegundo, √© tudo a mesma coisa - voc√™ pode usar o adiamento. <br><br><h3>  Passando um par√¢metro por refer√™ncia </h3><br>  Considere um mito popular. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkDirectByPointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { incDirectByPointer(&amp;testInt64) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incDirectByPointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { *n++ }</code> </pre> <br>  Nada mudou - nada vale a pena. <br><br><pre> <code class="plaintext hljs">//     BenchmarkDirectByPointer-4 2000000000 1.47 / BenchmarkDeferByPointer-4 30000000 43.90 /</code> </pre> <br>  Exceto 3 ns por adiamento, mas isso √© baixado para flutua√ß√µes. <br><br><h3>  Fun√ß√µes an√¥nimas </h3><br>  √Äs vezes, os novatos perguntam: "Uma fun√ß√£o an√¥nima √© cara?" <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkDirectAnonymous</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { testInt64++ }() } }</code> </pre> <br><blockquote>  Uma fun√ß√£o an√¥nima n√£o √© cara, s√£o necess√°rios 40,4 ns. </blockquote><br><h3>  Interfaces </h3><br>  Existe uma interface e estrutura que a implementa. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> testTypeInterface <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Inc() } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> testTypeStruct <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { n <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *testTypeStruct)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Inc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { s.n++ }</code> </pre> <br>  Existem tr√™s op√ß√µes para usar o m√©todo de incremento.  Diretamente do Struct: <code>var testStruct = testTypeStruct{}</code> . <br><br>  Na interface concreta correspondente: <code>var testInterface testTypeInterface = &amp;testStruct</code> . <br><br>  Com a convers√£o da interface de tempo de execu√ß√£o: <code>var testInterfaceEmpty interface{} = &amp;testStruct</code> . <br><br>  Abaixo est√° a convers√£o e o uso da interface de tempo de execu√ß√£o diretamente. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkInterface</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { testInterface.Inc() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkInterfaceRuntime</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { testInterfaceEmpty.(testTypeInterface).Inc() } }</code> </pre> <br><blockquote>  A interface, como tal, n√£o custa nada. </blockquote><br><pre> <code class="plaintext hljs">//  BenchmarkStruct-4 2000000000 1.44 / BenchmarkInterface-4 2000000000 1.88 / BenchmarkInterfaceRuntime-4 200000000 9.23 /</code> </pre> <br><br>  A convers√£o da interface em tempo de execu√ß√£o vale a pena, mas n√£o √© cara - voc√™ n√£o precisa se recusar especificamente.  Mas tente ficar sem ele sempre que poss√≠vel. <br><br>  <b>Mitos:</b> <br><br><ul><li>  Desrefer√™ncia - ponteiros de refer√™ncia - gr√°tis. </li><li>  Recursos an√¥nimos s√£o gratuitos. </li><li>  As interfaces s√£o gratuitas. </li><li>  Convers√£o da interface de tempo de execu√ß√£o - N√ÉO √â GRATUITA. </li></ul><br><h3>  Mudar, mapear e cortar </h3><br>  Todo iniciante no Go pergunta o que acontece se voc√™ substituir o switch pelo mapa.  Ser√° mais r√°pido? <br><br>  O interruptor vem em tamanhos diferentes.  Testei em tr√™s tamanhos: pequeno para 10 casos, m√©dio para 100 e grande para 1000 casos.  O switch para 1000 casos √© encontrado no c√≥digo de produ√ß√£o real.  Claro, ningu√©m os escreve com as m√£os.  Este √© um c√≥digo gerado automaticamente, geralmente uma op√ß√£o de tipo.  Testado em dois tipos: int e string.  Parecia que ficaria mais claro. <br><br>  <strong>Pequeno interruptor.</strong>  A op√ß√£o mais r√°pida √© a troca real.  A seguir, ele passa imediatamente a fatia, onde o √≠ndice inteiro correspondente cont√©m uma refer√™ncia √† fun√ß√£o.  O mapa n√£o √© um l√≠der em int ou string. <br><div class="scrollable-table"><table><tbody><tr><td>  BenchmarkSwitchIntSmall-4 </td><td>  500000000 </td><td>  3,26 ns / op </td></tr><tr><td>  BenchmarkMapIntSmall-4 </td><td>  100.000.000 </td><td>  11,70 ns / op </td></tr><tr><td>  BenchmarkSliceIntSmall-4 </td><td>  500000000 </td><td>  3,85 ns / op </td></tr><tr><td>  BenchmarkSwitchStringSmall-4 </td><td>  100.000.000 </td><td>  12,70 ns / op </td></tr><tr><td>  BenchmarkMapStringSmall-4 </td><td>  100.000.000 </td><td>  15,60 ns / op </td></tr></tbody></table></div><br>  Ativar strings √© significativamente mais lento que no int.  Se voc√™ pode mudar n√£o para string, mas para int, fa√ßa-o. <br><br>  <strong>Interruptor do meio.</strong>  O pr√≥prio switch ainda governa int, mas o fatia ultrapassou um pouco.  O mapa ainda est√° ruim.  Mas em uma chave de cadeia, o mapa √© mais r√°pido que o switch - como esperado. <br><div class="scrollable-table"><table><tbody><tr><td>  BenchmarkSwitchIntMedium-4 </td><td>  300000000 </td><td>  4,55 ns / op </td></tr><tr><td>  BenchmarkMapIntMedium-4 </td><td>  100.000.000 </td><td>  17,10 ns / op </td></tr><tr><td>  BenchmarkSliceIntMedium-4 </td><td>  300000000 </td><td>  3,76 ns / op </td></tr><tr><td>  BenchmarkSwitchStringMedium-4 </td><td>  50.000.000 </td><td>  28,50 ns / op </td></tr><tr><td>  BenchmarkMapStringMedium-4 </td><td>  100.000.000 </td><td>  20,30 ns / op </td></tr></tbody></table></div><br>  <strong>Grande mudan√ßa.</strong>  Mil casos mostram a vit√≥ria incondicional do mapa na nomea√ß√£o "alternar por sequ√™ncia".  Teoricamente, a fatia ganhou, mas na pr√°tica eu aconselho voc√™ a usar a mesma op√ß√£o aqui.  O mapa ainda √© lento, mesmo considerando que o mapa possui chaves inteiras com uma fun√ß√£o de hash especial.  Em geral, essa fun√ß√£o n√£o faz nada.  O pr√≥prio int tem um hash para int. <br><div class="scrollable-table"><table><tbody><tr><td>  BenchmarkSwitchIntLarge-4 </td><td>  100.000.000 </td><td>  13,6 ns / op </td></tr><tr><td>  BenchmarkMapIntLarge-4 </td><td>  50.000.000 </td><td>  34,3 ns / op </td></tr><tr><td>  BenchmarkSliceIntLarge-4 </td><td>  100.000.000 </td><td>  12,8 ns / op </td></tr><tr><td>  BenchmarkSwitchStringLarge-4 </td><td>  20.000.000 </td><td>  100,0 ns / op </td></tr><tr><td>  BenchmarkMapStringLarge-4 </td><td>  30000000 </td><td>  37,4 ns / op </td></tr></tbody></table></div><br>  <strong>Conclus√µes</strong>  O mapa √© melhor apenas em grandes quantidades e n√£o em uma condi√ß√£o inteira.  Estou certo de que em qualquer uma das condi√ß√µes, exceto int, ele se comportar√° da mesma maneira que na string.  A fatia sempre orienta quando as condi√ß√µes s√£o inteiras.  Use-o se voc√™ quiser "acelerar" o seu programa em 2 ns. <br><br><h2>  Intera√ß√£o inter-rotineira </h2><br>  O t√≥pico √© complexo, realizei muitos testes e apresentarei os mais reveladores.  Conhecemos os seguintes <strong>meios de intera√ß√£o interag√™ncias</strong> . <br><br><ul><li>  Atomic  Esses s√£o meios de aplicabilidade limitada - voc√™ pode substituir o ponteiro ou usar int. </li><li>  O Mutex tem sido amplamente utilizado desde o Java. </li><li>  O canal √© exclusivo para GO. </li><li>  Canal em buffer - canais em buffer. </li></ul><br>  Obviamente, testei em um n√∫mero significativamente maior de goroutines que competem por um recurso.  Mas ele escolheu tr√™s para si como indicativo: um pouco - 100, um meio - 1000 e muito - 10000. <br><br>  <strong>O perfil de carregamento √© diferente</strong> .  √Äs vezes, todos os gorutins querem escrever em uma vari√°vel, mas isso √© raro.  Geralmente, afinal, alguns escrevem, outros leem.  Da maioria dos leitores - 90% l√™, daqueles que escrevem - 90% escrevem. <br><br>  Este √© o c√≥digo usado para que a goroutine que serve o canal possa fornecer tanto a leitura quanto a grava√ß√£o de uma vari√°vel. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> n, ok := &lt;-cw: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { wgc.Done() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } testInt64 += n <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> cr &lt;- testInt64: } } }()</code> </pre> <br>  Se uma mensagem chega at√© n√≥s atrav√©s do canal atrav√©s do qual escrevemos, n√≥s a executamos.  Se o canal estiver fechado, terminamos a goroutin.  A qualquer momento, estamos prontos para gravar no canal usado por outras goroutines para leitura. <br><div class="scrollable-table"><table><tbody><tr><td>  Benchmarkmutex-4 </td><td>  100.000.000 </td><td>  16,30 ns / op </td></tr><tr><td>  Benchmarkatomic-4 </td><td>  200000000 </td><td>  6,72 ns / op </td></tr><tr><td>  Benchmarkcan-4 </td><td>  5.000.000 </td><td>  239,00 ns / op </td></tr></tbody></table></div><br>  Estes s√£o dados para uma goroutine.  O teste do canal √© realizado em duas goroutines: uma processa o canal e a outra grava nesse canal.  E essas op√ß√µes foram testadas em um. <br><br><ul><li>  Grava√ß√µes diretas em uma vari√°vel. </li><li>  O Mutex pega um log, grava em uma vari√°vel e libera um log. </li><li>  O Atomic grava em uma vari√°vel atrav√©s do Atomic.  N√£o √© gratuito, mas ainda significativamente mais barato que o Mutex em um garutin. </li></ul><br>  Com uma pequena quantidade de goroutine, o Atomic √© uma maneira r√°pida e eficaz de sincronizar, o que n√£o √© surpreendente.  O Direct n√£o est√° aqui, porque precisamos de sincroniza√ß√£o, que ele n√£o fornece.  Mas Atomic tem falhas, √© claro. <br><div class="scrollable-table"><table><tbody><tr><td>  BenchmarkMutexFew-4 </td><td>  30000 </td><td>  55894 ns / op </td></tr><tr><td>  BenchmarkAtomicFew-4 </td><td>  100.000 </td><td>  14585 ns / op </td></tr><tr><td>  BenchmarkChanFew-4 </td><td>  5000 </td><td>  323859 ns / op </td></tr><tr><td>  BenchmarkChanBufferedFew-4 </td><td>  5000 </td><td>  341321 ns / op </td></tr><tr><td>  BenchmarkChanBufferedFullFew-4 </td><td>  20000 </td><td>  70052 ns / op </td></tr><tr><td>  BenchmarkMutexMostlyReadFew-4 </td><td>  30000 </td><td>  56402 ns / op </td></tr><tr><td>  BenchmarkAtomicMostlyReadFew-4 </td><td>  1.000.000 </td><td>  2094 ns / op </td></tr><tr><td>  BenchmarkChanMostlyReadFew-4 </td><td>  3000 </td><td>  442689 ns / op </td></tr><tr><td>  BenchmarkChanBufferedMostlyReadFew-4 </td><td>  3000 </td><td>  449.666 ns / op </td></tr><tr><td>  BenchmarkChanBufferedFullMostlyReadFew-4 </td><td>  5000 </td><td>  442.708 ns / op </td></tr><tr><td>  BenchmarkMutexMostlyWriteFew-4 </td><td>  20000 </td><td>  79708 ns / op </td></tr><tr><td>  BenchmarkAtomicMostlyWriteFew-4 </td><td>  100.000 </td><td>  13358 ns / op </td></tr><tr><td>  BenchmarkChanMostlyWriteFew-4 </td><td>  3000 </td><td>  449.556 ns / op </td></tr><tr><td>  BenchmarkChanBufferedMostlyWriteFew-4 </td><td>  3000 </td><td>  445423 ns / op </td></tr><tr><td>  BenchmarkChanBufferedFullMostlyWriteFew-4 </td><td>  3000 </td><td>  414626 ns / op </td></tr></tbody></table></div><br>  O pr√≥ximo √© Mutex.  Eu esperava que o Channel fosse t√£o r√°pido quanto o Mutex, mas n√£o. <br><br><blockquote>  Canal √© uma ordem de magnitude mais cara que o Mutex. </blockquote><br>  Al√©m disso, o canal e o canal tamponado s√£o vendidos pelo mesmo pre√ßo.  E existe o canal, no qual o buffer nunca transborda.  √â uma ordem de magnitude mais barata do que aquela cujo buffer transborda.  Somente se o buffer no Canal n√£o estiver cheio, ele custar√° o mesmo em ordens de grandeza que o Mutex.  Isso √© o que eu esperava do teste. <br><br>  Essa imagem com a distribui√ß√£o de quanto custa √© repetida em qualquer perfil de carga - tanto no MostlyRead quanto no MostlyWrite.  Al√©m disso, o canal MostlyRead completo custa o mesmo que o incompleto.  E o canal em buffer do MostlyWrite, no qual o buffer n√£o est√° cheio, custa o mesmo que o restante.  N√£o sei dizer por que isso acontece - ainda n√£o estudei esse problema. <br><br><h2>  Passando par√¢metros </h2><br>  <strong>Como passar par√¢metros mais rapidamente - por refer√™ncia ou por valor?</strong>  Vamos conferir. <br><br>  Eu verifiquei da seguinte maneira - fiz tipos aninhados de 1 a 10. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TP001 <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { I001 <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TV002 <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { I001 <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> S001 TV001 I002 <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> S002 TV001 }</code> </pre> <br>  O d√©cimo tipo aninhado ter√° 10 campos int64 e os tipos aninhados do aninhamento anterior tamb√©m ser√£o 10. <br><br>  Em seguida, ele escreveu fun√ß√µes que criam um tipo de aninhamento. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewTP001</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TP001</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;TP001{ I001: rand.Int63(), } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewTV002</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TV002</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TV002{ I001: rand.Int63(), S001: NewTV001(), I002: rand.Int63(), S002: NewTV001(), } }</code> </pre> <br>  Para o teste, usei tr√™s op√ß√µes do tipo: pequeno com aninhamento 2, m√©dio com aninhamento 3, grande com aninhamento 5. Eu tive que fazer um teste muito grande com aninhamento 10 √† noite, mas a imagem √© exatamente a mesma de 5. <br><br>  <b>Nas fun√ß√µes, a passagem por valor √© pelo menos duas vezes mais r√°pida que a passagem por refer√™ncia</b> .  Isso se deve ao fato de que a passagem por valor n√£o carrega a an√°lise de escape.  Assim, as vari√°veis ‚Äã‚Äãque alocamos est√£o na pilha.  √â substancialmente mais barato para o tempo de execu√ß√£o, para o coletor de lixo.  Embora ele possa n√£o ter tempo para se conectar.  Esses testes continuaram por alguns segundos - o coletor de lixo provavelmente ainda estava dormindo. <br><div class="scrollable-table"><table><tbody><tr><td>  BenchmarkCreateSmallByValue-4 </td><td>  200.000 </td><td>  8942 ns / op </td></tr><tr><td>  BenchmarkCreateSmallByPointer-4 </td><td>  100.000 </td><td>  15985 ns / op </td></tr><tr><td>  BenchmarkCreateMediuMByValue-4 </td><td>  2000 </td><td>  862317 ns / op </td></tr><tr><td>  BenchmarkCreateMediuMByPointer-4 </td><td>  2000 </td><td>  1228130 ns / op </td></tr><tr><td>  BenchmarkCreateLargeByValue-4 </td><td>  30 </td><td>  47398456 ns / op </td></tr><tr><td>  BenchmarkCreateLargeByPointer-4 </td><td>  20 </td><td>  61928751 ns / op </td></tr></tbody></table></div><br><h2>  Magia negra </h2><br>  Voc√™ sabe o que esse programa produzir√°? <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> A <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { a, b <span class="hljs-keyword"><span class="hljs-keyword">int32</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { a := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(A) aa = <span class="hljs-number"><span class="hljs-number">0</span></span> ab = <span class="hljs-number"><span class="hljs-number">1</span></span> z := (*(*<span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>)(unsafe.Pointer(a))) fmt.Println(z) }</code> </pre> <br>  O resultado do programa depende da arquitetura em que √© executado.  No little endian, por exemplo, AMD64, o programa exibe <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>32</mn></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.039ex" height="2.419ex" viewBox="0 -935.7 1308.3 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/company/oleg-bunin/blog/461291/&amp;usg=ALkJrhhVpsgAeAMRBSgek_C_SFYeUhiNpg#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,393)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/company/oleg-bunin/blog/461291/&amp;usg=ALkJrhhVpsgAeAMRBSgek_C_SFYeUhiNpg#MJMAIN-33"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/company/oleg-bunin/blog/461291/&amp;usg=ALkJrhhVpsgAeAMRBSgek_C_SFYeUhiNpg#MJMAIN-32" x="500" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mn>32</mn></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-1"> 2 ^ {32} </script>  .  No big endian, um.  O resultado √© diferente, porque no little endian essa unidade aparece no meio do n√∫mero e no big endian - no final. <br><br>  Ainda existem processadores no mundo em que switches endian, por exemplo, Power PC.  Ser√° necess√°rio descobrir qual endian est√° configurado no seu computador na inicializa√ß√£o, antes de fazer infer√™ncias sobre o que fazem truques inseguros desse tipo.  Por exemplo, se voc√™ escrever um c√≥digo Go que ser√° executado em algum servidor multiprocessador IBM. <br><br>  Eu citei este c√≥digo para explicar por que considero toda a magia negra insegura.  Voc√™ n√£o precisa us√°-lo.  Mas Cyril acredita que √© necess√°rio.  E aqui est√° o porqu√™. <br><br>  Existe uma fun√ß√£o que faz a mesma coisa que GOB - Go Binary Marshaller.  Este √© o codificador, mas n√£o √© seguro. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encodeMut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(res []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { sz := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(data) * <span class="hljs-number"><span class="hljs-number">8</span></span> dh := (*header)(unsafe.Pointer(&amp;data)) rh := &amp;header{ data: dh.data, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>: sz, <span class="hljs-built_in"><span class="hljs-built_in">cap</span></span>: sz, } res = *(*[]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(unsafe.Pointer(&amp;rh)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }</code> </pre> <br>  De fato, √© preciso um peda√ßo de mem√≥ria e extrai uma matriz de bytes dele. <br><br>  Isso nem √© um pedido - esses s√£o dois pedidos.  Portanto, Cyril Danshin, quando escreve um c√≥digo de alto desempenho, n√£o hesita em entrar no √¢mago de seu programa e torn√°-lo inseguro. <br><br><div class="scrollable-table"><table><tbody><tr><td>  Refer√™ncia gob-4 </td><td>  200.000 </td><td>  8466 ns / op </td><td>  120,94 MB / s </td></tr><tr><td>  Refer√™ncia: UnsafeMut-4 </td><td>  50.000.000 </td><td>  37 ns / op </td><td>  27691.06 MB / s </td></tr></tbody></table></div><blockquote>  Discutiremos recursos mais espec√≠ficos do Go em 7 de outubro no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GolangConf</a> - uma confer√™ncia para aqueles que usam o Go no desenvolvimento profissional e aqueles que consideram esse idioma como uma alternativa.  Daniil Podolsky √© apenas um membro do Comit√™ de Programa, se voc√™ quiser discutir com este artigo ou revelar quest√µes relacionadas - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">envie uma inscri√ß√£o</a> para um relat√≥rio. <br><br>  Para todo o resto, em rela√ß√£o ao alto desempenho, √© claro, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HighLoad ++</a> .  Tamb√©m aceitamos inscri√ß√µes l√°.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Assine</a> a newsletter e fique por dentro das novidades de todas as nossas confer√™ncias para desenvolvedores da web. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt461291/">https://habr.com/ru/post/pt461291/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt461281/index.html">Passo a passo para configurar um servidor DNS BIND em um ambiente chroot para Red Hat (RHEL / CentOS) 7</a></li>
<li><a href="../pt461283/index.html">Arquitetura de software e design de sistemas: guia geral e recursos</a></li>
<li><a href="../pt461285/index.html">5 principais algoritmos de amostragem</a></li>
<li><a href="../pt461287/index.html">Desenvolvendo uma intelig√™ncia artificial astuta em um jogo t√°tico baseado em heur√≠sticas e muta√ß√µes</a></li>
<li><a href="../pt461289/index.html">Lan√ßamento do CLion 2019.2: suporte ao desenvolvimento incorporado, depurador para MSVC, pesquisa por arquivos de cabe√ßalho n√£o utilizados</a></li>
<li><a href="../pt461297/index.html">Como s√£o os ataques direcionados modernos</a></li>
<li><a href="../pt461299/index.html">Como o PC conquistou a ind√∫stria da m√≠dia com software de sucesso: discutindo o Pro Tools e o Media Composer</a></li>
<li><a href="../pt461303/index.html">Usando o cart√£o Troika como uma ap√≥lice de seguro m√©dico obrigat√≥ria</a></li>
<li><a href="../pt461305/index.html">Rede da empresa e MitM. Parte 2</a></li>
<li><a href="../pt461307/index.html">Convidamos voc√™ para o VK Hackathon 2019. O pr√™mio total deste ano √© de dois milh√µes de rublos.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>