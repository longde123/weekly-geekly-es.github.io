<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🎤 🍳 👝 Régua do CCD: o que é comido 👷🏻 💒 👨🏾‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Neste artigo, quero apresentar minha experiência no uso de um fotodetector CCD linear. Essa linha de CCD pode ser usada no design de um espectrômetro ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Régua do CCD: o que é comido</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457762/"><img src="https://habrastorage.org/webt/6f/ss/-0/6fss-0mg8davzerthbljhhg9ora.jpeg"><br>  Neste artigo, quero apresentar minha experiência no uso de um fotodetector CCD linear.  Essa linha de CCD pode ser usada no design de um espectrômetro improvisado, leitor de código de barras, sensor de posição ou desvio do feixe de laser, scanner de foto ou filme e muito mais.  No meu caso, era um scanner a laser, que não consigo descrever na rede. <br><a name="habracut"></a><br>  <b>O que é um dispositivo com carga acoplada?</b> <br><br>  Na maioria das vezes, quando se fala em CCD, eles significam vários fotodetectores.  Menos comumente, são dispositivos de memória: registradores de deslocamento, linhas de atraso.  Na sua essência, esse dispositivo lembra um pouco a memória em domínios magnéticos cilíndricos, apenas em silício - com a ajuda de uma onda itinerante de um campo elétrico criado por um sistema de eletrodos, aglomerados de portadores de carga que de alguma forma se formaram nele de alguma forma se movem anteriormente pelo semicondutor.  Assim, obtemos um registro de turno que possui uma estrutura extremamente simples e é capaz de memorizar não apenas uma sequência de unidades digitais e zeros, mas também um sinal analógico. <br><div style="text-align:center;"><img width="50%" src="https://habrastorage.org/webt/at/dl/gv/atdlgvfbnsok-t_geekshblchyo.gif"></div><br>  Nos receptores de imagem CCD, é precisamente essa capacidade dessa estrutura que é usada para emitir sequencialmente as cargas acumuladas sob cada um dos pixels da estrutura.  Além disso, o mesmo sistema de porta usado para mover as cargas durante a exposição cria poços potenciais nos quais essas cargas se acumulam (ou esses orifícios são criados durante a formação da estrutura - semelhante aos canais internos e induzidos do transistor MOS).  Estruturas mais complexas incluem um portão resistivo ao longo do qual uma inclinação de potencial suave é formada (é assim que as linhas do CCD Hamamatsu S11155 são organizadas), bem como a separação das zonas de acumulação de carga e transferência de carga - as cargas acumuladas de toda a linha são primeiro transferidas para a linha de buffer e depois posteriormente avançadas saia ao longo da última. <br>  A simplicidade da estrutura interna se traduz na complexidade de gerenciá-la.  Mesmo a versão mais simples da linha CCD requer a geração de um sinal bifásico ou trifásico de forma complexa com diferentes níveis de tensão com arestas íngremes (com uma alta capacitância de entrada de 1000 pF ou mais), deslocadas uma em relação à outra.  As réguas do tipo Hamamatsu S11155 requerem até oito sinais diferentes com diferentes níveis de alta e baixa tensão nos dois lados do zero. <br>  Felizmente, algumas empresas (por exemplo, a Sony) lançaram uma linha na qual toda essa complexidade é formada diretamente no chip.  E para o trabalho deles, você precisa gerar apenas dois sinais: o obturador eletrônico de abertura pela duração da exposição e o relógio.  Em nosso design, essa é exatamente a linha ILX554: (como regra, usada, mas bastante funcional) é fácil de comprar dos chineses no Aliexpress. <br><br>  <b>Vamos olhar para a folha de dados</b> <br><br>  E vemos que apenas 6 dos 22 pinos estão envolvidos: fonte de alimentação de + 5V, sinais de entrada ROG e CLK, sinal de saída Vout, entrada e aterramento de seleção de modo SHSW.  E isso é tudo. <br>  ROG é o controle eletrônico do obturador (e o início da transferência de carga da linha fotossensível para o registro de deslocamento direto).  Ele tem um nível ativo - zero.  Para expor a matriz, ela deve ser pressionada para zero e mantida pelo tempo necessário - de 5 μs a vários segundos.  E então, liberando, aguarde pelo menos 3 μs (durante esse período, o circuito de transferência de carga funcionará).  Todo esse tempo na entrada do CLK mantemos um alto nível.  E então você pode ler a linha, aplicando à entrada CLK um meandro com uma frequência de várias dezenas de quilohertz a 2 MHz.  Nesse caso, a cada diferença de unidade para zero, o próximo pixel será empurrado para a saída.  Existem 2088 desses pixels na programação, dos quais 2048 estão funcionando, fotossensíveis (na realidade, existem vários outros, mas os pixels mais externos são parcialmente obscurecidos).  A Datashit recomenda aplicar pelo menos 2090 pulsos CLK à matriz para a operação correta. <br>  E como ele será enviado depende do que está na entrada do SHSW.  Se for uma unidade lógica, a saída produzirá um sinal bastante complicado: <br><div style="text-align:center;"><img width="50%" src="https://habrastorage.org/webt/dz/xq/qb/dzxqqbdg8vq_r_jgxg4gwek-6lg.gif"></div><br>  Além disso, quando o CLK passa de zero para um, ocorre uma redefinição e de unidade para zero - a emissão de um sinal útil. <br>  E a zero na entrada SHSW, o circuito interno de amostragem e armazenamento é ativado, o que simplifica esse sinal para um sinal de vídeo passo a passo simples, onde, a cada nova transição de CLK para zero, o nível de sinal do próximo pixel simplesmente aparece e é mantido durante todo o período do sinal CLK. <br>  A faixa útil do sinal de saída vem de um certo nível escuro, que de acordo com a folha de dados é de 2,85 V, mas na realidade pode ser diferente (na minha linha - cerca de 3 V) e, quando saturado, o nível do sinal de saída cai para 1,5-2 B. <br>  Em geral, é tudo o que precisamos saber sobre essa linha. <br><br>  <b>Circuito de inclusão</b> <br><br><div style="text-align:center;"><img width="60%" src="https://habrastorage.org/webt/th/vo/xs/thvoxsmrevwageaehbzgex4j054.png"></div><br>  É simples e óbvio.  Geramos sinais CLK e ROG programaticamente usando MK, e os gatilhos Schmitt na entrada são a maneira mais simples de alternar de 3,3 V para 5 V. O fato é que não há buffers nessas linhas na linha e que os circuitos da matriz funcionem corretamente você precisa submeter a eles um meandro com escala completa de zero a cinco volts e uma boa inclinação das frentes.  Os NC7SZ14M5X indicados no diagrama são gatilhos de inversão Schmitt únicos muito convenientes, com frentes íngremes e capacidade de carga aumentada, e geralmente os uso em meus projetos. <br>  Usando DA1, o nível do sinal de vídeo da programação “acelera” até o intervalo em que o ADC opera, enquanto o “suporte” de aproximadamente 1,5 V correspondente ao nível de saturação é removido.  Como a diferença entre a amplitude do sinal e o valor “stand” varia muito entre os diferentes arranjos do CCD, as resistências R1 e R3 devem ser selecionadas “colocando” o sinal de saída na faixa desejada.  Deve-se ter em mente que não apenas o deslocamento, mas também o ganho depende da resistência R1; portanto, você deve primeiro selecioná-lo. <br>  L1 e L2 são esferas de ferrite ou bobinas pequenas para 1-2 μG do tamanho de quadro 0805 ou 0603. Resistores e capacitores são usados ​​do mesmo tamanho.  O circuito é montado em uma placa de dupla face por montagem em superfície.  Não trago o layout do quadro, pois ainda tenho muitas coisas nele. <br><br>  <b>Implementação de software no MK</b> <br><br>  A tarefa MK é gerar um sinal ROG de alto nível (não se esqueça dos inversores!) Da duração necessária, uma breve pausa (3-10 μs) e, depois, uma sequência de 2090 pulsos de alto nível separados por pausas iguais na duração.  Durante esses pulsos (ou pausas), algum tempo após a frente, o valor da iluminação de pixel é obtido usando um ADC externo ou de bordo.  Depois de ler o quadro, você também deve fazer uma pausa até um novo pulso ROG - os mesmos 3-10 μs.  Depois de ligar a energia e, como se viu, após um longo período de uso (mais de 100 ms) da régua, você precisa "limpá-la" aplicando um trem de pulso padrão gratuito ao CLK algumas vezes. <br>  No STM32, é aconselhável fazer tudo isso em uma interrupção do timer.  Ao configurar o timer para gerar interrupções com uma frequência correspondente a uma freqüência de pixel dobrada, colocamos cada operação do timer em uma interrupção, onde alternadamente produzimos zero ou um para a porta e, quando produzimos zero, lemos as leituras do ADC.  E depois de contar 2090 ciclos, paramos o cronômetro.  Para ler o próximo quadro, é necessário redefinir o contador de ciclos para zero, iniciar o temporizador e aguardar até que tudo seja contado. <br>  Algo assim, como mostrado nesses trechos de código. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> clkState = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> frameOk = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pixCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> ccdFrame[<span class="hljs-number"><span class="hljs-number">2090</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> uint16_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readADC1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//            { . . . } void Delay(unsigned int Val) //     { for( ; Val != 0; Val--) __NOP(); } void readCCD(void) //   - { pixCount = 0; //    frameOk = false; //   TIM_Cmd(TIM6, ENABLE); //   while(frameOk == false); // ,     } // ...    ... // void TIM6_IRQHandler(void) /*      -     CLK       */ { if (TIM_GetITStatus(TIM4, TIM_IT_Update) != RESET) { if(clkState == true) //   (.0)      { clkState = false; GPIOB-&gt;ODR &amp;= ~GPIO_ODR_ODR_1; //      Delay(3); //  ,        ccdFrame[pixCount] = readADC1(); } else //   (.1) { pixCount++; clkState = true; GPIOB-&gt;ODR |= GPIO_ODR_ODR_1; //      } if(pixCount &gt;= 2090) //    ,      { pixCount = 0; frameOk = true; TIM_Cmd(TIM6, DISABLE); } TIM_ClearITPendingBit(TIM4, TIM_IT_Update); } }</span></span></span></span></code> </pre> <br><br>  <b>E aqui está o resultado</b> <br>  O resultado não é ruim.  Apesar do ADC embutido não brilhar com suas características, suas características de ruído correspondem completamente ao ruído da linha CCD.  A faixa de ruído do sinal escuro com um tempo de acumulação de cerca de 1 ms resulta em níveis de quantização de ~ 3-4 e, ao usar um ADC externo de 14 bits com excelentes características, os resultados são apenas ligeiramente melhores.  Com o aumento da iluminação, o ruído aumenta por uma razão simples: o número de fotoelétrons em cada um dos pixels não é tão grande (de acordo com meus cálculos, cerca de 30 mil na saturação).  Para os melhores dispositivos, esse valor chega a 200 mil. <br>  No gráfico abaixo, há um exemplo de uma “figura” registrada pela régua, na qual, contra o fundo da parede iluminada, existe um suporte escuro no qual uma bola oca de vidro com um diâmetro de 1 cm fixado no interior é preenchida com solução preta.  Um pico é um reflexo da superfície externa desta bola.  O ruído nas áreas claras é a estrutura da parede propriamente dita, reforçada por manchas do laser, de quadro a quadro, permanece estacionária.  O ruído real da linha é muito menor. <br><div style="text-align:center;"><img width="65%" src="https://habrastorage.org/webt/ce/bt/jw/cebtjw-j6wmi1icilzg_oprfxnc.png" alt="imagem"></div><br><br>  <b>Outras linhas semelhantes</b> <br>  Algumas outras linhas SONY CCD em preto e branco de 2048 pixels da ILX511, ILX551 (a última possui uma pinagem diferente e requer duas tensões de alimentação - 5 e 9 V), diferindo no tamanho do pixel transversal (de 14 a 200 mícrons), funciona exatamente da mesma maneira. e sensibilidade espectral (o ILX554A é sensível ao vermelho e ao IR, semelhante ao índice B tem uma sensibilidade reduzida na região do IR e é muito próximo do olho, e o ILX511B é mais sensível ao azul).  Suas características dinâmicas são diferentes: a faixa dinâmica do ILX551B, devido ao pequeno tamanho de pixel, chega a 6000 (nossa linha atinge esse DD com velocidades curtas do obturador de cerca de 10 μs). <br><br>  * * * <br>  Este artigo discute a conexão talvez da linha CCD mais fácil de usar.  Essa simplicidade se deve ao fato de toda a complexidade estar escondida nela sob o capô.  Se não fossem os drivers internos, eu teria que gerar muitos sinais multiníveis. <br>  Infelizmente, pelos padrões modernos, uma linha CCD com drivers internos não possui as melhores características.  Portanto, nesta linha, a faixa dinâmica, definida como a proporção do sinal de saturação para o sinal escuro, é 333: 1 e definida como a proporção do sinal de saturação para o sinal mínimo detectado no contexto do ruído - cerca de 1000: 1.  Mas esses dispositivos não são apenas difíceis de usar, mas geralmente difíceis de acessar (o mesmo Hamamatsu exige formalidades burocráticas complexas na compra de suas matrizes CCD e outros fotodetectores devido à dupla finalidade desses produtos).  No entanto, esse alto desempenho nem sempre é necessário e, para muitos propósitos, os parâmetros desses dispositivos são bastante aceitáveis. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt457762/">https://habr.com/ru/post/pt457762/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt457752/index.html">Nem vagabundos da lua nem piadistas. O que sabemos sobre robôs em Fukushima</a></li>
<li><a href="../pt457754/index.html">Estado e T-killers</a></li>
<li><a href="../pt457756/index.html">O livro Kafka Streams em ação. Aplicativos e microsserviços em tempo real »</a></li>
<li><a href="../pt457758/index.html">Engenheiros salvam pessoas perdidas na floresta, mas a floresta ainda não se rendeu</a></li>
<li><a href="../pt457760/index.html">Como tornar os contêineres ainda mais isolados: uma revisão das tecnologias de sandbox de contêineres</a></li>
<li><a href="../pt457764/index.html">10 erros do jovem PO (parte II)</a></li>
<li><a href="../pt457766/index.html">Geramos níveis de ladrilhos e ocultamos quadrados do jogador</a></li>
<li><a href="../pt457768/index.html">Como fiquei vulnerável: digitalizando a infraestrutura de TI com a Qualys</a></li>
<li><a href="../pt457770/index.html">Escrevemos o transformador personalizado AST no TypeScript</a></li>
<li><a href="../pt457774/index.html">Estudar como piloto particular na Terra-média: mudar e morar em uma vila da Nova Zelândia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>