<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîú üôáüèæ ‚ôæ JVM TI: c√≥mo hacer un complemento para una m√°quina virtual ‚è∞ üòë üè≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¬øLe gustar√≠a agregar alguna caracter√≠stica √∫til a la JVM? Te√≥ricamente, cada desarrollador puede contribuir a OpenJDK, sin embargo, en la pr√°ctica, cu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JVM TI: c√≥mo hacer un complemento para una m√°quina virtual</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/odnoklassniki/blog/458812/"><img src="https://habrastorage.org/webt/dk/iw/hm/dkiwhmwayxse8--tbyxqszp0xeg.jpeg"><br><br>  ¬øLe gustar√≠a agregar alguna caracter√≠stica √∫til a la JVM?  Te√≥ricamente, cada desarrollador puede contribuir a OpenJDK, sin embargo, en la pr√°ctica, cualquier cambio no trivial en HotSpot no es bienvenido desde el lado, e incluso con el ciclo de lanzamiento acortado actual, pueden pasar a√±os antes de que los usuarios de JDK vean su funci√≥n. <br><br>  Sin embargo, en algunos casos es posible expandir la funcionalidad de una m√°quina virtual sin siquiera tocar su c√≥digo.  La interfaz de la herramienta JVM, la API est√°ndar para interactuar con la JVM, ayuda. <br><br>  En el art√≠culo, mostrar√© con ejemplos concretos lo que se puede hacer con √©l, contar√© lo que ha cambiado en Java 9 y 11, y honestamente advertir√© sobre las dificultades (spoiler: tengo que lidiar con C ++). <br><br>  Tambi√©n habl√© sobre este material en JPoint.  Si prefiere el video, puede ver el informe del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">video</a> . <br><a name="habracut"></a><br><h2>  Entrada </h2><br>  La red social Odnoklassniki, donde trabajo como ingeniero l√≠der, est√° casi completamente escrita en Java.  Pero hoy les contar√© sobre otra parte, que no est√° completamente en Java. <br><br>  Como saben, el problema m√°s popular entre los desarrolladores de Java es NullPointerException.  Una vez, mientras estaba de servicio en el portal, tambi√©n me encontr√© con NPE en producci√≥n.  El error fue acompa√±ado por algo como este seguimiento de pila: <br><br><img src="https://habrastorage.org/webt/j6/lb/4t/j6lb4tmh3wmmti8tebobo7znwsu.jpeg"><br><br>  Por supuesto, en el seguimiento de la pila, puede rastrear el lugar donde ocurri√≥ la excepci√≥n hasta una l√≠nea espec√≠fica en el c√≥digo.  Solo en este caso no me hizo sentir mejor, porque aqu√≠ NPE puede reunirse mucho donde: <br><br><img src="https://habrastorage.org/webt/xt/kt/pq/xtktpq4cozo4xvjvllvgtk9cibe.jpeg"><br><br>  Ser√≠a genial si la JVM sugiriera exactamente d√≥nde estaba este error, por ejemplo, as√≠: <br> <code>java.lang.NullPointerException: Called 'getUsers()' method on null object</code> <br> <br>  Pero, desafortunadamente, NPE ahora no contiene nada por el estilo.  Aunque han estado pidiendo esto durante mucho tiempo, al menos con Java 1.4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este error</a> tiene 16 a√±os.  Peri√≥dicamente, se abr√≠an m√°s y m√°s errores sobre este tema, pero siempre se cerraban como "No se solucionar√°": <br><br><img src="https://habrastorage.org/webt/5l/tc/xg/5ltcxgloqnkiiudcadczatl6_ne.jpeg"><br><br>  Esto no sucede en todas partes.  Volker Simonis de SAP <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cont√≥</a> c√≥mo hab√≠an implementado esta caracter√≠stica en SAP JVM durante mucho tiempo y la ayud√≥ m√°s de una vez.  Otro empleado de SAP, una vez m√°s, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">present√≥ un</a> error en OpenJDK y se ofreci√≥ como voluntario para implementar un mecanismo similar al de la JVM de SAP.  Y, he aqu√≠, esta vez el error no se cerr√≥; existe la posibilidad de que esta caracter√≠stica ingrese a JDK 14. <br><br>  Pero, ¬øcu√°ndo se lanzar√° JDK 14 y cu√°ndo cambiaremos a √©l?  ¬øQu√© hacer si quieres investigar el problema aqu√≠ y ahora? <br><br>  Por supuesto, puede mantener su bifurcaci√≥n de OpenJDK.  La funci√≥n de informes de NPE en s√≠ no es tan complicada que podr√≠amos haberla implementado.  Pero al mismo tiempo surgir√°n todos los problemas de apoyar su propio ensamblaje.  Ser√≠a genial implementar la funci√≥n una vez y luego simplemente conectarla a cualquier versi√≥n de la JVM como un complemento.  ¬°Y esto es realmente posible!  JVM tiene una API especial (desarrollada originalmente para todo tipo de depuradores y perfiladores): Interfaz de herramientas JVM. <br><br>  Lo m√°s importante, esta API es est√°ndar.  Tiene una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">especificaci√≥n</a> estricta, y al implementar una funci√≥n de acuerdo con ella, puede estar seguro de que funcionar√° en nuevas versiones de la JVM. <br><br>  Para usar esta interfaz, debe escribir un programa peque√±o (o grande, seg√∫n cu√°les sean sus tareas).  Nativo: generalmente se escribe en C o C ++.  La <code>jdk/include/jvmti.h</code> JDK est√°ndar tiene un archivo de encabezado <code>jdk/include/jvmti.h</code> que desea incluir. <br><br>  El programa se compila en una biblioteca din√°mica y se conecta mediante el par√°metro <code>-agentpath</code> durante el inicio de la JVM.  Es importante no confundirlo con otro par√°metro similar: <code>-javaagent</code> .  De hecho, los agentes Java son un caso especial de los agentes JVM TI.  Adem√°s en el texto bajo la palabra "agente" se entiende precisamente el agente nativo. <br><br><h2>  Por donde empezar </h2><br>  Veamos en la pr√°ctica c√≥mo escribir el agente JVM TI m√°s simple, una especie de "hola mundo". <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;jvmti.h&gt; #include &lt;stdio.h&gt; JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM* vm, char* options, void* reserved) { jvmtiEnv* jvmti; vm-&gt;GetEnv((void**) &amp;jvmti, JVMTI_VERSION_1_0); char* vm_name = NULL; jvmti-&gt;GetSystemProperty("java.vm.name", &amp;vm_name); printf("Agent loaded. JVM name = %s\n", vm_name); fflush(stdout); return 0; }</span></span></span></span></code> </pre><br>  La primera l√≠nea incluyo el mismo archivo de encabezado.  Luego viene la funci√≥n principal que debe implementarse en el agente: <code>Agent_OnLoad()</code> .  La m√°quina virtual en s√≠ misma lo llama cuando el agente arranca, pasando un puntero al objeto <code>JavaVM*</code> . <br><br>  Al <code>jvmtiEnv*</code> , puede obtener un puntero al entorno JVM TI: <code>jvmtiEnv*</code> .  Y a trav√©s de √©l, a su vez, ya llamamos a las funciones JVM TI.  Por ejemplo, usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GetSystemProperty,</a> lea el valor de una propiedad del sistema. <br><br>  Si ahora ejecuto este "hola mundo", pasando el archivo dll compilado a <code>-agentpath</code> , la l√≠nea impresa por nuestro agente aparecer√° en la consola antes de que el programa Java comience a ejecutarse: <br><br><img src="https://habrastorage.org/webt/rl/cq/eu/rlcqeul7gpb8mahabl0ehgckro8.png"><br><br><h2>  Enriquecimiento NPE </h2><br>  Como hello world no es el ejemplo m√°s interesante, volvamos a nuestras excepciones.  El c√≥digo de agente completo que complementa los informes de NPE est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en GitHub</a> . <br><br>  As√≠ es como se ve <code>Agent_OnLoad()</code> si quiero pedirle a la m√°quina virtual que nos notifique todas las excepciones: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">JNIEXPORT jint JNICALL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Agent_OnLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JavaVM* vm, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* options, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* reserved)</span></span></span><span class="hljs-function"> </span></span>{ jvmtiEnv* jvmti; vm-&gt;GetEnv((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>**) &amp;jvmti, JVMTI_VERSION_1_0); jvmtiCapabilities capabilities = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; capabilities.can_generate_exception_events = <span class="hljs-number"><span class="hljs-number">1</span></span>; jvmti-&gt;AddCapabilities(&amp;capabilities); jvmtiEventCallbacks callbacks = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; callbacks.Exception = ExceptionCallback; jvmti-&gt;SetEventCallbacks(&amp;callbacks, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(callbacks)); jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_EXCEPTION, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Primero le pido a JVM TI la capacidad correspondiente (can_generate_exception_events).  Hablaremos sobre la capacidad por separado. <br><br>  El siguiente paso es suscribirse a los eventos de excepci√≥n.  Siempre que la JVM arroje excepciones (sin importar si son capturadas o no), se llamar√° a nuestra funci√≥n <code>ExceptionCallback()</code> . <br><br>  El √∫ltimo paso es llamar a <code>SetEventNotificationMode()</code> para permitir la entrega de notificaciones. <br><br><div class="spoiler">  <b class="spoiler_title">En ExceptionCallback, la JVM pasa todo lo que necesitamos para manejar excepciones.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> JNICALL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExceptionCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(jvmtiEnv* jvmti, JNIEnv* env, jthread thread, jmethodID method, jlocation location, jobject exception, jmethodID catch_method, jlocation catch_location)</span></span></span><span class="hljs-function"> </span></span>{ jclass NullPointerException = env-&gt;FindClass(<span class="hljs-string"><span class="hljs-string">"java/lang/NullPointerException"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!env-&gt;IsInstanceOf(exception, NullPointerException)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } jclass Throwable = env-&gt;FindClass(<span class="hljs-string"><span class="hljs-string">"java/lang/Throwable"</span></span>); jfieldID detailMessage = env-&gt;GetFieldID(Throwable, <span class="hljs-string"><span class="hljs-string">"detailMessage"</span></span>, <span class="hljs-string"><span class="hljs-string">"Ljava/lang/String;"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (env-&gt;GetObjectField(exception, detailMessage) != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">32</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(buf, <span class="hljs-string"><span class="hljs-string">"at location %id"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) location); env-&gt;SetObjectField(exception, detailMessage, env-&gt;NewStringUTF(buf)); }</code> </pre><br></div></div><br>  Aqu√≠ hay tanto el objeto del subproceso que arroj√≥ la excepci√≥n (subproceso) como el lugar donde sucedi√≥ esto (m√©todo, ubicaci√≥n) y el objeto de la excepci√≥n (excepci√≥n), e incluso el lugar en el c√≥digo que captura esta excepci√≥n (catch_method, catch_location). <br><br>  Lo importante: en esta devoluci√≥n de llamada, adem√°s del puntero al entorno JVM TI, tambi√©n se pasa el entorno JNI (env).  Esto significa que podemos usar todas las funciones JNI en √©l.  Es decir, JVM TI y JNI coexisten perfectamente, se complementan entre s√≠. <br><br>  En mi agente uso ambos.  En particular, a trav√©s de JNI verifico que mi excepci√≥n es del tipo <code>NullPointerException</code> , y luego reemplazo el campo <code>detailMessage</code> un mensaje de error. <br><br>  Como la propia JVM nos pasa la ubicaci√≥n, el √≠ndice de c√≥digo de bytes en el que ocurri√≥ la excepci√≥n, entonces coloco esta ubicaci√≥n aqu√≠ en el mensaje: <br><br><img src="https://habrastorage.org/webt/ix/h8/pc/ixh8pcrtxcg4rcdwwlg83_gfuam.png"><br><br>  El n√∫mero 66 indica el √≠ndice en c√≥digo de bytes donde se produjo esta excepci√≥n.  Pero analizar el c√≥digo de bytes manualmente es triste: necesita descompilar el archivo de clase, buscar la instrucci√≥n n√∫mero 66, intentar comprender lo que estaba haciendo ... Ser√≠a genial si nuestro propio agente pudiera mostrar algo m√°s legible para los humanos. <br><br>  Sin embargo, en este caso, la TI JVM tiene todo lo que necesita.  Es cierto que debe solicitar caracter√≠sticas adicionales de JVM TI: obtenga el c√≥digo de bytes y el m√©todo de agrupaci√≥n constante. <br><br><pre> <code class="cpp hljs">jvmtiCapabilities capabilities = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; capabilities.can_generate_exception_events = <span class="hljs-number"><span class="hljs-number">1</span></span>; capabilities.can_get_bytecodes = <span class="hljs-number"><span class="hljs-number">1</span></span>; capabilities.can_get_constant_pool = <span class="hljs-number"><span class="hljs-number">1</span></span>; jvmti-&gt;AddCapabilities(&amp;capabilities);</code> </pre><br>  Ahora expandir√© ExceptionCallback: a trav√©s de la funci√≥n JVM TI <code>GetBytecodes()</code> obtendr√© el cuerpo del m√©todo para verificar lo que hay en √©l por √≠ndice de ubicaci√≥n.  Luego viene un gran interruptor de instrucciones de c√≥digo de bytes: si este es un acceso a la matriz, habr√° un mensaje de error, si el acceso al campo es otro mensaje, si la llamada al m√©todo es el tercero, y as√≠ sucesivamente. <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo de excepci√≥n de devoluci√≥n de llamada</b> <div class="spoiler_text"><pre> <code class="cpp hljs">jint bytecode_count; u1* bytecodes; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (jvmti-&gt;GetBytecodes(method, &amp;bytecode_count, &amp;bytecodes) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; location &lt; bytecode_count) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* message = get_exception_message(bytecodes[location]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (message != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { ... env-&gt;SetObjectField(exception, detailMessage, env-&gt;NewStringUTF(buf)); } } jvmti-&gt;Deallocate(bytecodes);</code> </pre><br></div></div><br>  Solo queda sustituir el nombre del campo o m√©todo.  Puede obtenerlo del grupo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">constante</a> , que est√° disponible nuevamente gracias a JVM TI. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (jvmti-&gt;GetConstantPool(holder, &amp;cpool_count, &amp;cpool_bytes, &amp;cpool) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strdup(<span class="hljs-string"><span class="hljs-string">"&lt;unknown&gt;"</span></span>); }</code> </pre><br>  Luego viene un poco de magia, pero en realidad nada complicado, solo de acuerdo con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la especificaci√≥n del</a> formato de archivo de clase analizamos el grupo constante y a partir de ah√≠ aislamos la l√≠nea, el nombre del m√©todo. <br><br><div class="spoiler">  <b class="spoiler_title">An√°lisis de grupo constante</b> <div class="spoiler_text"><pre> <code class="cpp hljs">u1* ref = get_cpool_at(cpool, get_u2(bytecodes + <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// CONSTANT_Fieldref u1* name_and_type = get_cpool_at(cpool, get_u2(ref + 3)); // CONSTANT_NameAndType u1* name = get_cpool_at(cpool, get_u2(name_and_type + 1)); // CONSTANT_Utf8 size_t name_length = get_u2(name + 1); char* result = (char*) malloc(name_length + 1); memcpy(result, name + 3, name_length); result[name_length] = 0;</span></span></code> </pre><br></div></div><br>  Otro punto importante: algunas funciones JVM TI, por ejemplo <code>GetConstantPool()</code> o <code>GetBytecodes()</code> , asignan una determinada estructura en la memoria nativa, que debe liberarse cuando termine de trabajar con ella. <br><br><pre> <code class="cpp hljs">jvmti-&gt;Deallocate(cpool);</code> </pre><br>  Ejecute el programa fuente con nuestro agente extendido, y aqu√≠ hay una descripci√≥n completamente diferente de la excepci√≥n: informa que llamamos al m√©todo longValue () en el objeto nulo. <br><br><img src="https://habrastorage.org/webt/8d/ge/-d/8dge-d_mtmqpdesbk6vm4nwolna.png"><br><br><h2>  Otras aplicaciones </h2><br>  En t√©rminos generales, los desarrolladores a menudo quieren manejar las excepciones a su manera.  Por ejemplo, reinicie autom√°ticamente la JVM si se <code>StackOverflowError</code> un <code>StackOverflowError</code> . <br><br>  Este deseo se puede entender, ya que <code>StackOverflowError</code> es el mismo error fatal que <code>OutOfMemoryError</code> , despu√©s de su aparici√≥n ya no es posible garantizar el correcto funcionamiento del programa.  O, por ejemplo, a veces para analizar el problema, quiero recibir un volcado de subprocesos o un volcado de almacenamiento din√°mico cuando se produce una excepci√≥n. <br><br><img src="https://habrastorage.org/webt/hh/8b/zy/hh8bzys2bji12vte4g_fsmlfaky.jpeg"><br><br>  Para ser justos, el IBM JDK tiene esa oportunidad fuera de la caja.  Pero ahora ya sabemos que con el agente JVM TI, puede implementar lo mismo en HotSpot.  Es suficiente suscribirse a la devoluci√≥n de llamada de excepci√≥n y analizar la excepci√≥n.  Pero, ¬øc√≥mo eliminar el volcado de hebras o el volcado de almacenamiento din√°mico de nuestro agente?  JVM TI tiene todo lo que necesita para este caso: <br><br><img src="https://habrastorage.org/webt/yp/jj/5o/ypjj5o9xn9m7tmhdzmh-z8bo2tk.jpeg"><br><br>  No es muy conveniente implementar todo el mecanismo de omitir el mont√≥n y crear un volcado.  Pero compartir√© el secreto de c√≥mo hacerlo m√°s f√°cil y r√°pido.  Es cierto que esto ya no est√° incluido en el JVM TI est√°ndar, sino que es una extensi√≥n privada de Hotspot. <br><br>  <a href="">Debe</a> conectar el archivo de encabezado <a href="">jmm.h</a> desde las fuentes de HotSpot y llamar a la funci√≥n <code>JVM_GetManagement()</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"jmm.h"</span></span></span><span class="hljs-meta"> JNIEXPORT void* JNICALL JVM_GetManagement(jint version); void JNICALL ExceptionCallback(jvmtiEnv* jvmti, JNIEnv* env, ...) { JmmInterface* jmm = (JmmInterface*) JVM_GetManagement(JMM_VERSION_1_0); jmm-&gt;DumpHeap0(env, env-&gt;NewStringUTF(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"dump.hprof"</span></span></span><span class="hljs-meta">), JNI_FALSE); }</span></span></code> </pre><br>  Devolver√° un puntero a la interfaz de administraci√≥n de HotSpot, que en una sola llamada generar√° un volcado de mont√≥n o volcado de subprocesos.  El c√≥digo completo para el ejemplo se puede encontrar en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mi respuesta</a> a Stack Overflow. <br><br>  Naturalmente, puede manejar no solo excepciones, sino tambi√©n un mont√≥n de otros eventos relacionados con la operaci√≥n JVM: iniciar / detener subprocesos, cargar clases, recolecci√≥n de basura, m√©todos de compilaci√≥n, m√©todos de entrada / salida, incluso acceder o modificar campos espec√≠ficos de objetos Java. <br><br>  Tengo un ejemplo de otro agente <a href="">vmtrace</a> que se suscribe a muchos eventos JVM TI est√°ndar y los registra.  Si ejecuto un programa simple con este agente, obtendr√© un registro detallado, que, cuando termine, con marcas de tiempo: <br><br><img src="https://habrastorage.org/webt/wu/he/ci/wuhecifrgrrkleshnnkqx6hd9ew.jpeg"><br><br>  Como puede ver, para imprimir simplemente hello world, se cargan cientos de clases, se generan y compilan decenas y cientos de m√©todos.  Queda claro por qu√© Java tarda tanto en ejecutarse.  Todo sobre todo tom√≥ m√°s de doscientos milisegundos. <br><br><h2>  Lo que JVM TI puede hacer </h2><br>  Adem√°s del manejo de eventos, el JVM TI tiene muchas otras caracter√≠sticas.  Se pueden dividir en dos grupos. <br><br>  Uno es obligatorio, que cualquier JVM que admita JVM TI debe implementar.  Estos incluyen las operaciones de an√°lisis de m√©todos, campos, flujos, la capacidad de agregar nuevas clases al classpath, etc. <br><br>  Hay caracter√≠sticas opcionales que requieren una solicitud de capacidades preliminares.  No se requiere que JVM los admita a todos, sin embargo, HotSpot implementa la especificaci√≥n completa en su totalidad.  Las caracter√≠sticas opcionales se dividen en dos subgrupos: las que se pueden conectar solo al comienzo de la JVM (por ejemplo, la capacidad de establecer un punto de interrupci√≥n o analizar variables locales), y las que se pueden conectar en cualquier momento (en particular, c√≥digo de bytes o grupo constante, que I usado arriba). <br><br><img src="https://habrastorage.org/webt/ee/9e/oo/ee9eooqcrrdowlrc1rvqmfuhjs0.jpeg"><br><br>  Puede notar que la lista de caracter√≠sticas es muy similar a las capacidades del depurador.  De hecho, un depurador de Java no es m√°s que un caso especial del agente JVM TI, que aprovecha todas estas capacidades y solicita todas las capacidades. <br><br>  La separaci√≥n de las capacidades en aquellas que se pueden habilitar en cualquier momento, y aquellas que solo est√°n en el momento del arranque, se realiza a prop√≥sito.  No todas las funciones son gratuitas, algunas llevan gastos generales. <br><br>  Si todo est√° claro con los gastos indirectos directos que acompa√±an al uso de la funci√≥n, entonces hay otros indirectos menos obvios que aparecen incluso si no usa la funci√≥n, pero simplemente a trav√©s de las capacidades declara que ser√° necesaria en alg√∫n momento en el futuro.  Esto se debe al hecho de que la m√°quina virtual puede compilar el c√≥digo de manera diferente o agregar comprobaciones adicionales al tiempo de ejecuci√≥n. <br><br>  Por ejemplo, la capacidad ya considerada para suscribirse a excepciones (can_generate_exception_events) lleva al hecho de que todas las excepciones de lanzamiento ir√°n de manera lenta.  En principio, esto no da tanto miedo, porque las excepciones son algo raro en un buen programa Java. <br><br>  La situaci√≥n con las variables locales es ligeramente peor.  Para can_access_local_variables, que le permite obtener los valores de las variables locales en cualquier momento, debe deshabilitar algunas optimizaciones importantes.  En particular, Escape Analysis deja de funcionar por completo, lo que puede generar una sobrecarga notable: dependiendo de la aplicaci√≥n, 5-10%. <br><br>  De ah√≠ la conclusi√≥n: si ejecuta Java con el agente de depuraci√≥n activado, sin siquiera usarlo, las aplicaciones se ejecutar√°n m√°s lentamente.  De todos modos, incluir un agente de depuraci√≥n en la producci√≥n no es una buena idea. <br><br>  Una serie de caracter√≠sticas, por ejemplo, establecer un punto de interrupci√≥n o rastrear todas las entradas / salidas de un m√©todo, conlleva una sobrecarga mucho m√°s grave.  En particular, algunos eventos JVM TI (FieldAccess, MethodEntry / Exit) solo funcionan en el int√©rprete. <br><br><h2>  Un agente es bueno y dos son mejores. </h2><br>  Puede conectar varios agentes a un solo proceso simplemente especificando varios par√°metros de <code>-agentpath</code> .  Todos tendr√°n su propio entorno JVM TI.  Esto significa que todos pueden suscribirse a sus capacidades e interceptar sus eventos de forma independiente. <br><br>  Y si dos agentes se suscribieron al evento de punto de interrupci√≥n, y en uno el punto de interrupci√≥n se establece en alg√∫n m√©todo, cuando se ejecute este m√©todo, ¬ørecibir√° el segundo agente el evento? <br><br>  En realidad, tal situaci√≥n no puede ocurrir (al menos en HotSpot JVM).  Porque hay algunas capacidades que solo uno de los agentes puede poseer en un momento dado.  Estos incluyen breakpoint_events en particular.  Por lo tanto, si el segundo agente solicita la misma capacidad, recibir√° un error en respuesta. <br><br>  Esta es una conclusi√≥n importante: el agente siempre debe verificar el resultado de la solicitud de capacidades, incluso si se est√° ejecutando en HotSpot y sabe que todos est√°n disponibles.  La especificaci√≥n JVM TI no dice nada sobre capacidades exclusivas, pero HotSpot tiene una funci√≥n de implementaci√≥n de este tipo. <br><br>  Es cierto que el aislamiento del agente no siempre funciona a la perfecci√≥n.  Durante el desarrollo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">async-profiler,</a> me encontr√© con este problema: cuando tenemos dos agentes y uno solicita la generaci√≥n de eventos de compilaci√≥n de m√©todos, todos los agentes reciben estos eventos.  Por supuesto, present√© un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">error</a> , pero debe tener en cuenta que los eventos que no espera pueden ocurrir en su agente. <br><br><h2>  Uso en un programa regular </h2><br>  JVM TI puede parecer algo muy espec√≠fico para depuradores y perfiladores, pero tambi√©n se puede usar en un programa Java normal.  Considera un ejemplo. <br><br>  El paradigma de programaci√≥n reactiva ahora est√° muy extendido cuando todo es as√≠ncrono, pero hay un problema con este paradigma. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TaskRunner</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">good</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ CompletableFuture.runAsync(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AsyncTask(GOOD)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ CompletableFuture.runAsync(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AsyncTask(BAD)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ good(); bad(); Thread.sleep(<span class="hljs-number"><span class="hljs-number">200</span></span>); } }</code> </pre><br>  Ejecuto dos tareas asincr√≥nicas que difieren solo en par√°metros.  Y si algo sale mal, se genera una excepci√≥n: <br><br><img src="https://habrastorage.org/webt/ds/me/wx/dsmewxe5rd4lzgq8fgjxn42zh0e.png"><br><br>  Desde el seguimiento de la pila, no est√° completamente claro cu√°l de estas tareas caus√≥ el problema.  Porque la excepci√≥n ocurre en un hilo completamente diferente, donde no tenemos contexto.  ¬øC√≥mo entender en qu√© tarea? <br><br>  Como una de las soluciones, puede agregar informaci√≥n sobre d√≥nde la creamos al constructor de nuestra tarea asincr√≥nica: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsyncTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String arg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arg = arg; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.location = getLocation(); }</code> </pre><br>  Es decir, recuerde la ubicaci√≥n: un lugar espec√≠fico en el c√≥digo, hasta la l√≠nea desde donde se llam√≥ al constructor.  Y en caso de una excepci√≥n para prometerlo: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = Integer.parseInt(arg); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable e) { System.err.println(<span class="hljs-string"><span class="hljs-string">"ParseTask failed at "</span></span> + location); e.printStackTrace(); }</code> </pre><br>  Ahora, cuando ocurre una excepci√≥n, veremos que esto sucedi√≥ en la l√≠nea 14 en el TaskRunner (donde se crea la tarea con el par√°metro BAD): <br><br><img src="https://habrastorage.org/webt/v-/tq/0q/v-tq0qa-bnlkakz8dnzxhrjfqvo.png"><br><br>  Pero, ¬øc√≥mo obtener el lugar en el c√≥digo desde donde se llama al constructor?  Antes de Java 9, hab√≠a la √∫nica forma legal de hacer esto: obtener un seguimiento de la pila, omitir algunos marcos irrelevantes, y justo debajo de la pila estar√° el lugar al que llam√≥ nuestro c√≥digo. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ StackTraceElement caller = Thread.currentThread().getStackTrace()[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> caller.getFileName() + <span class="hljs-string"><span class="hljs-string">':'</span></span> + caller.getLineNumber(); }</code> </pre><br>  Pero hay un problema.  Obtener el StackTrace completo es bastante lento.  Tengo un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">informe</a> completo dedicado a esto. <br><br>  Esto no ser√≠a un gran problema si ocurriera raramente.  Pero, por ejemplo, tenemos un servicio web, una interfaz que acepta solicitudes HTTP.  Esta es una gran aplicaci√≥n, millones de l√≠neas de c√≥digo.  Y para detectar errores de representaci√≥n, utilizamos un mecanismo similar: en los componentes para la representaci√≥n, recordamos el lugar donde se crean.  Tenemos millones de estos componentes, por lo que obtener todos los rastros de la pila lleva un tiempo tangible para iniciar la aplicaci√≥n, no solo un minuto.  Por lo tanto, esta caracter√≠stica se desactiv√≥ anteriormente en producci√≥n, aunque para el an√°lisis de problemas se necesita en producci√≥n. <br><br>  Java 9 introdujo una nueva forma de evitar las pilas de flujo: StackWalker, que a trav√©s de Stream API puede hacer todo esto de forma perezosa, bajo demanda.  Es decir, podemos omitir el n√∫mero correcto de fotogramas y obtener solo uno que nos interese. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StackWalker.getInstance().walk(s -&gt; { StackWalker.StackFrame frame = s.skip(<span class="hljs-number"><span class="hljs-number">3</span></span>).findFirst().get(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> frame.getFileName() + <span class="hljs-string"><span class="hljs-string">':'</span></span> + frame.getLineNumber(); }); }</code> </pre><br>  Funciona un poco mejor que obtener el seguimiento de la pila completa, pero no por un orden de magnitud o incluso muchas veces.  En nuestro caso, result√≥ ser aproximadamente una vez y media m√°s r√°pido: <br><br><img src="https://habrastorage.org/webt/v8/bz/rk/v8bzrkf8szriwvghilzvhrddtzo.jpeg"><br><br>  Existe un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">problema conocido</a> con la implementaci√≥n sub√≥ptima de StackWalker, y lo m√°s probable es que incluso se solucione en JDK 13. Pero, de nuevo, ¬øqu√© debemos hacer ahora en Java 8, donde StackWalker ni siquiera es lento? <br><br>  El JVM TI viene al rescate nuevamente.  Hay una funci√≥n <code>GetStackTrace()</code> que puede hacer todo lo que necesita: obtener un fragmento de un seguimiento de pila de una longitud determinada, comenzando desde el marco especificado, y no hacer nada m√°s. <br><br><pre> <code class="cpp hljs">GetStackTrace(jthread thread, jint start_depth, jint max_frame_count, jvmtiFrameInfo* frame_buffer, jint* count_ptr)</code> </pre><br>  Solo queda una pregunta: ¬øc√≥mo llamar a la funci√≥n JVM TI desde nuestro programa Java?  Al igual que cualquier otro m√©todo nativo: cargue la biblioteca nativa con <code>System.loadLibrary()</code> , donde estar√° la implementaci√≥n JNI de nuestro m√©todo. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StackFrame</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">native</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> depth)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { System.loadLibrary(<span class="hljs-string"><span class="hljs-string">"stackframe"</span></span>); } }</code> </pre><br>  Se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">puede obtener</a> un puntero al entorno JVM TI no solo de Agent_OnLoad (), sino tambi√©n mientras el programa se est√° ejecutando, y continuar us√°ndolo desde m√©todos JNI nativos comunes: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">JNIEXPORT jstring JNICALL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Java_StackFrame_getLocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JNIEnv* env, jclass unused, jint depth)</span></span></span><span class="hljs-function"> </span></span>{ jvmtiFrameInfo frame; jint count; jvmti-&gt;GetStackTrace(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, depth, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;frame, &amp;count);</code> </pre><br>               : <br><br><img src="https://habrastorage.org/webt/ia/-u/au/ia-uauyvrmwlvh84rh84rqqwu1s.jpeg"><br><br> ,    JDK   :    -  .          -. ,   ,      ,   JDK.   JDK 8u112,  JVM TI-,    (GetMethodName, GetMethodDeclaringClass   ),   . <br><br>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> ,  ,    :   JVM TI-   ,   ,         -.     ,         C++,    <a href="">jvmtiEnter.xsl</a> . <br><br>  :    HotSpot       XSLT-.       HotSpot. <br><br>     ?       ,   .  ,   - jmethodID  ,      .      ,      . <br><br><h2>   </h2><br>    ,  JVM TI     Java-     ,  <code>System.loadLibrary</code> . <br><br>  ,   ,    JVM TI-  <code>-agentpath</code>   JVM. <br><br>     :   (dynamic attach). <br><br>   ?          ,      - ,       ,    JVM TI-    . <br><br>   JDK 9,           jcmd: <br><br><pre> <code class="bash hljs">jcmd &lt;pid&gt; JVMTI.agent_load /path/to/agent.so [arguments]</code> </pre><br>      JDK     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">jattach</a> . , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">async-profiler</a>      ,   -  JVM-,    jattach. <br><br>    JVM TI-    , ,  <code>Agent_OnLoad()</code> ,    <code>Agent_OnAttach()</code> .  :  <code>Agent_OnAttach()</code>    capabilities,       . <br><br>  ,           ,   <code>Agent_OnAttach()</code>   . <br><br>   .     IntelliJ IDEA:    Java-, ,          - . <br><br>  process ID  IDEA,   jattach     JVM TI- patcher.dll: <br> <code>jattach 8648 load patcher.dll true</code> <br> <br>          : <br><br><img src="https://habrastorage.org/webt/rv/j7/wm/rvj7wmnfdbo26tjkcsqaix96k74.png"><br><br>    ?   Java-   ( <code>javax.swing.AbstractButton</code> )    JNI  <code>setBackground()</code> .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> . <br><br><h2>    Java 9 </h2><br> JVM TI   , ,    ,     API,     .      Java 9. <br><br>  , Java 9     ,   .  ,    ¬´¬ª JDK,       . <br><br> ,  JDK     Direct ByteBuffer.    API: <br><br><img src="https://habrastorage.org/webt/wj/qb/ue/wjqbuel-1g3j1qis_bihg0lpn_8.jpeg"><br><br> ,  Cassandra    ,          MappedByteBuffer,      ,  JVM  . <br><br>          JDK 9,  IllegalAccessError: <br><br><img src="https://habrastorage.org/webt/co/z-/49/coz-496tvv3ogo7kw44viuqtpwq.jpeg"><br><br>      Reflection:      . <br><br> ,  Java       Linux.   -        <code>java.io.FileDescriptor</code>       JNI    -  .  ,     JDK 9,     : <br><br><img src="https://habrastorage.org/webt/he/xc/6p/hexc6pnrkv0ehoablvlfy11imt0.jpeg"><br><br> ,   JVM,           .      ,   . ,    Cassandra  Java 11,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> : <br><br><pre> <code class="plaintext hljs">--add-exports java.base/jdk.internal.misc=ALL-UNNAMED --add-exports java.base/jdk.internal.ref=ALL-UNNAMED --add-exports java.base/sun.nio.ch=ALL-UNNAMED --add-exports java.management.rmi/com.sun.jmx.remote.internal.rmi=ALL-UNNAMED --add-exports java.rmi/sun.rmi.registry=ALL-UNNAMED --add-exports java.rmi/sun.rmi.server=ALL-UNNAMED --add-exports java.sql/java.sql=ALL-UNNAMED --add-opens java.base/java.lang.module=ALL-UNNAMED --add-opens java.base/jdk.internal.loader=ALL-UNNAMED --add-opens java.base/jdk.internal.ref=ALL-UNNAMED --add-opens java.base/jdk.internal.reflect=ALL-UNNAMED --add-opens java.base/jdk.internal.math=ALL-UNNAMED --add-opens java.base/jdk.internal.module=ALL-UNNAMED --add-opens java.base/jdk.internal.util.jar=ALL-UNNAMED --add-opens jdk.management/com.sun.management.internal=ALL-UNNAMED</code> </pre><br>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> JVM TI    : <br><br><ul><li> GetAllModules </li><li> AddModuleExports </li><li> AddModuleOpens </li><li>  . . </li></ul><br>    ,    :    JVM,    ,    ,      . <br><br>      Direct ByteBuffer: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ ByteBuffer buf = ByteBuffer.allocateDirect(<span class="hljs-number"><span class="hljs-number">1024</span></span>); ((sun.nio.ch.DirectBuffer) buf).cleaner().clean(); System.out.println(<span class="hljs-string"><span class="hljs-string">"Buffer cleaned"</span></span>); }</code> </pre><br>     ,   IllegalAccessError.     agentpath    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">antimodule</a> ,     .     . <br><br><h2>    Java 11 </h2><br>     Java 11.   ,   !     :    <code>SampledObjectAlloc</code> ,    ,      . <br><br>  callback   ,     : ,  ,   ,  , .   <code>SetHeapSampingInterval</code>   ,      . <br><br><img src="https://habrastorage.org/webt/5f/e1/8_/5fe18_nwt5i-zbm4e-vyn4roavm.jpeg"><br><br>   ?         ,    ,     .        Java Flight Recorder. <br><br>     ,     ,     ,  , . <br><br>           Thread Local Allocation Buffer   .      TLAB   ,   .        ,     . <br><br><img src="https://habrastorage.org/webt/v0/lm/di/v0lmdimdyk8uvasl3z9gkjlrfqe.jpeg"><br><br>     ,     TLAB,    .          JVM runtime   . <br><br>   ,        ,       ‚Äî     5%. <br><br>  ,    ,    JDK 7,    Flight Recorder.    API     async-profiler.  ,   JDK 11,  API  ,   JVM TI,      .  , YourKit   .     API,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> ,    . <br><br>         . ,   ,    , , . <br><br><img src="https://habrastorage.org/webt/qi/t1/lw/qit1lwwqv3p7vxhhl-fbcfh5bos.jpeg"><br><br><h2>  Conclusi√≥n </h2><br> JVM TI ‚Äî      . <br><br> ,     ++,     JVM         .  ,  JVM TI        . <br><br>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> GitHub</a> . ,    . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/458812/">https://habr.com/ru/post/458812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../458798/index.html">Nutrient Bot o c√≥mo quiero tomar el pan de los entrenadores de fitness</a></li>
<li><a href="../458800/index.html">Aprendizaje profundo Aprendizaje Federado</a></li>
<li><a href="../458804/index.html">Recopilaci√≥n de art√≠culos sobre aprendizaje autom√°tico e inteligencia artificial</a></li>
<li><a href="../458808/index.html">Informe postmortem de Habr: el peri√≥dico cay√≥</a></li>
<li><a href="../458810/index.html">Corel y Parallels vendidos al grupo de inversi√≥n KKR de EE. UU.</a></li>
<li><a href="../458814/index.html">Lanzar un sitio para un producto con una demanda sin forma</a></li>
<li><a href="../458818/index.html">Destacados contempor√°neos</a></li>
<li><a href="../458820/index.html">Sobre la implementaci√≥n del famoso g√©nero en la plataforma Minecraft</a></li>
<li><a href="../458826/index.html">C√≥mo eliminar los art√≠culos viejos para que crezcan bruscamente en lo org√°nico: + 104% del tr√°fico durante seis meses</a></li>
<li><a href="../458828/index.html">Por qu√©, por qu√© y cu√°ndo usar ValueTask</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>