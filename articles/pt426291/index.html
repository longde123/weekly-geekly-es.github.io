<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñãÔ∏è üìµ üë®üèø‚Äçü§ù‚Äçüë®üèæ Dois Z80s por uma m√°quina: como as m√°quinas de arcade de 8 bits diferiam dos computadores dom√©sticos? üå§Ô∏è üíá üë®üèª‚Äçüåæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O que aprendi sobre a m√°quina de fliperama Bomb Jack no processo de cria√ß√£o de seu emulador 


 Recentemente, escrevi um pequeno emulador para uma m√°q...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dois Z80s por uma m√°quina: como as m√°quinas de arcade de 8 bits diferiam dos computadores dom√©sticos?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426291/"><h2>  O que aprendi sobre a m√°quina de fliperama Bomb Jack no processo de cria√ß√£o de seu emulador </h2><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ea/be5/eae/7eabe5eaeb49a7c8a77b543628df89bf.png"></div><br>  Recentemente, escrevi um pequeno emulador para uma m√°quina Bomb Jack, principalmente para descobrir como essas primeiras m√°quinas arcade de 8 bits diferiam no design dos computadores dom√©sticos de 8 bits. <br><br>  Como aprendi muito mais tarde, uma reuni√£o em uma feira de ver√£o em minha cidade natal com m√°quinas de fliperama como Bomb Jack foi um daqueles momentos que mudaram meu destino.  Em um dia normal de ver√£o, depois de gastar todo o meu suprimento de moedas em m√°quinas de fliperama, voltei para casa e minha cabe√ßa estava cheia de flores e efeitos sonoros.  Eu tentei entender como esses jogos funcionavam.  E at√© o final do ano, passei todo o meu tempo depois da escola criando c√≥pias bastante desbotadas desses jogos de arcade no meu computador dom√©stico.  Eu era como um f√£ de cultos de carga das ilhas do Oceano Pac√≠fico, que queria criar uma esta√ß√£o de r√°dio militar americana a partir de gravetos. <br><br>  No come√ßo, pensei na id√©ia de criar um emulador do <em>Pengo</em> , porque meu c√©rebro adolescente ficou muito mais impressionado com este jogo do que Bomb Jack (a prop√≥sito, aqui est√° minha <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vers√£o do Pengo para cultos de carga</a> ).  Mas o equipamento de fliperama Pengo exigiria a cria√ß√£o de novos emuladores de chip para √°udio e v√≠deo, e para o Bomb Jack j√° havia partes suficientes (Z80 como CPU e AY-3-8910 para som), ent√£o fui o primeiro a enfrentar o Bomb Jack. <br><a name="habracut"></a><br>  Al√©m disso, o Bomb Jack foi uma √≥tima oportunidade para finalmente adicionar suporte a NMI (interrup√ß√£o n√£o mascar√°vel) ao meu emulador Z80.  Nenhuma das m√°quinas baseadas em Z80 que eu emulei usava NMI e, portanto, n√£o havia muito sentido em recriar essa fun√ß√£o - eu ainda n√£o conseguia verificar seu funcionamento. <br><br>  Se voc√™ n√£o sabe o que √© o Bomb Jack, esse jogo fica assim (n√£o tenho certeza se eu escolhi a propor√ß√£o correta): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af7/79a/9ae/af779a9ae761839ee041300bc817c7f6.png" alt="Bomb jack captura de tela"></div><br><iframe width="560" height="315" src="https://www.youtube.com/embed/_jJzasm63DE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  A vers√£o do emulador no WebAssembly pode ser encontrada aqui: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://floooh.github.io/tiny8bit/bombjack.html</a> <br><br>  Ap√≥s a conclus√£o do procedimento de carregamento e a tabela de pontua√ß√£o mais alta, pressione <strong>1</strong> para soltar uma moeda e, em seguida, pressione <strong>Enter</strong> (ou qualquer outra tecla, exceto as setas e a barra de espa√ßo) para iniciar o jogo. <br><br>  Dentro do jogo, use as <strong>setas do teclado</strong> para mudar de dire√ß√£o e a <strong>barra</strong> de <strong>espa√ßo</strong> para pular.  Enquanto estiver no ar, pressione a <strong>barra</strong> de <strong>espa√ßo</strong> para diminuir a queda. <br><br>  O c√≥digo fonte est√° aqui: <br><br>  <a href="">https://github.com/floooh/chips-test/blob/master/examples/sokol/bombjack.c</a> <br><br>  Ele usa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cabe√ßalhos de chip</a> para fornecer emula√ß√£o do Z80 e AY-3-8910, al√©m de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cabe√ßalhos sokol</a> como um inv√≥lucro de plataforma cruzada (para inserir o aplicativo, renderiza√ß√£o, entrada e som). <br><br><h2>  Etapa 1: Pesquisa </h2><br>  "Pesquisa" √© uma palavra muito grande: acabei de acessar as "especifica√ß√µes de hardware de arcade Bombjack do Google". <br><br>  Comparado com os populares computadores dom√©sticos dos anos 80 (ou mesmo os misteriosos computadores da Europa Oriental, que geralmente ainda t√™m comunidades ativas), h√° muito pouca informa√ß√£o sobre o Bomb Jack na Internet. <br><br>  Encontrei duas informa√ß√µes muito importantes: o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">diagrama de circuito da</a> m√°quina e, claro, o <a href="">c√≥digo fonte do emulador MAME</a> . <br><br>  H√° tamb√©m um projeto que implementa o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bomb Jack no FGPA</a> , a partir das fontes VHDL das quais consegui descobrir detalhes que n√£o est√£o no diagrama de circuito. <br><br>  Compreender o c√≥digo fonte do MAME seria complicado, porque os emuladores de m√°quinas arcade geralmente s√£o apenas um monte de macros que descrevem como v√°rias partes do equipamento interagem, mas n√£o <em>h√°</em> muito <em>c√≥digo fonte</em> . <br><br>  No entanto, as descri√ß√µes macro do equipamento, e especialmente os coment√°rios, acabaram sendo muito √∫teis para entender a opera√ß√£o do hardware e onde se tornaram muito enigm√°ticas (por exemplo, a <a href="">parte sobre decodifica√ß√£o de v√≠deo</a> ), tentativa e erro foram suficientes, estudo detalhado do conceito. <br><br><h2>  Vis√£o geral do hardware </h2><br>  O mais interessante sobre o hardware Bomb Jack √© que na verdade s√£o <strong>dois computadores</strong> conectados entre si por uma fita isolante: existe uma <strong>placa principal</strong> com CPU Z80 e equipamento de decodifica√ß√£o de v√≠deo e uma <strong>placa de som</strong> separada com sua pr√≥pria CPU Z80 e tr√™s (sim, tr√™s!) chips de som AY-3-8910. <br><br>  O equipamento de decodifica√ß√£o de v√≠deo n√£o √© implementado como um circuito integrado - s√£o apenas muitos chips pequenos de uso geral (o circuito deles ocupa 6 em 10 p√°ginas do diagrama de circuitos do dispositivo).  Ao criar um emulador, decidi percorrer um caminho curto: em vez de emular certas partes do equipamento de decodifica√ß√£o de v√≠deo, emulei apenas seu comportamento, criando a sa√≠da correspondente a partir dos dados de entrada e n√£o me preocupando com o funcionamento do pr√≥prio equipamento no meio. <br><br>  Essa solu√ß√£o simplificada √© bastante adequada para uma m√°quina de arcade separada, projetada para executar apenas um programa.  Se o jogo iniciar e funcionar corretamente, a emula√ß√£o poder√° ser considerada "boa o suficiente". <br><br>  Al√©m disso, essa abordagem simplificada √© uma diferen√ßa importante da emula√ß√£o da maioria dos computadores dom√©sticos: alguns jogos exigem emula√ß√£o mais precisa do que outros, por exemplo, m√°quinas como C64 ou Amstrad CPC precisam de emula√ß√£o muito precisa at√© ciclos de clock, para que os sistemas de v√≠deo de alguns jogos e gr√°ficos demos funcionou corretamente. <br><br>  Isso tamb√©m significa que meus emuladores de CPU e chip de som prontos s√£o realmente um trabalho sup√©rfluo para o Bomb Jack, por exemplo, trabalhar com CPUs Z80 com a implementa√ß√£o da fracionalidade do ciclo da m√°quina √© um exagero, uma fragmenta√ß√£o mais simples e r√°pida no n√≠vel da instru√ß√£o seria suficiente. <br><br><h2>  Placa principal </h2><br>  Normalmente, a primeira coisa que tento descobrir ao escrever um novo emulador √© o esquema de aloca√ß√£o de mem√≥ria (onde est√£o as √°reas de ROM e RAM, mem√≥ria de v√≠deo e endere√ßos especiais ou portas de entrada / sa√≠da). <br><br>  Existe apenas um chip "interessante" na placa principal do Bomb Jack - o CPU Z80 operando a 4 MHz.  Todo o espa√ßo restante na placa principal √© ocupado por equipamentos de decodifica√ß√£o de v√≠deo (com exce√ß√£o de um par de chips de RAM e ROM). <br><br>  O espa√ßo de endere√ßo de 16 bits √© o seguinte: <br><br><ul><li>  <strong>0000..7FFF</strong> : ROM de 32 KB </li><li>  <strong>8000..8FFF</strong> : 4 KB de RAM de uso geral </li><li>  <strong>9000..93FF</strong> : 1 KB de mem√≥ria de v√≠deo </li><li>  <strong>9400..97FF</strong> : 1 KB de RAM colorida </li><li>  <strong>9820..987F</strong> : 96 bytes de RAM do sprite </li><li>  <strong>9C00..9CFF</strong> : 256 bytes de paleta de cores RAM </li><li>  <strong>9E00, B000..B005, B800</strong> : portas de entrada e sa√≠da </li><li>  <strong>C000..DFFF</strong> : <strong>8KB</strong> ROM </li></ul><br>  A √°rea da porta de E / S √© a seguinte.  Algumas portas s√£o somente para grava√ß√£o, outras s√£o somente leitura e algumas t√™m fun√ß√µes diferentes ao ler e gravar nelas: <br><br><ul><li>  <strong>9E00</strong> : write: n√∫mero da imagem de fundo atual, leia: - </li><li>  <strong>B000</strong> : leitura: estado do joystick do jogador 1, grava√ß√£o: ativar / desativar a m√°scara NMI </li><li>  <strong>B001</strong> : leia: estado do joystick do jogador 2, escreva: - </li><li>  <strong>B002</strong> : leia: moedas e bot√µes Iniciar, escreva: - </li><li>  <strong>B003</strong> : leia: watchdog da CPU, escreva: ??? </li><li>  <strong>B004</strong> : leitura: interruptores dip 1, grava√ß√£o: comutador de tela </li><li>  <strong>B005</strong> : leia: dip switches 2, escreva: - </li><li>  <strong>B800</strong> : write: command placa de som, leia: - </li></ul><br>  Vale a pena mencionar aqui: <br><br><ul><li>  O dispositivo possui MUITA ROM (40 Kbytes) e muito pouca RAM (cerca de 7 Kbytes, e apenas 4 Kbytes deles s√£o "RAM de uso geral") </li><li>  Apenas 2 Kbytes s√£o alocados para a RAM da tela, divididos em dois fragmentos de 1 Kbyte, o que parece muito pequeno para uma tela colorida de 256x256, na qual, ao que parece, as cores s√£o definidas pixel por pixel </li><li>  Este √© um sistema de E / S em um esquema de aloca√ß√£o de mem√≥ria! </li></ul><br>  A E / S no esquema de aloca√ß√£o de mem√≥ria √© um pouco incomum para uma m√°quina Z80, porque uma das caracter√≠sticas do Z80 √© o espa√ßo de endere√ßo de 16 bits separado para E / S.  Isso √© feito para economizar espa√ßo valioso no endere√ßo de mem√≥ria.  A E / S em um esquema de aloca√ß√£o de mem√≥ria √© normalmente encontrada em computadores com um processador 6502. <br><br>  Uma olhada no diagrama de circuitos confirma isso: o pino IORQ n√£o √© detectado na CPU da placa principal, apenas o pino MREQ est√° conectado (que √© usado para inicializar a leitura ou grava√ß√£o na mem√≥ria): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a58/99e/3d8/a5899e3d8384702517d0c7fe6c0de436.png" alt="Bomb Jack IORQ"></div><br>  Isso significa que n√£o precisamos nos preocupar com solicita√ß√µes de E / S para a fun√ß√£o de timer da CPU da placa principal no emulador, mas apenas com solicita√ß√µes de mem√≥ria. <br><br>  Tendo estudado o diagrama de circuitos, encontrei outro detalhe interessante sobre a CPU da placa principal: <br><br>  Somente o pino NMI est√° conectado, enquanto o pino INT sempre mant√©m um alto n√≠vel de sinal de rel√≥gio / permanece inativo (isso significa que as interrup√ß√µes mascaradas "usuais" n√£o s√£o executadas e ocorrem apenas interrup√ß√µes n√£o mascaradas): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/393/acf/cb8/393acfcb88d846cc868e2fa0e490fbbd.png" alt="Bomb Jack IORQ"></div><br>  Isso tamb√©m √© bastante incomum para um carro com o Z80.  Em todos os computadores dom√©sticos baseados em Z80 com os quais eu costumava lidar, o oposto era verdadeiro - eles usavam apenas interrup√ß√µes mascar√°veis ‚Äã‚Äãe nunca usavam n√£o-mascar√°veis.  A interrup√ß√£o mascarada Z80 √© uma melhoria muito flex√≠vel e s√©ria em compara√ß√£o com o sistema de interrup√ß√£o primitivo de seu "pai ileg√≠timo" - Intel 8080, ou seu concorrente - MOS 6502. Mas esse aumento da flexibilidade tamb√©m √© mais dif√≠cil de implementar em equipamentos (a menos que seja uma fonte de interrup√ß√µes) outros chips da fam√≠lia Z80 s√£o usados, nos quais j√° existe um protocolo de interrup√ß√£o complexo incorporado quando conectado por barramento). <br><br>  Bem, detalhes suficientes sobre o equipamento, vamos para o emulador! <br><br><h2>  Procedimento de inicializa√ß√£o </h2><br>  O pr√≥ximo passo ap√≥s determinar a configura√ß√£o da mem√≥ria √© conectar a CPU emulada ao esquema de aloca√ß√£o de mem√≥ria emulada, registrar algum tipo de visualiza√ß√£o do conte√∫do da mem√≥ria de v√≠deo e iniciar os ciclos da CPU. <br><br>  Surpreendentemente, uma abordagem t√£o √°spera √© muitas vezes suficiente para passar pelo procedimento de carregamento e exibir <em>algo</em> na tela.  Ao projetar o emulador de Bomb Jack, peguei o conte√∫do da mem√≥ria de v√≠deo de 1 KB no intervalo de 0x9000 a 0x93FF como uma matriz de 32x32 bytes.  Quando o byte era 0, renderizei um bloco de pixels pretos 8x8 e, caso contr√°rio, um bloco de pixels brancos. <br><br>  Ent√£o eu apenas executei a CPU emulada e esperava o melhor.  Eis!  Algum tipo de imagem leg√≠vel apareceu: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/17d/7c2/198/17d7c2198881dbfd40978e26d832aaca.png" alt="Bomb jack boot 1"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d3b/e04/b97/d3be04b970ff2c8b5905ed3f7f757a51.png" alt="Bomb jack boot 2"></div><br>  A imagem superior se parece com uma tela de teste de hardware na inicializa√ß√£o e a parte inferior se parece com uma tela de registro de pontua√ß√£o que aparece ap√≥s a conclus√£o do procedimento de inicializa√ß√£o: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f6/5ae/4b9/0f65ae4b9d00fa43e2da7582b9ceb5f3.png" alt="Bomb jack boot 3"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/649/5c8/db1/6495c8db1d035484ef03e32902f28cdf.png" alt="Bomb jack boot 4"></div><br>  ... mas girou 90 graus (o que √© l√≥gico, porque a tela das m√°quinas de fliperama costumava estar na orienta√ß√£o "retrato" vertical). <br><br>  √ìtimo, o come√ßo √© promissor! <br><br>  O pr√≥ximo passo √© descobrir como transformar esses blocos brancos em pixels coloridos ... (e este √© um passo enorme, os detalhes s√£o descritos abaixo na se√ß√£o sobre decodifica√ß√£o de v√≠deo). <br><br>  No in√≠cio, tudo foi muito r√°pido, na tela de teste, pixels e cores foram exibidos durante o carregamento (mais tarde, notei que a decodifica√ß√£o de cores estava completamente errada e, no entanto ...): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c3/ecd/757/2c3ecd757e603194698f6f93b71e3127.png" alt="Bomb jack boot 5"></div><br>  Mas quando a tela de grava√ß√£o deveria aparecer, eu tinha uma tela preta.  Cortando a cor do plano de fundo para que ‚Äún√£o seja preto‚Äù, descobri que os pixels s√£o renderizados, mas toda a paleta de cores √© preta.  Hmm ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e81/dac/2e4/e81dac2e4796b7bf90d43a711a52f37e.png" alt="Bomb jack boot 5"></div><br>  Depois de olhar para essa tela por alguns minutos, lembrei-me de que algumas cores na tela de recordes s√£o animadas e, quando h√° anima√ß√£o, deve haver algum tipo de temporizador.  A fonte l√≥gica de tempo nesta configura√ß√£o de equipamento ser√° o sinal VSYNC do monitor e o VSYNC conectado ao pino NMI da CPU (ou melhor, n√£o o VSYNC, mas o VBLANK, que √© o breve momento entre o sinal VSYNC e o feixe de raios cat√≥dicos que se move para o canto superior esquerdo). <br><br>  E ainda n√£o implementei tudo isso ... <br><br>  Na noite seguinte, quando adicionei a primeira vers√£o do processamento NMI √† emula√ß√£o Z80 e a conectei ao primeiro contador vsync / vblank na fun√ß√£o de timer da CPU da placa principal, muitas coisas de repente come√ßaram a acontecer! <br><br>  Em primeiro lugar, as cores apareceram na tela de registros e algumas foram animadas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/163/661/72d/16366172d4eb6b8e2342acbbd74a64ac.png" alt="Bomb Jack NMI 1"></div><br>  Depois de alguns segundos, algo ainda mais emocionante come√ßou!  O recorde desapareceu e uma visualiza√ß√£o estranha do primeiro mapa foi exibida.  Ficou claro que este √© um modo de demonstra√ß√£o de uma m√°quina de fliperama para atrair aten√ß√£o - vi v√°rias bombas com anima√ß√µes coloridas que desapareceram quando um imagin√°rio Bomb Jack pulou em um mapa coletando essas bombas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d60/cd6/81d/d60cd681dedbdfbf4329410e0014f9f0.png" alt="Bomb Jack NMI 2"></div><br>  As cores ainda estavam completamente erradas e, no entanto, √© PROGRESS! <br><br>  √â o momento certo para fazer o resto da decodifica√ß√£o de v√≠deo: <br><br><h2>  Ferro de v√≠deo </h2><br>  √Ä primeira vista, o equipamento de processamento de v√≠deo em Bomb Jack parecia muito poderoso para uma m√°quina de 8 bits desde 1984: apesar da resolu√ß√£o de apenas 256x256 pixels, podia exibir simultaneamente 128 (de 4096) cores e renderizar at√© 24 sprites de hardware (tamanho 16x16) ou 32 x 32) com pixel por pixel. <br><br>  Os computadores dom√©sticos de 8 bits da √©poca tinham aproximadamente a mesma resolu√ß√£o de tela, mas tinham muitas restri√ß√µes de cores.  Essas restri√ß√µes s√£o claramente vis√≠veis ao comparar as vers√µes Bomb Jack para o ZX Spectrum e Amstrad CPC com a vers√£o para a m√°quina de arcade: <br><br>  A <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vers√£o para o ZX Spectrum</a> tinha uma resolu√ß√£o de pixel bastante boa (256x192), mas muito poucas cores, e sofria com o efeito t√≠pico de "conflito de cores" do Spectrum (embora os desenvolvedores tenham se esfor√ßado para n√£o ser percept√≠vel): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/46d/176/fff/46d176fffb8404ad696883849dd880d1.png" alt="Bomb jack zx"></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A vers√£o do Amstrad CPC √©</a> mais colorida, mas, para obter mais cores, os desenvolvedores tiveram que mudar para o modo de exibi√ß√£o de baixa resolu√ß√£o (160x200).  Como resultado disso, Jack e os monstros se transformaram em um monte ileg√≠vel de pixels: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bbd/f33/3d8/bbdf333d8e4d8d44735047f99e53b49c.png" alt="Bomb jack cpc"></div><br>  Compare isso com a vers√£o da m√°quina de fliperama, que tinha a mesma resolu√ß√£o de pixel que o ZX Spectrum, mas com muito mais cores <em>e</em> maior resolu√ß√£o de cores pixel por pixel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/112/ac5/69f/112ac569f11f32d6c1ed4836bb8c2b51.png" alt="Bomb jack arcade"></div><br>  O interessante aqui √© que a vers√£o arcade possui gr√°ficos melhores, n√£o porque funciona em hardware mais poderoso (possui mais ROMs para armazenar mais dados gr√°ficos, mas o "poder de computa√ß√£o" √© o mesmo), mas porque os desenvolvedores do dispositivo podem se concentrar na fabrica√ß√£o de uma m√°quina especializada para um tipo espec√≠fico de jogo e eles n√£o precisavam criar um computador dom√©stico universal para uso geral. <br><br>  Veja como o hardware da tela funciona (pelo menos na minha interpreta√ß√£o de alto n√≠vel): <br><br><h2>  Tr√™s camadas de exibi√ß√£o </h2><br>  O sinal de v√≠deo final do Bomb Jack √© combinado de tr√™s camadas: uma camada de fundo, uma camada frontal e uma camada de sprite. <br><br>  Esse sistema de camadas tem duas vantagens principais: <br><br><ul><li>  Ele implementa uma compacta√ß√£o de imagem de hardware bastante complicada para gerar uma imagem colorida de "alta resolu√ß√£o" a partir de uma quantidade muito pequena de dados. </li><li>  Reduz significativamente a quantidade de trabalho da CPU necess√°ria para atualizar os elementos din√¢micos da tela (mesmo a uma frequ√™ncia de 4 MHz, uma CPU de 8 bits n√£o tem energia suficiente para mover um n√∫mero t√£o grande de objetos em uma tela de 256x256 com uma frequ√™ncia de 60 Hz) </li></ul><br>  O ferro de v√≠deo √© bem diferente do que vi nos computadores dom√©sticos de 8 bits, mas o MAME implementa classes auxiliares generalizadas para esse tipo de equipamento, por isso posso assumir que √© bastante comum em m√°quinas de fliperama. <br><br><h3>  Camada de fundo </h3><br>  A camada de fundo pode renderizar 1 entre 5 imagens de fundo incorporadas na ROM.  A imagem de fundo √© selecionada escrevendo um valor de 1 a 5 no endere√ßo 0x9E00 (parece que o valor 0 √© especial e renderiza um fundo completamente preto). <br><br>  De fato, parece que o equipamento √© capaz de renderizar 7 imagens diferentes, mas apenas 5. s√£o usadas no jogo. Secretamente, eu esperava encontrar dados de imagem anteriormente n√£o detectados na ROM.  Mas, infelizmente, eles n√£o est√£o l√° (sim, provavelmente n√£o sou o primeiro a procur√°-los l√°). <br><br>  Aqui est√° a apar√™ncia da camada de segundo plano do primeiro mapa sem as outras duas camadas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/afe/75a/2c7/afe75a2c7386bb48fb3e90e2a24a655e.png" alt="Fundo de jack bomba"></div><br>  A camada de fundo √© montada a partir de blocos de <strong>16x16</strong> pixels. <br><br>  A vantagem de criar imagens de plano de fundo a partir de blocos √© que os mesmos blocos podem ser usados ‚Äã‚Äãv√°rias vezes, para que menos dados possam ser armazenados na ROM.  Observe que o c√©u azul, partes da pir√¢mide e areia sob a pir√¢mide usam os mesmos azulejos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/422/613/0ee/4226130ee4b597ccbeccebbce664dbdf.png" alt="Telhas de fundo de jack bomba"></div><br>  Para economizar mem√≥ria, o equipamento da camada de segundo plano implementa outro truque - os ladrilhos podem ser girados horizontalmente.  Quase perdi isso na minha implementa√ß√£o porque presumi que o software n√£o usasse essa fun√ß√£o de hardware, mas notei um pequeno bug no fundo da terceira placa: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22d/397/d5c/22d397d5c5b984b8a7b1e7c53e5abd34.png" alt="Bomba jack fundo 3"></div><br>  Usei o mesmo truque no quinto mapa, mas aqui √© um pouco mais dif√≠cil de perceber se voc√™ n√£o sabe o que procurar: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4af/82d/430/4af82d430deab8804a795ac9fb142b87.png" alt="Bomba de fundo 5"></div><br><br><h3>  Camada frontal: </h3><br>  Acima da camada de fundo est√° a ‚Äúcamada frontal‚Äù, que renderiza todas as partes fixas da tela, que, no entanto, devem ser atualizadas pela CPU (principalmente texto, plataformas e bombas).  O layout √© lido da RAM (de fragmentos de 1 KB de RAM e 1 KB de cor). <br><br>  Aqui est√° a apar√™ncia da camada frontal isolada do primeiro mapa: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/874/5ac/fa8/8745acfa89c446ba9b5a9d9e719c8d31.png" alt="Primeiro plano de bomba jack"></div><br>  A camada frontal tamb√©m consiste em blocos (assim como no plano de fundo), mas usa blocos menores de 8x8: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a9/e26/f94/5a9e26f94d1d9e0df0f50f4f1d1beb78.png" alt="Telhas de fundo de jack bomba"></div><br>  A principal vantagem de dividir o fundo e a frente em camadas separadas √© que a CPU n√£o precisa se preocupar em armazenar e restaurar pixels de fundo ao criar ou excluir elementos da frente. <br><br><h3>  Camada de Sprite </h3><br>  Finalmente, sprites de hardware s√£o renderizados sobre a camada frontal.  Tudo o que se move pela tela √© implementado em sprites.  O equipamento Bomb Jack pode renderizar at√© 24 sprites, e cada sprite pode ter um tamanho de 16x16 ou 32x32 pixels.  Nesse caso, os sprites podem ser posicionados com precis√£o pixel por pixel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/276/66e/5a0/27666e5a0a266d28babf72dafe2e66bc.png" alt="Sprites de jack de bomba"></div><br><br><h2>  Decodificador 8x8 lado a lado </h2><br>  No cora√ß√£o do equipamento de decodifica√ß√£o de v√≠deo est√° uma paleta de cores com 128 elementos e um decodificador de blocos de 8x8 pixels.  A tarefa do decodificador de bloco √© gerar um √≠ndice de paleta de cores de 7 bits para cada um dos 64 pixels do bloco. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esses blocos 8x8 s√£o os blocos de constru√ß√£o de tudo na tela - blocos 16x16 em segundo plano, blocos 8x8 na camada frontal e sprites de hardware 16x16 ou 32x32. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui est√° um diagrama de blocos deste decodificador de blocos 8x8 para renderizar a camada frontal (como eu a entendi):</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e79/d6e/5d9/e79d6e5d9b5019923a37bc14658e8ec4.jpg" alt="Decodifica√ß√£o de Bomb Jack Tile"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Explica√ß√£o do diagrama de blocos de cima para baixo: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O processo de decodifica√ß√£o come√ßa na parte superior, lendo o byte do ‚Äúc√≥digo de bloco‚Äù da mem√≥ria de v√≠deo (organizado como uma matriz de c√≥digos de bloco 32x32) e um byte separado da RAM colorida (tamb√©m uma matriz 32x32). </font><font style="vertical-align: inherit;">A obten√ß√£o dos c√≥digos de ladrilhos e cores da mem√≥ria de v√≠deo ocorre apenas na camada frontal, mas eu a adicionei para tornar a imagem como um todo mais compreens√≠vel. </font><font style="vertical-align: inherit;">O decodificador de bloco 8x8 requer apenas um c√≥digo de bloco e cor na entrada.</font></font></li><li>             .         (         ).         ,       ,    (       ). </li><li>       8   ,     8  (   ).            ,  ,       8x8  24    (3   ). </li><li>    64    7- .  3         ,   4  ‚Äî    .  ,  ,           16 ¬´¬ª,     8 .        8     . </li><li>  7- ,        ,    12-  RGB-    (4    ).            (  ,  ,       ;   ,          ). </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Este √© um esquema geral de decodifica√ß√£o de blocos que √© usado por cada uma das tr√™s camadas de exibi√ß√£o, mas a decodifica√ß√£o de cada camada √© um pouco diferente: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A camada frontal pode render 512 blocos diferentes de 8x8. </font><font style="vertical-align: inherit;">Isso requer c√≥digos de bloco de 9 bits, mas a mem√≥ria de v√≠deo fornece apenas 8 bits por bloco. </font><font style="vertical-align: inherit;">O nono bit √© "emprestado" do quinto bit do valor da cor (como apenas 4 bits do valor da cor s√£o usados ‚Äã‚Äãpara construir o √≠ndice da paleta de cores, restam mais 4 bits para outros fins). </font><font style="vertical-align: inherit;">Se todos os 3 bits das camadas de 8x8 lado a lado forem iguais a zero, o pixel frontal ser√° considerado transparente e o pixel de segundo plano "brilhar√°" nele.</font></font></li><li>      16x16,     16x16=256     256           (512   ).    ,     16x16      8x8,        .   ,      ;      ¬´¬ª   :   7   ,    . </li><li>       16x16   32x32 ,       4  16   8x8    .  ,    16x16  96 ,    32x32 ‚Äî    384    .       ,   3      ,    . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para entender melhor a apar√™ncia das camadas de bloco, escrevi um pequeno </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">programa C</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que converte blocos de ROM em arquivos PNG (3 bits por pixel convertido em 8 n√≠veis de escala de cinza). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A seguir, s√£o mostrados os blocos de ROM da camada frontal. </font><font style="vertical-align: inherit;">Vemos n√∫meros e dados de fontes de texto, blocos de plataforma, bombas (divididas ao meio), partes do logotipo do protetor de tela Bomb Jack e o n√∫mero de multiplicadores de pontua√ß√£o que aparecem na parte superior da tela (a prop√≥sito, tudo gira 90 graus, porque a tela inteira tamb√©m √© girada ):</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/681/ca4/fec/681ca4fec37418dffeb4d601b9e787cf.png" alt="ROM de telha de primeiro plano de bomba Jack"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, considere os blocos de ROM do plano de fundo. </font><font style="vertical-align: inherit;">N√£o parece muito claro, porque o que observamos √© na verdade decodificando blocos 16x16 para blocos 8x8. </font><font style="vertical-align: inherit;">Cada bloco 16x16 √© criado a partir de quatro blocos 8x8 adjacentes. </font><font style="vertical-align: inherit;">Mas voc√™ pode reconhecer partes do templo grego no mapa 2, o castelo no mapa 3 e os arranha-c√©us no mapa 4.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ebc/fa9/86d/ebcfa986da9add0a45acc02b54bcb69e.png" alt="ROM de telha de fundo de bomba Jack"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E, finalmente, ROM sprite tiles. </font><font style="vertical-align: inherit;">Sprites de 16x16 ocupam a metade superior e sprites de 32x32 ocupam a metade inferior.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/444/974/01e/44497401e4d25c7915f1c15c9fb9f4ac.png" alt="Bomba Jack Sprite Tile ROM"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um truque interessante do protetor de tela de Bomb Jack √© que o logotipo √© montado a partir dos mosaicos e sprites da frente. </font><font style="vertical-align: inherit;">Acho que os desenvolvedores estavam ficando sem ROMs do bloco frontal, mas havia pouco espa√ßo na ROM do sprite:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/939/bd5/b69/939bd5b6999622ee26e337f033087234.png" alt="Bomb Jack Splash 1"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d9/fef/f2a/6d9feff2acdd4ee2aaa63b8dc4226692.png" alt="Bomb Jack Splash 2"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/819/bb9/072/819bb90727322463b2c8a9196f6f74c2.png" alt="Bomb Jack Splash 3"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Equipamento de Sprite </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O equipamento de sprite Bomb Jack √© muito poderoso comparado ao usado em computadores dom√©sticos da √©poca: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pode renderizar at√© 24 sprites de hardware. </font><font style="vertical-align: inherit;">Parece que n√£o havia restri√ß√µes no n√∫mero de sprites por linha de varredura.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Os sprites podem ter um tamanho de 16x16 pixels ou 32x32 pixels </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cada sprite pode escolher um dos 16 slots de 8 cores em uma paleta de cores comum </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sprites tinham resolu√ß√£o de cor pixel por pixel. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cada sprite pode ser invertido verticalmente ou horizontalmente </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cada sprite pode escolher uma das 128 imagens de sprite exibidas na ROM. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao decodificar pixels e sprites de um sistema de sprites, o mesmo bloco base 8x8 √© usado como nas camadas frontal e de fundo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os atributos do Sprite est√£o localizados no intervalo de endere√ßos de 0x9820 a 0x987F - 96 bytes, 4 bytes por sprite. </font><font style="vertical-align: inherit;">At√© onde eu vi, essa √°rea √© apenas para grava√ß√£o; </font><font style="vertical-align: inherit;">pelo menos a CPU n√£o realiza acesso de leitura a esse intervalo de mem√≥ria. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada sprite √© descrito por 4 bytes:</font></font><br><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Byte 0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bit 7</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : se definido, este √© um sprite de 32x32, caso contr√°rio, 16x16</font></font></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bits 6..0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : 7 bits para definir o c√≥digo do bloco de sprites usado para procurar camadas de bits da imagem do sprite nos blocos de ROM.</font></font></li></ul></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Byte 1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bit 7</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : se definido, o sprite √© invertido horizontalmente</font></font></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bit 6</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : se definido, o sprite √© invertido verticalmente</font></font></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bits 3..0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : 4 bits para definir o valor da cor para o decodificador de </font><strong><font style="vertical-align: inherit;">blocos</font></strong></font></li></ul><br></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Byte 2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : posi√ß√£o do sprite do eixo X na tela</font></font></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Byte 3</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : posi√ß√£o do sprite na tela ao longo do eixo Y</font></font></li></ul><br>  N√£o est√° claro o que os bits 4 e 5 do byte 1 fazem, o coment√°rio em MAME diz o seguinte: <br><br> <code>e ? (,    ) <br> f ? (,     (B)?)</code> <br> <br><h2>  Portas de E / S de mem√≥ria </h2><br>  Algumas notas nas portas de entrada / sa√≠da da placa principal.  Como afirmado acima, as portas de E / S s√£o assim: <br><br><ul><li>  <strong>9E00</strong> : write: n√∫mero da imagem de fundo atual, leia: - </li><li>  <strong>B000</strong> : leitura: estado do joystick do jogador 1, grava√ß√£o: ativar / desativar a m√°scara NMI </li><li>  <strong>B001</strong> : leia: estado do joystick do jogador 2, escreva: - </li><li>  <strong>B002</strong> : leia: moedas e bot√µes Iniciar, escreva: - </li><li>  <strong>B003</strong> : leia: watchdog da CPU, escreva: ??? </li><li>  <strong>B004</strong> : leitura: interruptores dip 1, grava√ß√£o: comutador de tela </li><li>  <strong>B005</strong> : leia: dip switches 2, escreva: - </li><li>  <strong>B800</strong> : write: command placa de som, leia: - </li></ul><br>  O endere√ßo 0x9E00 (sele√ß√£o da imagem de plano de fundo) que j√° consideramos acima e o endere√ßo 0xB800 (placa de som de comando) que consideraremos na pr√≥xima se√ß√£o.  Permanece os endere√ßos de 0xB000 a 0xB005: <br><br>  A leitura dos endere√ßos 0xB000 e 0xB001 retorna o estado atual dos dois joysticks.  Os bytes definidos indicam os interruptores fechados do joystick: <br><br><ul><li>  <strong>bit 0</strong> : dire√ß√£o certa </li><li>  <strong>bit 1</strong> : dire√ß√£o esquerda </li><li>  <strong>bit 2</strong> : dire√ß√£o ascendente </li><li>  <strong>bit 3</strong> : dire√ß√£o descendente </li><li>  <strong>bit 4</strong> : bot√£o de salto pressionado </li></ul><br>  Os 3 bits restantes s√£o ignorados. <br><br>  A leitura de 0xB002 retorna o status do aceitador de moedas e os bot√µes Iniciar: <br><br><ul><li>  <strong>bit 0</strong> : a moeda do jogador 1 √© lan√ßada </li><li>  <strong>bit 1</strong> : a moeda do jogador 2 √© lan√ßada </li><li>  <strong>bit 2</strong> : bot√£o iniciar do jogador 1 </li><li>  <strong>bit 3</strong> : bot√£o iniciar do jogador 2 </li></ul><br>  A leitura dos endere√ßos 0xB004 e 0xB005 retorna o estado dos comutadores DIP usados ‚Äã‚Äãpara configurar o comportamento da m√°quina arcade: <br><br><ul><li>  <strong>B004</strong> : <br><ul><li>  <strong>bits 0,1</strong> : quantos "jogos" s√£o dados por uma moeda (1, 2, 3 ou 5) </li><li>  <strong>bits 2,3</strong> : o mesmo para o jogador 2 </li><li>  <strong>bits 4,5</strong> : quantas vidas por jogo (3, 4, 5 ou 2) </li><li>  <strong>bit 6</strong> : a localiza√ß√£o da m√°quina de arcade: ‚Äúmesa de coquetel‚Äù ou ‚Äúvertical‚Äù. </li><li>  <strong>bit 7</strong> : se √© para reproduzir som no modo de espera </li></ul></li><li>  <strong>B005</strong> : <br><ul><li>  <strong>bits 3.4</strong> : dificuldade 1 (velocidade das aves) </li><li>  <strong>bits 5,6</strong> : dificuldade 2 (n√∫mero e velocidade dos inimigos) </li><li>  <strong>bit 7</strong> : frequ√™ncia de ocorr√™ncia de uma moeda espec√≠fica </li></ul></li></ul><br>  Finalmente, a leitura do endere√ßo <strong>B003</strong> implementa um watchdog de software.  A CPU deve frequentemente ler este endere√ßo, caso contr√°rio, a m√°quina arcade executar√° uma redefini√ß√£o de hardware.  Se, por algum motivo, o jogo travar, o equipamento ser√° reiniciado automaticamente. <br><br>  Voc√™ pode gravar em alguns endere√ßos de porta de E / S: <br><br><ul><li>  <strong>B000</strong> : se deve gerar NMI durante o vblank;  parece estar desativado apenas durante o procedimento de inicializa√ß√£o </li><li>  <strong>B004</strong> : vira a tela inteira;  Nunca conheci o uso dessa fun√ß√£o, mas tenho uma teoria sobre isso (veja abaixo) </li></ul><br>  A funcionalidade de invers√£o de tela √© um pouco confusa, porque ao jogar um jogo, nunca vi seu uso.  No entanto, tenho um palpite sobre o que ele est√° fazendo, mas para confirmar, voc√™ precisa escrever um c√≥digo.  Quando a m√°quina de fliperama est√° na configura√ß√£o de "mesa de coquetel", dois jogadores se sentam um em frente ao outro.  Portanto, sugeri que, quando um jogo muda do jogador 1 para o jogador 2, essa fun√ß√£o vira a tela.  No entanto, ainda n√£o implementei o modo para dois jogadores no emulador. <br><br><h2>  Placa de som </h2><br>  A placa de som em si √© um computador completo com uma CPU Z80 (operando na frequ√™ncia de 3 MHz), tr√™s chips de som (AY-38910 operando na frequ√™ncia de 1,5 MHz), al√©m de RAM e ROM.  O esquema de aloca√ß√£o de mem√≥ria da placa de som parece bastante simples: <br><br><ul><li>  <strong>0000..2000</strong> : 8 Kbytes de ROM </li><li>  <strong>4000..4400</strong> : 1 KB de RAM </li><li>  <strong>6000</strong> : comando de som da placa principal </li></ul><br>  Como n√£o h√° nada interessante no esquema de aloca√ß√£o de mem√≥ria acima do endere√ßo 0x8000, o contato de endere√ßo mais alto da CPU nem est√° conectado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2f/4ea/35e/b2f4ea35ee4d2861ea1baa502da10837.png" alt="Bomb Jack Sound A15"></div><br>  O endere√ßo especial 0x6000 √© a porta de E / S (trava de 8 bits) localizada na mem√≥ria, que n√£o corresponde √† RAM real.  Essa √© a mesma porta que est√° localizada na placa principal em 0xB800.  √â um canal de comunica√ß√£o entre as placas principal e de som. <br><br>  Os tr√™s chips de som s√£o controlados por estas instru√ß√µes de sa√≠da do Z80, n√£o pelas portas de mem√≥ria.  O AY-3-8910 possui apenas duas portas de E / S abertas, a primeira √© usada para armazenar o n√∫mero do registro e a segunda √© usada para gravar ou ler o conte√∫do do registro especificado pela primeira porta. <br><br>  O circuito de E / S √© o seguinte: <br><br><ul><li>  <strong>0x00</strong> : primeiro chip de som: sele√ß√£o de registro </li><li>  <strong>0x01</strong> : primeiro chip de som: acesso ao registro selecionado </li><li>  <strong>0x10</strong> : segundo chip de som: sele√ß√£o de registro </li><li>  <strong>0x11</strong> : segundo chip de som: acesso ao registro selecionado </li><li>  <strong>0x80</strong> : terceiro chip de som: sele√ß√£o de registro </li><li>  <strong>0x81</strong> : terceiro chip de som: acesso ao registro selecionado </li></ul><br>  Algumas palavras sobre o chip de som AY-3-8910: <br><br>  Este √© um dispositivo bastante padr√£o, muito popular nos computadores dom√©sticos da √©poca (por exemplo, no Amstrad CPC, no ZX Spectrum 128, nos computadores MSX e em muitos outros).  O AY-3-8910 gerou muitas varia√ß√µes e clones (por exemplo, a Yamaha YM2149, que por si s√≥ se tornou a base de toda uma fam√≠lia de chips de som mais poderosos). <br><br>  O AY-3-8910 possui 3 canais de sinais retangulares, um gerador de ru√≠do que pode ser misturado com tr√™s canais e um gerador de envelope.  Como havia apenas um gerador de envelope para os tr√™s canais, n√£o era particularmente √∫til, e a maioria dos jogos usava uma CPU para modular o tom e o volume. <br><br>  Isso significa que o chip AY-3-8910 requer mais interven√ß√£o da CPU para criar som de alta qualidade (diferente de outros chips SID independentes, por exemplo, em um computador C64). <br><br>  √â incr√≠vel ver o que pode ser feito em tr√™s chips de som bastante simples e na CPU que os controla.  A m√∫sica e os efeitos sonoros de Bomb Jack s√£o muito mais ricos do que eu ouvi na maioria dos jogos de computador dom√©stico. <br><br>  A √∫nica coisa realmente interessante nesta placa de som √© a maneira como ela recebe seus comandos da placa principal. <br><br><h2>  Trava de comando de som </h2><br>  A ‚Äútrava de som‚Äù √© um armazenamento de byte √∫nico (trava de 8 bits) comum √†s placas principal e de som.  A trava est√° vinculada ao endere√ßo 0xB800 na placa principal e ao endere√ßo 0x6000 na placa de som. <br><br>  Quando a interrup√ß√£o da NMI √© ativada usando o VSYNC, a placa de som executa uma rotina de servi√ßo de interrup√ß√£o muito simples, que l√™ a trava do hardware, grava no endere√ßo de mem√≥ria normal e define o "bit de sinal", que informa ao "loop principal" que um novo comando de som foi recebido: <br><br><pre> <code class="plaintext hljs"> ex af,af' ;0066 exx ;0067 ld hl,04390h ;0068 set 0,(hl) ;006b ld a,(06000h) ;006d ld (04391h),a ;0070 exx ;0073 ex af,af' ;0074 retn ;0075</code> </pre> <br>  O m√©todo de ativa√ß√£o de contato da NMI √© um pouco diferente do m√©todo da placa principal: <br><br>  Na placa principal, o pino NMI se torna ativo durante a execu√ß√£o do VBLANK. <br><br>  No entanto, na placa de som, a NMI √© ativada quando o VSYNC √© acionado e permanece ativo n√£o durante o VBLANK, mas at√© o procedimento de servi√ßo de interrup√ß√£o ler os dados da trava em 0x6000. <br><br>  Quando o equipamento reconhece a leitura do endere√ßo 0x6000, ele executa duas opera√ß√µes codificadas: <br><br><ul><li>  o conte√∫do do clipe de som √© redefinido para 0 </li><li>  O contato com a MNI se torna inativo </li></ul><br>  De fato, esta √© uma simples elimina√ß√£o do ressalto de contato, que n√£o permite que um comando de som seja executado duas vezes. <br><br>  A √∫nica quest√£o permanece: com que freq√º√™ncia a placa principal escreve um novo comando (porque a maneira de implementar a emula√ß√£o de duas placas depende disso). <br><br>  Ap√≥s a depura√ß√£o com printf, descobri que a placa principal registra no m√°ximo um comando de som por quadro de 60 Hz.  Isso simplificou bastante a estrutura do "ciclo principal" do emulador. <br><br>  O problema do trabalho conjunto de dois computadores emulados separados que precisam trocar dados entre si √© que a emula√ß√£o de um computador √© efetiva apenas se puder executar muitos ciclos de cada vez sem interfer√™ncia. <br><br>  Por exemplo, o pior caso seria: <br><br><ul><li>  n√≥s executamos uma instru√ß√£o no computador 1 </li><li>  n√≥s executamos uma instru√ß√£o no computador 2 </li><li>  repita ... </li></ul><br>  Meu emulador Z80 n√£o √© otimizado para sair e inserir emula√ß√£o para cada instru√ß√£o, pois nesse caso ele deve liberar na mem√≥ria e carregar da mem√≥ria o estado da CPU no in√≠cio e no final de cada instru√ß√£o.  Se a CPU puder processar muitas instru√ß√µes sem interfer√™ncia, voc√™ poder√° armazenar (a maior parte) o estado da CPU nos registradores e redefinir o estado para a mem√≥ria na √∫ltima instru√ß√£o. <br><br>  Ou seja, uma situa√ß√£o ideal seria a seguinte: executamos um sistema emulado sem interfer√™ncia em todo o quadro do sistema host (para uma CPU com uma frequ√™ncia de 4 MHz e 60 Hz, isso significa cerca de 67 mil ciclos por quadro, ou algo entre 3 mil e 16 mil instru√ß√µes Z80). <br><br>  Ao trabalhar com Bomb Jack, eu precisava garantir que a placa principal n√£o registrasse um novo comando antes que a placa de som pudesse ler o √∫ltimo comando.  Antes de descobrir que a placa principal registra n√£o mais de um comando por quadro, considerei a necessidade de criar uma fila complexa de comandos que interceptasse grava√ß√µes na trava de som da placa principal e armazenasse o n√∫mero do ciclo e o byte de comando na fila. <br><br>  Ent√£o, no momento em que a placa de som estava executando seu quadro, seria necess√°rio um novo comando da fila de comandos quando o n√∫mero do ciclo de comando era atingido. <br><br>  Esse sistema funcionaria e seria "correto", mas aumentaria bastante a complexidade do c√≥digo. <br><br>  No final, decidi usar uma solu√ß√£o muito mais simples, sem filas.  Como a placa principal registra apenas um comando por quadro, alternei a execu√ß√£o em dois computadores para que cada um deles executasse duas faixas de tempo por quadro: <br><br><ul><li>  execute a primeira metade do quadro na placa principal </li><li>  execute a primeira metade do quadro na placa de som </li><li>  execute a segunda metade do quadro na placa principal </li><li>  execute a segunda metade do quadro na placa de som </li></ul><br>  Isso garante que a placa de som veja corretamente todos os comandos gravados pela placa principal e, ao mesmo tempo, execute cada emula√ß√£o por milhares de ciclos. <br><br>  Obviamente, o fato de o sistema host operar a uma taxa de quadros de 60 Hz √© uma suposi√ß√£o muito ousada :) <br><br><h2>  E o ultimo ... </h2><br>  O √∫ltimo fato interessante sobre a vers√£o do emulador no WebAssembly: <br><br>  Tamanho compactado de todos os arquivos baixados ao executar o emulador no WebAssembly <br>  aproximadamente igual a 113 Kbytes: <br><br><ul><li>  cerca de 2,5 Kbytes para HTML, CSS e JS "manuscrito" </li><li>  26,8 kb por arquivo JS de tempo de execu√ß√£o emscripten </li><li>  83,7 KB por arquivo .wasm </li></ul><br>  O arquivo WASM cont√©m as ROMs internas da m√°quina de fliperama. <br><br>  Descompactadas, essas ROMs ocupam 112 Kbytes. <br><br>  Ou seja, <strong>todo o</strong> emulador compactado com ROMs integradas ocupa quase o mesmo volume que as ROMs n√£o compactadas :) <br><br>  ROMs de 112 kilobytes s√£o compactadas para aproximadamente 57 KB, ou seja, o tamanho real do c√≥digo compactado no WASM sem dados de ROM √© menor que 30 KB (84-57). <br><br>  Parece-me bastante bom para um emulador completo de um sistema de 8 bits;) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt426291/">https://habr.com/ru/post/pt426291/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt426281/index.html">Fundadores da Amazon, Google, Microsoft e Facebook perderam mais de US $ 30 bilh√µes durante uma queda do mercado de a√ß√µes</a></li>
<li><a href="../pt426283/index.html">WeChat na √çndia: de um poderoso lan√ßamento a uma completa perda de interesse</a></li>
<li><a href="../pt426285/index.html">Em uma das oficinas da AvtoVAZ encontrou uma fazenda para minera√ß√£o</a></li>
<li><a href="../pt426287/index.html">Enviando para a lua</a></li>
<li><a href="../pt426289/index.html">Autentica√ß√£o asp .net core atrav√©s do IdentityServer4</a></li>
<li><a href="../pt426293/index.html">Qual bicicleta escolher para cidade, pa√≠s e viagens extremas - uma vis√£o geral dos modelos Airwheel e Twitter</a></li>
<li><a href="../pt426295/index.html">Como vejo o navegador perfeito</a></li>
<li><a href="../pt426297/index.html">Por que eu n√£o gosto da web moderna</a></li>
<li><a href="../pt426299/index.html">[Psicologia do Design] - A Psicologia do Design</a></li>
<li><a href="../pt426301/index.html">√â assim na Europa, enquanto escrevem sobre isso?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>