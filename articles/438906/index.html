<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçâ ü•ä üë± Comprender el protocolo de paginaci√≥n POCSAG üèáüèæ üèöÔ∏è ‚öΩÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hace mucho tiempo, cuando un tel√©fono m√≥vil costaba alrededor de 2000 $ y un minuto de llamada de voz costaba 50 centavos, los buscapersonas eran muy ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comprender el protocolo de paginaci√≥n POCSAG</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438906/">  Hace mucho tiempo, cuando un tel√©fono m√≥vil costaba alrededor de 2000 $ y un minuto de llamada de voz costaba 50 centavos, los buscapersonas eran muy populares.  M√°s tarde, los tel√©fonos celulares se volvieron m√°s baratos, las llamadas y los precios de los SMS disminuyeron, y finalmente los buscapersonas desaparecieron en su mayor√≠a. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8t/7j/xw/8t7jxwauxqbonmzwmweakgmwpvw.jpeg"></div><br>  Para las personas que antes ten√≠an un localizador y quieren saber c√≥mo funciona, este art√≠culo ser√° √∫til. <br><a name="habracut"></a><br><h2>  Informaci√≥n principal </h2><br>  Para las personas que olvidaron los principios o nacieron despu√©s de 2000x, les recordar√© las ideas principales en breve. <br><br>  La red de comunicaciones de paginaci√≥n tiene algunas ventajas, que a veces son importantes incluso ahora: <br><br>  - Es una comunicaci√≥n unidireccional, sin ning√∫n tipo de confirmaci√≥n, por lo que la red no se puede sobrecargar, simplemente no depende de varios usuarios.  Los mensajes se transmiten continuamente "tal cual", uno tras otro, y el localizador recibe el mensaje si su n√∫mero (llamado Capcode) es igual al n√∫mero interno del dispositivo. <br><br>  - El receptor es muy liviano (tanto literal como electr√≥nicamente) y puede funcionar hasta un mes con 2 bater√≠as AA. <br><br>  Hay dos est√°ndares b√°sicos de transmisi√≥n de mensajes: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">POCSAG</a> (Grupo Asesor de Normalizaci√≥n del C√≥digo de la Oficina de Correos) y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FLEX</a> .  Ambos est√°ndares son bastante antiguos, POCSAG se fabric√≥ en 1982, puede admitir velocidades de 512, 1200 y 2400 bit / s.  Para transmitir, el m√©todo FSK (modulaci√≥n por desplazamiento de frecuencia) se utiliza con una separaci√≥n de frecuencia de 4.5KHz.  FLEX es un poco m√°s nuevo (fue hecho por Motorola en el 90), puede funcionar con una velocidad de hasta 6400 bit / sy puede usar tanto FSK2 como FSK4. <br><br>  En general, ambos protocolos son muy f√°ciles, y hace unos 20 a√±os se crearon decodificadores de PC que pueden decodificar mensajes desde un puerto serie de tarjeta de sonido (no hay cifrado compatible, por lo que todos pueden leer todos los mensajes). <br><br>  Veamos c√≥mo funciona. <br><br><h2>  Recibiendo una se√±al </h2><br>  Primero, necesitamos una se√±al para decodificar.  Tomemos una computadora port√°til, un receptor rtl-sdr y consig√°mosla. <br><br><img src="https://habrastorage.org/webt/vj/ba/2g/vjba2gslgleejthwn_m8ccsvf00.jpeg"><br><br>  Se utiliza la modulaci√≥n por desplazamiento de frecuencia, por lo que configuraremos FM.  Con HDSDR guardaremos una se√±al en formato WAV. <br><br>  Vamos a ver qu√© tenemos.  Carga del archivo wav como una matriz de datos de Python: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy.io <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> wavfile <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt fs, data = wavfile.read(<span class="hljs-string"><span class="hljs-string">"pocsag.wav"</span></span>) plt.plot(data) plt.show()</code> </pre> <br>  Salida (bits a√±adidos manualmente): <br><br><img src="https://habrastorage.org/webt/pm/ss/y7/pmssy79glsbnfsgxogjd93ylqre.jpeg"><br><br>  Como podemos ver, es f√°cil, e incluso "a simple vista" podemos dibujar bits en Paint, es f√°cil distinguir d√≥nde est√° "0" y d√≥nde est√° "1".  Pero ser√° demasiado largo para hacerlo manualmente, es hora de automatizar el proceso. <br><br>  Despu√©s de ampliar el gr√°fico, podemos ver que cada bit tiene un ancho de 20 muestras.  Tenemos 24000 muestras por segundo archivo wav de velocidad de bits, por lo que la velocidad de codificaci√≥n es de 1200 bits / s.  Vamos a encontrar una posici√≥n de cruce por cero: es el comienzo de la secuencia de bits.  Tambi√©n agreguemos marcadores para verificar que todos los bits est√©n en los lugares adecuados. <br><br><pre> <code class="python hljs">speed = <span class="hljs-number"><span class="hljs-number">1200</span></span> fs = <span class="hljs-number"><span class="hljs-number">24000</span></span> cnt = int(fs/speed) start = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">2</span></span>*cnt): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[p] &lt; - <span class="hljs-number"><span class="hljs-number">50</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> data[p+<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">50</span></span>: start = p <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-comment"><span class="hljs-comment"># Bits frame bits = np.zeros(data.size) for p in range(0, data.size - cnt, cnt): bits[start + p] = 500 plt.plot(bits)</span></span></code> </pre><br>  Como podemos ver, no coincide perfectamente (el transmisor y el receptor tienen frecuencias ligeramente diferentes), pero definitivamente es suficiente para la decodificaci√≥n. <br><br><img src="https://habrastorage.org/webt/hc/s1/lf/hcs1lfxgchl-ngpkyeemhhsgrly.jpeg"><br><br>  Para se√±ales largas probablemente necesitaremos un algoritmo de correcci√≥n autom√°tica de frecuencia, pero para este tipo de se√±ales no es cr√≠tico. <br><br>  El √∫ltimo paso: necesitamos traducir el archivo wav a la secuencia de bits.  Tambi√©n es f√°cil, sabemos la longitud de cada bit, si la suma de datos es positiva, agregaremos "1", de lo contrario, "0" (finalmente se encontr√≥ que una se√±al debe revertirse, por lo que se reemplazaron 0 y 1) . <br><br><pre> <code class="python hljs">bits_str = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, data.size - cnt, cnt): s = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(p, p+cnt): s += data[p] bits_str += <span class="hljs-string"><span class="hljs-string">"1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-string"><span class="hljs-string">"0"</span></span> print(<span class="hljs-string"><span class="hljs-string">"Bits"</span></span>) print(bits_str)</code> </pre><br>  Salida: secuencia de bits adecuada (en formato de cadena) que contiene nuestro mensaje. <br><br> <code>101010101010101010101010101010101010101010101010101010101010101010101010101 <br> 010101010101010101010101010101010101010101010100111110011010010000101001101 <br> 100001111010100010011100000110010111011110101000100111000001100101110111101 <br> 010001001110000011001011101111010100010011100000110010111011110101000100111 <br> 000001100101110111101010001001110000011001011101111010100010011100000110010 <br> 011011110101000100111000001100101110111101010001001110000011001011101111010 <br> 100010011100000110010111011110101000100111000001100101110111101010001001110 <br> ... <br> 111101111</code> <br> <br><h2>  Decodificar mensajes solo num√©ricos </h2><br>  Una secuencia de bits es mucho m√°s conveniente que un archivo wav, podemos extraer datos de ella.  Primero, dividamos los datos en bloques de 4 bytes. <br><br> <code>10101010101010101010101010101010 <br> 10101010101010101010101010101010 <br> 10101010101010101010101010101010 <br> 10101010101010101010101010101010 <br> <br> 01111100110100100001010011011000 <br> 01111010100010011100000110010111 <br> 01111010100010011100000110010111 <br> 01111010100010011100000110010111 <br> 01111010100010011100000110010111 <br> 00001000011011110100010001101000 <br> 10000011010000010101010011010100 <br> <br> 01111100110100100001010111011000 <br> 11110101010001000001000000111000 <br> 01111010100010011100000110010111 <br> 01111010100010011100000110010111 <br> 01111010100010011100000110010111 <br> 00100101101001011010010100101111</code> <br> <br>  Definitivamente podemos ver un patr√≥n.  Ahora necesitamos encontrar qu√© significa cada parte.  El manual POCSAG est√° disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en formato PDF</a> , permite verificar la descripci√≥n de las estructuras de datos. <br><br><img src="https://habrastorage.org/webt/3k/yt/dc/3kytdccgmehfmqstxxli1nt3fpa.png"><br><br>  Ahora es mucho m√°s claro.  El encabezado contiene un bloque largo "10101010101", se utiliza para "despertar" el buscapersonas desde un modo de suspensi√≥n.  El mensaje en s√≠ contiene los bloques Batch-1 ... Batch-N, cada bloque comienza a partir de la secuencia √∫nica FSC.  Luego, como podemos ver en el manual, si la cadena comienza desde "0", contiene la direcci√≥n del destinatario.  La direcci√≥n en s√≠ (c√≥digo de cap) se almacena es el localizador, y si no coincide, el localizador ignorar√° el mensaje.  Si una cadena comienza desde "1", contiene el cuerpo del mensaje.  En nuestro ejemplo tenemos 2 cadenas de este tipo. <br><br>  No revisemos cada bloque.  Tambi√©n podemos ver c√≥digos inactivos: bloques vac√≠os 01111 ... 0111, no tienen ninguna informaci√≥n √∫til.  Despu√©s de eliminarlos, obtenemos solo esto: <br><br> <code>01111100110100100001010011011000 - Frame Sync <br> 00001000011011110100010001101000 - Address <br> 10000011010000010101010011010100 - Message <br> <br> 01111100110100100001010111011000 - Frame Sync <br> 11110101010001000001000000111000 - Message <br> 00100101101001011010010100101111 - Address</code> <br> <br>  Necesitamos encontrar, qu√© hay dentro. <br><br>  Despu√©s de revisar el manual, queda claro que hay dos tipos de mensajes: <b>solo</b> <b>num√©ricos y alfanum√©ricos</b> .  Los mensajes solo num√©ricos se guardan como c√≥digos BCD de 4 bits, por lo que 20 bits pueden contener 5 s√≠mbolos (tambi√©n hay bits CRC, no los estamos usando por ahora).  Si el mensaje es alfanum√©rico, se utiliza la codificaci√≥n ASCII de 7 bits.  Este mensaje es demasiado corto, por lo que solo puede ser un mensaje num√©rico. <br><br>  De las cadenas 10000011010000010101010011010100 y 11110101010001000001000000111000 podemos obtener estas secuencias de 4 bits: <br>  <i>1 0000 0110 1000 0010 10101 0011010100</i> - 0h 6h 8h 2h Ah <br>  <i>1 1110 1010 1000 1000 00100 0000111000</i> - Eh Ah 8h 8h 2h <br><br>  El siguiente paso es obtener la tabla de decodificaci√≥n del manual: <br><br><img src="https://habrastorage.org/webt/vb/sj/zl/vbsjzluxbhaeuy_zrefccmqhogw.jpeg"><br><br>  Es obvio que un mensaje solo num√©rico puede contener d√≠gitos 0-9, letra U ("ugrent"), espacio y dos par√©ntesis.  Vamos a escribir un peque√±o m√©todo para decodificarlo: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_msg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># 16 lines in a batch, each block has a length 32 bits for cw in range(16): cws = block[32 * cw:32 * (cw + 1)] if cws[0] == "0": addr = cws[1:19] print(" Addr:" + addr) else: msg = cws[1:21] print(" Msg: " + msg) size = 4 s = "" for ind in range(0, len(msg), size): bcd_s = msg[ind:ind + size] value = int(bcd_s, 2) symbols = "0123456789*U -)(" s += symbols[value] print(" ", s) print()</span></span></code> </pre><br>  Finalmente, recibimos un mensaje "0682 *) * 882". <br><br>  Es dif√≠cil saber qu√© significa, pero si se usan los mensajes solo num√©ricos, probablemente alguien lo necesite. <br><br><h2>  Decodificar mensajes alfanum√©ricos </h2><br>  El siguiente paso, y m√°s interesante, es decodificar mensajes alfanum√©ricos.  Es m√°s interesante, porque como salida, deber√≠amos obtener el texto legible por humanos. <br><br>  Primero, necesitamos grabar un mensaje nuevamente, usaremos HDSDR.  No conocemos un tipo de mensaje antes de la decodificaci√≥n, por lo que solo registraremos un mensaje m√°s largo que podamos obtener y esperamos que contenga algo de texto. <br><br><img src="https://habrastorage.org/webt/lu/ue/sk/luuesk79iv_yalka_pchncpwzoi.jpeg"><br><br>  Despu√©s de convertir de wav a una secuencia de bits (ver un c√≥digo de Python arriba), estamos obteniendo esto: <br><br><img src="https://habrastorage.org/webt/qb/wt/ud/qbwtud3zptfcwxw3xs0pam7pkr4.jpeg"><br><br>  Algunas cosas interesantes que podemos ver de inmediato, a simple vista, como por ejemplo, la secuencia de inicio 01010101010101 se repite dos veces.  Por lo tanto, este mensaje no solo es m√°s largo, sino que literalmente contiene dos mensajes, combinados (un est√°ndar no lo niega, por cierto). <br><br>  Como hemos encontrado antes, cada bloque de datos comienza a partir de una secuencia, llamada C√≥digo de sincronizaci√≥n de trama (01111100 ...), despu√©s de que se env√≠an bloques de 32 bits.  Cada bloque puede almacenar la direcci√≥n o el cuerpo del mensaje. <br><br>  Anteriormente recibimos los mensajes solo num√©ricos, ahora queremos leer los mensajes ASCII.  Primero, necesitamos distinguirlos.  Estos datos se guardan en un campo "Bits de funci√≥n" (bits 20-21): si ambos bits son 00, es un mensaje solo num√©rico, si los bits son 11, es un mensaje de texto. <br><br>  Es interesante mencionar que ese campo de mensaje tiene una longitud de 20 bits, por lo que es ideal colocar cinco bloques de 4 bits en el caso de un mensaje solo num√©rico.  Pero si tenemos un mensaje ASCII de 7 bits, no podemos dividir 20 a 7. Es posible predecir que la primera versi√≥n del protocolo <s>admit√≠a</s> solo mensajes num√©ricos (no olvide que se hizo en 1982 <s>y probablemente los primeros buscapersonas de tubo nixie) no pudieron mostrar m√°s</s> ), y solo m√°s tarde se agreg√≥ compatibilidad con mensajes ASCII.  Debido a las razones heredadas, el est√°ndar de encuadre no se modific√≥, y los desarrolladores utilizaron el enfoque f√°cil: simplemente combinaron bits "tal cual", uno tras otro.  De cada mensaje necesitamos tomar 20 bits y fusionarlo con el siguiente, finalmente podemos decodificar el cuerpo del mensaje. <br><br>  Veamos un bloque de nuestro mensaje (los espacios se sumaron para leer m√°s f√°cilmente): <br><br> <code>0 0001010011100010111111110010010 <br> 1 00010100000110110011 11100111001 <br> 1 01011010011001110100 01111011100 <br> 1 11010001110110100100 11011000100 <br> 1 11000001101000110100 10011110111 <br> 1 11100000010100011011 11101110000 <br> 1 00110010111011001101 10011011010 <br> 1 00011001011100010110 10011000010 <br> 1 10101100000010010101 10110000101 <br> 1 00010110111011001101 00000011011 <br> 1 10100101000000101000 11001010100 <br> 1 00111101010101101100 11011111010</code> <br> <br>  El bit "0" en la primera cadena nos muestra que es el campo de direcci√≥n, y el "11" en 20-21 bits nos muestra que el mensaje es realmente alfanum√©rico.  Luego solo tomamos 20 bits de cada cadena y los fusionamos. <br><br>  Esta es nuestra secuencia de bits: <br><br> <code>00010100000110110011010110100110011101001101000111011010010011000001101000 <br> 11010011100000010100011011001100101110110011010001100101110001011010101100 <br> 000010010101000101101110110011011010010100000010100000111101010101101</code> <br> <br>  En POCSAG se usa el c√≥digo ASCII de 7 bits, por lo que dividiremos una cadena en 7 bloques de caracteres: <br><br> <code>0001010 0000110 1100110 1011010 0110011 1010011 ...</code> <br> <br>  Despu√©s de intentar decodificarlo (la tabla ASCII se puede encontrar f√°cilmente en Internet), obtenemos ... simplemente nada.  Revisando el manual nuevamente, y aqu√≠ est√° la peque√±a frase "Los caracteres ASCII se colocan de izquierda a derecha (MSB a LSB).  El LSB est√° transmitiendo primero ".  Entonces, el bit bajo se transmite primero: para una decodificaci√≥n correcta, necesitamos invertir todas las cadenas. <br><br>  Es demasiado aburrido hacerlo manualmente, as√≠ que escribamos un c√≥digo Python: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_msg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block)</span></span></span><span class="hljs-function">:</span></span> msgs = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> cw <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">16</span></span>): cws = block[<span class="hljs-number"><span class="hljs-number">32</span></span> * cw:<span class="hljs-number"><span class="hljs-number">32</span></span> * (cw + <span class="hljs-number"><span class="hljs-number">1</span></span>)] <span class="hljs-comment"><span class="hljs-comment"># Skip the idle word if cws.startswith("0111101010"): continue if cws[0] == "0": addr, type = cws[1:19], cws[19:21] print(" Addr:" + addr, type) else: msg = cws[1:21] print(" Msg: " + msg) msgs += msg # Split long string to 7 chars blocks bits = [msgs[i:i+7] for i in range(0, len(msgs), 7)] # Get the message msg = "" for b in bits: b1 = b[::-1] # Revert string value = int(b1, 2) msg += chr(value) print("Msg:", msg) print()</span></span></code> </pre><br>  Finalmente, estamos obteniendo esta secuencia (bits, c√≥digos de s√≠mbolos y s√≠mbolos ASCII): <br><br><pre> <code class="plaintext hljs">0101000 40 ( 0110000 48 0 0110011 51 3 0101101 45 - 1100110 102 f 1100101 101 e 1100010 98 b 0101101 45 - 0110010 50 2 0110000 48 0 0110001 49 1 0111001 57 9 0100000 32 0110001 49 1 0110011 51 3 0111010 58 : 0110011 51 3 0110001 49 1 0111010 58 : 0110100 52 4 0110101 53 5 0100000 32 0101010 42 * 0110100 52 4 0110111 55 7 0110110 54 6 0101001 41 ) 0100000 32 1000001 65 A 1010111 87 W 1011010 90 Z</code> </pre><br>  Despu√©s de la fusi√≥n, obtenemos la cadena: "(03-feb-2019 13:31:45 * 476) AWZ".  Como se prometi√≥, es bastante legible para los humanos. <br><br>  Por cierto, es interesante mencionar que se utilizan c√≥digos ASCII de 7 bits.  Los s√≠mbolos de algunos alfabetos (alem√°n, cir√≠lico, etc.) no se pueden codificar correctamente en 7 bits.  ¬øPor qu√© 7 bits?  Probablemente los ingenieros hab√≠an decidido que "7 bits ser√°n suficientes para todos", qui√©n sabe ... <br><br><h2>  Conclusi√≥n </h2><br>  Fue realmente interesante investigar c√≥mo funciona POCSAG.  Es uno de los protocolos raros, que est√°n en uso hasta ahora, que literalmente se puede decodificar en la hoja de papel (y definitivamente no lo intentar√© con TETRA o GSM). <br><br>  Por supuesto, el protocolo POCSAG no se describe completamente aqu√≠.  La parte m√°s importante e interesante est√° hecha, otras cosas no son tan emocionantes.  Al menos, no hay decodificaci√≥n de capcodes y no hay c√≥digo de correcci√≥n de errores (BCH Check Bits): puede permitir corregir hasta 2 bits incorrectos en el mensaje.  Pero no hab√≠a objetivo para escribir otro decodificador POCSAG aqu√≠, ya hay suficientes. <br><br>  Para aquellos que quieran probar la decodificaci√≥n real con rtl-sdr, se puede usar la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aplicaci√≥n</a> gratuita <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PDW</a> .  No requiere instalaci√≥n, solo es suficiente para reenviar el sonido de HDSDR a PDW a trav√©s de la aplicaci√≥n Virtual Audio Cable. <br><br>  Los resultados se ven as√≠: <br><br><img src="https://habrastorage.org/webt/-7/g-/ka/-7g-kalvhmaqlv79qju-wmgpglg.jpeg"><br><br>  (tenga en cuenta que la decodificaci√≥n de mensajes de servicio p√∫blico puede ser ilegal en algunos pa√≠ses y, de todos modos, respetar la privacidad de los destinatarios) <br><br>  Si alguien quiere obtener m√°s informaci√≥n sobre este tema, las fuentes del decodificador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">multimon-ng</a> est√°n disponibles, puede decodificar muchos protocolos, tambi√©n POCSAG y FLEX. <br><br>  Gracias por leer </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/438906/">https://habr.com/ru/post/438906/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../438894/index.html">¬øPor qu√© el desarrollo web en Go es mejor que en PHP?</a></li>
<li><a href="../438896/index.html">No llores negocios</a></li>
<li><a href="../438898/index.html">Instalaci√≥n inversa de Chrome y extensi√≥n</a></li>
<li><a href="../438900/index.html">En el camino hacia los principios f√≠sicos de la evoluci√≥n biol√≥gica. Fin + texto completo de la traducci√≥n</a></li>
<li><a href="../438902/index.html">Usando DBREPLICATION al colapsar bases de datos en Microsoft SQL Server</a></li>
<li><a href="../438908/index.html">Entrenamiento Cisco 200-125 CCNA v3.0. Especialista certificado en redes de Cisco (CCNA). D√≠a 1. Conceptos b√°sicos de la red</a></li>
<li><a href="../438910/index.html">Samba como ADDC en Solaris 11.4</a></li>
<li><a href="../438916/index.html">Notas de un fitoqu√≠mico. La papa. Tercera parte "Bullet Fugu" o SOLANIN</a></li>
<li><a href="../438920/index.html">Avalonia: primer encuentro</a></li>
<li><a href="../438922/index.html">Cifrado de tr√°fico en Direct Connect, Parte 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>