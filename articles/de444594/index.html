<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐃 🐳 💔 Big o 🤞🏻 🤛🏼 💐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hinweis Abgekürzte Übersetzung, eher in eigenen Worten nacherzählen. 
 UPD: Wie in den Kommentaren erwähnt, sind die Beispiele nicht perfekt. Der Auto...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Big o</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444594/">  <i><u>Hinweis</u></i>  <i>Abgekürzte Übersetzung, eher in eigenen Worten nacherzählen.</i> <i><br></i>  <i>UPD: Wie in den Kommentaren erwähnt, sind die Beispiele nicht perfekt.</i>  <i>Der Autor sucht nicht nach der besten Lösung für das Problem, sein Ziel ist es, die Komplexität der Algorithmen „an den Fingern“ zu erklären.</i> <br><br>  Die Big O-Notation wird benötigt, um die Komplexität der Algorithmen zu beschreiben.  Hierfür wird das Konzept der Zeit verwendet.  Das Thema ist für viele beängstigend, Programmierer, die es vermeiden, über "Zeit der Ordnung N" zu sprechen, sind eine häufige Sache. <br><br>  Wenn Sie in der Lage sind, den Code in Bezug auf Big O zu bewerten, werden Sie höchstwahrscheinlich als „kluger Kerl“ angesehen.  Und höchstwahrscheinlich werden Sie Ihr nächstes Interview durchgehen.  Die Frage, ob es möglich ist, die Komplexität eines Codeteils auf n log n gegen n ^ 2 zu reduzieren, wird Sie nicht aufhalten. <br><br><h2>  Datenstrukturen </h2><br>  Die Wahl der Datenstruktur hängt von der jeweiligen Aufgabe ab: von der Art der Daten und dem Algorithmus für deren Verarbeitung.  Für bestimmte Arten von Algorithmen wurden verschiedene Datenstrukturen (in .NET, Java oder Elixir) erstellt. <br><br>  Bei der Auswahl der einen oder anderen Struktur kopieren wir häufig einfach die allgemein akzeptierte Lösung.  In den meisten Fällen reicht dies aus.  Ohne die Komplexität der Algorithmen zu verstehen, können wir jedoch keine fundierte Entscheidung treffen.  Das Thema Datenstrukturen kann erst nach der Komplexität der Algorithmen übergeben werden. <br><br>  Hier werden nur Arrays von Zahlen verwendet (genau wie in einem Interview).  JavaScript-Beispiele. <br><a name="habracut"></a><br><h2>  Beginnen wir mit dem einfachsten: O (1) </h2><br>  Nehmen Sie ein Array von 5 Zahlen: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nums = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>];</code> </pre> <br>  Angenommen, Sie müssen das erste Element erhalten.  Wir verwenden den Index dafür: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nums = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> firstNumber = nums[<span class="hljs-number"><span class="hljs-number">0</span></span>];</code> </pre> <br>  Wie kompliziert ist dieser Algorithmus?  Wir können sagen: "Überhaupt nicht kompliziert - nehmen Sie einfach das erste Element des Arrays."  Dies ist wahr, aber es ist korrekter, die Komplexität durch die Anzahl der durchgeführten Operationen zu beschreiben, um das Ergebnis zu erzielen, abhängig von der Eingabe (Eingabeoperationen). <br><br>  Mit anderen Worten: Wie viele Operationen werden mit zunehmender Anzahl von Eingabeparametern zunehmen? <br><br>  In unserem Beispiel gibt es 5 Eingabeparameter, da das Array 5 Elemente enthält.  Um das Ergebnis zu erhalten, müssen Sie eine Operation ausführen (ein Element nach Index nehmen).  Wie viele Operationen sind erforderlich, wenn die Array-Elemente 100 sind?  Oder 1000?  Oder 100.000?  Trotzdem ist nur eine Operation erforderlich. <br><br>  Das heißt: "eine Operation für alle möglichen Eingabedaten" - O (1). <br><br>  O (1) kann als "Komplexität der Ordnung 1" (Ordnung 1) oder "Algorithmus läuft in konstanter / konstanter Zeit" (konstante Zeit) gelesen werden. <br><br>  Sie haben bereits vermutet, dass O (1) -Algorithmen am effizientesten sind. <br><br><h2>  Iterationen und "Zeitpunkt der Bestellung n": O (n) </h2><br>  Lassen Sie uns nun die Summe der Elemente des Arrays ermitteln: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nums = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> num <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> nums){ sum += num; }</code> </pre> <br>  Wieder fragen wir uns: Wie viele Eingabeoperationen benötigen wir?  Hier müssen Sie alle Elemente sortieren, d. H.  Operation an jedem Element.  Je größer das Array, desto mehr Operationen. <br><br>  Verwenden der Big O-Notation: O (n) oder „Komplexität der Ordnung n (Ordnung n)“.  Diese Art von Algorithmus wird auch als "linear" bezeichnet oder der Algorithmus ist "linear skaliert". <br><br><h3>  Analyse </h3><br>  Können wir die Summierung effizienter gestalten?  Im Allgemeinen nicht.  Und wenn wir wissen, dass das Array garantiert bei 1 beginnt, sortiert ist und keine Lücken aufweist?  Dann können wir die Formel S = n (n + 1) / 2 anwenden (wobei n das letzte Element des Arrays ist): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sumContiguousArray = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ary</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//get the last item const lastItem = ary[ary.length - 1]; //Gauss's trick return lastItem * (lastItem + 1) / 2; } const nums = [1,2,3,4,5]; const sumOfArray = sumContiguousArray(nums);</span></span></code> </pre> <br>  Ein solcher Algorithmus ist viel effizienter als O (n), außerdem wird er in "konstanter / konstanter Zeit" ausgeführt, d.h.  es ist O (1). <br><br>  Tatsächlich gibt es mehr als eine Operation: Sie müssen die Länge des Arrays ermitteln, das letzte Element abrufen, die Multiplikation und Division durchführen.  Ist das nicht O (3) oder so?  In der Big O-Notation ist die tatsächliche Anzahl der Schritte nicht wichtig. Es ist wichtig, dass der Algorithmus in konstanter Zeit ausgeführt wird. <br><br>  Konstantzeitalgorithmen sind immer O (1).  Das gleiche gilt für lineare Algorithmen. Tatsächlich können Operationen O (n + 5) sein. In Big O lautet die Notation O (n). <br><br><h2>  Nicht die besten Lösungen: O (n ^ 2) </h2><br>  Schreiben wir eine Funktion, die das Array auf Duplikate überprüft.  Verschachtelte Schleifenlösung: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hasDuplicates = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//loop the list, our O(n) op for (let i = 0; i &lt; nums.length; i++) { const thisNum = nums[i]; //loop the list again, the O(n^2) op for (let j = 0; j &lt; nums.length; j++) { //make sure we're not checking same number if (j !== i) { const otherNum = nums[j]; //if there's an equal value, return if (otherNum === thisNum) return true; } } } //if we're here, no dups return false; } const nums = [1, 2, 3, 4, 5, 5]; hasDuplicates(nums);//true</span></span></code> </pre> <br>  Wir wissen bereits, dass die Array-Iteration O (n) ist.  Wir haben eine verschachtelte Schleife für jedes Element, das wir erneut iterieren - d. H.  O (n ^ 2) oder "Komplexität der Ordnung n Quadrat". <br><br>  Algorithmen mit verschachtelten Schleifen über dieselbe Sammlung sind immer O (n ^ 2). <br><br><h2>  "Die Komplexität der Reihenfolge von log n": O (log n) </h2><br>  Im obigen Beispiel hat eine verschachtelte Schleife für sich genommen (wenn Sie nicht berücksichtigen, dass sie verschachtelt ist) die Komplexität O (n), weil  Es ist eine Aufzählung von Array-Elementen.  Dieser Zyklus endet, sobald das gewünschte Element gefunden ist, d.h.  Tatsächlich werden nicht alle Elemente aufgezählt.  Die Big O-Notation berücksichtigt jedoch immer das Worst-Case-Szenario - der gesuchte Artikel ist möglicherweise der allerletzte. <br><br>  Hier wird eine verschachtelte Schleife verwendet, um nach einem bestimmten Element in einem Array zu suchen.  Die Suche nach einem Element in einem Array kann unter bestimmten Bedingungen optimiert werden - besser als lineares O (n). <br><br>  Lassen Sie das Array sortiert werden.  Dann können wir den binären Suchalgorithmus verwenden: Teilen Sie das Array in zwei Hälften, verwerfen Sie das Unnötige, teilen Sie das verbleibende wieder in zwei Teile und so weiter, bis wir den gewünschten Wert gefunden haben.  Diese Art von Algorithmus heißt Teilen und Erobern Teilen und Erobern. <br><br><img src="https://habrastorage.org/webt/0p/b9/em/0pb9em6fqdkdj0dtknyxbt8kbvk.png" alt="binäre Suche"><br><br>  Dieser Algorithmus basiert auf einem Logarithmus. <br><br><h2>  Schneller Überblick über Logarithmen </h2><br>  Betrachten Sie ein Beispiel, was wird x gleich sein? <br><br>  x ^ 3 = 8 <br><br>  Wir müssen die Kubikwurzel von 8 nehmen - dies wird 2 sein. Jetzt schwieriger <br><br>  2 ^ x = 512 <br><br>  Mit dem Logarithmus kann das Problem wie folgt geschrieben werden <br><br>  log2 (512) = x <br><br>  "Der Logarithmus zur Basis 2 von 512 ist x."  Achten Sie auf "Basis 2", d. H.  Wir denken zu zweit - wie oft müssen Sie 2 multiplizieren, um 512 zu erhalten. <br><br>  Im binären Suchalgorithmus teilen wir das Array bei jedem Schritt in zwei Teile. <br><br>  <i><u>Mein Zusatz.</u></i>  <i>Das heißt,</i>  <i>Im schlimmsten Fall führen wir so viele Operationen aus, wie wir das Array in zwei Teile teilen können.</i>  <i>Wie oft können wir beispielsweise ein Array von 4 Elementen in zwei Teile aufteilen?</i>  <i>2 mal.</i>  <i>Und ein Array von 8 Elementen?</i>  <i>3 mal.</i>  <i>Das heißt,</i>  <i>Anzahl der Unterteilungen / Operationen = log2 (n) (wobei n die Anzahl der Elemente im Array ist).</i> <i><br><br></i>  <i>Es stellt sich heraus, dass die Abhängigkeit der Anzahl der Operationen von der Anzahl der Eingabeelemente als log2 (n) beschrieben wird.</i> <i><br></i> <br><br>  Somit hat der binäre Suchalgorithmus unter Verwendung der Big O-Notation die Komplexität O (log n). <br><br><h2>  Verbessere O (n ^ 2) zu O (n log n) </h2><br>  Kehren wir zur Aufgabe zurück, das Array auf Duplikate zu überprüfen.  Wir haben alle Elemente des Arrays durchlaufen, und für jedes Element haben wir erneut durchlaufen.  Sie haben O (n) innerhalb von O (n) gemacht, d.h.  O (n * n) oder O (n ^ 2). <br><br>  Wir können die verschachtelte Schleife durch eine binäre Suche * ersetzen.  Das heißt,  wir müssen nur alle Elemente von O (n) durchgehen, im Inneren machen wir O (log n).  Es stellt sich heraus, O (n * log n) oder O (n log n). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nums = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> searchFor = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">items, num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//use binary search! //if found, return the number. Otherwise... //return null. We'll do this in a later chapter. } const hasDuplicates = function (nums) { for (let num of nums) { //let's go through the list again and have a look //at all the other numbers so we can compare if (searchFor(nums, num)) { return true; } } //only arrive here if there are no dups return false; }</span></span></code> </pre> <br><br>  * ACHTUNG, um ein Aufdrucken zu vermeiden.  Die Verwendung der binären Suche zum Überprüfen eines Arrays auf Duplikate ist eine schlechte Lösung.  Es wird nur gezeigt, wie in Big O-Begriffen die Komplexität des in der obigen Codeliste gezeigten Algorithmus bewertet werden kann.  Ein guter oder ein schlechter Algorithmus ist für diesen Artikel nicht wichtig, Sichtbarkeit ist wichtig. <br><br><h2>  Denken in Big O. </h2><br><ul><li>  Das Abrufen des Sammlungsgegenstandes ist O (1).  Unabhängig davon, ob es sich um einen Index in einem Array oder um einen Schlüssel in einem Wörterbuch in Big O-Notation handelt, ist es O (1). </li><li>  Das Iterieren über eine Sammlung ist O (n) </li><li>  Verschachtelte Schleifen über dieselbe Sammlung sind O (n ^ 2) </li><li>  Teile und erobere immer O (log n) </li><li>  Iterationen, die Teilen und Erobern verwenden, sind O (n log n) </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444594/">https://habr.com/ru/post/de444594/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444582/index.html">Palo Alto Networks NGFW-Optimierer für Sicherheitsrichtlinien</a></li>
<li><a href="../de444584/index.html">Android bietet europäischen Nutzern einen Browser und eine Suchmaschine ihrer Wahl</a></li>
<li><a href="../de444586/index.html">Russische Internet-Segment-Architektur</a></li>
<li><a href="../de444590/index.html">Datenverlust (der möglicherweise aufgetreten ist, aber nicht aufgetreten ist) von der Telemedizinfirma</a></li>
<li><a href="../de444592/index.html">Das US-Militär plant die Verwendung eines neuen Exoskeletttyps</a></li>
<li><a href="../de444596/index.html">Jodid: Mozilla Interactive Science Editor</a></li>
<li><a href="../de444598/index.html">Die CD ist 40 Jahre alt und er ist tot (oder?)</a></li>
<li><a href="../de444600/index.html">Rückblick auf 14 kopflose cm 2019</a></li>
<li><a href="../de444602/index.html">Kapselung in C ++ und C.</a></li>
<li><a href="../de444610/index.html">Statistik und Überwachung von PHP-Skripten in Echtzeit. ClickHouse und Grafana helfen Pinba</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>