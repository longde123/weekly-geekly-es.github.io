<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòô üç° üë≥ Implementierung eines Hot-Reloads von C ++ - Code unter Linux und MacOS: tiefer gehen üöú üë®üèª‚Äçüî¨ ü§∂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="* Link zur Bibliothek und zum Demo-Video am Ende des Artikels. Um zu verstehen, was passiert und wer all diese Leute sind, empfehle ich, den vorherige...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementierung eines Hot-Reloads von C ++ - Code unter Linux und MacOS: tiefer gehen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437312/"><p><img src="https://habrastorage.org/webt/cz/hn/wz/czhnwzufandjpr6jf5cwj1j3p48.png"></p><br><p>  * Link zur Bibliothek und zum Demo-Video am Ende des Artikels.  Um zu verstehen, was passiert und wer all diese Leute sind, empfehle ich, den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Artikel zu</a> lesen. </p><br><p>  Im letzten Artikel haben wir uns mit einem Ansatz vertraut gemacht, der ein Hot-Reload von C ++ - Code erm√∂glicht.  "Code" sind in diesem Fall Funktionen, Daten und deren koordinierte Arbeit miteinander.  Es gibt keine besonderen Probleme mit Funktionen, wir leiten den Ausf√ºhrungsfluss von der alten Funktion zur neuen um und alles funktioniert.  Das Problem tritt bei den Daten (statische und globale Variablen) auf, n√§mlich bei der Strategie ihrer Synchronisation im alten und neuen Code.  In der ersten Implementierung war diese Strategie sehr umst√§ndlich: Wir kopieren einfach die Werte aller statischen Variablen aus dem alten Code in den neuen, sodass der neue Code, der sich auf die neuen Variablen bezieht, mit den Werten aus dem alten Code arbeitet.  Dies ist nat√ºrlich falsch, und heute werden wir versuchen, diesen Fehler zu beheben, indem wir gleichzeitig eine Reihe kleiner, aber interessanter Probleme l√∂sen. </p><br><p>  In dem Artikel werden Details zu mechanischen Arbeiten wie das Lesen von Zeichen und Verschiebungen aus Elfen- und Mach-O-Dateien weggelassen.  Der Schwerpunkt liegt auf den subtilen Punkten, auf die ich im Implementierungsprozess gesto√üen bin und die f√ºr jemanden n√ºtzlich sein k√∂nnen, der wie ich k√ºrzlich nach Antworten sucht. </p><a name="habracut"></a><br><h3 id="sut">  Essenz </h3><br><p>  Stellen wir uns vor, wir haben eine Klasse (synthetische Beispiele, bitte suchen Sie nicht nach Bedeutung, nur der Code ist wichtig): </p><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Entity.hpp class Entity { public: Entity(const std::string&amp; description); ~Entity(); void printDescription(); static int getLivingEntitiesCount(); private: static int m_livingEntitiesCount; std::string m_description; }; // Entity.cpp int Entity::m_livingEntitiesCount = 0; Entity::Entity(const std::string&amp; description) : m_description(description) { m_livingEntitiesCount++; } Entity::~Entity() { m_livingEntitiesCount--; } int Entity::getLivingEntitiesCount() { return m_livingEntitiesCount; } void Entity::printDesctiption() { std::cout &lt;&lt; m_description &lt;&lt; std::endl; }</span></span></code> </pre> <br><p>  Nichts Besonderes als eine statische Variable.  Stellen Sie sich nun vor, wir m√∂chten die <code>printDescription()</code> -Methode in <code>printDescription()</code> √§ndern: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Entity::printDescription() { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"DESCRIPTION: "</span></span> &lt;&lt; m_description &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br><p>  Was passiert nach dem erneuten Laden des Codes?  Zus√§tzlich zu den Methoden der <code>Entity</code> Klasse wird die statische Variable <code>m_livingEntitiesCount</code> mit dem neuen Code in die Bibliothek aufgenommen.  Es wird nichts Schlimmes passieren, wenn wir einfach den Wert dieser Variablen aus dem alten Code in den neuen kopieren und die neue Variable weiterhin verwenden, wobei die alte vergessen wird, da sich alle Methoden, die diese Variable direkt verwenden, in der Bibliothek mit dem neuen Code befinden. </p><br><p>  C ++ ist sehr flexibel und reichhaltig.  Und w√§hrend die Eleganz, einige Probleme in C ++ zu l√∂sen, an den √ºbelriechenden Code grenzt, liebe ich diese Sprache.  Stellen Sie sich zum Beispiel vor, Ihr Projekt verwendet kein rtti.  Gleichzeitig ben√∂tigen Sie eine Implementierung der <code>Any</code> Klasse mit einer etwas typsicheren Schnittstelle: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Any</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Any</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp;&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } };</code> </pre> <br><p>  Wir werden nicht auf Details der Implementierung dieser Klasse eingehen.  F√ºr uns ist wichtig, dass wir f√ºr die Implementierung einen Mechanismus ben√∂tigen, mit dem der Typ (Entit√§t zur Kompilierungszeit) eindeutig dem Wert einer Variablen zugeordnet werden kann, z. B. <code>uint64_t</code> (Laufzeitentit√§t), <code>uint64_t</code> "Aufz√§hlungstypen".  Bei Verwendung von rtti stehen uns Dinge wie <code>type_info</code> und, f√ºr uns besser geeignet, <code>type_index</code> zur Verf√ºgung.  Aber wir haben kein rtti.  In diesem Fall ein ziemlich h√§ufiger Hack (oder eine elegante L√∂sung?) Ist diese Funktion: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> typeId() { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> someVar; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>&gt;(&amp;someVar); }</code> </pre> <br><p>  Dann sieht die Implementierung der <code>Any</code> Klasse ungef√§hr so ‚Äã‚Äãaus: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Any</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Any</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp;&amp; value)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_typeId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(typeId&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::decay&lt;T&gt;::type&gt;())</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// copy or move value somewhere {} template &lt;typename T&gt; bool is() const { return m_typeId == typeId&lt;std::decay&lt;T&gt;::type&gt;(); } template &lt;typename T&gt; T&amp; as() { ... } private: uint64_t m_typeId = 0; };</span></span></span></span></code> </pre> <br><p>  F√ºr jeden Typ wird die Funktion genau 1 Mal instanziiert, jede Version der Funktion hat ihre eigene statische Variable, offensichtlich mit ihrer eigenen eindeutigen Adresse.  Was passiert, wenn wir den Code mit dieser Funktion neu laden?  Aufrufe der alten Version der Funktion werden an die neue weitergeleitet.  F√ºr die neue Variable ist bereits eine eigene statische Variable initialisiert (wir haben den Wert und die Schutzvariable kopiert).  Die Bedeutung interessiert uns aber nicht, wir verwenden nur die Adresse.  Und die Adresse der neuen Variablen wird anders sein.  Somit wurden die Daten inkonsistent: In den bereits erstellten Instanzen der <code>Any</code> Klasse wird die Adresse der alten statischen Variablen gespeichert, und die <code>is()</code> -Methode vergleicht sie mit der Adresse der neuen, und "this <code>Any</code> nicht mehr dieselbe <code>Any</code> " ¬©. </p><br><h3 id="plan">  Planen </h3><br><p>  Um dieses Problem zu l√∂sen, ben√∂tigen Sie etwas Kl√ºgeres als nur das Kopieren.  Nachdem ich einige Abende bei Google verbracht, Dokumentation, Quellcodes und System-API gelesen hatte, wurde der folgende Plan in meinem Kopf erstellt: </p><br><ol><li>  Nachdem wir den neuen Code erstellt haben, gehen wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Umz√ºge durch</a> . </li><li>  Aus diesen Verschiebungen erhalten wir alle Stellen im Code, die statische (und manchmal globale) Variablen verwenden. </li><li>  Anstelle von Adressen f√ºr neue Versionen von Variablen ersetzen wir Adressen alter Versionen durch den Ort der Verlagerung. </li></ol><br><p>  In diesem Fall gibt es keine Links zu neuen Daten. Die gesamte Anwendung arbeitet weiterhin mit alten Versionen von Variablen bis zur Adresse.  Das sollte funktionieren.  Dies kann nicht scheitern. </p><br><h3 id="relokacii">  Umz√ºge </h3><br><p>  Wenn der Compiler Maschinencode generiert, f√ºgt er mehrere Bytes ein, die ausreichen, um die tats√§chliche Adresse der Variablen oder Funktion an diese Stelle an jeder Stelle zu schreiben, an der entweder die Funktion aufgerufen oder die Adresse der Variablen geladen wird, und generiert auch eine Verschiebung.  Er kann die tats√§chliche Adresse nicht sofort aufzeichnen, da er diese Adresse derzeit nicht kennt.  Funktionen und Variablen nach dem Verkn√ºpfen k√∂nnen sich in verschiedenen Abschnitten befinden, an verschiedenen Stellen von Abschnitten, in den Endabschnitten k√∂nnen sie zur Laufzeit an verschiedene Adressen geladen werden. </p><br><p>  Umzug enth√§lt Informationen: </p><br><ul><li>  An welcher Adresse m√ºssen Sie die Adresse der Funktion oder Variablen schreiben </li><li>  Die Adresse, welche Funktion oder Variable geschrieben werden soll </li><li>  Die Formel, nach der diese Adresse berechnet werden soll </li><li>  Wie viele Bytes sind f√ºr diese Adresse reserviert? </li></ul><br><p>  In verschiedenen Betriebssystemen werden Umz√ºge unterschiedlich dargestellt, aber am Ende arbeiten sie alle nach demselben Prinzip.  In elf (Linux) befinden sich Verschiebungen beispielsweise in speziellen <code>.rela</code> Abschnitten (in der 32-Bit-Version ist dies <code>.rel</code> ), die sich auf den Abschnitt mit der Adresse beziehen, die festgelegt werden muss (z. B. <code>.rela.text</code> - der Abschnitt, in dem sich die Verschiebungen befinden). angewendet auf den <code>.text</code> ), und jeder Eintrag speichert Informationen √ºber das Symbol, dessen Adresse Sie in die <code>.text</code> einf√ºgen m√∂chten.  In mach-o (macOS) ist das Gegenteil der Fall: Es gibt keinen separaten Abschnitt f√ºr Verschiebungen. Stattdessen enth√§lt jeder Abschnitt einen Zeiger auf eine Tabelle mit Verschiebungen, die auf diesen Abschnitt angewendet werden sollen, und jeder Datensatz in dieser Tabelle enth√§lt einen Verweis auf ein relationales Symbol. <br>  Zum Beispiel f√ºr einen solchen Code (mit der Option <code>-fPIC</code> ): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> globalVariable = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">veryUsefulFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> functionLocalVariable = <span class="hljs-number"><span class="hljs-number">0</span></span>; functionLocalVariable++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> globalVariable + functionLocalVariable; }</code> </pre> <br><p>  Der Compiler erstellt einen solchen Abschnitt mit Umz√ºgen unter Linux: </p><br><pre> <code class="plaintext hljs">Relocation section '.rela.text' at offset 0x1a0 contains 4 entries: Offset Info Type Symbol's Value Symbol's Name + Addend 0000000000000007 0000000600000009 R_X86_64_GOTPCREL 0000000000000000 globalVariable - 4 000000000000000d 0000000400000002 R_X86_64_PC32 0000000000000000 .bss - 4 0000000000000016 0000000400000002 R_X86_64_PC32 0000000000000000 .bss - 4 000000000000001e 0000000400000002 R_X86_64_PC32 0000000000000000 .bss - 4</code> </pre> <br><p>  und eine solche Verschiebungstabelle unter macOS: </p><br><pre> <code class="plaintext hljs">RELOCATION RECORDS FOR [__text]: 000000000000001b X86_64_RELOC_SIGNED __ZZ18veryUsefulFunctionvE21functionLocalVariable 0000000000000015 X86_64_RELOC_SIGNED _globalVariable 000000000000000f X86_64_RELOC_SIGNED __ZZ18veryUsefulFunctionvE21functionLocalVariable 0000000000000006 X86_64_RELOC_SIGNED __ZZ18veryUsefulFunctionvE21functionLocalVariable</code> </pre> <br><p>  Und hier ist die Funktion <code>veryUsefulFunction()</code> (unter Linux): </p><br><pre> <code class="plaintext hljs">0000000000000000 &lt;_Z18veryUsefulFunctionv&gt;: 0: 55 push rbp 1: 48 89 e5 mov rbp,rsp 4: 48 8b 05 00 00 00 00 mov rax,QWORD PTR [rip+0x0] b: 8b 0d 00 00 00 00 mov ecx,DWORD PTR [rip+0x0] 11: 83 c1 01 add ecx,0x1 14: 89 0d 00 00 00 00 mov DWORD PTR [rip+0x0],ecx 1a: 8b 08 mov ecx,DWORD PTR [rax] 1c: 03 0d 00 00 00 00 add ecx,DWORD PTR [rip+0x0] 22: 89 c8 mov eax,ecx 24: 5d pop rbp 25: c3 ret</code> </pre> <br><p>  und so nach dem Verkn√ºpfen des Objekts mit der dynamischen Bibliothek: </p><br><pre> <code class="plaintext hljs">00000000000010e0 &lt;_Z18veryUsefulFunctionv&gt;: 10e0: 55 push rbp 10e1: 48 89 e5 mov rbp,rsp 10e4: 48 8b 05 05 21 00 00 mov rax,QWORD PTR [rip+0x2105] 10eb: 8b 0d 13 2f 00 00 mov ecx,DWORD PTR [rip+0x2f13] 10f1: 83 c1 01 add ecx,0x1 10f4: 89 0d 0a 2f 00 00 mov DWORD PTR [rip+0x2f0a],ecx 10fa: 8b 08 mov ecx,DWORD PTR [rax] 10fc: 03 0d 02 2f 00 00 add ecx,DWORD PTR [rip+0x2f02] 1102: 89 c8 mov eax,ecx 1104: 5d pop rbp 1105: c3 ret</code> </pre> <br><p>  Es gibt 4 Stellen, an denen 4 Bytes f√ºr die Adresse realer Variablen reserviert sind. </p><br><p>  Auf verschiedenen Systemen sind die m√∂glichen Umz√ºge Ihre eigenen.  Unter Linux unter x86-64 bis zu <a href="">40 Arten von Umz√ºgen</a> .  Unter macOS unter x86-64 gibt es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nur 9</a> davon.  Alle Arten von Umz√ºgen k√∂nnen bedingt in zwei Gruppen unterteilt werden: </p><br><ol><li>  Verschiebungen zur Verkn√ºpfungszeit - Verschiebungen, die beim Verkn√ºpfen von Objektdateien mit einer ausf√ºhrbaren Datei oder einer dynamischen Bibliothek verwendet werden </li><li>  Ladezeitverschiebungen - Verschiebungen, die zum Zeitpunkt des Ladens der dynamischen Bibliothek in den Prozessspeicher angewendet werden </li></ol><br><p>  Die zweite Gruppe umfasst Verschiebungen exportierter Funktionen und Variablen.  Wenn eine dynamische Bibliothek in den Prozessspeicher geladen wird, sucht der Linker f√ºr alle dynamischen Verschiebungen (einschlie√ülich Verschiebungen globaler Variablen) nach der Definition von Symbolen in allen bereits geladenen Bibliotheken, einschlie√ülich im Programm selbst, und die Adresse des ersten geeigneten Symbols wird f√ºr die Verschiebung verwendet.  Daher muss mit diesen Verschiebungen nichts unternommen werden. Der Linker findet die Variable aus unserer Anwendung selbst, da sie fr√ºher in seine Liste der geladenen Bibliotheken und Programme aufgenommen wird, und ersetzt ihre Adresse im neuen Code, wobei die neue Version dieser Variablen ignoriert wird. </p><br><p>  Mit macOS und seinem dynamischen Linker ist ein subtiler Punkt verbunden.  MacOS implementiert den sogenannten zweistufigen Namespace-Mechanismus.  Wenn es unh√∂flich ist, sucht der Linker beim Laden einer dynamischen Bibliothek zuerst nach Zeichen in dieser Bibliothek. Wenn er sie nicht findet, sucht er in anderen.  Dies erfolgt zu Leistungszwecken, sodass Umz√ºge schnell aufgel√∂st werden, was im Allgemeinen logisch ist.  Dies unterbricht jedoch unseren Fluss in Bezug auf globale Variablen.  Gl√ºcklicherweise gibt es in ld unter macOS ein spezielles Flag - <code>-flat_namespace</code> . Wenn Sie eine Bibliothek mit diesem Flag erstellen, ist der Zeichensuchalgorithmus mit dem unter Linux identisch. </p><br><p>  Die erste Gruppe umfasst die Verlagerung statischer Variablen - genau das, was wir brauchen.  Das einzige Problem ist, dass sich diese Verschiebungen nicht in der kompilierten Bibliothek befinden, da sie bereits vom Linker aufgel√∂st werden.  Daher werden wir sie aus den Objektdateien lesen, aus denen die Bibliothek zusammengestellt wurde. <br>  M√∂gliche Arten von Verschiebungen sind auch dadurch begrenzt, ob der zusammengestellte Code positionsabh√§ngig ist oder nicht.  Da wir unseren Code im PIC-Modus (positionsunabh√§ngiger Code) erfassen, werden Verschiebungen nur relativ verwendet.  Total Umz√ºge, die uns interessieren, sind: </p><br><ul><li>  <code>.rela.text</code> aus dem Abschnitt <code>.rela.text</code> unter Linux und die Verschiebungen, auf die <code>__text</code> Abschnitt <code>__text</code> unter macOS <code>__text</code> wird, und </li><li>  Dabei werden Zeichen aus den Abschnitten <code>.data</code> und <code>.bss</code> unter Linux und <code>__data</code> , <code>__bss</code> und <code>__common</code> unter macOS und verwendet </li><li>  <code>R_X86_64_PC32</code> vom Typ <code>R_X86_64_PC32</code> und <code>R_X86_64_PC64</code> unter Linux und <code>X86_64_RELOC_SIGNED</code> , <code>X86_64_RELOC_SIGNED_1</code> , <code>X86_64_RELOC_SIGNED_2</code> und <code>X86_64_RELOC_SIGNED_4</code> unter macOS </li></ul><br><p>  Der subtile Punkt, der <code>__common</code> Abschnitt <code>__common</code> ist.  Linux hat auch einen √§hnlichen <code>*COM*</code> -Abschnitt.  Globale Variablen k√∂nnen in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen Abschnitt fallen</a> .  W√§hrend ich eine Reihe von Codefragmenten unter Linux getestet und kompiliert habe, waren Zeichenverschiebungen aus <code>*COM*</code> -Abschnitten immer dynamisch, wie normale globale Variablen.  Gleichzeitig wurden unter macOS solche Zeichen manchmal w√§hrend der Verkn√ºpfung verschoben, wenn sich die Funktion und das Zeichen in derselben Datei befinden.  Unter macOS ist es daher sinnvoll, diesen Abschnitt beim Lesen von Zeichen und Verschiebungen zu ber√ºcksichtigen. </p><br><p>  Nun haben wir eine Reihe von Umz√ºgen, die wir brauchen. Was tun mit ihnen?  Die Logik hier ist einfach.  Wenn der Linker die Bibliothek verkn√ºpft, schreibt er die Adresse des durch eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bestimmte Formel</a> berechneten Symbols an die Umzugsadresse.  F√ºr unsere Umz√ºge auf beiden Plattformen enth√§lt diese Formel die Adresse des Symbols als Begriff.  Somit hat die berechnete Adresse, die bereits im Funktionsk√∂rper aufgezeichnet ist, die Form: </p><br><pre> <code class="plaintext hljs">resultAddr = newVarAddr + addend - relocAddr</code> </pre> <br><p>  Gleichzeitig kennen wir die Adressen beider Variablenversionen - alt, bereits in der Anwendung vorhanden und neu.  Es bleibt uns √ºberlassen, es gem√§√ü der Formel zu √§ndern: </p><br><pre> <code class="plaintext hljs">resultAddr = resultAddr - newVarAddr + oldVarAddr</code> </pre> <br><p>  und schreiben Sie es an die Umzugsadresse.  Danach verwenden alle Funktionen im neuen Code die vorhandenen Versionen der Variablen, und die neuen Variablen l√ºgen einfach und tun nichts.  Was du brauchst!  Aber es gibt einen subtilen Punkt. </p><br><h3 id="zagruzka-biblioteki-s-novym-kodom">  Herunterladen der Bibliothek mit dem neuen Code </h3><br><p>  Wenn das System eine dynamische Bibliothek in den Prozessspeicher l√§dt, kann sie an einer beliebigen Stelle im virtuellen Adressraum abgelegt werden.  Auf meinem Ubuntu 18.04 wird die Anwendung unter <code>0x00400000</code> und unsere dynamischen Bibliotheken direkt nach <code>ld-2.27.so</code> unter Adressen im Bereich <code>0x7fd3829bd000</code> .  Der Abstand zwischen den Download-Adressen des Programms und der Bibliothek ist viel gr√∂√üer als die Zahl, die in die vorzeichenbehaftete 32-Bit-Ganzzahl passen w√ºrde.  Und bei Verschiebungen w√§hrend der Verbindungszeit sind nur 4 Bytes f√ºr Adressen von Zielzeichen reserviert. </p><br><p>  Nachdem ich die Dokumentation f√ºr Compiler und Linker geraucht hatte, entschied ich mich, die Option <code>-mcmodel=large</code> auszuprobieren.  Es zwingt den Compiler, Code ohne Annahmen √ºber den Abstand zwischen Zeichen zu generieren, wodurch angenommen wird, dass alle Adressen 64-Bit sind.  Diese Option ist jedoch nicht PIC-freundlich, da <code>-mcmodel=large</code> zumindest unter macOS nicht mit <code>-fPIC</code> verwendet werden kann.  Ich verstehe immer noch nicht, was das Problem ist, vielleicht gibt es unter macOS keine geeigneten Umz√ºge f√ºr diese Situation. </p><br><p>  In der Bibliothek unter Windows wird dieses Problem wie folgt gel√∂st.  Die H√§nde weisen einen virtuellen Speicherplatz in der N√§he des Download-Speicherorts der Anwendung zu, der ausreicht, um die erforderlichen Abschnitte der Bibliothek aufzunehmen.  Dann werden Abschnitte mit H√§nden in sie geladen, die erforderlichen Rechte werden auf Speicherseiten mit den entsprechenden Abschnitten gesetzt, alle Verschiebungen werden von H√§nden entpackt und alles andere wird gepatcht.  Ich bin faul  Ich wollte diese ganze Arbeit wirklich nicht mit Ladezeitverlagerungen machen, besonders unter Linux.  Und warum wei√ü ein dynamischer Linker bereits, wie es geht?  Schlie√ülich wissen die Leute, die es geschrieben haben, viel mehr als ich. </p><br><p>  Gl√ºcklicherweise wurden in der Dokumentation die erforderlichen Optionen gefunden, um anzugeben, wo unsere dynamische Bibliothek heruntergeladen werden soll: </p><br><ul><li>  Apple ld: <code>-image_base 0xADDRESS</code> </li><li>  LLVM lld: <code>--image-base=0xADDRESS</code> </li><li>  GNU ld: <code>-Ttext-segment=0xADDRESS</code> </li></ul><br><p>  Diese Optionen sollten zum Zeitpunkt der Verkn√ºpfung der dynamischen Bibliothek an den Linker √ºbergeben werden.  Es gibt 2 Schwierigkeiten. <br>  Der erste bezieht sich auf GNU ld.  Damit diese Optionen funktionieren, m√ºssen Sie: </p><br><ul><li>  Zum Zeitpunkt des Ladens der Bibliothek war der Bereich, in den wir sie laden m√∂chten, frei </li><li>  Die in der Option angegebene Adresse muss ein Vielfaches der Seitengr√∂√üe sein (unter x86-64 Linux und macOS ist sie <code>0x1000</code> ). </li><li>  Zumindest unter Linux muss die in der Option angegebene Adresse ein Vielfaches der Ausrichtung des <code>PT_LOAD</code> Segments sein </li></ul><br><p>  Das hei√üt, wenn der Linker die Ausrichtung auf <code>0x10000000</code> , kann diese Bibliothek nicht unter der Adresse <code>0x10001000</code> geladen werden, selbst wenn ber√ºcksichtigt wird, dass die Adresse an der Seitengr√∂√üe ausgerichtet ist.  Wenn eine dieser Bedingungen nicht erf√ºllt ist, wird die Bibliothek "wie gewohnt" geladen.  Ich habe GNU ld 2.30 auf meinem System und im Gegensatz zu LLVM lld wird die Ausrichtung des <code>PT_LOAD</code> Segments <code>0x20000</code> auf <code>0x20000</code> , was sehr <code>0x20000</code> ist.  Um dies zu <code>-Ttext-segment=...</code> , geben Sie zus√§tzlich zur Option <code>-Ttext-segment=...</code> <code>-z max-page-size=0x1000</code> .  Ich verbrachte einen Tag, bis mir klar wurde, warum die Bibliothek nicht dort geladen wird, wo ich muss. </p><br><p>  Die zweite Schwierigkeit - die Download-Adresse sollte in der Verkn√ºpfungsphase der Bibliothek bekannt sein.  Es ist nicht sehr schwer zu organisieren.  Unter Linux reicht es aus, die Pseudodatei <code>/proc/&lt;pid&gt;/maps</code> zu analysieren, das n√§chste unbesetzte Teil des Programms zu finden, in das die Bibliothek passt, und beim Verkn√ºpfen die Adresse am Anfang dieses Teils zu verwenden.  Die Gr√∂√üe der zuk√ºnftigen Bibliothek kann grob gesch√§tzt werden, indem die Gr√∂√üe der Objektdateien betrachtet oder analysiert und die Gr√∂√üe aller Abschnitte berechnet wird.  Am Ende brauchen wir keine genaue Zahl, sondern eine ungef√§hre Gr√∂√üe mit einem Rand. </p><br><p>  MacOS verf√ºgt nicht √ºber <code>/proc/*</code> . Stattdessen wird empfohlen, das Dienstprogramm <code>vmmap</code> .  Die Ausgabe des <code>vmmap -interleaved &lt;pid&gt;</code> enth√§lt dieselben Informationen wie <code>proc/&lt;pid&gt;/maps</code> .  Aber hier ergibt sich eine andere Schwierigkeit.  Wenn eine Anwendung einen untergeordneten Prozess erstellt, der diesen Befehl ausf√ºhrt, und die Kennung des aktuellen Prozesses als <code>&lt;pid&gt;</code> , bleibt das Programm h√§ngen.  So wie ich es verstehe, stoppt <code>vmmap</code> den Prozess, um seine Speicherzuordnungen zu lesen, und anscheinend geht etwas schief, wenn dies der aufrufende Prozess ist.  In diesem Fall m√ºssen Sie das zus√§tzliche Flag <code>-forkCorpse</code> damit <code>vmmap</code> einen leeren <code>vmmap</code> Prozess aus unserem Prozess erstellt, die Zuordnung daraus entfernt und beendet, ohne das Programm zu unterbrechen. </p><br><p>  Das ist im Grunde alles, was wir wissen m√ºssen. </p><br><h3 id="sobiraem-vse-vmeste">  Alles zusammenf√ºgen </h3><br><p>  Mit diesen √Ñnderungen sieht der endg√ºltige Algorithmus zum erneuten Laden des Codes folgenderma√üen aus: </p><br><ol><li>  Kompilieren Sie den neuen Code in Objektdateien </li><li>  F√ºr Objektdateien sch√§tzen wir die Gr√∂√üe der zuk√ºnftigen Bibliothek </li><li>  Lesen von Umzugsobjektdateien </li><li>  Wir suchen nach einem freien virtuellen Speicher neben der Anwendung </li><li>  Wir erstellen eine dynamische Bibliothek mit den erforderlichen Optionen, <code>dlopen</code> √ºber <code>dlopen</code> </li><li>  Patch-Code entsprechend der Verlagerung der Verbindungszeit </li><li>  Patch-Funktion </li><li>  Kopieren Sie statische Variablen, die nicht an Schritt 6 teilgenommen haben </li></ol><br><p>  Nur Schutzvariablen statischer Variablen fallen in Schritt 8, sodass sie sicher kopiert werden k√∂nnen (wodurch die "Initialisierung" der statischen Variablen selbst erhalten bleibt). </p><br><h3 id="zaklyuchenie">  Fazit </h3><br><p>  Da es sich ausschlie√ülich um ein Entwicklungstool handelt, das nicht f√ºr eine Produktion vorgesehen ist, ist das Schlimmste, was passieren kann, wenn die n√§chste Bibliothek mit dem neuen Code nicht in den Speicher passt oder versehentlich an einer anderen Adresse geladen wird, ein Neustart der debuggten Anwendung.  Beim Ausf√ºhren von Tests werden nacheinander 31 Bibliotheken mit aktualisiertem Code in den Speicher geladen. </p><br><p>  Der Vollst√§ndigkeit halber fehlen 3 weitere gewichtige Teile in der Implementierung: </p><br><ol><li>  Jetzt wird die Bibliothek mit dem neuen Code in den Speicher neben dem Programm geladen, obwohl Code aus einer anderen dynamischen Bibliothek, die weit geladen wurde, in diesen gelangen kann.  Um dies zu beheben, m√ºssen Sie den Besitz der √úbersetzungseinheiten f√ºr die eine oder andere Bibliothek und das andere Programm verfolgen und die Bibliothek bei Bedarf mit dem neuen Code aufteilen. </li><li>  Das erneute Laden von Code in einer Multithread-Anwendung ist immer noch unzuverl√§ssig (mit Sicherheit k√∂nnen Sie nur Code neu laden, der im selben Thread wie die Runloop-Bibliothek ausgef√ºhrt wird).  Zur Fixierung muss ein Teil der Implementierung in ein separates Programm verschoben werden. Dieses Programm muss vor dem Patchen den Prozess mit allen Threads stoppen, patchen und wieder funktionieren.  Ich wei√ü nicht, wie ich das ohne ein externes Programm machen soll. </li><li>  Verhinderung eines versehentlichen Absturzes der Anwendung nach dem erneuten Laden des Codes.  Nach dem Korrigieren des Codes k√∂nnen Sie den ung√ºltigen Zeiger im neuen Code versehentlich dereferenzieren. Danach m√ºssen Sie die Anwendung neu starten.  Nichts falsches, aber trotzdem.  Klingt nach schwarzer Magie, ich bin immer noch in Gedanken. </li></ol><br><p>  Aber bereits die aktuelle Implementierung hat mir pers√∂nlich geholfen, sie reicht f√ºr meine Hauptaufgabe aus.  Es ist etwas gew√∂hnungsbed√ºrftig, aber der Flug ist normal. <br>  Wenn ich zu diesen drei Punkten komme und in ihrer Umsetzung gen√ºgend interessante Dinge finde, werde ich sie auf jeden Fall teilen. </p><br><h3 id="demo">  Demo </h3><br><p>  Da die Implementierung das Hinzuf√ºgen neuer Sendeeinheiten im laufenden Betrieb erm√∂glicht, habe ich beschlossen, ein kurzes Video aufzunehmen, in dem ich ein obsz√∂nes einfaches Spiel von Grund auf √ºber ein Raumschiff schreibe, das die Weiten des Universums pfl√ºgt und quadratische Asteroiden schie√üt.  Ich habe versucht, nicht im Stil von "Alles in einer Datei" zu schreiben, sondern, wenn m√∂glich, alles in den Regalen anzuordnen und dabei viele kleine Dateien zu generieren (daher kam so viel Kritzeleien heraus).  Nat√ºrlich wird das Framework f√ºr Zeichnungen, Eingaben, Fenster und andere Dinge verwendet, aber der Code des Spiels selbst wurde von Grund auf neu geschrieben. <br>  Das Hauptmerkmal - Ich habe die Anwendung nur dreimal ausgef√ºhrt: ganz am Anfang, als sie nur eine leere Szene hatte, und zweimal nach dem Sturz aufgrund meiner Nachl√§ssigkeit.  Das ganze Spiel wurde schrittweise in den Prozess des Codeschreibens eingegossen.  Echtzeit - ungef√§hr 40 Minuten.  Im Allgemeinen sind Sie herzlich willkommen. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/5xfgViYchqg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Wie immer freue ich mich √ºber jede Kritik, danke! </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link zur Implementierung</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437312/">https://habr.com/ru/post/de437312/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437300/index.html">10 F√§higkeiten und Kenntnisse, die f√ºr einen iOS-Anf√§nger erforderlich sind</a></li>
<li><a href="../de437304/index.html">Wie man Kartoffeln kauft, wenn man farbenblind ist</a></li>
<li><a href="../de437306/index.html">Nicht offensichtliche F√§higkeiten, die der Produktmanager ben√∂tigt</a></li>
<li><a href="../de437308/index.html">SDL 2.0-Unterrichtszyklus: Lektion 4 - Behandeln von Ereignissen</a></li>
<li><a href="../de437310/index.html">CSS-Verlaufsgrenzen</a></li>
<li><a href="../de437314/index.html">Italienisches R√§tsel: OMI-Kryptografiemaschinen</a></li>
<li><a href="../de437316/index.html">Das Internet Development Institute hat Websites benannt, die seit dem 1. Februar m√∂glicherweise nicht mehr mit RuNet verbunden sind</a></li>
<li><a href="../de437318/index.html">Nahtlose (fast) Migration zwischen wichtigen PostgreSQL-Versionen mithilfe der logischen Replikation</a></li>
<li><a href="../de437320/index.html">2018 Media Sphere Development Index: Stagnation des Fernsehens, erh√∂htes Vertrauen in informelle Medien</a></li>
<li><a href="../de437322/index.html">Der Staat ist an BigDate beteiligt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>