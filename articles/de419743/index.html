<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤚🏾 👨🏿‍🏭 🍓 Was ist falsch an populären Artikeln, die besagen, dass foo schneller als bar ist? 😨 🧔🏾 👩‍👩‍👦‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Anmerkung des Übersetzers: Ich dachte auch, dass die Zeit für die Artikel "Was ist schneller - doppelte oder einfache Anführungszeichen?" Ist. Es hat ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Was ist falsch an populären Artikeln, die besagen, dass foo schneller als bar ist?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419743/"><p>  <em><strong>Anmerkung des Übersetzers:</strong> Ich dachte auch, dass die Zeit für die Artikel "Was ist schneller - doppelte oder einfache Anführungszeichen?" Ist.</em>  <em>Es hat noch 10 Jahre gedauert.</em>  <em>Aber hier hat ein ähnlicher Artikel ("Welche Leistungstricks tatsächlich funktionieren") kürzlich eine relativ hohe Bewertung für Reddit erhalten und ist sogar in den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PHP-Digest</a> für Habré eingestiegen.</em>  <em>Dementsprechend habe ich beschlossen, den Artikel mit einer kritischen Analyse dieser und ähnlicher "Tests" zu übersetzen.</em> </p><br><p>  Es gibt viele Artikel (und sogar ganze Websites), die sich mit dem Starten verschiedener Tests befassen, in denen die Leistung verschiedener syntaktischer Konstruktionen verglichen wird und auf dieser Grundlage angegeben wird, dass einer schneller als der andere ist. </p><br><h3 id="glavnaya-problema">  Hauptproblem </h3><br><p>  Solche Tests sind aus vielen Gründen falsch, von Fragen bis hin zu Implementierungsfehlern.  Vor allem aber sind solche Tests bedeutungslos <em>und gleichzeitig</em> schädlich. </p><br><ul><li>  Sie sind bedeutungslos, weil sie keinen praktischen Wert haben.  Kein wirkliches Projekt wurde jemals mit den in solchen Artikeln bereitgestellten Methoden beschleunigt.  Nur weil nicht die Unterschiede in der Syntax für die Leistung von Bedeutung sind, sondern <strong>die Datenverarbeitung.</strong> </li><li>  Sie sind schädlich, weil sie zum Auftreten des wildesten Aberglaubens führen und - noch schlimmer - ahnungslose Leser dazu ermutigen, schlechten Code zu schreiben, weil sie denken, dass sie ihn "optimieren". </li></ul><br><p>  Das sollte ausreichen, um die Frage zu schließen.  Aber selbst wenn Sie die Spielregeln akzeptieren und so tun, als hätten diese „Tests“ zumindest einen gewissen Sinn, stellt sich heraus, dass ihre Ergebnisse nur auf eine Demonstration des Mangels an Wissen des Testers und seiner mangelnden Erfahrung reduziert werden. <a name="habracut"></a></p><br><h3 id="odinarnye-protiv-dvoynyh">  Einzel gegen Doppel </h3><br><p>  Nehmen Sie die berüchtigten Zitate "einfach gegen doppelt".  Natürlich sind keine Zitate schneller.  Erstens gibt es so etwas wie einen <em>Opcode-Cache</em> , der das Ergebnis des Parsens des PHP-Skripts im Cache speichert.  In diesem Fall wird der PHP-Code im Opcode-Format gespeichert, in dem dieselben Zeichenfolgenliterale als absolut identische Entitäten gespeichert werden, unabhängig davon, welche Anführungszeichen im PHP-Skript verwendet wurden.  Was bedeutet, dass nicht einmal ein theoretischer Leistungsunterschied vorliegt. </p><br><p>  Aber selbst wenn wir keinen Opcode-Cache verwenden (obwohl wir dies tun sollten, wenn unsere Aufgabe darin besteht, die Leistung wirklich zu steigern), werden wir feststellen, dass der Unterschied beim Parsen von Code so gering ist (mehrere bedingte Übergänge, bei denen Einzelbyte-Zeichen verglichen werden, buchstäblich mehrere Prozessoranweisungen), dass dies absolut der Fall ist nicht nachweisbar.  Dies bedeutet, dass alle erhaltenen Ergebnisse nur Probleme in der Testumgebung zeigen.  Es gibt einen sehr detaillierten Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">des</a> PHP-Kernentwicklers Nikita Popov, in dem dieses Problem ausführlich analysiert wird.  Trotzdem erscheint fast jeden Monat ein Energietester, um der Gesellschaft einen imaginären „Leistungsunterschied“ aufzuzeigen. </p><br><h3 id="logicheskie-nestykovki">  Logische Inkonsistenzen </h3><br><p>  Einige Tests sind im Allgemeinen bedeutungslos, einfach unter dem Gesichtspunkt, die Frage zu stellen: Zum Beispiel der Test mit dem Titel "Ist Werfen wirklich eine super teure Operation?"  Dies ist im Wesentlichen die Frage "Ist es wirklich so, dass die Verarbeitung eines Fehlers teurer ist als die Nichtbearbeitung?".  Ist das dein ernst  Wenn Sie dem Code einige grundlegende Funktionen hinzufügen, wird er natürlich „langsamer“.  Dies bedeutet jedoch nicht, dass unter einem so lächerlichen Vorwand überhaupt keine neuen Funktionen hinzugefügt werden müssen.  Wenn Sie so reden, dann ist das schnellste Programm eines, das überhaupt nichts tut!  Das Programm sollte nützlich sein und in erster Linie fehlerfrei funktionieren.  Und erst wenn dies erreicht ist und nur wenn es langsam funktioniert, muss es optimiert werden.  Aber wenn die Frage selbst keinen Sinn ergibt, warum dann die Leistung testen?  Es ist lustig, dass der Tester selbst diesen sinnlosen Test nicht korrekt implementieren konnte, der im nächsten Abschnitt gezeigt wird. </p><br><p> Oder ein anderes Beispiel, ein Test mit dem Titel "Wird <code>$row[id]</code> wirklich langsamer sein als <code>$row['id']</code> ?"  Dies ist im Wesentlichen die Frage "Welcher Code ist schneller - derjenige, der mit oder ohne Fehler arbeitet?"  (Da das Schreiben einer <code>id</code> ohne Anführungszeichen in diesem Fall ein Fehler der <code>E_NOTICE</code> Ebene ist und ein solches Schreiben in zukünftigen Versionen von PHP veraltet ist).  WTF?  Was ist der Sinn der allgemeinen Messung der Leistung von Fehlercode?  Der Fehler sollte einfach behoben werden, weil es sich um einen Fehler handelt und nicht, weil dadurch der Code langsamer ausgeführt wird.  Es ist lustig, dass der Tester selbst diesen sinnlosen Test nicht korrekt implementieren konnte, der im nächsten Abschnitt gezeigt wird. </p><br><h3 id="kachestvo-testov">  Testqualität </h3><br><p>  Und wieder - selbst ein wissentlich nutzloser Test sollte konsistent und konsistent sein - das heißt, vergleichbare Werte messen.  In der Regel werden solche Tests jedoch mit der linken Ferse durchgeführt, sodass die erzielten Ergebnisse bedeutungslos und für die Aufgabe nicht relevant sind. </p><br><p>  Zum Beispiel hat sich unser dummer Tester verpflichtet, "übermäßige Nutzung des <code>try..catch</code> Operators" zu messen.  Im aktuellen Test maß er jedoch nicht nur den <code>try catch</code> , sondern auch zu <code>throw</code> , wobei bei jeder Iteration der Schleife eine Ausnahme ausgelöst wurde.  Ein solcher Test ist jedoch einfach falsch, da im wirklichen Leben nicht bei jeder Skriptausführung Fehler auftreten. </p><br><p>  Natürlich sollten Tests nicht mit Beta-Versionen von PHP durchgeführt werden und Mainstream-Lösungen sollten nicht mit experimentellen verglichen werden.  Und wenn sich der Tester verpflichtet, die "Parsing-Geschwindigkeit von json und xml" zu vergleichen, sollte er die experimentelle Funktion in den Tests nicht verwenden. </p><br><p>  Einige Tests zeigen lediglich ein völliges Missverständnis des Testers der von ihm gestellten Aufgabe.  Ein ähnliches Beispiel aus einem kürzlich veröffentlichten Artikel wurde bereits oben erwähnt: Der Autor des Tests hat versucht herauszufinden, ob der Code, der den Fehler verursacht hat ("Verwendung einer undefinierten Konstante"), langsamer ist als der Code ohne Fehler (der ein syntaktisch korrektes Zeichenfolgenliteral verwendet), ist jedoch fehlgeschlagen Selbst bei diesem offensichtlich bedeutungslosen Test wird die Leistung <em>einer zitierten Zahl</em> mit der Leistung einer ohne Anführungszeichen geschriebenen Zahl verglichen.  Natürlich können Sie in PHP Zahlen ohne Anführungszeichen schreiben (im Gegensatz zu Zeichenfolgen). Infolgedessen hat der Autor eine völlig andere Funktionalität getestet und falsche Ergebnisse erhalten. </p><br><p>  Es sind noch weitere Aspekte zu berücksichtigen, z. B. die Testumgebung.  Es gibt PHP-Erweiterungen wie XDebug, die einen großen Einfluss auf die Testergebnisse haben können.  Oder der bereits erwähnte Opcode-Cache, der bei Leistungstests enthalten sein muss, damit die Testergebnisse zumindest einen Sinn ergeben. </p><br><p>  Wie Tests durchgeführt werden, ist ebenfalls wichtig.  Da der PHP-Prozess nach jeder Anforderung vollständig abbricht, ist es sinnvoll, die Leistung des gesamten Lebenszyklus zu testen, angefangen beim Erstellen einer Verbindung zu einem Webserver bis hin zum Schließen dieser Verbindung.  Es gibt Dienstprogramme wie Apache Benchmark oder Siege, mit denen Sie dies tun können. </p><br><h3 id="realnoe-uluchshenie-proizvoditelnosti">  Echte Leistungsverbesserung </h3><br><p>  Das alles ist gut, aber welche Schlussfolgerung sollte der Leser aus diesem Artikel ziehen?  Welche Leistungstests sind per Definition nutzlos?  Natürlich nicht.  Aber was wirklich zählt, ist der <em>Grund</em> , <em>warum</em> sie anfangen sollten.  Testen von Grund auf ist Zeitverschwendung.  Es sollte immer einen bestimmten Grund für die Durchführung von Leistungstests geben.  Und dieser Grund wird als <em>"Profiling" bezeichnet.</em>  Wenn Ihre Anwendung langsam ausgeführt wird, müssen Sie eine Profilerstellung durchführen. Dies bedeutet, dass Sie die Geschwindigkeit verschiedener Codeabschnitte messen müssen, um den langsamsten zu finden.  Nachdem eine solche Site gefunden wurde, müssen wir die Ursache ermitteln.  In den meisten Fällen ist dies entweder viel größer als erforderlich, die Menge der verarbeiteten Daten oder eine Anforderung an eine externe Datenquelle.  Im ersten Fall besteht die Optimierung darin, die Menge der verarbeiteten Daten zu reduzieren und im zweiten Fall die Abfrageergebnisse zwischenzuspeichern. </p><br><p>  In Bezug auf die Leistung spielt es beispielsweise keine Rolle, ob wir eine explizit vorgeschriebene Schleife oder die integrierte PHP-Funktion verwenden, um Arrays zu verarbeiten (was im Wesentlichen nur syntaktischer Zucker ist).  Was wirklich wichtig ist, ist die <em>Datenmenge</em> , die wir zur Verarbeitung übertragen.  Wenn es unangemessen groß ist, müssen wir es kürzen oder die Verarbeitung an einen anderen Ort (in die Datenbank) verschieben.  Dies gibt uns einen <em>enormen</em> Leistungsschub, der <em>real sein wird</em> .  Während der Unterschied zwischen den Methoden zum Aufrufen der Schleife für die Datenverarbeitung wahrscheinlich überhaupt nicht erkennbar ist. </p><br><p>  Erst nachdem solche obligatorischen Leistungsverbesserungen durchgeführt wurden oder wenn wir die Menge der verarbeiteten Daten nicht reduzieren können, können wir Leistungstests starten.  Andererseits sollten solche Tests nicht von Grund auf neu durchgeführt werden.  Um die Leistung einer expliziten Schleife und einer Inline-Funktion vergleichen zu können, müssen wir sicher sein, dass die Schleife die Ursache des Problems ist und nicht deren Inhalt (Spoiler: Dies ist natürlich der Inhalt). </p><br><p>  Ein aktuelles Beispiel aus meiner Praxis: Im Code gab es eine Abfrage mit Doctrine Query Builder, die mehrere tausend Parameter annehmen sollte.  Die Abfrage selbst ist schnell genug, aber Doctrine benötigt eine ganze Weile, um mehrere tausend Parameter zu verarbeiten.  Infolgedessen wurde die Abfrage in reinem SQL neu geschrieben und die Parameter wurden in die execute () -Methode der PDO-Bibliothek übertragen, die so viele Parameter fast sofort verarbeitet. </p><br><p>  Bedeutet dies, dass ich Doctrine Query Builder niemals verwenden werde?  Natürlich nicht.  Es ist perfekt für 99% der Aufgaben und ich werde es weiterhin für alle Abfragen verwenden.  Und nur in Ausnahmefällen lohnt es sich, eine weniger bequeme, aber produktivere Methode zu verwenden. </p><br><p>  Die Abfrage und die Parameter für diese Auswahl wurden in einer Schleife erstellt.  Wenn ich eine blöde Idee hätte, wie der Zyklus aufgerufen wird, würde ich einfach Zeit verlieren, ohne ein positives Ergebnis zu erzielen.  Und das ist das Wesentliche aller Leistungsoptimierungen: <strong>Nur den Code</strong> zu <strong>optimieren, der</strong> in Ihrem speziellen Fall <strong>langsam ausgeführt</strong> wird.  Und nicht der Code, der vor langer Zeit in einer fernen Galaxie als langsam galt, oder der Code, den jemand aufgrund bedeutungsloser Tests als langsam bezeichnete. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de419743/">https://habr.com/ru/post/de419743/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de419727/index.html">Harbour - eine Registrierung für sofort einsatzbereite Docker-Container</a></li>
<li><a href="../de419729/index.html">Wohltätigkeitsveranstaltung „Geben Sie Kindern Flügel“</a></li>
<li><a href="../de419731/index.html">Mini-Review des Dentalphotopolymer-3D-Druckers MoonRay S.</a></li>
<li><a href="../de419733/index.html">Git passiert! 6 Häufige Git-Fehler und deren Behebung</a></li>
<li><a href="../de419735/index.html">Untersuchen des I / Q-Signals mit SDR mithilfe von Adobe Audition</a></li>
<li><a href="../de419745/index.html">Klassisches KI-Genre: ML sucht sich in der Poesie</a></li>
<li><a href="../de419747/index.html">DJI Ronin S - Erster Start und Hauptmerkmale</a></li>
<li><a href="../de419757/index.html">Übersetzung von Andrew Un's Buch, Leidenschaft für maschinelles Lernen, Kapitel 1 - 14</a></li>
<li><a href="../de419759/index.html">Interne DSL- und Ausdrucksbäume - Dynamische Erstellung von Funktionen zum Serialisieren, Kopieren, Klonen und Gleichstellen (Teil I)</a></li>
<li><a href="../de419761/index.html">Erstellen Sie ein 2D-Spiel in Python mit der Arcade-Bibliothek</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>