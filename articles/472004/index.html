<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äçü§ù‚Äçüë®üèª üï∏Ô∏è üïõ Impulsar el esp√≠ritu o agregar "espiritualidad" a los filtros de lista üßóüèø üç¶ üöû</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Buen d√≠a, colegas. Todav√≠a soy un desarrollador de sistemas ISP, y mi nombre sigue siendo Dmitry Smirnov. Durante un tiempo (bastante largo) no pude d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Impulsar el esp√≠ritu o agregar "espiritualidad" a los filtros de lista</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ispsystem/blog/472004/"><p><img src="https://habrastorage.org/webt/qv/yu/6-/qvyu6-kaqci3ha5ivctj0nvbwco.png" alt="imagen"></p><br><p>  Buen d√≠a, colegas.  Todav√≠a soy un desarrollador de sistemas ISP, y mi nombre sigue siendo Dmitry Smirnov.  Durante un tiempo (bastante largo) no pude decidir sobre el tema de la pr√≥xima publicaci√≥n, ya que se ha acumulado mucho material en los √∫ltimos meses de trabajo con Boost.Asio.  E incluso en ese momento cuando parec√≠a que era m√°s f√°cil lanzar una moneda, una tarea cambi√≥ todo.  Fue necesario desarrollar una herramienta que permita a la interfaz filtrar datos en las listas solicitadas.  La lista misma del backend es un json_array ordinario.  Bienvenido a Kat, hay todos los altibajos de los √∫ltimos d√≠as. </p><a name="habracut"></a><br><h3 id="diskleymer">  Descargo de responsabilidad </h3><br><p>  Debo decir de inmediato que la √∫ltima vez que el autor "sinti√≥" algo as√≠ como una gram√°tica libre de contexto hace diez a√±os.  Entonces parec√≠a una herramienta bastante innecesaria, pero aprend√≠ sobre la biblioteca Boost.Spirit el d√≠a de la declaraci√≥n del problema. </p><br><h3 id="zadacha">  Desaf√≠o </h3><br><p>  Necesita activar una consulta como: </p><br><pre><code class="cpp hljs">(string_field CP value AND int_field NOT LT <span class="hljs-number"><span class="hljs-number">150</span></span>) OR bool_field EQ <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><p>  En alguna estructura que verificar√° el objeto json e informar√° si cumple con los requisitos o no. </p><br><h3 id="pervye-shagi">  Primeros pasos </h3><br><p>  En primer lugar, debe decidir sobre la interfaz del filtro futuro.  Es necesario eliminar objetos innecesarios de la matriz, por lo que debe combinarse con algoritmos STL, en particular std :: remove_if. </p><br><p>  Un functor ser√° perfecto, que se construir√° directamente a partir de la solicitud desde el frente.  Como el proyecto usa nlohmann :: json, el dise√±o ser√° bastante elegante: </p><br><pre> <code class="cpp hljs">filter = <span class="hljs-string"><span class="hljs-string">"(string_field CP value AND int_field NOT LT 150) OR bool_field EQ true"</span></span>; json.erase(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::remove_if(json.begin(), json.end(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::not_fn(JsonFilter{filter})), json.end());</code> </pre> <br><p>  Para un uso conveniente del filtro, eleg√≠ dividir las condiciones en un √°rbol binario.  Los v√©rtices m√°s bajos deben contener operadores de comparaci√≥n, pero el resto deben ser operadores l√≥gicos.  As√≠ es como se ver√° el filtro anterior en un estado desmontado: </p><br><p><img src="https://habrastorage.org/webt/if/yc/zk/ifyczkjiznmiebrxvof3oxgnur4.jpeg" alt="√Årbol de filtro"></p><br><p>  El resultado fue una forma de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AST</a> , si puede llamarlo as√≠.  Ahora que la imagen de la pr√≥xima l√≥gica ha tomado forma, ha llegado el momento de lo m√°s interesante y terrible.  Esto debe estar escrito ... Sobre el Esp√≠ritu ... </p><br><h3 id="znakomstvo">  Conocido </h3><br><p>  La pregunta m√°s dif√≠cil surgi√≥: ¬øpor d√≥nde empezar?  A diferencia de Asio, leer encabezados de Spirit no dio pistas claras, en otras palabras, hay "alg√∫n tipo de magia".  Esto fue seguido por un estudio de ejemplos en la documentaci√≥n oficial del impulso y todo tipo de ejemplos en la red, que despu√©s de un tiempo trajo no solo sus frutos, sino una soluci√≥n lo m√°s cercana posible a mis necesidades: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">calculadora AST</a> </p><br><p>  Veamos la gram√°tica presentada en el ejemplo: </p><br><div class="spoiler">  <b class="spoiler_title">Calculadora de gram√°tica</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArithmeticGrammar1</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> qi::grammar&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::const_iterator, ASTNodePtr(), qi::space_type&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Iterator = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::const_iterator; ArithmeticGrammar1() : ArithmeticGrammar1::base_type(start) { start = (product &gt;&gt; <span class="hljs-string"><span class="hljs-string">'+'</span></span> &gt;&gt; start) [qi::_val = phx::new_&lt;OperatorNode&lt;<span class="hljs-string"><span class="hljs-string">'+'</span></span>&gt;&gt; (qi::_1, qi::_2)] | product[qi::_val = qi::_1]; product = (factor &gt;&gt; <span class="hljs-string"><span class="hljs-string">'*'</span></span> &gt;&gt; product) [qi::_val = phx::new_&lt;OperatorNode&lt;<span class="hljs-string"><span class="hljs-string">'*'</span></span>&gt;&gt; (qi::_1, qi::_2)] | factor[qi::_val = qi::_1]; factor = group[qi::_val = qi::_1] | qi::int_[qi::_val = phx::new_&lt;ConstantNode&gt;(qi::_1)]; group %= <span class="hljs-string"><span class="hljs-string">'('</span></span> &gt;&gt; start &gt;&gt; <span class="hljs-string"><span class="hljs-string">')'</span></span>; } qi::rule&lt;Iterator, ASTNodePtr(), qi::space_type&gt; start, group, product, factor; };</code> </pre> </div></div><br><p>  La gram√°tica se hereda de la base qi :: grammar.  <em>ASTNodePtr ()</em> no es una forma obvia, pero muy conveniente de pasar un objeto del resultado esperado a un objeto de gram√°tica. </p><br><div class="spoiler">  <b class="spoiler_title">Calculadora de nodo AST</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ASTNode</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~ASTNode() {} }; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ASTNodePtr = ASTNode*; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Operator&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OperatorNode</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ASTNode { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: OperatorNode(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ASTNodePtr &amp;left, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ASTNodePtr &amp;right) : left(left) , right(right) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Operator == <span class="hljs-string"><span class="hljs-string">'+'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left-&gt;evaluate() + right-&gt;evaluate(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Operator == <span class="hljs-string"><span class="hljs-string">'*'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left-&gt;evaluate() * right-&gt;evaluate(); } ~OperatorNode() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> left; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> right; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: ASTNodePtr left, right; <span class="hljs-comment"><span class="hljs-comment">//  }; class ConstantNode : public ASTNode { public: ConstantNode(double value) : value(value) {} double evaluate() { return value; } private: double value; };</span></span></code> </pre> </div></div><br><p>  Usando la biblioteca Boost.Phoenix, puede crear un nodo AST listo a partir de uno o varios no terminales justo durante el an√°lisis y escribir directamente en el resultado.  Echemos un vistazo m√°s de cerca en qu√© consiste la calculadora: </p><br><pre> <code class="cpp hljs">start = (product &gt;&gt; <span class="hljs-string"><span class="hljs-string">'+'</span></span> &gt;&gt; start)[qi::_val = phx::new_&lt;OperatorNode&lt;<span class="hljs-string"><span class="hljs-string">'+'</span></span>&gt;&gt; (qi::_1, qi::_2)] | product[qi::_val = qi::_1];</code> </pre> <br><p>  start: comienza a analizar la oraci√≥n.  Punto de partida  Se puede expresar a trav√©s de la suma del producto y el inicio, o simplemente a trav√©s del producto. </p><br><p>  Tenga en cuenta la acci√≥n entre corchetes para cada expresi√≥n.  Esta es la acci√≥n que debe realizarse si el an√°lisis es exitoso, si todo coincide.  <em>qi :: _ val</em> es realmente <em>boost :: spirit :: qi :: _ val</em> es un marcador de posici√≥n.  Con su ayuda, la respuesta se registrar√° en el resultado.  En el caso del inicio, este ser√° un objeto OperatorNode, cuyo primer argumento ser√° el resultado del an√°lisis del producto, y el segundo ser√° el resultado del inicio del an√°lisis. </p><br><p>  Nosotros miramos m√°s all√°.  Supongamos que encontramos la segunda opci√≥n, comenzar no es una suma, sino un producto.  ¬øC√≥mo se expresa? </p><br><pre> <code class="cpp hljs">product = (factor &gt;&gt; <span class="hljs-string"><span class="hljs-string">'*'</span></span> &gt;&gt; product) [qi::_val = phx::new_&lt;OperatorNode&lt;<span class="hljs-string"><span class="hljs-string">'*'</span></span>&gt;&gt; (qi::_1, qi::_2)] | factor[qi::_val = qi::_1];</code> </pre> <br><p>  La imagen anterior se repite con m√≠nimas diferencias.  Nuevamente encontramos alg√∫n tipo de expresi√≥n, nuevamente escribimos el objeto OperatorNode en el resultado, o simplemente alg√∫n tipo de factor.  Miremoslo. </p><br><pre> <code class="cpp hljs">factor = group[qi::_val = qi::_1] | qi::int_[qi::_val = phx::new_&lt;ConstantNode&gt;(qi::_1)];</code> </pre> <br><p>  A medida que avanzamos por el camino m√°s corto, asumimos que nos encontramos con nada menos que int.  Ahora, si describimos todos los pasos anteriores en pseudoc√≥digo, obtenemos en forma expandida algo como esto: </p><br><pre> <code class="cpp hljs">factor1 = ConstantNode(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   ,    factor2 = ConstantNode(3) product = OperatorNode&lt;'*'&gt;(factor1, factor2) start = product</span></span></code> </pre> <br><p>  Cada nodo, comenzando desde la parte superior (excepto los m√°s bajos, que son esencialmente enteros aqu√≠), se expresa a trav√©s de nodos posteriores.  Y la √∫nica llamada al m√©todo <em>Evaluation ()</em> en el elemento ra√≠z resuelve todo el problema, ¬°maravilloso! </p><br><p>  Entonces <em>qi :: space_type</em> llama tu atenci√≥n: este argumento es una lista de elementos ignorados al analizar.  Esto todav√≠a me jugar√° un truco :-). </p><br><p>  Lo que es notable aqu√≠ es la forma de priorizar la multiplicaci√≥n sobre la suma simplemente expresando el inicio no terminal (solo que contiene +) a trav√©s del producto (*).  En mi variante gramatical, ya que se decidi√≥ que Y prevalecer√≠a sobre O, simplemente sustituyo los operadores l√≥gicos requeridos en los lugares correctos.  Si es dif√≠cil cometer errores al escribir operadores matem√°ticos, los operadores l√≥gicos textuales son una historia completamente diferente.  Existe el deseo de resolver al menos parte de los posibles problemas, por ejemplo, el registro.  Para esto, Spirit tiene un tipo incorporado <em>qi :: no_case</em> </p><br><p>  Adem√°s, en lugar de n√∫meros, necesitar√© los nombres de los campos, por lo que agregamos el no terminal correspondiente en lugar del <em>qi :: int_</em> spirit incorporado: </p><br><pre> <code class="cpp hljs">field = qi::char_(<span class="hljs-string"><span class="hljs-string">"a-zA-Z_"</span></span>) &gt;&gt; *qi::char_(<span class="hljs-string"><span class="hljs-string">"a-zA-Z_0-9"</span></span>);</code> </pre> <br><p>  Y obtenemos aqu√≠ una expresi√≥n tan simple (hasta ahora no hay operaciones sem√°nticas): </p><br><pre> <code class="plaintext hljs">start = product &gt;&gt; qi::no_case["OR"] &gt;&gt; start | product; product = factor &gt;&gt; qi::no_case["AND"] &gt;&gt; product | factor; factor = group | field; group %= '(' &gt;&gt; start &gt;&gt; ')';</code> </pre> <br><p>  Ahora todo est√° listo para analizar la oraci√≥n m√°s simple <em>"campo Y campo2"</em> .  Comenzamos y ... nada funciona. </p><br><p>  El problema result√≥ estar en un lugar inesperado: <em>qi :: space_type</em> no solo ignora los espacios, sino que los elimina de la oraci√≥n antes del an√°lisis, y la expresi√≥n de filtro inicial entra en an√°lisis ya en la forma: </p><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"fieldAndfield2"</span></span> \\        ,    <span class="hljs-string"><span class="hljs-string">"(5 * 5) + 11 "</span></span> \\  <span class="hljs-string"><span class="hljs-string">"(5*5)+11"</span></span></code> </pre> <br><p>  Este es solo un campo √∫nico.  En consecuencia, necesitas un patr√≥n: </p><br><pre> <code class="cpp hljs">skipper = +qi::lit(<span class="hljs-string"><span class="hljs-string">' '</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    . ,    ,   ,  ,  C++ . start = product &gt;&gt; skipper &gt;&gt; qi::no_case["OR"] &gt;&gt; skipper &gt;&gt; start | product; ...</span></span></code> </pre> <br><p>  Despu√©s de analizar los campos, es posible aprender c√≥mo obtener valores de las expresiones y comprender c√≥mo se debe validar el campo contra el valor.  Todas las opciones de comparaci√≥n se pueden expresar a trav√©s de las siguientes operaciones: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Operator</span></span></span><span class="hljs-class"> {</span></span> EQ, <span class="hljs-comment"><span class="hljs-comment">//  LT, //  GT, //  CP //  (  ) }; unary = qi::no_case["NOT"]; // ,         </span></span></code> </pre> <br><p>  Y los valores en s√≠ mismos se expresan en tal no terminal: </p><br><pre> <code class="cpp hljs">value = qi::double_ | qi::int_ | qi::bool_ | <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> = qi::lit(<span class="hljs-string"><span class="hljs-string">"'"</span></span>) &gt;&gt; +qi::char_(<span class="hljs-string"><span class="hljs-string">"a-zA-Z0-9_. "</span></span>) &gt;&gt; qi::lit(<span class="hljs-string"><span class="hljs-string">"'"</span></span>);</code> </pre> <br><p>  Ahora a los problemas que trae tal m√©todo de obtener valor.  Spirit lo devolver√° en forma de <em>boost :: variant &lt;int, double, bool, std :: string&gt;</em> , y cuando llegue el momento de compararlo con algunos datos, se necesitar√°n ciertos trucos para obtener el valor del tipo deseado.  Aqu√≠ es a qu√© opci√≥n vine: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ValueType = boost::variant&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ValueGetter</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> boost::static_visitor&lt;Json&gt; { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type&gt; <span class="hljs-function"><span class="hljs-function">Json </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Type &amp;value)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } };</code> </pre> <br><p>  ¬øPor qu√© un getter devuelve un objeto Json?  Por lo tanto, al comparar valores durante el filtrado, evitar√© tener que averiguar qu√© tipo de datos est√° pasando la comparaci√≥n, dejando todo el trabajo a la biblioteca json. </p><br><p>  La linea de meta.  Descripci√≥n del mismo matcher.  Usaremos el mismo ejemplo con una calculadora.  Para comenzar, necesitamos una abstracci√≥n, que pasaremos a la gram√°tica, y el Esp√≠ritu la llenar√° amablemente con nosotros: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractMatcher</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: AbstractMatcher() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~AbstractMatcher() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Json &amp;object)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//       }; using MatcherPtr = std::shared_ptr&lt;AbstractMatcher&gt;;</span></span></code> </pre> <br><p>  Otros nodos l√≥gicos son los nodos de filtro principales: </p><br><div class="spoiler">  <b class="spoiler_title">Nodo l√≥gico</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logic</span></span></span><span class="hljs-class"> {</span></span> AND, OR }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;Logic Operator&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LogicNode</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractMatcher { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: LogicNode(MatcherPtr &amp;left, MatcherPtr &amp;right) : m_left(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(left)) , m_right(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(right)) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (Operator) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Logic::AND: m_evaluator = &amp;LogicNode::And; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Logic::OR: m_evaluator = &amp;LogicNode::Or; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Json &amp;object)</span></span></span><span class="hljs-function"> final </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::invoke(m_evaluator, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, object); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: MatcherPtr m_left; MatcherPtr m_right; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> EvaluateType = <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(LogicNode::*)(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Json &amp;); EvaluateType m_evaluator = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">And</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Json &amp;object)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_left-&gt;evaluate(object) &amp;&amp; m_right-&gt;evaluate(object); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Or</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Json &amp;object)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_left-&gt;evaluate(object) || m_right-&gt;evaluate(object); } };</code> </pre> </div></div><br><p>  Y finalmente, los nodos inferiores </p><br><div class="spoiler">  <b class="spoiler_title">Comparaci√≥n de valor</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectNode</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractMatcher { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ObjectNode(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> field, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ValueType &amp;value, boost::optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; &amp;unary, Operator oper) : m_field(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(field)) , m_json_value(boost::apply_visitor(ValueGetter(), value)) , m_reject(unary.has_value()) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (oper) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Operator::EQ: m_evaluator = &amp;ObjectNode::Equal; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Operator::LT: m_evaluator = &amp;ObjectNode::LesserThan; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Operator::GT: m_evaluator = &amp;ObjectNode::GreaterThan; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Operator::CP: m_evaluator = &amp;ObjectNode::Substr; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Json &amp;object)</span></span></span><span class="hljs-function"> final </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;value = object.at(m_field); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::invoke(m_evaluator, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, value); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_reject ? !result : result; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> EvaluateType = <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(ObjectNode::*)(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Json &amp;); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_field; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Json m_json_value; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> m_reject; EvaluateType m_evaluator = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Json &amp;json)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> json == m_json_value; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LesserThan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Json &amp;json)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> json &lt; m_json_value; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GreaterThan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Json &amp;json)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> json &gt; m_json_value; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Substr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Json &amp;json)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Str(json).find(Str(m_json_value)) != <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos; } };</code> </pre> </div></div><br><p>  Solo queda juntarlo todo: </p><br><div class="spoiler">  <b class="spoiler_title">Filtro Json</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonFilterGrammar</span></span></span><span class="hljs-class"> :</span></span> qi::grammar&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::const_iterator, MatcherPtr()&gt; { JsonFilterGrammar() : JsonFilterGrammar::base_type(expression) { skipper = +qi::lit(<span class="hljs-string"><span class="hljs-string">' '</span></span>); unary = qi::no_case[<span class="hljs-string"><span class="hljs-string">"NOT"</span></span>]; compare.add (<span class="hljs-string"><span class="hljs-string">"eq"</span></span>, Operator::EQ) (<span class="hljs-string"><span class="hljs-string">"lt"</span></span>, Operator::LT) (<span class="hljs-string"><span class="hljs-string">"gt"</span></span>, Operator::GT) (<span class="hljs-string"><span class="hljs-string">"cp"</span></span>, Operator::CP); expression = (product &gt;&gt; skipper &gt;&gt; qi::no_case[<span class="hljs-string"><span class="hljs-string">"OR"</span></span>] &gt;&gt; skipper &gt;&gt; expression) [qi::_val = make_shared_&lt;LogicNode&lt;Logic::OR&gt;&gt;()(qi::_1, qi::_2)] | product[qi::_val = qi::_1]; product = (term &gt;&gt; skipper &gt;&gt; qi::no_case[<span class="hljs-string"><span class="hljs-string">"AND"</span></span>] &gt;&gt; skipper &gt;&gt; product) [qi::_val = make_shared_&lt;LogicNode&lt;Logic::AND&gt;&gt;()(qi::_1, qi::_2)]| term[qi::_val = qi::_1]; term = group[qi::_val = qi::_1] | (field &gt;&gt; -(skipper &gt;&gt; unary)&gt;&gt; skipper &gt;&gt; qi::no_case[compare] &gt;&gt; skipper &gt;&gt; value) [qi::_val = make_shared_&lt;ObjectNode&gt;()(qi::_1, qi::_4, qi::_2, qi::_3)]; field = qi::char_(<span class="hljs-string"><span class="hljs-string">"a-zA-Z_"</span></span>) &gt;&gt; *qi::char_(<span class="hljs-string"><span class="hljs-string">"a-zA-Z_0-9"</span></span>); value = qi::double_ | qi::int_ | qi::bool_ | <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> = qi::lit(<span class="hljs-string"><span class="hljs-string">"'"</span></span>) &gt;&gt; +qi::char_(<span class="hljs-string"><span class="hljs-string">"a-zA-Z0-9_. \u20BD‚Ç¨$¬•-"</span></span>) &gt;&gt; qi::lit(<span class="hljs-string"><span class="hljs-string">"'"</span></span>); group %= <span class="hljs-string"><span class="hljs-string">'('</span></span> &gt;&gt; expression &gt;&gt; <span class="hljs-string"><span class="hljs-string">')'</span></span>; } qi::rule&lt;Iterator&gt; skipper; qi::rule&lt;Iterator, MatcherPtr()&gt; product, term, expression, group; qi::rule&lt;Iterator, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>()&gt; field, unary, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; qi::rule&lt;Iterator, ValueType()&gt; value; qi::symbols&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, Operator&gt; compare; <span class="hljs-comment"><span class="hljs-comment">//      enum };</span></span></code> </pre> </div></div><br><p>  Eso es todo  Ahora obtener el filtro terminado se ha convertido en una operaci√≥n bastante simple: </p><br><pre> <code class="cpp hljs">MatcherPtr matcher; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> filter = <span class="hljs-string"><span class="hljs-string">"int not LT 15"</span></span>; JsonFilterGrammar grammar; qi::parse(filter.begin(), filter.end(), grammar, matcher); <span class="hljs-comment"><span class="hljs-comment">//     matcher   .</span></span></code> </pre> <br><p>  Omitir√© el proceso de envolver la gram√°tica en un functor (no creo que sea interesante para nadie).  Consideraremos mejor la herramienta en acci√≥n usando el ejemplo m√°s simple: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> filter = <span class="hljs-string"><span class="hljs-string">"int not LT 15"</span></span>; Json json{ {{<span class="hljs-string"><span class="hljs-string">"int"</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>}}, {{<span class="hljs-string"><span class="hljs-string">"int"</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>}}, {{<span class="hljs-string"><span class="hljs-string">"int"</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>}}, {{<span class="hljs-string"><span class="hljs-string">"int"</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>}}, {{<span class="hljs-string"><span class="hljs-string">"int"</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>}} }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; json.dump() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; json.erase(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::remove_if(json.begin(), json.end(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::not_fn(JsonFilter{filter})), json.end()); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; json.dump() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br><p>  Aqu√≠ est√° la salida: </p><br><pre> <code class="bash hljs">[{<span class="hljs-string"><span class="hljs-string">"int"</span></span>:10},{<span class="hljs-string"><span class="hljs-string">"int"</span></span>:11},{<span class="hljs-string"><span class="hljs-string">"int"</span></span>:20},{<span class="hljs-string"><span class="hljs-string">"int"</span></span>:30},{<span class="hljs-string"><span class="hljs-string">"int"</span></span>:9}] [{<span class="hljs-string"><span class="hljs-string">"int"</span></span>:20},{<span class="hljs-string"><span class="hljs-string">"int"</span></span>:30}]</code> </pre> <br><p>  Espero, queridos lectores, que tambi√©n est√©n interesados ‚Äã‚Äãen conocer los conceptos b√°sicos del Esp√≠ritu, as√≠ como yo.  Entonces me quedo.  Hasta pronto. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/472004/">https://habr.com/ru/post/472004/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../471992/index.html">Implementando las caracter√≠sticas restantes de PEG</a></li>
<li><a href="../471994/index.html">Trabajar en PEG en Core Developer Sprint</a></li>
<li><a href="../471998/index.html">F # 10: listas</a></li>
<li><a href="../472000/index.html">"Es fundamental para la comunidad establecer est√°ndares": Marchin Moskala sobre Kotlin</a></li>
<li><a href="../472002/index.html">Empaquetado de Paquetes en Gradle</a></li>
<li><a href="../472006/index.html">Por qu√© es √∫til reinventar las ruedas</a></li>
<li><a href="../472012/index.html">Kanban en media hora</a></li>
<li><a href="../472014/index.html">OTUS Nuestros errores favoritos</a></li>
<li><a href="../472018/index.html">Sistema de control de biblioteca en Flask-Potion, Parte 0: preparar todo lo que necesita</a></li>
<li><a href="../472020/index.html">Top 10: los mejores informes de HolyJS 2019 Piter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>