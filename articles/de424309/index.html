<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∑üèΩ üíß ü•õ DevCore: Software-Teil des DevBoy-Projekts üßï üïû üõÅ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Freunde! 

 Nikolay ist wieder bei Ihnen. Im letzten Artikel " DevBoy - wie ich ein Open-Source-Ger√§teprojekt erstellt und ein Projekt auf Kicks...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>DevCore: Software-Teil des DevBoy-Projekts</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424309/">  <b>Hallo Freunde!</b> <br><br>  Nikolay ist wieder bei Ihnen. Im letzten Artikel " <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DevBoy - wie ich ein Open-Source-Ger√§teprojekt erstellt und ein Projekt auf Kickstarter gestartet habe</a></i> " lag der Schwerpunkt mehr auf Aussehen und Hardware. Heute werden wir dar√ºber sprechen, wie dies " <i>innen</i> " gemacht wird, und den Softwareteil analysieren. <br><br><img src="https://habrastorage.org/webt/6r/n4/u8/6rn4u8jvzpd-c9_oykzqia4l8fk.jpeg"><br><br>  Wen k√ºmmert es - ich bitte um eine Katze. <br><a name="habracut"></a><br>  Wie bereits erw√§hnt, basiert das Projekt auf dem Mikrocontroller <b>STM32F415RG</b> von STMicroelectronics auf dem ARM Cortex-M4-Kern.  Es gibt verschiedene IDEs f√ºr die Entwicklung von Mikrocontrollern f√ºr diese Mikrocontroller. F√ºr ein Open Source-Projekt ben√∂tigen Sie jedoch mindestens eine kostenlose IDE und vorzugsweise Open Source.  Dar√ºber hinaus muss die IDE in <b>STM32CubeMX</b> weiterhin unterst√ºtzt <b>werden</b> .  Als ich anfing, an diesem Projekt zu arbeiten, gab es nur eine IDE, die all diese Anforderungen erf√ºllte - <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">System Workbench f√ºr STM32</a></b> . <br><br><img src="https://habrastorage.org/webt/v7/pz/vi/v7pzviufspf40flvruysuro_ex0.png">  <i>Im Moment gibt es Atollic TrueStudio, das kostenlos wurde, nachdem STMicroelectronics sie gekauft hatte.</i> <i><br></i> <br>  Das n√§chste verwendete Programm ist <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">STM32CubeMX</a></b> .  Dieses Programm ist ein Dienstprogramm zum Konfigurieren der Mikrocontroller-Peripherieger√§te mithilfe einer grafischen Oberfl√§che. <br><img src="https://habrastorage.org/webt/i4/ym/3u/i4ym3unkrgskza2fmumqmmfzs1o.png"><br>  Das Ergebnis ist ein Code, der Hardware <b>A</b> bstraction <b>L</b> ayer (HAL) enth√§lt.  Viele Programmierer m√∂gen diese " <i>Kreation</i> " nicht wirklich, sie ist nicht ohne Fehler, aber sie vereinfacht die Entwicklung erheblich und verbessert die Portabilit√§t von Programmen zwischen verschiedenen Mikrocontrollern von STMicroelectronics. <br><br>  Dar√ºber hinaus k√∂nnen Sie w√§hrend der Konfiguration die Verwendung von Open Source-Software von Drittanbietern wie <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FreeRTOS</a></b> , <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FatFS</a></b> und einigen anderen <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">festlegen</a></b> . <br><br>  <b>Wir haben</b> die Beschreibung der verwendeten Software <b>fertiggestellt</b> . <b>Kommen</b> wir nun zum interessantesten Teil - <b>DevCore</b> .  Der Name kommt von der " <i>Core Development</i> ", lass uns in Ordnung gehen. <br><br>  Zun√§chst ist es <b>C ++ RTOS Wrapper</b> ( <i>in diesem Fall FreeRTOS</i> ).  Vrapper wird aus zwei Gr√ºnden ben√∂tigt: <br><br><ul><li>  Es ist viel sch√∂ner, ein Objekt zu erstellen und dann beispielsweise mutex.Take () aufzurufen, als ein Handle zu erstellen, die Funktion create aufzurufen und dieses Handle dann an alle Mutex-Funktionen zu √ºbergeben </li><li>  Wenn RTOS ersetzt werden muss, reicht es aus, den Wrapper zu ersetzen und nicht alle Aufrufe von RTOS-Funktionen aus dem Code </li></ul><br>  Es macht keinen Sinn, den Wrapper-Code hierher zu bringen, wen interessiert das? <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wir schauen uns GitHub</a> an und gehen weiter. <br><br>  Der n√§chste Teil ist das <b>Application Framework</b> .  Dies ist die Basisklasse f√ºr alle Aufgaben.  Da dies nur zwei relativ kleine Dateien sind, ist es sinnvoll, sie vollst√§ndig aufzulisten: <br><br><div class="spoiler">  <b class="spoiler_title">Header</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//****************************************************************************** // @file AppTask.h // @author Nicolai Shlapunov // // @details DevCore: Application Task Base Class, header // // @section LICENSE // // Software License Agreement (Modified BSD License) // // Copyright (c) 2016, Devtronic &amp; Nicolai Shlapunov // All rights reserved. // // Redistribution and use in source and binary forms, with or without // modification, are permitted provided that the following conditions are met: // // 1. Redistributions of source code must retain the above copyright // notice, this list of conditions and the following disclaimer. // 2. Redistributions in binary form must reproduce the above copyright // notice, this list of conditions and the following disclaimer in the // documentation and/or other materials provided with the distribution. // 3. Neither the name of the Devtronic nor the names of its contributors // may be used to endorse or promote products derived from this software // without specific prior written permission. // 4. Redistribution and use of this software other than as permitted under // this license is void and will automatically terminate your rights under // this license. // // THIS SOFTWARE IS PROVIDED BY DEVTRONIC ''AS IS'' AND ANY EXPRESS OR IMPLIED // WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF // MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. // IN NO EVENT SHALL DEVTRONIC BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED // TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. // // @section SUPPORT // // Devtronic invests time and resources providing this open source code, // please support Devtronic and open-source hardware/software by // donations and/or purchasing products from Devtronic. // //****************************************************************************** #ifndef AppTask_h #define AppTask_h // ***************************************************************************** // *** Includes ************************************************************ // ***************************************************************************** #include "DevCfg.h" // ***************************************************************************** // * AppTask class. This class is wrapper for call C++ function from class. **** // ***************************************************************************** class AppTask { public: // ************************************************************************* // *** Init Task ******************************************************* // ************************************************************************* virtual void InitTask(void) {CreateTask();} protected: // ************************************************************************* // *** Constructor ***************************************************** // ************************************************************************* AppTask(uint16_t stk_size, uint8_t task_prio, const char name[], uint16_t queue_len = 0U, uint16_t queue_msg_size = 0U, void* task_msg_p = nullptr, uint32_t task_interval_ms = 0U) : ctrl_queue((queue_len + 2U), sizeof(CtrlQueueMsg)), task_queue(queue_len, queue_msg_size), task_msg_ptr(task_msg_p), timer(task_interval_ms, RtosTimer::REPEATING, TimerCallback, (void*)this), stack_size(stk_size), task_priority(task_prio), task_name(name) {}; // ************************************************************************* // *** Virtual destructor - prevent warning **************************** // ************************************************************************* virtual ~AppTask() {}; // ************************************************************************* // *** Create task function ******************************************** // ************************************************************************* // * This function creates new task in FreeRTOS, provide pointer to function // * and pointer to class as parameter. When TaskFunctionCallback() called // * from FreeRTOS, it use pointer to class from parameter to call virtual // * functions. void CreateTask(); // ************************************************************************* // *** Setup function ************************************************** // ************************************************************************* // * * virtual function - some tasks may not have Setup() actions virtual Result Setup() {return Result::RESULT_OK;} // ************************************************************************* // *** IntervalTimerExpired function *********************************** // ************************************************************************* // * Empty virtual function - some tasks may not have TimerExpired() actions virtual Result TimerExpired() {return Result::RESULT_OK;} // ************************************************************************* // *** ProcessMessage function ***************************************** // ************************************************************************* // * Empty virtual function - some tasks may not have ProcessMessage() actions virtual Result ProcessMessage() {return Result::RESULT_OK;} // ************************************************************************* // *** Loop function *************************************************** // ************************************************************************* // * Empty virtual function - some tasks may not have Loop() actions virtual Result Loop() {return Result::RESULT_OK;} // ************************************************************************* // *** SendTaskMessage function **************************************** // ************************************************************************* Result SendTaskMessage(const void* task_msg, bool is_priority = false); private: // Task control queue message types enum CtrlQueueMsgType { CTRL_TIMER_MSG, CTRL_TASK_QUEUE_MSG }; // Task control queue message struct struct CtrlQueueMsg { CtrlQueueMsgType type; }; // Task control queue RtosQueue ctrl_queue; // Task queue RtosQueue task_queue; // Pointer to receive message buffer void* task_msg_ptr; // Timer object RtosTimer timer; // Task stack size uint16_t stack_size; // Task priority uint8_t task_priority; // Pointer to the task name const char* task_name; // ************************************************************************* // *** IntLoop function ************************************************ // ************************************************************************* Result IntLoop(); // ************************************************************************* // *** TaskFunctionCallback ******************************************** // ************************************************************************* static void TaskFunctionCallback(void* ptr); // ************************************************************************* // *** IntervalTimerCallback function ********************************** // ************************************************************************* static void TimerCallback(void* ptr); // ************************************************************************* // *** SendControlMessage function ************************************* // ************************************************************************* Result SendControlMessage(const CtrlQueueMsg&amp; ctrl_msg, bool is_priority = false); // ************************************************************************* // *** Change counter ************************************************** // ************************************************************************* static void ChangeCnt(bool is_up); // ************************************************************************* // *** Private constructor and assign operator - prevent copying ******* // ************************************************************************* AppTask(); AppTask(const AppTask&amp;); AppTask&amp; operator=(const AppTask&amp;); }; #endif</span></span></code> </pre> </div></div><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//****************************************************************************** // @file AppTask.cpp // @author Nicolai Shlapunov // // @details DevCore: Application Task Base Class, implementation // // @copyright Copyright (c) 2016, Devtronic &amp; Nicolai Shlapunov // All rights reserved. // // @section SUPPORT // // Devtronic invests time and resources providing this open source code, // please support Devtronic and open-source hardware/software by // donations and/or purchasing products from Devtronic. // //****************************************************************************** // ***************************************************************************** // *** Includes ************************************************************ // ***************************************************************************** #include "AppTask.h" #include "RtosMutex.h" // ***************************************************************************** // *** Static variables **************************************************** // ***************************************************************************** static RtosMutex startup_mutex; static uint32_t startup_cnt = 0U; // ***************************************************************************** // *** Create task function ************************************************ // ***************************************************************************** void AppTask::CreateTask() { Result result = Result::RESULT_OK; // If interval timer period isn't zero or task queue present if((timer.GetTimerPeriod() != 0U) || (task_queue.GetQueueLen() != 0U)) { // Set Control Queue name ctrl_queue.SetName(task_name, "Ctrl"); // Create control queue result = ctrl_queue.Create(); } // If task queue present if(task_queue.GetQueueLen() != 0U) { // Set Task Queue name task_queue.SetName(task_name, "Task"); // Create task queue result |= task_queue.Create(); } // If interval timer period isn't zero if(timer.GetTimerPeriod() != 0U) { // Create timer result |= timer.Create(); } // Create task: function - TaskFunctionCallback(), parameter - pointer to "this" result |= Rtos::TaskCreate(TaskFunctionCallback, task_name, stack_size, this, task_priority); // Check result if(result.IsBad()) { // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> implement error handling Break(); } } // ***************************************************************************** // *** SendTaskMessage function ******************************************** // ***************************************************************************** Result AppTask::SendTaskMessage(const void* task_msg, bool is_priority) { Result result = Result::RESULT_OK; // Send task message to front or back of task queue if(is_priority == true) { result = task_queue.SendToFront(task_msg); } else { result = task_queue.SendToBack(task_msg); } // If successful - send message to the control queue if(result.IsGood()) { CtrlQueueMsg ctrl_msg; ctrl_msg.type = CTRL_TASK_QUEUE_MSG; result = SendControlMessage(ctrl_msg, is_priority); } return result; } // ***************************************************************************** // *** IntLoop function **************************************************** // ***************************************************************************** Result AppTask::IntLoop() { Result result = Result::RESULT_OK; while(result.IsGood()) { // Buffer for control message CtrlQueueMsg ctrl_msg; // Read on the control queue result = ctrl_queue.Receive(&amp;ctrl_msg, timer.GetTimerPeriod() * 2U); // If successful if(result.IsGood()) { // Check message type switch(ctrl_msg.type) { case CTRL_TIMER_MSG: result = TimerExpired(); break; case CTRL_TASK_QUEUE_MSG: { // Non blocking read from the task queue result = task_queue.Receive(task_msg_ptr, 0U); // If successful if(result.IsGood()) { // Process it! result = ProcessMessage(); } break; } default: result = Result::ERR_INVALID_ITEM; break; } } } return result; } // ***************************************************************************** // *** TaskFunctionCallback ************************************************ // ***************************************************************************** void AppTask::TaskFunctionCallback(void* ptr) { Result result = Result::ERR_NULL_PTR; if(ptr != nullptr) { // Set good result result = Result::RESULT_OK; // Get reference to the task object AppTask&amp; app_task = *(static_cast&lt;AppTask*&gt;(ptr)); // Increment counter before call Setup() ChangeCnt(true); // Call virtual Setup() function from AppTask class app_task.Setup(); // Decrement counter after call Setup() ChangeCnt(false); // Pause for give other tasks run Setup() RtosTick::DelayTicks(1U); // Pause while other tasks run Setup() before executing any Loop() while(startup_cnt) RtosTick::DelayTicks(1U); // If no timer or queue - just call Loop() function if((app_task.timer.GetTimerPeriod() == 0U) &amp;&amp; (app_task.task_queue.GetQueueLen() == 0U)) { // Call virtual Loop() function from AppTask class while(app_task.Loop() == Result::RESULT_OK); } else { // Start task timer if needed if(app_task.timer.GetTimerPeriod() != 0U) { result = app_task.timer.Start(); } // Check result if(result.IsGood()) { // Call internal AppTask function result = app_task.IntLoop(); } // Stop task timer if needed if(app_task.timer.GetTimerPeriod() != 0U) { result |= app_task.timer.Stop(); } } } // Check result if(result.IsBad()) { // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> implement error handling Break(); } // Delete task after exit Rtos::TaskDelete(); } // ***************************************************************************** // *** TimerCallback function ********************************************** // ***************************************************************************** void AppTask::TimerCallback(void* ptr) { Result result = Result::ERR_NULL_PTR; if(ptr != nullptr) { // Get reference to the task object AppTask&amp; task = *((AppTask*)ptr); // Create control timer message CtrlQueueMsg timer_msg; timer_msg.type = CTRL_TIMER_MSG; // Send message to the control queue result = task.SendControlMessage(timer_msg); } // Check result if(result.IsBad()) { // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> implement error handling Break(); } } // ***************************************************************************** // *** SendControlMessage function ***************************************** // ***************************************************************************** Result AppTask::SendControlMessage(const CtrlQueueMsg&amp; ctrl_msg, bool is_priority) { Result result; if(is_priority == true) { result = ctrl_queue.SendToFront(&amp;ctrl_msg); } else { result = ctrl_queue.SendToBack(&amp;ctrl_msg); } return result; } // ***************************************************************************** // *** Change counter ****************************************************** // ***************************************************************************** void AppTask::ChangeCnt(bool is_up) { // Take semaphore before change counter startup_mutex.Lock(); // Check direction if(is_up == true) { // Increment counter startup_cnt++; } else { // Decrement counter startup_cnt--; } // Give semaphore after changes startup_mutex.Release(); }</span></span></code> </pre></div></div><br>  Vererbte Klassen k√∂nnen 4 virtuelle Funktionen √ºberschreiben: <br><br><ul><li>  <b>Setup ()</b> ist eine Funktion, die vor dem Starten einer Aufgabe aufgerufen wird.  Die Code-Vervollst√§ndigung ist in all diesen Funktionen aller Aufgaben vor der Ausf√ºhrung der Hauptzyklen garantiert. </li><li>  <b>Loop ()</b> - der Hauptaufgabenzyklus, in dem die Aufgabe selbst organisiert, was sie will.  Kann nicht in Verbindung mit den folgenden beiden Funktionen verwendet werden. </li><li>  <b>TimerExpired ()</b> - eine Funktion, die regelm√§√üig mit einem bestimmten Intervall aufgerufen wird.  Praktisch, um beispielsweise die Abfrage eines Sensors zu implementieren. </li><li>  <b>ProcessMessage ()</b> - Funktion zum Verarbeiten von Nachrichten aus anderen Aufgaben. </li></ul><br>  Die ersten beiden Funktionen implementieren " <i>Arduino-Style</i> " f√ºr Aufgaben. <br><br>  Die n√§chsten beiden implementieren das " <i>Ereignis</i> " -System, das die Interaktion von Aufgaben vereinfacht.  Bei diesem Ansatz implementiert die Aufgabe eine externe Schnittstelle in Form von Funktionen, die Sendedaten √ºber eine interne Mailbox an die Aufgabe senden.  Bei diesem Ansatz muss sich der Benutzer, der diese Schnittstelle verwendet, keine Gedanken dar√ºber machen, in welchem ‚Äã‚ÄãKontext Aktionen ausgef√ºhrt werden.  Dies ist zwar nur f√ºr Setter oder Teams m√∂glich.  F√ºr Getter ist es am besten, Mutexe und Datenkopien zu verwenden, um die Mutex-Erfassung f√ºr lange Zeit zu verhindern. <br><br>  Dieser Ansatz wurde entdeckt, als ich Software f√ºr medizinische Ger√§te entwickelte.  Der Mikrocontroller verf√ºgt √ºber einen <i>Watchdog,</i> und bei vielen Aufgaben m√ºssen Sie alle verfolgen.  Zu diesem Zweck gab es eine separate Aufgabe, die den Watchdog bediente und Nachrichten von anderen Aufgaben empfing, die von der Funktion TimerExpired () gesendet wurden.  Wenn w√§hrend des Timer-Zeitraums der Aufgabe * n keine Nachrichten vorhanden waren, die Aufgabe gestorben ist, <s>l√∂schen</s> wir <s>das Licht und</s> ergreifen Ma√ünahmen, um alle Dr√ºsen auszuschalten, die den Patienten betreffen. <br><br>  Alle Aufgaben sind Singleton-Aufgaben. Sie k√∂nnen sie nicht direkt erstellen, aber Sie k√∂nnen einen Link zur Aufgabe erhalten.  Zu diesem <b>Zweck</b> implementiert jede Aufgabe die statische <b>GetInstance ()</b> -Methode: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ***************************************************************************** // *** Get Instance ******************************************************** // ***************************************************************************** Application&amp; Application::GetInstance(void) { static Application application; return application; }</span></span></code> </pre> <br>  Ebenfalls enthalten sind Aufgaben f√ºr die <b>Audioausgabe</b> , f√ºr <b>Eingabemodule</b> und f√ºr die <b>Bildschirmwartung.</b> <br><br>  Die Aufgabe <b>der Tonausgabe ist</b> recht einfach: Sie empf√§ngt eine Reihe von Frequenzen und Dauern und √§ndert einfach regelm√§√üig die Timer-Einstellungen, um Rechteckimpulse einer bestimmten Frequenz zu erzeugen. <br><br><div class="spoiler">  <b class="spoiler_title">Header</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//****************************************************************************** // @file SoundDrv.h // @author Nicolai Shlapunov // // @details DevCore: Sound Driver Class, header // // @section LICENSE // // Software License Agreement (Modified BSD License) // // Copyright (c) 2016, Devtronic &amp; Nicolai Shlapunov // All rights reserved. // // Redistribution and use in source and binary forms, with or without // modification, are permitted provided that the following conditions are met: // // 1. Redistributions of source code must retain the above copyright // notice, this list of conditions and the following disclaimer. // 2. Redistributions in binary form must reproduce the above copyright // notice, this list of conditions and the following disclaimer in the // documentation and/or other materials provided with the distribution. // 3. Neither the name of the Devtronic nor the names of its contributors // may be used to endorse or promote products derived from this software // without specific prior written permission. // 4. Redistribution and use of this software other than as permitted under // this license is void and will automatically terminate your rights under // this license. // // THIS SOFTWARE IS PROVIDED BY DEVTRONIC ''AS IS'' AND ANY EXPRESS OR IMPLIED // WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF // MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. // IN NO EVENT SHALL DEVTRONIC BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED // TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. // // @section SUPPORT // // Devtronic invests time and resources providing this open source code, // please support Devtronic and open-source hardware/software by // donations and/or purchasing products from Devtronic. // //****************************************************************************** #ifndef SoundDrv_h #define SoundDrv_h // ***************************************************************************** // *** Includes ************************************************************ // ***************************************************************************** #include "DevCfg.h" #include "AppTask.h" #include "RtosMutex.h" #include "RtosSemaphore.h" // ***************************************************************************** // *** Sound Driver Class. This class implement work with sound. *********** // ***************************************************************************** class SoundDrv : public AppTask { public: // ************************************************************************* // *** Get Instance **************************************************** // ************************************************************************* // * This class is singleton. For use this class you must call GetInstance() // * to receive reference to Sound Driver class static SoundDrv&amp; GetInstance(void); // ************************************************************************* // *** Init Sound Driver Task ****************************************** // ************************************************************************* virtual void InitTask(TIM_HandleTypeDef *htm); // ************************************************************************* // *** Sound Driver Setup ********************************************** // ************************************************************************* virtual Result Setup(); // ************************************************************************* // *** Sound Driver Loop *********************************************** // ************************************************************************* virtual Result Loop(); // ************************************************************************* // *** Beep function *************************************************** // ************************************************************************* void Beep(uint16_t freq, uint16_t del, bool pause_after_play = false); // ************************************************************************* // *** Play sound function ********************************************* // ************************************************************************* void PlaySound(const uint16_t* melody, uint16_t size, uint16_t temp_ms = 100U, bool rep = false); // ************************************************************************* // *** Stop sound function ********************************************* // ************************************************************************* void StopSound(void); // ************************************************************************* // *** Mute sound function ********************************************* // ************************************************************************* void Mute(bool mute_flag); // ************************************************************************* // *** Is sound played function **************************************** // ************************************************************************* bool IsSoundPlayed(void); private: // Timer handle TIM_HandleTypeDef* htim = SOUND_HTIM; // Timer channel uint32_t channel = SOUND_CHANNEL; // Ticks variable uint32_t last_wake_ticks = 0U; // Pointer to table contains melody const uint16_t* sound_table = nullptr; // Size of table uint16_t sound_table_size = 0U; // Current position uint16_t sound_table_position = 0U; // Current frequency delay uint16_t current_delay = 0U; // Time for one frequency in ms uint32_t delay_ms = 100U; // Repeat flag bool repeat = false; // Mute flag bool mute = false; // Mutex to synchronize when playing melody frames RtosMutex melody_mutex; // Semaphore for start play sound RtosSemaphore sound_update; // ************************************************************************* // *** Process Button Input function *********************************** // ************************************************************************* void Tone(uint16_t freq); // ************************************************************************* // ** Private constructor. Only GetInstance() allow to access this class. ** // ************************************************************************* SoundDrv() : AppTask(SOUND_DRV_TASK_STACK_SIZE, SOUND_DRV_TASK_PRIORITY, "SoundDrv") {}; }; #endif</span></span></code> </pre> <br></div></div><br>  Die Wartung von <b>Wassermodulen ist</b> ebenfalls recht einfach.  Von den interessanten Punkten wird das Modul automatisch erkannt: Zuerst messen wir mit dem ADC die Spannung, wenn sie im Bereich von 25% bis 75% der Versorgungsspannung liegt, wird ein analoger Joystick eingesetzt, andernfalls Tasten oder ein Encoder.  Wenn es sich nicht um einen Joystick handelt, √ºberpr√ºfen Sie die vierte Zeile des E / A-Moduls: Wenn es sich auf einem hohen Pegel befindet, sind dies Tasten ( <i>alle Tasten werden zur Stromversorgung hochgezogen und, wenn die Tasten gedr√ºckt werden, zum Boden geschlossen</i> ). Wenn es niedrig ist, handelt es sich um einen Encoder (eine <i>kleine Taste wird ‚Äûhochgezogen‚Äú) auf den Boden und wenn gedr√ºckt, schlie√üt sich die Stromversorgung</i> ). <br><br><div class="spoiler">  <b class="spoiler_title">Header</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//****************************************************************************** // @file InputDrv.h // @author Nicolai Shlapunov // // @details DevCore: Input Driver Class, header // // @section LICENSE // // Software License Agreement (Modified BSD License) // // Copyright (c) 2016, Devtronic &amp; Nicolai Shlapunov // All rights reserved. // // Redistribution and use in source and binary forms, with or without // modification, are permitted provided that the following conditions are met: // // 1. Redistributions of source code must retain the above copyright // notice, this list of conditions and the following disclaimer. // 2. Redistributions in binary form must reproduce the above copyright // notice, this list of conditions and the following disclaimer in the // documentation and/or other materials provided with the distribution. // 3. Neither the name of the Devtronic nor the names of its contributors // may be used to endorse or promote products derived from this software // without specific prior written permission. // 4. Redistribution and use of this software other than as permitted under // this license is void and will automatically terminate your rights under // this license. // // THIS SOFTWARE IS PROVIDED BY DEVTRONIC ''AS IS'' AND ANY EXPRESS OR IMPLIED // WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF // MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. // IN NO EVENT SHALL DEVTRONIC BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED // TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. // // @section SUPPORT // // Devtronic invests time and resources providing this open source code, // please support Devtronic and open-source hardware/software by // donations and/or purchasing products from Devtronic. // //****************************************************************************** #ifndef InputDrv_h #define InputDrv_h // ***************************************************************************** // *** Includes ************************************************************ // ***************************************************************************** #include "DevCfg.h" #include "AppTask.h" // ***************************************************************************** // * Input Driver Class. This class implement work with user input elements like // * buttons and encoders. class InputDrv : public AppTask { public: // ************************************************************************* // *** Enum with all buttons ******************************************* // ************************************************************************* typedef enum { EXT_LEFT, // Left ext port EXT_RIGHT, // Right ext port EXT_MAX // Ext port count } PortType; // ************************************************************************* // *** Enum with all devices types ************************************* // ************************************************************************* typedef enum { EXT_DEV_NONE, // No device EXT_DEV_BTN, // Buttons(cross) EXT_DEV_ENC, // Encoder EXT_DEV_JOY, // Joystick EXT_DEV_MAX // Device types count } ExtDeviceType; // ************************************************************************* // *** Enum with all buttons ******************************************* // ************************************************************************* typedef enum { BTN_UP, // Up button BTN_LEFT, // Left button BTN_DOWN, // Down button BTN_RIGHT, // Right button BTN_MAX // Buttons count } ButtonType; // ************************************************************************* // *** Enum with all encoder buttons *********************************** // ************************************************************************* typedef enum { ENC_BTN_ENT, // Press on the knob ENC_BTN_BACK, // Small button ENC_BTN_MAX // Buttons count } EncButtonType; // ************************************************************************* // *** Get Instance **************************************************** // ************************************************************************* // * This class is singleton. For use this class you must call GetInstance() // * to receive reference to Input Driver class static InputDrv&amp; GetInstance(void); // ************************************************************************* // *** Init Input Driver Task ****************************************** // ************************************************************************* // * This function initialize Input Driver class. If htim provided, this // * timer will be used instead FreeRTOS task. virtual void InitTask(TIM_HandleTypeDef* htm, ADC_HandleTypeDef* had); // ************************************************************************* // *** Input Driver Setup ********************************************** // ************************************************************************* virtual Result Setup(); // ************************************************************************* // *** Input Driver Loop *********************************************** // ************************************************************************* // * If FreeRTOS task used, this function just call ProcessInput() with 1 ms // * period. If FreeRTOS tick is 1 ms - this task must have highest priority virtual Result Loop(); // ************************************************************************* // *** Process Input function ****************************************** // ************************************************************************* // * Main class function - must call periodically for process user input. // * If timer used, this function must be called from interrupt handler. void ProcessInput(void); // ************************************************************************* // *** Process Encoders Input function ********************************* // ************************************************************************* void ProcessEncodersInput(void); // ************************************************************************* // *** Get device type ************************************************* // ************************************************************************* ExtDeviceType GetDeviceType(PortType port); // ************************************************************************* // *** Get button state ************************************************ // ************************************************************************* // Return button state: true - pressed, false - unpressed bool GetButtonState(PortType port, ButtonType button); // ************************************************************************* // *** Get button state ************************************************ // ************************************************************************* // Return button state change flag: true - changed, false - not changed bool GetButtonState(PortType port, ButtonType button, bool&amp; btn_state); // ************************************************************************* // *** Get encoder counts from last call ******************************* // ************************************************************************* // * Return state of encoder. Class counts encoder clicks and stored inside. // * This function substract from current encoder counter last_enc_val and // * return it to user. Before return last_enc_val will be assigned to // * current encoder counter. int32_t GetEncoderState(PortType port, int32_t&amp; last_enc_val); // ************************************************************************* // *** Get button state ************************************************ // ************************************************************************* // Return button state: true - pressed, false - unpressed bool GetEncoderButtonState(PortType port, EncButtonType button); // ************************************************************************* // *** Get encoder button state **************************************** // ************************************************************************* // Return button state: true - pressed, false - unpressed bool GetEncoderButtonState(PortType port, EncButtonType button, bool&amp; btn_state); // ************************************************************************* // *** Get joystick counts from last call ****************************** // ************************************************************************* void GetJoystickState(PortType port, int32_t&amp; x, int32_t&amp; y); // ************************************************************************* // *** SetJoystickCalibrationConsts ************************************ // ************************************************************************* // * Set calibration constants. Must be call for calibration joystick. void SetJoystickCalibrationConsts(PortType port, int32_t x_mid, int32_t x_kmin, int32_t x_kmax, int32_t y_mid, int32_t y_kmin, int32_t y_kmax); // ************************************************************************* // *** Get joystick button state *************************************** // ************************************************************************* // Return button state: true - pressed, false - unpressed bool GetJoystickButtonState(PortType port); // ************************************************************************* // *** Get joystick button state *************************************** // ************************************************************************* // Return button state: true - pressed, false - unpressed bool GetJoystickButtonState(PortType port, bool&amp; btn_state); private: // How many cycles button must change state before state will be changed in // result returned by GetButtonState() function. For reduce debouncing const static uint32_t BUTTON_READ_DELAY = 4U; // Coefficient for calibration const static int32_t COEF = 100; // ADC max value - 12 bit const static int32_t ADC_MAX_VAL = 0xFFF; // Joystich threshold const static int32_t JOY_THRESHOLD = 1000; // Ticks variable uint32_t last_wake_ticks = 0U; // ************************************************************************* // *** Structure to describe button ************************************ // ************************************************************************* typedef struct { bool btn_state; // Button state returned by GetButtonState() function bool btn_state_tmp; // Temporary button state for reduce debouncing uint8_t btn_state_cnt; // Counter for reduce debouncing GPIO_TypeDef* button_port;// Button port uint16_t button_pin; // Button pin GPIO_PinState pin_state; // High/low on input treated as pressed } ButtonProfile; // ************************************************************************* // *** Structure to describe encoder *********************************** // ************************************************************************* typedef struct { // Encoder rotation int32_t enc_cnt; // Encoder counter uint8_t enc_state; // Current state of encder clock &amp; data pins GPIO_TypeDef* enc_clk_port; // Encoder clock port uint16_t enc_clk_pin; // Encoder clock pin GPIO_TypeDef* enc_data_port;// Encoder data port uint16_t enc_data_pin; // Encoder data pin } EncoderProfile; // ************************************************************************* // *** Structure to describe joysticks ********************************* // ************************************************************************* typedef struct { int32_t x_ch_val; // Joystick X axis value uint32_t x_channel; // Joystick X axis ADC channel GPIO_TypeDef* x_port; // Joystick X axis port uint16_t x_pin; // Joystick X axis pin int32_t bx; // Joystick X offset int32_t kxmin; // Joystick X coefficient int32_t kxmax; // Joystick X coefficient bool x_inverted; // Joystick X inverted flag int32_t y_ch_val; // Joystick Y axis value uint32_t y_channel; // Joystick Y axis ADC channel GPIO_TypeDef* y_port; // Joystick Y axis port uint16_t y_pin; // Joystick Y axis pin int32_t by; // Joystick Y offset int32_t kymin; // Joystick Y coefficient int32_t kymax; // Joystick Y coefficient bool y_inverted; // Joystick Y inverted flag } JoystickProfile; // ************************************************************************* // *** Structure to describe encoders ********************************** // ************************************************************************* typedef struct { EncoderProfile enc; ButtonProfile btn[ENC_BTN_MAX]; } DevEncoders; // ************************************************************************* // *** Structure to describe encoders ********************************** // ************************************************************************* typedef struct { JoystickProfile joy; ButtonProfile btn; } DevJoysticks; // ************************************************************************* // *** Structure to describe buttons *********************************** // ************************************************************************* typedef struct { ButtonProfile button[BTN_MAX]; } DevButtons; // *** Array describes types of connected devices *********************** ExtDeviceType devices[EXT_MAX]; // *** Structures array for describe buttons inputs ********************* DevButtons buttons[EXT_MAX] = { // Left device {{{false, false, 0, EXT_L1_GPIO_Port, EXT_L1_Pin, GPIO_PIN_RESET}, {false, false, 0, EXT_L2_GPIO_Port, EXT_L2_Pin, GPIO_PIN_RESET}, {false, false, 0, EXT_L3_GPIO_Port, EXT_L3_Pin, GPIO_PIN_RESET}, {false, false, 0, EXT_L4_GPIO_Port, EXT_L4_Pin, GPIO_PIN_RESET}}}, // Right device {{{false, false, 0, EXT_R1_GPIO_Port, EXT_R1_Pin, GPIO_PIN_RESET}, {false, false, 0, EXT_R2_GPIO_Port, EXT_R2_Pin, GPIO_PIN_RESET}, {false, false, 0, EXT_R3_GPIO_Port, EXT_R3_Pin, GPIO_PIN_RESET}, {false, false, 0, EXT_R4_GPIO_Port, EXT_R4_Pin, GPIO_PIN_RESET}}} }; // *** Structures array for describe encoders inputs ******************** DevEncoders encoders[EXT_MAX] = { // Left device {{0, 0, EXT_L1_GPIO_Port, EXT_L1_Pin, EXT_L2_GPIO_Port, EXT_L2_Pin}, // Encoder {{false, false, 0, EXT_L3_GPIO_Port, EXT_L3_Pin, GPIO_PIN_RESET}, // Button Enter {false, false, 0, EXT_L4_GPIO_Port, EXT_L4_Pin, GPIO_PIN_SET}}}, // Button Back // Right device {{0, 0, EXT_R1_GPIO_Port, EXT_R1_Pin, EXT_R2_GPIO_Port, EXT_R2_Pin}, // Encoder {{false, false, 0, EXT_R3_GPIO_Port, EXT_R3_Pin, GPIO_PIN_RESET}, // Button Enter {false, false, 0, EXT_R4_GPIO_Port, EXT_R4_Pin, GPIO_PIN_SET}}} // Button Back }; // *** Structures array for describe encoders inputs ******************** DevJoysticks joysticks[EXT_MAX] = { // Left device {{0, ADC_CHANNEL_11, EXT_L2_GPIO_Port, EXT_L2_Pin, 0, COEF, COEF, false, // Joystick 0, ADC_CHANNEL_10, EXT_L1_GPIO_Port, EXT_L1_Pin, 0, COEF, COEF, true}, {false, false, 0, EXT_L3_GPIO_Port, EXT_L3_Pin, GPIO_PIN_RESET}}, // Button // Right device {{0, ADC_CHANNEL_13, EXT_R2_GPIO_Port, EXT_R2_Pin, 0, COEF, COEF, false, // Joystick 0, ADC_CHANNEL_12, EXT_R1_GPIO_Port, EXT_R1_Pin, 0, COEF, COEF, true}, {false, false, 0, EXT_R3_GPIO_Port, EXT_R3_Pin, GPIO_PIN_RESET}} // Button }; // Handle to timer used for process encoders input TIM_HandleTypeDef* htim = nullptr; // Handle to timer used for process encoders input ADC_HandleTypeDef* hadc = nullptr; // ************************************************************************* // *** Process Button Input function *********************************** // ************************************************************************* void ProcessButtonInput(ButtonProfile&amp; button); // ************************************************************************* // *** Process Encoder Input function ********************************** // ************************************************************************* void ProcessEncoderInput(EncoderProfile&amp; encoder); // ************************************************************************* // *** Process Joystick Input function ********************************* // ************************************************************************* void ProcessJoystickInput(JoystickProfile&amp; joysticks, PortType port); // ************************************************************************* // *** Emulate buttons using joystick function ************************* // ************************************************************************* void EmulateButtonsByJoystick(PortType port); // ************************************************************************* // *** Emulate encoders using buttons function ************************* // ************************************************************************* void EmulateEncodersByButtons(PortType port); // ************************************************************************* // *** Configure inputs devices types ********************************** // ************************************************************************* ExtDeviceType DetectDeviceType(PortType port); // ************************************************************************* // *** Configure ADC *************************************************** // ************************************************************************* void ConfigADC(ExtDeviceType dev_left, ExtDeviceType dev_right); // ************************************************************************* // *** Configure inputs for read digital/analog data ******************* // ************************************************************************* void ConfigInputIO(bool is_digital, PortType port); // ************************************************************************* // ** Private constructor. Only GetInstance() allow to access this class. ** // ************************************************************************* InputDrv() : AppTask(INPUT_DRV_TASK_STACK_SIZE, INPUT_DRV_TASK_PRIORITY, "InputDrv") {}; }; #endif</span></span></code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bildschirmwartungsaufgabe</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist die interessanteste Aufgabe. Der Bildschirm ist zun√§chst 320 x 240 x 16 Bit gro√ü, sodass Sie </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">153600 Byte</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> f√ºr den Framebuffer </font><font style="vertical-align: inherit;">ben√∂tigen </font><font style="vertical-align: inherit;">. Das ist nicht nur viel, es ist einfach riesig - in diesem Mikrocontroller sind nur 192 KB RAM vorhanden, und in Mikrocontrollern ist es m√∂glicherweise einfacher, √ºberhaupt nicht die richtige Gr√∂√üe zu haben. Wie soll ich sein? Die Antwort ist einfach: Zeichnen Sie den Bildschirm in Teilen! Aber Sie k√∂nnen etwas auf verschiedene Arten zeichnen ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die L√∂sung, die ich f√ºr diese Aufgabe angewendet habe, ist wie alle genial. Es hat einen Puffer auf zwei Bildschirmzeilen. Wir zeichnen alles, was in einer Zeile stehen soll, senden es √ºber SPI im DMA-Modus an den Bildschirm und k√∂nnen zu diesem Zeitpunkt eine weitere Zeile vorbereiten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Woher wei√ü die Aufgabe, was in der Linie sein soll und wie sie zu zeichnen ist? Aber sie </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wei√ü es nicht!</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber sie hat eine Liste von Objekten, die wissen, wie man sich selbst zeichnet. </font><font style="vertical-align: inherit;">Jedes dieser Objekte wird von der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VisObject-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klasse geerbt </font><font style="vertical-align: inherit;">.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Header</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//****************************************************************************** // @file VisObject.h // @author Nicolai Shlapunov // // @details DevCore: Visual Object Base Class, header // // @section LICENSE // // Software License Agreement (BSD License) // // Copyright (c) 2016, Devtronic &amp; Nicolai Shlapunov // All rights reserved. // // Redistribution and use in source and binary forms, with or without // modification, are permitted provided that the following conditions are met: // 1. Redistributions of source code must retain the above copyright // notice, this list of conditions and the following disclaimer. // 2. Redistributions in binary form must reproduce the above copyright // notice, this list of conditions and the following disclaimer in the // documentation and/or other materials provided with the distribution. // 3. Neither the name of the Devtronic nor the names of its contributors // may be used to endorse or promote products derived from this software // without specific prior written permission. // // THIS SOFTWARE IS PROVIDED BY DEVTRONIC ''AS IS'' AND ANY EXPRESS OR IMPLIED // WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF // MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. // IN NO EVENT SHALL DEVTRONIC BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED // TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. // //****************************************************************************** #ifndef VisObject_h #define VisObject_h // ***************************************************************************** // *** Includes ************************************************************ // ***************************************************************************** #include "DevCfg.h" // ***************************************************************************** // * VisObject class. This class implements base Visual Objects properties. class VisObject { public: // ************************************************************************* // *** Action ********************************************************** // ************************************************************************* typedef enum { ACT_TOUCH, // When object touched ACT_UNTOUCH, // When object detouched ACT_MOVE, // When object moved on object ACT_MOVEIN, // When object moved in to object ACT_MOVEOUT, // When object moved out of object ACT_MAX // Total possible actions } ActionType; // ************************************************************************* // *** VisObject ******************************************************* // ************************************************************************* VisObject() {}; // ************************************************************************* // *** ~VisObject ****************************************************** // ************************************************************************* // * Destructor. Call DelVisObjectFromList() from DisplayDrv class for // * remove from list before delete and delete semaphore. virtual ~VisObject(); // ************************************************************************* // *** LockVisObject *************************************************** // ************************************************************************* void LockVisObject(); // ************************************************************************* // *** UnlockVisObject ************************************************* // ************************************************************************* void UnlockVisObject(); // ************************************************************************* // *** Show ************************************************************ // ************************************************************************* // * Show VisObject on screen. This function call AddVisObjectToList() from // * DisplayDrv class. When this function calls first time, user must // * provide Z level. In future user can call this function without // * parameters - previously set Z will be used. virtual void Show(uint32_t z_pos = 0); // ************************************************************************* // *** Hide ************************************************************ // ************************************************************************* // * Hide VisObject from screen. This function call DelVisObjectFromList() // * from DisplayDrv class. virtual void Hide(void); // ************************************************************************* // *** IsShow ********************************************************** // ************************************************************************* // * Check status of Show Visual Object. Return true if object in DisplayDrv list. virtual bool IsShow(void); // ************************************************************************* // *** Move ************************************************************ // ************************************************************************* // * Move object on screen. Set new x and y coordinates. If flag is set - // * move is relative, not absolute. virtual void Move(int32_t x, int32_t y, bool is_delta = false); // ************************************************************************* // *** DrawInBufH ****************************************************** // ************************************************************************* // * Draw one horizontal line of object in specified buffer. // * Each derived class must implement this function. virtual void DrawInBufH(uint16_t* buf, int32_t n, int32_t row, int32_t start_y = 0) = 0; // ************************************************************************* // *** DrawInBufW ****************************************************** // ************************************************************************* // * Draw one vertical line of object in specified buffer. // * Each derived class must implement this function. virtual void DrawInBufW(uint16_t* buf, int32_t n, int32_t line, int32_t start_x = 0) = 0; // ************************************************************************* // *** Action ********************************************************** // ************************************************************************* virtual void Action(ActionType action, int32_t tx, int32_t ty); // ************************************************************************* // *** Return Start X coordinate *************************************** // ************************************************************************* virtual int32_t GetStartX(void) {return x_start;}; // ************************************************************************* // *** Return Start Y coordinate *************************************** // ************************************************************************* virtual int32_t GetStartY(void) {return y_start;}; // ************************************************************************* // *** Return End X coordinate ***************************************** // ************************************************************************* virtual int32_t GetEndX(void) {return x_end;}; // ************************************************************************* // *** Return End Y coordinate ***************************************** // ************************************************************************* virtual int32_t GetEndY(void) {return y_end;}; // ************************************************************************* // *** Return Width of object ****************************************** // ************************************************************************* virtual int32_t GetWidth(void) {return width;}; // ************************************************************************* // *** Return Height of object ***************************************** // ************************************************************************* virtual int32_t GetHeight(void) {return height;}; protected: // ************************************************************************* // *** Object parameters *********************************************** // ************************************************************************* // X and Y start coordinates of object int16_t x_start = 0, y_start = 0; // X and Y end coordinates of object int16_t x_end = 0, y_end = 0; // Width and Height of object int16_t width = 0, height = 0; // Rotation of object int8_t rotation = 0; // Object active bool active = false; private: // ************************************************************************* // *** Object parameters *********************************************** // ************************************************************************* // * Only base class and DisplayDrv have access to this parameters // Z position of object uint16_t z = 0; // Pointer to next object. This pointer need to maker object list. Object // can be added only to one list. VisObject* p_next = nullptr; // Pointer to next object. This pointer need to maker object list. Object // can be added only to one list. VisObject* p_prev = nullptr; // DisplayDrv is friend for access to pointers and Z friend class DisplayDrv; }; #endif</span></span></code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Bildschirmwartungsaufgabe f√ºr jede Linie durchl√§uft die Liste der Objekte und ruft die Funktion DrawInBufW () auf. Dabei wird ein Zeiger auf den Puffer, die Anzahl der Punkte, die zu zeichnende Linie und die Startposition √ºbergeben ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bis die Idee verwendet wurde, den Bildschirmsteuerungsmodus zum Aktualisieren des Fensters zu verwenden</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Tats√§chlich zeichnet sich jedes Objekt √ºber die bereits gezeichneten Objekte und es ist einfach, die Objekte in der gew√ºnschten Reihenfolge anzuordnen, indem Sie sie einfach an der gew√ºnschten Position in der Liste platzieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dar√ºber hinaus erleichtert dieser Ansatz die Integration der Verarbeitung aktiver Objekte. Nach dem Empfang der Koordinaten vom Touchscreen-Controller kann die Bildschirmwartungsaufgabe das Arbeitsblatt von Ende an auf der Suche nach dem aktiven Objekt durchlaufen, das in die Koordinaten des Dr√ºckens f√§llt. Wird ein solches Objekt gefunden, wird die virtuelle Funktion Action () f√ºr das angegebene Objekt aufgerufen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Moment gibt es Objekte f√ºr Linien, Grundelemente ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linie, Quadrat, Kreis</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), Bilder und Kachelkarten ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zum Erstellen von Spielen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auch in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DevCore</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> betritt einen </font><font style="vertical-align: inherit;">anderen Code f√ºr einige Elemente der Benutzeroberfl√§che ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wie zum </font><font style="vertical-align: inherit;">Beispiel ein Men√º</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), die Schnittstelle f√ºr den I2C - </font><font style="vertical-align: inherit;">Treiber, I2C - </font><font style="vertical-align: inherit;">Treiber und Bibliotheken f√ºr das </font><font style="vertical-align: inherit;">Arbeiten mit Sensor BME280 und EEPROM 24S256, aber es ist nicht so interessant, und doch will ich nicht beschreiben - und es stellte sich heraus , </font><font style="vertical-align: inherit;">ziemlich gro√ü . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der vollst√§ndige Code ist </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ohne Registrierung und SMS</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verf√ºgbar </font><font style="vertical-align: inherit;">: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/nickshl/devboy </font></font></a> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anscheinend geht das Unternehmen zu Epic Fail. In der ersten Woche nur drei B√§cker, darunter ein Dollar aus einer Art " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Innovationsfonds"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">", $ 180 von einer Person, die wahrscheinlich aus einem Artikel √ºber Habr√© ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Danke, Andrey!</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) Von </font><font style="vertical-align: inherit;">diesem Projekt erfahren hat. </font><font style="vertical-align: inherit;">Und der Rest von meinem Kollegen aus einem benachbarten W√ºrfel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kein Geld zu sammeln ist kein Problem. Das Problem ist das mangelnde Interesse an dem Projekt ...</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424309/">https://habr.com/ru/post/de424309/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424295/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 9: ‚ÄûSicherheit von Webanwendungen‚Äú, Teil 2</a></li>
<li><a href="../de424297/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 9: Sicherheit von Webanwendungen, Teil 3</a></li>
<li><a href="../de424301/index.html">Adaptiver neuronaler Netzwerkbildfilteralgorithmus</a></li>
<li><a href="../de424305/index.html">Plattform√ºbergreifende RIBs f√ºr die mobile Architektur von Uber</a></li>
<li><a href="../de424307/index.html">GitLab 11.3 wurde mit Maven-Repository und sicheren Umgebungen ver√∂ffentlicht</a></li>
<li><a href="../de424311/index.html">Asynchrone Gesch√§ftslogik heutzutage</a></li>
<li><a href="../de424313/index.html">EveryLang ist ein Programm, das fast alles kann</a></li>
<li><a href="../de424315/index.html">Eine neue Runde der Importsubstitution. Wo laufen und was tun?</a></li>
<li><a href="../de424319/index.html">Die Struktur des Online-Shops. Teil 2</a></li>
<li><a href="../de424321/index.html">NetFlow billig und w√ºtend machen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>