<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😸 🎇 🍶 5 prinsip akal sehat untuk membuat aplikasi cloud-asli 💽 🧗🏻 🍊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aplikasi "berbasis cloud" (cloud asli) atau hanya "cloud" dibuat khusus untuk digunakan dalam infrastruktur cloud. Biasanya mereka dibangun sebagai sa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>5 prinsip akal sehat untuk membuat aplikasi cloud-asli</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/455024/">  Aplikasi "berbasis cloud" (cloud asli) atau hanya "cloud" dibuat khusus untuk digunakan dalam infrastruktur cloud.  Biasanya mereka dibangun sebagai satu set layanan microser longgar ditambah dikemas dalam wadah, yang, pada gilirannya, dikelola oleh platform cloud.  Aplikasi seperti itu secara default siap untuk kegagalan, yang berarti mereka bekerja dengan andal dan skala bahkan jika terjadi kegagalan serius pada tingkat infrastruktur.  Sisi lain dari koin adalah serangkaian pembatasan (kontrak) yang diberlakukan platform cloud pada aplikasi kontainer agar dapat mengelolanya secara otomatis. <br><br><img src="https://habrastorage.org/webt/i4/jg/_8/i4jg_8cdsmt7yazeyaz_e2lclmo.png" width="100%"><br><br>  Sadar akan kebutuhan dan pentingnya pindah ke aplikasi cloud, banyak organisasi masih tidak tahu harus mulai dari mana.  Dalam posting ini, kami akan mempertimbangkan sejumlah prinsip, kepatuhan yang selama pengembangan aplikasi kontainer akan menyadari potensi platform cloud dan mencapai operasi yang andal dan penskalaan aplikasi bahkan jika terjadi kegagalan serius di tingkat infrastruktur TI.  Tujuan utama dari prinsip-prinsip yang diuraikan di sini adalah untuk mempelajari cara membuat aplikasi yang dapat dikelola secara otomatis oleh platform cloud seperti Kubernetes. <br><a name="habracut"></a><br><h3>  Prinsip Desain Perangkat Lunak </h3><br>  Dalam dunia pemrograman, prinsip dipahami sebagai aturan yang cukup umum yang harus diperhatikan ketika mengembangkan perangkat lunak.  Mereka dapat digunakan saat bekerja dengan bahasa pemrograman apa pun.  Setiap prinsip memiliki tujuan masing-masing, templat dan praktik biasanya berfungsi sebagai instrumen untuk pencapaian mereka.  Ada juga sejumlah prinsip dasar untuk membuat perangkat lunak berkualitas tinggi, yang diikuti oleh semua yang lain.  Berikut adalah beberapa contoh prinsip dasar: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">KISS</a> (Keep it simple, stupid) - jangan menyulitkan; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">KERING</a> (Jangan ulangi diri Anda sendiri) - jangan ulangi; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">YAGNI</a> (Anda tidak akan membutuhkannya) - jangan membuat sesuatu yang tidak ada kebutuhan mendesaknya; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SoC</a> (Pemisahan keprihatinan) - untuk berbagi tanggung jawab. </li></ul><br>  Seperti yang Anda lihat, prinsip-prinsip ini tidak menetapkan aturan khusus, tetapi termasuk dalam kategori yang disebut pertimbangan akal sehat berdasarkan pengalaman praktis yang dibagikan oleh banyak pengembang dan yang mereka rujuk secara teratur. <br>  Selain itu, ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SOLID</a> - seperangkat lima prinsip pertama pemrograman dan desain berorientasi objek, yang dirumuskan oleh Robert Martin.  SOLID mencakup prinsip saling melengkapi yang digeneralisasi dan terbuka untuk interpretasi, yang - bila diterapkan dalam kombinasi - membantu menciptakan sistem perangkat lunak yang lebih baik dan mendukung mereka dalam jangka panjang. <br><br>  Prinsip SOLID berlaku untuk OOP dan dirumuskan dalam hal konsep dan konsep seperti kelas, antarmuka, dan warisan.  Dengan analogi, untuk aplikasi cloud, Anda juga dapat merumuskan prinsip-prinsip pengembangan, hanya elemen dasar di sini tidak akan menjadi kelas, tetapi sebuah wadah.  Mengikuti prinsip-prinsip ini, Anda dapat membuat aplikasi kemas yang lebih memenuhi tujuan dan sasaran platform cloud seperti Kubernetes. <br><br><h3>  Wadah Berbasis Cloud: Pendekatan Red Hat </h3><br>  Saat ini, hampir semua aplikasi relatif mudah untuk dimasukkan ke dalam wadah.  Tetapi agar aplikasi otomatis terotomatisasi dan diatur dalam platform cloud seperti Kubernetes, diperlukan upaya ekstra. <br>  Ide-ide yang disajikan di bawah ini didasarkan pada metodologi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">The Twelve-Factor App</a> dan banyak karya lain tentang berbagai aspek pembuatan aplikasi web, dari kontrol sumber hingga model skala.  Prinsip-prinsip yang diuraikan hanya berlaku untuk pengembangan aplikasi kontainer yang dibangun berdasarkan layanan microser dan dirancang untuk platform cloud seperti Kubernetes.  Elemen dasar dalam diskusi kami adalah gambar wadah, dan runtime wadah target adalah platform orkestrasi wadah.  Tujuan dari prinsip-prinsip yang diusulkan adalah untuk membuat wadah yang, pada sebagian besar platform orkestrasi, Anda dapat mengotomatiskan tugas penjadwalan (penjadwalan - memilih host untuk menjalankan instance wadah), penskalaan dan pemantauan.  Prinsip-prinsip tersebut diatur dalam urutan acak. <br><br><h3>  Prinsip Kekhawatiran Tunggal (SCP) </h3><br>  Prinsip ini dalam banyak hal mirip dengan Prinsip Tanggung Jawab Tunggal ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SRP</a> ), yang merupakan bagian dari paket SOLID dan menyatakan bahwa setiap objek harus memiliki satu tanggung jawab, dan tanggung jawab ini harus sepenuhnya dirangkum dalam kelas.  Inti dari SRP adalah bahwa setiap tugas adalah alasan untuk perubahan, dan kelas harus memiliki satu dan hanya satu alasan untuk perubahan. <br><br>  Dalam SCP, alih-alih kata "tanggung jawab", kami menggunakan kata "keprihatinan" untuk menunjukkan tingkat abstraksi yang lebih tinggi dan tujuan wadah yang lebih luas dibandingkan dengan kelas OOP.  Dan jika tujuan SRP hanya memiliki satu alasan untuk perubahan, maka SCP memiliki keinginan untuk memperluas kemungkinan menggunakan kembali dan mengganti wadah.  Dengan mengikuti SRP dan membuat wadah yang memecahkan satu tugas tunggal dan membuatnya secara fungsional lengkap, Anda meningkatkan peluang untuk menggunakan kembali gambar wadah ini dalam berbagai konteks aplikasi. <br><br>  Prinsip SCP menyatakan bahwa setiap wadah harus menyelesaikan satu tugas tunggal dan melakukannya dengan baik.  Selain itu, SCP dalam dunia kontainer dicapai lebih mudah daripada SRP dalam dunia OOP, karena kontainer biasanya melakukan satu proses tunggal, dan sebagian besar waktu proses ini menyelesaikan satu tugas tunggal. <br><br>  Jika layanan wadah mikro harus menyelesaikan beberapa masalah sekaligus, maka itu dapat dibagi menjadi wadah tugas tunggal dan menggabungkannya menjadi satu pod (unit penyebaran platform wadah) menggunakan templat sespan dan wadah init.  Selain itu, SCP memudahkan untuk mengganti wadah lama (seperti server web atau broker pesan) dengan yang baru yang memecahkan masalah yang sama, tetapi memiliki fungsionalitas yang ditingkatkan atau skala yang lebih baik. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ud/4j/3o/ud4j3okts2jt7hdfr68-tdjlkw4.png"></div><br><br><h3>  Prinsip kenyamanan pemantauan (Prinsip Observabilitas Tinggi, HOP) </h3><br>  Saat menggunakan wadah sebagai cara terpadu pengemasan dan peluncuran aplikasi, aplikasi itu sendiri dianggap sebagai "kotak hitam".  Namun, jika ini adalah wadah cloud, maka mereka harus menyediakan runtime dengan API khusus untuk memantau kesehatan kontainer dan mengambil tindakan yang sesuai jika perlu.  Tanpa ini, tidak akan mungkin untuk menyatukan otomatisasi memperbarui wadah dan mengelola siklus hidup mereka, yang, pada gilirannya, akan memperburuk stabilitas dan kegunaan sistem perangkat lunak. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nm/_y/lh/nm_ylhsfix0alpq7uwqmjy8smf0.png"></div><br>  Dalam praktiknya, aplikasi kontainer setidaknya harus memiliki API untuk berbagai jenis pemeriksaan kesehatan: tes liveness dan tes kesiapan.  Jika aplikasi mengklaim lebih, maka harus menyediakan cara lain untuk memantau kondisinya.  Misalnya, mencatat peristiwa penting melalui STDERR dan STDOUT untuk mengumpulkan log menggunakan Fluentd, Logstash, dan alat serupa lainnya.  Serta integrasi dengan jejak dan koleksi pustaka metrik seperti OpenTracing, Prometheus, dll. <br><br>  Secara umum, aplikasi masih dapat dianggap sebagai "kotak hitam", tetapi pada saat yang sama harus dilengkapi dengan semua API yang dibutuhkan platform untuk memantau dan mengelolanya dengan cara terbaik. <br><br><h3>  Prinsip Kesesuaian Siklus Hidup (LCP) </h3><br>  LCP adalah antitesis dari HOP.  Jika HOP menyatakan bahwa wadah harus menyediakan platform dengan API untuk dibaca, maka LCP mengharuskan aplikasi untuk dapat menerima informasi dari platform.  Selain itu, wadah tidak hanya harus menerima acara, tetapi juga beradaptasi, dengan kata lain, meresponsnya.  Oleh karena itu nama prinsip, yang dapat dianggap sebagai persyaratan untuk menyediakan platform dengan API untuk menulis. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bd/3s/p8/bd3sp8v4heoylqg4rzjmk5oiyue.png"></div><br>  Platform memiliki berbagai jenis peristiwa yang membantu mengelola siklus hidup wadah.  Tetapi terserah pada aplikasi untuk memutuskan yang mana dari mereka untuk melihat dan bagaimana menanggapi. <br><br>  Jelas bahwa beberapa peristiwa lebih penting daripada yang lain.  Misalnya, jika aplikasi tidak mentolerir penutupan darurat, maka ia harus menerima pesan sinyal: terminate (SIGTERM) dan memulai prosedur terminasi sesegera mungkin untuk menangkap sinyal: kill (SIGKILL) yang datang setelah SIGTERM. <br><br>  Selain itu, acara seperti PostStart dan PreStop dapat menjadi penting untuk siklus hidup aplikasi.  Misalnya, setelah meluncurkan aplikasi, mungkin perlu beberapa waktu untuk "pemanasan" sebelum dapat menanggapi permintaan.  Atau aplikasi itu entah bagaimana harus melepaskan sumber daya saat shutdown. <br><br><h3>  Prinsip imutabilitas gambar wadah (Image Immutability Principle, IIP) </h3><br>  Secara umum diterima bahwa aplikasi kemas harus tetap tidak berubah setelah perakitan, bahkan jika mereka berjalan di lingkungan yang berbeda.  Ini menyiratkan kebutuhan untuk mengeksternalisasi penyimpanan data pada saat runtime (dengan kata lain, gunakan alat eksternal untuk ini), serta bergantung pada konfigurasi eksternal yang dikonfigurasi untuk lingkungan runtime tertentu, alih-alih memodifikasi atau membuat wadah unik untuk setiap lingkungan.  Setelah ada perubahan pada aplikasi, gambar kontainer harus dipasang kembali dan digunakan di semua lingkungan yang digunakan.  Omong-omong, ketika mengelola sistem TI, prinsip yang sama digunakan, yang dikenal sebagai prinsip kekekalan server dan infrastruktur. <br><br>  Tujuan IIP adalah untuk mencegah pembuatan gambar wadah terpisah untuk lingkungan runtime yang berbeda dan menggunakan gambar yang sama di mana-mana bersama dengan konfigurasi yang sesuai untuk lingkungan tertentu.  Dengan mengikuti prinsip ini, Anda dapat menerapkan praktik penting semacam itu dari sudut pandang otomatisasi sistem cloud sebagai roll-back dan roll-forward pembaruan aplikasi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hl/rr/t9/hlrrt9r4lw4f7wcik19j3o5zmou.png"></div><br><h3>  Prinsip Disposabilitas Proses (PDP) </h3><br>  Salah satu karakteristik terpenting dari sebuah wadah adalah sifatnya yang sementara: wadah contoh mudah dibuat dan mudah dihancurkan, sehingga dapat dengan mudah diganti dengan wadah lain kapan saja.  Mungkin ada banyak alasan untuk penggantian seperti itu: kegagalan tes kesehatan, penskalaan aplikasi, transfer ke host lain, kehabisan sumber daya platform, atau situasi lain. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tk/qw/lq/tkqwlqu9-qyusgg6n-wpgl0hxks.png"></div><br>  Akibatnya, aplikasi kontainer harus mempertahankan keadaan mereka menggunakan beberapa cara eksternal, atau menggunakan sirkuit terdistribusi internal dengan redundansi untuk ini.  Selain itu, aplikasi harus diluncurkan dengan cepat dan ditutup dengan cepat, dan bersiaplah untuk kegagalan perangkat keras yang mendadak fatal. <br><br>  Salah satu praktik yang membantu menerapkan prinsip ini adalah membuat wadah kecil.  Lingkungan cloud dapat secara otomatis memilih host untuk meluncurkan instance kontainer, jadi semakin kecil container, semakin cepat akan dimulai - itu hanya akan disalin ke host target melalui jaringan lebih cepat. <br><br><h3>  Prinsip Self-Containment (S-CP) </h3><br>  Menurut prinsip ini, pada tahap perakitan semua komponen yang diperlukan termasuk dalam wadah.  Kontainer harus dibangun dengan harapan bahwa sistem hanya memiliki kernel Linux yang bersih, sehingga semua pustaka tambahan yang diperlukan harus ditempatkan dalam wadah itu sendiri.  Hal-hal juga harus ditempatkan di sana, seperti runtime untuk bahasa pemrograman yang sesuai, platform aplikasi (jika perlu), dan dependensi lain yang akan diperlukan selama pengoperasian aplikasi kontainer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p7/ia/qb/p7iaqbxksacennpuyk5vvhzdnw4.png"></div><br><br>  Pengecualian hanya dibuat untuk konfigurasi yang bervariasi dari satu lingkungan ke lingkungan lainnya, dan harus disediakan pada saat dijalankan, misalnya melalui Kubernetes ConfigMap. <br><br>  Suatu aplikasi dapat mencakup beberapa komponen yang di kemas, misalnya, wadah DBMS yang terpisah sebagai bagian dari aplikasi wadah web.  Menurut prinsip S-CP, wadah ini tidak boleh digabungkan menjadi satu, tetapi dibuat agar wadah DBMS berisi semua yang diperlukan agar database berfungsi, dan wadah aplikasi web berisi semua yang diperlukan agar aplikasi web berfungsi, server web yang sama .  Akibatnya, saat runtime, wadah aplikasi web akan bergantung pada wadah DBMS dan mengaksesnya sesuai kebutuhan. <br><br><h3>  Runtime Confinement Principle (RCP) </h3><br>  Prinsip S-CP mendefinisikan bagaimana wadah harus dirakit dan apa yang harus berisi file gambar biner.  Tapi sebuah wadah bukan hanya "kotak hitam", yang hanya memiliki satu karakteristik - ukuran file.  Saat runtime, wadah memperoleh dimensi lain: jumlah memori yang digunakan, waktu prosesor, dan sumber daya sistem lainnya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/e5/v5/vb/e5v5vbk3witcr7oe1bgs23forks.png"></div><br>  Dan di sini prinsip RCP berguna, yang menurutnya wadah harus memenggal persyaratan untuk sumber daya sistem dan mentransfernya ke platform.  Memiliki profil sumber daya dari setiap wadah (berapa banyak CPU, memori, jaringan dan sumber daya sistem disk yang dibutuhkan), platform dapat secara optimal melakukan penjadwalan dan penskalaan, mengelola kapasitas TI dan mendukung level SLA untuk wadah. <br><br>  Selain memenuhi persyaratan sumber daya wadah, juga penting agar aplikasi tidak melampaui kerangka yang ditentukan oleh wadah.  Kalau tidak, jika ada kekurangan sumber daya, platform lebih cenderung untuk memasukkannya ke dalam daftar aplikasi yang perlu diinterupsi atau dimigrasikan. <br><br>  Berbicara tentang fokus pada cloud, kami terutama memaksudkan cara kami bekerja. <br>  Di atas, kami merumuskan sejumlah prinsip umum yang menetapkan fondasi metodologis untuk membangun aplikasi kontainer berkualitas tinggi untuk lingkungan cloud. <br><br>  Perhatikan bahwa selain prinsip-prinsip umum ini, Anda juga akan memerlukan metode dan teknik canggih tambahan untuk bekerja dengan wadah.  Selain itu, kami memiliki beberapa rekomendasi singkat yang lebih spesifik dan harus diterapkan (atau tidak diterapkan) tergantung pada situasi: <br><br><ul><li>  Cobalah untuk mengurangi ukuran gambar: hapus file sementara dan jangan masukkan paket yang tidak perlu - semakin kecil wadahnya, semakin cepat dikumpulkan dan disalin ke host target melalui jaringan. </li><li>  Fokus pada User-ID sewenang-wenang: jangan gunakan perintah sudo atau userid khusus untuk menjalankan kontainer Anda. </li><li>  Label port penting: nomor port juga dapat ditetapkan saat runtime, tetapi lebih baik untuk menentukannya menggunakan perintah EXPOSE - akan lebih mudah bagi orang lain dan program untuk menggunakan gambar Anda. </li><li>  Menyimpan data terus-menerus pada volume: data yang harus tetap setelah wadah dihancurkan harus ditulis ke volume. </li><li>  Tulis metadata gambar: tag, label, dan anotasi membuatnya lebih mudah untuk menggunakan gambar - pengembang lain akan berterima kasih. </li><li>  Menyinkronkan host dan gambar: untuk beberapa aplikasi wadah, perlu untuk menyinkronkan wadah dengan host sesuai dengan atribut tertentu, seperti waktu atau ID mesin. </li><li>  Sebagai kesimpulan, kami berbagi templat dan praktik terbaik yang akan membantu menerapkan prinsip-prinsip di atas dengan lebih efektif: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.slideshare.net/luebken/container-patterns</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">docs.projectatomic.io/container-best-practices</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">docs.openshift.com/enterprise/3.0/creating_images/guidelines.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.usenix.org/system/files/conference/hotcloud16/hotcloud16_burns.pdf</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">leanpub.com/k8spatterns</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">12factor.net</a> </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>Webinar pada versi baru OpenShift Container Platform - 4</b></a> <br>  11 Juni pukul 11.00 <br><br>  Apa yang akan Anda pelajari: <br><br><ul><li>  CoreOS Linux Red Hat Enterprise yang Tidak Berubah </li><li>  Mesh layanan openshift </li><li>  Kerangka kerja operator </li><li>  Kerangka kerja knatif </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id455024/">https://habr.com/ru/post/id455024/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455010/index.html">Skrip pengguna asinkron di Rust murni tanpa kerangka kerja dan SMS</a></li>
<li><a href="../id455012/index.html">FAQ Intersepsi Seluler: Apa itu Interceptors / SCAT IMSI dan Dapatkah Saya Melindungi Mereka?</a></li>
<li><a href="../id455016/index.html">Kami membuat situs yang paling sulit diakses dengan peringkat ideal Mercusuar</a></li>
<li><a href="../id455020/index.html">Keuntungan dan Kerugian Menggunakan Flutter untuk Pengembangan Seluler</a></li>
<li><a href="../id455022/index.html">Bagaimana menjalankan Scrum secara efisien pada tahun 2019? Panduan cepat untuk pemula</a></li>
<li><a href="../id455030/index.html">Spesifikasi PHP</a></li>
<li><a href="../id455038/index.html">Tentang bagaimana Plesk mengunjungi KubeCon</a></li>
<li><a href="../id455040/index.html">Meningkatkan kerja Wi-Fi. Bagian 2. Fitur Peralatan</a></li>
<li><a href="../id455042/index.html">Kotlin DSL, Jadwal dan tes UI yang elegan di Android</a></li>
<li><a href="../id455048/index.html">Implementasi teknis dari metode potensi termal untuk analisis wilayah</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>