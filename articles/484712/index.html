<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍔 👂🏾 👨🏾‍🎨 Compatibilidad binaria reactiva: cómo la proporcionamos 🍳 👩🏿‍🔬 🕕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Mi nombre es Yuri Vlad, soy desarrollador de Android en Badoo y participo en la creación de la biblioteca Reaktive - Extensiones reactivas en Kot...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Compatibilidad binaria reactiva: cómo la proporcionamos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/484712/"><p>  Hola  Mi nombre es Yuri Vlad, soy desarrollador de Android en Badoo y participo en la creación de la biblioteca <a href="https://github.com/badoo/Reaktive">Reaktive</a> - Extensiones reactivas en Kotlin puro. </p><br><p>  Cualquier biblioteca debe observar la compatibilidad binaria siempre que sea posible.  Si las diferentes versiones de la biblioteca en las dependencias son incompatibles, el resultado se bloqueará en tiempo de ejecución.  Podemos encontrar un problema de este tipo, por ejemplo, al agregar soporte <a href="https://github.com/badoo/MVICore">Reaktive</a> a <a href="https://github.com/badoo/MVICore">MVICore</a> . </p><br><p><img src="https://habrastorage.org/webt/6w/hx/mc/6whxmcr9swxn5rtbxjeo46igkv8.jpeg"></p><br><p>  En este artículo, le diré brevemente qué es la compatibilidad binaria y cuáles son sus características para Kotlin, así como también cómo se admite en JetBrains y ahora en Badoo. </p><a name="habracut"></a><br><h2 id="problema-binarnoy-sovmestimosti-v-kotlin">  Problema de compatibilidad binaria de Kotlin </h2><br><p> Supongamos que tenemos una biblioteca maravillosa <code>com.sample:lib:1.0</code> con esta clase: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>)</code> </pre> <br><p>  En base a esto, creamos una segunda biblioteca <code>com.sample:lib-extensions:1.0</code> .  Entre sus dependencias se encuentra <code>com.sample:lib:1.0</code> .  Por ejemplo, contiene un método de fábrica para la clase <code>A</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: A = A(a)</code> </pre> <br><p>  Ahora <code>com.sample:lib:2.0</code> la nueva versión de nuestra biblioteca <code>com.sample:lib:2.0</code> con el siguiente cambio: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>)</code> </pre> <br><p>  El cambio totalmente compatible de Kotlin, ¿no?  Con el parámetro predeterminado, podemos continuar usando la construcción <code>val a = A(a)</code> , pero solo si todas las dependencias se vuelven a compilar por completo.  Los parámetros predeterminados no son parte de la JVM y están implementados por el constructor sintético especial <code>A</code> , que contiene todos los campos de la clase en los parámetros.  En el caso de recibir dependencias del repositorio de Maven, las tenemos ya ensambladas y no podemos volver a compilarlas. </p><br><p>  Se <code>com.sample:lib</code> una nueva versión de <code>com.sample:lib</code> , e inmediatamente la conectamos a nuestro proyecto.  ¡Queremos estar al día!  Nuevas características, nuevas correcciones, <del>  nuevos errores </del>  ! </p><br><pre> <code class="plaintext hljs">dependencies { implementation 'com.sample:lib:2.0' implementation 'com.sample:lib-extensions:1.0' }</code> </pre> <br><p>  Y en este caso, nos estrellamos en tiempo de ejecución.  <code>createA</code> función <code>createA</code> en el bytecode intentará llamar al constructor de clase <code></code> con un parámetro, pero no existe tal en el bytecode.  De todas las dependencias con el mismo grupo y nombre, Gradle seleccionará la que tenga la versión más reciente y la incluirá en el ensamblado. </p><br><p>  Lo más probable es que ya haya encontrado incompatibilidad binaria en sus proyectos.  Personalmente, me encontré con esto cuando migré nuestras aplicaciones a AndroidX. </p><br><p>  Puede leer más sobre la compatibilidad binaria en los artículos <a href="https://habr.com/ru/post/133907/">“Compatibilidad binaria en ejemplos y no solo”</a> del usuario de <a href="https://habr.com/ru/users/gvsmirnov/" class="user_link">gvsmirnov</a> , <a href="https://wiki.eclipse.org/Evolving_Java-based_APIs_2">“Evolución de las API 2 basadas en Java”</a> de los creadores de Eclipse y en el artículo recientemente publicado <a href="https://jakewharton.com/public-api-challenges-in-kotlin/">“Desafíos de la API pública en Kotlin” de</a> Jake Wharton. </p><br><h2 id="sposoby-obespecheniya-binarnoy-sovmestimosti">  Formas de garantizar la compatibilidad binaria </h2><br><p>  Parece que solo necesita intentar hacer cambios compatibles.  Por ejemplo, agregue constructores con un valor predeterminado al agregar nuevos campos, agregue nuevos parámetros a las funciones anulando un método con un nuevo parámetro, etc. Pero siempre es fácil cometer un error.  Por lo tanto, se crearon varias herramientas para verificar la compatibilidad binaria de dos versiones diferentes de la misma biblioteca, tales como: </p><br><ol><li>  Comprobador de cumplimiento de API Java </li><li>  Clirr </li><li>  Revapi </li><li>  Japicmp </li><li>  Japitools </li><li>  Jour </li><li>  Japi-checker </li><li>  Sigtest </li></ol><br><p>  Toman dos archivos JAR y dan el resultado: cuán compatibles son. </p><br><p>  Sin embargo, estamos desarrollando la biblioteca Kotlin, que hasta ahora tiene sentido usar solo desde Kotlin.  Esto significa que no siempre necesitamos una compatibilidad del 100%, por ejemplo, para <code>internal</code> clases <code>internal</code> .  Aunque son públicos en bytecode, su uso fuera del código de Kotlin es poco probable.  Por lo tanto, para mantener la compatibilidad binaria, kotlin-stdlib JetBrains utiliza un <a href="https://github.com/jetBrains/kotlin/tree/master/libraries/tools/binary-compatibility-validator">verificador de compatibilidad binaria</a> .  El principio básico es el siguiente: se crea un volcado de toda la API pública a partir del archivo JAR y se escribe en el archivo.  Este archivo es una línea de base (referencia) para todas las comprobaciones adicionales, y se ve así: </p><br><pre> <code class="plaintext hljs">public final class kotlin/coroutines/ContinuationKt { public static final fun createCoroutine (Lkotlin/jvm/functions/Function1;Lkotlin/coroutines/Continuation;)Lkotlin/coroutines/Continuation; public static final fun createCoroutine (Lkotlin/jvm/functions/Function2;Ljava/lang/Object;Lkotlin/coroutines/Continuation;)Lkotlin/coroutines/Continuation; public static final fun startCoroutine (Lkotlin/jvm/functions/Function1;Lkotlin/coroutines/Continuation;)V public static final fun startCoroutine (Lkotlin/jvm/functions/Function2;Ljava/lang/Object;Lkotlin/coroutines/Continuation;)V }</code> </pre> <br><p>  Después de realizar cambios en el código fuente, la biblioteca de línea base se regenera, en comparación con la actual, y la comprobación falla si aparece algún cambio en la línea base.  Estos cambios se pueden sobrescribir pasando <code>-Doverwrite.output=true</code> .  Se producirá un error incluso si se han producido cambios binarios compatibles.  Esto es necesario para actualizar oportunamente la línea de base y ver sus cambios directamente en la solicitud de extracción. </p><br><h2 id="binary-compatibility-validator">  Validador de compatibilidad binaria </h2><br><p>  Veamos cómo funciona esta herramienta.  La compatibilidad binaria se proporciona en el nivel JVM (bytecode) y es independiente del lenguaje.  Es posible reemplazar la implementación de la clase Java con Kotlin sin romper la compatibilidad binaria (y viceversa). <br>  Primero debe comprender qué clases hay en la biblioteca.  Recordamos que incluso para funciones y constantes globales, se crea una clase con el nombre del archivo y el sufijo <code>Kt</code> , por ejemplo, <code>ContinuationKt</code> .  Para obtener todas las clases, utilizamos la clase <code>JarFile</code> del JDK, obtenemos punteros a cada clase y los pasamos a <code>org.objectweb.asm.tree.ClassNode</code> .  Esta clase nos permitirá conocer la visibilidad de la clase, sus métodos, campos y anotaciones. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> jar = JarFile(<span class="hljs-string"><span class="hljs-string">"/path/to/lib.jar"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classStreams = jar.classEntries().map { entry -&gt; jar.getInputStream(entry) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classNodes = classStreams.map { it.use { stream -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classNode = ClassNode() ClassReader(stream).accept(classNode, ClassReader.SKIP_CODE) classNode } }</code> </pre> <br><p>  Kotlin, al compilar, agrega su anotación de tiempo de ejecución <code>@Metadata</code> a cada clase para que <code>kotlin-reflect</code> pueda restaurar el aspecto de la clase Kotlin antes de que se convierta en bytecode.  Se ve así: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Metadata</span></span>( mv = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>}, bv = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}, k = <span class="hljs-number"><span class="hljs-number">1</span></span>, d1 = {<span class="hljs-string"><span class="hljs-string">"\u0000 \n\u0002\u0018\u0002\n\u0002\u0010\u0000\n\u0000\n\u0002\u0010\b\n\u0002\b\u0006\n\u0002\u0010\u000b\n\u0002\b\u0003\n\u0002\u0010\u000e\n\u0000\b\u0086\b\u0018\u00002\u00020\u0001B\r\u0012\u0006\u0010\u0002\u001a\u00020\u0003¢\u0006\u0002\u0010\u0004J\t\u0010\u0007\u001a\u00020\u0003HÆ\u0003J\u0013\u0010\b\u001a\u00020\u00002\b\b\u0002\u0010\u0002\u001a\u00020\u0003HÆ\u0001J\u0013\u0010\t\u001a\u00020\n2\b\u0010\u000b\u001a\u0004\u0018\u00010\u0001HÖ\u0003J\t\u0010\f\u001a\u00020\u0003HÖ\u0001J\t\u0010\r\u001a\u00020\u000eHÖ\u0001R\u0011\u0010\u0002\u001a\u00020\u0003¢\u0006\b\n\u0000\u001a\u0004\b\u0005\u0010\u0006¨\u0006\u000f"</span></span>}, d2 = {<span class="hljs-string"><span class="hljs-string">"Lcom/sample/A;"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"(I)V"</span></span>, <span class="hljs-string"><span class="hljs-string">"getA"</span></span>, <span class="hljs-string"><span class="hljs-string">"()I"</span></span>, <span class="hljs-string"><span class="hljs-string">"component1"</span></span>, <span class="hljs-string"><span class="hljs-string">"copy"</span></span>, <span class="hljs-string"><span class="hljs-string">"equals"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"other"</span></span>, <span class="hljs-string"><span class="hljs-string">"hashCode"</span></span>, <span class="hljs-string"><span class="hljs-string">"toString"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"app_release"</span></span>} )</code> </pre> <br><p>  <code>ClassNode</code> obtener la anotación <code>@Metadata</code> de <code>@Metadata</code> y analizarla en <code>KotlinClassHeader</code> .  <code>kotlin-reflect</code> hacerlo manualmente, porque <code>kotlin-reflect</code> no sabe cómo trabajar con ObjectWeb ASM. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ClassNode.kotlinMetadata: KotlinClassMetadata? <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> metadata = findAnnotation(<span class="hljs-string"><span class="hljs-string">"kotlin/Metadata"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) ?: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> header = with(metadata) { KotlinClassHeader( kind = <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"k"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>?, metadataVersion = (<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"mv"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> List&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;?)?.toIntArray(), bytecodeVersion = (<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"bv"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> List&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;?)?.toIntArray(), data1 = (<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"d1"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> List&lt;String&gt;?)?.toTypedArray(), data2 = (<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> List&lt;String&gt;?)?.toTypedArray(), extraString = <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"xs"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> String?, packageName = <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"pn"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> String?, extraInt = <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"xi"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>? ) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> KotlinClassMetadata.read(header) }</code> </pre> <br><p>  kotlin.Metadata es necesaria para manejar adecuadamente <code>internal</code> , porque no existe en el bytecode.  Los cambios en <code>internal</code> clases y funciones <code>internal</code> no pueden afectar a los usuarios de la biblioteca, aunque son una API pública en términos de bytecode. </p><br><p>  Desde kotlin.Metadata puede encontrar información sobre <code>companion object</code> .  Incluso si lo declara privado, se almacenará en el campo público estático <code>Companion</code> , lo que significa que este campo se encuentra bajo el requisito de compatibilidad binaria. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompositeException</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { } }</code> </pre> <br><pre> <code class="plaintext hljs">public final static Lcom/badoo/reaktive/base/exceptions/CompositeException$Companion; Companion @Ljava/lang/Deprecated;()</code> </pre> <br><p>  De las anotaciones necesarias, vale la pena señalar <code>@PublishedApi</code> para las clases y métodos que se utilizan en funciones públicas en <code>inline</code> .  El cuerpo de tales funciones permanece en los lugares de su llamada, lo que significa que las clases y los métodos en ellas deben ser compatibles con los binarios.  Cuando intenta utilizar clases y métodos no públicos en tales funciones, el compilador de Kotlin <code>@PublishedApi</code> error y ofrecerá marcarlos con la anotación <code>@PublishedApi</code> . </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> ClassNode.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isPublishedApi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = findAnnotation(<span class="hljs-string"><span class="hljs-string">"kotlin/PublishedApi"</span></span>, includeInvisible = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) != <span class="hljs-literal"><span class="hljs-literal">null</span></span></code> </pre> <br><p>  El árbol de herencia de clases y la implementación de interfaces son importantes para admitir la compatibilidad binaria.  No podemos, por ejemplo, simplemente eliminar alguna interfaz de la clase.  Y obtener la clase principal y las interfaces implementables es bastante simple. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> supertypes = listOf(classNode.superName) - <span class="hljs-string"><span class="hljs-string">"java/lang/Object"</span></span> + classNode.interfaces.sorted()</code> </pre> <br><p>  <code>Object</code> eliminado de la lista, ya que el seguimiento no tiene ningún sentido. </p><br><p>  Dentro del validador hay muchas verificaciones adicionales específicas de Kotlin adicionales: verificar los métodos predeterminados en las interfaces a través de <code>Interface$DefaultImpls</code> , ignorar las clases <code>$WhenMappings</code> para el operador <code>when</code> trabajar, y otros. </p><br><p>  A continuación, debe pasar por todo el <code>ClassNode</code> y obtener su <code>MethodNode</code> y <code>FieldNode</code> .  A partir de la firma de las clases, sus campos y métodos, obtenemos <code>ClassBinarySignature</code> , <code>FieldBinarySignature</code> y <code>MethodBinarySignature</code> , que se declaran localmente en el proyecto.  Todos ellos implementan la interfaz <code>MemberBinarySignature</code> , pueden determinar su visibilidad pública utilizando el método <code>isEffectivelyPublic</code> y mostrar su firma en un formato legible. <code>val signature: String</code> . </p><br><pre> <code class="kotlin hljs">classNodes.map { with(it) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> metadata = kotlinMetadata <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> mVisibility = visibilityMapNew[name] <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classAccess = AccessFlags(effectiveAccess and Opcodes.ACC_STATIC.inv()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> supertypes = listOf(superName) - <span class="hljs-string"><span class="hljs-string">"java/lang/Object"</span></span> + interfaces.sorted() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> memberSignatures = ( fields.map { with(it) { FieldBinarySignature(JvmFieldSignature(name, desc), isPublishedApi(), AccessFlags(access)) } } + methods.map { with(it) { MethodBinarySignature(JvmMethodSignature(name, desc), isPublishedApi(), AccessFlags(access)) } } ).filter { it.isEffectivelyPublic(classAccess, mVisibility) } ClassBinarySignature(name, superName, outerClassName, supertypes, memberSignatures, classAccess, isEffectivelyPublic(mVisibility), metadata.isFileOrMultipartFacade() || isDefaultImpls(metadata) } }</code> </pre> <br><p>  Después de recibir la lista <code>ClassBinarySignature</code> , puede escribirla en un archivo o memoria utilizando el método <code>dump(to: Appendable)</code> y compararla con la línea de base, que ocurre en la prueba <code>RuntimePublicAPITest</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RuntimePublicAPITest</span></span></span><span class="hljs-class"> </span></span>{ @[Rule JvmField] <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testName = TestName() <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kotlinStdlibRuntimeMerged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { snapshotAPIAndCompare(<span class="hljs-string"><span class="hljs-string">"../../stdlib/jvm/build/libs"</span></span>, <span class="hljs-string"><span class="hljs-string">"kotlin-stdlib"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">snapshotAPIAndCompare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( basePath: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, jarPattern: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, publicPackages: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; = emptyList()</span></span></span></span>, nonPublicPackages: List&lt;String&gt; = emptyList() ) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> base = File(basePath).absoluteFile.normalize() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> jarFile = getJarPath(base, jarPattern, System.getProperty(<span class="hljs-string"><span class="hljs-string">"kotlinVersion"</span></span>)) println(<span class="hljs-string"><span class="hljs-string">"Reading binary API from </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$jarFile</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> api = getBinaryAPI(JarFile(jarFile)).filterOutNonPublic(nonPublicPackages) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> target = File(<span class="hljs-string"><span class="hljs-string">"reference-public-api"</span></span>) .resolve(testName.methodName.replaceCamelCaseWithDashedLowerCase() + <span class="hljs-string"><span class="hljs-string">".txt"</span></span>) api.dumpAndCompareWith(target) }</code> </pre> <br><p>  Al confirmar una nueva línea de base, obtenemos los cambios en un formato legible, como, por ejemplo, en esta <a href="https://github.com/badoo/Reaktive/pull/312/commits/c8985c15d24346ecfe89cb2ac84fbe7cf6cbeb3e">confirmación</a> : </p><br><pre> <code class="diff hljs"> public static final fun flattenObservable (Lcom/badoo/reaktive/single/Single;)Lcom/badoo/reaktive/observable/Observable; } + public final class com/badoo/reaktive/single/MapIterableKt { + public static final fun mapIterable (Lcom/badoo/reaktive/single/Single;Lkotlin/jvm/functions/Function1;)Lcom/badoo/reaktive/single/Single; + public static final fun mapIterableTo (Lcom/badoo/reaktive/single/Single;Lkotlin/jvm/functions/Function0;Lkotlin/jvm/functions/Function1;)Lcom/badoo/reaktive/single/Single; + } public final class com/badoo/reaktive/single/MapKt {</code> </pre> <br><h2 id="ispolzovanie-validatora-v-svoyom-proekte">  Usando un validador en su proyecto </h2><br><p>  El uso es extremadamente simple.  Copie el <code>binary-compatibility-validator</code> en su proyecto y cambie su <code>build.gradle</code> y <code>RuntimePublicAPITest</code> : </p><br><pre> <code class="kotlin hljs">plugins { id(<span class="hljs-string"><span class="hljs-string">"org.jetbrains.kotlin.jvm"</span></span>) } dependencies { implementation(Deps.asm) implementation(Deps.asm.tree) implementation(Deps.kotlinx.metadata.jvm) testImplementation(Deps.kotlin.test.junit) } tasks.named(<span class="hljs-string"><span class="hljs-string">"test"</span></span>, Test::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      ,   -     Gradle       : dependsOn( ":coroutines-interop:jvmJar", ":reaktive-annotations:jvmJar", ":reaktive:jvmJar", ":reaktive-annotations:jvmJar", ":reaktive-testing:jvmJar", ":rxjava2-interop:jar", ":rxjava3-interop:jar", ":utils:jvmJar" ) //    ,          baseline-: outputs.upToDateWhen { false } //    systemProperty("overwrite.output", findProperty("binary-compatibility-override") ?: "true") systemProperty("kotlinVersion", findProperty("reaktive_version").toString()) systemProperty("testCasesClassesDirs", sourceSets.test.get().output.classesDirs.asPath) jvmArgs("-ea") }</span></span></code> </pre> <br><p>  En nuestro caso, una de las funciones de prueba del archivo <code>RuntimePublicAPITest</code> ve así: </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reaktive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { snapshotAPIAndCompare(<span class="hljs-string"><span class="hljs-string">"../../reaktive/build/libs"</span></span>, <span class="hljs-string"><span class="hljs-string">"reaktive-jvm"</span></span>) }</code> </pre> <br><p>  Ahora, para cada solicitud de extracción, ejecute <code>./gradlew :tools:binary-compatibility:test -Pbinary-compatibility-override=false</code> y obligue a los desarrolladores a actualizar los archivos de referencia a tiempo. </p><br><h2 id="lozhka-dyogtya">  Volar en la pomada </h2><br><p>  Sin embargo, este enfoque tiene algunos puntos negativos. </p><br><p>  Primero, debemos analizar independientemente los cambios en los archivos de línea de base.  No siempre sus cambios conducen a incompatibilidad binaria.  Por ejemplo, si implementa una nueva interfaz, obtiene una diferencia en la línea de base: </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">- public final class com/test/A { + public final class com/test/A : Comparable {</span></span></code> </pre> <br><p>  En segundo lugar, se utilizan herramientas que no están destinadas a esto.  Las pruebas no deberían tener efectos secundarios en la forma de escribir algún archivo en el disco, que luego será utilizado por la misma prueba, y aún más, pasarle parámetros a través de variables de entorno.  Sería genial usar esta herramienta en un complemento de Gradle y crear una línea base usando una tarea.  Pero realmente no quiero cambiar algo por nuestra cuenta en el validador, por lo que más tarde sería fácil extraer todos sus cambios del repositorio de Kotlin, porque en el futuro pueden aparecer nuevas construcciones en el lenguaje que necesita ser compatible. </p><br><p>  Bueno y en tercer lugar, solo se admite JVM. </p><br><h2 id="zaklyuchenie">  Conclusión </h2><br><p>  Con el <a href="https://github.com/jetBrains/kotlin/tree/master/libraries/tools/binary-compatibility-validator">comprobador de compatibilidad binaria,</a> puede lograr la compatibilidad binaria y responder a tiempo a un cambio en su estado.  Para usarlo en el proyecto, era necesario cambiar solo dos archivos y conectar las pruebas a nuestro CI.  Esta solución tiene algunas desventajas, pero sigue siendo bastante conveniente de usar.  Ahora Reaktive intentará mantener la compatibilidad binaria para JVM de la misma manera que JetBrains lo hace para la Biblioteca estándar de Kotlin. </p><br><p>  Gracias por su atencion! </p></div></div><p>Source: <a href="https://habr.com/ru/post/484712/">https://habr.com/ru/post/484712/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../484700/index.html">Java 14: vista previa de registros</a></li>
<li><a href="../484702/index.html">Alternativas de Prestashop en 2020: principales plataformas de comercio electrónico</a></li>
<li><a href="../484706/index.html">Practica trabajando con neumáticos personalizados del complejo Redd</a></li>
<li><a href="../484708/index.html">Richard Hamming "Capítulo inexistente": ¿Cómo sabemos lo que sabemos (versión completa)</a></li>
<li><a href="../484710/index.html">Romper las reglas de la recolección de basura de Unity</a></li>
<li><a href="../484716/index.html">Deja de llamar a todo AI</a></li>
<li><a href="../484718/index.html">Las impresoras modernas HP se niegan a trabajar sin suscripción de tinta</a></li>
<li><a href="../484720/index.html">Concierto para una ciudad con una orquesta: quién y por qué graba los sonidos de la vida cotidiana</a></li>
<li><a href="../484722/index.html">Qué herramientas de desarrollo de Ruby on Rails se adaptan a su proyecto: las mejores gemas de Ruby on Rails para 2020</a></li>
<li><a href="../484724/index.html">Noticias del mundo de OpenStreetMap No. 494 (12.31.2019-06.01.2020)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>