<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽 👨🏽 📏 Unser kleiner Beitrag zum Kampf der Avalonia-Benutzeroberfläche für weniger Plattformen 📫 👩🏿‍🤝‍👩🏼 🎴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel ist eine Übersicht über die Fehler, die im Avalonia-UI-Projekt mit dem statischen Analysegerät PVS-Studio gefunden wurden. Avalonia UI ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unser kleiner Beitrag zum Kampf der Avalonia-Benutzeroberfläche für weniger Plattformen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/481612/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e34/9b1/06a/e349b106a7c1d3ea775353520b20cd91.png" alt="Abbildung 2"></div><br>  Dieser Artikel ist eine Übersicht über die Fehler, die im Avalonia-UI-Projekt mit dem statischen Analysegerät PVS-Studio gefunden wurden.  Avalonia UI ist ein plattformübergreifendes Open-Source-XAML-basiertes UI-Framework.  Dies ist eines der technologisch bedeutendsten Projekte in der Geschichte von .NET, da Entwickler plattformübergreifende Schnittstellen auf der Basis des WPF-Systems erstellen können.  Wir hoffen, dass die Autoren des Projekts diesen Artikel hilfreich finden, um einige der Fehler zu beheben und überzeugend genug sind, um statische Analysen in ihren Entwicklungsprozess einzubeziehen. <br><a name="habracut"></a><br><h2>  Über Avalonia UI </h2><br>  Mit Avalonia UI (früher als Perspex bekannt) können Entwickler Benutzeroberflächen erstellen, die unter Windows, Linux und MacOS ausgeführt werden können.  Als experimentelles Feature bietet es auch Unterstützung für Android und iOS.  Die Avalonia-Benutzeroberfläche ist kein Wrapper für andere Wrapper wie Xamarin Forms, der Xamarin-Wrapper umschließt, sondern greift direkt auf die native API zu.  Beim Anschauen eines der Demo-Videos war ich erstaunt, dass Sie ein Steuerelement auf der Debian-Konsole ausgeben können.  Dank der Verwendung der XAML-Auszeichnungssprache bietet die Avalonia-Benutzeroberfläche im Vergleich zu anderen Benutzeroberflächenkonstruktoren mehr Design- und Layoutfunktionen. <br><br>  Avalonia UI wird unter anderem in <a href="https://github.com/VitalElement/AvalonStudio">AvalonStudio</a> (einer plattformübergreifenden IDE für die C # - und C / C ++ - Softwareentwicklung) und <a href="https://github.com/wieslawsoltes/Core2D">Core2D</a> (einem 2D-Diagrammeditor) verwendet.  <a href="https://wasabiwallet.io/">Wasabi Wallet</a> (eine Bitcoin-Brieftasche) ist ein Beispiel für kommerzielle Software, die die Avalonia-Benutzeroberfläche verwendet. <br><br>  Der Kampf gegen die Notwendigkeit, beim Erstellen einer plattformübergreifenden Anwendung eine Reihe von Bibliotheken zu führen, ist äußerst wichtig.  Wir wollten den Autoren der Avalonia-Benutzeroberfläche dabei helfen, also lud ich den Quellcode des Projekts herunter und überprüfte ihn mit unserem Analyser.  Ich hoffe, dass sie diesen Artikel sehen und die vorgeschlagenen Korrekturen vornehmen und sogar regelmäßig statische Analysen als Teil ihres Entwicklungsprozesses verwenden.  Dies ist dank der kostenlosen Lizenzierungsoption von PVS-Studio für Open-Source-Entwickler problemlos möglich.  Die regelmäßige Verwendung statischer Analysen hilft, viele Probleme zu vermeiden und das Erkennen und Beheben von Fehlern viel billiger zu machen. <br><br><h2>  Analyseergebnisse </h2><br>  <b>PVS-Studio-Diagnosemeldung: <a href="https://www.viva64.com/en/w/v3001/">V3001</a></b> Links und rechts vom Operator '^' befinden sich identische Unterausdrücke 'controlledFlags'.  WindowImpl.cs 975TwitterClientMessageHandler.cs 52 <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateWMStyles</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Action change</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> style = (WindowStyles)GetWindowLong(....); .... style = style | controlledFlags ^ controlledFlags; .... }</code> </pre> <br>  Beginnen wir mit unserer ersten C # -Diagnose, um eine gewisse Symbolik hinzuzufügen.  Der Analysator hat einen merkwürdigen Ausdruck mit dem bitweisen Operator OR erkannt.  Lassen Sie mich dies mit Zahlen erklären: <br><br>  der Ausdruck <br><br><pre> <code class="cs hljs"><span class="hljs-number"><span class="hljs-number">1100</span></span> <span class="hljs-number"><span class="hljs-number">0011</span></span> | <span class="hljs-number"><span class="hljs-number">1111</span></span> <span class="hljs-number"><span class="hljs-number">0000</span></span> ^ <span class="hljs-number"><span class="hljs-number">1111</span></span> <span class="hljs-number"><span class="hljs-number">0000</span></span></code> </pre> <br>  ist äquivalent zu <br><br><pre> <code class="cs hljs"><span class="hljs-number"><span class="hljs-number">1100</span></span> <span class="hljs-number"><span class="hljs-number">0011</span></span> | <span class="hljs-number"><span class="hljs-number">0000</span></span> <span class="hljs-number"><span class="hljs-number">0000</span></span></code> </pre> <br>  Die Priorität des exklusiven ODER ("^") ist höher als die des bitweisen ODER ("|").  Der Programmierer hatte diese Reihenfolge wahrscheinlich nicht vorgesehen.  Der Code kann durch Einschließen des ersten Ausdrucks in Klammern festgelegt werden: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateWMStyles</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Action change</span></span></span><span class="hljs-function">)</span></span> { .... style = (style | controlledFlags) ^ controlledFlags; .... }</code> </pre> <br>  Was die nächsten beiden Warnungen angeht, muss ich zugeben: Dies sind falsch positive Ergebnisse.  Sie sehen, die Entwickler verwenden die öffentliche API der <i>TransformToVisual-</i> Methode.  In diesem Fall ist <i>VisualRoot</i> immer ein übergeordnetes Element für <i>Visual</i> .  Das habe ich bei der Prüfung der Warnung nicht verstanden.  Erst nachdem ich den Artikel fertiggestellt hatte, erzählte mir einer der Autoren des Projekts davon.  Daher zielen die unten vorgeschlagenen Korrekturen darauf ab, den Code vor möglichen Änderungen zu schützen, die diese Logik verletzen, und nicht auf einen tatsächlichen Absturz. <br><br>  <b>PVS-Studio-Diagnosemeldung: <a href="https://www.viva64.com/en/w/v3080/">V3080</a></b> Mögliche Null-Dereferenzierung des Methodenrückgabewerts.  Betrachten Sie Folgendes: TranslatePoint (...).  VisualExtensions.cs 23 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Point </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PointToClient</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IVisual visual, PixelPoint point</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rootPoint = visual.VisualRoot.PointToClient(point); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> visual.VisualRoot.TranslatePoint(rootPoint, visual).Value; }</code> </pre> <br>  Diese Methode ist klein.  Der Analysator ist der Ansicht, dass die Dereferenzierung des durch den Aufruf von <i>TranslatePoint zurückgegebenen</i> Werts unsicher ist.  Werfen wir einen Blick auf diese Methode: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Point? TranslatePoint(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IVisual visual, Point point, IVisual relativeTo) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> transform = visual.TransformToVisual(relativeTo); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (transform.HasValue) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> point.Transform(transform.Value); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  In der Tat könnte es <i>null zurückgeben</i> . <br><br>  Diese Methode wird sechsmal aufgerufen: dreimal mit einer Überprüfung des zurückgegebenen Werts und dreimal ohne Überprüfung, wodurch die Warnung vor einer möglichen Dereferenzierung ausgelöst wird.  Das erste ist das obige und hier sind die beiden anderen: <br><br><ul><li>  <a href="https://www.viva64.com/en/w/v3080/">V3080</a> Mögliche Null-Dereferenzierung.  Sehen Sie sich 'p' an.  VisualExtensions.cs 35 </li><li>  <a href="https://www.viva64.com/en/w/v3080/">V3080</a> Mögliche Null-Dereferenzierung.  Betrachten Sie die Inspektion von 'controlPoint'.  Scene.cs 176 </li></ul><br>  Ich schlage vor, diese Fehler nach dem in den sicheren Versionen verwendeten Muster zu beheben, dh durch Hinzufügen einer <i>Nullable &lt;Struct&gt; .HasValue-</i> Prüfung in der <i>PointToClient-</i> Methode: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Point </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PointToClient</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IVisual visual, PixelPoint point</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rootPoint = visual.VisualRoot.PointToClient(point); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rootPoint.HasValue) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> visual.VisualRoot.TranslatePoint(rootPoint, visual).Value; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ....; }</code> </pre> <br>  <b>PVS-Studio-Diagnosemeldung:</b> <a href="https://www.viva64.com/en/w/v3080/">V3080</a> Mögliche Null-Dereferenzierung des Methodenrückgabewerts.  Betrachten Sie Folgendes: TransformToVisual (...).  ViewportManager.cs 381 <br><br>  Dieser Fehler ist dem vorherigen sehr ähnlich: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEffectiveViewportChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TransformedBounds? bounds</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> transform = _owner.GetVisualRoot().TransformToVisual(_owner).Value; .... }</code> </pre> <br>  Dies ist der Code der <i>TransformToVisual-</i> Methode: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Matrix? TransformToVisual(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IVisual <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, IVisual to) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> common = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>.FindCommonVisualAncestor(to); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (common != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  Übrigens kann die <i>FindCommonVisualAncestor-</i> Methode tatsächlich <i>null</i> als Standardwert für Referenztypen zurückgeben: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IVisual </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindCommonVisualAncestor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IVisual visual, IVisual target</span></span></span><span class="hljs-function">)</span></span> { Contract.Requires&lt;ArgumentNullException&gt;(visual != <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ....FirstOrDefault(); }</code> </pre> <br>  Die <i>TransformToVisual-</i> Methode wird neunmal mit nur sieben Überprüfungen aufgerufen.  Der erste Aufruf mit unsicherer Dereferenzierung ist der obige und der zweite: <br><br>  <a href="https://www.viva64.com/en/w/v3080/">V3080</a> Mögliche Null-Dereferenzierung.  Betrachten Sie die Überprüfung von "Transformation".  MouseDevice.cs 80 <br><br>  <b>PVS-Studio Diagnosemeldung: <a href="https://www.viva64.com/en/w/v3022/">V3022</a></b> Ausdruck ist immer wahr.  Wahrscheinlich sollte hier der Operator '&amp;&amp;' verwendet werden.  NavigationDirection.cs 89 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsDirectional</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> NavigationDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> direction &gt; NavigationDirection.Previous || direction &lt;= NavigationDirection.PageDown; }</code> </pre> <br>  Diese Prüfung ist seltsam.  Die <i>NavigationDirection-</i> Enumeration enthält 9 Typen, wobei der <i>PageDown-</i> Typ der letzte ist.  Vielleicht war es nicht immer so, oder vielleicht ist dies ein Schutz gegen das Hinzufügen neuer Richtungsoptionen durch SUDDEN.  Meiner Meinung nach sollte die erste Überprüfung ausreichen.  Wie auch immer, überlassen wir dies den Autoren, um zu entscheiden. <br><br>  <b>PVS-Studio-Diagnosemeldung:</b> <a href="https://www.viva64.com/en/w/v3066/">V3066</a> Mögliche falsche Reihenfolge der an den Konstruktor 'SelectionChangedEventArgs' übergebenen Argumente: 'removedSelectedItems' und 'addedSelectedItems'.  DataGridSelectedItemsCollection.cs 338 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> SelectionChangedEventArgs </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSelectionChangedEventArgs</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SelectionChangedEventArgs (DataGrid.SelectionChangedEvent, removedSelectedItems, addedSelectedItems) { Source = OwningGrid }; }</code> </pre> <br>  Der Analysator warnt vor der falschen Reihenfolge der zweiten und dritten Argumente des Konstruktors.  Werfen wir einen Blick auf diesen Konstruktor: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelectionChangedEventArgs</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RoutedEvent routedEvent, IList addedItems, IList removedItems</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">routedEvent</span></span></span><span class="hljs-function">)</span></span> { AddedItems = addedItems; RemovedItems = removedItems; }</code> </pre> <br>  Es werden zwei Container vom Typ <i>IList</i> als Argumente verwendet, wodurch es sehr einfach ist, sie in der falschen Reihenfolge zu schreiben.  Ein Kommentar am Anfang der Klasse deutet darauf hin, dass dies ein Fehler im Code des Steuerelements ist, das von Microsoft ausgeliehen und für die Verwendung in Avalonia geändert wurde.  Aber ich würde immer noch darauf bestehen, die Argumentationsreihenfolge zu korrigieren, um zu vermeiden, dass ein Fehlerbericht darüber erstellt wird und Zeit damit verschwendet wird, nach einem Fehler in Ihrem eigenen Code zu suchen. <br><br>  Es gab drei weitere Fehler dieses Typs: <br><br>  <b>PVS-Studio-Diagnosemeldung:</b> <a href="https://www.viva64.com/en/w/v3066/">V3066</a> Mögliche falsche Reihenfolge der an den Konstruktor 'SelectionChangedEventArgs' übergebenen Argumente: 'entfernt' und 'hinzugefügt'.  AutoCompleteBox.cs 707 <br><br><pre> <code class="cs hljs">OnSelectionChanged(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SelectionChangedEventArgs(SelectionChangedEvent, removed, added));</code> </pre> <br>  Es ist derselbe Konstruktor <i>SelectionChangedEventArgs.</i> <br><br>  <b>PVS-Studio Diagnosemeldungen</b> <a href="https://www.viva64.com/en/w/v3066/">V3066</a> : <ul><li>  Mögliche falsche Reihenfolge der an den Konstruktor 'ItemsRepeaterElementIndexChangedEventArgs' übergebenen Argumente: 'oldIndex' und 'newIndex'.  ItemsRepeater.cs 532 </li><li>  Mögliche falsche Reihenfolge der an die 'Update'-Methode übergebenen Argumente:' oldIndex 'und' newIndex '.  ItemsRepeater.cs 536 </li></ul><br>  Zwei Warnungen bei einer Ereignisaufrufmethode. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnElementIndexChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IControl element, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newIndex</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ElementIndexChanged != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_elementIndexChangedArgs == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { _elementIndexChangedArgs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ItemsRepeaterElementIndexChangedEventArgs(element, oldIndex, newIndex); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _elementIndexChangedArgs.Update(element, oldIndex, newIndex); } ..... } }</code> </pre> <br>  Der Analysator hat festgestellt, dass die Argumente <i>oldIndex</i> und <i>newIndex</i> in beiden Methoden <i>ItemsRepeaterElementIndexChangedEventArgs</i> und <i>Update</i> in einer anderen Reihenfolge geschrieben sind: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ItemsRepeaterElementIndexChangedEventArgs</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> IControl element, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldIndex</span></span></span><span class="hljs-function">)</span></span> { Element = element; NewIndex = newIndex; OldIndex = oldIndex; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IControl element, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldIndex</span></span></span><span class="hljs-function">)</span></span> { Element = element; NewIndex = newIndex; OldIndex = oldIndex; }</code> </pre> <br>  Vielleicht wurde dieser Code von verschiedenen Programmierern geschrieben, von denen sich einer mehr für die Vergangenheit und der andere für die Zukunft interessierte :) <br><br>  Genau wie in der vorigen Ausgabe ist hier keine sofortige Korrektur erforderlich.  es muss noch festgestellt werden, ob dieser Code tatsächlich fehlerhaft ist. <br><br>  <b>PVS-Studio Diagnosemeldung:</b> <a href="https://www.viva64.com/en/w/v3004/">V3004</a> Die Anweisung 'then' entspricht der Anweisung 'else'.  DataGridSortDescription.cs 235 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> IOrderedEnumerable&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ThenBy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IOrderedEnumerable&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; seq</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_descending) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> seq.ThenByDescending(o =&gt; GetValue(o), InternalComparer); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> seq.ThenByDescending(o =&gt; GetValue(o), InternalComparer); } }</code> </pre> <br>  Dies ist eine ziemlich merkwürdige Implementierung der <i>ThenBy-</i> Methode.  Die <i>IEnumerable-</i> Schnittstelle, von der das <i>seq-</i> Argument geerbt wird, enthält die <i>ThenBy-</i> Methode, die anscheinend folgendermaßen verwendet werden sollte: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> IOrderedEnumerable&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ThenBy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IOrderedEnumerable&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; seq</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_descending) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> seq.ThenByDescending(o =&gt; GetValue(o), InternalComparer); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> seq.ThenBy(o =&gt; GetValue(o), InternalComparer); } }</code> </pre> <br>  <b>PVS-Studio Diagnosemeldung:</b> <a href="https://www.viva64.com/en/w/v3106/">V3106</a> Möglicher negativer Indexwert.  Der Wert von 'index' index könnte -1 erreichen.  Animator.cs 68 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InterpolationHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> animationTime, T neutralValue</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (kvCount &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (animationTime &lt;= <span class="hljs-number"><span class="hljs-number">0.0</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (animationTime &gt;= <span class="hljs-number"><span class="hljs-number">1.0</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = FindClosestBeforeKeyFrame(animationTime); firstKeyframe = _convertedKeyframes[index]; } .... } .... }</code> </pre> <br>  Der Analysator ist sich sicher, dass die <i>Indexvariable</i> den Wert -1 haben kann.  Dieser Variablen wird der von der <i>FindClosestBeforeKeyFrame-</i> Methode zurückgegebene Wert zugewiesen. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindClosestBeforeKeyFrame</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> time</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; _convertedKeyframes.Count; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_convertedKeyframes[i].Cue.CueValue &gt; time) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"Index time is out of keyframe time range."</span></span>); }</code> </pre> <br>  Wie Sie sehen, enthält die Schleife eine Bedingung, auf die eine return-Anweisung folgt, die den vorherigen Wert des Iterators zurückgibt.  Es ist schwierig zu überprüfen, ob diese Bedingung erfüllt ist, und ich kann nicht sicher sagen, welchen Wert <i>CueValue</i> haben wird, aber die Beschreibung legt nahe, dass es einen Wert von 0,0 bis 1,0 annimmt.  Wir können jedoch noch ein paar Worte zur <i>Zeit</i> sagen: Es handelt sich um die an die aufrufende Methode übergebene <i>animationTime-</i> Variable, die definitiv größer als null und kleiner als eins ist.  Andernfalls würde die Ausführung einem anderen Zweig folgen.  Wenn diese Methoden für Animationen verwendet werden, ähnelt diese Situation einem anständigen Heisenbug.  Ich würde empfehlen, den von <i>FindClosestBeforeKeyFrame zurückgegebenen</i> Wert zu <i>überprüfen,</i> wenn in diesem Fall eine spezielle Behandlung erforderlich ist, oder das erste Element aus der Schleife zu entfernen, wenn andere Bedingungen nicht erfüllt sind.  Ich weiß nicht, wie genau das alles funktionieren soll, also würde ich die zweite Lösung als Beispiel nehmen: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindClosestBeforeKeyFrame</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> time</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; _convertedKeyframes.Count; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_convertedKeyframes[i].Cue.CueValue &gt; time) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"Index time is out of keyframe time range."</span></span>); }</code> </pre> <br>  <b>PVS-Studio Diagnosemeldung:</b> <a href="https://www.viva64.com/en/w/v3117/">V3117</a> Konstruktorparameter 'phones' wird nicht verwendet.  Land.cs 25 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Country</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> region, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> population, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> area, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> density, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> coast, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">? migration, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">? infantMorality, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> gdp, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">? literacy, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">? phones, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">? birth, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">? death</span></span></span><span class="hljs-function">)</span></span> { Name = name; Region = region; Population = population; Area = area; PopulationDensity = density; CoastLine = coast; NetMigration = migration; InfantMortality = infantMorality; GDP = gdp; LiteracyPercent = literacy; BirthRate = birth; DeathRate = death; }</code> </pre> <br>  Dies ist ein gutes Beispiel dafür, wie statische Analysen besser sind als Codeüberprüfungen.  Der Konstruktor wird mit dreizehn Argumenten aufgerufen, von denen eines nicht verwendet wird.  Tatsächlich konnte Visual Studio es auch erkennen, jedoch nur mithilfe von Diagnosen der dritten Ebene (die häufig deaktiviert sind).  Wir haben es hier definitiv mit einem Fehler zu tun, da die Klasse auch dreizehn Eigenschaften enthält - eine pro Argument -, aber es gibt keine Zuweisung zur Variablen <i>Phones</i> .  Da das Problem offensichtlich ist, werde ich es nicht näher erläutern. <br><br>  <b>PVS-Studio Diagnosemeldung:</b> <a href="https://www.viva64.com/en/w/v3080/">V3080</a> Mögliche Null-Dereferenzierung.  Sehen Sie sich 'tabItem' an.  TabItemContainerGenerator.cs 22 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> IControl </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateContainer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> item</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tabItem = (TabItem)<span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.CreateContainer(item); tabItem.ParentTabControl = Owner; .... }</code> </pre> <br>  Der Analyzer betrachtet die Dereferenzierung des von der <i>CreateContainer-</i> Methode zurückgegebenen <i>Werts als</i> unsicher.  Werfen wir einen Blick auf diese Methode: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> IControl </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateContainer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> item</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> container = item <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> T; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (container != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> container; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } }</code> </pre> <br>  PVS-Studio kann eine Zuweisung von <i>Null</i> selbst durch eine Kette von fünfzig Methoden verfolgen, kann jedoch nicht sagen, ob die Ausführung jemals diesem Zweig folgen würde.  Ich könnte es auch nicht ... Die Aufrufe gehen zwischen überschriebenen und virtuellen Methoden verloren, daher würde ich einfach vorschlagen, einen zusätzlichen Scheck für den Fall zu schreiben: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> IControl </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateContainer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> item</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tabItem = (TabItem)<span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.CreateContainer(item); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(tabItem == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; tabItem.ParentTabControl = Owner; .... }</code> </pre> <br>  <b>PVS-Studio Diagnosemeldung:</b> <a href="https://www.viva64.com/en/w/v3142/">V3142</a> Nicht erreichbarer Code erkannt.  Möglicherweise liegt ein Fehler vor.  DevTools.xaml.cs 91 <br><br>  Es macht keinen Sinn, zu viel Code zu zitieren, um die Spannung aufrechtzuerhalten.  Ich sage es Ihnen gleich: Diese Warnung ist falsch positiv.  Der Analysator hat einen Aufruf der Methode festgestellt, der eine bedingungslose Ausnahme auslöst: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> obj</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XamlLoadException(<span class="hljs-string"><span class="hljs-string">$"No precompiled XAML found for </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{obj.GetType()}</span></span></span><span class="hljs-string">, make sure to specify x:Class and include your XAML file as AvaloniaResource"</span></span>); }</code> </pre> <br>  Fünfunddreißig (!) Warnungen über nicht erreichbaren Code nach den Aufrufen dieser Methode waren zu viel, um ignoriert zu werden, und ich fragte einen der Entwickler, was hier vor sich ging.  Er erzählte mir, dass sie eine Technik verwendeten, bei der Sie Aufrufe an eine Methode durch Aufrufe an andere Methoden ersetzen, indem Sie die <a href="https://www.mono-project.com/docs/">Mono.Cecil-</a> Bibliothek verwenden.  Mit dieser Bibliothek können Sie Anrufe direkt im IL-Code ersetzen. <br><br>  Unser Analyser unterstützt diese Bibliothek nicht, daher die große Menge an falschen Positiven.  Dies bedeutet, dass diese Diagnose deaktiviert werden sollte, wenn die Avalonia-Benutzeroberfläche überprüft wird.  Es fühlt sich etwas umständlich an, aber ich muss zugeben, dass ich es bin, der diese Diagnose erstellt hat ... Aber wie jedes andere Tool muss auch ein statischer Analysator etwas genauer eingestellt werden. <br><br>  Zum Beispiel arbeiten wir derzeit an einer Diagnose, die unsichere Typkonvertierungen erkennt.  Bei einem Spielprojekt, bei dem die Typprüfung auf der Seite der Engine durchgeführt wird, werden ungefähr tausend Fehlalarme ausgegeben. <br><br>  <b>PVS-Studio-Diagnosemeldung:</b> <a href="https://www.viva64.com/en/w/v3009/">V3009</a> Es ist merkwürdig, dass diese Methode immer den gleichen Wert von 'true' zurückgibt.  DataGridRows.cs 412 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ScrollSlotIntoView</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> slot, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scrolledHorizontally</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (DisplayData.FirstScrollingSlot &lt; slot &amp;&amp; DisplayData.LastScrollingSlot &gt; slot) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (DisplayData.FirstScrollingSlot == slot &amp;&amp; slot != <span class="hljs-number"><span class="hljs-number">-1</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } .... } .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Die Methode gibt die ganze Zeit <i>true zurück</i> .  Vielleicht hat sich sein Zweck geändert, seit es zum ersten Mal geschrieben wurde, aber es sieht eher nach einem Bug aus.  Nach dem Kommentar zu Beginn der Klasse zu urteilen, handelt es sich um eine weitere Kontrollklasse, die von Microsoft ausgeliehen wurde.  Wenn Sie mich fragen, ist <i>DataGrid</i> eines der am wenigsten stabilen Steuerelemente. <i>Daher</i> ist es möglicherweise keine gute Idee, den <i>Bildlauf</i> zu bestätigen, wenn die Bedingungen nicht erfüllt sind. <br><br><h2>  Fazit </h2><br>  Einige der oben beschriebenen Fehler wurden zusammen mit dem aus den WPF-Steuerelementen kopierten Code ausgeliehen, und die Autoren der Avalonia-Benutzeroberfläche haben nichts damit zu tun.  Für den Benutzer macht es jedoch keinen Unterschied: Eine nicht funktionierende oder fehlerhafte Benutzeroberfläche hinterlässt einen schlechten Eindruck von der Gesamtqualität des Programms. <br><br>  Ich erwähnte die Notwendigkeit der Feinabstimmung des Analysegeräts: False Positives sind aufgrund der Arbeitsweise der statischen Analysealgorithmen unvermeidlich.  Diejenigen, die mit dem <a href="https://en.wikipedia.org/wiki/Halting_problem">Problem</a> des <a href="https://en.wikipedia.org/wiki/Halting_problem">Anhaltens</a> vertraut sind <a href="https://en.wikipedia.org/wiki/Halting_problem">,</a> wissen, dass es mathematische Einschränkungen bei der Verarbeitung eines Codeteils mit einem anderen gibt.  In diesem Fall geht es jedoch darum, eine Diagnose von fast einhunderteinhalb zu deaktivieren.  Bei statischen Analysen besteht also kein Problem des Bedeutungsverlustes.  Außerdem könnte diese Diagnose auch Warnungen auslösen, die auf echte Bugs hinweisen, aber diese sind unter Tonnen von False Positives kaum zu bemerken. <br><br>  Ich muss die bemerkenswerte Qualität des Avalonia UI-Projekts erwähnen!  Ich hoffe die Entwickler werden es so halten.  Leider wächst die Anzahl der Fehler mit der Größe des Programms.  Eine kluge Feinabstimmung der CI \ CD-Systeme, unterstützt durch statische und dynamische Analysen, ist eine der Möglichkeiten, um Fehler in Schach zu halten.  Und wenn Sie die Entwicklung großer Projekte vereinfachen und weniger Zeit für das Debuggen aufwenden möchten, <a href="https://www.viva64.com/en/pvs-studio-download/">laden Sie</a> PVS-Studio <a href="https://www.viva64.com/en/pvs-studio-download/">herunter und probieren Sie es aus</a> ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481612/">https://habr.com/ru/post/de481612/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481598/index.html">Ein kleiner Beitrag zum Kampf gegen die Avalonia UI-Zoo-Plattformen</a></li>
<li><a href="../de481600/index.html">Bonsai Family Wiki Engine: 2019 Ergebnisse</a></li>
<li><a href="../de481604/index.html">Wie hart Tscheljabinsk Entwickler Spiele für Google Play und soziale Netzwerke machen</a></li>
<li><a href="../de481606/index.html">Statisches Abonnement unter Verwendung der Observer-Vorlage unter Verwendung von C ++ und des Cortex M4-Mikrocontrollers</a></li>
<li><a href="../de481610/index.html">PostgreSQL Antipatterns: Aktualisierung einer großen Tabelle unter Last</a></li>
<li><a href="../de481616/index.html">Geodätische Kuppel. Über das Gerät und meine Erfahrungen mit Berechnungen</a></li>
<li><a href="../de481618/index.html">MVP in Unity oder wie man das Leben vereinfacht</a></li>
<li><a href="../de481620/index.html">Juniper SRX und Cisco ASA: Nächste Serie</a></li>
<li><a href="../de481624/index.html">Schreiben einer Anwendung auf Flutter in Verbindung mit Redux</a></li>
<li><a href="../de481626/index.html">Komplexe Anzeigesammlungen in iOS: Probleme und Lösungen am Beispiel des VKontakte-Feeds</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>