<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ üë®üèΩ üìè Unser kleiner Beitrag zum Kampf der Avalonia-Benutzeroberfl√§che f√ºr weniger Plattformen üì´ üë©üèø‚Äçü§ù‚Äçüë©üèº üé¥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel ist eine √úbersicht √ºber die Fehler, die im Avalonia-UI-Projekt mit dem statischen Analyseger√§t PVS-Studio gefunden wurden. Avalonia UI ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unser kleiner Beitrag zum Kampf der Avalonia-Benutzeroberfl√§che f√ºr weniger Plattformen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/481612/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e34/9b1/06a/e349b106a7c1d3ea775353520b20cd91.png" alt="Abbildung 2"></div><br>  Dieser Artikel ist eine √úbersicht √ºber die Fehler, die im Avalonia-UI-Projekt mit dem statischen Analyseger√§t PVS-Studio gefunden wurden.  Avalonia UI ist ein plattform√ºbergreifendes Open-Source-XAML-basiertes UI-Framework.  Dies ist eines der technologisch bedeutendsten Projekte in der Geschichte von .NET, da Entwickler plattform√ºbergreifende Schnittstellen auf der Basis des WPF-Systems erstellen k√∂nnen.  Wir hoffen, dass die Autoren des Projekts diesen Artikel hilfreich finden, um einige der Fehler zu beheben und √ºberzeugend genug sind, um statische Analysen in ihren Entwicklungsprozess einzubeziehen. <br><a name="habracut"></a><br><h2>  √úber Avalonia UI </h2><br>  Mit Avalonia UI (fr√ºher als Perspex bekannt) k√∂nnen Entwickler Benutzeroberfl√§chen erstellen, die unter Windows, Linux und MacOS ausgef√ºhrt werden k√∂nnen.  Als experimentelles Feature bietet es auch Unterst√ºtzung f√ºr Android und iOS.  Die Avalonia-Benutzeroberfl√§che ist kein Wrapper f√ºr andere Wrapper wie Xamarin Forms, der Xamarin-Wrapper umschlie√üt, sondern greift direkt auf die native API zu.  Beim Anschauen eines der Demo-Videos war ich erstaunt, dass Sie ein Steuerelement auf der Debian-Konsole ausgeben k√∂nnen.  Dank der Verwendung der XAML-Auszeichnungssprache bietet die Avalonia-Benutzeroberfl√§che im Vergleich zu anderen Benutzeroberfl√§chenkonstruktoren mehr Design- und Layoutfunktionen. <br><br>  Avalonia UI wird unter anderem in <a href="https://github.com/VitalElement/AvalonStudio">AvalonStudio</a> (einer plattform√ºbergreifenden IDE f√ºr die C # - und C / C ++ - Softwareentwicklung) und <a href="https://github.com/wieslawsoltes/Core2D">Core2D</a> (einem 2D-Diagrammeditor) verwendet.  <a href="https://wasabiwallet.io/">Wasabi Wallet</a> (eine Bitcoin-Brieftasche) ist ein Beispiel f√ºr kommerzielle Software, die die Avalonia-Benutzeroberfl√§che verwendet. <br><br>  Der Kampf gegen die Notwendigkeit, beim Erstellen einer plattform√ºbergreifenden Anwendung eine Reihe von Bibliotheken zu f√ºhren, ist √§u√üerst wichtig.  Wir wollten den Autoren der Avalonia-Benutzeroberfl√§che dabei helfen, also lud ich den Quellcode des Projekts herunter und √ºberpr√ºfte ihn mit unserem Analyser.  Ich hoffe, dass sie diesen Artikel sehen und die vorgeschlagenen Korrekturen vornehmen und sogar regelm√§√üig statische Analysen als Teil ihres Entwicklungsprozesses verwenden.  Dies ist dank der kostenlosen Lizenzierungsoption von PVS-Studio f√ºr Open-Source-Entwickler problemlos m√∂glich.  Die regelm√§√üige Verwendung statischer Analysen hilft, viele Probleme zu vermeiden und das Erkennen und Beheben von Fehlern viel billiger zu machen. <br><br><h2>  Analyseergebnisse </h2><br>  <b>PVS-Studio-Diagnosemeldung: <a href="https://www.viva64.com/en/w/v3001/">V3001</a></b> Links und rechts vom Operator '^' befinden sich identische Unterausdr√ºcke 'controlledFlags'.  WindowImpl.cs 975TwitterClientMessageHandler.cs 52 <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateWMStyles</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Action change</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> style = (WindowStyles)GetWindowLong(....); .... style = style | controlledFlags ^ controlledFlags; .... }</code> </pre> <br>  Beginnen wir mit unserer ersten C # -Diagnose, um eine gewisse Symbolik hinzuzuf√ºgen.  Der Analysator hat einen merkw√ºrdigen Ausdruck mit dem bitweisen Operator OR erkannt.  Lassen Sie mich dies mit Zahlen erkl√§ren: <br><br>  der Ausdruck <br><br><pre> <code class="cs hljs"><span class="hljs-number"><span class="hljs-number">1100</span></span> <span class="hljs-number"><span class="hljs-number">0011</span></span> | <span class="hljs-number"><span class="hljs-number">1111</span></span> <span class="hljs-number"><span class="hljs-number">0000</span></span> ^ <span class="hljs-number"><span class="hljs-number">1111</span></span> <span class="hljs-number"><span class="hljs-number">0000</span></span></code> </pre> <br>  ist √§quivalent zu <br><br><pre> <code class="cs hljs"><span class="hljs-number"><span class="hljs-number">1100</span></span> <span class="hljs-number"><span class="hljs-number">0011</span></span> | <span class="hljs-number"><span class="hljs-number">0000</span></span> <span class="hljs-number"><span class="hljs-number">0000</span></span></code> </pre> <br>  Die Priorit√§t des exklusiven ODER ("^") ist h√∂her als die des bitweisen ODER ("|").  Der Programmierer hatte diese Reihenfolge wahrscheinlich nicht vorgesehen.  Der Code kann durch Einschlie√üen des ersten Ausdrucks in Klammern festgelegt werden: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateWMStyles</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Action change</span></span></span><span class="hljs-function">)</span></span> { .... style = (style | controlledFlags) ^ controlledFlags; .... }</code> </pre> <br>  Was die n√§chsten beiden Warnungen angeht, muss ich zugeben: Dies sind falsch positive Ergebnisse.  Sie sehen, die Entwickler verwenden die √∂ffentliche API der <i>TransformToVisual-</i> Methode.  In diesem Fall ist <i>VisualRoot</i> immer ein √ºbergeordnetes Element f√ºr <i>Visual</i> .  Das habe ich bei der Pr√ºfung der Warnung nicht verstanden.  Erst nachdem ich den Artikel fertiggestellt hatte, erz√§hlte mir einer der Autoren des Projekts davon.  Daher zielen die unten vorgeschlagenen Korrekturen darauf ab, den Code vor m√∂glichen √Ñnderungen zu sch√ºtzen, die diese Logik verletzen, und nicht auf einen tats√§chlichen Absturz. <br><br>  <b>PVS-Studio-Diagnosemeldung: <a href="https://www.viva64.com/en/w/v3080/">V3080</a></b> M√∂gliche Null-Dereferenzierung des Methodenr√ºckgabewerts.  Betrachten Sie Folgendes: TranslatePoint (...).  VisualExtensions.cs 23 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Point </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PointToClient</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IVisual visual, PixelPoint point</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rootPoint = visual.VisualRoot.PointToClient(point); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> visual.VisualRoot.TranslatePoint(rootPoint, visual).Value; }</code> </pre> <br>  Diese Methode ist klein.  Der Analysator ist der Ansicht, dass die Dereferenzierung des durch den Aufruf von <i>TranslatePoint zur√ºckgegebenen</i> Werts unsicher ist.  Werfen wir einen Blick auf diese Methode: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Point? TranslatePoint(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IVisual visual, Point point, IVisual relativeTo) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> transform = visual.TransformToVisual(relativeTo); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (transform.HasValue) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> point.Transform(transform.Value); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  In der Tat k√∂nnte es <i>null zur√ºckgeben</i> . <br><br>  Diese Methode wird sechsmal aufgerufen: dreimal mit einer √úberpr√ºfung des zur√ºckgegebenen Werts und dreimal ohne √úberpr√ºfung, wodurch die Warnung vor einer m√∂glichen Dereferenzierung ausgel√∂st wird.  Das erste ist das obige und hier sind die beiden anderen: <br><br><ul><li>  <a href="https://www.viva64.com/en/w/v3080/">V3080</a> M√∂gliche Null-Dereferenzierung.  Sehen Sie sich 'p' an.  VisualExtensions.cs 35 </li><li>  <a href="https://www.viva64.com/en/w/v3080/">V3080</a> M√∂gliche Null-Dereferenzierung.  Betrachten Sie die Inspektion von 'controlPoint'.  Scene.cs 176 </li></ul><br>  Ich schlage vor, diese Fehler nach dem in den sicheren Versionen verwendeten Muster zu beheben, dh durch Hinzuf√ºgen einer <i>Nullable &lt;Struct&gt; .HasValue-</i> Pr√ºfung in der <i>PointToClient-</i> Methode: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Point </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PointToClient</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IVisual visual, PixelPoint point</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rootPoint = visual.VisualRoot.PointToClient(point); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rootPoint.HasValue) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> visual.VisualRoot.TranslatePoint(rootPoint, visual).Value; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ....; }</code> </pre> <br>  <b>PVS-Studio-Diagnosemeldung:</b> <a href="https://www.viva64.com/en/w/v3080/">V3080</a> M√∂gliche Null-Dereferenzierung des Methodenr√ºckgabewerts.  Betrachten Sie Folgendes: TransformToVisual (...).  ViewportManager.cs 381 <br><br>  Dieser Fehler ist dem vorherigen sehr √§hnlich: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEffectiveViewportChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TransformedBounds? bounds</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> transform = _owner.GetVisualRoot().TransformToVisual(_owner).Value; .... }</code> </pre> <br>  Dies ist der Code der <i>TransformToVisual-</i> Methode: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Matrix? TransformToVisual(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IVisual <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, IVisual to) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> common = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>.FindCommonVisualAncestor(to); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (common != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  √úbrigens kann die <i>FindCommonVisualAncestor-</i> Methode tats√§chlich <i>null</i> als Standardwert f√ºr Referenztypen zur√ºckgeben: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IVisual </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindCommonVisualAncestor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IVisual visual, IVisual target</span></span></span><span class="hljs-function">)</span></span> { Contract.Requires&lt;ArgumentNullException&gt;(visual != <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ....FirstOrDefault(); }</code> </pre> <br>  Die <i>TransformToVisual-</i> Methode wird neunmal mit nur sieben √úberpr√ºfungen aufgerufen.  Der erste Aufruf mit unsicherer Dereferenzierung ist der obige und der zweite: <br><br>  <a href="https://www.viva64.com/en/w/v3080/">V3080</a> M√∂gliche Null-Dereferenzierung.  Betrachten Sie die √úberpr√ºfung von "Transformation".  MouseDevice.cs 80 <br><br>  <b>PVS-Studio Diagnosemeldung: <a href="https://www.viva64.com/en/w/v3022/">V3022</a></b> Ausdruck ist immer wahr.  Wahrscheinlich sollte hier der Operator '&amp;&amp;' verwendet werden.  NavigationDirection.cs 89 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsDirectional</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> NavigationDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> direction &gt; NavigationDirection.Previous || direction &lt;= NavigationDirection.PageDown; }</code> </pre> <br>  Diese Pr√ºfung ist seltsam.  Die <i>NavigationDirection-</i> Enumeration enth√§lt 9 Typen, wobei der <i>PageDown-</i> Typ der letzte ist.  Vielleicht war es nicht immer so, oder vielleicht ist dies ein Schutz gegen das Hinzuf√ºgen neuer Richtungsoptionen durch SUDDEN.  Meiner Meinung nach sollte die erste √úberpr√ºfung ausreichen.  Wie auch immer, √ºberlassen wir dies den Autoren, um zu entscheiden. <br><br>  <b>PVS-Studio-Diagnosemeldung:</b> <a href="https://www.viva64.com/en/w/v3066/">V3066</a> M√∂gliche falsche Reihenfolge der an den Konstruktor 'SelectionChangedEventArgs' √ºbergebenen Argumente: 'removedSelectedItems' und 'addedSelectedItems'.  DataGridSelectedItemsCollection.cs 338 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> SelectionChangedEventArgs </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSelectionChangedEventArgs</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SelectionChangedEventArgs (DataGrid.SelectionChangedEvent, removedSelectedItems, addedSelectedItems) { Source = OwningGrid }; }</code> </pre> <br>  Der Analysator warnt vor der falschen Reihenfolge der zweiten und dritten Argumente des Konstruktors.  Werfen wir einen Blick auf diesen Konstruktor: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelectionChangedEventArgs</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RoutedEvent routedEvent, IList addedItems, IList removedItems</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">routedEvent</span></span></span><span class="hljs-function">)</span></span> { AddedItems = addedItems; RemovedItems = removedItems; }</code> </pre> <br>  Es werden zwei Container vom Typ <i>IList</i> als Argumente verwendet, wodurch es sehr einfach ist, sie in der falschen Reihenfolge zu schreiben.  Ein Kommentar am Anfang der Klasse deutet darauf hin, dass dies ein Fehler im Code des Steuerelements ist, das von Microsoft ausgeliehen und f√ºr die Verwendung in Avalonia ge√§ndert wurde.  Aber ich w√ºrde immer noch darauf bestehen, die Argumentationsreihenfolge zu korrigieren, um zu vermeiden, dass ein Fehlerbericht dar√ºber erstellt wird und Zeit damit verschwendet wird, nach einem Fehler in Ihrem eigenen Code zu suchen. <br><br>  Es gab drei weitere Fehler dieses Typs: <br><br>  <b>PVS-Studio-Diagnosemeldung:</b> <a href="https://www.viva64.com/en/w/v3066/">V3066</a> M√∂gliche falsche Reihenfolge der an den Konstruktor 'SelectionChangedEventArgs' √ºbergebenen Argumente: 'entfernt' und 'hinzugef√ºgt'.  AutoCompleteBox.cs 707 <br><br><pre> <code class="cs hljs">OnSelectionChanged(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SelectionChangedEventArgs(SelectionChangedEvent, removed, added));</code> </pre> <br>  Es ist derselbe Konstruktor <i>SelectionChangedEventArgs.</i> <br><br>  <b>PVS-Studio Diagnosemeldungen</b> <a href="https://www.viva64.com/en/w/v3066/">V3066</a> : <ul><li>  M√∂gliche falsche Reihenfolge der an den Konstruktor 'ItemsRepeaterElementIndexChangedEventArgs' √ºbergebenen Argumente: 'oldIndex' und 'newIndex'.  ItemsRepeater.cs 532 </li><li>  M√∂gliche falsche Reihenfolge der an die 'Update'-Methode √ºbergebenen Argumente:' oldIndex 'und' newIndex '.  ItemsRepeater.cs 536 </li></ul><br>  Zwei Warnungen bei einer Ereignisaufrufmethode. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnElementIndexChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IControl element, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newIndex</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ElementIndexChanged != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_elementIndexChangedArgs == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { _elementIndexChangedArgs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ItemsRepeaterElementIndexChangedEventArgs(element, oldIndex, newIndex); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _elementIndexChangedArgs.Update(element, oldIndex, newIndex); } ..... } }</code> </pre> <br>  Der Analysator hat festgestellt, dass die Argumente <i>oldIndex</i> und <i>newIndex</i> in beiden Methoden <i>ItemsRepeaterElementIndexChangedEventArgs</i> und <i>Update</i> in einer anderen Reihenfolge geschrieben sind: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ItemsRepeaterElementIndexChangedEventArgs</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> IControl element, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldIndex</span></span></span><span class="hljs-function">)</span></span> { Element = element; NewIndex = newIndex; OldIndex = oldIndex; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IControl element, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldIndex</span></span></span><span class="hljs-function">)</span></span> { Element = element; NewIndex = newIndex; OldIndex = oldIndex; }</code> </pre> <br>  Vielleicht wurde dieser Code von verschiedenen Programmierern geschrieben, von denen sich einer mehr f√ºr die Vergangenheit und der andere f√ºr die Zukunft interessierte :) <br><br>  Genau wie in der vorigen Ausgabe ist hier keine sofortige Korrektur erforderlich.  es muss noch festgestellt werden, ob dieser Code tats√§chlich fehlerhaft ist. <br><br>  <b>PVS-Studio Diagnosemeldung:</b> <a href="https://www.viva64.com/en/w/v3004/">V3004</a> Die Anweisung 'then' entspricht der Anweisung 'else'.  DataGridSortDescription.cs 235 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> IOrderedEnumerable&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ThenBy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IOrderedEnumerable&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; seq</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_descending) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> seq.ThenByDescending(o =&gt; GetValue(o), InternalComparer); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> seq.ThenByDescending(o =&gt; GetValue(o), InternalComparer); } }</code> </pre> <br>  Dies ist eine ziemlich merkw√ºrdige Implementierung der <i>ThenBy-</i> Methode.  Die <i>IEnumerable-</i> Schnittstelle, von der das <i>seq-</i> Argument geerbt wird, enth√§lt die <i>ThenBy-</i> Methode, die anscheinend folgenderma√üen verwendet werden sollte: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> IOrderedEnumerable&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ThenBy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IOrderedEnumerable&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; seq</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_descending) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> seq.ThenByDescending(o =&gt; GetValue(o), InternalComparer); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> seq.ThenBy(o =&gt; GetValue(o), InternalComparer); } }</code> </pre> <br>  <b>PVS-Studio Diagnosemeldung:</b> <a href="https://www.viva64.com/en/w/v3106/">V3106</a> M√∂glicher negativer Indexwert.  Der Wert von 'index' index k√∂nnte -1 erreichen.  Animator.cs 68 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InterpolationHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> animationTime, T neutralValue</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (kvCount &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (animationTime &lt;= <span class="hljs-number"><span class="hljs-number">0.0</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (animationTime &gt;= <span class="hljs-number"><span class="hljs-number">1.0</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = FindClosestBeforeKeyFrame(animationTime); firstKeyframe = _convertedKeyframes[index]; } .... } .... }</code> </pre> <br>  Der Analysator ist sich sicher, dass die <i>Indexvariable</i> den Wert -1 haben kann.  Dieser Variablen wird der von der <i>FindClosestBeforeKeyFrame-</i> Methode zur√ºckgegebene Wert zugewiesen. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindClosestBeforeKeyFrame</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> time</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; _convertedKeyframes.Count; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_convertedKeyframes[i].Cue.CueValue &gt; time) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"Index time is out of keyframe time range."</span></span>); }</code> </pre> <br>  Wie Sie sehen, enth√§lt die Schleife eine Bedingung, auf die eine return-Anweisung folgt, die den vorherigen Wert des Iterators zur√ºckgibt.  Es ist schwierig zu √ºberpr√ºfen, ob diese Bedingung erf√ºllt ist, und ich kann nicht sicher sagen, welchen Wert <i>CueValue</i> haben wird, aber die Beschreibung legt nahe, dass es einen Wert von 0,0 bis 1,0 annimmt.  Wir k√∂nnen jedoch noch ein paar Worte zur <i>Zeit</i> sagen: Es handelt sich um die an die aufrufende Methode √ºbergebene <i>animationTime-</i> Variable, die definitiv gr√∂√üer als null und kleiner als eins ist.  Andernfalls w√ºrde die Ausf√ºhrung einem anderen Zweig folgen.  Wenn diese Methoden f√ºr Animationen verwendet werden, √§hnelt diese Situation einem anst√§ndigen Heisenbug.  Ich w√ºrde empfehlen, den von <i>FindClosestBeforeKeyFrame zur√ºckgegebenen</i> Wert zu <i>√ºberpr√ºfen,</i> wenn in diesem Fall eine spezielle Behandlung erforderlich ist, oder das erste Element aus der Schleife zu entfernen, wenn andere Bedingungen nicht erf√ºllt sind.  Ich wei√ü nicht, wie genau das alles funktionieren soll, also w√ºrde ich die zweite L√∂sung als Beispiel nehmen: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindClosestBeforeKeyFrame</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> time</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; _convertedKeyframes.Count; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_convertedKeyframes[i].Cue.CueValue &gt; time) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"Index time is out of keyframe time range."</span></span>); }</code> </pre> <br>  <b>PVS-Studio Diagnosemeldung:</b> <a href="https://www.viva64.com/en/w/v3117/">V3117</a> Konstruktorparameter 'phones' wird nicht verwendet.  Land.cs 25 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Country</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> region, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> population, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> area, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> density, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> coast, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">? migration, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">? infantMorality, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> gdp, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">? literacy, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">? phones, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">? birth, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">? death</span></span></span><span class="hljs-function">)</span></span> { Name = name; Region = region; Population = population; Area = area; PopulationDensity = density; CoastLine = coast; NetMigration = migration; InfantMortality = infantMorality; GDP = gdp; LiteracyPercent = literacy; BirthRate = birth; DeathRate = death; }</code> </pre> <br>  Dies ist ein gutes Beispiel daf√ºr, wie statische Analysen besser sind als Code√ºberpr√ºfungen.  Der Konstruktor wird mit dreizehn Argumenten aufgerufen, von denen eines nicht verwendet wird.  Tats√§chlich konnte Visual Studio es auch erkennen, jedoch nur mithilfe von Diagnosen der dritten Ebene (die h√§ufig deaktiviert sind).  Wir haben es hier definitiv mit einem Fehler zu tun, da die Klasse auch dreizehn Eigenschaften enth√§lt - eine pro Argument -, aber es gibt keine Zuweisung zur Variablen <i>Phones</i> .  Da das Problem offensichtlich ist, werde ich es nicht n√§her erl√§utern. <br><br>  <b>PVS-Studio Diagnosemeldung:</b> <a href="https://www.viva64.com/en/w/v3080/">V3080</a> M√∂gliche Null-Dereferenzierung.  Sehen Sie sich 'tabItem' an.  TabItemContainerGenerator.cs 22 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> IControl </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateContainer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> item</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tabItem = (TabItem)<span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.CreateContainer(item); tabItem.ParentTabControl = Owner; .... }</code> </pre> <br>  Der Analyzer betrachtet die Dereferenzierung des von der <i>CreateContainer-</i> Methode zur√ºckgegebenen <i>Werts als</i> unsicher.  Werfen wir einen Blick auf diese Methode: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> IControl </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateContainer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> item</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> container = item <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> T; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (container != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> container; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } }</code> </pre> <br>  PVS-Studio kann eine Zuweisung von <i>Null</i> selbst durch eine Kette von f√ºnfzig Methoden verfolgen, kann jedoch nicht sagen, ob die Ausf√ºhrung jemals diesem Zweig folgen w√ºrde.  Ich k√∂nnte es auch nicht ... Die Aufrufe gehen zwischen √ºberschriebenen und virtuellen Methoden verloren, daher w√ºrde ich einfach vorschlagen, einen zus√§tzlichen Scheck f√ºr den Fall zu schreiben: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> IControl </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateContainer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> item</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tabItem = (TabItem)<span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.CreateContainer(item); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(tabItem == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; tabItem.ParentTabControl = Owner; .... }</code> </pre> <br>  <b>PVS-Studio Diagnosemeldung:</b> <a href="https://www.viva64.com/en/w/v3142/">V3142</a> Nicht erreichbarer Code erkannt.  M√∂glicherweise liegt ein Fehler vor.  DevTools.xaml.cs 91 <br><br>  Es macht keinen Sinn, zu viel Code zu zitieren, um die Spannung aufrechtzuerhalten.  Ich sage es Ihnen gleich: Diese Warnung ist falsch positiv.  Der Analysator hat einen Aufruf der Methode festgestellt, der eine bedingungslose Ausnahme ausl√∂st: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> obj</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XamlLoadException(<span class="hljs-string"><span class="hljs-string">$"No precompiled XAML found for </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{obj.GetType()}</span></span></span><span class="hljs-string">, make sure to specify x:Class and include your XAML file as AvaloniaResource"</span></span>); }</code> </pre> <br>  F√ºnfunddrei√üig (!) Warnungen √ºber nicht erreichbaren Code nach den Aufrufen dieser Methode waren zu viel, um ignoriert zu werden, und ich fragte einen der Entwickler, was hier vor sich ging.  Er erz√§hlte mir, dass sie eine Technik verwendeten, bei der Sie Aufrufe an eine Methode durch Aufrufe an andere Methoden ersetzen, indem Sie die <a href="https://www.mono-project.com/docs/">Mono.Cecil-</a> Bibliothek verwenden.  Mit dieser Bibliothek k√∂nnen Sie Anrufe direkt im IL-Code ersetzen. <br><br>  Unser Analyser unterst√ºtzt diese Bibliothek nicht, daher die gro√üe Menge an falschen Positiven.  Dies bedeutet, dass diese Diagnose deaktiviert werden sollte, wenn die Avalonia-Benutzeroberfl√§che √ºberpr√ºft wird.  Es f√ºhlt sich etwas umst√§ndlich an, aber ich muss zugeben, dass ich es bin, der diese Diagnose erstellt hat ... Aber wie jedes andere Tool muss auch ein statischer Analysator etwas genauer eingestellt werden. <br><br>  Zum Beispiel arbeiten wir derzeit an einer Diagnose, die unsichere Typkonvertierungen erkennt.  Bei einem Spielprojekt, bei dem die Typpr√ºfung auf der Seite der Engine durchgef√ºhrt wird, werden ungef√§hr tausend Fehlalarme ausgegeben. <br><br>  <b>PVS-Studio-Diagnosemeldung:</b> <a href="https://www.viva64.com/en/w/v3009/">V3009</a> Es ist merkw√ºrdig, dass diese Methode immer den gleichen Wert von 'true' zur√ºckgibt.  DataGridRows.cs 412 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ScrollSlotIntoView</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> slot, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scrolledHorizontally</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (DisplayData.FirstScrollingSlot &lt; slot &amp;&amp; DisplayData.LastScrollingSlot &gt; slot) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (DisplayData.FirstScrollingSlot == slot &amp;&amp; slot != <span class="hljs-number"><span class="hljs-number">-1</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } .... } .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Die Methode gibt die ganze Zeit <i>true zur√ºck</i> .  Vielleicht hat sich sein Zweck ge√§ndert, seit es zum ersten Mal geschrieben wurde, aber es sieht eher nach einem Bug aus.  Nach dem Kommentar zu Beginn der Klasse zu urteilen, handelt es sich um eine weitere Kontrollklasse, die von Microsoft ausgeliehen wurde.  Wenn Sie mich fragen, ist <i>DataGrid</i> eines der am wenigsten stabilen Steuerelemente. <i>Daher</i> ist es m√∂glicherweise keine gute Idee, den <i>Bildlauf</i> zu best√§tigen, wenn die Bedingungen nicht erf√ºllt sind. <br><br><h2>  Fazit </h2><br>  Einige der oben beschriebenen Fehler wurden zusammen mit dem aus den WPF-Steuerelementen kopierten Code ausgeliehen, und die Autoren der Avalonia-Benutzeroberfl√§che haben nichts damit zu tun.  F√ºr den Benutzer macht es jedoch keinen Unterschied: Eine nicht funktionierende oder fehlerhafte Benutzeroberfl√§che hinterl√§sst einen schlechten Eindruck von der Gesamtqualit√§t des Programms. <br><br>  Ich erw√§hnte die Notwendigkeit der Feinabstimmung des Analyseger√§ts: False Positives sind aufgrund der Arbeitsweise der statischen Analysealgorithmen unvermeidlich.  Diejenigen, die mit dem <a href="https://en.wikipedia.org/wiki/Halting_problem">Problem</a> des <a href="https://en.wikipedia.org/wiki/Halting_problem">Anhaltens</a> vertraut sind <a href="https://en.wikipedia.org/wiki/Halting_problem">,</a> wissen, dass es mathematische Einschr√§nkungen bei der Verarbeitung eines Codeteils mit einem anderen gibt.  In diesem Fall geht es jedoch darum, eine Diagnose von fast einhunderteinhalb zu deaktivieren.  Bei statischen Analysen besteht also kein Problem des Bedeutungsverlustes.  Au√üerdem k√∂nnte diese Diagnose auch Warnungen ausl√∂sen, die auf echte Bugs hinweisen, aber diese sind unter Tonnen von False Positives kaum zu bemerken. <br><br>  Ich muss die bemerkenswerte Qualit√§t des Avalonia UI-Projekts erw√§hnen!  Ich hoffe die Entwickler werden es so halten.  Leider w√§chst die Anzahl der Fehler mit der Gr√∂√üe des Programms.  Eine kluge Feinabstimmung der CI \ CD-Systeme, unterst√ºtzt durch statische und dynamische Analysen, ist eine der M√∂glichkeiten, um Fehler in Schach zu halten.  Und wenn Sie die Entwicklung gro√üer Projekte vereinfachen und weniger Zeit f√ºr das Debuggen aufwenden m√∂chten, <a href="https://www.viva64.com/en/pvs-studio-download/">laden Sie</a> PVS-Studio <a href="https://www.viva64.com/en/pvs-studio-download/">herunter und probieren Sie es aus</a> ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481612/">https://habr.com/ru/post/de481612/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481598/index.html">Ein kleiner Beitrag zum Kampf gegen die Avalonia UI-Zoo-Plattformen</a></li>
<li><a href="../de481600/index.html">Bonsai Family Wiki Engine: 2019 Ergebnisse</a></li>
<li><a href="../de481604/index.html">Wie hart Tscheljabinsk Entwickler Spiele f√ºr Google Play und soziale Netzwerke machen</a></li>
<li><a href="../de481606/index.html">Statisches Abonnement unter Verwendung der Observer-Vorlage unter Verwendung von C ++ und des Cortex M4-Mikrocontrollers</a></li>
<li><a href="../de481610/index.html">PostgreSQL Antipatterns: Aktualisierung einer gro√üen Tabelle unter Last</a></li>
<li><a href="../de481616/index.html">Geod√§tische Kuppel. √úber das Ger√§t und meine Erfahrungen mit Berechnungen</a></li>
<li><a href="../de481618/index.html">MVP in Unity oder wie man das Leben vereinfacht</a></li>
<li><a href="../de481620/index.html">Juniper SRX und Cisco ASA: N√§chste Serie</a></li>
<li><a href="../de481624/index.html">Schreiben einer Anwendung auf Flutter in Verbindung mit Redux</a></li>
<li><a href="../de481626/index.html">Komplexe Anzeigesammlungen in iOS: Probleme und L√∂sungen am Beispiel des VKontakte-Feeds</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>