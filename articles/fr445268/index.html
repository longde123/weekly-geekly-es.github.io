<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😋 👇🏻 🥓 Détails GraphQL: quoi, comment et pourquoi 👨‍🏫 🐣 🧢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="GraphQL est maintenant, sans exagération, c'est le dernier coup d'oeil du mode informatique. Et si vous ne savez pas encore de quel type de technologi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Détails GraphQL: quoi, comment et pourquoi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/445268/">  GraphQL est maintenant, sans exagération, c'est le dernier coup d'oeil du mode informatique.  Et si vous ne savez pas encore de quel type de technologie il s'agit, comment l'utiliser et pourquoi elle peut vous être utile, l'article que nous publions aujourd'hui est écrit pour vous.  Nous allons ici passer en revue les bases de GraphQL en utilisant un exemple d'implémentation d'un schéma de données pour l'API d'une entreprise de pop-corn.  Parlons en particulier des types de données, des requêtes et des mutations. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/c7/oq/a1/c7oqa1w2b00akzatd2womwb_daw.png"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Qu'est-ce que GraphQL?</font> </h2><br>  GraphQL est un langage de requête utilisé par les applications clientes pour travailler avec les données.  GraphQL est associé à un concept tel que «schéma» - c'est ce qui vous permet d'organiser la création, la lecture, la mise à jour et la suppression de données dans votre application (c'est-à-dire que nous avons quatre fonctions de base utilisées lorsque nous travaillons avec des entrepôts de données, qui sont généralement désignés par l'acronyme CRUD - créer, lire, mettre à jour, supprimer). <br><br>  Il a été dit plus haut que GraphQL est utilisé pour travailler avec des données dans «votre application», et non «dans votre base de données».  Le fait est que GraphQL est un système indépendant des sources de données, c'est-à-dire qu'il importe peu où il est organisé pour organiser son travail. <br><br>  Si vous regardez, sans rien savoir de GraphQL, sur le nom de cette technologie, il peut sembler que nous sommes confrontés à quelque chose de très compliqué et déroutant.  Le nom de la technologie a le mot «graphique».  Est-ce à dire que pour le maîtriser, il faut apprendre à travailler avec des bases de données graphiques?  Et le fait que le nom contienne «QL» (qui peut signifier «langage de requête», c'est-à-dire «langage de requête»), cela signifie-t-il que ceux qui veulent utiliser GraphQL devront apprendre un tout nouveau langage de programmation? <br><br>  Ces craintes ne sont pas entièrement justifiées.  Afin de vous rassurer - c'est la cruelle vérité sur cette technologie: il s'agit simplement d'embellir des requêtes <code>GET</code> ou <code>POST</code> .  Alors que GraphQL, en général, introduit de nouveaux concepts liés à l'organisation des données et à leur interaction, les mécanismes internes de cette technologie reposent sur les bonnes vieilles requêtes HTTP. <br><br><h2>  <font color="#3AC1EF">Repenser la technologie REST</font> </h2><br>  La flexibilité est ce qui distingue la technologie GraphQL de la technologie REST bien connue.  Lorsque vous utilisez REST, si tout est fait correctement, les noeuds finaux sont généralement créés en tenant compte des caractéristiques d'un certain type de données de ressource ou d'application. <br><br>  Par exemple, lors de l'exécution d'une demande <code>GET</code> vers le point de terminaison <code>/api/v1/flavors</code> il est prévu qu'il envoie une réponse qui ressemble à ceci: <br><br><pre> <code class="plaintext hljs">[ {  "id": 1,   "name": "The Lazy Person's Movie Theater",   "description": "That elusive flavor that you begrudgingly carted yourself to the theater for, now in the comfort of your own home, you slob!" }, {   "id": 2,   "name": "What's Wrong With You Caramel",   "description": "You're a crazy person that likes sweet popcorn. Congratulations." }, {   "id": 3,   "name": "Gnarly Chili Lime",   "description": "The kind of popcorn you make when you need a good smack in the face."} ]</code> </pre> <br>  Il n'y a rien de catastrophique dans cette réponse, mais réfléchissons à l'interface utilisateur, ou plutôt à la façon dont nous avons l'intention de consommer ces données. <br><br>  Si nous voulons afficher une simple liste dans l'interface qui ne contient que les noms des types de pop-corn disponibles (et rien d'autre), cette liste peut ressembler à celle illustrée ci-dessous. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a89/0fd/c56/a890fdc56389815233584327e76011c1.png"></div><br>  <i><font color="#999999">Liste des types de pop-corn</font></i> <br><br>  On peut voir que nous sommes ici dans une situation difficile.  Nous pouvons bien décider de ne pas utiliser le champ de <code>description</code> , mais allons-nous nous asseoir et prétendre que nous n'avons pas envoyé ce champ au client?  Que pouvons-nous faire d'autre?  Et quand, au bout de quelques mois, ils nous demanderont pourquoi l'application est si lente pour les utilisateurs, il suffit de laisser le gars et de ne plus rencontrer la direction de l'entreprise pour laquelle nous avons fait cette application. <br><br>  En fait, le fait que le serveur envoie des données inutiles en réponse à une demande client n'est pas entièrement de notre faute.  REST est un mécanisme d'acquisition de données qui peut être comparé à un restaurant dans lequel le serveur demande au visiteur: "Qu'est-ce que tu veux?" . <br><br>  Si nous mettons de côté les blagues, dans les applications réelles, cela peut conduire à des situations problématiques.  Par exemple, nous pouvons afficher diverses informations supplémentaires sur chaque type de pop-corn, telles que des informations sur les prix, des informations sur le fabricant ou des informations nutritionnelles («Popcorn végétalien!»).  Dans le même temps, les points de terminaison REST rigides rendent très difficile l'obtention de données spécifiques sur des types spécifiques de pop-corn, ce qui conduit à une charge déraisonnablement élevée sur les systèmes et au fait que les solutions qui en résultent sont loin de celles dont les développeurs pourraient être fiers. <br><br><h2>  <font color="#3AC1EF">Comment la technologie GraphQL améliore l'utilisation de la technologie REST</font> </h2><br>  Une analyse superficielle de la situation décrite ci-dessus peut sembler que nous ne sommes qu'un problème mineur.  "Quel est le problème avec l'envoi au client de données inutiles?"  Afin de comprendre dans quelle mesure les «données inutiles» peuvent être un gros problème, n'oubliez pas que GraphQL a été développé par Facebook.  Cette entreprise doit répondre à des millions de demandes par seconde. <br><br>  Qu'est-ce que cela signifie?  Et le fait qu'avec de tels volumes, chaque petite chose compte. <br><br>  GraphQL, si nous continuons l'analogie avec un restaurant, au lieu de «porter» au visiteur «ce qui est», apporte exactement ce que le visiteur commande. <br><br>  Nous pouvons obtenir une réponse de GraphQL qui se concentre sur le contexte dans lequel les données sont utilisées.  Dans ce cas, nous n'avons pas besoin d'ajouter des points d'accès «uniques» au système, d'effectuer de nombreuses demandes ou d'écrire des structures conditionnelles à plusieurs étages. <br><br><h2>  <font color="#3AC1EF">Comment fonctionne GraphQL?</font> </h2><br>  Comme nous l'avons déjà dit, GraphQL s'appuie sur de simples requêtes <code>GET</code> ou <code>POST</code> pour transmettre des données au client et les recevoir de lui.  Si nous considérons cette idée plus en détail, il s'avère qu'il existe deux types de requêtes dans GraphQL.  Le premier type comprend les demandes de lecture de données, qui dans la terminologie GraphQL sont simplement appelées requêtes et font référence à la lettre R (lecture, lecture) de l'acronyme CRUD.  Les requêtes du deuxième type sont des demandes de modification de données, appelées mutations dans GraphQL.  Ils concernent les boîtes d'essieux C, U et D de l'acronyme CRUD, c'est-à-dire qu'ils les utilisent pour créer, créer, mettre à jour et supprimer des enregistrements. <br><br>  Toutes ces requêtes et mutations sont envoyées à l'URL du serveur GraphQL, qui peut par exemple ressembler à <code>https://myapp.com/graphql</code> , sous forme de requêtes <code>GET</code> ou <code>POST</code> .  Nous en parlerons plus loin ci-dessous. <br><br><h2>  <font color="#3AC1EF">Requêtes GraphQL</font> </h2><br>  Les requêtes GraphQL sont des entités représentant une demande au serveur de recevoir certaines données.  Par exemple, nous avons une certaine interface utilisateur que nous voulons remplir de données.  Pour ces données, nous nous tournons vers le serveur, exécutant la demande.  Lorsque vous utilisez des API REST traditionnelles, notre demande prend la forme d'une demande GET.  Lorsque vous travaillez avec GraphQL, une nouvelle syntaxe de requête est utilisée: <br><br><pre> <code class="plaintext hljs">{ flavors {   name } }</code> </pre> <br>  Est-ce JSON?  Ou un objet JavaScript?  Ni l'un ni l'autre.  Comme nous l'avons déjà dit, au nom de la technologie GraphQL, les deux dernières lettres, QL, signifient «langage de requête», c'est-à-dire le langage de requête.  C'est, littéralement, un nouveau langage pour écrire des demandes de données.  Tout cela ressemble à une description de quelque chose de plutôt compliqué, mais en fait il n'y a rien de compliqué ici.  Analysons la requête ci-dessus: <br><br><pre> <code class="plaintext hljs">{ //    ,   . }</code> </pre> <br>  Toutes les demandes commencent par une «demande racine» et ce que vous devez obtenir lors de l'exécution de la demande s'appelle un champ.  Afin de vous éviter la confusion, il est préférable d'appeler ces entités «champs de requête dans le schéma».  Si un tel nom vous semble incompréhensible - attendez un peu - ci-dessous, nous parlerons davantage du schéma.  Ici, dans la requête racine, nous demandons le champ des <code>flavors</code> . <br><br><pre> <code class="plaintext hljs">{ flavors {   //  ,        flavor. } }</code> </pre> <br>  Lors de la demande d'un certain champ, nous devons également indiquer les champs imbriqués qui doivent être reçus pour chaque objet qui vient en réponse à la demande (même s'il est prévu qu'un seul objet viendra en réponse à la demande). <br><br><pre> <code class="plaintext hljs">{ flavors {   name } }</code> </pre> <br>  Quel sera le résultat?  Après avoir envoyé une telle demande au serveur GraphQL, nous obtiendrons une réponse nette et bien formée, comme la suivante: <br><br><pre> <code class="plaintext hljs">{ "data": {   "flavors": [     { "name": "The Lazy Person's Movie Theater" },     { "name": "What's Wrong With You Caramel" },     { "name": "Gnarly Chili Lime" }   ] } }</code> </pre> <br>  Veuillez noter qu'il n'y a rien de superflu.  Afin de le rendre plus clair, voici une autre requête qui est exécutée pour obtenir des données sur une autre page de l'application: <br><br><pre> <code class="plaintext hljs">{ flavors {   id   name   description } }</code> </pre> <br>  En réponse à cette demande, nous obtenons ce qui suit: <br><br><pre> <code class="plaintext hljs">{ "data": {   "flavors": [     { "id": 1, "name": "The Lazy Person's Movie Theater", description: "That elusive flavor that you begrudgingly carted yourself to the theater for, now in the comfort of your own home, you slob!" },     { "id": 2, "name": "What's Wrong With You Caramel", description: "You're a crazy person that likes sweet popcorn. Congratulations." },     { "id": 3, "name": "Gnarly Chili Lime", description: "A friend told me this would taste good. It didn't. It burned my kernels. I haven't had the heart to tell him." }   ] } }</code> </pre> <br>  Comme vous pouvez le voir, GraphQL est une technologie très puissante.  Nous nous tournons vers le même point de terminaison, et les réponses aux demandes correspondent exactement à ce qui est nécessaire pour remplir la page à partir de laquelle ces demandes sont exécutées. <br><br>  Si nous devons obtenir un seul objet de <code>flavor</code> , nous pouvons profiter du fait que GraphQL peut fonctionner avec des arguments: <br><br><pre> <code class="plaintext hljs">{ flavors(id: "1") {   id   name   description } }</code> </pre> <br>  Ici, nous définissons de manière rigide l'identifiant spécifique ( <code>id</code> ) de l'objet dans le code, les informations dont nous avons besoin, mais dans de tels cas, nous pouvons utiliser des identifiants dynamiques: <br><br><pre> <code class="plaintext hljs">query getFlavor($id: ID) { flavors(id: $id) {   id   name   description } }</code> </pre> <br>  Ici, dans la première ligne, nous donnons un nom à la demande (le nom est choisi arbitrairement, <code>getFlavor</code> peut être remplacé par quelque chose comme <code>pizza</code> , et la demande restera opérationnelle) et déclarons les variables que la demande attend.  Dans ce cas, on suppose que l'identifiant ( <code>id</code> ) de l' <code>ID</code> type scalaire sera transmis à la requête (nous parlerons des types ci-dessous). <br><br>  Peu importe si un <code>id</code> statique ou dynamique <code>id</code> utilisé lors de l'exécution d'une demande, voici à quoi ressemblera la réponse à une demande similaire: <br><br><pre> <code class="plaintext hljs">{ "data": {   "flavors": [     { "id": 1, "name": "The Lazy Person's Movie Theater", description: "That elusive flavor that you begrudgingly carted yourself to the theater for, now in the comfort of your own home, you slob!" }   ] } }</code> </pre> <br>  Comme vous pouvez le voir, tout est arrangé de manière très pratique.  Vous commencez probablement à penser à utiliser GraphQL dans votre propre projet.  Et, bien que ce dont nous avons déjà parlé soit magnifique, la beauté de GraphQL se manifeste vraiment là où il fonctionne avec des champs imbriqués.  Supposons que dans notre schéma, il existe un autre domaine appelé <code>nutrition</code> qui contient des informations sur la valeur nutritionnelle de différents types de pop-corn: <br><br><pre> <code class="plaintext hljs">{ flavors {   id   name   nutrition {     calories     fat     sodium   } } }</code> </pre> <br>  Il peut sembler que dans notre entrepôt de données, chaque objet de <code>flavor</code> contiendra un objet <code>nutrition</code> imbriqué.  Mais ce n'est pas tout à fait vrai.  À l'aide de GraphQL, vous pouvez combiner des appels à des sources de données indépendantes mais liées dans une seule requête, ce qui vous permet de recevoir des réponses qui offrent la commodité de travailler avec des données incorporées sans avoir besoin de dénormaliser la base de données: <br><br><pre> <code class="plaintext hljs">{ "data": {   "flavors": [     {       "id": 1,       "name": "The Lazy Person's Movie Theater",       "nutrition": {         "calories": 500,         "fat": 12,         "sodium": 1000       }     },     ...   ] } }</code> </pre> <br>  Cela peut augmenter considérablement la productivité du programmeur et la vitesse du système. <br><br>  Jusqu'à présent, nous avons parlé des demandes de lecture.  Qu'en est-il des demandes de mise à jour des données?  Les utiliser nous donne-t-il la même commodité? <br><br><h2>  <font color="#3AC1EF">Mutations GraphQL</font> </h2><br>  Tandis que les requêtes GraphQL chargent des données, les mutations sont responsables d'apporter des modifications aux données.  Les mutations peuvent être utilisées sous la forme du mécanisme de base RPC (Remote Procedure Call) pour résoudre diverses tâches, telles que l'envoi de données utilisateur à une API tierce. <br><br>  Lors de la description des mutations, une syntaxe similaire à celle utilisée lors de la génération des requêtes est utilisée: <br><br><pre> <code class="plaintext hljs">mutation updateFlavor($id: ID!, $name: String, $description: String) { updateFlavor(id: $id, name: $name, description: $description) {   id   name   description } }</code> </pre> <br>  Ici, nous déclarons la mutation <code>updateFlavor</code> , en spécifiant certaines variables - <code>id</code> , <code>name</code> et <code>description</code> .  En agissant selon le même schéma que celui utilisé pour décrire les requêtes, nous «établissons» des champs de variables (mutation racine) à l'aide du mot-clé <code>mutation</code> , suivis d'un nom décrivant la mutation et d'un ensemble de variables nécessaires pour former la demande de changement de données correspondante. <br><br>  Ces variables incluent ce que nous essayons de changer ou quelle mutation nous voulons provoquer.  Veuillez également noter qu'après la mutation, nous pouvons demander le retour de certains champs. <br><br>  Dans ce cas, nous devons obtenir, après avoir modifié l'enregistrement, les champs <code>id</code> , <code>name</code> et <code>description</code> .  Cela peut être utile lors du développement de quelque chose comme des interfaces optimistes, éliminant ainsi la nécessité de répondre à une demande de réception de données modifiées après les avoir modifiées. <br><br><h2>  <font color="#3AC1EF">Concevoir un schéma et le connecter à un serveur GraphQL</font> </h2><br>  Jusqu'à présent, nous avons parlé du fonctionnement de GraphQL sur le client et de la façon dont ils exécutent les requêtes.  Voyons maintenant comment répondre à ces demandes. <br><br><h3>  <font color="#3AC1EF">Server Serveur GraphQL</font> </h3><br>  Pour exécuter une requête GraphQL, vous avez besoin d'un serveur GraphQL auquel vous pouvez envoyer une telle requête.  Un serveur GraphQL est un serveur HTTP standard (si vous écrivez en JavaScript, il peut s'agir d'un serveur créé en utilisant Express ou Hapi), auquel un diagramme GraphQL est attaché. <br><br><pre> <code class="plaintext hljs">import express from 'express' import graphqlHTTP from 'express-graphql' import schema from './schema' const app = express() app.use('/graphql', graphqlHTTP({ schema: schema, graphiql: true })) app.listen(4000)</code> </pre> <br>  Par «rejoindre» un schéma, nous entendons un mécanisme qui transmet les demandes reçues du client via le schéma et y renvoie des réponses.  C'est comme un filtre à air à travers lequel l'air pénètre dans la pièce. <br><br>  Le processus de "filtrage" est associé aux requêtes ou mutations envoyées par le client au serveur.  Les requêtes et les mutations sont résolues à l'aide de fonctions liées aux champs définis dans la requête racine ou dans la mutation racine du schéma. <br><br>  Ce qui précède est un exemple d'infrastructure de serveur HTTP créé à l'aide de la bibliothèque JavaScript Express.  En utilisant la fonction <code>express-graphql</code> de Facebook, nous «attachons» le schéma (on suppose qu'il est décrit dans un fichier séparé) et exécutons le serveur sur le port 4000. Autrement dit, les clients, parlant de l'utilisation locale de ce serveur, pourront envoyer des requêtes via adresse <code>http://localhost:4000/graphql</code> . <br><br><h3>  <font color="#3AC1EF">▍ Types de données et résolveurs</font> </h3><br>  Afin d'assurer le fonctionnement du serveur GraphQL, vous devez préparer le schéma et le joindre à celui-ci. <br><br>  Rappelons que nous avons parlé de déclarer des champs dans une requête racine ou dans une mutation racine ci-dessus. <br><br><pre> <code class="plaintext hljs">import gql from 'graphql-tag' import mongodb from '/path/to/mongodb' //  -  . ,  `mongodb`     MongoDB. const schema = { typeDefs: gql`   type Nutrition {     flavorId: ID     calories: Int     fat: Int     sodium: Int   }   type Flavor {     id: ID     name: String     description: String     nutrition: Nutrition   }   type Query {     flavors(id: ID): [Flavor]   }   type Mutation {     updateFlavor(id: ID!, name: String, description: String): Flavor   } `, resolvers: {   Query: {     flavors: (parent, args) =&gt; {       // ,  args  ,  { id: '1' }       return mongodb.collection('flavors').find(args).toArray()     },   },   Mutation: {     updateFlavor: (parent, args) =&gt; {       // ,  args    { id: '1', name: 'Movie Theater Clone', description: 'Bring the movie theater taste home!' }       //  .       mongodb.collection('flavors').update(args)       //  flavor  .       return mongodb.collection('flavors').findOne(args.id)     },   },   Flavor: {     nutrition: (parent) =&gt; {       return mongodb.collection('nutrition').findOne({         flavorId: parent.id,       })     }   }, }, } export default schema</code> </pre> <br>  La définition des champs dans un schéma GraphQL se compose de deux parties - à partir des déclarations de type ( <code>typeDefs</code> ) et des <code>resolver</code> .  L' <code>typeDefs</code> contient des déclarations de type pour les données utilisées dans l'application.  Par exemple, plus tôt, nous avons parlé d'une demande pour obtenir une liste d'objets de <code>flavor</code> du serveur.  Afin de faire une demande similaire à notre serveur, vous devez effectuer les trois étapes suivantes: <br><br><ol><li>  Indiquez au schéma à quoi ressemblent les données de l'objet de <code>flavor</code> (dans l'exemple ci-dessus, elles ressemblent à une annonce de <code>type Flavor</code> ). </li><li>  Déclarez le champ dans le champ racine de <code>type Query</code> (il s'agit de la propriété <code>flavors</code> de la valeur de <code>type Query</code> ). </li><li>  Déclarez une fonction de reconnaissance d'objet <code>resolvers.Query</code> écrite conformément aux champs déclarés dans le champ racine de <code>type Query</code> . </li></ol><br>  <code>typeDefs</code> maintenant attention à <code>typeDefs</code> .  Ici, nous donnons les informations de schéma sur la forme de nos données.  En d'autres termes, nous informons GraphQL des différentes propriétés qui peuvent être contenues dans des entités du type correspondant. <br><br><pre> <code class="plaintext hljs">type Flavor { id: ID name: String description: String nutrition: Nutrition }</code> </pre> <br>  Une déclaration de <code>type Flavor</code> indique qu'un objet <code>type Flavor</code> peut contenir un champ <code>id</code> de type <code>ID</code> , un champ de <code>name</code> de type <code>String</code> , un champ de <code>description</code> de type <code>String</code> et un champ de <code>nutrition</code> de type <code>Nutrition</code> . <br><br>  Dans le cas de la <code>nutrition</code> nous utilisons ici le nom d'un type différent déclaré dans <code>typeDefs</code> .  Ici, le <code>type Nutrition</code> construction <code>type Nutrition</code> décrit la forme de données nutritionnelles du pop-corn. <br><br>  Faites attention au fait qu'ici, comme au tout début de ce document, nous parlons d'une «application» et non d'une «base de données».  Dans l'exemple ci-dessus, on suppose que nous avons une base de données, mais les données de l'application peuvent provenir de n'importe quelle source.  Il peut même s'agir d'une API tierce ou d'un fichier statique. <br><br>  Tout comme nous l'avons fait dans la déclaration de <code>type Flavor</code> , nous indiquons ici les noms des champs qui seront contenus dans les objets de <code>nutrition</code> , en utilisant, comme types de données de ces champs (propriétés), ce qui dans GraphQL est appelé types de données scalaires.  Au moment d'écrire ces lignes, GraphQL supportait <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">5 types de données scalaires intégrés</a> : <br><br><ul><li>  <code>Int</code> : entier 32 bits signé. </li><li>  <code>Float</code> : un nombre à virgule flottante double précision avec un signe. </li><li>  <code>String</code> : une séquence de caractères encodés en UTF-8. </li><li>  <code>Boolean</code> : Boolean <code>true</code> or <code>false</code> . </li><li>  <code>ID</code> : identifiant unique souvent utilisé pour charger à plusieurs reprises des objets ou comme clé dans le cache.  Les valeurs de type <code>ID</code> sérialisées de la même manière que les chaînes, cependant, une indication qu'un type d' <code>ID</code> a une valeur est soulignée par le fait que cette valeur n'est pas destinée à être affichée aux gens, mais à être utilisée dans des programmes. </li></ul><br>  En plus de ces types scalaires, nous pouvons également attribuer des propriétés aux types que nous définissons nous-mêmes.  C'est exactement ce que nous avons fait en attribuant la propriété <code>nutrition</code> décrite dans le <code>type Flavor</code> , type <code>Nutrition</code> . <br><br><pre> <code class="plaintext hljs">type Query { flavors(id: ID): [Flavor] }</code> </pre> <br>  Dans la construction de <code>type Query</code> , qui décrit le type racine de <code>Query</code> (la «requête racine» dont nous avons parlé plus tôt), nous déclarons le nom du champ qui peut être demandé.  En déclarant ce champ, nous spécifions, en plus du type de données que nous attendons, les arguments qui peuvent venir dans la demande. <br><br>  Dans cet exemple, nous attendons une réception possible de l'argument <code>id</code> d'un <code>ID</code> type scalaire.  En réponse à une telle demande, un tableau d'objets est attendu dont le périphérique ressemble à un périphérique de type <code>Flavor</code> . <br><br><h3>  <font color="#3AC1EF">▍Connexion du module de reconnaissance des requêtes</font> </h3><br> ,    <code>type Query</code>    <code>field</code> ,    ,   -. <br><br>  —  ,  GraphQL,   , «».      <code>resolvers</code> ,     <code>Query</code> ,   ,      <code>flavors</code> ,   .        <code>flavors</code> ,     <code>type Query</code> . <br><br><pre> <code class="plaintext hljs">typeDefs: gql`…`, resolvers: { Query: {   flavors: (parent, args) =&gt; {     // ,  args    { id: '1' }     return mongodb.collection('flavors').find(args).toArray()   }, }, … },</code> </pre> <br>  -   .  <code>parent</code> —   ,   ,  <code>args</code>      ,   .      <code>context</code> ,      .       «»  ( —        ,       ). <br><br>     ,    ,   .   GraphQL « »          . , ,      . <br><br>  GraphQL      ,      ,    .    JSON-,  JSON-,  (  GraphQL   ). <br><br>    -   <code>flavors</code>   MongoDB,  <code>args</code> (    )   <code>.find()</code>   ,        ,   . <br><br><h3> <font color="#3AC1EF">▍    </font> </h3><br>     -,   GraphQL,  , ,   ,      <code>nutrition</code> .   ,  ,   <code>Nutrition</code> , ,   ,      ,   <code>flavor</code> .      ,       /  . <br><br>    GraphQL  ,  <code>type Flavor</code>      <code>nutrition</code>   <code>type Nutrition</code> ,          .  ,    ,      <code>flavor</code> . <br><br><pre> <code class="plaintext hljs">typeDefs: gql`   type Nutrition {     flavorId: ID     calories: Int     fat: Int     sodium: Int   }   type Flavor {     […]     nutrition: Nutrition   }   type Query {…}   type Mutation {…} `, resolvers: {   Query: {     flavors: (parent, args) =&gt; {…},   },   Mutation: {…},   Flavor: {     nutrition: (parent) =&gt; {       return mongodb.collection('nutrition').findOne({         flavorId: parent.id,       })     }   }, },</code> </pre> <br>      <code>resolvers</code>  ,   ,      <code>Query</code> , <code>Mutation</code>  <code>Flavor</code> .   ,      <code>typeDefs</code> . <br><br>     <code>Flavors</code> ,  ,   <code>nutrition</code>     -.       ,        <code>Flavor</code> .  ,   : « ,     <code>nutrition</code>     ,  <code>type Flavor</code> ». <br><br>         MongoDB,      ,     <code>parent</code> ,  -. ,     <code>parent</code> ,   ,    ,   <code>flavors</code> . ,      <code>flavor</code> ,    : <br><br><pre> <code class="plaintext hljs">{ flavors {   id   name   nutrition {     calories   } } }</code> </pre> <br>   <code>flavor</code> ,   <code>flavors</code> ,     <code>nutrition</code> ,        <code>parent</code> .     ,  ,  ,    MongoDB,   <code>parent.id</code> ,    <code>id</code>  <code>flavor</code> ,       . <br><br>  <code>parent.id</code>      ,     <code>nutrition</code>   <code>flavorId</code> ,     <code>flavor</code> . <br><br><h3> <font color="#3AC1EF">▍ </font> </h3><br> ,      ,     .   ,          .      <code>type Mutation</code> ,   ,       <code>updateFlavor</code> ,  ,   . <br><br><pre> <code class="plaintext hljs">type Mutation { updateFlavor(id: ID!, name: String, description: String): Flavor }</code> </pre> <br>     : « ,   <code>updateFlavor</code>  <code>id</code>  <code>ID</code> ( , <code>!</code> ,  GraphQL  ,    ), <code>name</code>  <code>String</code>  <code>description</code>  <code>String</code> ».  ,         ,     <code>Flavor</code> (  — ,    <code>id</code> , <code>name</code> , <code>description</code> , , , <code>nutrition</code> ). <br><br><pre> <code class="plaintext hljs">{ typeDefs: gql`…`, resolvers: {   Mutation: {     updateFlavor: (parent, args) =&gt; {       // ,  args    { id: '1', name: 'Movie Theater Clone', description: 'Bring the movie theater taste home!' }       //  .       mongodb.collection('flavors').update(         { id: args.id },         {           $set: {             ...args,           },         },       )       //  flavor  .       return mongodb.collection('flavors').findOne(args.id)     },   }, }, }</code> </pre> <br>  -   <code>updateFlavor</code>    ,      :       ,    ,   — ,      <code>flavor</code> . <br><br>    ,               ,       <code>flavor</code>     .   ? <br><br>   ,          ,        .     ,     <code>flavor</code> ,     . <br><br>      <code>args</code> ? , . ,          ,   ,      100%   ,         .       ,    ,  ,     ,      ,    . <br><br><h2> <font color="#3AC1EF">    GraphQL?</font> </h2><br>  ,      ,    ,     ,   , GraphQL-API. <br><br>        ,     GraphQL      ,      .  ,         .        ,    .  , ,   ,   GraphQL      REST      .  ,   ,           ,     GraphQL. <br><br><h3> <font color="#3AC1EF">▍    ,   </font> </h3><br>     ,       HTTP-,  ,      ,   ,   —  .       GraphQL       ,  ,    ,     ,     (            ). <br><br>        ,  ,     ( —         ),  GraphQL      . <br><br><h3> <font color="#3AC1EF">▍    ,    ,       </font> </h3><br>  ,       ,    « ».      , ,   ,   .        .   GraphQL         . <br><br><h3> <font color="#3AC1EF">▍     ,       </font> </h3><br>          REST API,          :  ,    . ,      -,   iOS  Android,   API  .    ,  , ,   , «   »    . <br><br>    ,   ,   ,   HTTP,              API (, ,   ). <br><br><h3> <font color="#3AC1EF">▍   GraphQL —   ?        REST API    GraphQL?</font> </h3><br> , .   . ,  ,   GraphQL     .       GraphQL,     .       ,      ,      ,           .     ,      ,     . <br><br> ,  GraphQL  ,  ,      ,  .    GraphQL    ,      Apollo  Relay,       . <br><br> GraphQL — ,  ,   .   <code>graphql</code> (     <code>express-graphql</code> ,    ) —      .  ,   GraphQL      -  .      ,     -,   ,  ,     ,    . <br><br><h2>  <font color="#3AC1EF">Résumé</font> </h2><br>   ,   GraphQL    ,           . GraphQL      ,    , ,  .  , ,       ,        ,       GraphQL. <br><br> ,       : GraphQL   .              GraphQL  . ,     GraphQL,      ,  , ,  ,  ,  ,  . <br><br>  —   ,  GraphQL — ,   ,   .  GraphQL       ,   .    ,  GraphQL —  ,  , ,  .           .  ,       ,      ,   ,     ,      ,      GraphQL. <br><br>  <b>Chers lecteurs!</b>        GraphQL —     ,         . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr445268/">https://habr.com/ru/post/fr445268/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr445258/index.html">Comment supprimer en toute sécurité vos données de votre smartphone Android avant de les vendre</a></li>
<li><a href="../fr445260/index.html">Les robots se reconnaîtront-ils jamais vraiment? Les scientifiques s'orientent dans cette direction.</a></li>
<li><a href="../fr445262/index.html">GeekUniversity ouvre le recrutement au département Big Data d'Analytics</a></li>
<li><a href="../fr445264/index.html">Préchargement, prélecture et autres balises</a></li>
<li><a href="../fr445266/index.html">GeekBrains et Rostelecom organiseront un IoT Hackathon</a></li>
<li><a href="../fr445270/index.html">[signet] Bash pour les débutants: 21 commandes utiles</a></li>
<li><a href="../fr445272/index.html">JavaScript est le meilleur langage de programmation pour les débutants. C'est vrai ou pas?</a></li>
<li><a href="../fr445274/index.html">Lorsque "Zoë"! == "Zoë", ou pourquoi vous devez normaliser les chaînes Unicode</a></li>
<li><a href="../fr445276/index.html">Guide d'utilisation complet</a></li>
<li><a href="../fr445278/index.html">Comment créer un jeu si vous n'êtes jamais artiste</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>