<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¿ï¸ ğŸ’³ ğŸ‘©â€ğŸŒ¾ Cache Laravel: dasar-dasar ditambah kiat & trik ğŸ•£ âœ‹ğŸ» ğŸšï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Teknik caching memungkinkan Anda membuat aplikasi yang lebih skalabel, menyimpan hasil beberapa kueri dalam penyimpanan cepat di memori. Namun, cachin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cache Laravel: dasar-dasar ditambah kiat & trik</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463495/"><p>  Teknik caching memungkinkan Anda membuat aplikasi yang lebih skalabel, menyimpan hasil beberapa kueri dalam penyimpanan cepat di memori.  Namun, caching yang diimplementasikan secara tidak tepat dapat sangat menurunkan kesan pengguna terhadap aplikasi Anda.  Artikel ini berisi beberapa konsep dasar tentang caching, berbagai aturan dan tabu yang telah saya pelajari dari beberapa proyek sebelumnya. </p><br><h2 id="ne-ispolzuyte-keshirovanie">  Jangan gunakan caching. </h2><br><p>  Apakah proyek Anda cepat dan tidak memiliki masalah kinerja? <br>  Lupakan tentang caching.  Serius :) </p><br><p>  Ini akan sangat menyulitkan operasi membaca dari database tanpa manfaat apa pun. </p><br><p> Benar, Mohamed Said di awal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">artikel ini</a> membuat beberapa perhitungan dan membuktikan bahwa dalam beberapa kasus, mengoptimalkan aplikasi selama milidetik dapat menghemat banyak uang di akun AWS Anda.  Jadi, jika penghematan yang diproyeksikan pada proyek Anda lebih dari $ 1,86, maka mungkin caching adalah ide yang bagus. </p><a name="habracut"></a><br><h2 id="kak-eto-rabotaet">  Bagaimana cara kerjanya? </h2><br><p> Ketika sebuah aplikasi ingin mendapatkan beberapa data dari database, misalnya, entitas Post dengan id-nya, ia menghasilkan kunci caching yang unik untuk kasus ini ( <code>'post_' . $id</code> sangat cocok) dan mencoba untuk menemukan nilai dengan kunci ini di penyimpanan nilai kunci cepat (memcache, redis, atau lainnya).  Jika nilainya ada, maka aplikasi menggunakannya.  Jika tidak, ini diambil dari database dan disimpan dalam cache oleh kunci ini untuk digunakan di masa depan. </p><br><p><img src="https://habrastorage.org/webt/vd/9i/kj/vd9ikjg-gji5lauz1atmq9bkdpq.png"></p><br><p>  Menyimpan nilai ini dalam cache bukanlah ide yang baik selamanya, karena entitas Post ini dapat diperbarui, tetapi aplikasi akan selalu menerima nilai yang lama, di-cache. <br>  Oleh karena itu, fungsi caching biasanya menanyakan berapa nilai ini harus disimpan. </p><br><p>  Setelah waktu ini berakhir, memcache atau redis akan "lupa" tentang hal itu dan aplikasi akan mengambil nilai segar dari database. </p><br><p>  Contoh: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function"> </span></span>{ $key = <span class="hljs-string"><span class="hljs-string">'post_'</span></span> . $id; $post = \Cache::get($key); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($post === <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { $post = Post::findOrFail($id); \Cache::put($key, $post, <span class="hljs-number"><span class="hljs-number">900</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $post; }</code> </pre> <br><p>  Di sini saya meletakkan entitas Post dalam cache selama 15 menit (sejak versi 5.8, laravel menggunakan detik dalam parameter ini, sebelum ada menit).  Fasad <code>Cache</code> juga memiliki metode <code>remember</code> mudah digunakan untuk kasus ini.  Kode ini melakukan hal yang persis sama dengan yang sebelumnya: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> \Cache::remember(<span class="hljs-string"><span class="hljs-string">'post_'</span></span> . $id, <span class="hljs-number"><span class="hljs-number">900</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Post::findOrFail($id); }); }</code> </pre> <br><p>  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">bab Cache dalam</a> dokumentasi Laravel yang menjelaskan cara menginstal driver yang diperlukan untuk aplikasi Anda dan fungsi utama. </p><br><h2 id="dannye-v-keshe">  Data dalam cache </h2><br><p>  Semua driver Laravel standar menyimpan data sebagai string.  Ketika kami meminta Anda untuk membuat cache instance dari model Eloquent, ia menggunakan fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">serialisasi</a> untuk mendapatkan string dari objek.  Fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">unserialize</a> mengembalikan keadaan suatu objek ketika kita mendapatkannya dari cache. </p><br><p>  Hampir semua data dapat di-cache.  Bilangan, string, array, objek (jika serialisasi dengan benar, lihat deskripsi fungsi dari tautan sebelumnya). </p><br><p>  Entitas yang fasih dan koleksi dapat dengan mudah di-cache dan merupakan nilai yang paling populer di cache aplikasi Laravel.  Namun, penggunaan jenis lain juga dipraktikkan cukup luas.  Metode <code>Cache::increment</code> populer untuk menerapkan berbagai penghitung.  Juga, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">kunci atom</a> sangat berguna ketika pengembang berjuang melawan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">kondisi balapan</a> . </p><br><h2 id="chto-keshirovat">  Apa yang di-cache? </h2><br><p>  Calon pertama untuk caching adalah permintaan yang dieksekusi sangat sering, tetapi rencana eksekusi mereka bukan yang termudah.  Contoh terbaik adalah 5 artikel teratas di halaman utama, atau berita terbaru.  Caching nilai-nilai tersebut dapat sangat meningkatkan kinerja halaman utama. </p><br><p>  Biasanya, mengambil entitas dengan id menggunakan <code>Model::find($id)</code> sangat cepat, tetapi jika tabel ini sarat dengan banyak pembaruan, masukkan dan hapus kueri, mengurangi jumlah kueri pemilihan akan memberikan kelonggaran yang baik untuk database.  Entitas yang memiliki banyak hubungan yang akan dimuat setiap saat juga merupakan kandidat yang baik untuk caching.  Ketika saya mengerjakan sebuah proyek dengan 10+ juta pengunjung sehari, kami men-cache hampir semua permintaan pilih. </p><br><h2 id="invalidaciya-kesha">  Pembatalan cache </h2><br><p>  Pembusukan kunci setelah waktu tertentu membantu memperbarui data dalam cache, tetapi ini tidak terjadi segera.  Pengguna dapat mengubah data, tetapi untuk beberapa waktu ia akan terus melihat versi lama dari mereka dalam aplikasi.  Dialog biasa pada salah satu proyek masa lalu saya: </p><br><pre> <code class="plaintext hljs">:   ,     ! : ,  15 ( ,  )...</code> </pre> <br><p>  Perilaku ini sangat merepotkan bagi pengguna, dan keputusan yang jelas untuk menghapus data lama dari cache ketika kami memperbaruinya dengan cepat terlintas dalam pikiran.  Proses ini disebut disabilitas.  Untuk kunci sederhana seperti <code>"post_%id%"</code> , <code>"post_%id%"</code> tidak terlalu sulit. </p><br><p>  Peristiwa fasih dapat membantu, atau jika aplikasi Anda menghasilkan acara khusus seperti <code>PostPublished</code> atau <code>UserBanned</code> itu bisa lebih sederhana.  Contoh dengan acara Eloquent.  Pertama, Anda perlu membuat kelas acara.  Untuk kenyamanan, saya akan menggunakan kelas abstrak untuk mereka: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PostEvent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> Post */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $post; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Post $post)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;post = $post; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;post; } } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PostSaved</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PostEvent</span></span></span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PostDeleted</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PostEvent</span></span></span></span>{}</code> </pre> <br><p>  Tentu saja, menurut PSR-4, setiap kelas harus dalam file sendiri.  Atur kelas Post Eloquent (menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">dokumentasi</a> ): </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Post</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $dispatchesEvents = [ <span class="hljs-string"><span class="hljs-string">'saved'</span></span> =&gt; PostSaved::class, <span class="hljs-string"><span class="hljs-string">'deleted'</span></span> =&gt; PostDeleted::class, ]; }</code> </pre> <br><p>  Buat pendengar untuk acara ini: </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventServiceProvider</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $listen = [ PostSaved::class =&gt; [ ClearPostCache::class, ], PostDeleted::class =&gt; [ ClearPostCache::class, ], ]; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClearPostCache</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PostEvent $event)</span></span></span><span class="hljs-function"> </span></span>{ \Cache::forget(<span class="hljs-string"><span class="hljs-string">'post_'</span></span> . $event-&gt;getPost()-&gt;id); } }</code> </pre> <br><p>  Kode ini akan menghapus nilai yang di-cache setelah setiap pembaruan atau penghapusan Entitas pos.  Daftar entitas yang tidak valid, seperti 5 artikel teratas atau berita terbaru, akan sedikit lebih rumit.  Saya melihat tiga strategi: </p><br><h3 id="strategiya-ne-invalidiruem">  Jangan Nonaktifkan Strategi </h3><br><p>  Hanya saja, jangan menyentuh nilai-nilai ini.  Biasanya, ini tidak membawa masalah.  Tidak apa-apa bahwa berita baru akan muncul dalam daftar yang terakhir nanti (tentu saja, jika ini bukan portal berita besar).  Tetapi untuk beberapa proyek, sangat penting untuk memiliki data baru dalam daftar ini. </p><br><h3 id="strategiya-nayti-i-obezvredit">  Temukan dan Defuse Strategy </h3><br><p>  Setiap kali Anda memperbarui publikasi, Anda dapat mencoba menemukannya di daftar yang di-cache, dan jika ada, hapus nilai yang di-cache ini. </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTopPosts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> \Cache::remember(<span class="hljs-string"><span class="hljs-string">'top_posts'</span></span>, <span class="hljs-number"><span class="hljs-number">900</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Post::<span class="hljs-comment"><span class="hljs-comment">/*   top-5*/</span></span>()-&gt;get(); }); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CheckAndClearTopPostsCache</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PostEvent $event)</span></span></span><span class="hljs-function"> </span></span>{ $updatedPost = $event-&gt;getPost(); $posts = \Cache::get(<span class="hljs-string"><span class="hljs-string">'top_posts'</span></span>, []); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($posts <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $post) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($updatedPost-&gt;id == $post-&gt;id) { \Cache::forget(<span class="hljs-string"><span class="hljs-string">'top_posts'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } } }</code> </pre> <br><p>  Terlihat jelek, tetapi berhasil. </p><br><h3 id="strategiya-hranit-id">  Strategi "id penyimpanan" </h3><br><p>  Jika urutan item dalam daftar tidak penting, maka dalam cache Anda hanya dapat menyimpan entri id.  Setelah menerima id, Anda dapat membuat daftar kunci dari form <code>'post_'.$id</code> dan mendapatkan semua nilai menggunakan metode <code>Cache::many</code> , yang mendapatkan banyak nilai dari cache dalam satu permintaan (ini juga disebut multi get). </p><br><p>  Pembatalan cache tidak sia-sia disebut salah satu dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">dua kesulitan dalam pemrograman</a> dan sangat sulit dalam beberapa kasus. </p><br><h2 id="keshirovanie-otnosheniy">  Caching Hubungan </h2><br><p>  Caching entitas dengan hubungan membutuhkan peningkatan perhatian. </p><br><pre> <code class="php hljs">$post = Post::findOrFail($id); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($post-&gt;comments...)</code> </pre> <br><p>  Kode ini melakukan dua kueri <code>SELECT</code> .  Mendapatkan entitas dengan <code>id</code> dan komentar oleh <code>post_id</code> .  Kami menerapkan caching: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> \Cache::remember(<span class="hljs-string"><span class="hljs-string">'post_'</span></span> . $id, <span class="hljs-number"><span class="hljs-number">900</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Post::findOrFail($id); }); } $post = getPost($id); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($post-&gt;comments...)</code> </pre> <br><p>  Permintaan pertama di-cache, dan yang kedua tidak.  Ketika driver cache menulis Posting ke cache, <code>comments</code> belum dimuat.  Jika kita ingin menyimpannya juga, maka kita harus memuatnya secara manual: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> \Cache::remember(<span class="hljs-string"><span class="hljs-string">'post_'</span></span> . $id, <span class="hljs-number"><span class="hljs-number">900</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function"> </span></span>{ $post = Post::findOrFail($id); $post-&gt;load(<span class="hljs-string"><span class="hljs-string">'comments'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $post; }); }</code> </pre> <br><p>  Kedua permintaan sekarang di-cache, tetapi kita harus membatalkan nilai <code>'post_'.$id</code> setiap kali komentar ditambahkan.  Ini tidak terlalu efisien, oleh karena itu lebih baik menyimpan cache komentar secara terpisah: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPostComments</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Post $post)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> \Cache::remember(<span class="hljs-string"><span class="hljs-string">'post_comments_'</span></span> . $post-&gt;id, <span class="hljs-number"><span class="hljs-number">900</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($post)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $post-&gt;comments; }); } $post = getPost($id); $comments = getPostComments($post); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($comments...)</code> </pre> <br><p>  Terkadang esensi dan sikap sangat terkait satu sama lain dan selalu digunakan bersama (memesan dengan perincian, publikasi dengan terjemahan ke dalam bahasa yang diinginkan).  Dalam hal ini, menyimpannya dalam satu cache cukup normal. </p><br><h2 id="single-source-of-truth-dlya-klyuchey-keshirovaniya">  Sumber kebenaran tunggal untuk kunci cache </h2><br><p>  Jika proyek mengimplementasikan pembatalan, kunci cache dihasilkan di setidaknya dua tempat: untuk memanggil <code>Cache::get</code> / <code>Cache::remember</code> dan untuk memanggil <code>Cache::forget</code> .  Saya sudah mengalami situasi ketika kunci ini diubah di satu tempat, tetapi tidak di tempat lain, dan cacatnya pecah.  Saran yang biasa untuk kasus seperti ini adalah konstanta, tetapi kunci cache dihasilkan secara dinamis, jadi saya menggunakan kelas khusus yang menghasilkan kunci: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CacheKeys</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($postId)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'post_'</span></span> . $postId; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postComments</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($postId)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'post_comments'</span></span> . $postId; } } \Cache::remember(CacheKeys::postById($id), <span class="hljs-number"><span class="hljs-number">900</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function"> </span></span>{ $post = Post::findOrFail($id); }); <span class="hljs-comment"><span class="hljs-comment">// .... \Cache::forget(CacheKeys::postById($id));</span></span></code> </pre> <br><p>  Masa hidup kunci juga dapat diberikan dalam konstanta demi keterbacaan yang lebih baik.  900 atau 15 * 60 ini meningkatkan beban kognitif saat membaca kode. </p><br><h2 id="ne-ispolzuyte-kesh-v-operaciyah-zapisi">  Jangan gunakan cache dalam operasi tulis </h2><br><p>  Saat menerapkan operasi tulis, seperti mengubah judul atau teks publikasi, tergoda untuk menggunakan metode <code>getPost</code> yang ditulis sebelumnya: </p><br><pre> <code class="php hljs">$post = getPost($id); $post-&gt;title = $newTitle; $post-&gt;save();</code> </pre> <br><p>  Tolong jangan lakukan itu.  Nilai dalam cache mungkin kedaluwarsa, bahkan jika pembatalan dilakukan dengan benar.  Kondisi ras kecil dan penerbitan akan kehilangan perubahan yang dibuat oleh pengguna lain.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Kunci optimis</a> akan membantu setidaknya untuk tidak kehilangan perubahan, tetapi jumlah permintaan yang salah dapat sangat meningkat. </p><br><p>  Solusi terbaik adalah dengan menggunakan logika pemilihan entitas yang sangat berbeda untuk operasi baca dan tulis (halo, CQRS).  Dalam operasi tulis, Anda selalu perlu memilih nilai terbaru dari database.  Dan jangan lupa tentang kunci (optimis atau pesimis) untuk data penting. </p><br><p>  Saya pikir ini cukup untuk artikel pengantar.  Caching adalah topik yang sangat kompleks dan panjang, dengan jebakan untuk pengembang, tetapi peningkatan kinerja terkadang melebihi semua kesulitannya. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id463495/">https://habr.com/ru/post/id463495/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id463481/index.html">Matematika diskrit untuk WMS: algoritma untuk mengompresi barang dalam sel (bagian 1)</a></li>
<li><a href="../id463483/index.html">Kolaborasi dokumen, obrolan perusahaan yang diperbarui dan aplikasi seluler: Apa yang Baru di Zextras Suite 3.0</a></li>
<li><a href="../id463489/index.html">Heavy metal berbohong: pada kenyataannya, musik berat memiliki efek positif pada kesehatan para penggemarnya</a></li>
<li><a href="../id463491/index.html">Kisah terjemahan bahasa Inggris yang aneh dari Metal Gear Solid</a></li>
<li><a href="../id463493/index.html">Lebih banyak statistik situs di repositori kecil Anda</a></li>
<li><a href="../id463497/index.html">Kalkulator Efisiensi Saham dan 5 Alasan Mengapa Sesuatu Menjadi Salah</a></li>
<li><a href="../id463499/index.html">Kantor yang nyaman - membantu bekerja atau mengganggu dan mengalihkan perhatian? Sidenis, Alternativa Games, dan FunBox akan menjawab</a></li>
<li><a href="../id463503/index.html">Mengapa pengembangan web modern begitu rumit? Bagian 1</a></li>
<li><a href="../id463505/index.html">Mengapa administrator sistem harus menjadi insinyur DevOps</a></li>
<li><a href="../id463507/index.html">Ginjal adalah jalan keluarnya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>