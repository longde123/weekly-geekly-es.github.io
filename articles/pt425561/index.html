<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧒🏿 🧛🏾 👩🏾‍🤝‍👩🏼 Curso MIT "Segurança de sistemas de computadores". Palestra 10: Execução Simbólica, Parte 2 🐗 👨🏿‍🎓 🌦️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Instituto de Tecnologia de Massachusetts. Curso de Aula nº 6.858. "Segurança de sistemas de computador". Nikolai Zeldovich, James Mickens. 2014 ano 
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Curso MIT "Segurança de sistemas de computadores". Palestra 10: Execução Simbólica, Parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/425561/"><h3>  Instituto de Tecnologia de Massachusetts.  Curso de Aula nº 6.858.  "Segurança de sistemas de computador".  Nikolai Zeldovich, James Mickens.  2014 ano </h3><br>  Computer Systems Security é um curso sobre o desenvolvimento e implementação de sistemas de computador seguros.  As palestras abrangem modelos de ameaças, ataques que comprometem a segurança e técnicas de segurança baseadas em trabalhos científicos recentes.  Os tópicos incluem segurança do sistema operacional (SO), recursos, gerenciamento de fluxo de informações, segurança de idiomas, protocolos de rede, segurança de hardware e segurança de aplicativos da web. <br><br>  Palestra 1: “Introdução: modelos de ameaças” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 2: “Controle de ataques de hackers” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Aula 3: “Estouros de Buffer: Explorações e Proteção” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 4: “Separação de Privilégios” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 5: “De onde vêm os sistemas de segurança?” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> <br>  Palestra 6: “Oportunidades” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 7: “Sandbox do Cliente Nativo” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Aula 8: “Modelo de Segurança de Rede” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Aula 9: “Segurança de aplicativos da Web” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 10: “Execução Simbólica” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <a name="habracut"></a><br><br>  <b>Público:</b> Parece que você não falou sobre como os bits são usados ​​para armazenar um número inteiro int. <br><br>  <b>Professor:</b> Essa é uma pergunta muito boa.  E realmente tem a ver com a forma como você define suas limitações, certo?  Portanto, se você olhar para o nosso exemplo simples desde o início, verá que assumimos a presença de números inteiros que estudamos no ensino fundamental.  Ao mesmo tempo, decidimos ignorar completamente os erros de estouro.  Se você se preocupa com erros de estouro, e é importante que você não exista esses erros, o uso de números inteiros matematicamente não ajudará a corrigir o problema. <br><br><img src="https://habrastorage.org/webt/d4/-r/y0/d4-ry0kha0k0koshx0mwy3zwums.jpeg"><br><br>  O que você precisa é apresentar essas quantidades não como números inteiros, mas como vetores de bits.  Ao representá-los como vetores de bits, você deve usar uma visão mais ampla das coisas.  Aqui voltamos aos solucionadores SMT.  Um aspecto da teoria modular é que o solucionador em si é extensível usando diferentes teorias. <br><br>  As teorias mais populares são as de vetores de bits de comprimento fixo.  Isso significa que, se você interpreta suas fórmulas na teoria dos vetores de bits de comprimento fixo, deve primeiro definir o comprimento dos vetores de bits.  Ou seja, você deve indicar explicitamente que isso será usado para vetores de bits com 32 bits ou 8 bits ou 64 bits. <br><br><img src="https://habrastorage.org/webt/_n/af/n-/_nafn-pei3kbsz4sxqgnbvi8ggy.jpeg"><br><br>  Há uma outra teoria chamada teoria da matriz TOA.  E falaremos um pouco mais sobre isso.  Diferentemente da teoria dos vetores de bits, projetada para objetos de comprimento fixo, a teoria das matrizes é destinada a coleções cujo tamanho é a priori desconhecido. <br><br>  Agora, na prática, ninguém usa a teoria das matrizes, por exemplo, para modelar números inteiros, porque é muito caro.  Falar sobre um problema é muito mais caro quando você não conhece seus limites.  Portanto, como regra, as pessoas usam a teoria de um comprimento fixo de vetores de bits nas discussões de números inteiros ou mesmo símbolos. <br><br>  Outra teoria muito difundida é a teoria da aritmética de número inteiro real e, em particular, a aritmética de número inteiro linear. <br><br><img src="https://habrastorage.org/webt/qb/aa/8t/qbaa8tza3h3ahkhgi5eeo1ba4mw.jpeg"><br><br>  As pessoas gostam muito dessa teoria porque ela fornece argumentação eficaz, mas não é muito boa quando você fala sobre programas, porque aqui você realmente se importa com problemas de transbordamento.  Mas essa teoria é amplamente usada para muitas coisas. <br><br>  Outra teoria que é freqüentemente usada é a teoria das funções não interpretadas.  O que essa teoria significa? <br><br><img src="https://habrastorage.org/webt/8k/8l/1j/8k8l1jurngs68kehvett1zaaifk.jpeg"><br><br>  Isso significa que você tem uma certa fórmula.  Nesta fórmula, você sabe que está chamando uma função, mas não sabe nada sobre essa função, exceto pelo fato de que se você inserir alguma entrada nela, obterá a mesma saída. <br><br>  Acontece que isso é muito útil ao raciocinar sobre coisas como o uso de código de ponto flutuante, modelagem, senos, cossenos, raízes quadradas.  Discussões detalhadas sobre essas coisas podem ser muito demoradas e caras.  Mas usar essa teoria permite que você diga: "Olha, eu realmente não me importo com o que a função senoidal faz.  Eu não ligo para o que exatamente ela vai dar.  Eu só preciso saber que se eu chamar a função seno em vários locais do programa com entrada específica, obterá dados do mesmo tipo na saída.  Isso é o suficiente para eu raciocinar sobre o meu programa. ” <br><br>  E, portanto, as operações mais comuns na análise de sistemas reais são vetores de bits que funcionam com números inteiros, logs e ponteiros.  De fato, os ponteiros geralmente são representados por um número inteiro, porque às vezes você não define vetores de bits nos ponteiros.  Mas, às vezes, você precisa fazer isso e não pode mais usar números inteiros. <br><br>  Então, examinamos o que um solucionador SMT pode fazer por você.  Como isso realmente funciona?  O que há dentro deles que os faz funcionar? <br><br>  De fato, os solucionadores SMT dependem de nossa capacidade de resolver os problemas de viabilidade das fórmulas booleanas SAT, de considerar problemas associados apenas a restrições puramente booleanas e variáveis ​​booleanas e nos informar se você garantirá que o programa atribua os valores atribuídos a essas variáveis ​​booleanas ou não. . <br><br>  Isso é algo que por muitos e muitos anos ensinou aos alunos mais velhos, dizendo que essa é realmente uma tarefa completa do NP e, nos casos em que algo se resume ao SAT, você não deve fazer isso.  Mas, na verdade, temos realmente bons solucionadores de SAT. <br><br>  Então, vou lhe contar a idéia básica de como os solucionadores de SAT funcionam.  Está no fato de você pegar todas as suas restrições nas variáveis ​​booleanas e colocá-las no banco de dados.  Talvez você não consiga ver claramente as letras minúsculas na tela, mas é tudo o que posso fazer. <br><br><img src="https://habrastorage.org/webt/h6/j8/gp/h6j8gpmtgfurf6gsslrlr76i8tw.jpeg"><br><br>  Vou comentar e falar sobre isso no decorrer da ação, e depois publicarei os slides para que você possa ver o que está escrito lá. <br><br>  Então, aqui na tarefa SAT, temos todas essas variáveis ​​representando incógnitas booleanas, certo?  Queremos saber se é possível que X seja verdadeiro ao mesmo tempo (X = VERDADEIRO), e Y seja verdadeiro e Z seja verdadeiro.  Estas são as nossas incógnitas.  Além disso, todas as restrições estão na forma conjuntiva normal.  Isso significa que todas as nossas restrições estão na forma de X1 = verdadeiro, ou X2 = verdadeiro ou X3 = verdadeiro. <br><br><img src="https://habrastorage.org/webt/jh/b0/-v/jhb0-vkga5zdzwxjtu5zlg6euky.jpeg"><br><br>  Nesta forma, temos todas as nossas limitações, que dizem que X1 é verdadeiro ou X2 é falso ou X3 é falso.  Você provavelmente lembra da matemática discreta que qualquer fórmula booleana pode ser representada na forma conectiva normal.  Isso significa que, qualquer representação usada para representar fórmulas booleanas, você pode facilmente converter para esse formato. <br><br>  Portanto, temos um banco de dados com muitas limitações deste formulário.  O solucionador SAT escolherá uma dessas variáveis ​​aleatoriamente, suponha que seja X1.  E ele dirá: “por que não definir X1 como verdadeiro?  Eu não sei nada sobre essas restrições, então posso assumir que é isso mesmo. "  E acontece que você terá restrições que, por exemplo, afirmam que X1 é falso ou X7 é verdadeiro. <br><br>  Portanto, se você sabe que X1 é verdadeiro e sabe que X1 é falso ou X7 é verdadeiro, o que você sabe sobre X7? <br><br>  <b>Público:</b> deve ser verdade! <br><br>  <b>Professor:</b> sim, deve ser verdade.  Porque, caso contrário, esta restrição não será cumprida.  Portanto, agora você distribuiu esse valor de X1 para X7.  Suponha que você agora selecione outra variável aleatória, como X5. <br><br><img src="https://habrastorage.org/webt/c8/xt/rp/c8xtrpz4r9k438asupto0lwc5ni.jpeg"><br><br>  Agora, suponha que você tenha uma restrição que diz: X7 é falso ou X6 é verdadeiro ou X5 é falso.  Então, eu tenho X5 = verdadeiro e X7 = verdadeiro.  Isso significa que o X6 agora também deve ser verdadeiro.  Porque, caso contrário, essa restrição seria violada.  Portanto, o sistema conclui que o X6 deve ser verdadeiro e continua o processo, executando as verificações disponíveis e analisando todas as ofertas disponíveis.  O sistema verifica se há outras coisas implícitas nas verificações que possui.  E ela segue esses significados até que uma de duas coisas aconteça. <br><br>  A primeira é que você segue as consequências e tenta coisas aleatórias e, por fim, define o valor de cada variável sem nunca encontrar uma contradição.  Então você fez tudo certo. <br><br>  A segunda - você se depara com uma contradição e volta à condição que fez X4 ser verdadeiro, excluindo a condição que fez X4 ser falso.  Mas há uma regra da álgebra booleana que todos deveriam conhecer: uma variável não pode ser verdadeira e falsa ao mesmo tempo. <br><br><img src="https://habrastorage.org/webt/yf/bk/tg/yfbktgumqupvocdxul_cx9wlt20.jpeg"><br><br>  E diz que você se depara com uma contradição, obviamente fez algo errado em uma dessas tarefas aleatórias que tentou concluir. <br><br>  Vamos analisar essa contradição e ver que tipo de tarefas levaram a essa contradição.  Com base nas atribuições que levaram a essa contradição, vamos apresentar uma nova cláusula de conflito que resume essa contradição. <br><br>  O que acontece que X1 é falso e X5 é falso e X9 também é falso?  Basicamente, isso se baseia no que aprendi com essas tarefas aleatórias, durante as quais descobri que uma dessas coisas deve ser verdadeira, que não é possível que X1 seja verdadeiro e X5 seja verdadeiro, e X9 seja false, isso não pode ser. <br><br>  Sei que isso não pode acontecer, porque quando tentei fazer tudo "explodir", encerrei o programa com uma contradição. <br><br>  E assim, o solucionador SAT tenta concluir tarefas aleatórias, verificando como elas são.  Quando ele encontra contradições, ele analisa o conjunto de consequências que as levaram e, finalmente, forma uma nova restrição, que garante que o solucionador nunca mais encontre essa contradição específica, esse problema específico. <br>  Assim, podemos imaginar o solucionador SAT como uma "caixa preta" que fornece uma restrição booleana e pode dizer se é satisfatório ou não.  Os solucionadores SMT são construídos sobre os melhores solucionadores SAT.  Eles podem usar o poder dos solucionadores de SAT para resolver problemas completos de NP com raciocínio orientado ao assunto sobre teorias suportadas. <br><br>  Para ter uma idéia de como isso funciona, suponha que você tenha essa fórmula. <br><br><img src="https://habrastorage.org/webt/fi/hc/za/fihczar0nfdk1h7j_jgkzixzpli.jpeg"><br><br>  Isso é factível?  Podemos encontrar um teste satisfatório para ela?  O solucionador SMT pode separar parte dessa fórmula, o que requer raciocínio na teoria dos números inteiros.  Usamos estruturas booleanas para separar fórmulas.  Portanto, temos as fórmulas F1, F2, F3 e F4. <br><br><img src="https://habrastorage.org/webt/wi/yr/sy/wiyrsy_aikhwm3soegrypiu2vfk.jpeg"><br><br>  Agora, essa é uma tarefa booleana puramente lógica - posso encontrar uma tarefa satisfatória para isso?  O solucionador do SAT pode dizer: "sim, posso encontrar algo que satisfaça essa tarefa executando F1 = true, F2 = true e F3 = true".  Isso satisfaz a especificação da fórmula booleana. <br><br><img src="https://habrastorage.org/webt/s5/ff/pc/s5ffpcpzbfo2cktluc4jrnnz9pk.jpeg">  \ <br><br>  Então, agora temos uma pergunta que podemos pedir ao solucionador para uma área específica, neste caso, é apenas um solucionador aritmético linear.  Assim, podemos ir ao solucionador linear do solucionador de teoria e dizer: "O solucionador de SAT afirma que essa é uma tarefa razoável e que, se eu puder fazer essa tarefa funcionar, minha fórmula será satisfeita". <br><br>  Posso dizer que F1 é X&gt; 5, F2 é Y &lt;5 e F3 é Y&gt; X. Então, posso perguntar ao solucionador SAT se é possível obter esses X e Y para que X seja&gt; 5, Y é &lt; 5 e, nesse caso, Y seria&gt; X?  Agora, esta é uma questão de aritmética puramente linear, não há lógica booleana. <br><br>  E qual é a resposta para esta pergunta?  Não.  É impossível satisfazer essas condições ao mesmo tempo. <br>  Portanto, existem métodos tradicionais para resolver problemas lineares.  Você pode usar o método simplex, por exemplo, para resolver sistemas de desigualdades lineares.  Existem muitos métodos que podem ser usados ​​para resolver sistemas de desigualdades lineares. <br><br><img src="https://habrastorage.org/webt/4g/q3/uy/4gq3uyrn1tqglftbpfldn0-vofe.jpeg"><br><br>  Assim, o solucionador SAT envia perguntas teóricas ao solucionador de Teoria.  O ponto principal é que os solucionadores de solucionadores de teoria sabem tudo sobre esses problemas e podem dar uma resposta precisa à questão de saber se essas condições funcionarão. <br><br>  Nesse caso, o solucionador teórico processa a solicitação, descobre que essa atribuição de condições não pode funcionar, retorna ao solucionador SAT e diz: “o que você fez não funcionará”! <br><br>  Mas ele não apenas diz sim ou não, mas explica por que algo não vai funcionar.  Pelo fato de essas fórmulas não funcionarem, o solucionador de teoria conclui que F1 e F2 e F3 não podem existir simultaneamente e informa ao solucionador de SAT que essas 3 fórmulas são mutuamente exclusivas. <br><br>  Portanto, agora temos algumas das informações que posso retornar ao solucionador do SAT e perguntamos a ele: “ei, você pode me dar uma solução que satisfaça não apenas a restrição que tínhamos no início, mas também a nova restrição que a Theory descobriu. solucionador "? <br><br>  Existe algum outro objetivo que agora satisfaça essas duas limitações? <br><br><img src="https://habrastorage.org/webt/3v/zx/ls/3vzxlsvv19wp3h-ifqye1fushps.jpeg"><br><br>  Então, descartamos a restrição inicial X&gt; 5, Y &lt;5, Y&gt; X, isso não nos incomoda mais. <br><br><img src="https://habrastorage.org/webt/jc/es/mi/jcesmivnxfc8ur3hzivvmrt1ywc.jpeg"><br><br>  Temos uma nova restrição que podemos definir para nosso solucionador de Teoria - X&gt; 5, Y &lt;5, Y&gt; 2. Podemos fazer Y igual a 3 e X igual a 6, e então ele funcionará.  Agora você tem uma tarefa que satisfaz a fórmula na teoria e satisfaz a estrutura booleana desse objetivo.  E com isso, o sistema pode voltar e dizer: "Sim, esta é a tarefa que satisfaz todas as suas limitações".  Essa é a interação entre o solucionador de teoria e o solucionador de SAT.  Na realidade, isso significa poder falar sobre fórmulas booleanas muito, muito grandes e muito complexas.  Aqui está o que torna possível a execução simbólica. <br><br>  Agora consideraremos a próxima pergunta - como é realizada a transição do programa para as restrições que podemos fornecer ao solucionador SMT. <br><br>  <b>Público:</b> está construindo um SMT solver NP-complete ou não? <br><br>  <b>Professor: O</b> solucionador SMT é essencialmente um problema canônico de NP-completo.  Mas a maioria dos solucionadores atualmente inclui suporte para certas teorias que são completamente insolúveis. <br><br>  <b>Público:</b> como você aborda esse problema no seu sistema? <br><br>  <b>Professor:</b> bem, no final, você receberá uma restrição criada a partir deste programa.  Você vai entregá-lo ao solucionador SMT.  E o fato de serem tarefas NP completas ou de serem insatisfatórias significa que, se você tiver sorte, receberá uma resposta em questão de segundos.  Mas se você não tiver sorte, pode levar mais tempo do que a criação do universo levou. <br><br><img src="https://habrastorage.org/webt/ji/zl/eb/jizlebbqvbb7ni0w0snmlsx_dqm.jpeg"><br><br>  <b>Público:</b> acontece que as tarefas do sistema linear não passam no SAT? <br><br>  <b>Professor:</b> sim, isso realmente acontece.  No entanto, as ferramentas de engenharia existentes o tornam menos comum.  Não resolvemos problemas aleatórios de SAT, não resolvemos problemas completamente aleatórios de vetores de bits. <br><br>  Resolvemos problemas que possuem uma certa estrutura para que uma pessoa possa observá-la e ter alguma confiança de que ela funcionará.  Estamos tentando criar alguns argumentos em sua cabeça para entender por que isso funcionou.  E os solucionadores SAT usam essa estrutura.  Seu problema pode ter um milhão de variáveis ​​booleanas, mas, na realidade, a maioria dessas variáveis ​​depende muito dos valores uma da outra.  Assim, o número de graus de liberdade no problema é realmente muito menor do que o que milhões de variáveis ​​sugerem. <br><br>  <b>Público:</b> você diz que não se trata de uma pergunta do exame, mas da vida real.  Uma vez que alguém tenha construído esse sistema, ele deve funcionar e fazer sentido.  Portanto, esse provavelmente não será um dos discursos teóricos desnecessários. <br><br>  <b>Professor:</b> é isso.  Portanto, na prática, quando você usa essa ferramenta, o que você sempre faz é definir tempos limite.  Em geral, tudo acontece porque a exponencialidade não significa que você não pode fazer isso.  Exponencialidade, isto é, quando uma função é limitada por outra, significa simplesmente que existe uma parede de tijolos à frente da qual essas coisas funcionarão, e elas funcionarão muito rapidamente.  A exponencialidade funciona em ambas as direções. <br><br><img src="https://habrastorage.org/webt/tm/yu/3j/tmyu3janxuwwu_ghngg9srbpg-0.jpeg"><br><br>  Quando você se afasta dessa parede, as coisas crescem muito rapidamente, mas quando você aborda problemas menores ou mais simples, esses problemas também aceleram muito, muito rapidamente.  Isso significa que muitos problemas terminam muito rapidamente.  E então ocorre o tempo limite do problema.  O objetivo é projetar coisas para que entre os problemas que terminam rapidamente estejam os que trazem benefícios práticos.  Esses são os problemas que apontam para as vulnerabilidades de segurança do seu sistema, para erros, para caminhos que você talvez não tenha explorado antes ou para entradas que violem seus caminhos se você não as investigar previamente. <br><br>  Então, sabemos como passar de uma fórmula, de um conjunto de restrições para uma resposta que diz: "Sim, essa fórmula tem uma solução, e aqui está, essa é uma solução".  Ou ele dirá: "essa fórmula é insatisfatória, porque não há dados que satisfaçam suas tarefas".  Então, como obtemos a fórmula do programa? <br><br>  Ao executar a execução simbólica, você vai para o ramo e não sabe em qual direção ele irá.  Existem duas opções para o que fazer neste caso.    —  ,      ,             ,        . <br><br>  ,   ,         .   ,          SMT-.         .   ,               . <br><br>      : «   ,          ,     ,     ,      ». <br><br>      ,     ,      .         .  ,     . <br><br>   ,   . ,     ,   . ,     –       ,        .        ?    ,     . <br><br><img src="https://habrastorage.org/webt/ty/jk/r0/tyjkr0wfkidwul4c72ksygznaky.jpeg"><br><br>     ,     ,    t=0    false. <br><br><img src="https://habrastorage.org/webt/9b/vk/fq/9bvkfq3d5pjdx1hvldxuu6sidvq.jpeg"><br><br>   ,    ,       ?       : ,      ,    . <br><br>  ,  ,      ,    ,   ,            ,     . <br><br>   ,     ,    t = 0,    x, y  0.       ,       . ,         ,  X ,  Y. <br><br>  ,      X &gt; Y. <br><br><img src="https://habrastorage.org/webt/px/us/2m/pxus2m_qn9igfcjvipllca7-juk.jpeg"><br><br> 55:00  <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> MIT «  ».  10: « »,  3</a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/yRVZPvHYHzw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  A versão completa do curso está disponível <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br> ,    .    ?     ?       , <b>30%        entry-level ,      :</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps  $20     ?</a> (   RAID1  RAID10,  24    40GB DDR4). <br><br>  <b>VPS (KVM) E5-2650 v4 (6 núcleos) 10GB DDR4 240GB SSD de 1Gbps até dezembro de graça</b> quando pagar por um período de seis meses, você pode fazer o pedido <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br> <b>Dell R730xd  2  ?</b>    <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2  Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100   $249</a>    !</b>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   .  c   Dell R730xd 5-2650 v4  9000   ?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt425561/">https://habr.com/ru/post/pt425561/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt425551/index.html">Quem deve receber dinheiro com a venda de uma obra de arte criada pela AI?</a></li>
<li><a href="../pt425553/index.html">O que o conde de Monte Cristo pode nos dizer sobre segurança cibernética</a></li>
<li><a href="../pt425555/index.html">Charles Nutter sobre idiomas dinâmicos na JVM em jug.msk.ru</a></li>
<li><a href="../pt425557/index.html">Curso MIT "Segurança de sistemas de computadores". Palestra 10: Execução Simbólica, Parte 1</a></li>
<li><a href="../pt425559/index.html">Curso MIT "Segurança de sistemas de computadores". Aula 10: Execução Simbólica, Parte 3</a></li>
<li><a href="../pt425563/index.html">A Califórnia proíbe a venda de dispositivos IoT com ou sem senhas simples</a></li>
<li><a href="../pt425565/index.html">Matemática rápida de ponto fixo para aplicativos financeiros em Java</a></li>
<li><a href="../pt425569/index.html">Teste funcional do PWB</a></li>
<li><a href="../pt425571/index.html">Protegendo um servidor Web no Linux</a></li>
<li><a href="../pt425575/index.html">Neuroinflamação</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>