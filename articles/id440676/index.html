<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚚 🕜 🧗 Hari ketika Dodo berhenti. Script sinkron 📃 💇🏽 🕵🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dodo IS adalah sistem global yang membantu Anda mengelola bisnis Anda secara efektif di Dodo Pizza. Itu menutup masalah pemesanan pizza, membantu pewa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hari ketika Dodo berhenti. Script sinkron</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dodopizzadev/blog/440676/">  Dodo IS adalah sistem global yang membantu Anda mengelola bisnis Anda secara efektif di Dodo Pizza.  Itu menutup masalah pemesanan pizza, membantu pewaralaba melacak bisnis, meningkatkan efisiensi karyawan, dan kadang-kadang jatuh.  Yang terakhir adalah yang terburuk bagi kita.  Setiap menit dari kejatuhan seperti itu menyebabkan hilangnya keuntungan, ketidakpuasan pengguna, dan malam pengembang yang tidak bisa tidur. <br><br>  Tapi sekarang kita tidur lebih nyenyak.  Kami belajar mengenali skenario kiamat sistemik dan memprosesnya.  Di bawah ini saya akan memberi tahu Anda bagaimana kami memberikan stabilitas sistem. <br><img src="https://habrastorage.org/webt/cj/_g/bz/cj_gbzxwy6ky8m_qqomj46f4nf4.png"><br><a name="habracut"></a><blockquote> <b>Serangkaian artikel tentang runtuhnya sistem Dodo IS *</b> : <br>  1. Hari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ketika Dodo berhenti.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Script sinkron.</a> <br>  2. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hari ketika Dodo berhenti.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Skrip asinkron.</a> <br><br>  * <i>Materi ditulis berdasarkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kinerja saya di DotNext 2018 di Moskow</a></i> . </blockquote><br><h2>  Dodo adalah </h2><br>  Sistem ini merupakan keunggulan kompetitif waralaba kami, karena franchisee mendapatkan model bisnis yang sudah jadi.  Ini adalah ERP, HRM dan CRM, semuanya dalam satu. <br><br>  Sistem muncul beberapa bulan setelah pembukaan restoran pizza pertama.  Ini digunakan oleh manajer, pelanggan, kasir, juru masak, pembeli misteri, karyawan pusat panggilan - itu saja.  Secara konvensional, Dodo IS dibagi menjadi dua bagian.  Yang pertama adalah untuk pelanggan.  Ini termasuk situs web, aplikasi seluler, pusat kontak.  Yang kedua untuk mitra franchisee, ini membantu mengelola pizzeria.  Melalui sistem, faktur dari pemasok, manajemen personalia, karyawan yang mengambil giliran kerja, akunting penggajian otomatis, pelatihan online untuk personel, sertifikasi manajer, sistem kontrol kualitas, dan pembeli misterius melewati sistem. <br><br><h2>  Kinerja sistem </h2><br>  Kinerja Sistem Dodo IS = Keandalan = Toleransi / Pemulihan Kesalahan.  Mari kita bahas masing-masing poin. <br><br><h4>  Keandalan </h4><br>  Kami tidak memiliki perhitungan matematis yang besar: kami perlu melayani sejumlah pesanan, ada zona pengiriman tertentu.  Jumlah pelanggan tidak terlalu bervariasi.  Tentu saja, kita akan bahagia ketika itu tumbuh, tetapi ini jarang terjadi dalam ledakan besar.  Bagi kami, kinerja bermuara pada beberapa kegagalan yang terjadi, hingga keandalan sistem. <br><br><h4>  Toleransi kesalahan </h4><br>  Satu komponen mungkin tergantung pada komponen lain.  Jika kesalahan terjadi dalam satu sistem, subsistem lainnya tidak boleh jatuh. <br><br><h4>  Ketangguhan </h4><br>  Kegagalan komponen individu terjadi setiap hari.  Ini normal.  Penting seberapa cepat kita pulih dari kegagalan. <br><br><h2>  Skenario Kegagalan Sistem Sinkron </h2><br><h4>  Apa ini </h4><br>  Naluri bisnis besar adalah melayani banyak pelanggan secara bersamaan.  Seperti halnya mustahil untuk bekerja di restoran pizza dapur yang bekerja untuk pengiriman dengan cara yang sama seperti ibu rumah tangga di dapur di rumah, kode yang dirancang untuk eksekusi sinkron tidak dapat bekerja dengan sukses untuk layanan pelanggan massal di server. <br><br>  Ada perbedaan mendasar antara mengeksekusi algoritma dalam satu instance, dan mengeksekusi algoritma yang sama sebagai server dalam kerangka layanan massal. <br><br>  Lihatlah gambar di bawah ini.  Di sebelah kiri, kita melihat bagaimana permintaan terjadi antara dua layanan.  Ini adalah panggilan RPC.  Permintaan berikutnya berakhir setelah yang sebelumnya.  Jelas, pendekatan ini tidak skala - pesanan tambahan berbaris. <br><br>  Untuk melayani banyak pesanan, kami membutuhkan opsi yang tepat: <br><br><img src="https://habrastorage.org/webt/ce/ux/u0/ceuxu0aoqpmcgvnuvj0oboctjdm.png"><br><br>  Pengoperasian kode pemblokiran dalam aplikasi sinkron sangat dipengaruhi oleh model multithreading yang digunakan, yaitu preemptive multitasking.  Itu saja dapat menyebabkan kegagalan. <br><br>  Multitasking sederhana dan preemptive dapat diilustrasikan sebagai berikut: <br><br><img src="https://habrastorage.org/webt/k_/i3/pi/k_i3piihcieztws0hjgt-l6jw1q.png"><br><br>  Blok warna adalah pekerjaan nyata yang dilakukan CPU, dan kami melihat bahwa pekerjaan bermanfaat yang ditunjukkan oleh warna hijau dalam diagram cukup kecil terhadap latar belakang umum.  Kita perlu membangkitkan arus, menidurkannya, dan ini di atas kepala.  Tidur / bangun seperti itu terjadi selama sinkronisasi pada primitif sinkronisasi apa pun. <br><br>  Jelas, kinerja CPU akan menurun jika Anda mencairkan pekerjaan yang bermanfaat dengan sejumlah besar sinkronisasi.  Seberapa kuat multitasking dapat mempengaruhi kinerja? <br><br>  Pertimbangkan hasil tes sintetis: <br><br><img src="https://habrastorage.org/webt/k5/vo/bh/k5vobhcdjza0tu5-gz5nkmxb2yu.png"><br><br>  Jika interval aliran antara sinkronisasi sekitar 1000 nanodetik, efisiensinya cukup kecil, bahkan jika jumlah utas sama dengan jumlah inti.  Dalam hal ini, efisiensinya sekitar 25%.  Jika jumlah Thread 4 kali lebih besar, efisiensi turun drastis, menjadi 0,5%. <br><br>  Pikirkan tentang hal itu, di cloud Anda memesan mesin virtual dengan 72 core.  Harganya uang, dan Anda menggunakan kurang dari setengah inti.  Inilah yang dapat terjadi dalam aplikasi multi-utas. <br><br>  Jika ada lebih sedikit tugas, tetapi durasinya lebih lama, efisiensinya meningkat.  Kami melihat bahwa pada 5.000 operasi per detik, dalam kedua kasus efisiensi adalah 80-90%.  Untuk sistem multiprosesor, ini sangat bagus. <br><br><img src="https://habrastorage.org/webt/mk/h0/ku/mkh0kui8a2xqylkxs4obdexrpms.png"><br><br>  Dalam aplikasi nyata kami, durasi satu operasi antara sinkronisasi terletak di antara keduanya, sehingga masalahnya sangat mendesak. <br><br><h4>  Apa yang sedang terjadi </h4><br>  Perhatikan hasil stress testing.  Dalam hal ini, yang disebut "pengujian ekstrusi." <br><br><img src="https://habrastorage.org/webt/bs/cc/pu/bsccpuz17k6921f54mhkjzg3p_k.png"><br><br>  Inti dari pengujian ini adalah bahwa dengan menggunakan dudukan beban, kami mengirimkan semakin banyak permintaan buatan ke sistem, mencoba menempatkan sebanyak mungkin pesanan per menit.  Kami mencoba menemukan batas setelah mana aplikasi akan menolak untuk melayani permintaan di luar kemampuannya.  Secara intuitif, kami mengharapkan sistem berjalan hingga batasnya, mengabaikan permintaan tambahan.  Inilah yang akan terjadi dalam kehidupan nyata, misalnya - ketika melayani di restoran yang penuh dengan pelanggan.  Tetapi sesuatu yang lain terjadi.  Pelanggan membuat lebih banyak pesanan, dan sistem mulai melayani lebih sedikit.  Sistem mulai melayani pesanan sangat sedikit sehingga dapat dianggap sebagai kegagalan total, kerusakan.  Ini terjadi dengan banyak aplikasi, tetapi haruskah itu terjadi? <br><br>  Pada grafik kedua, waktu untuk memproses permintaan bertambah, selama interval ini lebih sedikit permintaan yang dilayani.  Permintaan yang tiba lebih awal dilayani jauh kemudian. <br><br><img src="https://habrastorage.org/webt/au/ho/9y/auho9yjcdbtb8gqqbjytppvyuc0.png"><br><br>  Mengapa aplikasi berhenti?  Ada algoritma, itu berhasil.  Kami memulainya dari mesin lokal kami, ini bekerja sangat cepat.  Kami berpikir bahwa jika kami mengambil mesin seratus kali lebih kuat dan menjalankan seratus permintaan yang sama, maka itu harus dijalankan dalam waktu yang bersamaan.  Ternyata permintaan dari klien yang berbeda bertabrakan.  Di antara mereka, Pertentangan muncul dan ini merupakan masalah mendasar dalam aplikasi terdistribusi.  Permintaan terpisah memperebutkan sumber daya. <br><br><h2>  Cara menemukan masalah </h2><br>  Jika server tidak berfungsi, pertama-tama kami akan mencoba mencari dan memperbaiki masalah sepele dari kunci di dalam aplikasi, dalam database dan selama file I / O.  Masih ada seluruh kelas masalah dalam jaringan, tetapi sejauh ini kami akan membatasi diri pada ketiga hal ini, ini cukup untuk belajar bagaimana mengenali masalah yang sama, dan kami terutama tertarik pada masalah yang menyebabkan Pertentangan - perjuangan untuk sumber daya. <br><br><h4>  Kunci dalam proses </h4><br>  Berikut adalah permintaan khas dalam aplikasi pemblokiran. <br><img src="https://habrastorage.org/webt/xn/za/vw/xnzavw3w6riwwwnd9tblut9pj0m.png"><br>  Ini adalah variasi dari Sequence Diagram yang menggambarkan algoritma untuk interaksi kode aplikasi dan database sebagai hasil dari beberapa operasi bersyarat.  Kami melihat bahwa panggilan jaringan sedang dibuat, kemudian sesuatu terjadi dalam database - database sedikit digunakan.  Kemudian permintaan lain dibuat.  Untuk seluruh periode, transaksi dalam database dan kunci umum untuk semua permintaan digunakan.  Itu bisa dua pelanggan yang berbeda atau dua pesanan yang berbeda, tetapi satu dan objek menu restoran yang sama, disimpan dalam database yang sama dengan pesanan pelanggan.  Kami bekerja menggunakan transaksi untuk konsistensi, dua kueri memiliki Contention pada kunci dari objek umum. <br><br>  Mari kita lihat bagaimana skala. <br><img src="https://habrastorage.org/webt/ej/wl/s1/ejwls1dfpfr0hzq-ysxsvakwm9m.png"><br>  Utas tidur sebagian besar waktu.  Dia, pada kenyataannya, tidak melakukan apa pun.  Kami memiliki kunci yang mengganggu proses lainnya.  Yang paling menjengkelkan adalah bahwa operasi yang paling tidak berguna dalam transaksi yang mengunci kunci terjadi di awal.  Ini memperpanjang ruang lingkup transaksi dalam waktu. <br><br>  Kami akan bertarung dengan cara ini. <br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fallback = FallbackPolicy&lt;OptionalData&gt; .Handle&lt;OperationCancelledException&gt;() .FallbackAsync&lt;OptionalData&gt;(OptionalData.Default); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> optionalDataTask = fallback .ExecuteAsync(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> CalculateOptionalDataAsync()); <span class="hljs-comment"><span class="hljs-comment">//… var required = await CalculateRequiredData(); var optional = await optionalDataTask; var price = CalculatePriceAsync(optional, required);</span></span></code> </pre> <br>  Ini adalah Konsistensi Akhirnya.  Kami berasumsi bahwa beberapa data kami mungkin kurang terkini.  Untuk melakukan ini, kita perlu bekerja dengan kode secara berbeda.  Kami harus menerima bahwa data memiliki kualitas yang berbeda.  Kami tidak akan melihat apa yang terjadi sebelumnya - manajer mengubah sesuatu di menu atau klien mengklik tombol "checkout".  Bagi kami, tidak ada bedanya siapa di antara mereka yang menekan tombol dua detik sebelumnya.  Dan untuk bisnis tidak ada perbedaan. <br><br>  Tidak ada perbedaan, kita bisa melakukan hal seperti itu.  Menyebutnya dengan syarat opsional Data.  Yaitu, beberapa nilai yang bisa kita lakukan tanpanya.  Kami memiliki fallback - nilai yang kami ambil dari cache atau meneruskan beberapa nilai default.  Dan untuk operasi yang paling penting (variabel yang diperlukan) kami akan menunggu.  Kami akan menunggunya dengan tegas, dan hanya setelah itu kami akan menunggu jawaban atas permintaan untuk data opsional.  Ini akan memungkinkan kami untuk mempercepat pekerjaan.  Ada poin penting lainnya - operasi ini mungkin tidak dilakukan sama sekali karena beberapa alasan.  Misalkan kode untuk operasi ini tidak optimal, dan saat ini ada bug.  Jika operasi gagal, lakukan fallback.  Dan kemudian kita bekerja dengan ini seperti dengan makna yang biasa. <br><br><h4>  DB Locks </h4><br>  Kami mendapatkan kira-kira tata letak yang sama ketika kami menulis ulang di async dan mengubah model konsistensi. <br><img src="https://habrastorage.org/webt/aw/lq/xv/awlqxvspzylkqut1gklosn6pooi.png"><br>  Yang penting di sini bukanlah permintaannya menjadi lebih cepat.  Yang penting adalah kita tidak memiliki Pertengkaran.  Jika kami menambahkan permintaan, maka hanya sisi kiri gambar yang jenuh dengan kami. <br><img src="https://habrastorage.org/webt/_y/to/gz/_ytogzwl2pvkvzuxjy6mt365xnm.png"><br><br>  Ini permintaan pemblokiran.  Di sini Thread tumpang tindih dan tombol-tombol tempat Contention terjadi.  Di sebelah kanan, kami sama sekali tidak memiliki transaksi dalam basis data dan mereka dieksekusi dengan diam-diam.  Kasing yang tepat dapat bekerja dalam mode ini tanpa batas.  Kiri akan menyebabkan server mogok. <br><br><h4>  Sinkronkan io </h4><br>  Terkadang kita membutuhkan file log.  Anehnya, sistem logging dapat memberikan kegagalan yang tidak menyenangkan.  Latensi pada disk di Azure - 5 milidetik.  Jika kita menulis file secara berurutan, itu hanya 200 permintaan per detik.  Itu dia, aplikasi sudah berhenti. <br><img src="https://habrastorage.org/webt/4f/ye/oz/4fyeozpwhurta8vmpo6qelgvot4.png"><br><br>  Hanya saja rambut Anda berdiri ketika Anda melihat ini - lebih dari 2000 Thread telah berkembang biak dalam aplikasi.  78% dari semua Utas adalah tumpukan panggilan yang sama.  Mereka berhenti di tempat yang sama dan mencoba memasuki monitor.  Monitor ini membatasi akses ke file tempat kita semua masuk.  Tentu saja, ini harus dipotong. <br><img src="https://habrastorage.org/webt/ga/7f/27/ga7f27rhtreou-lssvsrcfjcvzo.png"><br>  Inilah yang perlu Anda lakukan di NLog untuk mengkonfigurasinya.  Kami membuat target yang tidak sinkron dan menulisnya.  Dan target asinkron menulis ke file nyata.  Tentu saja, kita dapat kehilangan sejumlah pesan dalam log, tetapi apa yang lebih penting untuk bisnis?  Ketika sistem jatuh selama 10 menit, kami kehilangan sejuta rubel.  Mungkin lebih baik kehilangan beberapa pesan di log layanan, yang mengalami kegagalan dan reboot. <br><br><h2>  Semuanya sangat buruk </h2><br>  Kontensi adalah masalah besar dalam aplikasi multi-utas, yang tidak memungkinkan Anda untuk hanya skala aplikasi utas tunggal.  Sumber Contention perlu dapat mengidentifikasi dan menghilangkan.  Sejumlah besar Utas merupakan bencana bagi aplikasi, dan pemblokiran panggilan harus ditulis ulang menjadi async. <br><br>  Saya harus menulis ulang banyak warisan dari pemblokiran panggilan di async, saya sendiri sering memulai upgrade semacam itu.  Cukup sering, seseorang datang dan bertanya: "Dengar, kami sudah menulis ulang selama dua minggu sekarang, hampir semuanya async.  Dan seberapa banyak itu akan bekerja lebih cepat? "  Kawan, saya akan mengecewakan Anda - itu tidak akan bekerja lebih cepat.  Itu akan menjadi lebih lambat.  Bagaimanapun, TPL adalah salah satu model kompetitif di atas yang lain - multitasking kooperatif atas multitasking preemptive, dan ini overhead.  Di salah satu proyek kami - sekitar + 5% untuk penggunaan CPU dan memuat di GC. <br><br>  Ada satu lagi berita buruk - aplikasi dapat bekerja jauh lebih buruk setelah hanya menulis ulang di async, tanpa menyadari fitur-fitur model kompetitif.  Saya akan berbicara tentang fitur-fitur ini dengan sangat rinci di artikel selanjutnya. <br><br>  Ini menimbulkan pertanyaan - apakah perlu menulis ulang? <br><br>  Kode sinkron ditulis ulang pada async untuk melepaskan ikatan model pelaksanaan kompetitif proses (Model Mata Uang), dan untuk menyingkirkan model Preemptive Multitasking.  Kami melihat bahwa jumlah Thread dapat mempengaruhi kinerja, sehingga Anda harus membebaskan diri dari kebutuhan untuk menambah jumlah Thread untuk meningkatkan Concurrency.  Meskipun kami memiliki Legacy, dan kami tidak ingin menulis ulang kode ini - ini adalah alasan utama untuk menulis ulang kode ini. <br><br>  Kabar baiknya pada akhirnya adalah bahwa kita sekarang tahu sesuatu tentang cara menyingkirkan masalah sepele dari Contention of blocking code.  Jika Anda menemukan masalah seperti itu di aplikasi pemblokiran Anda, maka sudah waktunya untuk menyingkirkannya sebelum menulis ulang ke async, karena di sana mereka tidak akan hilang dengan sendirinya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id440676/">https://habr.com/ru/post/id440676/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id440662/index.html">Bereaksi Tutorial Bagian 18: Fase Keenam Bekerja pada Aplikasi TODO</a></li>
<li><a href="../id440666/index.html">Klasifikasi gambar tulisan tangan. Laporkan dalam Yandex</a></li>
<li><a href="../id440670/index.html">Bank Sentral menerbitkan rekomendasi tentang perlindungan kriptografi EBS</a></li>
<li><a href="../id440672/index.html">Metode Rasionalitas dan Matras Doa Maghreb</a></li>
<li><a href="../id440674/index.html">Menggunakan grafik sebar untuk memvisualisasikan data</a></li>
<li><a href="../id440678/index.html">Hobi DIY CNC router. Humaniora untuk humaniora. Bagian 2</a></li>
<li><a href="../id440680/index.html">Cara menonton besok igrofikuyuchi</a></li>
<li><a href="../id440682/index.html">- Dan Anda membuat gas di sana dalam industri petrokimia, bukan?</a></li>
<li><a href="../id440688/index.html">PR di IT: bagaimana cara hidup, ke mana harus pergi?</a></li>
<li><a href="../id440690/index.html">Fitur bekerja dengan Mesh in Unity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>