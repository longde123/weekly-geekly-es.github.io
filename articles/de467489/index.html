<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñ•Ô∏è üîã ‚õàÔ∏è Sie sind seltsame statische Variablen in PHP ‚ñ´Ô∏è üôãüèø üßû</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Haftungsausschluss: Dieser Artikel offenbart Ihnen keinerlei Offenbarung und √∂ffnet nicht das dritte Auge, sondern erm√∂glicht es Ihnen, die nicht so o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sie sind seltsame statische Variablen in PHP</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467489/"><p> Haftungsausschluss: Dieser Artikel offenbart Ihnen keinerlei Offenbarung und √∂ffnet nicht das dritte Auge, sondern erm√∂glicht es Ihnen, die nicht so offensichtliche Frage genauer zu verstehen.  Zumindest als ich es schrieb, half sie mir dabei.  Wenn Sie ein erfahrener Wolf in PHP sind, dann k√∂nnen Sie es nicht lesen. Ich denke, es wird erfahrenen Menschen nicht schaden, durch ihre Augen zu rennen, sie sozusagen im Ged√§chtnis aufzufrischen, der Rest wird normal sein. </p><br><p>  Also ... </p><br><p>  Statische Variablen in PHP sind eine spezielle Art von Variablen, die mit dem <strong>Schl√ºsselwort static deklariert werden</strong> . </p><br><pre><code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $foo = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre> <br><p>  Sie unterscheiden sich von gew√∂hnlichen Variablen darin (sp√§ter in diesem Artikel werden diese Punkte genauer betrachtet): </p><br><ol><li>  Es k√∂nnen nur Konstanten und konstante Ausdr√ºcke zugewiesen werden </li><li>  Die Lebensdauer einer statischen Variablen ist nicht auf die Lebensdauer des Bereichs beschr√§nkt, in dem sie deklariert wurde </li><li>  kann nur einmal im Skript definiert werden </li><li>  erst am Ende des Skripts zerst√∂rt </li></ol><br><p>  Jetzt in Ordnung. </p><br><h4 id="1-mogut-byt-prisvoeny-tolko-konstanty-i-konstantnye-vyrazheniya">  1. Es k√∂nnen nur Konstanten und konstante Ausdr√ºcke zugewiesen werden </h4><br><p>  Dies bedeutet, dass das Ergebnis der Operation einer Funktion oder Methode keiner statischen Variablen oder im Allgemeinen allem zugewiesen werden kann, was in der Kompilierungsphase noch nicht bekannt ist.  Das hei√üt, eine solche Anzeige funktioniert nicht </p><a name="habracut"></a><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $var = foo();</code> </pre> <br><p>  aber es ist durchaus m√∂glich </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $var = <span class="hljs-string"><span class="hljs-string">'some str'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $varInt = <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><h4 id="2-vremya-zhizni-staticheskoy-peremennoy-ne-ogranicheno-vremenem-zhizni-oblasti-vidimosti-v-kotoroy-ona-obyavlena">  2. Die Lebensdauer einer statischen Variablen ist nicht auf die Lebensdauer des Bereichs beschr√§nkt, in dem sie deklariert ist </h4><br><p>  Ich werde versuchen zu erkl√§ren, was ich hier gemeint habe.  Vielleicht werde ich einige Ungenauigkeiten in der Terminologie machen, aber ich werde versuchen, die Essenz so genau wie m√∂glich zu vermitteln.  Vergleiche mit einer regul√§ren Variablen.  Wenn eine Variable innerhalb einer Funktion deklariert wird, handelt es sich standardm√§√üig um eine lokale Variable, dh sie wird im lokalen Bereich (Bereich dieser Funktion) deklariert.  In diesem Fall ist der Kontext dieser Funktion der lokale Bereich.  Nachdem die Funktion funktioniert und das Ergebnis zur√ºckgegeben hat, wird ihr Bereich oder ihr Kontext mit allen darin enthaltenen Variablen zerst√∂rt. </p><br><p>  Wenn wir eine statische Variable innerhalb der Funktion deklarieren, wird sie auch im lokalen Bereich deklariert, aber ihr Kontext ist nicht der lokale Bereich, sondern die Funktion selbst. </p><br><p>  (Ferner, der schwierigste Moment zu erkl√§ren, √ºbergebe ich nur die Essenz ohne Details, wie Funktionen in PHP deklariert werden, wie viel Speicher ihnen zugewiesen ist und was in diesem Speicher liegt).  Es stellt sich heraus, dass der Interpreter beim Aufrufen einer Funktion einen lokalen Bereich daf√ºr erstellt. Darin werden alle lokalen Variablen und Funktionen deklariert und hinsichtlich ihres Kontexts daran angeh√§ngt.  Durch Deklarieren einer Variablen im lokalen Bereich mit static wird die Funktion selbst dieser Variablen als Kontext zugewiesen, und diese Variable bleibt bestehen, solange die Funktion selbst vorhanden ist.  Dies ist so etwas wie js, wenn eine Funktion ein Objekt ist, dem Sie beliebige Eigenschaften und Methoden zuweisen k√∂nnen.  Auch hier ist nur eine Funktion in PHP ein Objekt nicht f√ºr PHP, sondern f√ºr eine niedrigere Sprache. </p><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">echoStaticVar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $var = <span class="hljs-number"><span class="hljs-number">0</span></span>; $var++; var_dump($var); }; echoStaticVar(); <span class="hljs-comment"><span class="hljs-comment">//1 echoStaticVar(); //2 echoStaticVar(); //3</span></span></code> </pre> <br><p>  Es ist ersichtlich, dass der Kollektor nach Beendigung der Funktion die Variable $ var nicht wie bei einer regul√§ren Variablen zerst√∂rt. </p><br><p>  Und hier ist ein Beispiel, das deutlich zeigt, dass eine statische Variable zu einer Funktion geh√∂rt (entweder ist sie in einer Funktion gespeichert oder ihr Kontext ist eine Funktion. Es tut mir leid, dass ich nicht wei√ü, wie ich sie richtig benennen soll). </p><br><pre> <code class="php hljs">$one = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $var = <span class="hljs-number"><span class="hljs-number">0</span></span>; $var += $i; var_dump($var); }; $two = $one; $one(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">//1 $one(5); //6 $one(5); //11 $two(5); //16 $two(5); //21</span></span></code> </pre> <br><p>  Alles funktioniert wie erwartet, denn wenn $ zwei = $ eins zugewiesen wird;  Die Funktion selbst wird nicht kopiert, aber diese beiden Variablen beziehen sich einfach auf denselben Speicherbereich.  Dementsprechend ist die statische Variable $ var sowohl f√ºr $ eins als auch f√ºr $ zwei eins </p><br><p>  Wir √§ndern das Beispiel ein wenig, n√§mlich wir weisen es nicht zu, aber wir klonen </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// $two = $one; // $two = clone($one);</span></span></code> </pre> <br><pre> <code class="php hljs">$one = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $var = <span class="hljs-number"><span class="hljs-number">0</span></span>; $var += $i; var_dump($var); }; $two = <span class="hljs-keyword"><span class="hljs-keyword">clone</span></span>($one); $one(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">//1 $one(5); //6 $one(5); //11 $two(5); //5 $two(5); //10</span></span></code> </pre> <br><p>  Nun stellte sich heraus, dass $ one und $ two nicht auf dieselbe Funktion mit einer statischen Variablen $ var verweisen, sondern auf zwei verschiedene Funktionen, die in unterschiedlichen Speicherbereichen liegen und jeweils eine eigene statische Variable $ var haben.  Dies ist kein besonders offensichtlicher Punkt, daher k√∂nnen Sie darauf sto√üen, wenn Sie Code in einem prozeduralen Stil schreiben, der wahrscheinlich bereits als schlechte Form angesehen wird, aber nicht korrekt ist. </p><br><p>  Was Sie damit machen k√∂nnen, ist ein klassisches Beispiel f√ºr einen Funktionsaufrufz√§hler. <br>  Aber im Zusammenhang mit der Verbreitung von OOP in dieser Form sind statische Variablen selten, da Sie grunds√§tzlich mit Klassen und Methoden arbeiten m√ºssen (ich werde einen separaten Artikel √ºber die Implementierung von statischen in ihnen schreiben). </p><br><h4 id="3-mogut-byt-opredeleny-v-skripte-lish-odnazhdy">  3. kann im Skript nur einmal definiert werden </h4><br><p>  Dies bedeutet, dass wenn eine statische Variable bereits deklariert ist und ihr ein Wert zugewiesen wurde, nachfolgende Zuweisungen den bereits zugewiesenen Wert nicht √ºberschreiben, sondern den vorhandenen zur√ºckgeben. </p><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">staticVar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $var = <span class="hljs-number"><span class="hljs-number">0</span></span>; $var += $i; var_dump($var); }; staticVar(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">//1 staticVar(5); //6 staticVar(5); //11</span></span></code> </pre> <br><p>  Es ist ersichtlich, dass wenn die statische Variable $ var jedes Mal einen neu zugewiesenen Wert h√§tte, wir immer das Ergebnis 1 erhalten w√ºrden. Da es jedoch bei der Neuzuweisung nicht neu geschrieben wird, erhalten wir das, was wir erhalten. <br>  Es stimmt, es gibt eine Sache, die alles ruinieren kann.  Im Rahmen einer Funktion (genauer gesagt beim ersten Aufruf der Funktion) kann eine solche Variable beliebig oft umgeschrieben werden (in den folgenden F√§llen funktioniert alles wie angegeben).  Dieses Verhalten kam mir seltsam und lustig vor, besonders wenn man mit Beispielen herumspielt. </p><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">staticVar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $var = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $var = <span class="hljs-number"><span class="hljs-number">5</span></span>; $var += $i; var_dump($var); }; staticVar(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">//6 staticVar(5); //11 staticVar(5); //16</span></span></code> </pre> <br><p>  Hier wurde die Variable <em>$ var</em> im ersten Aufruf der <em>staticVar-</em> Funktion in der ersten Zeile zugewiesen und in der zweiten Zeile √ºberschrieben.  Aber bereits in weiteren Anrufen, weder in der ersten noch in der zweiten Zeile, wurde sie neu zugewiesen, sondern gab zur√ºck, was bereits im vorherigen Anruf war </p><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">staticVar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $var = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// static $var = 5; //    $var += $i; static $var = 0; //    var_dump($var); }; staticVar(1); //1 staticVar(5); //6 staticVar(5); //11</span></span></code> </pre> <br><p>  Noch seltsamer beim ersten Aufruf von <em>staticVar</em> in der ersten Zeile wurde es zugewiesen, dann wurde es in der zweiten Zeile neu zugewiesen (aber erfolglos), dann wurde eine Additionsaktion damit ausgef√ºhrt, und danach wurde beim Versuch, es sogar innerhalb des ersten Funktionsaufrufs neu zuzuweisen, die bereits vorhandene zur√ºckgegeben ihre Bedeutung. </p><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">staticVarWrong</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $var = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $var = <span class="hljs-number"><span class="hljs-number">5</span></span>; $var += $i; var_dump($var); }; <span class="hljs-comment"><span class="hljs-comment">//  staticVarWrong(1); //6 staticVarWrong(5); //11 staticVarWrong(5); //16 function staticVarRight($i) { static $var = 0; static $var = 5; $var += $i; static $var = 0; //    var_dump($var); }; //  staticVarRight(1); //1 staticVarRight(5); //6 staticVarRight(5); //11</span></span></code> </pre> <br><p>  Das hei√üt, es stellt sich in fast den gleichen Methoden heraus, unterschiedliches Verhalten.  Basierend auf der Beschreibung, wie sich statische Variablen verhalten sollen, wird in <em>staticVarRight</em> das richtige Ergebnis erzielt.  In <em>staticVarWrong</em> stellt sich (basierend auf dem Verhalten der Funktion) heraus, dass in der zweiten Zeile der Funktion die Variable neu definiert wurde. <br>  Das hat mich ziemlich am√ºsiert. </p><br><h4 id="4-ne-unichtozhayutsya-do-konca-vypolneniya-skripta">  4. werden erst am Ende des Skripts zerst√∂rt </h4><br><p>  Ich sehe nicht viel Sinn darin, diesen Punkt zu erkl√§ren, zumal aus den Beispielen alles klar hervorgeht.  W√§hrend das Skript ausgef√ºhrt wird und eine Funktion vorhanden ist, f√ºr die eine statische Variable deklariert ist, ist diese Variable vorhanden. </p><br><p>  Wie geplant ist dies der erste Artikel √ºber <strong>statische</strong> , vor OOP, statische Felder und Methoden. <br>  Nun, nat√ºrlich, wenn es zumindest jemand ist, wird er interessiert und nicht schwer zu beschuldigen sein. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467489/">https://habr.com/ru/post/de467489/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467475/index.html">Geben Sie Thread.Abort () an .NET Core zur√ºck. Anwendungsbereitstellung mit der Version von CoreCLR und CoreFX</a></li>
<li><a href="../de467477/index.html">Kubernetes 1.16: Highlights √úbersicht</a></li>
<li><a href="../de467479/index.html">Kir Shatrov: Shopify hat mit Rails angefangen und hier lieben sie diesen Rahmen aufrichtig.</a></li>
<li><a href="../de467485/index.html">Probleml√∂sung mit pwnable.kr 23 - md5 Rechner. Wir besch√§ftigen uns mit Stack Canary. C-Bibliotheken in Python verbinden</a></li>
<li><a href="../de467487/index.html">√úber die Zukunft von Blockchain- und Kryptow√§hrungszahlungen</a></li>
<li><a href="../de467493/index.html">So werden Sie f√ºr einen potenziellen Angreifer im Internet weniger zug√§nglich. Pers√∂nliche Erfahrungen und Beobachtungen</a></li>
<li><a href="../de467495/index.html">Die Kosten f√ºr die Weiterleitung</a></li>
<li><a href="../de467497/index.html">Diebe verwenden Deepfakes, um Unternehmen dazu zu bringen, Geld an sich selbst zu senden</a></li>
<li><a href="../de467499/index.html">Nachrichten aus der Welt von OpenStreetMap Nr. 476 (28.08.2019 - 02.09.2019)</a></li>
<li><a href="../de467501/index.html">Implementierung in die Architektur der sowjetischen programmierbaren Taschenrechner "Electronics MK-52"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>