<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚Äçüíª üñ≤Ô∏è üë®üèø‚Äçü§ù‚Äçüë®üèº Softwareentwicklung f√ºr die Motorsteuerung DSP TMS320F28 üë®üèº‚Äç‚úàÔ∏è ‚öúÔ∏è üßöüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In meinem ersten Artikel habe ich √ºber diese Controller-Familie gesprochen, mehr als ein Dutzend Leute haben mir in PM mit Fragen dazu geschrieben, ob...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Softwareentwicklung f√ºr die Motorsteuerung DSP TMS320F28</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/410161/">  In meinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Artikel habe</a> ich √ºber diese Controller-Familie gesprochen, mehr als ein Dutzend Leute haben mir in PM mit Fragen dazu geschrieben, obwohl dies nicht das Thema des Artikels war.  Die Leute wollten kategorisch nicht zu Google gehen und sprachen √ºber den Mangel an Informationen.  Ich war ein wenig √ºberrascht und entschied mich zu √ºberpr√ºfen - tats√§chlich gibt es auf Russisch praktisch nichts in der C2000-Familie (vor dem Hintergrund von AVR, STM), und vor allem gibt es keine klaren Startanleitungen.  Informationen k√∂nnen auf Englisch gefunden werden, aber es reicht nicht aus.  F√ºr mich ist das etwas √ºberraschend, da diese Familie nicht wenige Jahre alt ist.  Daher wurde beschlossen, die Situation nach besten Kr√§ften zu beeinflussen. <br><br>  Wer braucht diese Steuerungen grunds√§tzlich ... M√∂chten Sie einen Schwei√üwechselrichter montieren?  Unterbrechungsfreie Stromversorgung?  Galvanisierbadgl√§tter?  Frequenz?  Ein Wechselrichter f√ºr alternative Energie?  CNC-Maschine?  Wenn es in mindestens einem Punkt um Sie geht, ist der Artikel Ihnen gewidmet! <br><br>  Andere Leser werden ebenfalls daran interessiert sein, mehr √ºber den "neu-alten" Controller zu erfahren, warum er ben√∂tigt wird und wie man damit arbeitet.  Diese Familie ist sehr einfach (viel einfacher als STM, LPC und andere Cortex), die Steine ‚Äã‚Äãsind leicht zu kaufen (es gibt auch Ali), sie erm√∂glichen es Ihnen, hochzuverl√§ssige industrielle L√∂sungen zu implementieren, auf deren Grundlage Sie fast jedes industrielle Steuerungssystem bauen k√∂nnen. <br><br>  Haben Sie bereits entschieden, dass dieser Controller Ihr Traum ist und bereit ist, in die Schlacht zu eilen?  Dann kaufen wir f√ºr 17 US-Dollar das folgende Debugging von F28027-LaunchPad: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ed/cd/cv/edcdcvjwp5ewu_jl0jbnwwzsfyc.png"></div><br>  Hast du gekauft  Jetzt kannst du in die Schlacht ziehen.  Wenn sich die Frage stellte, wo man "besser" und "billiger" kaufen kann, gehen wir zum offiziellen Laden.  Wir gehen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hierher</a> und sehen den Preis von 17 $.  F√ºr diesen Betrag erhalten Sie eine Original-Debugging-Geb√ºhr und eine Kurierzustellung an die T√ºr.  Ich habe einmal in China f√ºr die Lieferung bestellt, es stellte sich heraus, 16 $ und es ist mit einem Rabatt und einem Gutschein sowie einer "Bonus" -Reise zur Post.  Daher empfehle ich es ist der Beamte.  Lass uns gehen! <br><a name="habracut"></a><br><h2>  √úbersicht √ºber die C2000-Serie </h2><br>  Sie k√∂nnen auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Website</a> nat√ºrlich alles auf Englisch am ausf√ºhrlichsten lesen.  Ich werde kurz dar√ºber sprechen und meine Gedanken √ºber die Anwendung zum Ausdruck bringen.  Bitte beachten Sie, dass dies nur meine Spekulation ist und sie nicht die Wahrheit behaupten. <br><br>  Zun√§chst ein paar Worte zum C2000 im Allgemeinen.  Besondere Merkmale der Familie, die mit ihrem Hauptzweck der Motorsteuerung verbunden sind, sind das Vorhandensein von HRPWM (hochpr√§zises PWM) und CLA (Coprozessor).  Letzteres fehlt beim j√ºngsten Piccolo TMS320F2802x wirklich, wird dort aber nicht ben√∂tigt, Hauptsache HRPWM.  Was ist das? HRPWM selbst ist ein regul√§res PWM, es ist nur sehr genau und die Aufzeichnungs- und Einstellzeit f√ºr einen neuen Arbeitszyklus ist erheblich schneller.  Dies erm√∂glicht es beispielsweise, einen perfekt geformten Sinus in einem DC / AC-Wechselrichter zu erhalten oder Schrittmotoren in einer CNC-Maschine mit sehr hoher Genauigkeit zu steuern. <br><br>  CLA ist im Wesentlichen ein vollwertiger Kern, hat jedoch keinen Zugriff auf Peripherieger√§te, sondern nur auf den Hauptkern und den Speicher.  Es dient dazu, den Hauptkern vom Computing zu entlasten.  Dieser Coprozessor verarbeitet Float-Daten sehr einfach und auf nat√ºrliche Weise. Dies ist wichtig, wenn verschiedene Algorithmen, Filter und mehr implementiert werden. <br><br><img src="https://habrastorage.org/webt/5o/ui/lh/5ouilh691kdhoflkcrtcs4tmwqy.png"><br><br>  Ich werde √ºber zwei Hauptfamilien sprechen, denen Sie wahrscheinlich begegnen werden: <br><br><ul><li>  <b>Piccolo.</b>  Die j√ºngsten Controller, aber auch die billigsten.  Mein TMS320F28027 stammt aus dieser Familie.  Wenn Sie sich f√ºr die Entwicklung von Leistungselektronik f√ºr kommerzielle Zwecke entscheiden, sind dies Ihre Hauptsteine ‚Äã‚Äã- sie sind recht billig, kostenpflichtig (LQFP, QFN, TSSOP) und erm√∂glichen es Ihnen, fast alles zu implementieren.  Zum Beispiel reicht ihre Leistung f√ºr einen zweiphasigen PFC, einen Wechselrichter f√ºr Solarmodule, einen Frequenzumrichter bis 10 kW mit Vektorsteuerung usw. aus.  Wie Sie sehen, handelt es sich um ein Produktsegment, das von normalen Menschen und Unternehmen gekauft wird, was bedeutet, dass es sehr gefragt ist.  Die Hauptbeschr√§nkungen sind die Frequenz von 60 MHz, eine begrenzte Anzahl von PWM-Kan√§len. </li><li>  <b>Delfino.</b>  Ideologisch sind dies alle die gleichen Piccolo, nur mit Meldonium aufgeblasen.  In dem, was es ausdr√ºckt - einer Frequenz von bis zu 200 MHz, gibt es in √§lteren Steinen bereits 2 vollwertige Kerne + 2 Coprozessoren, gro√üe Geh√§use und dementsprechend viele Beine, viele PWM-Kan√§le, viele ADCs und im Allgemeinen viel.  Das hei√üt, in √§lteren Steinen haben wir 4 Kerne mit einer Frequenz von 200 MHz, eine Leistung von 800 MIPS, was ziemlich beeindruckend ist.  Diese Leistung kann auf verschiedene Arten verwendet werden, aber die Hauptanwendung sind algorithmisch komplexe Systeme, zum Beispiel der Vienne-Gleichrichter oder etwas anderes.  Auf einer solchen Steuerung k√∂nnen Sie auch das gesamte Steuerungssystem f√ºr eine CNC-Maschine implementieren, z. B. Fr√§sen oder Flammenschneiden von Metall. </li></ul><br><h2>  Finalisierung des Debugboards </h2><br>  Wenn Sie eine Box mit einer Debug-Karte erhalten, finden Sie den fehlenden Quarz und die Kondensatoren.  Sie sind nicht notwendig, aber es ist ratsam zu dope.  Ich habe keinen Quarz mehr im HC-49, also musste ich ihn mir von einem Freund ausleihen.  Er w√§hlt AVR und STM, also hat er nur 8 MHz gefunden.  Gel√∂tet.  Ich habe 22 pF Kondensatoren aus dem alten Speicher hinzugef√ºgt, wie ich es bei Mega in der Schule getan habe. <br><br>  Diese L√∂sung ist nicht die beste und h√§ngt mit der PLL-Konfiguration zusammen.  Der maximale Multiplikator f√ºr PLL ist x12 (mehr kann sein, wird aber nicht empfohlen und funktioniert schief).  Die maximale Frequenz betr√§gt 60 MHz.  Der Maximalwert des Teilers am PLL-Ausgang betr√§gt 3. Die Frequenz des Quarzes betr√§gt 8 MHz.  Ich kann nicht mit 8 mit einer ganzen Zahl multiplizieren und 60 erhalten. Wir suchen nach dem n√§chsten Gesamtwert, in diesem Fall 240. Das hei√üt, ich werde 8 mit 30 multiplizieren und dann durch 4 dividieren, um die begehrten 60 MHz zu erhalten, aber das Problem ist, dass der x30-PLL-Multiplikator nicht akzeptabel ist , divider / 4 ist ebenfalls nicht verf√ºgbar.  Es gibt zwei Auswege: <br><br><ul><li>  <b>Schlecht:</b> Multiplizieren Sie die Frequenz von 8 MHz mit 7 und dividieren Sie durch 1 und erhalten Sie 56 MHz.  Sie k√∂nnen mit 8 multiplizieren und 64 MHz erhalten, es wird stabil funktionieren, aber in beiden F√§llen betr√§gt die Frequenz nicht maximal 60 MHz.  Leider nicht genug Perfektionismus.  Ich habe gerade eine solche Option, 8 MHz gel√∂tet und eine Frequenz von 56 MHz gemacht. </li><li>  <b>Gut:</b> Kaufen Sie Quarz bei 10 oder 20 MHz (besser als 10) und multiplizieren Sie mit 6, dividieren Sie durch 1, wir erhalten die gesch√§tzten 60 MHz.  Ich lebe au√üerhalb der Stadt und ehrlich gesagt war es zu faul, in ein lokales Gesch√§ft zu gehen, in dem es keine Tatsache ist, dass es 10-MHz-Quarz gibt.  Nat√ºrlich werden sowohl die interne RC-Schaltung als auch der 8-MHz-Quarz f√ºr das Training verwendet, aber in Ihren zuk√ºnftigen Projekten sollten Sie den 10-MHz-Quarz und nicht die Mammutmutanten in das HC-49-Paket aufnehmen. </li></ul><br><h2>  Architektur und periphere Merkmale </h2><br>  Alles, was als n√§chstes passieren wird, gilt f√ºr den TMS320F28027-Controller.  Schauen wir uns zun√§chst die Struktur aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenblatt an</a> : <br><br> <a href=""><img src="https://habrastorage.org/webt/sr/da/hb/srdahbswvkrs9zjzbnvevwgqvho.png"></a> <br><br>  Das erste, worauf Sie achten sollten, ist, dass RAM in drei Sektoren unterteilt ist: M0, M1 und SARAM.  Das Volumen dieser Speichersektoren betr√§gt in unserem Fall 1k, 1k und 4k.  Es ist erw√§hnenswert, dass in diesem Fall das Wort nicht 8 Bit, sondern 16 Bit ist, dh in einer bekannteren Form 2 kB + 2 kB + 8 kB.  Die Besonderheit dieses Moduls besteht darin, dass die Sektoren M0 und M1 schneller sind als die verbleibenden 8 kB RAM.  Formal k√∂nnen Sie dies als Cache verwenden.  Die Sektoren M0 und M1 speichern normalerweise die am h√§ufigsten verwendeten Daten sowie die Daten, die f√ºr die Speicherleistung am kritischsten sind.  Standardm√§√üig k√∂nnen wir den Linker verwenden, um anzugeben, was und wo gespeichert wird. Ich werde dieses Thema in diesem Artikel jedoch nicht ansprechen. Hier wird mindestens ein separater Artikel ben√∂tigt. <br><br>  Das zweite wichtige Merkmal ist, dass alle Peripherieger√§te vom Systembus getaktet werden, d. H. Von 60 MHz (in meinem Fall 56 MHz).  Als Beispiel gebe ich die STM32-Mikrocontroller an, bei denen die Kernfrequenz beispielsweise 180 MHz f√ºr F4 betr√§gt, die Peripherieger√§te jedoch √ºber eine Reihe von Teilern getaktet sind.  Ich nenne diesen Ansatz f√ºr mich ‚ÄûFake Megahertz‚Äú, obwohl dies sehr √ºbertrieben ist.  Daher sind 60 MHz f√ºr TMS320F28 und 180 MHz f√ºr stm32 nicht so unterschiedlich, und wenn Sie sich an das Vorhandensein von CLA erinnern, sind 60 + 60 MHz zumindest vergleichbar.  Es ist klar, dass ein solcher Vergleich nicht korrekt ist, aber es macht deutlich, dass nicht nur Megahertz voll ist. <br><br>  Ebenfalls ein interessanter Punkt - achten Sie auf die allgemeine Struktur: HRPWM, ADCs, Komparatoren mit internem DAC, Encoder Processing Module (eCAP) ... Ein fertiger Frequenzumrichter mit Vektorsteuerung in seiner reinen Form!  Das ist die ganze Essenz dieser Familie - der Minimalismus.  Einerseits ist die Peripherie im Vergleich zu Cortex eher schlecht, andererseits reicht es aus, einen Frequenzumrichter, Gleichstrom / Gleichstrom, Gleichstrom / Wechselstrom und einen Schrittmotortreiber zu implementieren.  Aus diesem Grund ist die Arbeit mit den TMS320F28-Controllern sehr einfach, verst√§ndlich und nicht mit unn√∂tigen Aktionen √ºberlastet.  Aber wenn Sie pl√∂tzlich 3 UARTs ben√∂tigen und f√ºr sie ein Paar i2c und 3 weitere SPIs, dann sind diese Controller definitiv nichts f√ºr Sie - sie haben unterschiedliche Aufgaben. <br><br><h2>  Entwicklungsumgebung </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5v/vc/iv/5vvcivdcbwzulr9uocxmccv-ba0.png"></div><br>  Haben Sie sich das Splash-Logo angesehen?  Erinnere dich an sie.  Wenn Sie sich entscheiden, Artikel f√ºr die Entwicklung der Helden des Artikels zu verwenden, geh√∂rt diese Software Ihnen, und wie Sie sehen, hei√üt die <b>Software controlSUITE</b> . <br><br>  Diese Anwendung ist eine Sammlung und Bibliothek von allem, was Sie zur Entwicklung von Software f√ºr die Controller-Familie C2000 ben√∂tigen.  Die Installation dieser Anwendung ist das erste, was Sie tun m√ºssen, um ihre Zusammensetzung zu sehen. Sie enth√§lt: <br><br><ul><li>  Beschreibung aller vorhandenen Controller und darauf basierenden Debug-Boards.  Schaltungsquellen, Leiterplatten, St√ºcklisten haupts√§chlich in Altium Designer </li><li>  Beispiele f√ºr Schaltungen und Design von Leiterplatten </li><li>  Kernbibliotheken f√ºr die Firmware-Entwicklung </li><li>  Mathematik- und DSP-Bibliotheken, auch zur Verwendung mit CLA </li><li>  Ein Beispiel f√ºr Softwareprojekte f√ºr jeden Peripherietyp </li><li>  Eine gro√üe Anzahl von Apnouts f√ºr die Implementierung der meisten Algorithmen zur Steuerung von Motoren, DC / DC-Wandlern, MPPT-Controllern und anderen Systemen </li><li>  Eine Reihe von Programmen, mit denen Sie ein Motormanagementsystem ohne Programmierung erstellen k√∂nnen, indem Sie einfach eine grafische Umgebung verwenden </li><li>  Die IDE selbst, die entwickelt wird </li></ul><br>  Alles, was ich oben beschrieben habe, ist sehr kurz und bescheiden.  Es dauert einige Wochen, bis Sie mindestens diagonal sehen und scrollen.  Nat√ºrlich werden Sie zu Beginn nicht die meisten dieser Datenmengen ben√∂tigen, aber Sie m√ºssen sich merken, wohin Sie gehen m√ºssen, wenn etwas f√ºr Sie unverst√§ndlich und ausgefallen ist. <br><br>  Was wir heute arbeiten werden, ist die IDE, deren grafischer Teil auf der Basis der bekannten Eclipse basiert.  Der Compiler ist kein GCC, sondern ein eigener aus Texas, der meiner subjektiven Meinung nach definitiv besser ist als der erste.  Obwohl es den Verdacht gibt, dass dies trotzdem gr√ºndlich dotiert ist.  Die Entwicklungsumgebung hei√üt <b>Code Composer Studio</b> , die aktuelle Version 7.4. <br><br><h2>  Projekterstellung </h2><br>  Zuerst wollte ich eine Aufgabe implementieren, die mit dem ersten Artikel identisch ist, dh einen Sinus zeichnen.  Im Rahmen eines Artikels h√§tte dies im Prinzip getan werden k√∂nnen, wobei ein Rahmen eine sehr gro√üe Menge kleiner Dinge zur√ºckgelassen h√§tte, aber wie Sie wissen, liegt die Essenz genau in kleinen Dingen.  Es gibt mehrere Artikel √ºber das TMS im Internet, aber sie sind alle sehr oberfl√§chlich und f√ºhren zu der Art ‚Äûkopiere dies und alles funktioniert‚Äú, dh der Prozess selbst und die Ideologie werden √ºberhaupt nicht ber√ºcksichtigt.  Daher werden wir im Rahmen dieses Artikels ein Projekt erstellen, unn√∂tige Komponenten entfernen, die Firmware im Flash-Speicher des Controllers konfigurieren und lernen, wie man mit GPIO arbeitet. Diese sind hier sehr interessant. <br><br>  Laden Sie CCS7 von der Website des Herstellers herunter, installieren Sie das Projekt und erstellen Sie es wie gewohnt: <i>Datei ‚Üí Neu ‚Üí CCS-Projekt ...</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wb/v0/jy/wbv0jyccatp8jysn2nckh7qaooc.png"></div><br>  Wir sehen dieses Fenster und m√ºssen darin den Controller ausw√§hlen, der uns interessiert. In meinem Fall ist es TMS320F28027, den Namen des Projekts angeben und den Pfad vorgeben, in dem es gespeichert wird.  Zuerst m√ºssen Sie einen Ordner erstellen, in dem das Projekt gespeichert wird.  Der Projektname und der Ordnername stimmen m√∂glicherweise nicht √ºberein.  Klicken Sie auf die Schaltfl√§che <i>Fertig stellen</i> und unser Projekt wird erstellt. <br><br>  Jetzt m√ºssen Sie unser Projekt mit Inhalten f√ºllen und verbinden.  Erstellen Sie zuvor folgende Ordner, um die Struktur des Projekts zu verbessern: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ee/cg/er/eecgerskm0jeso2ocebvaheeyrc.png"></div><br><ul><li>  <i>inc</i> - Ein Ordner, der alle Header-Dateien enth√§lt </li><li>  <i>system_inc</i> - In diesem Abschnitt werden die Header-Dateien der Standardbibliotheken gespeichert. Die Dateien, die wir selbst erstellen, z. B. main.c, befinden sich im Ordner inc.  Dies wird nicht etwas gedankenlos brechen oder unn√∂tig entfernen </li><li>  <i>src</i> - Ordner mit allen Quellen </li><li>  <i>system_src</i> - Ordner mit Quelldateien f√ºr Standardbibliotheken </li></ul><br>  Bitte beachten Sie, dass diese Struktur kein Dogma ist, sondern nur meine Idee der Bestellung.  Obwohl ich es Leuten mit minimaler Erfahrung empfehlen werde, werden Sie es im Laufe der Zeit √§ndern, um es Ihrem Weltbild anzupassen, aber im Moment wird dies die Anzahl der Pfosten minimieren. <br><br>  Erstellen Sie nun die Datei main.h im Ordner inc und verbinden Sie sie mit main.c.  Durch sie werden die Basisbibliotheken verbunden.  Bevor Sie mit dem √úbertragen von Bibliotheken und anderen Dateien beginnen, schreiben Sie den Pfad zu den Ordnern auf, in denen unsere zuk√ºnftigen Header-Dateien in den Projekteinstellungen gespeichert werden.  Klicken Sie dazu mit der rechten Maustaste auf das Projekt (Test) in der Projektstruktur und klicken Sie unten auf <i>Eigenschaften</i> oder dr√ºcken <i>Sie</i> einfach <i>Alt + Eingabetaste</i> .  Gehen Sie im folgenden Fenster zu <i>Build ‚Üí C2000 Compiler ‚Üí Include Options</i> und schlie√üen Sie hier zwei vorhandene Pfade ein - registrieren Sie den Pfad zu den Ordnern inc und system_inc.  Klicken Sie auf <i>Hinzuf√ºgen</i> , dann auf <i>Arbeitsbereich</i> und dann auf den gew√ºnschten inc-Ordner. Machen Sie dasselbe und klammern Sie sich an den zweiten Ordner.  Daher haben wir relative Pfade vorgeschrieben. Wenn Sie ein Projekt √ºbertragen, m√ºssen Sie nichts neu konfigurieren.  Als Ergebnis erhalten wir ein solches Bild und klicken auf <i>OK</i> : <br><br><img src="https://habrastorage.org/webt/2x/nd/ql/2xndqlhcm5szyalytbw6oeseyka.png"><br><br>  Jetzt haben wir ein leeres Projekt mit den vorgeschriebenen Pfaden und anderen Einstellungen, es bleibt nur, um es mit Bibliotheken zu f√ºllen.  Sie m√ºssen nur pr√ºfen, ob alles angeschlossen ist.  Theoretisch sollten Sie einen solchen Code und ein Bild erhalten, das Projekt kompilieren.  Dr√ºcken Sie dazu <i>STRG + B</i> oder gehen Sie oben zu <i>Projekt ‚Üí Alle</i> erstellen.  Das Projekt sollte fehlerfrei kompiliert werden und so aussehen (das Bild ist anklickbar): <br><br> <a href=""><img src="https://habrastorage.org/webt/0b/hv/ur/0bhvurabfuhr1-6lqjgzn4svzp0.png"></a> <br><br>  Lassen Sie uns nun ein wenig √ºber den Linker sprechen.  Beim Erstellen eines Projekts generiert die IDE zun√§chst die Datei <i>28027_RAM_lnk.cmd</i> und legt unser Programm w√§hrend des Debuggens und der Firmware im RAM ab.  Dies ist praktisch, wenn wir debuggen, weil  Flash-Speicherressourcen werden nicht verschwendet und das Debuggen im RAM ist erheblich schneller.  Aber was ist, wenn wir Blitz einn√§hen wollen?  Zu diesem Zweck gibt es eine weitere Linkdatei, die unser Programm in Flash platziert.  Ich werde diese Option zeigen. <br><br>  L√∂schen Sie zun√§chst die Datei <i>28027_RAM_lnk.cmd</i> .  Wie gesagt - <b>controlSUITE ist</b> unser Alles.  Wir √∂ffnen es.  Gehen Sie nun zu <i>Englisch ‚Üí Ger√§t ‚Üí Piccolo F2802x ‚Üí Unterst√ºtzende Bibliotheken ‚Üí Header-Dateien f√ºr F28027x</i> .  Rechts sehen wir Ordner - dies sind die Standardbibliotheken und alles, was ben√∂tigt wird, einschlie√ülich Linker.  Jetzt gehen wir zum Ordner <i>f2802x_common ‚Üí cmd</i> und hier sehen wir eine Reihe von Linkern f√ºr alle Steine ‚Äã‚Äãin der Linie.  Es ist nicht schwer, die _RAM-Dateien zum Hochladen von Code in den Arbeitsspeicher und ohne dieses Tag zum Hochladen √ºber Flash zu erraten.  Wir nehmen die Datei <i>F28027.cmd</i> und kopieren sie in unser Projekt anstelle des alten Remote-Linkers. <br><br>  Jetzt ist es Zeit, die Bibliotheken selbst zu migrieren.  Wir gehen zum Ordner <i>f2802x_common ‚Üí source</i> und sehen eine Reihe von Dateien.  Es gibt zwei Arten von Bibliotheken: Standardregister (√§hnlich wie CMSIS) und eine Art SPL.  In diesem Fall interessiert uns nur die erste Ansicht, <i>dh</i> Dateien mit dem Pr√§fix <i>f2802x_</i> .  Nat√ºrlich k√∂nnen Sie alle in unser Projekt ziehen, aber warum sollten Sie es verstopfen, wenn wir nicht alles verwenden?  Wenn Sie etwas brauchen, f√ºgen wir es in Zukunft einfach hinzu.  Im Moment beschr√§nken wir uns auf folgende Dateigruppen: <br><br><ul><li>  <i>f2802x_codestartbranch.asm</i> </li><li>  <i>f2802x_defaultisr.c</i> </li><li>  <i>f2802x_piectrl.c</i> </li><li>  <i>f2802x_pievect.c</i> </li><li>  <i>f2802x_sysctrl.c</i> </li></ul><br>  Wir kopieren die <i>Datendatei</i> und f√ºgen sie in unseren Ordner <i>system_src ein</i> .  Nun gehen wir zum Ordner <i>f2802x_headers ‚Üí source</i> und nehmen von dort die Datei <i>F2802x_GlobalVariableDefs.c</i> und kopieren sie erneut in unseren Ordner <i>system_src</i> .  <i>Wechseln Sie als</i> N√§chstes zum Ordner <i>f2802x_headers ‚Üí cmd</i> und kopieren Sie die Datei <i>F2802x_Headers_nonBIOS.cmd</i> von dort in denselben Ordner.  Damit ist das Ausf√ºllen des Ordners <i>system_src abgeschlossen</i> und Sie k√∂nnen mit den Headern fortfahren. <br><br>  Wir gehen in den Ordner <i>f2802x_headers ‚Üí include</i> und kopieren alle Dateien von dort in unseren Ordner <i>system_inc</i> .  Nun gehen wir zum Ordner <i>f2802x_common ‚Üí source</i> und kopieren die Dateien von dort: <br><br><ul><li>  <i>f2802x_examples.h</i> </li><li>  <i>f2802x_globalprototypes.h</i> </li><li>  <i>f2802x_i2c_defines.h</i> </li><li>  <i>f2802x_epwm_defines</i> </li><li>  <i>f2802x_swprioritizedisrlevels.h</i> </li><li>  <i>f2802x_defaultisr.h</i> </li></ul><br>  Wir sollten dieses Bild im Projektbaum bekommen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jw/tu/h-/jwtuh-pssz-pn5_ynxlxugmijtw.png"></div><br>  Jetzt m√ºssen Sie die <i>Basisbibliotheken verbinden. Die</i> Datei <i>main.h</i> hat die folgende Form: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"F2802x_Device.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"F2802x_examples.h"</span></span></span></span></code> </pre> <br>  Wir versuchen zu kompilieren.  Wenn das Projekt ohne Fehler und Warnungen kompiliert wurde, ist alles korrekt verbunden.  Wenn dies nicht geschehen ist, √ºberpr√ºfen Sie alle 10 Male, und wenn es √ºberhaupt nicht funktioniert, schreiben Sie an die PM - ich werde helfen, wie Owl sagte: <i>"Baz-woz-mEz-bottom, das hei√üt umsonst</i> . <i>"</i> <br><br><h2>  Initialisierung der Steuerung und des Taktsystems </h2><br>  In diesem Abschnitt schreiben wir eine Funktion, die den Watchdog-Timer und die Interrupt-Vektoren initialisiert und die Interrupt-Flags auf Null setzt.  Wir haben auch das Taktsystem eingerichtet, wodurch der externe Quarz anstelle der internen RC-Kette zur Taktquelle wird, die PLL konfiguriert und die Taktung f√ºr alle Peripherieger√§te aktiviert. <br><br>  F√ºr die Genauigkeit des Codes schlage ich vor, alle grundlegenden Initialisierungen in einer separaten Datei <i>abzulegen</i> , deren Frontend die Funktion <i>void InitStartSystem (void) sein wird</i> .  Erstellen Sie dazu die Dateien <i>systemInitStart.h</i> und <i>systemInitStart.c</i> .  Ich werde sofort eine Funktion schreiben und dann analysieren wir einfach ihren Inhalt: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitStartSystem</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ DisableDog(); XtalOscSel(); InitPll(TMS320_PLLCR, TMS320_DIVSEL); InitPeripheralClocks(); InitPieCtrl(); InitPieVectTable(); }</code> </pre><br>  Alle Funktionen, die in <i>InitStartSystem ()</i> aufgerufen werden, sind Standard.  Ich rate Ihnen, im Detail zu sehen, wie sie implementiert werden. Dazu k√∂nnen Sie die STRG-Taste gedr√ºckt halten und auf die gew√ºnschte Funktion klicken.  Hast du geschaut?  Jetzt kurz durchgehen ... <br><br><ul><li>  <i>DisableDog ()</i> - Die Funktion schaltet den "Hund" aus.  Dies ist ein obligatorischer Schritt beim Einrichten des Hauptteils kritischer Peripherieger√§te, z. B. eines Taktsystems.  Im Bibliothekscode, den Sie h√§ufig sehen, wird er dupliziert und dupliziert </li><li>  <i>XtalOscSel ()</i> - Diese Funktion implementiert das Umschalten von einer internen Taktquelle auf einen externen Quarz.  <b>Ein wichtiger Punkt!</b>  Bei dieser Funktion liegt ein Fehler in der Standardbibliothek vor - sie wird nicht deklariert.  Wir gehen zur Datei <i>f2802x_globalprototypes.h</i> und <i>f√ºgen</i> unter allen anderen die Zeile <i>extern void XtalOscSel (void) hinzu.</i> <br><br><img src="https://habrastorage.org/webt/3l/vv/yv/3lvvyvwdfpwbqpek6bphfkheapu.png"><br><br>  <b>Der zweite wichtige Punkt!</b>  Gehen Sie zur XtalOscSel-Funktion und l√∂schen Sie die Verz√∂gerungsfunktion. <br><br><img src="https://habrastorage.org/webt/ve/iq/iw/veiqiwa2locaclbj2-xfbpiakpe.png"><br><br>  <b>Der dritte wichtige Punkt!</b>  Wir gehen zur Datei <i>f28027x_exmaples.h</i> und kommentieren die Verz√∂gerungsimplementierungsfunktion aus. <br><br><img src="https://habrastorage.org/webt/t7/jk/jp/t7jkjpu3nbgcqlqt5aolaniwqxg.png"><br></li><li>  <i>InitPll (TMS320_PLLMUL, TMS320_DIVSEL)</i> - Die Funktion konfiguriert die PLL.  Es werden 2 Werte √ºbertragen: Multiplikator und Divisor.  Ihr Wert wird in der Header-Datei angegeben.  <b>Ein wichtiger Punkt!</b>  Wir √∂ffnen diese Funktion in der Bibliothek und Sie m√ºssen die Verz√∂gerung ganz unten auskommentieren <br><br><img src="https://habrastorage.org/webt/mg/up/gi/mgupgi_vhx8hvcvg3tgaqsxaxas.png"></li><li>  <i>InitPll (TMS320_PLLMUL, TMS320_DIVSEL)</i> - Die Funktion konfiguriert die PLL.  Es werden 2 Werte √ºbertragen: Multiplikator und Divisor.  Ihr Wert wird in der Header-Datei angegeben.  <b>Ein wichtiger Punkt!</b>  Wir √∂ffnen diese Funktion in der Bibliothek und Sie m√ºssen die Verz√∂gerung ganz unten auskommentieren </li><li>  <i>InitPeripheralClocks ()</i> - Diese Funktion <i>aktiviert</i> einfach die Taktung f√ºr die gesamte Peripherie.  Ja f√ºr alle.  C2000 ist keine L√∂sung f√ºr batteriebetriebene Verschraubungen. <br>  Diese L√∂sung von Einheiten-Zehntausenden von Kilowatt und erb√§rmlichen 2-3 mA wird hier keine Rolle spielen.  Nun, Sie m√ºssen sich nicht jedes Mal daran erinnern, wenn Sie die Uhr f√ºr eine Art SPI eingeschaltet haben oder nicht </li><li>  <i>InitPieCtrl ()</i> - Die Funktion <i>deaktiviert</i> alle Interrupts und setzt Interrupt-Flags zur√ºck </li><li>  <i>InitPieVectTable ()</i> - Die Funktion f√ºllt die Tabelle mit Interruptvektoren </li></ul><br>  Eigentlich ist hier alles Initialisierung.  Ich denke, viele haben die ‚Äûwichtigen Punkte‚Äú bemerkt, die mit der <i>Verz√∂gerungsfunktion verbunden</i> sind.  Warum haben wir es am Rebstock geschnitten?  Ja, alles ist einfach - es ist eine Kr√ºcke. <br><br>  Die TI-Ingenieure haben diese v√∂llig unn√∂tigen Verz√∂gerungen zu einigen Funktionen hinzugef√ºgt, die in den letzten Updates hinzugef√ºgt wurden.  Warum - ein R√§tsel nicht nur f√ºr mich.  Register und andere kritische Eintr√§ge sind bereits gesch√ºtzt, sodass unser Controller nicht dumm wird.  √úbrigens ist es bei der Initialisierung in der Leistungselektronik unm√∂glich, √ºberhaupt zu "stumpfen", sonst sind es Weichlinge.  Vergessen Sie daher f√ºr immer die <i>Verz√∂gerungsfunktionen</i> und andere Teufelei, nur Timer!  Verz√∂gerungen sind nur f√ºr bestimmte Bildungszwecke zul√§ssig, z. B. schnelles Blinken mit einer LED. <br><br>  Um zu √ºberpr√ºfen, ob der Code funktioniert, rufen wir die Initialisierungsfunktion in main auf, kompilieren, <b>flashen</b> und schlie√üen das <b>GPIO18-</b> Oszilloskop an.  Dieser Pin √§hnelt dem MCO des STM32, dh er gibt die Systemfrequenz aus.  Ein Oszilloskop sollte ein Signal mit einer Frequenz von 56 MHz sehen.  Wenn das Oszilloskop gut ist, sehen Sie den M√§ander, wenn die Chinesen (sogar gut), dann ist es h√∂chstwahrscheinlich etwas n√§her am Sinus.  Das Einstellen von GPIO18 zur Ausgabe der <i>Systemfrequenz wird</i> in der Funktion <i>InitPeripheralClocks () angezeigt</i> .  Zuerst m√ºssen Sie gpio an den Frequenzausgang ‚Äûanschlie√üen‚Äú und dann den Teiler auf 1 setzen: <br><br><pre> <code class="cpp hljs"> GpioCtrlRegs.GPAMUX2.bit.GPIO18 = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">// GPIO18 = XCLKOUT SysCtrlRegs.XCLK.bit.XCLKOUTDIV=2; // Set XCLKOUT = SYSCLKOUT/1</span></span></code> </pre><br><h2>  GPIO-Setup </h2><br>  Um mit dieser Familie arbeiten zu k√∂nnen, ben√∂tigen wir nur ein Referenzhandbuch, das die TI-Entwickler in mehrere Dateien unterteilt haben, von denen jede eine bestimmte Peripherie beschreibt, was sehr praktisch ist.  Laden Sie das Datenblatt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> herunter und gehen Sie zum Abschnitt <i>Dokumentationsunterst√ºtzung</i> auf Seite 126. Hier sehen Sie eine Reihe von Links zur Dokumentation mit ihrer kurzen Beschreibung: Errata, eine Anleitung zum Starten der Motorverwaltung und Anleitungen f√ºr jede Peripherie.  Wir sind an einem Dokument mit dem Namen <b>TMS320F2802x / TMS320F2802xx Piccolo-Referenzhandbuch f√ºr Systemsteuerung und Interrupts</b> interessiert. Es enth√§lt die Beschreibung des GPIO und andere grundlegende Systemeinstellungen, die uns interessieren.  Wir betrachten das GPIO-Blockdiagramm: <br><br> <a href=""><img src="https://habrastorage.org/webt/vp/uu/29/vpuu29qhryyngpm2thgtvtquoeo.png"></a> <br><br>  Wir sehen ein ziemlich bekanntes Bild der Eingangs- / Ausgangsanschl√ºsse des Ger√§ts.  Hier und die M√∂glichkeit, den internen Hosentr√§ger einzuschalten, und die Verwendung eines Signals mit GPIO f√ºr Interrupts und andere Annehmlichkeiten.  Das Hauptmerkmal dieses Peripherieger√§ts im C2000 ist die M√∂glichkeit der Unterdr√ºckung von Hardware-Interferenzen, beispielsweise das Klappern mechanischer Kontakte einer Taste.  Schauen wir uns ein interessantes Diagramm an: <br><br><img src="https://habrastorage.org/webt/gu/zj/ym/guzjymm5gq08m1gar1284zobjx8.png"><br><br>  Es zeigt das Prinzip des Lesens des Status von Eingaben.  In den meisten Controllern wird der Eingangszustand mit der Taktfrequenz dieser Peripherie gelesen, dh in unserem Fall standardm√§√üig mit einer Frequenz von 56 MHz, und bei gleichem stm in den √§lteren Familien sind diese Frequenzen sogar noch h√∂her.  Ich denke, jeder versteht, dass der Controller bei einer solchen Frequenz Zeit hat, St√∂rungen und Ger√§usche zu ‚Äûsehen‚Äú.  Manchmal wird eine solche Frequenz ben√∂tigt, und manchmal nicht, zum Beispiel, wenn wir eine Schaltfl√§che abfragen m√ºssen.  Warum sollten wir sie alle 18 ns interviewen?  Daher haben wir die M√∂glichkeit erkannt, die Taktfrequenz eines bestimmten Ports mithilfe des <i>CTRL-</i> Registers und der <i>QUALPRDx-</i> Bits zu <i>reduzieren</i> , wobei X einen Wert von 0 bis 3 annimmt: QUALPRD0 ist f√ºr GPIO0 ... 7 verantwortlich, QUALPRD1 ist f√ºr GPIO8 ... 15 usw. verantwortlich.  Tats√§chlich ist dies ein gew√∂hnlicher Frequenzteiler mit einem Koeffizienten von 1 bis 510. <br><br><img src="https://habrastorage.org/webt/a5/ro/9e/a5ro9eq9hvvmomonnkm8ggkxzcq.png"><br><br>  Es macht oft keinen Sinn, eine Taste abzufragen, daher stellen wir den Teiler auf 510 ein, dh auf das Maximum.  Wir sehen uns das Diagramm noch einmal an und sehen, dass das Signal nur dann als stabil angesehen wird, wenn sein Pegel f√ºr 6 Ticks unver√§ndert war.  Die Anzahl der zur Fixierung erforderlichen Ma√ünahmen kann 1, 3 oder 6 <b>betragen</b> . <b>Je gr√∂√üer der Teiler und je mehr Zyklen wir fixieren, desto stabiler ist der Schutz vor Rattern.</b>  Wenn es zu einem Rattern von Kontakten kommt, handelt es sich zun√§chst um chaotische √úberg√§nge von 0 nach 1 und umgekehrt. Wenn das Rattern vorbei ist und das Signal stoppt und sich f√ºr 6 Takte nicht √§ndert, bedeutet dies, dass die Taste gedr√ºckt wird.  Alles Geniale ist einfach. <br><br>  Schauen wir uns nun die Hauptregister an, wir werden keine Interrupts ber√ºhren - nur die Einstellungen der Ports selbst.  Zuerst m√ºssen Sie sagen, dass die Register in zwei Typen unterteilt sind: <b>Setup-</b> <b>Register</b> und <b>Datenregister</b> .  Erstere sind f√ºr die Konfiguration von Eigenschaften verantwortlich, beispielsweise dieser Eingabe oder Ausgabe.  Die zweite Gruppe ist f√ºr das Schreiben und Lesen des Portstatus verantwortlich. <br><br>  <u>Setup-Register:</u> <br><br><ul><li>  <i>GPxCTRL</i> - Register zum Schreiben des <i>Taktteilers</i> .  Anstelle von "x" ersetzen wir den Buchstaben "A" - wenn wir GPIO0 ... 31 haben, "B" - wenn wir GPIO32 ... 63 verwenden und so weiter </li><li>  <i>GPAQSELx</i> - Register zum Einstellen der Anzahl der Ticks zum Festlegen des Werts am Eingang </li><li>  <i>GPAMUX1</i> ist ein Register zur Auswahl angeschlossener Peripherieger√§te. Es zeigt beispielsweise an, dass GPIO oder UART oder m√∂glicherweise PWM zum Fu√ü kommen. </li><li>  <i>GPADIR</i> - GPIO-Richtungsauswahlregister: Ein- oder Ausgang.  Standardm√§√üig sind alle Ports f√ºr die Eingabe konfiguriert. </li><li>  <i>GPAPUD</i> ist das Register, das f√ºr den Anschluss des internen Hosentr√§gers an VCC verantwortlich ist. <br>  Es ist anzumerken, dass f√ºr einige Ports das Pull-up standardm√§√üig deaktiviert und f√ºr einen Teil aktiviert ist. <br>  Dies ist wichtig zu beachten! </li></ul><br>  <u>Datenregister:</u> <br><br><ul><li>  <i>GPADAT</i> - Ausgangsstatusregister.  Wenn der Ausgang f√ºr die Eingabe konfiguriert ist, lesen wir daraus den Eingabestatus.  Wenn es f√ºr eine Ausgabe konfiguriert ist, k√∂nnen wir den Wert aufschreiben, den diese Ausgabe annehmen soll, dh 0 oder 1 </li><li>  <i>GPASET</i> - Register, das den Ausgang auf "1" setzt.  Um auf "1" zu setzen, m√ºssen Sie "1" schreiben. Wenn Sie "0" schreiben, wird der Befehl ignoriert </li><li>  <i>GPACLEAR</i> - Register, das den Ausgang auf "0" setzt.  Um auf "0" zu setzen, m√ºssen Sie "1" schreiben. Wenn Sie "0" schreiben, wird der Befehl ignoriert </li><li>  <i>GPATOGGLE</i> ist ein Register, das den aktuellen Wert des Ausgangszustands invertiert.  Um den Wert zu invertieren, schreiben Sie "1". Wenn Sie "0" schreiben, wird der Befehl ignoriert </li></ul><br>  Hier ist so ein einfacher Satz von Registern.  Selbst anhand der obigen Beschreibung k√∂nnen Sie bereits verstehen, was zur Konfiguration des Ports getan werden muss, aber die umsichtigen Ingenieure oder technischen Redakteure von TI haben eine weitere schrittweise Anleitung gegeben: <br><br><img src="https://habrastorage.org/webt/ly/tx/mk/lytxmkk_nwnp8qzigdzblyywwx8.png"><br><br>  Ich werde gleich sagen, dass die Schritte 6 und 7 f√ºr uns nicht notwendig sind, weil  In diesem Artikel werden weder der Hund noch die Unterbrechung verwendet.  Ich werde die verbleibenden Schritte f√ºr Leute, die in der Schule Deutsch gelernt haben, kurz beschreiben: <br><br><ul><li>  <i>Schritt 1</i> - Bestimmen Sie die Ausgabefunktionalit√§t: dass es sich um eine Eingabe oder Ausgabe handelt, <br>  GPIO oder Ausgabe an andere Peripherieger√§te und so </li><li>  <i>Schritt 2</i> - Aktivieren oder Deaktivieren des internen Pullups </li><li>  <i>Schritt 3</i> - Konfigurieren Sie den Takt- und Sprungschutz f√ºr einen bestimmten Port </li><li>  <i>Schritt 4</i> - W√§hlen Sie die gew√ºnschte Funktion: GPIO oder Peripherieger√§te </li><li>  <i>Schritt 5</i> - Stellen Sie die Ausgaberichtung ein: Eingabe oder Ausgabe </li></ul><br>  Das ist das ganze Setup, wie Sie sehen, es ist elementar und logisch klar.  Ich m√∂chte sofort darauf hinweisen, dass es in dieser Reihenfolge nicht erforderlich ist, Einstellungen vorzunehmen. Sie k√∂nnen beispielsweise die Richtung (Eingabe oder Ausgabe) bereits im ersten Schritt festlegen.  Es spielt keine Rolle. <br><br>  <b>Super wichtig!</b> <br><br>  Bei der Arbeit mit Registern der C2000-Familie muss der Zeitpunkt ber√ºcksichtigt werden, zu dem sie gesch√ºtzt sind.  Alles, was unten beschrieben wird, gilt haupts√§chlich f√ºr die Register der Konfigurationsgruppe.  Wenn Sie sich die Standardfunktionen genau angesehen haben, haben Sie dort wahrscheinlich seltsame Befehle gesehen: <b>EALLOW;</b>  und <b>EDIS;</b>  .  Befehl <i>EALLOW</i> - <i>Entfernt</i> den Schutz und erm√∂glicht den Zugriff auf die Arbeit mit Systemregistern.  <i>EDIS-</i> Befehl - <i>Aktiviert</i> den R√ºckenschutz und erm√∂glicht den Zugriff auf die Arbeit mit Systemregistern.  Das hei√üt, jede Arbeit mit Systemregistern sollte IMMER so aussehen: <br><br><pre> <code class="cpp hljs">EALLOW; <span class="hljs-comment"><span class="hljs-comment">//    ,   ,  EDIS;</span></span></code> </pre><br>  Eine solche Operation ist nicht erforderlich, wenn wir mit Datenregistern arbeiten. Wenn wir beispielsweise unseren Ausgang mithilfe des <i>GPxSET-</i> Registers auf ‚Äû1‚Äú <i>setzen</i> , m√ºssen wir den Schutz nicht entfernen und ihn dementsprechend wieder einschalten.  In der Dokumentation steht √ºberall, was gesch√ºtzt werden muss und was nicht, zum Beispiel so: <br><br><img src="https://habrastorage.org/webt/ly/tx/mk/lytxmkk_nwnp8qzigdzblyywwx8.png"><br><br>  Basierend auf all dem oben Genannten konfigurieren wir GPIO0 ... 3 mit LEDs f√ºr die Ausgabe.  Ich schlage vor, alle GPIO-Einstellungen in die <i>InitLEDgpio-</i> Funktion zu setzen und zu schreiben: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitLEDgpio</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ EALLOW; GpioCtrlRegs.GPADIR.bit.GPIO0 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO2 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO3 = <span class="hljs-number"><span class="hljs-number">1</span></span>; EDIS; }</code> </pre><br>  Standardm√§√üig sind unsere GPIOs bereits als GPIOs konfiguriert  Alle Registerwerte werden gel√∂scht, was bedeutet, dass ‚Äû0‚Äú bereits in das GPAMUX1-Register geschrieben wurde.  F√ºr GPIO0 ... 11 ist das Pull-up standardm√§√üig deaktiviert, sodass wir die Arbeitsrichtung zum Ausgang nur mit GPADIR bestimmen k√∂nnen.  Wenn Sie sich erinnern, sind die LEDs √ºber Kathoden mit dem Controller verbunden, was bedeutet, dass sie unmittelbar nach der Initialisierung leuchten.  Setzen wir diese Schlussfolgerungen direkt in der Initialisierungsfunktion auf ‚Äû1‚Äú: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitLEDgpio</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ EALLOW; GpioCtrlRegs.GPADIR.bit.GPIO0 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO2 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO3 = <span class="hljs-number"><span class="hljs-number">1</span></span>; EDIS; GpioDataRegs.GPASET.bit.GPIO0 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioDataRegs.GPASET.bit.GPIO1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioDataRegs.GPASET.bit.GPIO2 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioDataRegs.GPASET.bit.GPIO3 = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br>  Wie Sie sehen k√∂nnen, verwende ich das <i>GPADAT-</i> Register nicht zum Schreiben, sondern <i>SET, CLEAR, TOGGLE</i> .  Beachten Sie auch, dass ich diesen Eintrag au√üerhalb der Schutzzone vorgenommen habe, <i>dh</i> nach dem <i>EDIS-</i> Befehl.  Konfigurieren Sie nun in derselben Funktion GPIO12 so, dass es mit der Schaltfl√§che funktioniert, und f√ºgen Sie unsere Funktion hinzu: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitLEDgpio</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ EALLOW; GpioCtrlRegs.GPADIR.bit.GPIO0 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO2 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO3 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPAPUD.bit.GPIO12 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPACTRL.bit.QUALPRD1 = <span class="hljs-number"><span class="hljs-number">0xFF</span></span>; GpioCtrlRegs.GPAQSEL1.bit.GPIO12 = <span class="hljs-number"><span class="hljs-number">2</span></span>; EDIS; GpioDataRegs.GPASET.bit.GPIO0 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioDataRegs.GPASET.bit.GPIO1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioDataRegs.GPASET.bit.GPIO2 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioDataRegs.GPASET.bit.GPIO3 = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br>  Zun√§chst schalte ich die interne <i>Verschraubung aus</i> , indem ich "1" in das <i>GPAPUD-</i> Register <i>schreibe</i> , weil  Es ist standardm√§√üig von GPIO12 aktiviert.  Wie ich bereits geschrieben habe, sind alle Ports nach der Initialisierung f√ºr die Eingabe als konfiguriert  Nullen werden in das <i>GPADIR-</i> Register geschrieben, wir konfigurieren es hier nicht. <br><br>  Es bleibt die Konfiguration des <i>Sprungschutzes</i> zu konfigurieren, dazu teilen wir die Teiler <i>0xFF</i> , die dem Wert / 510 entsprechen.  In das Register <i>GPAQSEL1</i> schreiben wir den Wert ‚Äû10‚Äú oder 2, wodurch der Wert auf eine Stichprobe von 6 Takten gesetzt wird.  Fertig!  Um den Wert einer bestimmten Eingabe zu lesen, m√ºssen Sie nur den Wert aus dem <i>GPADAT-</i> Register lesen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GpioDataRegs.GPADAT.bit.GPIO12) { <span class="hljs-comment"><span class="hljs-comment">//      +3.3 (. 1)  ,     }</span></span></code> </pre><br>  So hinterfragen wir die notwendigen Schlussfolgerungen.  Rufen wir nun die GPIO-Konfigurationsfunktion in unserer Hauptfunktion auf und erhalten ihre endg√ºltige Form: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitStartSystem</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ DisableDog(); XtalOscSel(); InitPll(TMS320_PLLMUL, TMS320_DIVSEL); InitPeripheralClocks(); InitPieCtrl(); InitPieVectTable(); <span class="hljs-comment"><span class="hljs-comment">/*********************************/</span></span> InitLEDgpio(); }</code> </pre><br>  Jetzt rufen wir die <i>InitStartSystem-</i> Funktion im Hauptteil des Programms in main auf und damit ist die Konfiguration abgeschlossen.  Wir erhalten folgenden Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main (void) { InitStartSystem(); while(1) { } }</span></span></code> </pre><br>  Es ist Zeit, unser erstes Testprogramm zu schreiben und das Ganze zu testen.  Der Algorithmus lautet wie folgt: Die LED auf GPIO3 blinkt, und wenn Sie die Taste auf GPIO12 dr√ºcken, leuchtet die GPIO0-LED einfach auf.  Daher werden wir die Funktion der Ports sowohl f√ºr die Eingabe als auch f√ºr die Ausgabe √ºberpr√ºfen.  Wir schreiben den folgenden Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main (void) { InitStartSystem(); while(1) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (GpioDataRegs.GPADAT.bit.GPIO12) { GpioDataRegs.GPACLEAR.bit.GPIO0 = 1; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { GpioDataRegs.GPASET.bit.GPIO0 = 1; } GpioDataRegs.GPATOGGLE.bit.GPIO3 = 1; delay(100000); } }</span></span></code> </pre><br>  Wir kompilieren, gehen zum Debugger, starten ihn und sehen, wie eine LED st√§ndig blinkt, und wenn Sie die Taste dr√ºcken, leuchtet eine andere auf.  Am Ende des Abschnitts werde ich ein Projekt mit diesem Code anh√§ngen. Wenn etwas nicht funktioniert, dann schau es dir an.  Besonders f√ºr diejenigen, die sich mit Texten schwer tun oder nicht alle Punkte verstanden haben, empfehle ich, dieses Video √ºber die Arbeit mit GPIO anzuschauen. Dort geschieht alles, wie im Abschnitt "GPIO".  Ich warne Sie, dass das Video f√ºr eine Stunde trostlos, lang, aber so detailliert wie m√∂glich und alles sichtbar ist: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/jlyVy73pa98" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  Dateien aus dem Artikel </h2><br><ul><li>  Archiv mit dem Projekt f√ºr CCS7 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> herunterladen </li><li>  Sie k√∂nnen den Code auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github sehen</a> </li></ul><br><h2>  Zusammenfassung </h2><br>  In dieser Phase beende ich den heutigen Artikel.  Ich denke, Sie haben verstanden, dass der Artikel um ein Vielfaches gr√∂√üer gewesen w√§re, wenn ich mich sofort entschlossen h√§tte, die DC / AC-Implementierung des Wechselrichters zu zeigen, oder dass viele wichtige Details einfach hinter den Kulissen geblieben w√§ren, was meiner Meinung nach nicht akzeptabel ist. <br><br>  Ich hoffe, mein Artikel wird allen helfen, mit der Entwicklung dieser Steuerungsfamilie und der Entwicklung auf dem Gebiet der Leistungselektronik und Werkzeugmaschinen zu beginnen.  In Zukunft werde ich wahrscheinlich noch etwas zu diesem Thema schreiben, zum Beispiel m√∂chte ich √ºberlegen, mit PWM zu arbeiten oder eine Art Algorithmus zu implementieren.  Die Hauptsache ist, Zeit zu haben. <br><br>  Wenn Sie Fragen haben oder etwas f√ºr Sie nicht funktioniert, k√∂nnen Sie mir private Nachrichten schreiben. Ich werde versuchen, Ihre Fragen zu beantworten und alle m√∂glichen Hilfen f√ºr die Studie bereitzustellen.  Ich w√ºnsche Ihnen viel Erfolg beim Training! <br><br>  <b>UPD</b>  Vielen Dank f√ºr den Tipp von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">BelerafonL</a> zum Buch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûEmbedded High-Performance Digital Control Systems‚Äú.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de410161/">https://habr.com/ru/post/de410161/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de410149/index.html">So verhandeln Sie √ºber Skype und Telefon auf Englisch: Anweisungen und n√ºtzliche S√§tze</a></li>
<li><a href="../de410153/index.html">Das nuttige Mittelalter</a></li>
<li><a href="../de410155/index.html">Bandage lebensspendend nicht entfernbar</a></li>
<li><a href="../de410157/index.html">Intel zeigte eine intelligente Brille, mit der das Bild auf die Netzhaut √ºbertragen wird</a></li>
<li><a href="../de410159/index.html">Wie ein Smartphone lauschen, gucken und verfolgen kann</a></li>
<li><a href="../de410163/index.html">[CASE] 3D-Druck in der Leichtindustrie am Beispiel von FullPower</a></li>
<li><a href="../de410167/index.html">Wie Schmutz die Menschheit vor einer ansteckenden Apokalypse retten kann</a></li>
<li><a href="../de410171/index.html">Virale DNA-Roboter wurden so programmiert, dass sie menschliche Blutgef√§√üe blockieren und Krebstumoren abt√∂ten.</a></li>
<li><a href="../de410173/index.html">Yandex voreingenommen stellt seine Top-Nachrichten zusammen, sagte die Beschwerde an die FAS</a></li>
<li><a href="../de410175/index.html">Traumgitarren: Mehrfinger-Monster, seltsame Hybriden und andere neu erfundene ‚ÄûBikes‚Äú</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>