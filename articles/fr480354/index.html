<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üà∂ üë®‚Äçüëß‚Äçüë¶ üë©üèª‚Äç‚öïÔ∏è Premiers pas avec les m√©thodes de tableau JavaScript .map (), .filter () et .reduce () üïî üë©‚Äçüë©‚Äçüë¶ üåº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quand j'ai compris comment utiliser les m√©thodes du tableau JS .map() , .filter() et .reduce() , tout ce que j'ai lu, regard√© et √©cout√© semblait tr√®s ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Premiers pas avec les m√©thodes de tableau JavaScript .map (), .filter () et .reduce ()</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/480354/"> Quand j'ai compris comment utiliser les m√©thodes du tableau JS <code>.map()</code> , <code>.filter()</code> et <code>.reduce()</code> , tout ce que j'ai lu, regard√© et √©cout√© semblait tr√®s compliqu√©.  Ces concepts ont √©t√© consid√©r√©s comme des m√©canismes ind√©pendants qui n'ont rien √† voir avec autre chose.  Il √©tait difficile pour moi de saisir leur essence et de les comprendre. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/480354/"><img src="https://habrastorage.org/webt/kn/qk/-z/knqk-ztl4akx8wdgib1rxhc5tea.jpeg"></a> <br><br>  J'ai entendu dire que ce sont des choses fondamentales, dont la compr√©hension est quelque chose comme la fronti√®re entre les "initi√©s" et les "non initi√©s".  J'aimerais alors qu'on leur dise la v√©rit√©.  Elle consiste dans le fait que ces trois m√©thodes symbolisent le fait que les raisons de trier certains objets it√©rables s'inscrivent souvent dans l'une des trois cat√©gories fonctionnelles. <br><a name="habracut"></a><br>  En parcourant le code que j'ai √©crit plus t√¥t, j'ai r√©alis√© que dans 95% des cas, lorsque je r√©p√©tais les √©l√©ments de cha√Ænes ou de tableaux, j'ai fait l'une des actions suivantes: <br><br><ul><li>  Appliquer une certaine s√©quence d'instructions √† chaque valeur (analogue √† la m√©thode <code>.map()</code> ). </li><li>  Filtrage des valeurs qui correspondent √† un crit√®re donn√© (comme pour <code>.filter()</code> ). </li><li>  R√©duction d'un ensemble de donn√©es √† une seule valeur agr√©g√©e (analogue de <code>.reduce()</code> ). </li></ul><br>  Ce fut un moment de v√©rit√©.  C'est alors que j'ai compris l'essence de ces m√©thodes et j'ai vu leur lien avec ce que je connais depuis longtemps. <br><br>  Afin de m'entra√Æner, j'ai pris mon ancien code et l'ai refactoris√© en utilisant ces m√©thodes.  Cela s'est av√©r√© tr√®s utile. <br><br>  Et maintenant, sans plus tarder, parlons de ces m√©thodes et, en particulier, examinons comment les utiliser au lieu des sch√©mas r√©pandus d'utilisation des boucles. <br><br><h2>  <font color="#3AC1EF">M√©thode .Map ()</font> </h2><br>  La m√©thode <code>.map()</code> est utilis√©e si vous devez effectuer les op√©rations suivantes: <br><br><ol><li>  Il est n√©cessaire d'effectuer une certaine s√©quence d'actions sur chaque √©l√©ment de l'objet it√©rable. </li><li>  Il est n√©cessaire de renvoyer la valeur qui, vraisemblablement, a √©t√© modifi√©e. </li></ol><br>  Prenons un exemple simple dans lequel pour chaque √©l√©ment d'un tableau contenant des prix, vous devez trouver de nouveaux montants, y compris les prix d'origine et la taxe de vente: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prices = [<span class="hljs-number"><span class="hljs-number">19.99</span></span>, <span class="hljs-number"><span class="hljs-number">4.95</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>, <span class="hljs-number"><span class="hljs-number">3.50</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> new_prices = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; prices.length; i++) {   new_prices.push(prices[i] * <span class="hljs-number"><span class="hljs-number">1.06</span></span>); }</code> </pre> <br>  Voici comment faire de m√™me avec <code>.map()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prices = [<span class="hljs-number"><span class="hljs-number">19.99</span></span>, <span class="hljs-number"><span class="hljs-number">4.95</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>, <span class="hljs-number"><span class="hljs-number">3.50</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> new_prices = prices.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">price</span></span></span><span class="hljs-function"> =&gt;</span></span> price * <span class="hljs-number"><span class="hljs-number">1.06</span></span>);</code> </pre> <br>  Il utilise des constructions syntaxiques assez concises.  Regardons donc cet exemple.  La m√©thode <code>.map()</code> accepte un rappel.  Il s'agit de la fonction qui sera appliqu√©e aux √©l√©ments du tableau.  Dans ce cas, il s'agit d'une fonction fl√®che, qui est d√©clar√©e directement entre parenth√®ses apr√®s la d√©claration de la m√©thode. <br><br>  Le nom du param√®tre de <code>price</code> est le nom qui sera utilis√© lors de l'utilisation des √©l√©ments du tableau.  Comme notre fonction fl√®che n'a qu'un seul param√®tre, nous pouvons nous passer de parenth√®ses lors de sa d√©claration. <br><br>  L'expression apr√®s la fl√®che ( <code>=&gt;</code> ) est le corps du rappel.  Puisqu'il n'y a qu'une seule expression dans le corps de la fonction, nous pouvons nous passer des accolades et du mot-cl√© <code>return</code> . <br><br>  Si vous trouvez cette entr√©e incompr√©hensible, voici une version l√©g√®rement √©tendue de cet exemple: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prices = [<span class="hljs-number"><span class="hljs-number">19.99</span></span>, <span class="hljs-number"><span class="hljs-number">4.95</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>, <span class="hljs-number"><span class="hljs-number">3.50</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> new_prices = prices.map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">price</span></span></span><span class="hljs-function">) =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> price * <span class="hljs-number"><span class="hljs-number">1.06</span></span> });</code> </pre> <br><h2>  <font color="#3AC1EF">M√©thode .Filter ()</font> </h2><br>  La m√©thode <code>.filter()</code> est utilis√©e dans les cas o√π certains √©l√©ments doivent √™tre s√©lectionn√©s dans l'objet it√©rable.  Lorsque vous utilisez cette m√©thode, vous devez vous rappeler que les valeurs correspondant au filtre sont incluses dans le r√©sultat final et non exclues de celui-ci.  C'est-√†-dire que tout pour lequel la fonction a pass√© <code>.filter()</code> retournera <code>true</code> , sera laiss√©. <br><br>  Prenons un exemple dans lequel seuls les √©l√©ments impairs doivent √™tre s√©lectionn√©s dans un tableau d'entiers.  Ici, nous utilisons l'op√©rateur pour prendre le reste de la division et savoir s'il y a un reste en divisant chaque √©l√©ment du tableau par 2. Si le reste est 1, cela nous indique que le nombre correspondant est impair.  Tout d'abord, examinons un moyen de r√©soudre ce probl√®me en utilisant une boucle r√©guli√®re: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> odds = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numbers.length; i++) {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(numbers[i] % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">1</span></span>) {      odds.push(numbers[i]);   } }</code> </pre> <br>  La m√©thode <code>.filter()</code> , comme <code>.map()</code> , accepte un rappel, auquel les √©l√©ments de l'objet it√©r√© seront transmis √† leur tour: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> odds = numbers.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function"> =&gt;</span></span> num % <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  Ici, le travail est organis√© de la m√™me mani√®re que dans l'exemple avec <code>.map()</code> .  La fonction fl√®che pass√©e √† <code>.filter()</code> n'utilise qu'un seul param√®tre, nous le faisons donc sans parenth√®ses.  Son corps ne contient qu'une seule expression, il peut donc √™tre omis entre crochets et il est acceptable de le faire sans <code>return</code> . <br><br><h2>  <font color="#3AC1EF">M√©thode .Reduce ()</font> </h2><br>  Et maintenant, nous sommes finalement arriv√©s √† la m√©thode <code>.reduce()</code> .  Il est, je crois, la plus incompr√©hensible des trois m√©thodes envisag√©es aujourd'hui.  Le nom de cette m√©thode indique qu'elle est utilis√©e pour r√©duire plusieurs valeurs √† une.  Cependant, il me semble qu'il est plus facile de la consid√©rer comme une m√©thode qui vous permet de collecter certaines valeurs √† partir de pi√®ces, et non comme une m√©thode qui vous permet de ¬´r√©duire¬ª ou de ¬´r√©duire¬ª quelque chose. <br><br>  Lors de la construction du code dans lequel cette m√©thode est appel√©e, une certaine valeur initiale est d'abord d√©finie.  √Ä mesure que la m√©thode parcourt les valeurs du tableau, cette valeur initiale est modifi√©e et, sous une forme modifi√©e, est pass√©e √† l'it√©ration suivante. <br><br>  Voici un probl√®me classique, √† r√©soudre, dont vous avez besoin pour calculer la somme des √©l√©ments du tableau.  Dans notre cas, cela consiste √† trouver le montant des dons pour un certain projet caritatif: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> donations = [<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">75</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; donations.length; i++) {   total += donations[i]; }</code> </pre> <br>  Contrairement aux <code>.map()</code> et <code>.filter()</code> , la m√©thode <code>.reduce()</code> besoin d'un rappel qui prend deux param√®tres.  Il s'agit de la batterie et de la valeur actuelle.  La batterie est le premier param√®tre.  C'est lui qui est modifi√© √† chaque it√©ration et pass√© au suivant: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> donations = [<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">75</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> total = donations.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">total,donation</span></span></span><span class="hljs-function">) =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total + donation; });</code> </pre> <br>  <code>.reduce()</code> pouvez √©galement passer un deuxi√®me argument √† la <code>.reduce()</code> .  C'est ce qui va jouer le r√¥le de la valeur initiale de la batterie.  Supposons que nous voulons conna√Ætre le montant total des dons en deux jours, √©tant donn√© qu'hier ce montant √©tait de 450 $ et que les informations sur les dons d'aujourd'hui sont stock√©es dans un tableau: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> donations = [<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">75</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> total = donations.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">total,donation</span></span></span><span class="hljs-function">) =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total + donation; }, <span class="hljs-number"><span class="hljs-number">450</span></span>);</code> </pre> <br><h2>  <font color="#3AC1EF">R√©sum√©</font> </h2><br>  J'esp√®re que vous avez maintenant compris les m√©thodes du tableau <code>.map()</code> , <code>.filter()</code> et <code>.reduce()</code> .  Consid√©rez-les comme des m√©canismes qui am√©liorent la lisibilit√© de votre code.  Ils vous permettent d'√©crire des programmes plus compacts que ceux obtenus en utilisant des boucles conventionnelles.  Mais leur principale force est qu'ils vous permettent d'exprimer clairement l'intention qui sous-tend le code. <br><br>  Gr√¢ce √† ces m√©thodes, le code √©crit depuis un certain temps sera plus facile √† lire.  Au lieu de plonger dans les constructions plac√©es √† l'int√©rieur des boucles <code>for</code> , en ne faisant cela que pour comprendre leur objectif ultime, vous n'avez vu que le nom d'une de ces m√©thodes peut d√©j√† vous faire une id√©e g√©n√©rale des raisons de l'existence d'un morceau de code particulier. <br><br>  <b>Chers lecteurs!</b>  Utilisez-vous les m√©thodes de tableau JS .map (), .filter () et .reduce ()? <br><br><div style="text-align:center;"> <a href="https://ruvds.com/ru-rub"><img src="https://habrastorage.org/webt/yx/3g/bv/yx3gbv0xlht1gyjfwlg2z_kgylo.png"></a> </div><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr480354/">https://habr.com/ru/post/fr480354/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr480340/index.html">Je me suis oppos√© √† un gestionnaire incomp√©tent, puis il a √©t√© promu</a></li>
<li><a href="../fr480342/index.html">Paradigme de d√©veloppement par le commentaire</a></li>
<li><a href="../fr480348/index.html">Deep Fake Science, la crise de la reproductibilit√© et d'o√π viennent les r√©f√©rentiels vides</a></li>
<li><a href="../fr480350/index.html">Le condens√© de mat√©riaux int√©ressants pour le d√©veloppeur mobile # 326 (du 9 au 15 d√©cembre)</a></li>
<li><a href="../fr480352/index.html">Un g√©n√©ticien de Harvard d√©veloppe un prototype d'application de datation pour l'analyse d'ADN</a></li>
<li><a href="../fr480356/index.html">Conseils Python utiles que vous n'avez pas rencontr√©s</a></li>
<li><a href="../fr480358/index.html">Le prix cach√© des biblioth√®ques CSS-in-JS dans les applications React</a></li>
<li><a href="../fr480362/index.html">Aventures d'hexafluorure d'uranium appauvri allemand en Russie. Partie 1. Histoire et technologies d'enrichissement</a></li>
<li><a href="../fr480364/index.html">M√©taphysique de l'injection de d√©pendance</a></li>
<li><a href="../fr480368/index.html">Attraper les fuites de m√©moire en C / C ++</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>