<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèΩ‚Äçü§ù‚ÄçüßëüèΩ üôá üôèüèº G√©n√©ralisation rapide des marqueurs sur une carte WebGL ‚úçüèø üéí üåí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les marqueurs sont une bonne chose. Utile en quantit√© raisonnable. Quand il y en a trop, les b√©n√©fices disparaissent. Que faire si vous souhaitez marq...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>G√©n√©ralisation rapide des marqueurs sur une carte WebGL</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/2gis/blog/442720/"><p><img src="https://habrastorage.org/webt/wl/if/9y/wlif9yuvumhoa16egkvqphgdzyo.png" alt="image"></p><br><p>  Les marqueurs sont une bonne chose.  Utile en quantit√© raisonnable.  Quand il y en a trop, les b√©n√©fices disparaissent.  Que faire si vous souhaitez marquer des r√©sultats de recherche sur la carte, dans laquelle des dizaines de milliers d'objets?  Dans l'article, je vais vous expliquer comment r√©soudre ce probl√®me sur une carte WebGL sans compromettre son apparence et ses performances. </p><a name="habracut"></a><br><h1 id="predystoriya">  Contexte </h1><br><p>  En 2016, 2GIS a lanc√© son premier projet WebGL, Floors: 3D floor plans of buildings. </p><br><p><img src="https://habrastorage.org/webt/dt/90/4v/dt904vhpl-gjcyju0tuf_n-nefc.png" alt="image"><br>  <em>Planchers du centre commercial Novosibirsk Aura</em> </p><br><p>  Imm√©diatement apr√®s la sortie de Floors, notre √©quipe a commenc√© √† d√©velopper un moteur cartographique tridimensionnel √† part enti√®re sur WebGL.  Le moteur a √©t√© d√©velopp√© conjointement avec la nouvelle version 2gis.ru et est maintenant en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">version b√™ta publique</a> . </p><br><p><img src="https://habrastorage.org/webt/_9/nl/q9/_9nlq9yh87m2vbaznj3_tvji6q8.png" alt="image"><br>  <em>Carr√© rouge dessin√© sur WebGL.</em>  <em>Les plans de construction sont d√©sormais int√©gr√©s directement dans la carte.</em> </p><br><h1 id="zadacha-generalizacii-podpisey">  T√¢che de g√©n√©ralisation de signature </h1><br><p>  Quiconque veut √©crire son propre moteur de carte sera t√¥t ou tard confront√© au probl√®me de placer des signatures sur la carte.  Il y a beaucoup d'objets sur la carte, et il est impossible de signer chacun pour que les signatures ne se chevauchent pas. </p><br><p><img src="https://habrastorage.org/webt/si/0j/cf/si0jcfdcbaz8tqeazopjba1f1b8.png" alt="image"><br>  <em>Que se passera-t-il si √† Novossibirsk tous les objets sont sign√©s en m√™me temps</em> </p><br><p>  Pour r√©soudre ce probl√®me, une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">g√©n√©ralisation des</a> signatures est requise.  La g√©n√©ralisation au sens g√©n√©ral est la transformation des donn√©es cartographiques afin qu'elles conviennent √† un affichage √† petite √©chelle.  Cela peut √™tre fait par diff√©rentes m√©thodes.  Pour les signatures, la m√©thode de s√©lection est g√©n√©ralement utilis√©e: √† partir du nombre total, un sous-ensemble des signatures de priorit√© la plus √©lev√©e qui ne se chevauchent pas est s√©lectionn√©. </p><br><p>  La priorit√© de la signature est d√©termin√©e par son type, ainsi que l'√©chelle actuelle de la carte.  Par exemple, √† petite √©chelle, les signatures des villes et des pays sont n√©cessaires, et √† grande √©chelle, les signatures routi√®res et les num√©ros de maison deviennent beaucoup plus importants.  Souvent, la priorit√© du nom d'une colonie est d√©termin√©e par la taille de sa population.  Plus elle est grande, plus la signature est importante. </p><br><p>  La g√©n√©ralisation est requise non seulement pour les signatures, mais aussi pour les marqueurs qui marquent les r√©sultats de la recherche sur la carte.  Par exemple, lors de la recherche de ¬´magasin¬ª √† Moscou, il y a plus de 15 000 r√©sultats.  Les marquer tous sur la carte d'un seul coup est √©videmment une mauvaise id√©e. </p><br><p><img src="https://habrastorage.org/webt/2a/in/jj/2ainjj57s8zfmdjv4103va5trqm.png" alt="image"><br>  <em>Tous les magasins de Moscou sur la carte.</em>  <em>Il n'y a aucun moyen de se passer de la g√©n√©ralisation</em> </p><br><p> Toute interaction de l'utilisateur avec la carte (d√©placement, zoom, rotation et inclinaison) entra√Æne un changement de position des marqueurs sur l'√©cran, vous devez donc √™tre en mesure de recalculer la g√©n√©ralisation √† la vol√©e.  Par cons√©quent, cela doit √™tre rapide. </p><br><p>  Dans cet article, en utilisant l'exemple de la g√©n√©ralisation des marqueurs, je vais montrer diff√©rentes fa√ßons de r√©soudre ce probl√®me, qui ont √©t√© utilis√©es √† diff√©rents moments dans nos projets. </p><br><h1 id="obschiy-podhod-k-generalizacii">  Approche g√©n√©rale de la g√©n√©ralisation </h1><br><ol><li>  Projetez chaque marqueur sur le plan de l'√©cran et calculez pour lui une limite - la zone rectangulaire qu'il occupe sur l'√©cran. </li><li>  Trier les marqueurs par priorit√©. </li><li>  Examinez s√©quentiellement chaque marqueur et placez-le sur l'√©cran s'il ne recoupe pas d'autres marqueurs plac√©s devant lui. </li></ol><br><p>  Avec le point 1, tout est clair - ce n'est qu'un calcul.  Avec le point 2, nous avons √©galement eu de la chance: la liste des marqueurs qui nous vient du backend est d√©j√† tri√©e par priorit√© par les algorithmes de recherche.  Les r√©sultats les plus pertinents susceptibles d'int√©resser l'utilisateur se trouvent en haut des r√©sultats. </p><br><p>  Le principal probl√®me se trouve au paragraphe 3: le temps de calcul de la g√©n√©ralisation peut d√©pendre grandement de la fa√ßon dont elle est mise en ≈ìuvre. </p><br><p>  Pour rechercher des intersections entre les marqueurs, nous avons besoin d'une structure de donn√©es qui: </p><br><ol><li>  Stocke les limites des marqueurs ajout√©s √† l'√©cran. </li><li> A une m√©thode d' <code>insert(marker)</code> pour ajouter un marqueur √† l'√©cran. </li><li>  Il a une m√©thode de <code>collides(marker)</code> pour v√©rifier le marqueur pour l'intersection avec ceux d√©j√† ajout√©s √† l'√©cran. </li></ol><br><p>  Consid√©rez plusieurs impl√©mentations de cette structure.  Tous les autres exemples seront √©crits en TypeScript, que nous utilisons dans la plupart de nos projets.  Dans tous les exemples, les marqueurs seront repr√©sent√©s par des objets de la forme suivante: </p><br><pre> <code class="plaintext hljs">interface Marker { minX: number; maxX: number; minY: number; maxY: number; }</code> </pre> <br><p>  Toutes les approches envisag√©es seront des impl√©mentations de l'interface suivante: </p><br><pre> <code class="plaintext hljs">interface CollisionDetector { insert(item: Marker): void; collides(item: Marker): boolean; }</code> </pre> <br><p>  Pour comparer les performances, le temps d'ex√©cution du code suivant sera mesur√©: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> marker <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> markers) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!impl.collides(marker)) { impl.insert(marker); } }</code> </pre> <br><p>  Le tableau de <code>markers</code> contiendra 100 000 √©l√©ments 30x50 plac√©s au hasard sur un plan de taille 1920x1080. </p><br><p>  Les performances seront mesur√©es sur le Macbook Air 2012. </p><br><p>  Les tests et exemples de code fournis dans l'article sont √©galement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">publi√©s sur GitHub</a> . </p><br><h1 id="naivnaya-realizaciya">  Impl√©mentation na√Øve </h1><br><p>  Pour commencer, consid√©rez l'option la plus simple, lorsque le marqueur est v√©rifi√© pour l'intersection avec les autres dans un cycle simple. </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NaiveImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CollisionDetector</span></span></span><span class="hljs-class"> </span></span>{ private markers: Marker[]; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.markers = []; } insert(marker: Marker): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.markers.push(marker); } collides(candidate: Marker): boolean { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (marker <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.markers) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( candidate.minX &lt;= marker.maxX &amp;&amp; candidate.minY &lt;= marker.maxY &amp;&amp; candidate.maxX &gt;= marker.minX &amp;&amp; candidate.maxY &gt;= marker.minY ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><p>  Temps de calcul de g√©n√©ralisation pour 100 000 marqueurs: <strong>420 ms</strong> .  Trop.  M√™me si le calcul de g√©n√©ralisation se fait dans un Web Worker et ne bloque pas le thread principal, un tel retard sera perceptible √† l'oeil, d'autant plus que cette op√©ration doit √™tre effectu√©e apr√®s chaque mouvement de carte.  De plus, sur les appareils mobiles avec un processeur faible, le d√©lai peut √™tre encore plus important. </p><br><h1 id="realizaciya-s-primeneniem-r-dereva">  Impl√©mentation de R-tree </h1><br><p>  √âtant donn√© que dans une impl√©mentation na√Øve, chaque marqueur est v√©rifi√© pour l'intersection avec tous les pr√©c√©dents, dans le pire des cas, la complexit√© de cet algorithme est quadratique.  Vous pouvez l'am√©liorer en appliquant la structure de donn√©es de l'arborescence R.  En tant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">qu'impl√©mentation de</a> l'arborescence R, prenez la biblioth√®que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RBush</a> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> rbush <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rbush'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RTreeImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CollisionDetector</span></span></span><span class="hljs-class"> </span></span>{ private tree: rbush.RBush&lt;Marker&gt;; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tree = rbush(); } insert(marker: Marker): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tree.insert(marker); } collides(candidate: Marker): boolean { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tree.collides(candidate); } }</code> </pre> <br><p>  Temps de calcul de g√©n√©ralisation pour 100 000 marqueurs: <strong>173 ms</strong> .  Beaucoup mieux.  Nous avons utilis√© cette approche dans les √©tages (cela a √©t√© mentionn√© dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mon article pr√©c√©dent</a> ). </p><br><p><img src="https://habrastorage.org/webt/44/mp/v5/44mpv5pc8gwyqr4jfr5mqcibwqu.png" alt="image"><br>  <em>Visualisation du stockage des points dans l'arborescence R.</em>  <em>La division hi√©rarchique du plan en rectangles vous permet de r√©tr√©cir rapidement la zone de recherche et de ne pas trier tous les objets</em> </p><br><h1 id="realizaciya-s-primeneniem-bufera-kolliziy">  Impl√©mentation du tampon de collision </h1><br><p>  Dessiner une carte est une t√¢che beaucoup plus compliqu√©e que de dessiner le plan d'un b√¢timent.  Cela se manifeste √©galement dans la g√©n√©ralisation.  M√™me dans les plus grands centres commerciaux du monde, 1 000 organisations sont rarement au m√™me √©tage.  Dans le m√™me temps, une simple requ√™te de recherche dans une grande ville peut renvoyer des dizaines de milliers de r√©sultats. </p><br><p>  Lorsque nous avons commenc√© √† d√©velopper une carte WebGL, nous avons commenc√© √† penser: est-il encore possible d'acc√©l√©rer la g√©n√©ralisation.  Une id√©e int√©ressante nous a √©t√© propos√©e par le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">stellarateur</a> qui a fonctionn√© pour nous: au lieu de l'arborescence R, utilisez un tampon dans lequel stocker l'√©tat de chaque pixel de l'√©cran (occup√© ou non occup√©).  Lors de l'insertion d'un marqueur sur l'√©cran, ¬´remplissez¬ª l'emplacement correspondant dans le tampon, et lors de la v√©rification de la possibilit√© de coller, v√©rifiez les valeurs des pixels dans la zone requise. </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CollisionBufferByteImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CollisionDetector</span></span></span><span class="hljs-class"> </span></span>{ private buffer: <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>; private height: number; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(width: number, height: number) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>(width * height); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height = height; } insert(marker: Marker): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { minX, minY, maxX, maxY } = marker; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = minX; i &lt; maxX; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = minY; j &lt; maxY; j++) { buffer[i * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height + j] = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } } collides(candidate: Marker): boolean { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { minX, minY, maxX, maxY } = candidate; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = minX; i &lt; maxX; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = minY; j &lt; maxY; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer[i * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height + j]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><p>  Temps de calcul de g√©n√©ralisation pour 100 000 marqueurs: <strong>46 ms</strong> . </p><br><p>  Pourquoi si vite?  Cette approche semble na√Øve √† premi√®re vue, et les boucles imbriqu√©es dans les deux m√©thodes ne sont pas comme du code rapide.  Cependant, si vous regardez de plus pr√®s le code, vous remarquerez que le temps d'ex√©cution des deux m√©thodes ne d√©pend pas du nombre total de marqueurs.  Ainsi, pour une taille fixe de marqueurs WxH, on obtient la complexit√© O (W * H * n), c'est-√†-dire lin√©aire! </p><br><h1 id="optimizaciya-podhoda-s-buferom-kolliziy">  Approche de tampon de collision optimis√©e </h1><br><p>  Vous pouvez am√©liorer l'approche pr√©c√©dente √† la fois en vitesse et en m√©moire occup√©e, si vous vous assurez qu'un pixel est repr√©sent√© en m√©moire non pas par un octet, mais par un bit.  Le code apr√®s cette optimisation, cependant, est visiblement compliqu√© et se d√©veloppe avec un peu de magie: </p><br><div class="spoiler">  <b class="spoiler_title">Code source</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CollisionBufferBitImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CollisionDetector</span></span></span><span class="hljs-class"> </span></span>{ private width: number; private height: number; private buffer: <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(width: number, height: number) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.ceil(width / <span class="hljs-number"><span class="hljs-number">8</span></span>) * <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height = height; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height / <span class="hljs-number"><span class="hljs-number">8</span></span>); } insert(marker: Marker): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { minX, minY, maxX, maxY } = marker; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { width, buffer } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = minY; j &lt; maxY; j++) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> start = j * width + minX &gt;&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> end = j * width + maxX &gt;&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (start === end) { buffer[start] = buffer[start] | (<span class="hljs-number"><span class="hljs-number">255</span></span> &gt;&gt; (minX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">255</span></span> &lt;&lt; (<span class="hljs-number"><span class="hljs-number">8</span></span> - (maxX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>))); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { buffer[start] = buffer[start] | (<span class="hljs-number"><span class="hljs-number">255</span></span> &gt;&gt; (minX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = start + <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; end; i++) { buffer[i] = <span class="hljs-number"><span class="hljs-number">255</span></span>; } buffer[end] = buffer[end] | (<span class="hljs-number"><span class="hljs-number">255</span></span> &lt;&lt; (<span class="hljs-number"><span class="hljs-number">8</span></span> - (maxX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>))); } } } collides(marker: Marker): boolean { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { minX, minY, maxX, maxY } = marker; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { width, buffer } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = minY; j &lt; maxY; j++) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> start = j * width + minX &gt;&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> end = j * width + maxX &gt;&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (start === end) { sum = buffer[start] &amp; (<span class="hljs-number"><span class="hljs-number">255</span></span> &gt;&gt; (minX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">255</span></span> &lt;&lt; (<span class="hljs-number"><span class="hljs-number">8</span></span> - (maxX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>))); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { sum = buffer[start] &amp; (<span class="hljs-number"><span class="hljs-number">255</span></span> &gt;&gt; (minX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = start + <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; end; i++) { sum = buffer[i] | sum; } sum = buffer[end] &amp; (<span class="hljs-number"><span class="hljs-number">255</span></span> &lt;&lt; (<span class="hljs-number"><span class="hljs-number">8</span></span> - (maxX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>))) | sum; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sum !== <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> </div></div><br><p>  Temps de calcul de g√©n√©ralisation pour 100 000 marqueurs: <strong>16 ms</strong> .  Comme vous pouvez le voir, la complexit√© de la logique se justifie et nous permet d'acc√©l√©rer le calcul de la g√©n√©ralisation de pr√®s de trois fois. </p><br><h1 id="ogranicheniya-bufera-kolliziy">  Limitations du tampon de collision </h1><br><p>  Il est important de comprendre que le tampon de collision n'est pas un remplacement complet de l'arborescence R.  Il a beaucoup moins de fonctionnalit√©s et plus de restrictions: </p><br><ol><li>  Vous ne pouvez pas comprendre exactement ce que le marqueur recoupe.  Le tampon ne stocke que des donn√©es sur les pixels occup√©s et ceux qui ne le sont pas.  Par cons√©quent, il est impossible d'impl√©menter une op√©ration qui renvoie une liste de marqueurs qui se croisent avec le donn√©. </li><li>  Impossible de supprimer le marqueur ajout√© pr√©c√©demment.  Le tampon ne stocke pas de donn√©es sur le nombre de marqueurs dans un pixel donn√©.  Par cons√©quent, il est impossible d'impl√©menter correctement l'op√©ration de suppression d'un marqueur du tampon. </li><li>  Haute sensibilit√© √† la taille des √©l√©ments.  Si vous essayez d'ajouter des marqueurs qui occupent la totalit√© de l'√©cran au tampon de collision, les performances chuteront consid√©rablement. </li><li>  Fonctionne dans une zone limit√©e.  La taille du tampon est d√©finie lors de sa cr√©ation, et il est impossible d'y placer un marqueur qui d√©passe cette taille.  Par cons√©quent, lorsque vous utilisez cette approche, il est n√©cessaire de filtrer manuellement les marqueurs qui n'apparaissent pas √† l'√©cran. </li></ol><br><p>  Toutes ces restrictions n'ont pas interf√©r√© avec la solution du probl√®me de la g√©n√©ralisation des marqueurs.  Maintenant, cette m√©thode est utilis√©e avec succ√®s pour les marqueurs dans la version b√™ta de 2gis.ru. </p><br><p>  Cependant, pour g√©n√©raliser les principales signatures sur la carte, les exigences sont plus complexes.  Par exemple, pour eux, il est n√©cessaire de s'assurer que l'ic√¥ne POI ne peut pas ¬´tuer¬ª sa propre signature.  √âtant donn√© que le tampon de collision ne distingue pas exactement avec quoi l'intersection s'est produite, il ne permet pas de mettre en ≈ìuvre une telle logique.  Par cons√©quent, ils ont d√ª laisser une solution √† RBush. </p><br><h1 id="vyvod">  Conclusion </h1><br><p><img src="https://habrastorage.org/webt/cl/ey/uq/cleyuqjc1utr1xm4elsi2g_uxxs.png" alt="image"><br>  L'article montre le chemin que nous sommes pass√©s de la solution la plus simple √† celle utilis√©e maintenant. </p><br><p>  L'utilisation de l'arborescence R a √©t√© la premi√®re √©tape importante qui nous a permis d'acc√©l√©rer plusieurs fois la mise en ≈ìuvre na√Øve.  Cela fonctionne tr√®s bien dans les √©tages, mais en fait, nous n'utilisons qu'une petite fraction des capacit√©s de cette structure de donn√©es. </p><br><p>  Apr√®s avoir abandonn√© l'arbre R et le remplacer par un simple tableau bidimensionnel, qui fait exactement ce dont nous avons besoin, et rien d'autre, nous avons obtenu une augmentation encore plus grande de la productivit√©. </p><br><p>  Cet exemple nous a montr√© combien il est important de choisir une solution √† un probl√®me parmi plusieurs options, de comprendre et de r√©aliser les limites de chacune d'entre elles.  Les limites sont importantes et utiles, et vous ne devriez pas en avoir peur: en vous limitant habilement √† quelque chose d'insignifiant, vous pouvez obtenir d'√©normes avantages en retour l√† o√π cela est vraiment n√©cessaire.  Par exemple, pour simplifier la r√©solution d'un probl√®me, ou pour vous prot√©ger de toute une classe de probl√®mes, ou, comme dans notre cas, pour am√©liorer plusieurs fois la productivit√©. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr442720/">https://habr.com/ru/post/fr442720/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr442708/index.html">Qu'est-ce qui d√©termine le revenu des mineurs?</a></li>
<li><a href="../fr442710/index.html">Examen de la plateforme Google IoT</a></li>
<li><a href="../fr442714/index.html">Comme des d√©fauts</a></li>
<li><a href="../fr442716/index.html">Chaussons</a></li>
<li><a href="../fr442718/index.html">Les employ√©s de Google ont constat√© que le travail sur la version du moteur de recherche pour la Chine se poursuit</a></li>
<li><a href="../fr442722/index.html">Arr√™tez de t√©l√©charger et de stocker des z√©ros</a></li>
<li><a href="../fr442724/index.html">Le film ¬´Office Space¬ª a 20 ans: comment cela a chang√© nos m√©tiers</a></li>
<li><a href="../fr442726/index.html">Le robot gu√©pard du MIT peut faire des sauts en arri√®re et courir vite</a></li>
<li><a href="../fr442730/index.html">Microsoft: la Russie devance les √âtats-Unis et l'Europe dans la mise en ≈ìuvre de l'intelligence artificielle</a></li>
<li><a href="../fr442732/index.html">Mes petits relais: Triple Brainfuck, ou qu'est-ce que la folie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>