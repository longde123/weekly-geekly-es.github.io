<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💅🏾 👎🏼 🐙 Swift：ARC和内存管理 🥁 📰 🍙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="作为一种现代的高级语言， Swift基本上负责应用程序中的内存管理，分配和释放内存。 这是由于一种称为自动引用计数的机制，简称ARC 。 在本指南中，您将学习ARC如何工作以及如何在Swift中正确管理内存。 了解此机制后，您可以影响位于堆（ heap ）上的对象的生存期。 

 在本指南中，您将通...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Swift：ARC和内存管理</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451130/"> 作为一种现代的高级语言， <b>Swift</b>基本上负责应用程序中的内存管理，分配和释放内存。 这是由于一种称为<b>自动引用计数</b>的机制，简称<b>ARC</b> 。 在本指南中，您将学习ARC如何工作以及如何在Swift中正确管理内存。 了解此机制后，您可以影响位于堆（ <b>heap</b> ）上的对象的生存期。 <br><br> 在本指南中，您将通过学习以下知识来增强对Swift和ARC的了解： <br><br><ul><li>  ARC如何运作 </li><li> 什么是<b>参考周期</b>以及如何正确修复它们 </li><li> 如何创建示例链接循环 </li><li> 如何使用Xcode提供的可视化工具查找链接循环 </li><li> 如何处理引用类型和值类型 </li></ul><a name="habracut"></a><br><h2> 开始使用 </h2><br> 下载<a href="" rel="nofollow">源材料。</a> 在<b>Cycles / Starter</b>文件夹中打开项目。 在指南的第一部分，了解关键概念，我们将专门处理<b>MainViewController.swif</b> t文件。 <br><br> 在MainViewController.swift的底部添加此类： <br><br><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(name: <span class="hljs-type"><span class="hljs-type">String</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.name = name <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"User \(name) was initialized"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">deinit</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Deallocating user named: \(name)"</span></span>) } }</code> </pre> <br> 这里定义了<b>User</b>类，它在<b>print</b>语句的帮助下向我们发出有关类实例的初始化和释放的信号。 <br><br> 现在，在MainViewController的顶部创建User类的实例。 <br><br> 将此代码放在<b>viewDidLoad（）</b>方法之前： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user = <span class="hljs-type"><span class="hljs-type">User</span></span>(name: <span class="hljs-string"><span class="hljs-string">"John"</span></span>)</code> </pre> <br> 启动应用程序。 使用<b>Command-Shift-Y</b>使Xcode控制台可见，以查看打印语句的输出。 <br><br> 注意， <b>已初始化用户John</b> ，该<b>用户</b>出现在控制台上，但未执行<b>deinit中</b>的print语句。 这意味着该对象未被释放，因为它没有超出<b>范围</b> 。 <br><br> 换句话说，除非包含该对象的视图控制器超出范围，否则该对象将永远不会被释放。 <br><br><h2> 他在范围内吗？ </h2><br> 通过将User类的实例包装在方法中，我们将允许它超出范围，从而允许ARC释放它。 <br><br> 让我们在MainViewController类中创建<b>runScenario（）</b>方法，并在其中移动User类实例的初始化。 <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runScenario</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user = <span class="hljs-type"><span class="hljs-type">User</span></span>(name: <span class="hljs-string"><span class="hljs-string">"John"</span></span>) }</code> </pre><br>  runScenario（）定义User实例的范围。 退出该区域时，必须释放<b>用户</b> 。 <br><br> 现在调用runScenario（）将其添加到viewDidLoad（）的末尾： <br><br><pre> <code class="swift hljs">runScenario()</code> </pre> <br> 启动应用程序。 现在，控制台输出如下所示： <br><br> 用户John已初始化 <br> 取消分配用户名为：John <br><br> 这意味着您释放了离开视野的对象。 <br><br><h2> 对象寿命 </h2><br><br> 对象的存在分为五个阶段： <br><br><ul><li> 内存分配：从堆栈还是从堆 </li><li> 初始化：代码在init内部执行 </li><li> 使用 </li><li> 反初始化：代码在反初始化内部执行 </li><li> 可用内存：已分配的内存返回到堆栈或堆 </li></ul><br> 没有直接方法可以跟踪分配和释放内存的步骤，但是可以在init和deinit中使用代码。 <br><br>  <b>参考计数</b> （也称为<b>使用计数</b> ）确定何时不再需要某个对象。 此计数器显示“使用”该对象的人数。 当使用计数器为零时，不需要对象。 然后，该对象被取消初始化并释放。 <br><br><img src="https://habrastorage.org/webt/b5/oo/78/b5oo78ealf173ey0ayz7rngnszk.png"><br><br> 初始化User对象时，其引用计数为1，因为<b>用户</b>常数引用了此对象。 <br><br> 在runScenario（）的末尾，用户超出范围，并且引用计数减少为0。结果，用户未初始化然后释放。 <br><br><h2> 参考周期 </h2><br> 在大多数情况下，ARC可以正常工作。 当未使用的对象无限期地未分配时，开发人员通常无需担心内存泄漏。 <br><br> 但并非总是如此！ 可能的内存泄漏。 <br><br> 怎么会这样 想象一个情况，不再使用两个对象，但每个对象都引用另一个对象。 由于每个引用计数都不为0，因此不会释放它们。 <br><br><img src="https://habrastorage.org/webt/hd/zp/ff/hdzpffk1eh3rug0fgmgnlghnb3q.png"><br><br> 这是一个<b>很强的参考周期</b> 。 这种情况会使ARC感到困惑，并且不允许它清除内存。 <br><br> 如您所见，结尾处的引用计数不为0，尽管不再需要任何对象，但是object1和object2将不会被释放。 <br><br><h2> 查看我们的链接 </h2><br> 要测试所有这些，请在MainViewController.swift中的User类之后添加以下代码： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phone</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> model: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> owner: <span class="hljs-type"><span class="hljs-type">User?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(model: <span class="hljs-type"><span class="hljs-type">String</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.model = model <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Phone \(model) was initialized"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">deinit</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Deallocating phone named: \(model)"</span></span>) } }</code> </pre> <br> 这段代码添加了一个新的<b>Phone</b>类，它具有两个属性，一个用于模型，一个用于所有者，以及init和deinit方法。 所有者的属性是可选的，因为手机可能没有所有者。 <br><br> 现在将此行添加到runScenario（）： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iPhone = <span class="hljs-type"><span class="hljs-type">Phone</span></span>(model: <span class="hljs-string"><span class="hljs-string">"iPhone Xs"</span></span>)</code> </pre><br> 这将创建Phone类的实例。 <br><br><h2> 握住手机 </h2><br> 现在，在name属性之后，立即将以下代码添加到User类： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> phones: [<span class="hljs-type"><span class="hljs-type">Phone</span></span>] = [] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(phone: Phone)</span></span></span></span> { phones.append(phone) phone.owner = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> }</code> </pre><br> 添加用户拥有的电话阵列。 该设置程序被标记为私有，因此必须使用add（phone :)。 <br><br> 启动应用程序。 如您所见，将根据需要释放Phone和User对象类的实例。 <br><br> 用户John已初始化 <br> 手机iPhone XS已初始化 <br> 取消分配名为：iPhone Xs的电话 <br> 取消分配用户名为：John <br><br> 现在，将其添加到runScenario（）的末尾： <br><pre> <code class="swift hljs">user.add(phone: iPhone)</code> </pre> <br><br> 在这里，我们将iPhone添加到<b>用户</b>拥有的手机列表中，还将手机的<b>owner</b>属性设置为' <b>user</b> '。 <br><br> 再次运行该应用程序。 您将看到未释放用户和iPhone对象。 它们之间的强链接周期阻止ARC释放它们。 <br><br><img src="https://habrastorage.org/webt/lo/az/mu/loazmuamyoww2ttr7wnwcd8_n4w.png"><br><br><h2> 链接弱 </h2><br> 要中断强链接的循环，可以将对象之间的关系指定为弱链接。 <br><br> 默认情况下，所有链接都是强链接，分配会导致引用计数增加。 使用弱引用时，引用计数不会增加。 <br><br> 换句话说， <b>弱链接不会影响对象的寿命管理</b> 。 弱链接始终被声明为<b>可选</b> 。 这样，当链接计数变为0时，可以将链接设置为nil。 <br><br><img src="https://habrastorage.org/webt/ti/qd/kc/tiqdkcyfstrndd8xswpf8zfebfo.png"><br><br> 在此图示中，虚线表示弱链接。 请注意，对象1的引用计数为1，因为变量1引用了它。 对象2的引用计数为2，因为它由变量2和对象1引用。 <br><br>  object2也引用object1，但引用为<b>WEAK</b> ，这意味着它不影响object1的引用计数。 <br><br> 当释放variable1和variable2时，object1的引用计数为0，这将释放它。 反过来，这释放了对object2的强烈引用，这已经导致了它的发布。 <br><br> 在Phone类中，如下更改owner属性声明： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> owner: <span class="hljs-type"><span class="hljs-type">User?</span></span></code> </pre> <br> 通过将所有者属性引用声明为“弱”，我们打破了User和Phone类之间的牢固链接循环。 <br><br><img src="https://habrastorage.org/webt/ym/ax/_m/ymax_mv9cvlpi8xqwnxmb14vr2g.png"><br><br> 启动应用程序。 现在，用户和电话已正确释放。 <br><br><h2> 无主链接 </h2><br> 还有另一个不会增加引用计数的链接修饰符： <b>unowned</b> 。 <br><br>  <b>无主和</b> <b>弱者有</b>什么区别？ 弱引用始终是可选的，并且在释放所引用的对象时会自动变为nil。 <br><br> 这就是为什么我们应将弱属性声明为类型的可选变量：为什么必须更改此属性。 <br><br> 相反，无主链接绝不是可选的。 如果尝试访问引用已释放对象的无主属性，则会收到一个错误，该错误看起来像是强制展开，其中包含nil变量（强制展开）。 <br><br><img src="https://habrastorage.org/webt/i9/hf/bc/i9hfbcizzk2eg38s_hidjq3evju.png"><br><br> 让我们尝试应用<b>unown</b> 。 <br><br> 在MainViewController.swift的末尾添加一个新的<b>CarrierSubscription</b>类： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CarrierSubscription</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> countryCode: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> number: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user: <span class="hljs-type"><span class="hljs-type">User</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(name: <span class="hljs-type"><span class="hljs-type">String</span></span>, countryCode: <span class="hljs-type"><span class="hljs-type">String</span></span>, number: <span class="hljs-type"><span class="hljs-type">String</span></span>, user: <span class="hljs-type"><span class="hljs-type">User</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.name = name <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.countryCode = countryCode <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.number = number <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.user = user <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"CarrierSubscription \(name) is initialized"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">deinit</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Deallocating CarrierSubscription named: \(name)"</span></span>) } }</code> </pre> <br>  CarrierSubscription具有四个属性： <br><br> 名称：提供者名称。 <br>  CountryCode：国家代码。 <br> 号码：电话号码。 <br> 用户：链接到用户。 <br><br><h2> 谁是您的提供者？ </h2><br> 现在，将其添加到name属性之后的User类中： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> subscriptions: [<span class="hljs-type"><span class="hljs-type">CarrierSubscription</span></span>] = []</code> </pre> <br> 在这里，我们保留了一系列用户提供程序。 <br><br> 现在，在owner属性之后，将其添加到Phone类： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> carrierSubscription: <span class="hljs-type"><span class="hljs-type">CarrierSubscription?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provision</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(carrierSubscription: CarrierSubscription)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.carrierSubscription = carrierSubscription } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decommission</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { carrierSubscription = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br> 这将添加可选的CarrierSubscription属性以及向提供者注册和注销电话的两种方法。 <br><br> 现在，在print语句之前，在init方法内添加CarrierSubscription类： <br><br><pre> <code class="swift hljs">user.subscriptions.append(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)</code> </pre> <br> 我们将CarrierSubscription添加到用户提供者数组中。 <br><br> 最后，将其添加到runScenario（）方法的末尾： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> subscription = <span class="hljs-type"><span class="hljs-type">CarrierSubscription</span></span>( name: <span class="hljs-string"><span class="hljs-string">"TelBel"</span></span>, countryCode: <span class="hljs-string"><span class="hljs-string">"0032"</span></span>, number: <span class="hljs-string"><span class="hljs-string">"31415926"</span></span>, user: user) iPhone.provision(carrierSubscription: subscription)</code> </pre> <br> 我们为用户创建了对提供商的订阅，并将电话连接到该订阅者。 <br><br> 启动应用程序。 在控制台中，您将看到： <br><br> 用户John已初始化 <br> 手机iPhone Xs已初始化 <br> 运营商订阅电话已初始化 <br><br> 再一次链接周期！ 用户，iPhone和订阅最终并未免费。 <br><br> 你能找到问题吗？ <br><br><img src="https://habrastorage.org/webt/uu/fg/eq/uufgeqkvqa31jwwlsnlikc-iob8.png"><br><br><h2> 打破链条 </h2><br> 从用户到订阅的链接或从订阅到用户的链接都必须是无所有权的，才能打破循环。 问题是要选择哪个选项。 让我们看一下结构。 <br><br> 用户拥有对提供者的订阅，但反之亦然-不，对提供者的订阅不拥有用户。 <br><br> 此外，如果不参考拥有CarrierSubscription的用户，就没有意义。 <br><br> 因此，用户链接必须是无主的。 <br><br> 在CarrierSubscription中更改用户声明： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user: <span class="hljs-type"><span class="hljs-type">User</span></span></code> </pre><br> 现在，用户为无主用户，这打破了链接循环，并允许您释放所有对象。 <br><br><img src="https://habrastorage.org/webt/en/vx/cu/envxcuihbevfcfqv1cyg-kc3lo4.png"><br><br><h2> 闭包中的循环链接 </h2><br> 当对象具有彼此引用的属性时，将发生对象的链接周期。 像对象一样，闭包是引用类型，并且可能导致引用循环。 闭包捕获它们使用的对象。 <br><br> 例如，如果您为一个类的属性分配一个闭包，并且该闭包使用同一类的属性，那么我们会得到一个链接循环。 换句话说，该对象通过该属性拥有一个到闭包的链接。 闭包包含通过捕获的self值对对象的引用。 <br><br><img src="https://habrastorage.org/webt/z-/lh/ow/z-lhowlkfyvy4ycusafxhygjisw.png"><br><br> 在用户属性之后，立即将此代码添加到CarrierSubscription中： <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> completePhoneNumber: () -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.countryCode + <span class="hljs-string"><span class="hljs-string">" "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.number }</code> </pre><br> 此闭包计算并返回完整的电话号码。 该属性声明为<b>lazy</b> ，它将在首次使用时分配。 <br><br> 这是必需的，因为它使用self.countryCode和self.number，在执行初始化程序代码之前它们将不可用。 <br><br> 将runScenario（）添加到末尾： <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(subscription.completePhoneNumber())</code> </pre> <br> 调用completePhoneNumber（）将执行关闭。 <br><br> 启动该应用程序，您将看到已释放用户和iPhone，但由于对象和闭包之间的紧密链接的循环而未发行CarrierSubscription。 <br><br><img src="https://habrastorage.org/webt/7t/rb/ax/7trbaxtrrhtadtm29-dvqwehzo4.png"><br><br><h2> 捕获列表 </h2><br>  Swift提供了一种简单而优雅的方法来打破闭包中强链接的循环。 您声明一个捕获列表，在其中定义闭包与其捕获的对象之间的关系。 <br><br> 为了演示捕获列表，请考虑以下代码： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> someClosure = { [x] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"\(x), \(y)"</span></span>) } x = <span class="hljs-number"><span class="hljs-number">6</span></span> y = <span class="hljs-number"><span class="hljs-number">6</span></span> someClosure() <span class="hljs-comment"><span class="hljs-comment">// Prints 5, 6 print("\(x), \(y)") // Prints 6, 6</span></span></code> </pre> <br>  x在闭包捕获列表中，因此x的值被复制到闭包定义中。 它是按值捕获的。 <br><br>  y不在捕获列表中，它通过引用捕获。 这意味着y的值将与电路被调用时的值相同。 <br><br> 锁定列表有助于识别与循环中捕获的对象有关的弱交互或无主交互。 在我们的情况下，没有适当的选择，因为如果释放CarrierSubscription实例，闭包将不存在。 <br><br><h2> 抓紧自己 </h2><br> 用CarrierSubscription替换completePhoneNumber定义:: <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> completePhoneNumber: () -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> = { [<span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.countryCode + <span class="hljs-string"><span class="hljs-string">" "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.number }</code> </pre> <br> 我们将<b>[unown self]</b>添加到关闭捕获列表中。 这意味着我们将<b>自我</b>作为一个<b>无主的</b>链接而不是一个牢固的链接。 <br><br> 启动应用程序，您将看到CarrierSubscription现在已发布。 <br><br> 实际上，以上语法是更长和更完整的语法的一种简短形式，其中出现了一个新变量： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> closure = { [<span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> newID = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-comment"><span class="hljs-comment">// Use unowned newID here... }</span></span></code> </pre> <br> 这里newID是self的无主副本。 除了封闭之外，自我依然存在。 在前面给出的简短形式中，我们<b>创建了一个新的self变量</b> ，该<b>变量</b>使闭包内部现有的self变得模糊。 <br><br><h2> 谨慎使用无所有权 </h2><br> 在您的代码中，self和completePhoneNumber之间的关系被指定为未拥有。 <br><br> 如果您确定不会释放闭包中使用的对象，则可以使用未拥有的对象。 如果他这样做，那您就麻烦了！ <br><br> 在MainViewController.swift的末尾添加以下代码： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WWDCGreeting</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> who: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(who: <span class="hljs-type"><span class="hljs-type">String</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.who = who } <span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> greetingMaker: () -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> = { [<span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Hello \(self.who)."</span></span> } }</code> </pre><br> 现在这是runScenario（）的结尾： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> greetingMaker: () -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mermaid = <span class="hljs-type"><span class="hljs-type">WWDCGreeting</span></span>(who: <span class="hljs-string"><span class="hljs-string">"caffeinated mermaid"</span></span>) greetingMaker = mermaid.greetingMaker } <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(greetingMaker()) <span class="hljs-comment"><span class="hljs-comment">// !</span></span></code> </pre> <br> 启动应用程序，您将在控制台中看到崩溃以及类似的信息： <br><br> 用户John已初始化 <br> 手机iPhone XS已初始化 <br> 运营商订阅电话已初始化 <br>  0032 31415926 <br> 致命错误：尝试读取一个未拥有的引用但对象0x600000f0de30已被释放2019-02-24 12：29：40.744248-0600周期[33489：5926466]致命错误：试图读取一个未拥有的引用但对象0x600000f0de30已被重新分配 <br><br> 发生异常是因为闭包等待self.who存在，但是在do块结尾时，一旦美人鱼超出范围，它就会被释放。 <br><br> 这个例子看起来像是用手指吮吸，但是这种事情会发生。 例如，当我们使用闭包在稍后启动某件事时，例如，在网络上的异步调用结束之后。 <br><br><h2> 疏通陷阱 </h2><br> 将WWDCGreeting类中的greetingMaker替换为： <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> greetingMaker: () -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> = { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Hello \(self?.who)."</span></span> }</code> </pre> <br> 我们做了两件事：首先，我们用弱者代替了无者者。 其次，由于自我变得虚弱，我们通过自我访问谁的财产？ 忽略Xcode警告，我们将尽快修复它。 <br><br> 该应用程序不再崩溃，但是如果您运行它，我们会得到一个有趣的结果：“你好，零。” <br><br> 也许结果是完全可以接受的，但是如果对象被释放，我们经常需要做一些事情。 可以使用guard语句来完成。 <br><br> 用以下内容替换关闭文本： <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> greetingMaker: () -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> = { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"No greeting available."</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Hello \(self.who)."</span></span> }</code> </pre><br> 保护声明分配从弱自我获取的自我。 如果self为nil，则闭包返回“无问候可用”。 否则，自我将成为有力的参考，因此可以保证对象活到关闭的最后。 <br><br><h2> 在Xcode 10中寻找链接循环 </h2><br> 现在您已经了解了ARC的工作原理，什么是链接循环以及如何中断它们，现在该看一个实际应用程序的示例了。 <br><br> 打开“联系人”文件夹中的Starter项目。 <br><br> 启动应用程序。 <br><br><img src="https://habrastorage.org/webt/a8/ce/l1/a8cel1rgbdkm_fel_d880f2swf4.png"><br><br> 这是最简单的联系人管理器。 尝试单击一个联系人，添加几个新联系人。 <br><br> 文件分配： <br><br>  ContactsTableViewController：显示所有联系人。 <br>  DetailViewController：显示所选联系人的详细信息。 <br>  NewContactViewController：允许您添加新联系人。 <br>  ContactTableViewCell：显示联系人详细信息的表单元格。 <br> 联系人：联系人模型。 <br> 号码：电话号码型号。 <br><br> 但是，对于这个项目，一切都是不好的：有一个循环的链接。 起初，由于泄漏内存较小，用户不会注意到问题，出于同样的原因，很难发现泄漏。 <br><br> 幸运的是，Xcode 10具有内置工具来查找最小的内存泄漏。 <br><br> 再次启动该应用程序。 使用向左滑动和删除按钮删除3-4个联系人。 好像它们完全消失了，对不对？ <br><br><img src="https://habrastorage.org/webt/xu/d9/qf/xud9qf3rcyaf5ot_08l8vauizto.png"><br><br><h2> 它流向哪里？ </h2><br> 当应用程序运行时，单击“调试内存图”按钮： <br><br><img src="https://habrastorage.org/webt/la/na/km/lanakmzc0d2ousrcf5jwkpu-ova.png"><br><br> 在“调试”导航器中观察“运行时问题”。 它们用紫色正方形标记，内部带有白色感叹号： <br><br><img src="https://habrastorage.org/webt/uc/ko/vj/uckovjp_eqoplopih79xuz1jl7e.png"><br><br> 在导航器中选择有问题的联系人对象之一。 周期清晰可见：相互关联的Contact和Number对象保持住。 <br><br><img src="https://habrastorage.org/webt/7f/wi/os/7fwios8n7zdk4ww7bj81p4kvgle.png"><br><br> 看起来您应该研究代码。 请记住，联系人可以不带数字而存在，反之亦然。 <br><br> 您将如何解决此循环？ 从联系人链接到号码还是从号码链接到联系人？ 虚弱还是无主？ 自己先尝试！ <br><br><div class="spoiler">  <b class="spoiler_title">如果您需要帮助...</b> <div class="spoiler_text"> 有2种可能的解决方案：要么使“联系人”到“号码”之间的链接弱，要么使“号码到联系人”不存在。 <br><br>  Apple的文档建议父对象强烈引用“子”，反之亦然。 这意味着我们为Contact提供了对Number的强烈引用，以及Number-Contact的未拥有链接： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Number</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contact: <span class="hljs-type"><span class="hljs-type">Contact</span></span> <span class="hljs-comment"><span class="hljs-comment">// Other code... } class Contact { var number: Number? // Other code... }</span></span></code> </pre> <br></div></div><br><h2> 奖励：循环使用引用类型和值类型。 </h2><br>  Swift具有引用类型（类和闭包）和值类型（结构，枚举）。 值类型在传递时将被复制，引用类型使用链接共享相同的值。 <br><br> 这意味着在值类型的情况下，将没有循环。 为了使循环发生，我们至少需要2种引用类型。 <br><br> 让我们回到Cycles项目，并在MainViewController.swift的末尾添加以下代码： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Error var payload = 0 var next: Node? }</span></span></code> </pre><br> 将无法正常工作！ 结构是一个值类型，不能对其自身的实例进行递归。 否则，这样的结构将具有无限的大小。 <br><br> 将结构更改为类。 <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> payload = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> next: <span class="hljs-type"><span class="hljs-type">Node?</span></span> }</code> </pre> <br> 对自身的引用对于类（引用类型）是完全可以接受的，因此编译器没有问题。 <br><br> 现在，将其添加到MainViewController.swift的末尾： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> friends: [<span class="hljs-type"><span class="hljs-type">Person</span></span>] = [] <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(name: <span class="hljs-type"><span class="hljs-type">String</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.name = name <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"New person instance: \(name)"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">deinit</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Person instance \(name) is being deallocated"</span></span>) } }</code> </pre> <br> 这是runScenario（）的结尾： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ernie = <span class="hljs-type"><span class="hljs-type">Person</span></span>(name: <span class="hljs-string"><span class="hljs-string">"Ernie"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bert = <span class="hljs-type"><span class="hljs-type">Person</span></span>(name: <span class="hljs-string"><span class="hljs-string">"Bert"</span></span>) ernie.friends.append(bert) <span class="hljs-comment"><span class="hljs-comment">// Not deallocated bert.friends.append(ernie) // Not deallocated }</span></span></code> </pre><br> 启动应用程序。 请注意：ernie和bert均未释放。 <br><br><h2> 链接和意义 </h2><br> 这是导致链接循环的引用类型和值类型组合的示例。 <br><br> 尽管ernie和bert本身是值类型，但它们仍未释放，彼此保持在其Friends数组中。 <br><br> 尝试将好友存档设置为“无主”，Xcode将显示错误：“无主”仅适用于类。 <br><br> 要修复此循环，我们必须创建一个包装对象，并使用它来将实例添加到数组。 <br><br> 在Person类之前添加以下定义： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Unowned</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnyObject</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value: <span class="hljs-type"><span class="hljs-type">T</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> (<span class="hljs-number"><span class="hljs-number">_</span></span> value: <span class="hljs-type"><span class="hljs-type">T</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value = value } }</code> </pre><br> 然后在Person类中更改friends的定义： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> friends: [<span class="hljs-type"><span class="hljs-type">Unowned</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Person</span></span>&gt;] = []</code> </pre> <br> 最后，替换runScenario（）中do块的内容： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ernie = <span class="hljs-type"><span class="hljs-type">Person</span></span>(name: <span class="hljs-string"><span class="hljs-string">"Ernie"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bert = <span class="hljs-type"><span class="hljs-type">Person</span></span>(name: <span class="hljs-string"><span class="hljs-string">"Bert"</span></span>) ernie.friends.append(<span class="hljs-type"><span class="hljs-type">Unowned</span></span>(bert)) bert.friends.append(<span class="hljs-type"><span class="hljs-type">Unowned</span></span>(ernie)) }</code> </pre> <br> 启动应用程序，现在ernie和bert已正确发布！ <br><br>  friends数组不再是Person对象的集合。 现在，这是一个<b>Unperson对象</b>的<b>集合，这些对象</b>充当Person实例的包装。 <br><br> 要从Unowned获取Person对象，请使用value属性： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstFriend = bert.friends.first?.value <span class="hljs-comment"><span class="hljs-comment">// get ernie</span></span></code> </pre> <br><h2> 结论 </h2><br> 您现在已经对Swift中的内存管理有了很好的了解，并且知道ARC的工作原理。 我希望该出版物对您有所帮助。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">苹果：自动引用计数</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN451130/">https://habr.com/ru/post/zh-CN451130/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN451116/index.html">我如何应对共享元素转换并编写了我的第一个开源库</a></li>
<li><a href="../zh-CN451118/index.html">测试不适合初学者</a></li>
<li><a href="../zh-CN451120/index.html">关于将死细胞移植到移动平台的挑战</a></li>
<li><a href="../zh-CN451124/index.html">使用Python和Transcriptic在云端开发蛋白质，或如何以360美元的价格创建蛋白质</a></li>
<li><a href="../zh-CN451126/index.html">研究人员的工具箱-问题一：自我组织和数据可视化</a></li>
<li><a href="../zh-CN451132/index.html">消费者驱动合同或Gitlab CI眼质量检查测试自动化</a></li>
<li><a href="../zh-CN451138/index.html">Symfony CLI-新的本地开发工具</a></li>
<li><a href="../zh-CN451140/index.html">创建物联网解决方案需要多少费用？</a></li>
<li><a href="../zh-CN451144/index.html">上古：电视广告技术</a></li>
<li><a href="../zh-CN451146/index.html">使用webpack加速Web应用程序构建</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>