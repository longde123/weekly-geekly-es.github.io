<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚚 🍒 🤚🏼 Die Perspektive von EcmaScript auf die allgemeine Theorie der OOP 👨‍🏫 😪 ⛹🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! 

 Bis heute habe ich meiner Meinung nach nur interessante Artikel englischsprachiger Autoren übersetzt. Und jetzt ist es Zeit, selbst etw...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Perspektive von EcmaScript auf die allgemeine Theorie der OOP</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468157/"> Hallo Habr! <br><br>  Bis heute habe ich meiner Meinung nach nur interessante Artikel englischsprachiger Autoren übersetzt.  Und jetzt ist es Zeit, selbst etwas zu schreiben.  Für den ersten Artikel habe ich ein Thema ausgewählt, das sicher für Nachwuchsentwickler nützlich sein wird, die in die "Mitte" wachsen wollen, weil  Es wird die Ähnlichkeit / den Unterschied zwischen JavaScript und klassischen Programmiersprachen (C ++, C #, Java) in Bezug auf OOP analysieren.  Also fangen wir an! <br><br><h3>  Die allgemeinen Bestimmungen des Paradigmas </h3><br>  Wenn wir uns die Definition von JavaScript in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia</a> ansehen, sehen wir das folgende Konzept: <br><blockquote>  JavaScript (/ ˈdʒɑːvːˌskrɪpt /; abbr. JS /ˈdʒeɪ.ɛs./) ist eine Programmiersprache mit mehreren Paradigmen.  Unterstützt objektorientierte, imperative und funktionale Stile.  Es ist eine Implementierung der ECMAScript-Sprache (ECMA-262-Standard). </blockquote><br>  Wie aus dieser Definition hervorgeht, existiert JavaScript nicht für sich, sondern ist eine Implementierung einiger EcmaScript-Spezifikationen.  Darüber hinaus implementieren andere Sprachen diese Spezifikation. <br><a name="habracut"></a><br>  Die folgenden Paradigmen sind in EcmaScript (im Folgenden: ES) vorhanden: <br><br><ul><li>  strukturell </li><li>  OOP </li><li>  funktional </li><li>  zwingend erforderlich </li><li>  aspektorientiert (in seltenen Fällen) </li></ul><br>  OOP in ES wird in einer <i>Prototyp-Organisation</i> implementiert.  Von unerfahrenen Entwicklern als Antwort auf die Frage: "Wie unterscheidet sich OOP in JS von OOP in klassischen Sprachen?"  In der Regel werden sie sehr vage: „Klassen sind in klassischen Sprachen und Prototypen in JS“. <br><br>  In Wirklichkeit ist die Situation etwas komplizierter.  In Bezug auf das Verhalten ist der Unterschied zwischen der <i>Dynamic Class Organization</i> und der <i>Prototype Organization</i> gering (es existiert zwar, ist aber nicht so global). <br><br>  Schauen Sie sich Python oder Ruby an.  In diesen Sprachen basiert OOP auf einer dynamischen Klassenorganisation.  In beiden Sprachen können wir die Klasse eines Objekts im Verlauf des Programms dynamisch ändern, und Änderungen innerhalb der Klasse wirken sich auch dynamisch auf die von ihr generierten Entitäten aus.  Genau wie in JS, aber in JS basiert OOP auf Prototypen. <br><br>  Ein signifikanter Unterschied zwischen Sprachen mit einer statischen Klassenorganisation und einer Prototyporganisation.  Der Unterschied an sich ist: „Es gibt Klassen.  hier Prototypen “sind nicht so bedeutend. <br><cut></cut><br><h4>  Worauf basiert die statische Klassenorganisation? </h4><br>  Grundlage dieser Art von OOP sind die Konzepte „Klasse“ und „Essenz“.  <i>Eine Klasse</i> ist eine bestimmte formalisierte verallgemeinerte Menge von Merkmalen von Entitäten, die sie generieren kann.  Das heißt,  Dies ist ein bestimmter allgemeiner Plan aller von ihm erzeugten Objekte. <br><br>  Es gibt zwei Arten von Merkmalen.  Eigenschaften (Beschreibung einer Entität) und Methoden (Aktivität einer Entität, deren Verhalten). <br><br>  Von einer Klasse generierte <i>Entitäten</i> sind Kopien dieser Klasse, jedoch mit initialisierten Eigenschaften.  Wie wir sehen, regelt die Klasse streng die Beschreibung einer Entität (Bereitstellung eines genau definierten Satzes von Eigenschaften) und ihr Verhalten (Bereitstellung einer streng definierten Liste von Methoden). <br><br>  Hier ist ein kleines Beispiel für JAVA: <br><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>{ String name; <span class="hljs-comment"><span class="hljs-comment">//  int age; //  void displayInfo(){ System.out.printf("Name: %s \tAge: %d\n", name, age); } }</span></span></code> </pre> <cut></cut><br>  Erstellen Sie nun eine Instanz der Klasse: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Program</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ Person tom; } }</code> </pre><br>  Unsere <u>Tom-</u> Entität hat alle Eigenschaften der <u>Person-</u> Klasse, sie hat auch alle Methoden ihrer Klasse. <br><br>  Das OOP-Paradigma bietet eine sehr breite Palette von Möglichkeiten zur Wiederverwendung von Code. Eine dieser Funktionen ist die <b>Vererbung</b> . <br><br>  Eine Klasse kann eine andere Klasse erweitern, wodurch eine Generalisierungs-Spezialisierungs-Beziehung erstellt wird.  In diesem Fall werden die Eigenschaften der allgemeinen Klasse (Oberklasse) beim Erstellen in die Essenz der untergeordneten Klasse kopiert, und die Methoden stehen als Referenz zur Verfügung (entsprechend der hierarchischen Vererbungskette).  Bei der statischen Klassentypisierung ist diese Kette <b>statisch</b> , und bei der dynamischen Typisierung kann sie sich während der Programmausführung ändern.  Dies ist der wichtigste Unterschied.  Ich rate Ihnen jetzt, sich an diesen Moment zu erinnern.  Wenn wir zur Prototyp-Organisation gelangen, wird das Wesentliche des Problems der Antwort „Es gibt Klassen, es gibt Prototypen“ offensichtlich. <br><br>  Was sind die Nachteile dieses Ansatzes? <br><br>  Ich denke, es ist offensichtlich, dass: <br><br><ul><li>  Im Wesentlichen kann es Eigenschaften geben, die niemals nützlich sein werden. </li><li>  Eine Klasse kann Eigenschaften und Methoden, die sie generierten Entitäten bereitstellt, nicht dynamisch ändern, hinzufügen, löschen, d. H.  kann seine Unterschrift nicht ändern. </li><li>  Im Wesentlichen können Eigenschaften oder Methoden, die in der Klasse des Elternteils (oder der hierarchischen Kette von Eltern) nicht vorhanden sind, nicht vorhanden sein </li><li>  Der Speicherverbrauch ist proportional zur Anzahl der Links in der Vererbungshierarchie (aufgrund von Kopiereigenschaften). </li></ul><br><h4>  Worauf basiert die Prototypenorganisation? </h4><br>  Das Schlüsselkonzept der Prototyporganisation ist ein dynamisch veränderbares Objekt (dmo).  DMO benötigt keine Klasse.  Er selbst kann alle seine Eigenschaften und Methoden speichern. <br><br>  Beim Festlegen eines DMO einer Eigenschaft wird geprüft, ob diese Eigenschaft darin vorhanden ist.  Wenn es eine Eigenschaft gibt, wird sie einfach zugewiesen. Wenn dies nicht der Fall ist, wird die Eigenschaft hinzugefügt und mit dem übergebenen Wert initialisiert.  DMOs können ihre Signatur während des Programms beliebig oft ändern. <br><br>  Hier ist ein Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//        const Person = { name: null, age: null, sayHi() { return `Hi! My name is ${this.name}. I'm ${this.age} years old.` } } const Tom = { //-       } Tom.__proto__ = Person;</span></span></code> </pre><br>  Ich denke, jeder in diesem Fach weiß, dass die Klassensyntax in ES6 erschienen ist, aber dies ist nichts weiter als syntaktischer Zucker, d. H.  Prototypen unter der Haube.  Der obige Code sollte nicht als gute Codierungspraxis angesehen werden.  Dies ist nichts weiter als eine Illustration. Sie wird in dieser Form dargestellt (jetzt verwenden alle normalen Menschen ES6-Klassen), um den Leser nicht zu verwirren und den Unterschied in den theoretischen Konzepten hervorzuheben. <br><br>  Wenn wir das Tom-Objekt an die Konsole ausgeben, sehen wir, dass das Objekt selbst nur den _proto_-Link enthält, der standardmäßig immer vorhanden ist.  Die Referenz verweist auf das Objekt Person, das ein Prototyp des Tom-Objekts ist. <br><br>  <b>Ein Prototyp</b> ist ein Objekt, das als Prototyp für andere Objekte oder als Objekt dient, in das ein anderes Objekt bei Bedarf Eigenschaften und Methoden zeichnen kann. <br><br>  Der Prototyp für ein Objekt kann ein beliebiges Objekt sein. Darüber hinaus kann ein Objekt seinen Prototyp während des Programms neu zuweisen. <br><br>  Kommen wir zurück zu unserem Tom: <br><br><pre> <code class="javascript hljs">Tom.name = <span class="hljs-string"><span class="hljs-string">'Tom'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    Tom.surname = 'Williams'; //    Tom.age = 28;//    Tom.sayHi();//  sayHi,      ,    ,       const tomSon = { name: 'John', age: 5, sayHi() { return this.__proto__.sayHi.call(this) + `My father is ${this.__proto__.name} ${this.surname}`; } } //,     tomSon.__proto__ = Tom; tomSon.sayHi();//  "Hi! My name is John. I'm 5 years old.My father is Tom Williams"</span></span></code> </pre><br>  Beachten Sie, dass der Name, die Alterseigenschaften und die sayHi-Methode die Eigenschaften des tomSon-Objekts sind.  Gleichzeitig rufen wir die sayHi-Prototypmethode in tomSon sayHi explizit so auf, als wäre sie im Tom-Objekt, aber tatsächlich ist sie nicht vorhanden und wird implizit vom Person-Prototyp zurückgegeben. Wir arbeiten auch explizit mit dem Namen der Prototyp-Eigenschaft und erhalten implizit get die Nachnamen-Eigenschaft, die wir als unsere eigene Eigenschaft des tomSon-Objekts bezeichnen, aber tatsächlich nicht vorhanden ist.  Die Nachnameigenschaft wird implizit über den Link <b>__proto__</b> vom Prototyp <b>abgerufen</b> . <br><br>  Wir setzen die Entwicklung der Geschichte unseres Tom und seines Sohnes John fort. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ,    (  ) //  ,   ,    , //      const Ben = { name: 'Ben', surname: 'Silver', age: 42, sayHi() { return `Hello! I'm ${this.name} ${this.surname}. `; } } tomSon.nativeFather = Tom; tomSon.__proto__= Ben; tomSon.sayHi(); //    (),     () //   'Hello! I'm John Silver. My father is Ben Silver'</span></span></code> </pre><br>  Bitte beachten Sie, dass wir während des Programms den Prototyp des bereits erstellten Objekts geändert haben.  Dies ist die Ähnlichkeit der <b>Prototyp-Organisation</b> und der <b>dynamischen Klassenorganisation</b> .  Deshalb lautet die Antwort "Es gibt Klassen, es gibt Prototypen" auf die Frage "Was ist der Unterschied zwischen klassischen Sprachen und JavaScript?"  nicht ganz korrekt und weist auf ein Missverständnis der OOP-Theorie und ihrer Implementierung in Klassen und / oder Prototypen hin. <br><br>  Bei der Prototyp-Organisation haben wir im Gegensatz zur statischen Klassenorganisation die Möglichkeit, Änderungen am Prototyp vorzunehmen, nachdem eine Entität erstellt wurde, die die Eigenschaften dieses Prototyps erbt. Diese Änderungen wirken sich auf die bereits erstellte Entität aus. <br><br><pre> <code class="javascript hljs">Ben.hobbies = [<span class="hljs-string"><span class="hljs-string">'chess'</span></span>, <span class="hljs-string"><span class="hljs-string">'badminton'</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// tomSon   ,             ,      tomSon.sayAboutFathersHobies = function () { const reducer = (accumulator, current) =&gt; {`${accumulator} and ${current}`} return `My Father play ${this.hobbies.reduce(reducer)}` } tomSon.sayAboutFathersHobies(); //  'My Father play chess and badminton'</span></span></code> </pre><br>  Dies wird als <i>Prototyporganisation bezeichnet, die die Modell-</i> oder <i>Prototypvererbung</i> <i>delegiert</i> . <br><br><h4>  Wie wird die Fähigkeit einer Entität bestimmt, ein bestimmtes Verhalten zu implementieren? </h4><br>  In einer statischen Klassenorganisation umfasst diese Operation das Überprüfen der Entität auf Mitgliedschaft in einer bestimmten Klasse, die das erforderliche Verhalten implementiert.  In der Prototypenorganisation gibt es das Konzept der <i>Ententypisierung</i> .  Im Fall der Ententypisierung bedeutet das Überprüfen der Entität auf die Fähigkeit, ein bestimmtes Verhalten zu implementieren, das direkte Testen der Entität auf die Fähigkeit, dieses Verhalten zu einem bestimmten Zeitpunkt zu implementieren, d. H.  In verschiedenen Teilen des Programms kann das Ergebnis der Überprüfung diametral entgegengesetzt sein. <br><br>  Was sind die Vorteile eines Prototypansatzes? <br><br><ul><li>  Mehr Flexibilität </li><li>  Entitäten haben keine Eigenschaften, die sie nicht benötigen. </li></ul><br>  Was sind die Nachteile? <br><br><ul><li>  Weniger klar </li><li>  Es ist nicht immer einfach zu verfolgen, was als Ausgangspunkt für das unerwünschte Verhalten des Unternehmens diente, d. H.  Der Prototyp ist weniger vorhersehbar als die statische Klassenorganisation </li><li>  Die Softwareentwickler sind trotz der Popularität und Verbreitung von JavaScript nicht ausreichend damit vertraut </li></ul><br><h3>  Fazit </h3><br>  Damit werden wir heute enden.  Ich hoffe, dass ich die Idee vermitteln konnte, dass der Unterschied zwischen klassischen Sprachen und JavaScript nicht mit dem Vorhandensein / Fehlen von Klassen und dem Vorhandensein / Fehlen von Prototypen zusammenhängt, sondern mit der statischen / dynamischen Natur der Organisation. <br><br>  Natürlich wurde viel nicht berücksichtigt.  Ich möchte keine Artikel schreiben, die zu lang sind, daher werden die Funktionen des Cascade-Modells in der Prototyp-Organisation und in den OOP-Tools (Polymorphismus, Kapselung, Abstraktion usw.) in den folgenden Artikeln erläutert. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468157/">https://habr.com/ru/post/de468157/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468143/index.html">466 Terabit: Der weltweite Internetverkehr wächst weiter. Können Satelliten mit U-Boot-Kabeln konkurrieren?</a></li>
<li><a href="../de468145/index.html">Tests oder Typen? - Rostversion</a></li>
<li><a href="../de468147/index.html">Einladung zur Lichtshow „Circle of Light“ 2019 in Moskau und ein kleiner Insider von einem der Standorte</a></li>
<li><a href="../de468151/index.html">Schwachstellen in GeekBrains: Warum Geld für Kurse bezahlen, wenn Sie diese nur herunterladen können?</a></li>
<li><a href="../de468155/index.html">Neue Produkttrends</a></li>
<li><a href="../de468161/index.html">Die gierige Leuchte: Warum Sonnenenergie die Welt nicht eroberte und wie das „russische Mineral“ sie retten kann</a></li>
<li><a href="../de468163/index.html">Oracle VM Server für SPARC for Dummies (Anleitung)</a></li>
<li><a href="../de468165/index.html">Wie der Browser zeichnet. Yandex-Bericht</a></li>
<li><a href="../de468167/index.html">Lebe und lerne. Teil 4. Während der Arbeit lernen?</a></li>
<li><a href="../de468169/index.html">JQuery Geschichte und Erbe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>