<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöö üçí ü§öüèº Die Perspektive von EcmaScript auf die allgemeine Theorie der OOP üë®‚Äçüè´ üò™ ‚õπüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! 

 Bis heute habe ich meiner Meinung nach nur interessante Artikel englischsprachiger Autoren √ºbersetzt. Und jetzt ist es Zeit, selbst etw...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Perspektive von EcmaScript auf die allgemeine Theorie der OOP</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468157/"> Hallo Habr! <br><br>  Bis heute habe ich meiner Meinung nach nur interessante Artikel englischsprachiger Autoren √ºbersetzt.  Und jetzt ist es Zeit, selbst etwas zu schreiben.  F√ºr den ersten Artikel habe ich ein Thema ausgew√§hlt, das sicher f√ºr Nachwuchsentwickler n√ºtzlich sein wird, die in die "Mitte" wachsen wollen, weil  Es wird die √Ñhnlichkeit / den Unterschied zwischen JavaScript und klassischen Programmiersprachen (C ++, C #, Java) in Bezug auf OOP analysieren.  Also fangen wir an! <br><br><h3>  Die allgemeinen Bestimmungen des Paradigmas </h3><br>  Wenn wir uns die Definition von JavaScript in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia</a> ansehen, sehen wir das folgende Konzept: <br><blockquote>  JavaScript (/ Ààd í…ëÀêvÀêÀåskr…™pt /; abbr. JS /Ààd íe…™.…õs./) ist eine Programmiersprache mit mehreren Paradigmen.  Unterst√ºtzt objektorientierte, imperative und funktionale Stile.  Es ist eine Implementierung der ECMAScript-Sprache (ECMA-262-Standard). </blockquote><br>  Wie aus dieser Definition hervorgeht, existiert JavaScript nicht f√ºr sich, sondern ist eine Implementierung einiger EcmaScript-Spezifikationen.  Dar√ºber hinaus implementieren andere Sprachen diese Spezifikation. <br><a name="habracut"></a><br>  Die folgenden Paradigmen sind in EcmaScript (im Folgenden: ES) vorhanden: <br><br><ul><li>  strukturell </li><li>  OOP </li><li>  funktional </li><li>  zwingend erforderlich </li><li>  aspektorientiert (in seltenen F√§llen) </li></ul><br>  OOP in ES wird in einer <i>Prototyp-Organisation</i> implementiert.  Von unerfahrenen Entwicklern als Antwort auf die Frage: "Wie unterscheidet sich OOP in JS von OOP in klassischen Sprachen?"  In der Regel werden sie sehr vage: ‚ÄûKlassen sind in klassischen Sprachen und Prototypen in JS‚Äú. <br><br>  In Wirklichkeit ist die Situation etwas komplizierter.  In Bezug auf das Verhalten ist der Unterschied zwischen der <i>Dynamic Class Organization</i> und der <i>Prototype Organization</i> gering (es existiert zwar, ist aber nicht so global). <br><br>  Schauen Sie sich Python oder Ruby an.  In diesen Sprachen basiert OOP auf einer dynamischen Klassenorganisation.  In beiden Sprachen k√∂nnen wir die Klasse eines Objekts im Verlauf des Programms dynamisch √§ndern, und √Ñnderungen innerhalb der Klasse wirken sich auch dynamisch auf die von ihr generierten Entit√§ten aus.  Genau wie in JS, aber in JS basiert OOP auf Prototypen. <br><br>  Ein signifikanter Unterschied zwischen Sprachen mit einer statischen Klassenorganisation und einer Prototyporganisation.  Der Unterschied an sich ist: ‚ÄûEs gibt Klassen.  hier Prototypen ‚Äúsind nicht so bedeutend. <br><cut></cut><br><h4>  Worauf basiert die statische Klassenorganisation? </h4><br>  Grundlage dieser Art von OOP sind die Konzepte ‚ÄûKlasse‚Äú und ‚ÄûEssenz‚Äú.  <i>Eine Klasse</i> ist eine bestimmte formalisierte verallgemeinerte Menge von Merkmalen von Entit√§ten, die sie generieren kann.  Das hei√üt,  Dies ist ein bestimmter allgemeiner Plan aller von ihm erzeugten Objekte. <br><br>  Es gibt zwei Arten von Merkmalen.  Eigenschaften (Beschreibung einer Entit√§t) und Methoden (Aktivit√§t einer Entit√§t, deren Verhalten). <br><br>  Von einer Klasse generierte <i>Entit√§ten</i> sind Kopien dieser Klasse, jedoch mit initialisierten Eigenschaften.  Wie wir sehen, regelt die Klasse streng die Beschreibung einer Entit√§t (Bereitstellung eines genau definierten Satzes von Eigenschaften) und ihr Verhalten (Bereitstellung einer streng definierten Liste von Methoden). <br><br>  Hier ist ein kleines Beispiel f√ºr JAVA: <br><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>{ String name; <span class="hljs-comment"><span class="hljs-comment">//  int age; //  void displayInfo(){ System.out.printf("Name: %s \tAge: %d\n", name, age); } }</span></span></code> </pre> <cut></cut><br>  Erstellen Sie nun eine Instanz der Klasse: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Program</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ Person tom; } }</code> </pre><br>  Unsere <u>Tom-</u> Entit√§t hat alle Eigenschaften der <u>Person-</u> Klasse, sie hat auch alle Methoden ihrer Klasse. <br><br>  Das OOP-Paradigma bietet eine sehr breite Palette von M√∂glichkeiten zur Wiederverwendung von Code. Eine dieser Funktionen ist die <b>Vererbung</b> . <br><br>  Eine Klasse kann eine andere Klasse erweitern, wodurch eine Generalisierungs-Spezialisierungs-Beziehung erstellt wird.  In diesem Fall werden die Eigenschaften der allgemeinen Klasse (Oberklasse) beim Erstellen in die Essenz der untergeordneten Klasse kopiert, und die Methoden stehen als Referenz zur Verf√ºgung (entsprechend der hierarchischen Vererbungskette).  Bei der statischen Klassentypisierung ist diese Kette <b>statisch</b> , und bei der dynamischen Typisierung kann sie sich w√§hrend der Programmausf√ºhrung √§ndern.  Dies ist der wichtigste Unterschied.  Ich rate Ihnen jetzt, sich an diesen Moment zu erinnern.  Wenn wir zur Prototyp-Organisation gelangen, wird das Wesentliche des Problems der Antwort ‚ÄûEs gibt Klassen, es gibt Prototypen‚Äú offensichtlich. <br><br>  Was sind die Nachteile dieses Ansatzes? <br><br>  Ich denke, es ist offensichtlich, dass: <br><br><ul><li>  Im Wesentlichen kann es Eigenschaften geben, die niemals n√ºtzlich sein werden. </li><li>  Eine Klasse kann Eigenschaften und Methoden, die sie generierten Entit√§ten bereitstellt, nicht dynamisch √§ndern, hinzuf√ºgen, l√∂schen, d. H.  kann seine Unterschrift nicht √§ndern. </li><li>  Im Wesentlichen k√∂nnen Eigenschaften oder Methoden, die in der Klasse des Elternteils (oder der hierarchischen Kette von Eltern) nicht vorhanden sind, nicht vorhanden sein </li><li>  Der Speicherverbrauch ist proportional zur Anzahl der Links in der Vererbungshierarchie (aufgrund von Kopiereigenschaften). </li></ul><br><h4>  Worauf basiert die Prototypenorganisation? </h4><br>  Das Schl√ºsselkonzept der Prototyporganisation ist ein dynamisch ver√§nderbares Objekt (dmo).  DMO ben√∂tigt keine Klasse.  Er selbst kann alle seine Eigenschaften und Methoden speichern. <br><br>  Beim Festlegen eines DMO einer Eigenschaft wird gepr√ºft, ob diese Eigenschaft darin vorhanden ist.  Wenn es eine Eigenschaft gibt, wird sie einfach zugewiesen. Wenn dies nicht der Fall ist, wird die Eigenschaft hinzugef√ºgt und mit dem √ºbergebenen Wert initialisiert.  DMOs k√∂nnen ihre Signatur w√§hrend des Programms beliebig oft √§ndern. <br><br>  Hier ist ein Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//        const Person = { name: null, age: null, sayHi() { return `Hi! My name is ${this.name}. I'm ${this.age} years old.` } } const Tom = { //-       } Tom.__proto__ = Person;</span></span></code> </pre><br>  Ich denke, jeder in diesem Fach wei√ü, dass die Klassensyntax in ES6 erschienen ist, aber dies ist nichts weiter als syntaktischer Zucker, d. H.  Prototypen unter der Haube.  Der obige Code sollte nicht als gute Codierungspraxis angesehen werden.  Dies ist nichts weiter als eine Illustration. Sie wird in dieser Form dargestellt (jetzt verwenden alle normalen Menschen ES6-Klassen), um den Leser nicht zu verwirren und den Unterschied in den theoretischen Konzepten hervorzuheben. <br><br>  Wenn wir das Tom-Objekt an die Konsole ausgeben, sehen wir, dass das Objekt selbst nur den _proto_-Link enth√§lt, der standardm√§√üig immer vorhanden ist.  Die Referenz verweist auf das Objekt Person, das ein Prototyp des Tom-Objekts ist. <br><br>  <b>Ein Prototyp</b> ist ein Objekt, das als Prototyp f√ºr andere Objekte oder als Objekt dient, in das ein anderes Objekt bei Bedarf Eigenschaften und Methoden zeichnen kann. <br><br>  Der Prototyp f√ºr ein Objekt kann ein beliebiges Objekt sein. Dar√ºber hinaus kann ein Objekt seinen Prototyp w√§hrend des Programms neu zuweisen. <br><br>  Kommen wir zur√ºck zu unserem Tom: <br><br><pre> <code class="javascript hljs">Tom.name = <span class="hljs-string"><span class="hljs-string">'Tom'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    Tom.surname = 'Williams'; //    Tom.age = 28;//    Tom.sayHi();//  sayHi,      ,    ,       const tomSon = { name: 'John', age: 5, sayHi() { return this.__proto__.sayHi.call(this) + `My father is ${this.__proto__.name} ${this.surname}`; } } //,     tomSon.__proto__ = Tom; tomSon.sayHi();//  "Hi! My name is John. I'm 5 years old.My father is Tom Williams"</span></span></code> </pre><br>  Beachten Sie, dass der Name, die Alterseigenschaften und die sayHi-Methode die Eigenschaften des tomSon-Objekts sind.  Gleichzeitig rufen wir die sayHi-Prototypmethode in tomSon sayHi explizit so auf, als w√§re sie im Tom-Objekt, aber tats√§chlich ist sie nicht vorhanden und wird implizit vom Person-Prototyp zur√ºckgegeben. Wir arbeiten auch explizit mit dem Namen der Prototyp-Eigenschaft und erhalten implizit get die Nachnamen-Eigenschaft, die wir als unsere eigene Eigenschaft des tomSon-Objekts bezeichnen, aber tats√§chlich nicht vorhanden ist.  Die Nachnameigenschaft wird implizit √ºber den Link <b>__proto__</b> vom Prototyp <b>abgerufen</b> . <br><br>  Wir setzen die Entwicklung der Geschichte unseres Tom und seines Sohnes John fort. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ,    (  ) //  ,   ,    , //      const Ben = { name: 'Ben', surname: 'Silver', age: 42, sayHi() { return `Hello! I'm ${this.name} ${this.surname}. `; } } tomSon.nativeFather = Tom; tomSon.__proto__= Ben; tomSon.sayHi(); //    (),     () //   'Hello! I'm John Silver. My father is Ben Silver'</span></span></code> </pre><br>  Bitte beachten Sie, dass wir w√§hrend des Programms den Prototyp des bereits erstellten Objekts ge√§ndert haben.  Dies ist die √Ñhnlichkeit der <b>Prototyp-Organisation</b> und der <b>dynamischen Klassenorganisation</b> .  Deshalb lautet die Antwort "Es gibt Klassen, es gibt Prototypen" auf die Frage "Was ist der Unterschied zwischen klassischen Sprachen und JavaScript?"  nicht ganz korrekt und weist auf ein Missverst√§ndnis der OOP-Theorie und ihrer Implementierung in Klassen und / oder Prototypen hin. <br><br>  Bei der Prototyp-Organisation haben wir im Gegensatz zur statischen Klassenorganisation die M√∂glichkeit, √Ñnderungen am Prototyp vorzunehmen, nachdem eine Entit√§t erstellt wurde, die die Eigenschaften dieses Prototyps erbt. Diese √Ñnderungen wirken sich auf die bereits erstellte Entit√§t aus. <br><br><pre> <code class="javascript hljs">Ben.hobbies = [<span class="hljs-string"><span class="hljs-string">'chess'</span></span>, <span class="hljs-string"><span class="hljs-string">'badminton'</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// tomSon   ,             ,      tomSon.sayAboutFathersHobies = function () { const reducer = (accumulator, current) =&gt; {`${accumulator} and ${current}`} return `My Father play ${this.hobbies.reduce(reducer)}` } tomSon.sayAboutFathersHobies(); //  'My Father play chess and badminton'</span></span></code> </pre><br>  Dies wird als <i>Prototyporganisation bezeichnet, die die Modell-</i> oder <i>Prototypvererbung</i> <i>delegiert</i> . <br><br><h4>  Wie wird die F√§higkeit einer Entit√§t bestimmt, ein bestimmtes Verhalten zu implementieren? </h4><br>  In einer statischen Klassenorganisation umfasst diese Operation das √úberpr√ºfen der Entit√§t auf Mitgliedschaft in einer bestimmten Klasse, die das erforderliche Verhalten implementiert.  In der Prototypenorganisation gibt es das Konzept der <i>Ententypisierung</i> .  Im Fall der Ententypisierung bedeutet das √úberpr√ºfen der Entit√§t auf die F√§higkeit, ein bestimmtes Verhalten zu implementieren, das direkte Testen der Entit√§t auf die F√§higkeit, dieses Verhalten zu einem bestimmten Zeitpunkt zu implementieren, d. H.  In verschiedenen Teilen des Programms kann das Ergebnis der √úberpr√ºfung diametral entgegengesetzt sein. <br><br>  Was sind die Vorteile eines Prototypansatzes? <br><br><ul><li>  Mehr Flexibilit√§t </li><li>  Entit√§ten haben keine Eigenschaften, die sie nicht ben√∂tigen. </li></ul><br>  Was sind die Nachteile? <br><br><ul><li>  Weniger klar </li><li>  Es ist nicht immer einfach zu verfolgen, was als Ausgangspunkt f√ºr das unerw√ºnschte Verhalten des Unternehmens diente, d. H.  Der Prototyp ist weniger vorhersehbar als die statische Klassenorganisation </li><li>  Die Softwareentwickler sind trotz der Popularit√§t und Verbreitung von JavaScript nicht ausreichend damit vertraut </li></ul><br><h3>  Fazit </h3><br>  Damit werden wir heute enden.  Ich hoffe, dass ich die Idee vermitteln konnte, dass der Unterschied zwischen klassischen Sprachen und JavaScript nicht mit dem Vorhandensein / Fehlen von Klassen und dem Vorhandensein / Fehlen von Prototypen zusammenh√§ngt, sondern mit der statischen / dynamischen Natur der Organisation. <br><br>  Nat√ºrlich wurde viel nicht ber√ºcksichtigt.  Ich m√∂chte keine Artikel schreiben, die zu lang sind, daher werden die Funktionen des Cascade-Modells in der Prototyp-Organisation und in den OOP-Tools (Polymorphismus, Kapselung, Abstraktion usw.) in den folgenden Artikeln erl√§utert. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468157/">https://habr.com/ru/post/de468157/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468143/index.html">466 Terabit: Der weltweite Internetverkehr w√§chst weiter. K√∂nnen Satelliten mit U-Boot-Kabeln konkurrieren?</a></li>
<li><a href="../de468145/index.html">Tests oder Typen? - Rostversion</a></li>
<li><a href="../de468147/index.html">Einladung zur Lichtshow ‚ÄûCircle of Light‚Äú 2019 in Moskau und ein kleiner Insider von einem der Standorte</a></li>
<li><a href="../de468151/index.html">Schwachstellen in GeekBrains: Warum Geld f√ºr Kurse bezahlen, wenn Sie diese nur herunterladen k√∂nnen?</a></li>
<li><a href="../de468155/index.html">Neue Produkttrends</a></li>
<li><a href="../de468161/index.html">Die gierige Leuchte: Warum Sonnenenergie die Welt nicht eroberte und wie das ‚Äûrussische Mineral‚Äú sie retten kann</a></li>
<li><a href="../de468163/index.html">Oracle VM Server f√ºr SPARC for Dummies (Anleitung)</a></li>
<li><a href="../de468165/index.html">Wie der Browser zeichnet. Yandex-Bericht</a></li>
<li><a href="../de468167/index.html">Lebe und lerne. Teil 4. W√§hrend der Arbeit lernen?</a></li>
<li><a href="../de468169/index.html">JQuery Geschichte und Erbe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>