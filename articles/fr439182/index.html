<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😭 👨🏼‍🏫 🍅 Comment nous distribuons les commandes entre les chauffeurs dans Yandex.Taxi ✋🏼 🗄️ 👩🏻‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'une des principales tâches de Yandex.Taxi est de s'assurer qu'une voiture arrive rapidement à l'utilisateur, et le temps du conducteur pour la «marc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment nous distribuons les commandes entre les chauffeurs dans Yandex.Taxi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/439182/"><img src="https://habrastorage.org/webt/5h/l9/th/5hl9thxhtitxpaufvidq23vkycy.png" alt="image"><br><br>  L'une des principales tâches de Yandex.Taxi est de s'assurer qu'une voiture arrive rapidement à l'utilisateur, et le temps du conducteur pour la «marche au ralenti» est réduit (c'est-à-dire le temps où il est sur la ligne sans passager).  Il semblerait que tout soit simple: l'utilisateur sélectionne le tarif, indique des souhaits supplémentaires (siège enfant par exemple).  Reste à filtrer les pilotes sur la ligne selon ces critères, sélectionner le plus proche et lui proposer une commande.  Cependant, tout n'est si simple qu'à première vue. <br><br>  Aujourd'hui, je vais dire à la communauté Habr comment nous choisissons le pilote le plus approprié et comment ce processus a évolué au fil du temps.  Vous découvrirez deux approches pour résoudre le problème. <br><a name="habracut"></a><br><h3>  Architecture de recherche générale </h3><br>  Lorsque l'utilisateur clique sur le bouton «Appeler un taxi», un objet de commande est créé dans le backend et son traitement commence conformément à la machine d'état.  Pour que la commande passe de l'état «En attente» à «Le conducteur est affecté», vous devez trouver le conducteur, lui proposer une commande et attendre la confirmation que la commande a été acceptée. <br><br><img src="https://habrastorage.org/webt/fn/bq/bp/fnbqbplbhy626m7u_kxujya0zho.png" alt="image"><br><br><h3>  Approche gourmande </h3><br>  Pendant très longtemps, une approche <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">gourmande a</a> fonctionné chez Yandex.Taxi.  Avec cette approche, au stade de la recherche de l'entrepreneur, une demande est faite au microservice Tracker, qui est responsable des chauffeurs.  Tracker sait tout sur les voitures: de la couleur et de la marque à son <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">emplacement actuel</a> .  Tracker dispose d'un géo-index local pour les pilotes et les connecteurs aux services de routage (routeurs) pour la création d'itinéraires du point A au point B (et même via les points B, D, D).  Par conséquent, lorsqu'une demande est faite pour rechercher un conducteur, Tracker détermine d'abord les voitures les plus proches dans le géo-index local le long du rayon direct, en tenant compte des restrictions de commande «dures» (classe de voiture, exigences - siège enfant, numéros jaunes).  Ensuite, le temps et la longueur de l'itinéraire d'approvisionnement du véhicule sont spécifiés et, en tenant compte de ces informations, la meilleure option est sélectionnée. <br><br>  Plus tard, cette logique a évolué: pour chaque pilote, ils ont commencé à compter sur son «scoring» sur commande - fonction de l'heure de livraison de la voiture.  Et les pilotes étaient déjà classés en fonction de leur valeur.  La fonction prend en compte non seulement le délai de livraison lui-même, mais aussi de nombreux autres facteurs: du niveau de la demande aux points A et B à «l'expérience» du conducteur.  Ce rendez-vous gourmand s'appelle un bonus. <br><br><h3>  Approche tampon (faisceau) </h3><br>  Cependant, avec une approche gourmande, le chauffeur le plus proche recevra celui qui a d'abord commandé un taxi.  Cependant, certains utilisateurs peuvent même se retrouver sans voiture. <br><br><img src="https://habrastorage.org/webt/k-/gr/df/k-grdfddnk6lgvkpxylphlkcv2e.png" alt="image"><br><br><img src="https://habrastorage.org/webt/6b/9x/iz/6b9xizmxnoqytx90py50-8utc00.png" alt="image"><br><br>  Avec une demande accrue, lorsque la compétition pour les artistes commence, l'approche gourmande n'est pas bonne.  Afin de satisfaire au maximum la demande même aux heures les plus chargées, nous utilisons de nombreuses approches et algorithmes.  L'un d'eux est la désignation tampon (faisceau) des conducteurs sur les commandes.  Il est basé sur la tâche bien connue du domaine de l'optimisation combinatoire - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le problème d'affectation</a> .  Bref, son essence: ayons N oeuvres et M interprètes, tout employé peut accomplir n'importe quelle tâche pendant le temps p (i, j) [0 &lt;= i &lt;N, 0 &lt;= j &lt;M].  Il est nécessaire d'affecter un tel entrepreneur à chaque tâche afin de réduire le temps d'exécution total de tous les travaux (dans ce cas, un entrepreneur ne peut occuper qu'un seul emploi). <br><br><img src="https://habrastorage.org/webt/fc/-k/sh/fc-kshacpkn4hy0nuwqeo1mmzik.png" alt="image"><img src="https://habrastorage.org/webt/fp/en/ot/fpenotm7jopgnz5ndaj3fal_jie.png" alt="image"><br><br>  Lors de la résolution d'un tel problème d'affectation, notre «coût» d'exécution du travail (commande) par l'exécuteur testamentaire (parc de taxis et chauffeur) est la valeur de la fonction de notation à partir du moment où la voiture a été livrée à l'utilisateur.  La tâche peut être décrite en termes de graphes bipartites: d'une part, les ordres, d'autre part, les interprètes.  Entre les commandes et les interprètes, il y a des bords pondérés (notation).  Ainsi, l'un de nos objectifs est de minimiser le délai total de livraison du véhicule en maximisant le nombre de commandes terminées (correspondance maximale).  L'un des moyens les plus connus pour résoudre un tel problème est l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">algorithme hongrois</a> . <br><div class="scrollable-table"><table><tbody><tr><td><img src="https://habrastorage.org/webt/vd/en/lr/vdenlrgpxfigisllopvwogmqk0k.png" alt="image"></td><td><img src="https://habrastorage.org/webt/jd/5q/sy/jd5qsysg54yoo-n99eipmfuky1m.png" alt="image"></td></tr></tbody></table></div><br>  Evidemment, avec un rendez-vous tampon, on ne peut pas donner de chauffeur sur demande, comme avec une approche gourmande.  Vous devez d'abord mettre la commande dans la file d'attente, puis jouer, puis informer sur le pilote trouvé.  Cela ne correspondait pas du tout à la machine d'état du traitement des commandes, et il fallait l'améliorer un peu.  Afin de tester et de créer une nouvelle solution sans affecter nos collègues, nous avons immédiatement convenu que nous ferions tout dans un microservice DriverDispatcher distinct.  Il prendra les commandes, fera la queue, trouvera les pilotes et enregistrera les résultats des rallyes. <br><br>  Tout d'abord, nous avons dû préparer le Tracker pour un nouveau profil de charge.  Si avec une approche gourmande, les demandes de pilotes tombaient simplement individuellement sur l'équilibreur de suivi et étaient redirigées vers ses instances avec équilibrage de charge, alors dans la destination du tampon toutes les demandes provenaient d'une seule machine: les demandes individuelles obstrueraient simplement le pool de connexions.  Par conséquent, nous avons ajouté au tracker la possibilité de traiter des lots de demandes qui ont été traitées simultanément dans le tracker.  En cours de route, nous avons également dû résoudre le problème d'un nombre raisonnable de demandes de traitement par lots.  Du côté du client (DriverDispatcher), nous avons divisé le gros lot en plusieurs petits et l'avons envoyé à différentes instances de Tracker. <br><br><img src="https://habrastorage.org/webt/gf/kw/xb/gfkwxba9mefbr-advegu6vg4uv4.png" alt="image"><br><br>  Ainsi, le tracker est préparé, le scoring est considéré à la fois dans Tracker (rendez-vous gourmand) et dans le nouveau service (DriverDispatcher'e), l'algorithme de résolution du problème d'affectation est débogué et fonctionne correctement.  La question s'est posée de savoir comment intégrer tout cela dans la machine d'état du traitement des commandes.  Nous avons ajouté l'envoi et la suppression des méta-informations de commande dans DriverDispatcher lorsque la commande est transférée d'un état à l'autre.  Et cela a presque fonctionné.  Presque - parce que les itérations de recherche d'un entrepreneur à commander n'étaient pas contrôlées en externe.  Nous pourrions simplement remplacer le voyage vers le tracker par le chauffeur par un voyage à notre service et donner au chauffeur quand il est trouvé, et avant cela juste donner 404. Mais c'est mauvais, car vous devez offrir une commande au chauffeur dès que nous trouvons une commande, et même plusieurs les secondes de retard jouent ici un rôle: le conducteur peut simplement tourner dans la mauvaise direction, et la commande ne sera plus pertinente.  Pour ce faire, nous avons permis d'appeler le processus de recherche d'un artiste sans affecter les tâches prévues.  Nous avons donc enregistré la logique de recherche (avec de nouvelles demandes) et ajouté la possibilité de l'appeler en dehors du planificateur. <br><br>  Ainsi, nous avons pu combiner la machine à états principale pour le traitement des commandes avec la machine à états dans la répartition du tampon sans affecter la logique de travail et sans courir entre les états.  Vous pouvez exécuter les premières expériences sur des utilisateurs en direct. <br><br>  Tout cela est très cool, mais qu'en est-il du temps pour rechercher un artiste, demandez-vous.  Si la recherche n'a pas lieu immédiatement après la réception de la commande, alors le temps de recherche augmente et est par conséquent compensé par un flux plus rapide?  Ce n'est pas tout à fait vrai: à l'aide de diverses techniques (dont l'utilisation du machine learning), nous avons pu isoler des cas où l'attente a du sens, dans d'autres cas le temps d'attente ne change pas. <br><br><h3>  Tirage au sort </h3><br>  Une autre façon de trouver un artiste plus rapidement est de commencer à le rechercher AVANT de créer une commande.  Lorsqu'une nouvelle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">épingle</a> apparaît (c'est-à-dire que l'utilisateur saisit uniquement les données de commande dans l'application), les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">algorithmes d'</a> apprentissage automatique évaluent la probabilité qu'une commande suive et décident de la prendre en compte lors de la mise en mémoire tampon des pilotes.  Nous pouvons trouver la voiture à l'avance et, lorsque l'utilisateur clique sur le bouton de commande, faire immédiatement une offre à un conducteur approprié. <br><br><h3>  Conclusion </h3><br>  Faire correspondre les commandes et les chauffeurs n'est pas une tâche facile; cela nécessite de prendre en compte de nombreux facteurs.  L'un d'eux est le contexte des mouvements de conducteurs lors du choix des candidats à l'ordre.  Nous en parlerons dans les articles suivants. <br><br><h3>  Autres postes de technologie de taxi </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tarification dynamique ou comment Yandex.Taxi prédit une forte demande</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment utiliser une vision par ordinateur pour évaluer l'état de la voiture.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Découvrez Yandex.Taxi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment Yandex.Taxi prédit le temps de livraison des voitures à l'aide de l'apprentissage automatique</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr439182/">https://habr.com/ru/post/fr439182/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr439170/index.html">Les opérateurs cellulaires aideront les banques à vérifier l'exactitude des données clients</a></li>
<li><a href="../fr439172/index.html">Extension de macro Assert () pour implémenter une gestion minimale des erreurs</a></li>
<li><a href="../fr439174/index.html">Safe Internet Day: quelles menaces rechercher en 2019</a></li>
<li><a href="../fr439176/index.html">Envoyer un e-mail avec des pièces jointes par JavaMailSender de SpringFramework</a></li>
<li><a href="../fr439180/index.html">Défi Rekko</a></li>
<li><a href="../fr439184/index.html">Modifier votre mot de passe: tester les stratégies de mot de passe du service Web</a></li>
<li><a href="../fr439186/index.html">Editeur UX: histoire vraie, vie rial</a></li>
<li><a href="../fr439190/index.html">Comment créer une application de réalité augmentée à l'aide d'ARCore</a></li>
<li><a href="../fr439192/index.html">Haut-parleur PC à onze</a></li>
<li><a href="../fr439194/index.html">Gestion des personnages avec SharedEvents</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>