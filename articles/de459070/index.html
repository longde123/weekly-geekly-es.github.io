<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äç‚öñÔ∏è üåö üë©üèº‚Äçüîß Turmverteidigung in Einheit schaffen: T√ºrme und schie√üende Feinde üí™üèº üôÇ üßó</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[ Der erste und zweite Teil des Tutorials] 



- Wir platzieren auf dem Feld des Turms. 
- Wir zielen mit Hilfe der Physik auf Feinde. 
- Wir verfolge...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Turmverteidigung in Einheit schaffen: T√ºrme und schie√üende Feinde</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459070/">  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der erste</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zweite</a> Teil des Tutorials] <br><br><ul><li>  Wir platzieren auf dem Feld des Turms. </li><li>  Wir zielen mit Hilfe der Physik auf Feinde. </li><li>  Wir verfolgen sie, solange es m√∂glich ist. </li><li>  Wir schie√üen sie mit einem Laserstrahl. </li></ul><br>  Dies ist der dritte Teil einer Reihe von Tutorials zur Erstellung eines einfachen Tower Defense-Genres.  Es beschreibt die Schaffung von T√ºrmen, die auf Feinde zielen und auf diese schie√üen. <br><br>  Das Tutorial wurde in Unity 2018.3.0f2 erstellt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/470/ceb/183/470ceb1832b49ee7372fb79b8425b567.jpg" width="512" height="256"></div><br>  <i>Erhitzen wir die Feinde.</i> <br><br><h2>  Turmsch√∂pfung </h2><br>  Mauern verlangsamen nur Feinde und verl√§ngern den Weg, den sie gehen m√ºssen.  Das Ziel des Spiels ist es jedoch, die Feinde zu zerst√∂ren, bevor sie den Endpunkt erreichen.  Dieses Problem wird gel√∂st, indem T√ºrme auf dem Feld platziert werden, die auf sie schie√üen. <br><a name="habracut"></a><br><h3>  Kachelinhalt </h3><br>  T√ºrme sind eine andere Art von <code>GameTileContent</code> . <code>GameTileContent</code> Sie daher einen Eintrag f√ºr sie in <code>GameTileContent</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> GameTileContentType { Empty, Destination, Wall, SpawnPoint, Tower‚Ç¨ }</code> </pre> <br>  In diesem Tutorial werden wir nur einen Turmtyp unterst√ºtzen, der implementiert werden kann, indem <code>GameTileContentFactory</code> einem Link zum Tower-Fertighaus versehen wird, von dem eine Instanz auch √ºber <code>Get</code> erstellt werden kann. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTileContent towerPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTileContent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContentType type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Tower‚Ç¨: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(towerPrefab); } ‚Ä¶ }</code> </pre> <br>  Aber die T√ºrme m√ºssen schie√üen, daher muss ihr Zustand aktualisiert werden und sie ben√∂tigen ihren eigenen Code.  Erstellen Sie zu diesem Zweck eine <code>Tower</code> Klasse, die die <code>GameTileContent</code> Klasse erweitert. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Tower</span></span> : <span class="hljs-title"><span class="hljs-title">GameTileContent</span></span> {}</code> </pre> <br>  Sie k√∂nnen dem Tower-Fertighaus eine eigene Komponente hinzuf√ºgen, indem Sie den Feldtyp der Fabrik in <code>Tower</code> √§ndern.  Da die Klasse immer noch als <code>GameTileContent</code> , muss nichts anderes ge√§ndert werden. <br><br><pre> <code class="cs hljs"> Tower towerPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><h3>  Fertighaus </h3><br>  Erstellen Sie ein Fertighaus f√ºr den Turm.  Sie k√∂nnen beginnen, indem Sie das Wandfertigteil duplizieren und die <code>GameTileContent</code> Komponente durch die <code>Tower</code> Komponente ersetzen und dann ihren Typ in <em>Tower</em> √§ndern.  Speichern Sie den Wandw√ºrfel als Basis des Turms, damit der Turm an die W√§nde passt.  Dann legen Sie einen weiteren W√ºrfel darauf.  Ich gab ihm eine Skala von 0,5.  Lege einen weiteren W√ºrfel darauf, der auf einen Turm hinweist. Dieser Teil zielt und schie√üt auf Feinde. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/392/e5d/633/392e5d63397672627c3b5ec018df0444.png" width="190" height="260"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d92/dec/c33/d92decc33036a1e973a7f20a3df2c00e.png" width="320" height="120"></div><br>  <i>Drei W√ºrfel bilden einen Turm.</i> <br><br>  Der Turm dreht sich und da er einen Kollider hat, wird er von einem physischen Motor verfolgt.  Wir m√ºssen jedoch nicht so pr√§zise sein, da wir Turmkollider nur zur Auswahl von Zellen verwenden.  Dies kann ungef√§hr erfolgen.  Entfernen Sie den Revolverw√ºrfelkollider und √§ndern Sie den Turmw√ºrfelkollider so, dass er beide W√ºrfel bedeckt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e01/11e/3b7/e0111e3b7221bbbe4e5b0d23373e4b3a.png" width="190" height="260"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1f/857/09b/a1f85709bd504d176a18930240edea5a.png" width="320" height="152"></div><br>  <i>Collider W√ºrfelturm.</i> <br><br>  Der Turm schie√üt einen Laserstrahl.  Es kann auf viele Arten visualisiert werden, aber wir verwenden nur einen durchscheinenden W√ºrfel, den wir dehnen, um einen Strahl zu bilden.  Jeder Turm muss einen eigenen Balken haben, also f√ºgen Sie ihn dem vorgefertigten Turm hinzu.  Platzieren Sie es so im Turm, dass es standardm√§√üig ausgeblendet ist, und geben Sie ihm einen kleineren Ma√üstab, z. B. 0,2.  Machen wir es zu einem Kind der vorgefertigten Wurzel, nicht des Turmw√ºrfels. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19a/1dc/29e/19a1dc29e70adb158e07f29653db2d66.png" width="190" height="260" alt="Laserstrahl"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45a/273/081/45a273081365aa9e483f1aa97cbe39c8.png" width="226" height="108" alt="Hierarchie"></div><br>  <i>Versteckter W√ºrfel eines Laserstrahls.</i> <br><br>  Erstellen Sie ein geeignetes Material f√ºr den Laserstrahl.  Ich habe gerade das durchscheinende schwarze Standardmaterial verwendet, alle Reflexionen ausgeschaltet und ihm eine rot emittierte Farbe gegeben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2fb/e49/860/2fbe498604cc4cc4ed6ee60a45eea63d.png" width="320" height="284" alt="Farbe"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0eb/b46/483/0ebb4648376a7fe68c96b7a16ce27db9.png" width="320" height="56" alt="keine reflexionen"></div><br>  <i>Das Material des Laserstrahls.</i> <br><br>  Stellen Sie sicher, dass der Laserstrahl keinen Kollider hat, und schalten Sie auch den Wurf und den Schatten aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecf/f21/0ad/ecff210ad75ef4b12cb0a74102365492.png" width="320" height="162"></div><br>  <i>Der Laserstrahl interagiert nicht mit Schatten.</i> <br><br>  Nachdem die Erstellung des Turmfertigteils abgeschlossen ist, werden wir es der Fabrik hinzuf√ºgen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/626/37c/935/62637c9353cf1e20e170e82bbefcdb11.png" width="320" height="114"></div><br>  <i>Fabrik mit einem Turm.</i> <br><br><h3>  Turmplatzierung </h3><br>  Wir werden T√ºrme mit einer anderen Schaltmethode hinzuf√ºgen und entfernen.  Sie k√∂nnen <code>GameBoard.ToggleWall</code> einfach duplizieren, indem Sie den Methodennamen und den Inhaltstyp √§ndern. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleTower</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Tower‚Ç¨) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.Tower‚Ç¨); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!FindPaths()) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } } }</code> </pre> <br>  <code>Game.HandleTouch</code> in <code>Game.HandleTouch</code> die Umschalttaste gedr√ºckt halten, werden eher T√ºrme als W√§nde <code>Game.HandleTouch</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = board.GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { board.ToggleTower(tile); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { board.ToggleWall(tile); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/926/804/2ac/9268042acc19a28d6ff1a6d74d83144f.png" width="230" height="230"></div><br>  <i>T√ºrme auf dem Feld.</i> <br><br><h3>  Pfadblockierung </h3><br>  Bisher k√∂nnen nur Mauern die Suche nach einem Pfad blockieren, sodass sich Feinde durch T√ºrme bewegen.  <code>GameTileContent</code> wir <code>GameTileContent</code> Eigenschaft <code>GameTileContent</code> , die angibt, ob der Inhalt den Pfad blockiert.  Der Weg ist blockiert, wenn es sich um eine Mauer oder einen Turm handelt. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> BlocksPath =&gt; Type == GameTileContentType.Wall || Type == GameTileContentType.Tower‚Ç¨;</code> </pre> <br>  Verwenden Sie diese Eigenschaft in <code>GameTile.GrowPathTo</code> anstatt den Inhaltstyp zu √ºberpr√ºfen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor, Direction direction</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-comment"><span class="hljs-comment">//neighbor.Content.Type != GameTileContentType.Wall ? neighbor : null; neighbor.Content.BlocksPath ? null : neighbor; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fa/93f/eed/6fa93feedb4925ee12decb4233612a4c.png" width="230" height="230"></div><br>  <i>Jetzt ist der Weg durch Mauern und T√ºrme blockiert.</i> <br><br><h3>  Ersetzen Sie die W√§nde </h3><br>  H√∂chstwahrscheinlich wird der Spieler die W√§nde oft durch T√ºrme ersetzen.  Es wird f√ºr ihn unpraktisch sein, zuerst die Mauer zu entfernen, und au√üerdem k√∂nnen Feinde in diese vor√ºbergehend erscheinende L√ºcke eindringen.  Sie k√∂nnen einen direkten Ersatz implementieren, indem Sie <code>GameBoard.ToggleTower</code> zwingen, zu √ºberpr√ºfen, ob sich die Wand derzeit auf der Kachel befindet.  Wenn ja, ersetzen Sie es sofort durch einen Turm.  In diesem Fall m√ºssen wir nicht nach anderen Wegen suchen, da die Kachel sie immer noch blockiert. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleTower</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Tower) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Wall) { tile.Content = contentFactory.Get(GameTileContentType.Tower); } }</code> </pre> <br><h2>  Wir zielen auf Feinde </h2><br>  Ein Turm kann seine Aufgabe nur erf√ºllen, wenn er einen Feind findet.  Nachdem sie den Feind gefunden hat, muss sie entscheiden, auf welchen Teil sie zielen soll. <br><br><h3>  Zielpunkt </h3><br>  Um Ziele zu erkennen, verwenden wir die Physik-Engine.  Wie beim Tower Collider muss der feindliche Collider nicht unbedingt mit seiner Form √ºbereinstimmen.  Sie k√∂nnen den einfachsten Collider ausw√§hlen, dh eine Kugel.  Nachdem wir den Feind entdeckt haben, verwenden wir die Position des Spielobjekts mit dem daran befestigten Collider als Zielpunkt. <br><br>  Wir k√∂nnen den Collider nicht am Wurzelobjekt des Feindes befestigen, da er nicht immer mit der Position des Modells √ºbereinstimmt und den Turm auf den Boden zielen l√§sst.  Das hei√üt, Sie m√ºssen den Collider irgendwo auf dem Modell platzieren.  Die Physik-Engine gibt uns einen Link zu diesem Objekt, den wir zum Zielen verwenden k√∂nnen, aber wir ben√∂tigen weiterhin Zugriff auf die <code>Enemy</code> Komponente des Stammobjekts.  Um die Aufgabe zu vereinfachen, erstellen <code>TargetPoint</code> die <code>TargetPoint</code> Komponente.  Geben wir ihm eine Eigenschaft f√ºr den privaten Auftrag und den √∂ffentlichen Empfang der <code>Enemy</code> Komponente und eine weitere Eigenschaft f√ºr die Erlangung seiner Position in der Welt. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TargetPoint</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Enemy Enemy‚Ç¨ { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 Position =&gt; transform.position; }</code> </pre> <br>  Geben wir ihm eine <code>Awake</code> Methode, die einen Link zu seiner <code>Enemy</code> Komponente herstellt.  Gehen Sie mit <code>transform.root</code> direkt zum <code>transform.root</code> .  Wenn die <code>Enemy</code> Komponente nicht vorhanden ist, haben wir beim Erstellen des Feindes einen Fehler gemacht. F√ºgen wir also eine Erkl√§rung dazu hinzu. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Enemy‚Ç¨ = transform.root.GetComponent&lt;Enemy&gt;(); Debug.Assert(Enemy‚Ç¨ != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Target point without Enemy root!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  Au√üerdem muss der Collider an dasselbe Spielobjekt angeh√§ngt werden, an das <code>TargetPoint</code> angeh√§ngt ist. <br><br><pre> <code class="cs hljs"> Debug.Assert(Enemy‚Ç¨ != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Target point without Enemy root!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); Debug.Assert( GetComponent&lt;SphereCollider&gt;() != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Target point without sphere collider!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> );</code> </pre> <br>  F√ºgen Sie dem vorgefertigten W√ºrfel des Feindes eine Komponente und einen Collider hinzu.  Dadurch zielen die T√ºrme auf die Mitte des W√ºrfels.  Wir verwenden einen Kugelcollider mit einem Radius von 0,25.  Der W√ºrfel hat eine Skala von 0,5, sodass der wahre Radius des Kolliders 0,125 betr√§gt.  Dank dessen muss der Feind den Entfernungskreis des Turms visuell √ºberqueren, und erst nach einiger Zeit wird das eigentliche Ziel erreicht.  Die Gr√∂√üe des Kolliders wird auch von der zuf√§lligen Skala des Feindes beeinflusst, sodass seine Gr√∂√üe im Spiel ebenfalls geringf√ºgig variiert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/85e/5ca/5e4/85e5ca5e47b8d59fa4211c78126bd512.png" width="176" height="176"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ae/a71/aec/7aea71aecbd64d4e045df141ecd1c711.png" width="320" height="176" alt="Inspektor"></div><br>  <i>Ein Feind mit einem Zielpunkt und einem Kollider auf einem W√ºrfel.</i> <br><br><h3>  Feindliche Schicht </h3><br>  T√ºrme k√ºmmern sich nur um Feinde, und sie zielen nicht auf etwas anderes, also werden wir alle Feinde in eine separate Schicht legen.  Wir werden Ebene 9 verwenden. √Ñndern Sie ihren Namen im Fenster " <em>Ebenen und Tags"</em> in " <em>Feind".</em> <em>Dies</em> kann √ºber die Option " <em>Ebenen bearbeiten</em> " im Dropdown-Men√º " <em>Ebenen"</em> in der oberen rechten Ecke des Editors ge√∂ffnet werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e6/9a5/762/8e69a5762e8eb1856175f9d9dc1ab388.png" width="320" height="308"></div><br>  <i>Schicht 9 wird f√ºr Feinde verwendet.</i> <br><br>  Diese Schicht wird nur zur Erkennung von Feinden und nicht f√ºr physische Interaktionen ben√∂tigt.  Lassen Sie uns darauf hinweisen, indem Sie sie in der <em>Layer Collision Matrix</em> deaktivieren, die sich im Bereich <em>Physik</em> der Projektparameter befindet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/876/06e/e7d/87606ee7dfc4777760d81219517125ce.png" width="200" height="200"></div><br>  <i>Matrix von Schichtkollisionen.</i> <br><br>  Stellen Sie sicher, dass sich das Spielobjekt des Zielpunkts auf der gew√ºnschten Ebene befindet.  Der Rest des Fertighauses des Feindes befindet sich m√∂glicherweise auf anderen Ebenen, aber es ist einfacher, alles zu koordinieren und das gesamte Fertighaus in der <em>feindlichen</em> Ebene zu platzieren.  Wenn Sie die Ebene des Stammobjekts √§ndern, werden Sie aufgefordert, die Ebene f√ºr alle untergeordneten Objekte zu √§ndern. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d1/f75/062/6d1f75062420abadb285e9efca1e1a5e.png" width="320" height="44"></div><br>  <i>Feind auf der rechten Ebene.</i> <br><br>  <code>TargetPoint</code> wir die Aussage hinzu, dass <code>TargetPoint</code> wirklich auf der richtigen Ebene liegt. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ Debug.Assert(gameObject.layer == <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-string"><span class="hljs-string">"Target point on wrong layer!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  Au√üerdem m√ºssen die Aktionen des Spielers von feindlichen Kollidern ignoriert werden.  Dies kann erreicht werden, indem <code>Physics.Raycast</code> in <code>GameBoard.GetTile</code> <code>Physics.Raycast</code> <code>GameBoard.GetTile</code> .  Diese Methode hat eine Form, die den Abstand zum Strahl und zur Ebenenmaske als zus√§tzliche Argumente verwendet.  Wir geben ihm standardm√§√üig den maximalen Abstand und die maximale Ebenenmaske, d. H. 1. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTile</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ray ray</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> RaycastHit hit, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>.MaxValue, <span class="hljs-number"><span class="hljs-number">1</span></span>)) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Sollte die Ebenenmaske nicht 0 sein?</b> <div class="spoiler_text">  Der Standard-Ebenenindex ist Null, aber wir √ºbergeben die Ebenenmaske.  Die Maske √§ndert die einzelnen Bits einer Ganzzahl in 1, wenn die Ebene aktiviert werden muss.  In diesem Fall m√ºssen Sie nur das erste Bit setzen, dh das niedrigstwertige, dh 2 <sup>0</sup> , was 1 entspricht. </div></div><br><h3>  Aktualisieren des Kachelinhalts </h3><br>  T√ºrme k√∂nnen ihre Aufgabe nur ausf√ºhren, wenn ihr Status aktualisiert wird.  Gleiches gilt f√ºr den Inhalt der gesamten Kacheln, obwohl der Rest des Inhalts bisher nichts bewirkt.  <code>GameTileContent</code> daher <code>GameTileContent</code> virtuelle <code>GameTileContent</code> Methode <code>GameUpdate</code> , die standardm√§√üig nichts bewirkt. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {}</code> </pre> <br>  Lassen Sie <code>Tower</code> neu definieren, auch wenn es vorerst einfach in der Konsole anzeigt, dass es nach einem Ziel sucht. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Searching for target..."</span></span>); }</code> </pre> <br>  <code>GameBoard</code> befasst sich mit Kacheln und deren Inhalten, sodass auch <code>GameBoard</code> werden kann, welche Inhalte aktualisiert werden m√ºssen.  <code>GameUpdate</code> Sie dazu die Liste und die √∂ffentliche <code>GameUpdate</code> Methode hinzu, mit der alle <code>GameUpdate</code> in der Liste aktualisiert werden. <br><br><pre> <code class="cs hljs"> List&lt;GameTileContent&gt; updatingContent = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;GameTileContent&gt;(); ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; updatingContent.Count; i++) { updatingContent[i].GameUpdate(); } }</code> </pre> <br>  In unserem Tutorial m√ºssen Sie nur die T√ºrme aktualisieren.  √Ñndern Sie <code>ToggleTower</code> so, dass bei Bedarf Inhalte <code>ToggleTower</code> und entfernt werden.  Wenn auch andere Inhalte ben√∂tigt werden, brauchen wir einen allgemeineren Ansatz, aber im Moment reicht dies aus. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleTower</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Tower) { updatingContent.Remove(tile.Content); tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.Tower); <span class="hljs-comment"><span class="hljs-comment">//if (!FindPaths()) { if (FindPaths()) { updatingContent.Add(tile.Content); } else { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } } else if (tile.Content.Type == GameTileContentType.Wall) { tile.Content = contentFactory.Get(GameTileContentType.Tower); updatingContent.Add(tile.Content); } }</span></span></code> </pre> <br>  Damit dies funktioniert, reicht es jetzt aus, das Feld in <code>Game.Update</code> einfach zu aktualisieren.  Wir werden das Feld nach den Feinden aktualisieren.  Dank dessen k√∂nnen die T√ºrme genau zielen, wo sich die Feinde befinden.  Wenn wir es anders machen w√ºrden, w√ºrden die T√ºrme zielen, wo sich die Feinde im letzten Frame befanden. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ enemies.GameUpdate(); board.GameUpdate(); }</code> </pre> <br><h3>  Zielbereich </h3><br>  T√ºrme haben einen begrenzten Zielradius.  Machen wir es uns benutzerdefiniert, indem wir der <code>Tower</code> Klasse ein Feld hinzuf√ºgen.  Der Abstand wird von der Mitte des Turmpl√§ttchens gemessen, sodass in einem Bereich von 0,5 nur das eigene Pl√§ttchen abgedeckt wird.  Daher w√§re ein angemessener Mindest- und Standardbereich 1,5, der die meisten benachbarten Fliesen abdeckt. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(1.5f, 10.5f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> targetingRange = <span class="hljs-number"><span class="hljs-number">1.5f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c38/ae4/ee8/c38ae4ee885cf5d89f24164b9c6bc5fe.png" width="320" height="74"></div><br>  <i>Zielbereich 2.5.</i> <br><br>  Lassen Sie uns die Reichweite mit Gizmo visualisieren.  Wir m√ºssen es nicht st√§ndig sehen, daher erstellen wir die <code>OnDrawGizmosSelected</code> Methode, die nur f√ºr die ausgew√§hlten Objekte aufgerufen wird.  Wir zeichnen den gelben Rahmen der Kugel mit einem Radius, der dem Abstand entspricht und relativ zum Turm zentriert ist.  Stellen Sie es leicht √ºber den Boden, damit es immer gut sichtbar ist. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmosSelected</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Gizmos.color = Color.yellow; Vector3 position = transform.localPosition; position.y += <span class="hljs-number"><span class="hljs-number">0.01f</span></span>; Gizmos.DrawWireSphere(position, targetingRange); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/674/6b7/3cd/6746b73cd2e015fd599b770bb89e1c8a.png" width="230" height="230"></div><br>  <i>Gizmo Zielstrecke.</i> <br><br>  Jetzt k√∂nnen wir sehen, welcher der Feinde ein erschwingliches Ziel f√ºr jeden der T√ºrme ist.  Die Auswahl von T√ºrmen im Szenenfenster ist jedoch unpraktisch, da wir einen der untergeordneten W√ºrfel ausw√§hlen und dann zum Stammobjekt des Turms wechseln m√ºssen.  Andere Arten von Flieseninhalten leiden ebenfalls unter dem gleichen Problem.  Wir k√∂nnen die Auswahl des <code>GameTileContent</code> des <code>GameTileContent</code> im <code>GameTileContent</code> indem <code>GameTileContent</code> dem <code>GameTileContent</code> das <code>SelectionBase</code> Attribut <code>GameTileContent</code> . <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">SelectionBase</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameTileContent</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ }</code> </pre> <br><h3>  Zielerfassung </h3><br>  F√ºgen <code>TargetPoint</code> der <code>Tower</code> Klasse ein <code>TargetPoint</code> Feld hinzu, damit sie das erfasste Ziel verfolgen kann.  Anschlie√üend <code>GameUpdate</code> wir <code>GameUpdate</code> , um die neue <code>AquireTarget</code> Methode <code>AquireTarget</code> , die Informationen dar√ºber zur√ºckgibt, ob das Ziel gefunden wurde.  Bei der Erkennung wird eine Meldung in der Konsole angezeigt. <br><br><pre> <code class="cs hljs"> TargetPoint target; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (AcquireTarget()) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Acquired target!"</span></span>); } }</code> </pre> <br>  In <code>AcquireTarget</code> wir alle verf√ºgbaren Ziele, indem wir <code>Physics.OverlapSphere</code> mit einer <code>Physics.OverlapSphere</code> und einem Bereich als Argumente aufrufen.  Das Ergebnis ist ein <code>Collider</code> Array, das alle <code>Collider</code> enth√§lt, die mit der Kugel in Kontakt stehen.  Wenn die L√§nge des Arrays positiv ist, gibt es mindestens einen Zielpunkt, und wir w√§hlen einfach den ersten aus.  Nehmen Sie die <code>TargetPoint</code> Komponente, die immer vorhanden sein muss, weisen Sie sie dem Zielfeld zu und melden Sie den Erfolg.  Andernfalls l√∂schen wir das Ziel und melden den Fehler. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Collider[] targets = Physics.OverlapSphere( transform.localPosition, targetingRange ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (targets.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { target = targets[<span class="hljs-number"><span class="hljs-number">0</span></span>].GetComponent&lt;TargetPoint&gt;(); Debug.Assert(target != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Targeted non-enemy!"</span></span>, targets[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Wir erhalten garantiert die richtigen Zielpunkte, wenn wir Kollider nur auf der Ebene der Feinde ber√ºcksichtigen.  Dies ist Ebene 9, daher √ºbergeben wir die entsprechende Ebenenmaske. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> enemyLayerMask = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">9</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Collider[] targets = Physics.OverlapSphere( transform.localPosition, targetingRange, enemyLayerMask ); ‚Ä¶ }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Wie funktioniert diese Bitmaske?</b> <div class="spoiler_text">  Da die feindliche Schicht einen Index von 9 hat, sollte das zehnte Bit der Bitmaske den Wert 1 haben. Dies entspricht einer ganzen Zahl 2 <sup>9</sup> , dh 512. Ein solcher Bitmaskendatensatz ist jedoch nicht intuitiv.  Wir k√∂nnen auch ein bin√§res Literal schreiben, zum Beispiel <code>0b10_0000_0000</code> , aber dann m√ºssen wir Nullen z√§hlen.  In diesem Fall w√§re die bequemste Eingabe die Verwendung des Linksverschiebungsoperators <code>&lt;&lt;</code> , der die Bits nach links verschiebt.  das entspricht einer Zahl in der Potenz von zwei. </div></div><br>  Sie k√∂nnen das erfasste Ziel visualisieren, indem Sie eine Gizmo-Linie zwischen den Positionen des Turms und des Ziels zeichnen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmosSelected</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Gizmos.DrawLine(position, target.Position); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a5/e99/4be/7a5e994be6b7d848c2d4bfe7d627c708.png" width="230" height="230"></div><br>  <i>Visualisierung von Zielen.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Warum nicht Methoden wie OnTriggerEnter verwenden?</b> <div class="spoiler_text">  Der Vorteil der manuellen √úberpr√ºfung von Querschnittszielen besteht darin, dass wir dies nur bei Bedarf tun k√∂nnen.  Es gibt keinen Grund, nach Zielen zu suchen, wenn der Turm bereits eines hat.  Indem wir alle potenziellen Ziele gleichzeitig erreichen, m√ºssen wir nicht f√ºr jeden Turm eine Liste potenzieller Ziele verarbeiten, die sich st√§ndig √§ndert. </div></div><br><h3>  Zielsperre </h3><br>  Das zu erfassende Ziel h√§ngt von der Reihenfolge ab, in der sie von der physischen Engine dargestellt werden, dh es ist tats√§chlich willk√ºrlich.  Daher scheint sich das erfasste Ziel ohne Grund zu √§ndern.  Nachdem der Turm das Ziel erhalten hat, ist es f√ºr sie logischer, ihr Ziel zu folgen und nicht zu einem anderen zu wechseln.  F√ºgen Sie eine <code>TrackTarget</code> Methode hinzu, die eine solche Verfolgung implementiert und Informationen dar√ºber zur√ºckgibt, ob sie erfolgreich war.  Zun√§chst teilen wir Ihnen nur mit, ob das Ziel erfasst wurde. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Wir werden diese Methode in <code>GameUpdate</code> und nur wenn false zur√ºckgegeben wird, werden wir <code>AcquireTarget</code> .  Wenn die Methode true zur√ºckgibt, haben wir ein Ziel.  Dies kann erreicht werden, indem beide Methodenaufrufe beim <code>if</code> Operator einer <code>if</code> Pr√ºfung unterzogen werden. Wenn der erste Operand <code>true</code> zur√ºckgibt, wird der zweite nicht gepr√ºft und der Aufruf wird verpasst.  Der AND-Operator verh√§lt sich √§hnlich. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TrackTarget() || AcquireTarget()) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Locked on target!"</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ec/27c/0a2/8ec27c0a2201434cba3725621b68aaa1.png" width="230" height="230"></div><br>  <i>Ziele verfolgen.</i> <br><br>  Infolgedessen werden die T√ºrme am Ziel befestigt, bis es den Endpunkt erreicht und zerst√∂rt wird.  Wenn Sie wiederholt Feinde verwenden, m√ºssen Sie stattdessen die Richtigkeit des Links √ºberpr√ºfen, wie dies bei Links zu Zahlen der Fall ist, die in einer Reihe von Tutorials zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Objektverwaltung</a> verarbeitet wurden. <br><br>  Um Ziele nur dann zu verfolgen, wenn sie sich in Reichweite befinden, muss <code>TrackTarget</code> die Entfernung zwischen dem Turm und dem Ziel verfolgen.  Wenn der Bereichswert √ºberschritten wird, muss das Ziel zur√ºckgesetzt und false zur√ºckgegeben werden.  Sie k√∂nnen die <code>Vector3.Distance</code> Methode f√ºr diese Pr√ºfung verwenden. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } Vector3 a = transform.localPosition; Vector3 b = target.Position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Vector3.Distance(a, b) &gt; targetingRange) { target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Dieser Code ber√ºcksichtigt jedoch nicht den Radius des Colliders.  Infolgedessen kann der Turm das Ziel verlieren und es dann erneut erfassen, um es im n√§chsten Frame nicht mehr zu verfolgen, und so weiter.  Wir k√∂nnen dies vermeiden, indem wir dem Bereich einen Kolliderradius hinzuf√ºgen. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Vector3.Distance(a, b) &gt; targetingRange + <span class="hljs-number"><span class="hljs-number">0.125f</span></span>) { ‚Ä¶ }</code> </pre> <br>  Dies gibt uns die richtigen Ergebnisse, aber nur, wenn die Gr√∂√üe des Feindes nicht ge√§ndert wird.  Da wir jedem Feind eine zuf√§llige Skala geben, m√ºssen wir diese bei der √Ñnderung der Reichweite ber√ºcksichtigen.  Dazu m√ºssen wir uns die von <code>Enemy</code> vorgegebene Skala merken und sie mit der Getter-Eigenschaft √∂ffnen. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Scale { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathOffset</span></span></span><span class="hljs-function">)</span></span> { Scale = scale; ‚Ä¶ }</code> </pre> <br>  Jetzt k√∂nnen wir den korrekten Bereich in <code>Tower.TrackTarget</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Vector3.Distance(a, b) &gt; targetingRange + <span class="hljs-number"><span class="hljs-number">0.125f</span></span> * target.Enemy‚Ç¨.Scale) { ‚Ä¶ }</code> </pre> <br><h3>  Wir synchronisieren die Physik </h3><br>  Alles scheint gut zu funktionieren, aber T√ºrme, die auf die Mitte des Feldes zielen k√∂nnen, k√∂nnen Ziele erfassen, die au√üerhalb der Reichweite liegen sollten.  Sie k√∂nnen diese Ziele nicht verfolgen, daher sind sie nur f√ºr einen Frame darauf festgelegt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e91/0a1/836/e910a1836ef729d95ebee121a67c3f2c.png" width="230" height="230"></div><br>  <i>Falsches Zielen.</i> <br><br>  Dies geschieht, weil der Status der physischen Engine nicht perfekt mit dem Status des Spiels synchronisiert ist.  Instanzen aller Feinde entstehen am Ursprung der Welt, der mit dem Mittelpunkt des Feldes zusammenf√§llt.  Dann bewegen wir sie zum Punkt der Sch√∂pfung, aber die Physik-Engine wei√ü nicht sofort davon. <br><br>  Sie k√∂nnen die sofortige Synchronisierung aktivieren, die beim √Ñndern von Objekttransformationen auftritt, indem Sie <code>Physics.autoSyncTransforms</code> auf <code>true</code> .  Standardm√§√üig ist es jedoch deaktiviert, da es viel effizienter ist, alles miteinander und bei Bedarf zu synchronisieren.  In unserem Fall ist eine Synchronisierung nur erforderlich, wenn der Status der T√ºrme aktualisiert wird.  Wir k√∂nnen es ausf√ºhren, indem <code>Physics.SyncTransforms</code> zwischen Feind- und <code>Game.Update</code> in <code>Game.Update</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ enemies.GameUpdate(); Physics.SyncTransforms(); board.GameUpdate(); }</code> </pre> <br><h3>  Ignoriere die H√∂he </h3><br>  Tats√§chlich findet unser Gameplay in 2D statt.  √Ñndern wir daher den <code>Tower</code> so, dass beim Zielen und Verfolgen nur die X- und Z-Koordinaten ber√ºcksichtigt werden. Die physische Engine arbeitet im 3D-Raum, aber im Wesentlichen k√∂nnen wir <code>AcquireTarget</code> in 2D ausf√ºhren: <code>AcquireTarget</code> die Kugel so, dass sie alle Kollider unabh√§ngig davon abdeckt von ihrer vertikalen Position.  Dies kann durch Verwendung einer Kapsel anstelle einer Kugel erfolgen, deren zweiter Punkt mehrere Einheiten √ºber dem Boden liegt (z. B. drei). <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a = transform.localPosition; Vector3 b = a; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> += <span class="hljs-number"><span class="hljs-number">3f</span></span>; Collider[] targets = Physics.OverlapCapsule( a, b, targetingRange, enemyLayerMask ); ‚Ä¶ }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ist es nicht m√∂glich, eine physische 2D-Engine zu verwenden?</font></font></b> <div class="spoiler_text">   ,       XZ,   2D-    XY.     ,     ,    2D-   .     3D-. </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist auch notwendig zu √§ndern </font></font><code>TrackTarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nat√ºrlich k√∂nnen wir 2D-Vektoren verwenden und </font></font><code>Vector2.Distance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber lassen Sie uns die Berechnungen selbst durchf√ºhren und stattdessen die Quadrate der Entfernungen vergleichen, wird dies ausreichen. </font><font style="vertical-align: inherit;">Wir m√ºssen also nicht mehr die Quadratwurzel berechnen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } Vector3 a = transform.localPosition; Vector3 b = target.Position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = ax - bx; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> z = az - bz; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> r = targetingRange + <span class="hljs-number"><span class="hljs-number">0.125f</span></span> * target.Enemy‚Ç¨.Scale; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x * x + z * z &gt; r * r) { target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie funktionieren diese mathematischen Berechnungen?</font></font></b> <div class="spoiler_text">     2D-   ,     .     ,       .  ,        ,    . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Speicherzuordnung vermeiden </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Nachteil der Verwendung </font></font><code>Physics.OverlapCapsule</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">besteht darin, dass f√ºr jeden Aufruf ein neues Array zugewiesen wird. </font><font style="vertical-align: inherit;">Dies kann vermieden werden, indem das Array einmal zugewiesen und eine alternative Methode </font></font><code>OverlapCapsuleNonAlloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit dem Array als zus√§tzlichem Argument aufgerufen wird. </font><font style="vertical-align: inherit;">Die L√§nge des √ºbertragenen Arrays bestimmt die Anzahl der Ergebnisse. </font><font style="vertical-align: inherit;">Alle potenziellen Ziele au√üerhalb des Arrays werden verworfen. </font><font style="vertical-align: inherit;">Trotzdem verwenden wir nur das erste Element, daher reicht uns ein Array mit der L√§nge 1 aus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anstelle eines Arrays wird </font></font><code>OverlapCapsuleNonAlloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Anzahl der aufgetretenen Kollisionen bis zum maximal zul√§ssigen Wert zur√ºckgegeben. Dies ist die Anzahl, die wir anstelle der L√§nge des Arrays √ºberpr√ºfen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Collider[] targetsBuffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Collider[<span class="hljs-number"><span class="hljs-number">1</span></span>]; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a = transform.localPosition; Vector3 b = a; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> += <span class="hljs-number"><span class="hljs-number">2f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hits = Physics.OverlapCapsuleNonAlloc( a, b, targetingRange, targetsBuffer, enemyLayerMask ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hits &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { target = targetsBuffer[<span class="hljs-number"><span class="hljs-number">0</span></span>].GetComponent&lt;TargetPoint&gt;(); Debug.Assert(target != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Targeted non-enemy!"</span></span>, targetsBuffer[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir schie√üen auf Feinde </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt, da wir ein echtes Ziel haben, ist es Zeit, es zu schie√üen. </font><font style="vertical-align: inherit;">Das Schie√üen umfasst das Zielen, einen Laserschuss und das Verursachen von Schaden.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Revolver zielen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um den Turm zum Ziel zu lenken, muss die Klasse </font></font><code>Tower</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine Verbindung zur </font></font><code>Transform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Turmkomponente haben. </font><font style="vertical-align: inherit;">F√ºgen Sie dazu ein Konfigurationsfeld hinzu und verbinden Sie es mit dem Tower-Fertighaus.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] Transform turret = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0f/3be/41b/e0f3be41b0936993268316b8f01e1f67.png" width="320" height="90"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der angebrachte Turm. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn </font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es ein echtes Ziel gibt, m√ºssen wir es abschie√üen. </font><font style="vertical-align: inherit;">Geben Sie den Aufnahmecode in eine separate Methode ein. </font><font style="vertical-align: inherit;">Lassen Sie ihn den Turm in Richtung des Ziels drehen und seine Methode </font></font><code>Transform.LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit dem Zielpunkt als Argument </font><font style="vertical-align: inherit;">aufrufen </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TrackTarget() || AcquireTarget()) { <span class="hljs-comment"><span class="hljs-comment">//Debug.Log("Locked on target!"); Shoot(); } } void Shoot () { Vector3 point = target.Position; turret.LookAt(point); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00e/5bb/e9d/00e5bbe9d98e739800bf47435ca574af.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nur zielen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir schie√üen einen Laser </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um den Laserstrahl zu positionieren, ben√∂tigt die Klasse </font></font><code>Tower</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auch eine Verkn√ºpfung dazu.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] Transform turret = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, laserBeam = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/802/c9c/86e/802c9c86eac24112cb2b4f072fd0f410.png" width="320" height="110"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben einen Laserstrahl angeschlossen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um einen W√ºrfel in einen echten Laserstrahl zu verwandeln, m√ºssen Sie drei Schritte ausf√ºhren. </font><font style="vertical-align: inherit;">Erstens sollte seine Ausrichtung der Ausrichtung des Turmes entsprechen. </font><font style="vertical-align: inherit;">Dies kann durch Kopieren der Drehung erfolgen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Shoot</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 point = target.Position; turret.LookAt(point); laserBeam.localRotation = turret.localRotation; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zweitens skalieren wir den Laserstrahl so, dass seine L√§nge dem Abstand zwischen dem lokalen Ursprungspunkt des Turmes und dem Zielpunkt entspricht. </font><font style="vertical-align: inherit;">Wir skalieren es entlang der Z-Achse, dh der lokalen Achse, die auf das Ziel gerichtet ist. </font><font style="vertical-align: inherit;">Um die urspr√ºngliche XY-Skala beizubehalten, schreiben wir die urspr√ºngliche Skala auf, wenn wir den Awake-Turm aufwecken.</font></font><br><br><pre> <code class="cs hljs"> Vector3 laserBeamScale; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { laserBeamScale = laserBeam.localScale; } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Shoot</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 point = target.Position; turret.LookAt(point); laserBeam.localRotation = turret.localRotation; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d = Vector3.Distance(turret.position, point); laserBeamScale.z = d; laserBeam.localScale = laserBeamScale; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Drittens platzieren wir den Laserstrahl in der Mitte zwischen dem Turm und dem Zielpunkt. </font></font><br><br><pre> <code class="cs hljs"> laserBeam.localScale = laserBeamScale; laserBeam.localPosition = turret.localPosition + <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * d * laserBeam.forward;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/288/d96/438/288d96438354bd732fd7a3bb84ead491.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Laserschie√üen.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ist es nicht m√∂glich, einen Laserstrahl zum Kind eines Turmes zu machen?</font></font></b> <div class="spoiler_text">     ,         ,       forward.       ,     .     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies funktioniert, w√§hrend der Turm am Ziel befestigt ist. </font><font style="vertical-align: inherit;">Wenn jedoch kein Ziel vorhanden ist, bleibt der Laser aktiv. </font><font style="vertical-align: inherit;">Wir k√∂nnen die Laseranzeige ausschalten, indem wir ihre Skala auf </font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 setzen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TrackTarget() || AcquireTarget()) { Shoot(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { laserBeam.localScale = Vector3.zero; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39b/8c8/c23/39b8c8c239e0936137c646f91a4197de.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leerlauft√ºrme feuern nicht.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Feindliche Gesundheit </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher ber√ºhren unsere Laserstrahlen nur die Feinde und beeinflussen sie nicht mehr. </font><font style="vertical-align: inherit;">Es muss sichergestellt werden, dass der Laser Feinden Schaden zuf√ºgt. </font><font style="vertical-align: inherit;">Wir wollen Feinde nicht sofort zerst√∂ren, also geben wir die </font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eigenschaft der Gesundheit. </font><font style="vertical-align: inherit;">Sie k√∂nnen einen beliebigen Wert als Gesundheit ausw√§hlen, nehmen wir also 100. F√ºr gro√üe Feinde ist es jedoch logischer, mehr Gesundheit zu haben. Daher f√ºhren wir hierf√ºr einen Koeffizienten ein.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Health { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathOffset</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Health = <span class="hljs-number"><span class="hljs-number">100f</span></span> * scale; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie eine √∂ffentliche Methode hinzu </font></font><code>ApplyDamage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die den Parameter von der Gesundheit abzieht, </font><font style="vertical-align: inherit;">um Unterst√ºtzung f√ºr das Verursachen von Schaden hinzuzuf√ºgen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir gehen davon aus, dass der Schaden nicht negativ ist, und f√ºgen daher eine Erkl√§rung dazu hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ApplyDamage</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> damage</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(damage &gt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-string"><span class="hljs-string">"Negative damage applied."</span></span>); Health -= damage; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden den Feind nicht sofort loswerden, sobald seine Gesundheit Null erreicht. </font><font style="vertical-align: inherit;">Zu Beginn wird gepr√ºft, ob die Gesundheit ersch√∂pft ist und der Feind zerst√∂rt ist </font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Health &lt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>) { OriginFactory.Reclaim(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dank dessen schie√üen alle T√ºrme im Wesentlichen gleichzeitig und nicht nacheinander, wodurch sie zu anderen Zielen wechseln k√∂nnen, wenn der vorherige Turm den Feind zerst√∂rt hat, auf den sie auch abgezielt haben. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schaden pro Sekunde </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt m√ºssen wir bestimmen, wie viel Schaden der Laser anrichten wird. </font><font style="vertical-align: inherit;">F√ºgen Sie dazu </font></font><code>Tower</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">das Konfigurationsfeld hinzu. </font><font style="vertical-align: inherit;">Da der Laserstrahl kontinuierlichen Schaden verursacht, werden wir ihn als Schaden pro Sekunde ausdr√ºcken. </font><font style="vertical-align: inherit;">Wir </font></font><code>Shoot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenden es auf die </font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zielkomponente mit Multiplikation mit der Deltazeit an.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(1f, 100f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> damagePerSecond = <span class="hljs-number"><span class="hljs-number">10f</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Shoot</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ target.Enemy.ApplyDamage(damagePerSecond * Time.deltaTime); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/886/18f/199/88618f199c9c08e7eaeb89b16083f545.png" width="320" height="128" alt="Inspektor"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gk/vt/sf/gkvtsfa1ya4igbsjagqhtnzu0wq.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Schaden jedes Turms betr√§gt 20 Einheiten pro Sekunde.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zuf√§lliges Zielen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir immer das erste verf√ºgbare Ziel ausw√§hlen, h√§ngt das Zielverhalten von der Reihenfolge ab, in der die Physik-Engine sich √ºberschneidende Kollider √ºberpr√ºft. Diese Abh√§ngigkeit ist nicht sehr gut, da wir die Details nicht kennen und sie nicht kontrollieren k√∂nnen. Au√üerdem wird sie seltsam und inkonsistent aussehen. Oft f√ºhrt dieses Verhalten zu konzentriertem Feuer, aber dies ist nicht immer der Fall. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anstatt sich ausschlie√ülich auf die Physik-Engine zu verlassen, f√ºgen wir etwas Zuf√§lligkeit hinzu. Dies kann erreicht werden, indem die Anzahl der von Kollidern empfangenen Kreuzungen beispielsweise auf 100 erh√∂ht wird. M√∂glicherweise reicht dies nicht aus, um alle m√∂glichen Ziele in einem dicht mit Feinden gef√ºllten Feld zu erreichen, aber dies reicht aus, um das Zielen zu verbessern.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Collider[] targetsBuffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Collider[<span class="hljs-number"><span class="hljs-number">100</span></span>];</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anstatt das erste potenzielle Ziel auszuw√§hlen, w√§hlen wir jetzt ein zuf√§lliges Element aus dem Array aus. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hits &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { target = targetsBuffer[Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, hits)].GetComponent&lt;TargetPoint&gt;(); ‚Ä¶ } target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nv/lt/hi/nvlthij_ixh6lsxgwujtoipjwg4.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuf√§lliges Zielen.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">K√∂nnen andere Kriterien f√ºr die Auswahl der Ziele verwendet werden?</font></font></b> <div class="spoiler_text"> , ,        .  ,      ,     .    .             . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In unserem Tower Defense-Spiel sind also endlich T√ºrme aufgetaucht. </font><font style="vertical-align: inherit;">Im n√§chsten Teil wird das Spiel noch mehr seine endg√ºltige Form annehmen.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459070/">https://habr.com/ru/post/de459070/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459052/index.html">Wie man vergleicht: "tolles Auto" und "h√§ssliche H√ºtte", in einer Marketingumfrage und in Big Data</a></li>
<li><a href="../de459054/index.html">Heatmap von Klicks - wie sich Benutzer auf der Website verhalten</a></li>
<li><a href="../de459062/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 305 (vom 1. bis 7. Juli)</a></li>
<li><a href="../de459066/index.html">Datenbank-Schreib- und Leseausgleich</a></li>
<li><a href="../de459068/index.html">Windows Server 2008 R2 - Der K√∂nig ist tot, es lebe der K√∂nig</a></li>
<li><a href="../de459074/index.html">Kleine Freude # 7: Drei zum Preis von One-Console-Animation, Algorithmen und Debugging</a></li>
<li><a href="../de459078/index.html">CERN wechselt zu Open Source Software - warum?</a></li>
<li><a href="../de459080/index.html">Features HttpUrlConnection von java.net</a></li>
<li><a href="../de459082/index.html">Wer sind Eidetiker, wie falsche Erinnerungen funktionieren und drei popul√§re Mythen √ºber das Ged√§chtnis</a></li>
<li><a href="../de459084/index.html">Ein wenig √ºber Google Home Hub oder wie ich einen Fotorahmen f√ºr 130 Euro gekauft habe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>