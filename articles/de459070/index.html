<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍⚖️ 🌚 👩🏼‍🔧 Turmverteidigung in Einheit schaffen: Türme und schießende Feinde 💪🏼 🙂 🧗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[ Der erste und zweite Teil des Tutorials] 



- Wir platzieren auf dem Feld des Turms. 
- Wir zielen mit Hilfe der Physik auf Feinde. 
- Wir verfolge...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Turmverteidigung in Einheit schaffen: Türme und schießende Feinde</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459070/">  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der erste</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zweite</a> Teil des Tutorials] <br><br><ul><li>  Wir platzieren auf dem Feld des Turms. </li><li>  Wir zielen mit Hilfe der Physik auf Feinde. </li><li>  Wir verfolgen sie, solange es möglich ist. </li><li>  Wir schießen sie mit einem Laserstrahl. </li></ul><br>  Dies ist der dritte Teil einer Reihe von Tutorials zur Erstellung eines einfachen Tower Defense-Genres.  Es beschreibt die Schaffung von Türmen, die auf Feinde zielen und auf diese schießen. <br><br>  Das Tutorial wurde in Unity 2018.3.0f2 erstellt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/470/ceb/183/470ceb1832b49ee7372fb79b8425b567.jpg" width="512" height="256"></div><br>  <i>Erhitzen wir die Feinde.</i> <br><br><h2>  Turmschöpfung </h2><br>  Mauern verlangsamen nur Feinde und verlängern den Weg, den sie gehen müssen.  Das Ziel des Spiels ist es jedoch, die Feinde zu zerstören, bevor sie den Endpunkt erreichen.  Dieses Problem wird gelöst, indem Türme auf dem Feld platziert werden, die auf sie schießen. <br><a name="habracut"></a><br><h3>  Kachelinhalt </h3><br>  Türme sind eine andere Art von <code>GameTileContent</code> . <code>GameTileContent</code> Sie daher einen Eintrag für sie in <code>GameTileContent</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> GameTileContentType { Empty, Destination, Wall, SpawnPoint, Tower€ }</code> </pre> <br>  In diesem Tutorial werden wir nur einen Turmtyp unterstützen, der implementiert werden kann, indem <code>GameTileContentFactory</code> einem Link zum Tower-Fertighaus versehen wird, von dem eine Instanz auch über <code>Get</code> erstellt werden kann. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTileContent towerPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTileContent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContentType type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { … <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Tower€: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(towerPrefab); } … }</code> </pre> <br>  Aber die Türme müssen schießen, daher muss ihr Zustand aktualisiert werden und sie benötigen ihren eigenen Code.  Erstellen Sie zu diesem Zweck eine <code>Tower</code> Klasse, die die <code>GameTileContent</code> Klasse erweitert. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Tower</span></span> : <span class="hljs-title"><span class="hljs-title">GameTileContent</span></span> {}</code> </pre> <br>  Sie können dem Tower-Fertighaus eine eigene Komponente hinzufügen, indem Sie den Feldtyp der Fabrik in <code>Tower</code> ändern.  Da die Klasse immer noch als <code>GameTileContent</code> , muss nichts anderes geändert werden. <br><br><pre> <code class="cs hljs"> Tower towerPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><h3>  Fertighaus </h3><br>  Erstellen Sie ein Fertighaus für den Turm.  Sie können beginnen, indem Sie das Wandfertigteil duplizieren und die <code>GameTileContent</code> Komponente durch die <code>Tower</code> Komponente ersetzen und dann ihren Typ in <em>Tower</em> ändern.  Speichern Sie den Wandwürfel als Basis des Turms, damit der Turm an die Wände passt.  Dann legen Sie einen weiteren Würfel darauf.  Ich gab ihm eine Skala von 0,5.  Lege einen weiteren Würfel darauf, der auf einen Turm hinweist. Dieser Teil zielt und schießt auf Feinde. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/392/e5d/633/392e5d63397672627c3b5ec018df0444.png" width="190" height="260"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d92/dec/c33/d92decc33036a1e973a7f20a3df2c00e.png" width="320" height="120"></div><br>  <i>Drei Würfel bilden einen Turm.</i> <br><br>  Der Turm dreht sich und da er einen Kollider hat, wird er von einem physischen Motor verfolgt.  Wir müssen jedoch nicht so präzise sein, da wir Turmkollider nur zur Auswahl von Zellen verwenden.  Dies kann ungefähr erfolgen.  Entfernen Sie den Revolverwürfelkollider und ändern Sie den Turmwürfelkollider so, dass er beide Würfel bedeckt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e01/11e/3b7/e0111e3b7221bbbe4e5b0d23373e4b3a.png" width="190" height="260"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1f/857/09b/a1f85709bd504d176a18930240edea5a.png" width="320" height="152"></div><br>  <i>Collider Würfelturm.</i> <br><br>  Der Turm schießt einen Laserstrahl.  Es kann auf viele Arten visualisiert werden, aber wir verwenden nur einen durchscheinenden Würfel, den wir dehnen, um einen Strahl zu bilden.  Jeder Turm muss einen eigenen Balken haben, also fügen Sie ihn dem vorgefertigten Turm hinzu.  Platzieren Sie es so im Turm, dass es standardmäßig ausgeblendet ist, und geben Sie ihm einen kleineren Maßstab, z. B. 0,2.  Machen wir es zu einem Kind der vorgefertigten Wurzel, nicht des Turmwürfels. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19a/1dc/29e/19a1dc29e70adb158e07f29653db2d66.png" width="190" height="260" alt="Laserstrahl"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45a/273/081/45a273081365aa9e483f1aa97cbe39c8.png" width="226" height="108" alt="Hierarchie"></div><br>  <i>Versteckter Würfel eines Laserstrahls.</i> <br><br>  Erstellen Sie ein geeignetes Material für den Laserstrahl.  Ich habe gerade das durchscheinende schwarze Standardmaterial verwendet, alle Reflexionen ausgeschaltet und ihm eine rot emittierte Farbe gegeben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2fb/e49/860/2fbe498604cc4cc4ed6ee60a45eea63d.png" width="320" height="284" alt="Farbe"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0eb/b46/483/0ebb4648376a7fe68c96b7a16ce27db9.png" width="320" height="56" alt="keine reflexionen"></div><br>  <i>Das Material des Laserstrahls.</i> <br><br>  Stellen Sie sicher, dass der Laserstrahl keinen Kollider hat, und schalten Sie auch den Wurf und den Schatten aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecf/f21/0ad/ecff210ad75ef4b12cb0a74102365492.png" width="320" height="162"></div><br>  <i>Der Laserstrahl interagiert nicht mit Schatten.</i> <br><br>  Nachdem die Erstellung des Turmfertigteils abgeschlossen ist, werden wir es der Fabrik hinzufügen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/626/37c/935/62637c9353cf1e20e170e82bbefcdb11.png" width="320" height="114"></div><br>  <i>Fabrik mit einem Turm.</i> <br><br><h3>  Turmplatzierung </h3><br>  Wir werden Türme mit einer anderen Schaltmethode hinzufügen und entfernen.  Sie können <code>GameBoard.ToggleWall</code> einfach duplizieren, indem Sie den Methodennamen und den Inhaltstyp ändern. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleTower</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Tower€) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.Tower€); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!FindPaths()) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } } }</code> </pre> <br>  <code>Game.HandleTouch</code> in <code>Game.HandleTouch</code> die Umschalttaste gedrückt halten, werden eher Türme als Wände <code>Game.HandleTouch</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = board.GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { board.ToggleTower(tile); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { board.ToggleWall(tile); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/926/804/2ac/9268042acc19a28d6ff1a6d74d83144f.png" width="230" height="230"></div><br>  <i>Türme auf dem Feld.</i> <br><br><h3>  Pfadblockierung </h3><br>  Bisher können nur Mauern die Suche nach einem Pfad blockieren, sodass sich Feinde durch Türme bewegen.  <code>GameTileContent</code> wir <code>GameTileContent</code> Eigenschaft <code>GameTileContent</code> , die angibt, ob der Inhalt den Pfad blockiert.  Der Weg ist blockiert, wenn es sich um eine Mauer oder einen Turm handelt. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> BlocksPath =&gt; Type == GameTileContentType.Wall || Type == GameTileContentType.Tower€;</code> </pre> <br>  Verwenden Sie diese Eigenschaft in <code>GameTile.GrowPathTo</code> anstatt den Inhaltstyp zu überprüfen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor, Direction direction</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-comment"><span class="hljs-comment">//neighbor.Content.Type != GameTileContentType.Wall ? neighbor : null; neighbor.Content.BlocksPath ? null : neighbor; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fa/93f/eed/6fa93feedb4925ee12decb4233612a4c.png" width="230" height="230"></div><br>  <i>Jetzt ist der Weg durch Mauern und Türme blockiert.</i> <br><br><h3>  Ersetzen Sie die Wände </h3><br>  Höchstwahrscheinlich wird der Spieler die Wände oft durch Türme ersetzen.  Es wird für ihn unpraktisch sein, zuerst die Mauer zu entfernen, und außerdem können Feinde in diese vorübergehend erscheinende Lücke eindringen.  Sie können einen direkten Ersatz implementieren, indem Sie <code>GameBoard.ToggleTower</code> zwingen, zu überprüfen, ob sich die Wand derzeit auf der Kachel befindet.  Wenn ja, ersetzen Sie es sofort durch einen Turm.  In diesem Fall müssen wir nicht nach anderen Wegen suchen, da die Kachel sie immer noch blockiert. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleTower</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Tower) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Wall) { tile.Content = contentFactory.Get(GameTileContentType.Tower); } }</code> </pre> <br><h2>  Wir zielen auf Feinde </h2><br>  Ein Turm kann seine Aufgabe nur erfüllen, wenn er einen Feind findet.  Nachdem sie den Feind gefunden hat, muss sie entscheiden, auf welchen Teil sie zielen soll. <br><br><h3>  Zielpunkt </h3><br>  Um Ziele zu erkennen, verwenden wir die Physik-Engine.  Wie beim Tower Collider muss der feindliche Collider nicht unbedingt mit seiner Form übereinstimmen.  Sie können den einfachsten Collider auswählen, dh eine Kugel.  Nachdem wir den Feind entdeckt haben, verwenden wir die Position des Spielobjekts mit dem daran befestigten Collider als Zielpunkt. <br><br>  Wir können den Collider nicht am Wurzelobjekt des Feindes befestigen, da er nicht immer mit der Position des Modells übereinstimmt und den Turm auf den Boden zielen lässt.  Das heißt, Sie müssen den Collider irgendwo auf dem Modell platzieren.  Die Physik-Engine gibt uns einen Link zu diesem Objekt, den wir zum Zielen verwenden können, aber wir benötigen weiterhin Zugriff auf die <code>Enemy</code> Komponente des Stammobjekts.  Um die Aufgabe zu vereinfachen, erstellen <code>TargetPoint</code> die <code>TargetPoint</code> Komponente.  Geben wir ihm eine Eigenschaft für den privaten Auftrag und den öffentlichen Empfang der <code>Enemy</code> Komponente und eine weitere Eigenschaft für die Erlangung seiner Position in der Welt. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TargetPoint</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Enemy Enemy€ { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 Position =&gt; transform.position; }</code> </pre> <br>  Geben wir ihm eine <code>Awake</code> Methode, die einen Link zu seiner <code>Enemy</code> Komponente herstellt.  Gehen Sie mit <code>transform.root</code> direkt zum <code>transform.root</code> .  Wenn die <code>Enemy</code> Komponente nicht vorhanden ist, haben wir beim Erstellen des Feindes einen Fehler gemacht. Fügen wir also eine Erklärung dazu hinzu. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Enemy€ = transform.root.GetComponent&lt;Enemy&gt;(); Debug.Assert(Enemy€ != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Target point without Enemy root!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  Außerdem muss der Collider an dasselbe Spielobjekt angehängt werden, an das <code>TargetPoint</code> angehängt ist. <br><br><pre> <code class="cs hljs"> Debug.Assert(Enemy€ != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Target point without Enemy root!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); Debug.Assert( GetComponent&lt;SphereCollider&gt;() != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Target point without sphere collider!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> );</code> </pre> <br>  Fügen Sie dem vorgefertigten Würfel des Feindes eine Komponente und einen Collider hinzu.  Dadurch zielen die Türme auf die Mitte des Würfels.  Wir verwenden einen Kugelcollider mit einem Radius von 0,25.  Der Würfel hat eine Skala von 0,5, sodass der wahre Radius des Kolliders 0,125 beträgt.  Dank dessen muss der Feind den Entfernungskreis des Turms visuell überqueren, und erst nach einiger Zeit wird das eigentliche Ziel erreicht.  Die Größe des Kolliders wird auch von der zufälligen Skala des Feindes beeinflusst, sodass seine Größe im Spiel ebenfalls geringfügig variiert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/85e/5ca/5e4/85e5ca5e47b8d59fa4211c78126bd512.png" width="176" height="176"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ae/a71/aec/7aea71aecbd64d4e045df141ecd1c711.png" width="320" height="176" alt="Inspektor"></div><br>  <i>Ein Feind mit einem Zielpunkt und einem Kollider auf einem Würfel.</i> <br><br><h3>  Feindliche Schicht </h3><br>  Türme kümmern sich nur um Feinde, und sie zielen nicht auf etwas anderes, also werden wir alle Feinde in eine separate Schicht legen.  Wir werden Ebene 9 verwenden. Ändern Sie ihren Namen im Fenster " <em>Ebenen und Tags"</em> in " <em>Feind".</em> <em>Dies</em> kann über die Option " <em>Ebenen bearbeiten</em> " im Dropdown-Menü " <em>Ebenen"</em> in der oberen rechten Ecke des Editors geöffnet werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e6/9a5/762/8e69a5762e8eb1856175f9d9dc1ab388.png" width="320" height="308"></div><br>  <i>Schicht 9 wird für Feinde verwendet.</i> <br><br>  Diese Schicht wird nur zur Erkennung von Feinden und nicht für physische Interaktionen benötigt.  Lassen Sie uns darauf hinweisen, indem Sie sie in der <em>Layer Collision Matrix</em> deaktivieren, die sich im Bereich <em>Physik</em> der Projektparameter befindet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/876/06e/e7d/87606ee7dfc4777760d81219517125ce.png" width="200" height="200"></div><br>  <i>Matrix von Schichtkollisionen.</i> <br><br>  Stellen Sie sicher, dass sich das Spielobjekt des Zielpunkts auf der gewünschten Ebene befindet.  Der Rest des Fertighauses des Feindes befindet sich möglicherweise auf anderen Ebenen, aber es ist einfacher, alles zu koordinieren und das gesamte Fertighaus in der <em>feindlichen</em> Ebene zu platzieren.  Wenn Sie die Ebene des Stammobjekts ändern, werden Sie aufgefordert, die Ebene für alle untergeordneten Objekte zu ändern. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d1/f75/062/6d1f75062420abadb285e9efca1e1a5e.png" width="320" height="44"></div><br>  <i>Feind auf der rechten Ebene.</i> <br><br>  <code>TargetPoint</code> wir die Aussage hinzu, dass <code>TargetPoint</code> wirklich auf der richtigen Ebene liegt. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … Debug.Assert(gameObject.layer == <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-string"><span class="hljs-string">"Target point on wrong layer!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  Außerdem müssen die Aktionen des Spielers von feindlichen Kollidern ignoriert werden.  Dies kann erreicht werden, indem <code>Physics.Raycast</code> in <code>GameBoard.GetTile</code> <code>Physics.Raycast</code> <code>GameBoard.GetTile</code> .  Diese Methode hat eine Form, die den Abstand zum Strahl und zur Ebenenmaske als zusätzliche Argumente verwendet.  Wir geben ihm standardmäßig den maximalen Abstand und die maximale Ebenenmaske, d. H. 1. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTile</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ray ray</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> RaycastHit hit, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>.MaxValue, <span class="hljs-number"><span class="hljs-number">1</span></span>)) { … } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Sollte die Ebenenmaske nicht 0 sein?</b> <div class="spoiler_text">  Der Standard-Ebenenindex ist Null, aber wir übergeben die Ebenenmaske.  Die Maske ändert die einzelnen Bits einer Ganzzahl in 1, wenn die Ebene aktiviert werden muss.  In diesem Fall müssen Sie nur das erste Bit setzen, dh das niedrigstwertige, dh 2 <sup>0</sup> , was 1 entspricht. </div></div><br><h3>  Aktualisieren des Kachelinhalts </h3><br>  Türme können ihre Aufgabe nur ausführen, wenn ihr Status aktualisiert wird.  Gleiches gilt für den Inhalt der gesamten Kacheln, obwohl der Rest des Inhalts bisher nichts bewirkt.  <code>GameTileContent</code> daher <code>GameTileContent</code> virtuelle <code>GameTileContent</code> Methode <code>GameUpdate</code> , die standardmäßig nichts bewirkt. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {}</code> </pre> <br>  Lassen Sie <code>Tower</code> neu definieren, auch wenn es vorerst einfach in der Konsole anzeigt, dass es nach einem Ziel sucht. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Searching for target..."</span></span>); }</code> </pre> <br>  <code>GameBoard</code> befasst sich mit Kacheln und deren Inhalten, sodass auch <code>GameBoard</code> werden kann, welche Inhalte aktualisiert werden müssen.  <code>GameUpdate</code> Sie dazu die Liste und die öffentliche <code>GameUpdate</code> Methode hinzu, mit der alle <code>GameUpdate</code> in der Liste aktualisiert werden. <br><br><pre> <code class="cs hljs"> List&lt;GameTileContent&gt; updatingContent = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;GameTileContent&gt;(); … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; updatingContent.Count; i++) { updatingContent[i].GameUpdate(); } }</code> </pre> <br>  In unserem Tutorial müssen Sie nur die Türme aktualisieren.  Ändern Sie <code>ToggleTower</code> so, dass bei Bedarf Inhalte <code>ToggleTower</code> und entfernt werden.  Wenn auch andere Inhalte benötigt werden, brauchen wir einen allgemeineren Ansatz, aber im Moment reicht dies aus. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleTower</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Tower) { updatingContent.Remove(tile.Content); tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.Tower); <span class="hljs-comment"><span class="hljs-comment">//if (!FindPaths()) { if (FindPaths()) { updatingContent.Add(tile.Content); } else { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } } else if (tile.Content.Type == GameTileContentType.Wall) { tile.Content = contentFactory.Get(GameTileContentType.Tower); updatingContent.Add(tile.Content); } }</span></span></code> </pre> <br>  Damit dies funktioniert, reicht es jetzt aus, das Feld in <code>Game.Update</code> einfach zu aktualisieren.  Wir werden das Feld nach den Feinden aktualisieren.  Dank dessen können die Türme genau zielen, wo sich die Feinde befinden.  Wenn wir es anders machen würden, würden die Türme zielen, wo sich die Feinde im letzten Frame befanden. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … enemies.GameUpdate(); board.GameUpdate(); }</code> </pre> <br><h3>  Zielbereich </h3><br>  Türme haben einen begrenzten Zielradius.  Machen wir es uns benutzerdefiniert, indem wir der <code>Tower</code> Klasse ein Feld hinzufügen.  Der Abstand wird von der Mitte des Turmplättchens gemessen, sodass in einem Bereich von 0,5 nur das eigene Plättchen abgedeckt wird.  Daher wäre ein angemessener Mindest- und Standardbereich 1,5, der die meisten benachbarten Fliesen abdeckt. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(1.5f, 10.5f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> targetingRange = <span class="hljs-number"><span class="hljs-number">1.5f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c38/ae4/ee8/c38ae4ee885cf5d89f24164b9c6bc5fe.png" width="320" height="74"></div><br>  <i>Zielbereich 2.5.</i> <br><br>  Lassen Sie uns die Reichweite mit Gizmo visualisieren.  Wir müssen es nicht ständig sehen, daher erstellen wir die <code>OnDrawGizmosSelected</code> Methode, die nur für die ausgewählten Objekte aufgerufen wird.  Wir zeichnen den gelben Rahmen der Kugel mit einem Radius, der dem Abstand entspricht und relativ zum Turm zentriert ist.  Stellen Sie es leicht über den Boden, damit es immer gut sichtbar ist. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmosSelected</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Gizmos.color = Color.yellow; Vector3 position = transform.localPosition; position.y += <span class="hljs-number"><span class="hljs-number">0.01f</span></span>; Gizmos.DrawWireSphere(position, targetingRange); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/674/6b7/3cd/6746b73cd2e015fd599b770bb89e1c8a.png" width="230" height="230"></div><br>  <i>Gizmo Zielstrecke.</i> <br><br>  Jetzt können wir sehen, welcher der Feinde ein erschwingliches Ziel für jeden der Türme ist.  Die Auswahl von Türmen im Szenenfenster ist jedoch unpraktisch, da wir einen der untergeordneten Würfel auswählen und dann zum Stammobjekt des Turms wechseln müssen.  Andere Arten von Flieseninhalten leiden ebenfalls unter dem gleichen Problem.  Wir können die Auswahl des <code>GameTileContent</code> des <code>GameTileContent</code> im <code>GameTileContent</code> indem <code>GameTileContent</code> dem <code>GameTileContent</code> das <code>SelectionBase</code> Attribut <code>GameTileContent</code> . <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">SelectionBase</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameTileContent</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { … }</code> </pre> <br><h3>  Zielerfassung </h3><br>  Fügen <code>TargetPoint</code> der <code>Tower</code> Klasse ein <code>TargetPoint</code> Feld hinzu, damit sie das erfasste Ziel verfolgen kann.  Anschließend <code>GameUpdate</code> wir <code>GameUpdate</code> , um die neue <code>AquireTarget</code> Methode <code>AquireTarget</code> , die Informationen darüber zurückgibt, ob das Ziel gefunden wurde.  Bei der Erkennung wird eine Meldung in der Konsole angezeigt. <br><br><pre> <code class="cs hljs"> TargetPoint target; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (AcquireTarget()) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Acquired target!"</span></span>); } }</code> </pre> <br>  In <code>AcquireTarget</code> wir alle verfügbaren Ziele, indem wir <code>Physics.OverlapSphere</code> mit einer <code>Physics.OverlapSphere</code> und einem Bereich als Argumente aufrufen.  Das Ergebnis ist ein <code>Collider</code> Array, das alle <code>Collider</code> enthält, die mit der Kugel in Kontakt stehen.  Wenn die Länge des Arrays positiv ist, gibt es mindestens einen Zielpunkt, und wir wählen einfach den ersten aus.  Nehmen Sie die <code>TargetPoint</code> Komponente, die immer vorhanden sein muss, weisen Sie sie dem Zielfeld zu und melden Sie den Erfolg.  Andernfalls löschen wir das Ziel und melden den Fehler. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Collider[] targets = Physics.OverlapSphere( transform.localPosition, targetingRange ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (targets.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { target = targets[<span class="hljs-number"><span class="hljs-number">0</span></span>].GetComponent&lt;TargetPoint&gt;(); Debug.Assert(target != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Targeted non-enemy!"</span></span>, targets[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Wir erhalten garantiert die richtigen Zielpunkte, wenn wir Kollider nur auf der Ebene der Feinde berücksichtigen.  Dies ist Ebene 9, daher übergeben wir die entsprechende Ebenenmaske. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> enemyLayerMask = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">9</span></span>; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Collider[] targets = Physics.OverlapSphere( transform.localPosition, targetingRange, enemyLayerMask ); … }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Wie funktioniert diese Bitmaske?</b> <div class="spoiler_text">  Da die feindliche Schicht einen Index von 9 hat, sollte das zehnte Bit der Bitmaske den Wert 1 haben. Dies entspricht einer ganzen Zahl 2 <sup>9</sup> , dh 512. Ein solcher Bitmaskendatensatz ist jedoch nicht intuitiv.  Wir können auch ein binäres Literal schreiben, zum Beispiel <code>0b10_0000_0000</code> , aber dann müssen wir Nullen zählen.  In diesem Fall wäre die bequemste Eingabe die Verwendung des Linksverschiebungsoperators <code>&lt;&lt;</code> , der die Bits nach links verschiebt.  das entspricht einer Zahl in der Potenz von zwei. </div></div><br>  Sie können das erfasste Ziel visualisieren, indem Sie eine Gizmo-Linie zwischen den Positionen des Turms und des Ziels zeichnen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmosSelected</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Gizmos.DrawLine(position, target.Position); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a5/e99/4be/7a5e994be6b7d848c2d4bfe7d627c708.png" width="230" height="230"></div><br>  <i>Visualisierung von Zielen.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Warum nicht Methoden wie OnTriggerEnter verwenden?</b> <div class="spoiler_text">  Der Vorteil der manuellen Überprüfung von Querschnittszielen besteht darin, dass wir dies nur bei Bedarf tun können.  Es gibt keinen Grund, nach Zielen zu suchen, wenn der Turm bereits eines hat.  Indem wir alle potenziellen Ziele gleichzeitig erreichen, müssen wir nicht für jeden Turm eine Liste potenzieller Ziele verarbeiten, die sich ständig ändert. </div></div><br><h3>  Zielsperre </h3><br>  Das zu erfassende Ziel hängt von der Reihenfolge ab, in der sie von der physischen Engine dargestellt werden, dh es ist tatsächlich willkürlich.  Daher scheint sich das erfasste Ziel ohne Grund zu ändern.  Nachdem der Turm das Ziel erhalten hat, ist es für sie logischer, ihr Ziel zu folgen und nicht zu einem anderen zu wechseln.  Fügen Sie eine <code>TrackTarget</code> Methode hinzu, die eine solche Verfolgung implementiert und Informationen darüber zurückgibt, ob sie erfolgreich war.  Zunächst teilen wir Ihnen nur mit, ob das Ziel erfasst wurde. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Wir werden diese Methode in <code>GameUpdate</code> und nur wenn false zurückgegeben wird, werden wir <code>AcquireTarget</code> .  Wenn die Methode true zurückgibt, haben wir ein Ziel.  Dies kann erreicht werden, indem beide Methodenaufrufe beim <code>if</code> Operator einer <code>if</code> Prüfung unterzogen werden. Wenn der erste Operand <code>true</code> zurückgibt, wird der zweite nicht geprüft und der Aufruf wird verpasst.  Der AND-Operator verhält sich ähnlich. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TrackTarget() || AcquireTarget()) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Locked on target!"</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ec/27c/0a2/8ec27c0a2201434cba3725621b68aaa1.png" width="230" height="230"></div><br>  <i>Ziele verfolgen.</i> <br><br>  Infolgedessen werden die Türme am Ziel befestigt, bis es den Endpunkt erreicht und zerstört wird.  Wenn Sie wiederholt Feinde verwenden, müssen Sie stattdessen die Richtigkeit des Links überprüfen, wie dies bei Links zu Zahlen der Fall ist, die in einer Reihe von Tutorials zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Objektverwaltung</a> verarbeitet wurden. <br><br>  Um Ziele nur dann zu verfolgen, wenn sie sich in Reichweite befinden, muss <code>TrackTarget</code> die Entfernung zwischen dem Turm und dem Ziel verfolgen.  Wenn der Bereichswert überschritten wird, muss das Ziel zurückgesetzt und false zurückgegeben werden.  Sie können die <code>Vector3.Distance</code> Methode für diese Prüfung verwenden. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } Vector3 a = transform.localPosition; Vector3 b = target.Position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Vector3.Distance(a, b) &gt; targetingRange) { target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Dieser Code berücksichtigt jedoch nicht den Radius des Colliders.  Infolgedessen kann der Turm das Ziel verlieren und es dann erneut erfassen, um es im nächsten Frame nicht mehr zu verfolgen, und so weiter.  Wir können dies vermeiden, indem wir dem Bereich einen Kolliderradius hinzufügen. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Vector3.Distance(a, b) &gt; targetingRange + <span class="hljs-number"><span class="hljs-number">0.125f</span></span>) { … }</code> </pre> <br>  Dies gibt uns die richtigen Ergebnisse, aber nur, wenn die Größe des Feindes nicht geändert wird.  Da wir jedem Feind eine zufällige Skala geben, müssen wir diese bei der Änderung der Reichweite berücksichtigen.  Dazu müssen wir uns die von <code>Enemy</code> vorgegebene Skala merken und sie mit der Getter-Eigenschaft öffnen. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Scale { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathOffset</span></span></span><span class="hljs-function">)</span></span> { Scale = scale; … }</code> </pre> <br>  Jetzt können wir den korrekten Bereich in <code>Tower.TrackTarget</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Vector3.Distance(a, b) &gt; targetingRange + <span class="hljs-number"><span class="hljs-number">0.125f</span></span> * target.Enemy€.Scale) { … }</code> </pre> <br><h3>  Wir synchronisieren die Physik </h3><br>  Alles scheint gut zu funktionieren, aber Türme, die auf die Mitte des Feldes zielen können, können Ziele erfassen, die außerhalb der Reichweite liegen sollten.  Sie können diese Ziele nicht verfolgen, daher sind sie nur für einen Frame darauf festgelegt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e91/0a1/836/e910a1836ef729d95ebee121a67c3f2c.png" width="230" height="230"></div><br>  <i>Falsches Zielen.</i> <br><br>  Dies geschieht, weil der Status der physischen Engine nicht perfekt mit dem Status des Spiels synchronisiert ist.  Instanzen aller Feinde entstehen am Ursprung der Welt, der mit dem Mittelpunkt des Feldes zusammenfällt.  Dann bewegen wir sie zum Punkt der Schöpfung, aber die Physik-Engine weiß nicht sofort davon. <br><br>  Sie können die sofortige Synchronisierung aktivieren, die beim Ändern von Objekttransformationen auftritt, indem Sie <code>Physics.autoSyncTransforms</code> auf <code>true</code> .  Standardmäßig ist es jedoch deaktiviert, da es viel effizienter ist, alles miteinander und bei Bedarf zu synchronisieren.  In unserem Fall ist eine Synchronisierung nur erforderlich, wenn der Status der Türme aktualisiert wird.  Wir können es ausführen, indem <code>Physics.SyncTransforms</code> zwischen Feind- und <code>Game.Update</code> in <code>Game.Update</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … enemies.GameUpdate(); Physics.SyncTransforms(); board.GameUpdate(); }</code> </pre> <br><h3>  Ignoriere die Höhe </h3><br>  Tatsächlich findet unser Gameplay in 2D statt.  Ändern wir daher den <code>Tower</code> so, dass beim Zielen und Verfolgen nur die X- und Z-Koordinaten berücksichtigt werden. Die physische Engine arbeitet im 3D-Raum, aber im Wesentlichen können wir <code>AcquireTarget</code> in 2D ausführen: <code>AcquireTarget</code> die Kugel so, dass sie alle Kollider unabhängig davon abdeckt von ihrer vertikalen Position.  Dies kann durch Verwendung einer Kapsel anstelle einer Kugel erfolgen, deren zweiter Punkt mehrere Einheiten über dem Boden liegt (z. B. drei). <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a = transform.localPosition; Vector3 b = a; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> += <span class="hljs-number"><span class="hljs-number">3f</span></span>; Collider[] targets = Physics.OverlapCapsule( a, b, targetingRange, enemyLayerMask ); … }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ist es nicht möglich, eine physische 2D-Engine zu verwenden?</font></font></b> <div class="spoiler_text">   ,       XZ,   2D-    XY.     ,     ,    2D-   .     3D-. </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist auch notwendig zu ändern </font></font><code>TrackTarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Natürlich können wir 2D-Vektoren verwenden und </font></font><code>Vector2.Distance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber lassen Sie uns die Berechnungen selbst durchführen und stattdessen die Quadrate der Entfernungen vergleichen, wird dies ausreichen. </font><font style="vertical-align: inherit;">Wir müssen also nicht mehr die Quadratwurzel berechnen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } Vector3 a = transform.localPosition; Vector3 b = target.Position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = ax - bx; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> z = az - bz; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> r = targetingRange + <span class="hljs-number"><span class="hljs-number">0.125f</span></span> * target.Enemy€.Scale; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x * x + z * z &gt; r * r) { target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie funktionieren diese mathematischen Berechnungen?</font></font></b> <div class="spoiler_text">     2D-   ,     .     ,       .  ,        ,    . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Speicherzuordnung vermeiden </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Nachteil der Verwendung </font></font><code>Physics.OverlapCapsule</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">besteht darin, dass für jeden Aufruf ein neues Array zugewiesen wird. </font><font style="vertical-align: inherit;">Dies kann vermieden werden, indem das Array einmal zugewiesen und eine alternative Methode </font></font><code>OverlapCapsuleNonAlloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit dem Array als zusätzlichem Argument aufgerufen wird. </font><font style="vertical-align: inherit;">Die Länge des übertragenen Arrays bestimmt die Anzahl der Ergebnisse. </font><font style="vertical-align: inherit;">Alle potenziellen Ziele außerhalb des Arrays werden verworfen. </font><font style="vertical-align: inherit;">Trotzdem verwenden wir nur das erste Element, daher reicht uns ein Array mit der Länge 1 aus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anstelle eines Arrays wird </font></font><code>OverlapCapsuleNonAlloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Anzahl der aufgetretenen Kollisionen bis zum maximal zulässigen Wert zurückgegeben. Dies ist die Anzahl, die wir anstelle der Länge des Arrays überprüfen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Collider[] targetsBuffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Collider[<span class="hljs-number"><span class="hljs-number">1</span></span>]; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a = transform.localPosition; Vector3 b = a; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> += <span class="hljs-number"><span class="hljs-number">2f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hits = Physics.OverlapCapsuleNonAlloc( a, b, targetingRange, targetsBuffer, enemyLayerMask ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hits &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { target = targetsBuffer[<span class="hljs-number"><span class="hljs-number">0</span></span>].GetComponent&lt;TargetPoint&gt;(); Debug.Assert(target != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Targeted non-enemy!"</span></span>, targetsBuffer[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir schießen auf Feinde </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt, da wir ein echtes Ziel haben, ist es Zeit, es zu schießen. </font><font style="vertical-align: inherit;">Das Schießen umfasst das Zielen, einen Laserschuss und das Verursachen von Schaden.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Revolver zielen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um den Turm zum Ziel zu lenken, muss die Klasse </font></font><code>Tower</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine Verbindung zur </font></font><code>Transform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Turmkomponente haben. </font><font style="vertical-align: inherit;">Fügen Sie dazu ein Konfigurationsfeld hinzu und verbinden Sie es mit dem Tower-Fertighaus.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] Transform turret = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0f/3be/41b/e0f3be41b0936993268316b8f01e1f67.png" width="320" height="90"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der angebrachte Turm. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn </font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es ein echtes Ziel gibt, müssen wir es abschießen. </font><font style="vertical-align: inherit;">Geben Sie den Aufnahmecode in eine separate Methode ein. </font><font style="vertical-align: inherit;">Lassen Sie ihn den Turm in Richtung des Ziels drehen und seine Methode </font></font><code>Transform.LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit dem Zielpunkt als Argument </font><font style="vertical-align: inherit;">aufrufen </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TrackTarget() || AcquireTarget()) { <span class="hljs-comment"><span class="hljs-comment">//Debug.Log("Locked on target!"); Shoot(); } } void Shoot () { Vector3 point = target.Position; turret.LookAt(point); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00e/5bb/e9d/00e5bbe9d98e739800bf47435ca574af.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nur zielen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir schießen einen Laser </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um den Laserstrahl zu positionieren, benötigt die Klasse </font></font><code>Tower</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auch eine Verknüpfung dazu.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] Transform turret = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, laserBeam = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/802/c9c/86e/802c9c86eac24112cb2b4f072fd0f410.png" width="320" height="110"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben einen Laserstrahl angeschlossen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um einen Würfel in einen echten Laserstrahl zu verwandeln, müssen Sie drei Schritte ausführen. </font><font style="vertical-align: inherit;">Erstens sollte seine Ausrichtung der Ausrichtung des Turmes entsprechen. </font><font style="vertical-align: inherit;">Dies kann durch Kopieren der Drehung erfolgen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Shoot</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 point = target.Position; turret.LookAt(point); laserBeam.localRotation = turret.localRotation; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zweitens skalieren wir den Laserstrahl so, dass seine Länge dem Abstand zwischen dem lokalen Ursprungspunkt des Turmes und dem Zielpunkt entspricht. </font><font style="vertical-align: inherit;">Wir skalieren es entlang der Z-Achse, dh der lokalen Achse, die auf das Ziel gerichtet ist. </font><font style="vertical-align: inherit;">Um die ursprüngliche XY-Skala beizubehalten, schreiben wir die ursprüngliche Skala auf, wenn wir den Awake-Turm aufwecken.</font></font><br><br><pre> <code class="cs hljs"> Vector3 laserBeamScale; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { laserBeamScale = laserBeam.localScale; } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Shoot</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 point = target.Position; turret.LookAt(point); laserBeam.localRotation = turret.localRotation; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d = Vector3.Distance(turret.position, point); laserBeamScale.z = d; laserBeam.localScale = laserBeamScale; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Drittens platzieren wir den Laserstrahl in der Mitte zwischen dem Turm und dem Zielpunkt. </font></font><br><br><pre> <code class="cs hljs"> laserBeam.localScale = laserBeamScale; laserBeam.localPosition = turret.localPosition + <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * d * laserBeam.forward;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/288/d96/438/288d96438354bd732fd7a3bb84ead491.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Laserschießen.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ist es nicht möglich, einen Laserstrahl zum Kind eines Turmes zu machen?</font></font></b> <div class="spoiler_text">     ,         ,       forward.       ,     .     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies funktioniert, während der Turm am Ziel befestigt ist. </font><font style="vertical-align: inherit;">Wenn jedoch kein Ziel vorhanden ist, bleibt der Laser aktiv. </font><font style="vertical-align: inherit;">Wir können die Laseranzeige ausschalten, indem wir ihre Skala auf </font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 setzen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TrackTarget() || AcquireTarget()) { Shoot(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { laserBeam.localScale = Vector3.zero; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39b/8c8/c23/39b8c8c239e0936137c646f91a4197de.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leerlauftürme feuern nicht.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Feindliche Gesundheit </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher berühren unsere Laserstrahlen nur die Feinde und beeinflussen sie nicht mehr. </font><font style="vertical-align: inherit;">Es muss sichergestellt werden, dass der Laser Feinden Schaden zufügt. </font><font style="vertical-align: inherit;">Wir wollen Feinde nicht sofort zerstören, also geben wir die </font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eigenschaft der Gesundheit. </font><font style="vertical-align: inherit;">Sie können einen beliebigen Wert als Gesundheit auswählen, nehmen wir also 100. Für große Feinde ist es jedoch logischer, mehr Gesundheit zu haben. Daher führen wir hierfür einen Koeffizienten ein.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Health { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathOffset</span></span></span><span class="hljs-function">)</span></span> { … Health = <span class="hljs-number"><span class="hljs-number">100f</span></span> * scale; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie eine öffentliche Methode hinzu </font></font><code>ApplyDamage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die den Parameter von der Gesundheit abzieht, </font><font style="vertical-align: inherit;">um Unterstützung für das Verursachen von Schaden hinzuzufügen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir gehen davon aus, dass der Schaden nicht negativ ist, und fügen daher eine Erklärung dazu hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ApplyDamage</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> damage</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(damage &gt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-string"><span class="hljs-string">"Negative damage applied."</span></span>); Health -= damage; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden den Feind nicht sofort loswerden, sobald seine Gesundheit Null erreicht. </font><font style="vertical-align: inherit;">Zu Beginn wird geprüft, ob die Gesundheit erschöpft ist und der Feind zerstört ist </font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Health &lt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>) { OriginFactory.Reclaim(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dank dessen schießen alle Türme im Wesentlichen gleichzeitig und nicht nacheinander, wodurch sie zu anderen Zielen wechseln können, wenn der vorherige Turm den Feind zerstört hat, auf den sie auch abgezielt haben. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schaden pro Sekunde </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt müssen wir bestimmen, wie viel Schaden der Laser anrichten wird. </font><font style="vertical-align: inherit;">Fügen Sie dazu </font></font><code>Tower</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">das Konfigurationsfeld hinzu. </font><font style="vertical-align: inherit;">Da der Laserstrahl kontinuierlichen Schaden verursacht, werden wir ihn als Schaden pro Sekunde ausdrücken. </font><font style="vertical-align: inherit;">Wir </font></font><code>Shoot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenden es auf die </font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zielkomponente mit Multiplikation mit der Deltazeit an.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(1f, 100f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> damagePerSecond = <span class="hljs-number"><span class="hljs-number">10f</span></span>; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Shoot</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … target.Enemy.ApplyDamage(damagePerSecond * Time.deltaTime); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/886/18f/199/88618f199c9c08e7eaeb89b16083f545.png" width="320" height="128" alt="Inspektor"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gk/vt/sf/gkvtsfa1ya4igbsjagqhtnzu0wq.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Schaden jedes Turms beträgt 20 Einheiten pro Sekunde.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zufälliges Zielen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir immer das erste verfügbare Ziel auswählen, hängt das Zielverhalten von der Reihenfolge ab, in der die Physik-Engine sich überschneidende Kollider überprüft. Diese Abhängigkeit ist nicht sehr gut, da wir die Details nicht kennen und sie nicht kontrollieren können. Außerdem wird sie seltsam und inkonsistent aussehen. Oft führt dieses Verhalten zu konzentriertem Feuer, aber dies ist nicht immer der Fall. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anstatt sich ausschließlich auf die Physik-Engine zu verlassen, fügen wir etwas Zufälligkeit hinzu. Dies kann erreicht werden, indem die Anzahl der von Kollidern empfangenen Kreuzungen beispielsweise auf 100 erhöht wird. Möglicherweise reicht dies nicht aus, um alle möglichen Ziele in einem dicht mit Feinden gefüllten Feld zu erreichen, aber dies reicht aus, um das Zielen zu verbessern.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Collider[] targetsBuffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Collider[<span class="hljs-number"><span class="hljs-number">100</span></span>];</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anstatt das erste potenzielle Ziel auszuwählen, wählen wir jetzt ein zufälliges Element aus dem Array aus. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hits &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { target = targetsBuffer[Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, hits)].GetComponent&lt;TargetPoint&gt;(); … } target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nv/lt/hi/nvlthij_ixh6lsxgwujtoipjwg4.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zufälliges Zielen.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Können andere Kriterien für die Auswahl der Ziele verwendet werden?</font></font></b> <div class="spoiler_text"> , ,        .  ,      ,     .    .             . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In unserem Tower Defense-Spiel sind also endlich Türme aufgetaucht. </font><font style="vertical-align: inherit;">Im nächsten Teil wird das Spiel noch mehr seine endgültige Form annehmen.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459070/">https://habr.com/ru/post/de459070/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459052/index.html">Wie man vergleicht: "tolles Auto" und "hässliche Hütte", in einer Marketingumfrage und in Big Data</a></li>
<li><a href="../de459054/index.html">Heatmap von Klicks - wie sich Benutzer auf der Website verhalten</a></li>
<li><a href="../de459062/index.html">Die Zusammenfassung interessanter Materialien für den mobilen Entwickler # 305 (vom 1. bis 7. Juli)</a></li>
<li><a href="../de459066/index.html">Datenbank-Schreib- und Leseausgleich</a></li>
<li><a href="../de459068/index.html">Windows Server 2008 R2 - Der König ist tot, es lebe der König</a></li>
<li><a href="../de459074/index.html">Kleine Freude # 7: Drei zum Preis von One-Console-Animation, Algorithmen und Debugging</a></li>
<li><a href="../de459078/index.html">CERN wechselt zu Open Source Software - warum?</a></li>
<li><a href="../de459080/index.html">Features HttpUrlConnection von java.net</a></li>
<li><a href="../de459082/index.html">Wer sind Eidetiker, wie falsche Erinnerungen funktionieren und drei populäre Mythen über das Gedächtnis</a></li>
<li><a href="../de459084/index.html">Ein wenig über Google Home Hub oder wie ich einen Fotorahmen für 130 Euro gekauft habe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>