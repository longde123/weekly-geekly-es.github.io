<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚óºÔ∏è üà≥ ‚úäüèª So rendern Sie den Rahmen von Mittelerde: Schatten von Mordor üíë üë®üèø‚Äçüç≥ üôé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mittelerde: Shadow of Mordor wurde 2014 ins Leben gerufen. Das Spiel selbst war eine gro√üe √úberraschung, und die Tatsache, dass es ein Spin-off der Ha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So rendern Sie den Rahmen von Mittelerde: Schatten von Mordor</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430518/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ow/br/se/owbrsedfx4zll9o8sxbxx2fbnza.gif"></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Mittelerde: Shadow of Mordor</a> wurde 2014 ins Leben gerufen.  Das Spiel selbst war eine gro√üe √úberraschung, und die Tatsache, dass es ein Spin-off der Handlung des Universums Lord of the Ring war, war ziemlich unerwartet.  Das Spiel war sehr erfolgreich und zum Zeitpunkt des Schreibens hat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Monolith</a> bereits eine Fortsetzung ver√∂ffentlicht - Shadow of War.  Die Grafiken des Spiels sind sehr sch√∂n, besonders wenn man bedenkt, dass es f√ºr verschiedene Konsolengenerationen ver√∂ffentlicht wurde, einschlie√ülich der Xbox 360 und PS3.  Die PC-Version ist ziemlich gut poliert, enth√§lt zus√§tzliche Grafikoptionen und hochaufl√∂sende Texturpakete, die das Potenzial des Spiels voll aussch√∂pfen. <br><br>  Das Spiel verwendet den relativ neuen DX11-Renderer.  Ich habe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Renderdoc verwendet</a> , um die Rendering-Techniken des Spiels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gr√ºndlich</a> zu lernen.  Bei der Arbeit wurden die maximal m√∂glichen Grafikparameter (Ultra) verwendet und alle m√∂glichen ‚ÄûLotionen‚Äú einbezogen, z. B. Transparenz unabh√§ngig von Reihenfolge, Tessellation, Okklusion im Bildschirmbereich und verschiedene Bewegungsunsch√§rfen. <br><a name="habracut"></a><br><h2>  Rahmen </h2><br>  Hier ist ein Rahmen, den wir analysieren werden.  Der Spieler befindet sich auf einer Holzplattform in der Region Udun.  Shadow of Mordor verwendet eine √§hnliche Mechanik wie Spiele wie Assassin's Creed, bei der Sie Geb√§ude und T√ºrme besteigen und dann die umgebende digitale Landschaft von den D√§chern aus genie√üen k√∂nnen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73d/325/3e0/73d3253e0323327f95babf989f060f93.jpg" alt="Bild"></div><br><h2>  Tiefenpassage </h2><br>  Die ungef√§hr 140 ersten Renderaufrufe f√ºhren einen kurzen vorl√§ufigen Durchgang durch, um die gr√∂√üten H√∂henelemente und Geb√§ude in den Tiefenpuffer zu rendern.  Die meisten Objekte fallen nicht in diesen vorl√§ufigen Durchgang, aber es hilft, wenn das Spiel eine sehr gro√üe Anzahl von Draw Calls hat und Sie weit in die Ferne schauen k√∂nnen.  Interessanterweise f√§llt ein Charakter, der sich immer in der Mitte des Bildschirms befindet und einen anst√§ndigen Teil des Bildschirmraums einnimmt, nicht in diese Passage.  Wie in vielen anderen Open-World-Spielen verwendet die Engine die inversen z-Werte.  Diese Technik bindet die nahe Ebene an 1,0 und die ferne Ebene an 0,0, um die Genauigkeit bei gro√üen Entfernungen zu erh√∂hen und Z-Konflikte zu verhindern.  Lesen Sie hier mehr √ºber die Genauigkeit von Z-Puffern. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/181/ba6/57d/181ba657ddc430ee3a892e852cc276e9.png" alt="Bild"></div><br><h4>  G-Puffer </h4><br>  Unmittelbar danach beginnt der G-Puffer-Durchlauf, der in ungef√§hr 2700 Draw-Aufrufen ausgef√ºhrt wird.  Wenn Sie meine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherige Analyse von Castlevania: Lords of Shadow 2</a> gelesen oder andere √§hnliche Artikel studiert haben, sollte Ihnen diese Passage bekannt sein.  Die Eigenschaft der Oberfl√§chen wird in einer Reihe von Puffern aufgezeichnet, die dann in den Durchg√§ngen der Beleuchtungsberechnung gelesen werden, um die Reaktionen der Oberfl√§chen auf Licht zu berechnen.  Shadow of Mordor verwendet einen klassischen verz√∂gerten Renderer, aber eine relativ kleine Anzahl von Renderzielen des G-Puffers wird verwendet, um dieses Ziel zu erreichen (3).  Zum Vergleich: Unreal Engine in dieser Passage verwendet 5-6 Puffer.  G-Puffer hat das folgende Schema: <br><br><h5>  Normaler Puffer </h5><br><table><tbody><tr><td>  <strong><font color="#ff0000">R.</font></strong> </td><td>  <strong><font color="#00ff00">G.</font></strong> </td><td>  <strong><font color="#0000ff">B.</font></strong> </td><td>  <strong>A.</strong> </td></tr><tr><td>  <strong>Normal.x</strong> </td><td>  <strong>Normal.y</strong> </td><td>  <strong>Normal.z</strong> </td><td>  <strong>ID</strong> </td></tr></tbody></table><br>  Der Normalenpuffer speichert Normalen im Weltraum im Format ‚Äû8 Bit pro Kanal‚Äú.  Dies reicht kaum und manchmal gar nicht aus, um glatt variierende flache Oberfl√§chen zu beschreiben.  Wenn Sie genau hinschauen, kann dies in einigen Pf√ºtzen im Spiel gesehen werden.  Der Alphakanal wird als ID verwendet, die verschiedene Objekttypen kennzeichnet.  Zum Beispiel fand ich heraus, dass 255 sich auf das Zeichen bezieht, 128 auf den animierten Teil der Flagge, und der Himmel mit der ID 1 markiert ist, da diese Kennungen sp√§ter verwendet werden, um ihn beim Hinzuf√ºgen zu filtern (der Himmel erh√§lt seine eigene radiale Bl√ºte). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/za/jf/y8/zajfy84cg-abqarjiybgm3qcztw.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9k/aq/4v/9kaq4vempyj-n14_kdfte3d51ss.png"></div><br>  <i>Im Originalartikel sind diese und viele andere Bilder zur besseren √úbersicht animiert, daher empfehle ich, dort nachzuschauen.</i> <br><br><h5>  Puffer Albedo </h5><br><table><tbody><tr><td>  <strong><font color="#ff0000">R.</font></strong> </td><td>  <strong><font color="#00ff00">G.</font></strong> </td><td>  <strong><font color="#0000ff">B.</font></strong> </td><td>  <strong>A.</strong> </td></tr><tr><td>  <strong>Albedo.r</strong> </td><td>  <strong>Albedo.g</strong> </td><td>  <strong>Albedo.b</strong> </td><td>  <b>Hohlraumverschluss</b> </td></tr></tbody></table><br>  Der Albedopuffer speichert alle drei Komponenten der Albedo und eine kleine Okklusion (manchmal auch als Hohlraumokklusion bezeichnet), mit der kleine Details schattiert werden, die mit einer Schattenkarte oder einer Nachbearbeitung im Bildschirmbereich nicht erreicht werden k√∂nnen.  Es wird haupts√§chlich zu dekorativen Zwecken verwendet, zum Beispiel f√ºr L√∂cher und Falten an der Kleidung, kleine Risse in einem Baum, kleine Muster an der Kleidung von Talion usw. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/t6/ul/bz/t6ulbzqtlw3ncodrlnd49uxtmwa.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/28/52/lr/2852lrdq75bxtqpkywvutfsm4se.png"></div><br>  Bei der Verarbeitung von Feinden im Shader ber√ºcksichtigt die Albedo die Textur des Blutes (interessanterweise bekommt Talion niemals sichtbare Wunden).  Die Bluttextur ist die Eingabe f√ºr die Rendering-Phase der Kleidung und des K√∂rpers der Feinde, gibt jedoch nicht die Farbe des Blutes an, die die Eingabe im konstanten Puffer ist, sondern bestimmt die Faktoren / Blutspiegel, um die angezeigte Blutmenge zu steuern.  Au√üerdem wird die normale Ausrichtung verwendet, um den Effekt zu skalieren, sodass Sie die Richtung der Blutspritzer steuern k√∂nnen.  Dann schattiert die Albedo im Wesentlichen mit der Helligkeit der Wunden, die der Feind von der entsprechenden Stelle auf der Blutkarte erhalten hat, und modifiziert auch andere Eigenschaften, wie z. B. Spiegel, um einen √ºberzeugenden Bluteffekt zu erzielen.  Ich konnte den Teil des Rahmens, in dem die Karte gerendert wird, nicht finden, aber ich gehe davon aus, dass sie direkt am Anfang des Rahmens aufgezeichnet werden, wenn das Schwert freigelegt ist, und dann hier verwendet werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1y/_r/rt/1y_rrtgi8bsuryvjmqmpdvzwpfk.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mi/tv/nu/mitvnumojb0zx4qhzohrgrj810e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qp/wx/t7/qpwxt7y4r-k3ugakdasysx1vtvm.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6d/-r/lz/6d-rlzgi7fvdep6xrxnakmjp9yg.png"></div><br><h5>  Spiegelpuffer </h5><br><table><tbody><tr><td>  <strong><font color="#ff0000">R.</font></strong> </td><td>  <strong><font color="#00ff00">G.</font></strong> </td><td>  <strong><font color="#0000ff">B.</font></strong> </td><td>  <strong>A.</strong> </td></tr><tr><td>  <b>Rauheit</b> </td><td>  <b>Spiegelintensit√§t</b> </td><td>  <b>Fresnel</b> </td><td>  <b>Streufaktor unter der Oberfl√§che</b> </td></tr></tbody></table><br>  Der Spiegelpuffer enth√§lt andere Oberfl√§cheneigenschaften, die in Spielen zu erwarten sind, wie z. B. die Rauheit (dies ist nicht ganz die Rauheit, sondern ein skalierter Spiegelgrad, der jedoch auf diese Weise interpretiert werden kann), die Spiegelintensit√§t (die Helligkeit der Spiegelreflexion), die skaliert Albedo, um den richtigen Farbspiegel, den Reflektivit√§tsfaktor (in der Literatur allgemein als F0 bezeichnet, weil er die Eingabe f√ºr die Fresnel-Spiegelantwort ist) und die Komponente der Streuung unter der Oberfl√§che (Streuung unter der Oberfl√§che) zu erhalten.  Die letztere Komponente wird verwendet, um durchscheinende Materialien wie d√ºnnes Gewebe, Pflanzen und Haut zu beleuchten.  Wenn wir sp√§ter in das Studium des Licht-Shaders eintauchen, stellen wir fest, dass wir hier die Variation des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">normalisierten Spiegelmodells nach Blinn-Fong verwenden</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qx/rv/8c/qxrv8c9xk-4-akibiogsgnvxszw.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wv/xw/_f/wvxw_f6h-5vgmu6cvlucuum3sei.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fb/f3/v1/fbf3v1y8ardyfkjtshlv8zf5ld8.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ql/zq/lz/qlzqlzbbxwy_mlx05pwxwpxmrga.png"></div><br><h5>  Aufgeschobene Abziehbilder </h5><br>  Wie wir oben gesehen haben, zeigt Shadow of Mordor ziemlich detaillierte Blutspuren an verwundeten Charakteren.  Wenn Talion sein Schwert schwenkt, erh√§lt die Umgebung auch ihren Anteil an dunklem Orkblut.  F√ºr Umgebungen wird jedoch eine andere Technik verwendet - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verz√∂gerte Abziehbilder</a> .  Diese Technik besteht darin, einen Satz flacher Texturen auf die Oberfl√§che des zuvor gerenderten zu projizieren.  Auf diese Weise wird der Inhalt des G-Puffers vor dem Durchf√ºhren des Beleuchtungsdurchlaufs durch diesen neuen Inhalt ersetzt.  Im Falle von Blut reicht nur blutiger Spr√ºhnebel aus, und wenn viele Abziehbilder nacheinander gerendert werden, entsteht schnell eine ziemlich d√ºstere Landschaft. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8_/zo/no/8_zonoux0rx6h_cemftpprebcke.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pk/sc/qn/pkscqng3m2s0c2hj-e-fs1eonis.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/a4/uf/rs/a4ufrsgki8blucgm4g8zq3n95ha.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dj/jl/3c/djjl3c5s2dsimxwtoim-c5vk3rg.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wj/hj/cb/wjhjcbcfdu0ts1kpnmh_2_tvhdq.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8r/tk/fi/8rtkfinzlyym0jweyx0gpizv4zs.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uh/ns/pw/uhnspwmomqsrlnoctsokx8q878a.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/di/7m/70/di7m700h63pqtmaiydgrezyt0w4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8t/ky/sz/8tkyszkhinic56jqebsteeudram.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0a/tu/kj/0atukjo4vjzv3djehm6sttjhqps.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-5/vm/ja/-5vmjatrsxyfdjhqm5nhsmu_vxw.png"></div><br>  Das Letzte, was in der G-Puffer-Passage gerendert wird, ist der Himmel. Die Himmelstextur hat eine sehr hohe Aufl√∂sung (8192 √ó 2048) im HDR BC6H-Format.  Ich musste eine kleine Tonkorrektur durchf√ºhren, da in HDR alle Farben zu dunkel sind. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95a/6b2/dda/95a6b2dda3a632aebe8fc902f143232d.jpg" alt="Bild"></div><br><h3>  Tessellation </h3><br>  Ein sehr interessantes ‚ÄûFeature‚Äú des Spiels (wenn es aktiviert ist) ist die Tessellation.  Es wird f√ºr viele verschiedene Dinge verwendet, vom Gel√§nde bis zur Charakterwiedergabe (sowie f√ºr Requisiten und Charakterobjekte).  Hier unterteilt die Tessellation das niedrige Polynetz nicht, sondern erzeugt Polygone aus einer Punktwolke unter Verwendung des erforderlichen Unterteilungsgrades, abh√§ngig von den Kriterien f√ºr den Detaillierungsgrad, beispielsweise von der Entfernung zur Kamera.  Ein interessantes Beispiel ist der Talion-Umhang, der als Punktwolke (nach der Physiksimulation) an die GPU √ºbertragen wird, und der Tessellations-Shader erstellt die Polygone neu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1i/jf/3i/1ijf3ikncscrhyvhjyyan6kdx80.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wj/fp/il/wjfpil_rw7_t1z7pxrfntobcrse.png"></div><br><h3>  Auftragsunabh√§ngige Transparenz </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b78/f09/897/b78f09897b7ed45f990f51f91291c967.png"></div><br>  Eines der ersten Dinge, die mich an seiner Seltsamkeit beeindruckt haben, ist der Haarbehandlungspass, da er einen sehr komplexen speziellen Shader ausf√ºhrt.  In den Grafikoptionen wird die Option OIT (Order-Independent Transparency) f√ºr Haare erw√§hnt, das hei√üt, es sollte so sein.  Zun√§chst wird die Ausgabe in einen separaten Puffer ausgef√ºhrt und die Gesamtzahl der √ºberlagerten transparenten Pixel berechnet, w√§hrend Eigenschaften in einer ‚Äûtiefen‚Äú Struktur √§hnlich einem G-Puffer gespeichert werden.  Sp√§ter sortiert ein anderer Shader einzelne Fragmente nach ihrer Tiefe.  Es scheint, dass die Pfeile auch auf diese Weise gerendert werden (wahrscheinlich erfordert ihr Gefieder eine ordnungsgem√§√üe Sortierung).  Dies ist ein sehr subtiler Effekt, der keine besonderen grafischen Unterschiede hinzuf√ºgt, aber dennoch ein interessantes Detail darstellt.  Hier ein einfaches Beispiel: Das Bild oben zeigt die Anzahl der √ºberlappenden Fragmente (je roter, desto mehr Fragmente).  Regelm√§√üige Transparenz wird weiterhin von der CPU sortiert und als traditionelles Alpha gerendert.  Nur einzelne Entit√§ten fallen in den OIT-Pass. <br><br><h3>  Schatten von Mordor </h3><br>  SoM hat viele Schattenquellen.  Zus√§tzlich zu herk√∂mmlichen Schattenkarten dynamischer Lichtquellen verwendet SoM eine zweikanalige Umgebungsokklusion im Bildschirmbereich, eine f√ºr fast alle Objekte im Spiel erstellte Okklusion im Mikroma√üstab und eine Okklusionstextur √§hnlich einer H√∂henkarte mit Draufsicht. <br><br><h5>  Okklusion im Bildschirmbereich </h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2cb/58c/fc5/2cb58cfc57777d65a15af4813977c962.png"></div><br>  Der erste Durchgang wird unter Verwendung des Umgebungs-G-Puffers und der Spiegelokklusion im Bildschirmbereich gerendert.  Der Shader selbst ist ein riesiger entfalteter Zyklus, der sowohl eine Tiefenkarte in voller Gr√∂√üe als auch eine zuvor reduzierte durchschnittliche Tiefenkarte abtastet und nach benachbarten Abtastwerten in einem bestimmten Muster sucht.  Es verwendet eine 4x4-Quadrat-Textur, um Pseudozufallsvektoren auf der Suche nach Okklusionsquellen auszuw√§hlen.  Es wird ein verrauschter Okklusionspuffer gerendert, der dann durch eine einfache Unsch√§rfe in zwei Durchg√§ngen gegl√§ttet wird.  Das interessanteste Merkmal hierbei ist, dass es zwei verschiedene Okklusionskan√§le gibt: Einer von ihnen wird als Spiegelokklusion und der andere als diffuse Okklusion verwendet.  In Standard-SSAO-Implementierungen wird ein Kanal berechnet, der f√ºr alle gebackenen Beleuchtungen gilt.  Hier wird die SSAO-Karte auch zur √úbertragung an den gerichteten Beleuchtungskanal gelesen, wo sie verwendet wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/re/xf/kj/rexfkjx49htyufzecfeg2n7lsau.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dl/va/nz/dlvanzzg8bpcqughsrout8kaxlg.png"></div><br><h5>  Schattenkarten </h5><br>  Das n√§chste Ereignis ist das Rendern der Schattenkarte.  Da die Aktion des Spiels haupts√§chlich in offenen R√§umen stattfindet, werden der gr√∂√üte Teil des Lichts und der Schatten vom Hauptrichtungslicht aufgenommen.  Hier verwenden wir die Technik der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kaskadierung von Schattenkarten</a> (eine Variation davon sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=http://">parallel geteilte Schattenkarten</a> ), eine ziemlich √ºbliche Technik zum Anwenden von Schatten √ºber gro√üe Entfernungen, die darin besteht, dieselbe Szene aus einem Blickwinkel der Lichtquelle f√ºr verschiedene Bereiche des Raums zu rendern.  Normalerweise befinden sich Schattenkarten, die weit vom Abdeckungsbereich der Kamera entfernt sind, entweder in gro√üen Entfernungen oder haben eine niedrigere Aufl√∂sung als die vorherigen. Dadurch wird die Aufl√∂sung in Bereichen, in denen Details noch nicht ben√∂tigt werden, wesentlich verringert, da die Geometrie zu weit entfernt ist.  In dieser Szene rendert das Spiel drei Schattenkaskaden 4096 √ó 4096 (tats√§chlich hat das Spiel einen Platz f√ºr vier).  Die obere Kaskade befindet sich ganz in der N√§he von Talion, und die untere Kaskade enth√§lt Berge und Objekte, die sehr weit von der Kamera entfernt sind.  Bei der Arbeit mit Schatten verwendet das Spiel den gleichen Trick mit der inversen z-Koordinate wie in der Tiefenkarte. \ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/347/7bc/a65/3477bca65b8cff92dfcfd68c9d66b8a8.jpg"></div><br><h5>  Schattenpuffer </h5><br>  Der n√§chste Schritt ist das Erstellen eines Schattenpuffers.  Dies ist eine einkanalige Textur, die auf Okklusionsinformationen aus fr√ºheren Schattenkarten basiert und einen Schattenfaktor im Intervall [0, 1] codiert.  Um eine Gl√§tte an den R√§ndern zu erzielen, wird die Schattenkarte viermal mit dem Status eines speziellen bilinearen Samplers abgetastet, der vier Samples empf√§ngt und diese mit einem bestimmten Wert vergleicht (dies wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=http://">Percentage Close Filtering bezeichnet</a> ).  Das Abrufen mehrerer Stichproben und das Mitteln ihrer Ergebnisse wird h√§ufig als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">prozentuale, engere weiche Schatten bezeichnet</a> .  Zus√§tzlich zum Lesen der Schattenkarte wird auch die letzte Komponente des Spiegelpuffers (dh der Streukoeffizient unter der Oberfl√§che) abgetastet, die mit dem ‚ÄûLichtblutungsfaktor‚Äú multipliziert wird.  Es scheint notwendig zu sein, um die Schatten dieser Objekte zu beseitigen, damit etwas mehr Licht durch sie hindurchgeht. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b7f/b55/63f/b7fb5563faae1553e0f970374ee0b774.jpg"></div><br><h5>  Richtungsprojektionstextur </h5><br>  Eine andere Licht- und Schattenquelle ist eine Draufsichttextur, die von einer gerichteten Lichtquelle abgetastet wird.  Dies ist der Farbstich, der der Farbe der gerichteten Lichtquelle hinzugef√ºgt wird, sowie der Effekt der globalen Schattierung, der f√ºr die gerichtete Beleuchtung gilt.  Es scheint, dass einige von ihnen manuell √ºber einer automatisch generierten ebenen Beleuchtungskarte mit einer Draufsicht erstellt wurden.  Es scheint, dass die Kanten der Schatten f√ºr die statische Geometrie manuell angepasst werden (m√∂glicherweise um Konflikte mit der realen Schattenkarte zu vermeiden), und einige Teile scheinen auch von Hand leicht get√∂nt zu sein.  Wahrscheinlich ist die Aufgabe dieser Textur die kosteng√ºnstige Hinzuf√ºgung von Simulationen der Umgebungsokklusion in gro√üem Ma√üstab und der globalen Beleuchtung mit Licht zus√§tzlich zur gerichteten Beleuchtung.  Die folgenden Bilder zeigen den Farbton, die Okklusion und das Produkt beider Faktoren, wodurch wir eine Vorstellung davon bekommen, wie die endg√ºltige Farbmaske aussieht. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6v/vf/6a/6vvf6aaf5khdrbclmwpzp9_faka.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7e/fs/fe/7efsferrjbdtsu9megpk0gtfidc.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sd/bk/sv/sdbksv3a4jlkgzxui4nvl-suylq.png"></div><br>  Das Ergebnis aller Beleuchtungsdurchl√§ufe wird im Renderziel des Formats R11G11B10F gespeichert.  So sieht das Ergebnis aus.  Ich habe eine tonale Korrektur der Ergebnisse durchgef√ºhrt, um den Effekt der gerichteten Beleuchtung auf der Ebene besser sichtbar zu machen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2a/28e/a63/f2a28ea6372642667b3778dfc32b193f.jpg"></div><br>  Alle entfernten Berge (im obigen Bild nicht dargestellt) werden ebenfalls durch gerichtetes Licht beleuchtet, sie werden jedoch als separater Fall hervorgehoben, damit die Beleuchtung besser gesteuert werden kann.  Einige sind skaliert, aber die weiter entfernten sind tats√§chlich Betr√ºger mit geschickt erstellten Normal- und Albedokarten.  Sie haben spezielle gerichtete Lichtquellen, die nur die Berge betreffen. <br><br><h3>  Statische Beleuchtung </h3><br>  Shadow of Mordor verwendet eine sehr speicherintensive Implementierung der statischen Beleuchtung, bei der sehr gro√üvolumige Texturen verwendet werden.  Das Bild unten zeigt drei statische Texturen f√ºr die Beleuchtungsst√§rke, mit der ein Teil dieses Bereichs diffus beleuchtet wird.  Jedes von ihnen ist eine riesige komprimierte Textur 512x512x128 BC6H, dh sie belegen 32 MB pro Textur oder 96 MB im Allgemeinen (wir spielen mit maximalen Qualit√§tseinstellungen).  Die Textur der Farbe gibt die Intensit√§t an, die in das Voxel eintritt.  Die anderen beiden geben die St√§rke oder Gr√∂√üe dieser Intensit√§t entlang aller sechs Richtungen xyz und -xyz an, und die Normalen werden verwendet, um drei Komponenten auszuw√§hlen (positive oder negative xyz, diejenigen, die am besten mit der Normalen √ºbereinstimmen).  Nachdem wir diesen Vektor erstellt haben, nehmen wir sein Vektorprodukt durch das Quadrat der Normalen, und dies wird zum Skalierungsfaktor f√ºr die Intensit√§t.  Die Formel lautet wie folgt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l9/yw/vk/l9ywvkgxuoti8bbppke_2c8o068.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ez/j3/uf/ezj3ufolhefyqxafjqskci0msho.png"></div><br>  Statische Lichtvolumina rendern auch eine kubische Karte f√ºr spiegelnde Beleuchtung, die wahrscheinlich in der Mitte des SLV erfasst wird.  Interessanterweise speichern Volumentexturen HDR-Werte, die in BC6H komprimiert sind, und kubische Karten werden im BC3-Format (DXT5) gespeichert, in dem keine Gleitkommawerte gespeichert werden k√∂nnen.  Um diese Einschr√§nkung auszugleichen, beh√§lt der Alphakanal die Helligkeit bei, die dann von 1 bis 10 skaliert.  Dies ist eine etwas seltsame Entscheidung, und f√ºr mich sieht es eher nach einer Legacy-Implementierung aus.  Vergessen Sie nicht, dass das Spiel f√ºr Konsolen der vorherigen Generation ver√∂ffentlicht wurde, die die neuen HDR-Texturformate nicht unterst√ºtzen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k3/qo/z-/k3qoz-zblorjdxi7jyqthripztg.png"></div><br>  Die folgenden Bilder zeigen die Ergebnisse ‚Äûvorher und nachher‚Äú unter Ber√ºcksichtigung der Auswirkungen des Durchschnittsbilds.  Zur Visualisierung habe ich eine Tonwertkorrektur durchgef√ºhrt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4i/iq/yo/4iiqyosjg2tmdud840rxbhstofa.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/su/of/cd/suofcd-ls4myfuivd5vqb9ykbgi.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/37/rq/wb/37rqwb76ngards_rywaxhb_x9xw.png"></div><br><h3>  Atmosph√§rischer Nebel </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9af/086/c47/9af086c474cada9250daae007ec3c8bc.jpg"></div><br>  Shadow of Mordor hat ein Wetter- und Zeitsystem, dank dessen die Sonne scheint oder Regen durch das Spiel in Mordor str√∂mt.  Dieses System wird durch die Summe der Komponenten gesteuert, und einer der wichtigsten ist Nebel.  Shadow of Mordor verwendet ein ziemlich einfaches, aber physikalisch einwandfreies Modell des atmosph√§rischen Nebels, einschlie√ülich der einzelnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rayleigh-</a> Streuung sowie der Streuung durch ein kugelf√∂rmiges Teilchen (Mie-Streuung). <br><br>  Zun√§chst wird die Position der Kamera relativ zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erdmittelpunkt</a> berechnet.  Verschiedene trigonometrische Formeln erm√∂glichen es zu bestimmen, wo sich die Kamera in der Atmosph√§re befindet, wo sich das Pixel befindet und welche Entfernung der Strahl in der Atmosph√§re bei einer bestimmten maximalen atmosph√§rischen H√∂he zur√ºcklegt.  In unserem Fall befindet sich die Atmosph√§re in einer H√∂he von 65.000 Metern √ºber der Oberfl√§che des Planeten.  Unter Ber√ºcksichtigung dieser Informationen werden Rayleigh- und sph√§rische Partikelkoeffizienten verwendet, um sowohl die Arten der Dichte der Nebelpartikel als auch ihre Farben zu berechnen.  Diese Dichten verdecken die bereits schattierten Pixel, streuen Licht, das von der schattierten Oberfl√§che in die Kamera eintritt, und tragen zum Nebel bei.  Bei der Simulation einer solchen Streuung werden Helligkeit und Richtung der Sonne ber√ºcksichtigt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ye/at/id/yeatidzdiemga1gntnm1zg9uz8k.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zj/39/zr/zj39zryuhmwdyadmcp0nb_g1uz8.png"></div><br><h3>  Verschlusszeit- und Tonkorrektur </h3><br>  Bei der Berechnung der Verschlusszeit wird ein ziemlich standardm√§√üiger Ansatz verwendet: Reduzieren der Aufl√∂sung des aus dem HDR-Hauptfarbpuffer berechneten Helligkeitspuffers nacheinander in eine Kette von Texturen, von denen jede halb so gro√ü wie die vorherige Textur ist, beginnend mit einer Textur 1/3 des Hauptbildpuffers.  Mit dieser Verringerung der Aufl√∂sung werden 4 Abtastwerte entnommen, wobei die Werte benachbarter Pixel gemittelt werden, dh nachdem alle Durchschnittswerte in ein einzelnes Texel umgewandelt wurden, wird das Endergebnis zur durchschnittlichen Helligkeit.  Nachdem die Textur die Gr√∂√üe von 16 √ó 9 Texeln erreicht hat, wird ein Compute Shader gestartet, der alle verbleibenden Texel zusammenfasst.  Dieser Wert wird sofort im Tonkorrekturdurchlauf gelesen, um die Helligkeitswerte zu √§ndern. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ig/bi/h4/igbih41dc2x9aytucfgq1z_iuye.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/os/gw/t8/osgwt8co0pqgvomovsydsemapuw.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qh/bc/qv/qhbcqvqxy5hgvtn9x0c9kd1an6e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/g-/dw/fm/g-dwfm48oqtvuu1bizc1sikm7sq.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zg/8w/oz/zg8wozwpviq0nnt4-kef9b9azis.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/56/ik/dc/56ikdcoixmrbo0whghswhxdzxhk.png"></div><br>  F√ºr die Tonkorrektur wird der Reinhardt-Operator verwendet, dessen optimierte Formel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> zu finden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ist</a> .  Im hlsl-Code sieht dies folgenderma√üen aus: <br><br><pre><code class="cpp hljs">float3 hdrColor = tex2D(HDRTexture, uv.xy); hdrColor *= exposureValue; <span class="hljs-comment"><span class="hljs-comment">// This was calculated by the compute shader in the luminance downsampling pass float3 x = max(0.0, hdrColor - 0.004); float3 finalColor = (x * (6.2 * x + 0.5)) / (x * (6.2 * x + 1.7) + 0.06);</span></span></code> </pre> <br>  Wenn wir diese Kurve zeichnen, werden wir sehen, dass dieser Operator 10% der Wei√üwerte auch bei einem Eingabewert von 2,0 verwirft und gleichzeitig einen kleinen Teil des unteren Intervalls zwangsweise vollst√§ndig schwarz l√§sst.  Dies erzeugt ein ents√§ttigtes, dunkles Bild. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc2/ea1/097/cc2ea10970239fb761b995496c049a8b.jpg" alt="Bild"></div><br><h3>  Alpha Stage </h3><br>  Der Alpha-Schritt ist etwas ungew√∂hnlich, da er Objekte direkt in den LDR-Puffer rendert.  Andere Spiele rendern sie ebenfalls im HDR-Puffer, damit sie am Verschluss teilnehmen k√∂nnen.  Wie dem auch sei, die zuvor berechnete Helligkeitstextur ist auf alle Alpha-beleuchteten Objekte beschr√§nkt (in einigen F√§llen wird beispielsweise bei lichtemittierenden Objekten die Verschlusszeit anhand der Shader-Konstanten und nicht anhand der Textur-Suche berechnet), und daher wird die Verschlusszeit beim Rendern automatisch angewendet nicht in der Nachbearbeitung durchgef√ºhrt.  Ein sehr spezieller Fall der Verwendung von Alpha in einem Spiel ist der √úbergang in den Geistermodus (darin wird der Geist von Celebrimbor √ºber dem Charakter des Spielers gerendert, der in den souver√§nen Ringen des LOTR-Universums geschmiedet ist. Das Spiel zeigt also, dass er immer in der N√§he ist, obwohl er unsichtbar ist).  Das Spiel √ºbergibt mehrere Parameter an die Maschen beider Charaktere, die die Deckkraft steuern und es dem Spiel erm√∂glichen, Talion teilweise zu verdecken und nach und nach Celebrimore zu zeigen.  Andere Objekte im Spiel im Geistermodus rendern ebenfalls Geisterversionen √ºber undurchsichtigen Objekten wie Feinden und T√ºrmen.  Hier ist eine weitere Szene mit dem √úbergang in die Geisterwelt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ux/ca/zs/uxcazsok9pqzuusfrb__dutdphw.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6g/1c/9e/6g1c9esdqit50db_mbck516ma-0.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/f_/dq/ss/f_dqss-avlzlyrb4s6_z6kqog0e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uw/yy/va/uwyyvakydfnsksy49ntfltpbwp8.png"></div><br><h3>  Regen </h3><br>  Im Hauptrahmen, den wir untersucht haben, gibt es keinen Regen, aber das Wetter ist ein so wichtiger Teil des Spiels, dass ich es hier erw√§hnen m√∂chte.  Es wird in der GPU generiert und simuliert und direkt am Ende der Alpha-Phase gerendert.  Es wird ein Compute-Shader ausgef√ºhrt, der die Simulation ausf√ºhrt und die Positionen in den Puffer schreibt.  Diese Positionen werden von einem anderen Shader eingenommen, der mit Hilfe eines instanziierten indirekten Anrufs so viele Quad-Instanzen rendert, wie die Positionen im vorherigen Durchgang berechnet wurden.  Der Vertex-Shader verf√ºgt √ºber ein einfaches Quad, das bei Bedarf verformt wird und sich in Richtung Kamera dreht.  Um zu verhindern, dass Regen in die Oberfl√§chen eindringt, liest der Vertex-Shader auch H√∂henkarten aus einer Draufsicht, sodass Sie alle Tropfen unter der √ºberlappenden Oberfl√§che zur√ºckweisen k√∂nnen.  Diese H√∂henkarte wird direkt am Anfang des Rahmens gerendert.  Der gleiche Vertex-Shader teilt dem Pixel-Shader mit, woher das Sample aus der Drop-Textur stammt.  Befindet sich der Tropfen nahe an der Oberfl√§che, wird ein Texturbereich ausgew√§hlt, der eine Begr√º√üungsanimation enth√§lt.  Dar√ºber hinaus f√ºhren Regentropfen Nebelberechnungen im Pixel-Shader durch, um sich nahtlos in den Rest der Szene einzuf√ºgen.  Hier ist ein Screenshot aus derselben Perspektive an einem regnerischen Tag. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xv/yv/ds/xvyvds_w25ybjxilgvr5crbcpo4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3c/ox/ax/3coxaxhejifprppkaheiahszfcm.png"></div><br>  Wenn der Regeneffekt aktiviert ist, wird der Spiegelpuffer global ge√§ndert, um nasse Oberfl√§chen zu erzeugen, und Regenwellen werden in den normalen Puffer gerendert.  Die Animation ist zeitgesteuert, sodass nur ein Frame der geloopten Animation verwendet wird.  Der unten gezeigte normale Puffer wird ge√§ndert, um in den Puffer gerenderte Wellen anzuzeigen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ur/du/mz/urdumzhuebf1o2pnud_b2ztlfik.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p3/cv/t_/p3cvt_qq7vo9txgwycf7l2oec2y.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vc/3d/u3/vc3du3ytthqfsw1h7vwzr0tfxom.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6y/tk/rk/6ytkrkj0w38kvccrtrjpey95c_w.png"></div><br><h3>  Linseneffekte und Bl√ºte </h3><br>  Nach Abschluss des Alpha-Renderings werden dar√ºber Linseneffekte gerendert.  Eine Reihe von verschobenen Quads wird ab dem Punkt gerendert, von dem das gerichtete Licht kommt (in unserem Fall die Sonne).  Unmittelbar danach wird ein Bloom Pass durchgef√ºhrt.  Dies ist eine ziemlich Standardtechnik, die aus einer Reihe von verkleinerten und verschwommenen Texturen besteht, die Pixel enthalten, deren Helligkeit einen bestimmten Schwellenwert √ºberschreitet.  Es werden zwei Bloom-Durchg√§nge verwendet, die mit der Gau√üschen Unsch√§rfe f√ºr die gesamte Szene und einer speziellen radialen Unsch√§rfe, die nur f√ºr den Himmel gilt, √ºblich sind.  Radiale Unsch√§rfe ist eine der Operationen, bei denen eine spezielle ID aus dem G-Puffer normaler Karten verwendet wird, da nur Pixel am Himmel ber√ºcksichtigt werden.  Als Bonus wird durch diese Unsch√§rfe die Tiefenkarte abgetastet und es k√∂nnen kosteng√ºnstige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">D√§mmerungsstrahlen erzeugt werden</a> .  Da wir zu diesem Zeitpunkt mit einem LDR-Puffer arbeiten, unterscheidet sich der Wert der Bl√ºtenschwelle vom Wert des HDR-Teppichs (Werte √ºber der Schwelle, normalerweise 1,0, f√ºhren zur Berechnung), und dies bedeutet, dass der Wert der daraus erhaltenen Bl√ºte geringf√ºgig begrenzt ist.  In jedem Fall ist dies gut f√ºr das Spiel und hier sind die Ergebnisse.  In den folgenden Bildern sehen die Farben der Bloom-Mip-Textur etwas seltsam aus, da jedes Pixel durch die im Alphakanal enthaltene Helligkeit skaliert wird.  Diese Helligkeit wurde fr√ºher im Stadium der Tonwertkorrektur berechnet.  Beim endg√ºltigen Zusammensetzen wird Bloom als <strong>bloom.rgb ¬∑ bloom.a ¬∑ bloomScale berechnet</strong> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h3/2y/ra/h32yra8lvz_-pxsab9raxyfobei.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/le/2k/dx/le2kdxxuaqtjrdnhdvxfobubyhw.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jb/kz/mk/jbkzmkd2ans3vxvs_we9eowudvs.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xs/gs/dg/xsgsdgnvhckxgckfhs7k4hvpc7u.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/v3/yr/hh/v3yrhhxazolya5nu8fn7id66p6k.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/q8/r1/wl/q8r1wlekxf0tae6ivo6bfyjngie.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gw/5c/tj/gw5ctjh8owpukokne73nskb4n48.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8k/te/sg/8ktesgsr6ser_l6ssaorfcpniww.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/j6/u6/ts/j6u6tsvqcjuwqqzepsfeogf330i.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ee/tf/vg/eetfvgkcuahvbbonuhfnpinh32w.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/m-/zw/bc/m-zwbcp4qvnr69vn1unq1clh3ws.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ei/ta/-s/eita-ssnu2cqzwkspcrjan42-ua.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/db/cb/cs/dbcbcsoo_znq2ex30ixasi-c8le.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i4/ja/ro/i4jarols6px4f0nnbai-rk5r87u.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/na/ag/mj/naagmjq8e75kxcxmyhberqpslag.png"></div><br><h3>  Antialiasing + Sch√§rfentiefe </h3><br>  Zu diesen beiden Operationen gibt es nicht viel zu sagen, es werden branchen√ºbliche Ans√§tze verwendet.  Ein einfacher Durchgang durch das FXAA-Antialiasing wird unmittelbar nach dem Zusammenstellen der Bl√ºte mit dem LDR-Bild durchgef√ºhrt, und die Sch√§rfentiefe wird unmittelbar danach durchgef√ºhrt.  F√ºr die Sch√§rfentiefe rendert das Spiel zwei verminderte verschwommene Versionen des endg√ºltigen Puffers.  Dann wird die Pixeltiefe verwendet, um verschwommene und normale Bilder zu mischen, was den Effekt der Defokussierung ergibt.  Aus Gr√ºnden der Klarheit habe ich in dieser Aufnahme den Effekt der Sch√§rfentiefe √ºbertrieben.  Das Spiel verf√ºgt √ºber einen integrierten Screenshot-Modus, mit dem Sie diese Bedingungen einfach konfigurieren k√∂nnen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ug/et/zf/ugetzfmh2jbbcpvrzb1e6dpwbhu.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p_/x4/fk/p_x4fkleolfxxnpvs9vnveywipy.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bi/vg/bp/bivgbpqa_nmzkx4zgiuzmu3nm6e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w2/vn/hg/w2vnhg6eoxe92rjat51qf65pggo.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uf/0g/kj/uf0gkjnripqq4ctkcpsremqrqnk.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bx/k5/z4/bxk5z47piwcgchqepehqpyypwgu.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ue/dc/xq/uedcxqx7svcjyq6g0-tp4uc1gho.png"></div><br><h3>  Bewegungsunsch√§rfe </h3><br>  Bewegungsunsch√§rfe besteht aus zwei Durchg√§ngen.  Zun√§chst werden Daten aus der vorherigen und der aktuellen Kameraausrichtung in den Vollbild-Geschwindigkeitspuffer √ºbertragen.  In diesem Fall werden zwei Kan√§le der Textur im Bildschirmbereich mit Geschwindigkeit gef√ºllt.  Nun enth√§lt Kanal r die Gr√∂√üe der Pixel√§nderung in horizontaler Richtung des Bildschirms, und Kanal g enth√§lt die Gr√∂√üe in vertikaler Richtung.  Auf diese Weise werden beim Bewegen der Kamera radiale Streifen erhalten.  Der Charakter wird erneut gerendert und f√ºllt diesmal den blauen Kanal basierend auf seinen aktuellen und vorherigen Posen, wie dies bei der Kamera der Fall ist.  Der blaue Kanal wird verwendet, um zu markieren, ob das Rendern gerendert werden soll oder nicht.  Der Alphakanal ist ebenfalls mit einem konstanten Wert (0,0598) gef√ºllt, aber ich habe seinen Wert oder seine Ziele nicht untersucht.  Die Geschwindigkeitspufferaufl√∂sung wird durch Mitteln √ºber einen relativ gro√üen Geschwindigkeitsbereich in der urspr√ºnglichen Textur auf eine sehr kleine Textur reduziert.  Im letzten Durchgang gibt dies jedem Pixel eine ungef√§hre Vorstellung davon, wie der Unsch√§rferadius in einem echten Unsch√§rfedurchgang sein wird. <br><br>  Dann liest der Unsch√§rfepass beide Geschwindigkeitstexturen, eine Tiefenkarte, den urspr√ºnglichen Farbpuffer und die Rauschtextur.  Letzteres wird verwendet, um den Effekt eines Spiegelbildes zu verbergen, der bei dieser Art von Unsch√§rfe mit gro√üem Radius auftreten kann.  Dann wird der Bildpuffer mehrmals in der durch den Geschwindigkeitspuffer angegebenen Richtung abgetastet, die Farben werden gemittelt, was zu einer Unsch√§rfe des Bildes in Richtung der Bewegungsvektoren f√ºhrt.  Au√üerdem wird dieser Effekt entsprechend der Bildrate skaliert, mit der das Spiel arbeitet.  F√ºr diese Aufnahme musste ich das Spiel auf 30 fps beschr√§nken, da dies bei 60 fps und dar√ºber kaum sp√ºrbar ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zn/4r/-7/zn4r-7rgnvx9zuh6asjnzqxknno.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hr/x_/yu/hrx_yug350grzjbnn6r6d9b7spa.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/94/i5/bc/94i5bcpjozmzuykcwfh9vksqjk8.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n7/mr/zo/n7mrzoppnprexpqv5h7uj-xobvu.png"></div><br><h3>  Farbkorrektur </h3><br>  Der letzte Durchgang der Farbkorrektur wird mit den ‚ÄûFarbw√ºrfeln‚Äú durchgef√ºhrt.  Ein Farbw√ºrfel ist eine 3D-Textur, deren RGB-Komponenten an den xyz-Koordinaten der Textur ausgerichtet sind.  Diese xyz-Koordinaten enthalten die Farbe, durch die die urspr√ºngliche Farbe ersetzt werden muss.  In unserem Fall ist die Nachschlagetabelle (LUT) neutral (d. H. Die Koordinaten und die Farbe enthalten denselben Wert), daher habe ich dieselbe Szene mithilfe der Voreinstellungen ge√§ndert, die das Spiel im Kamera-Editor bereitstellt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-i/dk/rd/-idkrdltmru5ndotkyzhmdbwth4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/az/-x/it/az-xitiqseycg8t_mz0kuhjxh1m.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/em/p0/ds/emp0dsyarj3nhdi-s453p0p0rsa.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1e/9q/fa/1e9qfapyuezjdafa8licevb6csu.png"></div><br><h3>  Letzter Rahmen </h3><br>  Nach der Erstellung des Hauptrahmens in einem separaten Puffer wird die Benutzeroberfl√§che gerendert.  Dies stellt sicher, dass unabh√§ngig von der f√ºr den hinteren Puffer ausgew√§hlten Gr√∂√üe die Benutzeroberfl√§che in der nativen Fenstergr√∂√üe immer klar und sch√∂n dargestellt wird, w√§hrend das Spiel die Aufl√∂sung bei Bedarf √§ndern kann, um die Geschwindigkeit sicherzustellen.  Am Ende werden beide Texturen basierend auf den Alpha-Kanaldaten der Benutzeroberfl√§che zusammengemischt und dann in den endg√ºltigen Bildpuffer gerendert, der zur Anzeige auf dem Bildschirm bereit ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cv/ba/t9/cvbat95whbpymp0cfpnjmohp_oo.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i0/y0/qm/i0y0qmb9x6liyqlpcd4vs2rli3y.png"></div><br>  Ich hoffe, Ihnen hat meine Analyse gefallen.  Ich m√∂chte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Adrian Correge</a> f√ºr die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">gro√üartige</a> Arbeit danken, die mich zum Studium der Grafik inspiriert hat, sowie den Mitarbeitern des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Monolith-</a> Studios f√ºr dieses wirklich unvergessliche Spiel. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430518/">https://habr.com/ru/post/de430518/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430506/index.html">Dunkle Kunst der Auferstehung: Wie man Daten von besch√§digten Medien wiederherstellt</a></li>
<li><a href="../de430508/index.html">DevOps: Was ist das wirklich?</a></li>
<li><a href="../de430510/index.html">Wie schreibe ich Code, den jeder verstehen wird?</a></li>
<li><a href="../de430512/index.html">Wie Freiberufler leben: Arbeiten Sie nicht mit allwissenden Kunden zusammen und lassen Sie sich z√∂gern</a></li>
<li><a href="../de430514/index.html">Blockchain Charity - DataArt gewinnt Malta Blockchain Summit Hackathon</a></li>
<li><a href="../de430520/index.html">Einf√ºhrung in Spring Data MongoDB</a></li>
<li><a href="../de430522/index.html">Ben√∂tigen Sie eine Unternehmenskultur in der IT? Gest√§ndnis des Markenmanagers des Krasnodar-Studios Plarium</a></li>
<li><a href="../de430524/index.html">Neuronale Netzwerkarchitektur</a></li>
<li><a href="../de430526/index.html">Spielautomaten: Woher kamen sie in der UdSSR und wie sind sie angeordnet?</a></li>
<li><a href="../de430528/index.html">Programmieren mit PyUSB 1.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>