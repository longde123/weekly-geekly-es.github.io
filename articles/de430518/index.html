<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>◼️ 🈳 ✊🏻 So rendern Sie den Rahmen von Mittelerde: Schatten von Mordor 💑 👨🏿‍🍳 🙎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mittelerde: Shadow of Mordor wurde 2014 ins Leben gerufen. Das Spiel selbst war eine große Überraschung, und die Tatsache, dass es ein Spin-off der Ha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So rendern Sie den Rahmen von Mittelerde: Schatten von Mordor</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430518/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ow/br/se/owbrsedfx4zll9o8sxbxx2fbnza.gif"></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Mittelerde: Shadow of Mordor</a> wurde 2014 ins Leben gerufen.  Das Spiel selbst war eine große Überraschung, und die Tatsache, dass es ein Spin-off der Handlung des Universums Lord of the Ring war, war ziemlich unerwartet.  Das Spiel war sehr erfolgreich und zum Zeitpunkt des Schreibens hat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Monolith</a> bereits eine Fortsetzung veröffentlicht - Shadow of War.  Die Grafiken des Spiels sind sehr schön, besonders wenn man bedenkt, dass es für verschiedene Konsolengenerationen veröffentlicht wurde, einschließlich der Xbox 360 und PS3.  Die PC-Version ist ziemlich gut poliert, enthält zusätzliche Grafikoptionen und hochauflösende Texturpakete, die das Potenzial des Spiels voll ausschöpfen. <br><br>  Das Spiel verwendet den relativ neuen DX11-Renderer.  Ich habe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Renderdoc verwendet</a> , um die Rendering-Techniken des Spiels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gründlich</a> zu lernen.  Bei der Arbeit wurden die maximal möglichen Grafikparameter (Ultra) verwendet und alle möglichen „Lotionen“ einbezogen, z. B. Transparenz unabhängig von Reihenfolge, Tessellation, Okklusion im Bildschirmbereich und verschiedene Bewegungsunschärfen. <br><a name="habracut"></a><br><h2>  Rahmen </h2><br>  Hier ist ein Rahmen, den wir analysieren werden.  Der Spieler befindet sich auf einer Holzplattform in der Region Udun.  Shadow of Mordor verwendet eine ähnliche Mechanik wie Spiele wie Assassin's Creed, bei der Sie Gebäude und Türme besteigen und dann die umgebende digitale Landschaft von den Dächern aus genießen können. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73d/325/3e0/73d3253e0323327f95babf989f060f93.jpg" alt="Bild"></div><br><h2>  Tiefenpassage </h2><br>  Die ungefähr 140 ersten Renderaufrufe führen einen kurzen vorläufigen Durchgang durch, um die größten Höhenelemente und Gebäude in den Tiefenpuffer zu rendern.  Die meisten Objekte fallen nicht in diesen vorläufigen Durchgang, aber es hilft, wenn das Spiel eine sehr große Anzahl von Draw Calls hat und Sie weit in die Ferne schauen können.  Interessanterweise fällt ein Charakter, der sich immer in der Mitte des Bildschirms befindet und einen anständigen Teil des Bildschirmraums einnimmt, nicht in diese Passage.  Wie in vielen anderen Open-World-Spielen verwendet die Engine die inversen z-Werte.  Diese Technik bindet die nahe Ebene an 1,0 und die ferne Ebene an 0,0, um die Genauigkeit bei großen Entfernungen zu erhöhen und Z-Konflikte zu verhindern.  Lesen Sie hier mehr über die Genauigkeit von Z-Puffern. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/181/ba6/57d/181ba657ddc430ee3a892e852cc276e9.png" alt="Bild"></div><br><h4>  G-Puffer </h4><br>  Unmittelbar danach beginnt der G-Puffer-Durchlauf, der in ungefähr 2700 Draw-Aufrufen ausgeführt wird.  Wenn Sie meine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherige Analyse von Castlevania: Lords of Shadow 2</a> gelesen oder andere ähnliche Artikel studiert haben, sollte Ihnen diese Passage bekannt sein.  Die Eigenschaft der Oberflächen wird in einer Reihe von Puffern aufgezeichnet, die dann in den Durchgängen der Beleuchtungsberechnung gelesen werden, um die Reaktionen der Oberflächen auf Licht zu berechnen.  Shadow of Mordor verwendet einen klassischen verzögerten Renderer, aber eine relativ kleine Anzahl von Renderzielen des G-Puffers wird verwendet, um dieses Ziel zu erreichen (3).  Zum Vergleich: Unreal Engine in dieser Passage verwendet 5-6 Puffer.  G-Puffer hat das folgende Schema: <br><br><h5>  Normaler Puffer </h5><br><table><tbody><tr><td>  <strong><font color="#ff0000">R.</font></strong> </td><td>  <strong><font color="#00ff00">G.</font></strong> </td><td>  <strong><font color="#0000ff">B.</font></strong> </td><td>  <strong>A.</strong> </td></tr><tr><td>  <strong>Normal.x</strong> </td><td>  <strong>Normal.y</strong> </td><td>  <strong>Normal.z</strong> </td><td>  <strong>ID</strong> </td></tr></tbody></table><br>  Der Normalenpuffer speichert Normalen im Weltraum im Format „8 Bit pro Kanal“.  Dies reicht kaum und manchmal gar nicht aus, um glatt variierende flache Oberflächen zu beschreiben.  Wenn Sie genau hinschauen, kann dies in einigen Pfützen im Spiel gesehen werden.  Der Alphakanal wird als ID verwendet, die verschiedene Objekttypen kennzeichnet.  Zum Beispiel fand ich heraus, dass 255 sich auf das Zeichen bezieht, 128 auf den animierten Teil der Flagge, und der Himmel mit der ID 1 markiert ist, da diese Kennungen später verwendet werden, um ihn beim Hinzufügen zu filtern (der Himmel erhält seine eigene radiale Blüte). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/za/jf/y8/zajfy84cg-abqarjiybgm3qcztw.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9k/aq/4v/9kaq4vempyj-n14_kdfte3d51ss.png"></div><br>  <i>Im Originalartikel sind diese und viele andere Bilder zur besseren Übersicht animiert, daher empfehle ich, dort nachzuschauen.</i> <br><br><h5>  Puffer Albedo </h5><br><table><tbody><tr><td>  <strong><font color="#ff0000">R.</font></strong> </td><td>  <strong><font color="#00ff00">G.</font></strong> </td><td>  <strong><font color="#0000ff">B.</font></strong> </td><td>  <strong>A.</strong> </td></tr><tr><td>  <strong>Albedo.r</strong> </td><td>  <strong>Albedo.g</strong> </td><td>  <strong>Albedo.b</strong> </td><td>  <b>Hohlraumverschluss</b> </td></tr></tbody></table><br>  Der Albedopuffer speichert alle drei Komponenten der Albedo und eine kleine Okklusion (manchmal auch als Hohlraumokklusion bezeichnet), mit der kleine Details schattiert werden, die mit einer Schattenkarte oder einer Nachbearbeitung im Bildschirmbereich nicht erreicht werden können.  Es wird hauptsächlich zu dekorativen Zwecken verwendet, zum Beispiel für Löcher und Falten an der Kleidung, kleine Risse in einem Baum, kleine Muster an der Kleidung von Talion usw. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/t6/ul/bz/t6ulbzqtlw3ncodrlnd49uxtmwa.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/28/52/lr/2852lrdq75bxtqpkywvutfsm4se.png"></div><br>  Bei der Verarbeitung von Feinden im Shader berücksichtigt die Albedo die Textur des Blutes (interessanterweise bekommt Talion niemals sichtbare Wunden).  Die Bluttextur ist die Eingabe für die Rendering-Phase der Kleidung und des Körpers der Feinde, gibt jedoch nicht die Farbe des Blutes an, die die Eingabe im konstanten Puffer ist, sondern bestimmt die Faktoren / Blutspiegel, um die angezeigte Blutmenge zu steuern.  Außerdem wird die normale Ausrichtung verwendet, um den Effekt zu skalieren, sodass Sie die Richtung der Blutspritzer steuern können.  Dann schattiert die Albedo im Wesentlichen mit der Helligkeit der Wunden, die der Feind von der entsprechenden Stelle auf der Blutkarte erhalten hat, und modifiziert auch andere Eigenschaften, wie z. B. Spiegel, um einen überzeugenden Bluteffekt zu erzielen.  Ich konnte den Teil des Rahmens, in dem die Karte gerendert wird, nicht finden, aber ich gehe davon aus, dass sie direkt am Anfang des Rahmens aufgezeichnet werden, wenn das Schwert freigelegt ist, und dann hier verwendet werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1y/_r/rt/1y_rrtgi8bsuryvjmqmpdvzwpfk.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mi/tv/nu/mitvnumojb0zx4qhzohrgrj810e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qp/wx/t7/qpwxt7y4r-k3ugakdasysx1vtvm.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6d/-r/lz/6d-rlzgi7fvdep6xrxnakmjp9yg.png"></div><br><h5>  Spiegelpuffer </h5><br><table><tbody><tr><td>  <strong><font color="#ff0000">R.</font></strong> </td><td>  <strong><font color="#00ff00">G.</font></strong> </td><td>  <strong><font color="#0000ff">B.</font></strong> </td><td>  <strong>A.</strong> </td></tr><tr><td>  <b>Rauheit</b> </td><td>  <b>Spiegelintensität</b> </td><td>  <b>Fresnel</b> </td><td>  <b>Streufaktor unter der Oberfläche</b> </td></tr></tbody></table><br>  Der Spiegelpuffer enthält andere Oberflächeneigenschaften, die in Spielen zu erwarten sind, wie z. B. die Rauheit (dies ist nicht ganz die Rauheit, sondern ein skalierter Spiegelgrad, der jedoch auf diese Weise interpretiert werden kann), die Spiegelintensität (die Helligkeit der Spiegelreflexion), die skaliert Albedo, um den richtigen Farbspiegel, den Reflektivitätsfaktor (in der Literatur allgemein als F0 bezeichnet, weil er die Eingabe für die Fresnel-Spiegelantwort ist) und die Komponente der Streuung unter der Oberfläche (Streuung unter der Oberfläche) zu erhalten.  Die letztere Komponente wird verwendet, um durchscheinende Materialien wie dünnes Gewebe, Pflanzen und Haut zu beleuchten.  Wenn wir später in das Studium des Licht-Shaders eintauchen, stellen wir fest, dass wir hier die Variation des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">normalisierten Spiegelmodells nach Blinn-Fong verwenden</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qx/rv/8c/qxrv8c9xk-4-akibiogsgnvxszw.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wv/xw/_f/wvxw_f6h-5vgmu6cvlucuum3sei.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fb/f3/v1/fbf3v1y8ardyfkjtshlv8zf5ld8.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ql/zq/lz/qlzqlzbbxwy_mlx05pwxwpxmrga.png"></div><br><h5>  Aufgeschobene Abziehbilder </h5><br>  Wie wir oben gesehen haben, zeigt Shadow of Mordor ziemlich detaillierte Blutspuren an verwundeten Charakteren.  Wenn Talion sein Schwert schwenkt, erhält die Umgebung auch ihren Anteil an dunklem Orkblut.  Für Umgebungen wird jedoch eine andere Technik verwendet - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verzögerte Abziehbilder</a> .  Diese Technik besteht darin, einen Satz flacher Texturen auf die Oberfläche des zuvor gerenderten zu projizieren.  Auf diese Weise wird der Inhalt des G-Puffers vor dem Durchführen des Beleuchtungsdurchlaufs durch diesen neuen Inhalt ersetzt.  Im Falle von Blut reicht nur blutiger Sprühnebel aus, und wenn viele Abziehbilder nacheinander gerendert werden, entsteht schnell eine ziemlich düstere Landschaft. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8_/zo/no/8_zonoux0rx6h_cemftpprebcke.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pk/sc/qn/pkscqng3m2s0c2hj-e-fs1eonis.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/a4/uf/rs/a4ufrsgki8blucgm4g8zq3n95ha.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dj/jl/3c/djjl3c5s2dsimxwtoim-c5vk3rg.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wj/hj/cb/wjhjcbcfdu0ts1kpnmh_2_tvhdq.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8r/tk/fi/8rtkfinzlyym0jweyx0gpizv4zs.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uh/ns/pw/uhnspwmomqsrlnoctsokx8q878a.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/di/7m/70/di7m700h63pqtmaiydgrezyt0w4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8t/ky/sz/8tkyszkhinic56jqebsteeudram.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0a/tu/kj/0atukjo4vjzv3djehm6sttjhqps.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-5/vm/ja/-5vmjatrsxyfdjhqm5nhsmu_vxw.png"></div><br>  Das Letzte, was in der G-Puffer-Passage gerendert wird, ist der Himmel. Die Himmelstextur hat eine sehr hohe Auflösung (8192 × 2048) im HDR BC6H-Format.  Ich musste eine kleine Tonkorrektur durchführen, da in HDR alle Farben zu dunkel sind. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95a/6b2/dda/95a6b2dda3a632aebe8fc902f143232d.jpg" alt="Bild"></div><br><h3>  Tessellation </h3><br>  Ein sehr interessantes „Feature“ des Spiels (wenn es aktiviert ist) ist die Tessellation.  Es wird für viele verschiedene Dinge verwendet, vom Gelände bis zur Charakterwiedergabe (sowie für Requisiten und Charakterobjekte).  Hier unterteilt die Tessellation das niedrige Polynetz nicht, sondern erzeugt Polygone aus einer Punktwolke unter Verwendung des erforderlichen Unterteilungsgrades, abhängig von den Kriterien für den Detaillierungsgrad, beispielsweise von der Entfernung zur Kamera.  Ein interessantes Beispiel ist der Talion-Umhang, der als Punktwolke (nach der Physiksimulation) an die GPU übertragen wird, und der Tessellations-Shader erstellt die Polygone neu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1i/jf/3i/1ijf3ikncscrhyvhjyyan6kdx80.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wj/fp/il/wjfpil_rw7_t1z7pxrfntobcrse.png"></div><br><h3>  Auftragsunabhängige Transparenz </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b78/f09/897/b78f09897b7ed45f990f51f91291c967.png"></div><br>  Eines der ersten Dinge, die mich an seiner Seltsamkeit beeindruckt haben, ist der Haarbehandlungspass, da er einen sehr komplexen speziellen Shader ausführt.  In den Grafikoptionen wird die Option OIT (Order-Independent Transparency) für Haare erwähnt, das heißt, es sollte so sein.  Zunächst wird die Ausgabe in einen separaten Puffer ausgeführt und die Gesamtzahl der überlagerten transparenten Pixel berechnet, während Eigenschaften in einer „tiefen“ Struktur ähnlich einem G-Puffer gespeichert werden.  Später sortiert ein anderer Shader einzelne Fragmente nach ihrer Tiefe.  Es scheint, dass die Pfeile auch auf diese Weise gerendert werden (wahrscheinlich erfordert ihr Gefieder eine ordnungsgemäße Sortierung).  Dies ist ein sehr subtiler Effekt, der keine besonderen grafischen Unterschiede hinzufügt, aber dennoch ein interessantes Detail darstellt.  Hier ein einfaches Beispiel: Das Bild oben zeigt die Anzahl der überlappenden Fragmente (je roter, desto mehr Fragmente).  Regelmäßige Transparenz wird weiterhin von der CPU sortiert und als traditionelles Alpha gerendert.  Nur einzelne Entitäten fallen in den OIT-Pass. <br><br><h3>  Schatten von Mordor </h3><br>  SoM hat viele Schattenquellen.  Zusätzlich zu herkömmlichen Schattenkarten dynamischer Lichtquellen verwendet SoM eine zweikanalige Umgebungsokklusion im Bildschirmbereich, eine für fast alle Objekte im Spiel erstellte Okklusion im Mikromaßstab und eine Okklusionstextur ähnlich einer Höhenkarte mit Draufsicht. <br><br><h5>  Okklusion im Bildschirmbereich </h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2cb/58c/fc5/2cb58cfc57777d65a15af4813977c962.png"></div><br>  Der erste Durchgang wird unter Verwendung des Umgebungs-G-Puffers und der Spiegelokklusion im Bildschirmbereich gerendert.  Der Shader selbst ist ein riesiger entfalteter Zyklus, der sowohl eine Tiefenkarte in voller Größe als auch eine zuvor reduzierte durchschnittliche Tiefenkarte abtastet und nach benachbarten Abtastwerten in einem bestimmten Muster sucht.  Es verwendet eine 4x4-Quadrat-Textur, um Pseudozufallsvektoren auf der Suche nach Okklusionsquellen auszuwählen.  Es wird ein verrauschter Okklusionspuffer gerendert, der dann durch eine einfache Unschärfe in zwei Durchgängen geglättet wird.  Das interessanteste Merkmal hierbei ist, dass es zwei verschiedene Okklusionskanäle gibt: Einer von ihnen wird als Spiegelokklusion und der andere als diffuse Okklusion verwendet.  In Standard-SSAO-Implementierungen wird ein Kanal berechnet, der für alle gebackenen Beleuchtungen gilt.  Hier wird die SSAO-Karte auch zur Übertragung an den gerichteten Beleuchtungskanal gelesen, wo sie verwendet wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/re/xf/kj/rexfkjx49htyufzecfeg2n7lsau.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dl/va/nz/dlvanzzg8bpcqughsrout8kaxlg.png"></div><br><h5>  Schattenkarten </h5><br>  Das nächste Ereignis ist das Rendern der Schattenkarte.  Da die Aktion des Spiels hauptsächlich in offenen Räumen stattfindet, werden der größte Teil des Lichts und der Schatten vom Hauptrichtungslicht aufgenommen.  Hier verwenden wir die Technik der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kaskadierung von Schattenkarten</a> (eine Variation davon sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=http://">parallel geteilte Schattenkarten</a> ), eine ziemlich übliche Technik zum Anwenden von Schatten über große Entfernungen, die darin besteht, dieselbe Szene aus einem Blickwinkel der Lichtquelle für verschiedene Bereiche des Raums zu rendern.  Normalerweise befinden sich Schattenkarten, die weit vom Abdeckungsbereich der Kamera entfernt sind, entweder in großen Entfernungen oder haben eine niedrigere Auflösung als die vorherigen. Dadurch wird die Auflösung in Bereichen, in denen Details noch nicht benötigt werden, wesentlich verringert, da die Geometrie zu weit entfernt ist.  In dieser Szene rendert das Spiel drei Schattenkaskaden 4096 × 4096 (tatsächlich hat das Spiel einen Platz für vier).  Die obere Kaskade befindet sich ganz in der Nähe von Talion, und die untere Kaskade enthält Berge und Objekte, die sehr weit von der Kamera entfernt sind.  Bei der Arbeit mit Schatten verwendet das Spiel den gleichen Trick mit der inversen z-Koordinate wie in der Tiefenkarte. \ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/347/7bc/a65/3477bca65b8cff92dfcfd68c9d66b8a8.jpg"></div><br><h5>  Schattenpuffer </h5><br>  Der nächste Schritt ist das Erstellen eines Schattenpuffers.  Dies ist eine einkanalige Textur, die auf Okklusionsinformationen aus früheren Schattenkarten basiert und einen Schattenfaktor im Intervall [0, 1] codiert.  Um eine Glätte an den Rändern zu erzielen, wird die Schattenkarte viermal mit dem Status eines speziellen bilinearen Samplers abgetastet, der vier Samples empfängt und diese mit einem bestimmten Wert vergleicht (dies wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=http://">Percentage Close Filtering bezeichnet</a> ).  Das Abrufen mehrerer Stichproben und das Mitteln ihrer Ergebnisse wird häufig als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">prozentuale, engere weiche Schatten bezeichnet</a> .  Zusätzlich zum Lesen der Schattenkarte wird auch die letzte Komponente des Spiegelpuffers (dh der Streukoeffizient unter der Oberfläche) abgetastet, die mit dem „Lichtblutungsfaktor“ multipliziert wird.  Es scheint notwendig zu sein, um die Schatten dieser Objekte zu beseitigen, damit etwas mehr Licht durch sie hindurchgeht. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b7f/b55/63f/b7fb5563faae1553e0f970374ee0b774.jpg"></div><br><h5>  Richtungsprojektionstextur </h5><br>  Eine andere Licht- und Schattenquelle ist eine Draufsichttextur, die von einer gerichteten Lichtquelle abgetastet wird.  Dies ist der Farbstich, der der Farbe der gerichteten Lichtquelle hinzugefügt wird, sowie der Effekt der globalen Schattierung, der für die gerichtete Beleuchtung gilt.  Es scheint, dass einige von ihnen manuell über einer automatisch generierten ebenen Beleuchtungskarte mit einer Draufsicht erstellt wurden.  Es scheint, dass die Kanten der Schatten für die statische Geometrie manuell angepasst werden (möglicherweise um Konflikte mit der realen Schattenkarte zu vermeiden), und einige Teile scheinen auch von Hand leicht getönt zu sein.  Wahrscheinlich ist die Aufgabe dieser Textur die kostengünstige Hinzufügung von Simulationen der Umgebungsokklusion in großem Maßstab und der globalen Beleuchtung mit Licht zusätzlich zur gerichteten Beleuchtung.  Die folgenden Bilder zeigen den Farbton, die Okklusion und das Produkt beider Faktoren, wodurch wir eine Vorstellung davon bekommen, wie die endgültige Farbmaske aussieht. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6v/vf/6a/6vvf6aaf5khdrbclmwpzp9_faka.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7e/fs/fe/7efsferrjbdtsu9megpk0gtfidc.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sd/bk/sv/sdbksv3a4jlkgzxui4nvl-suylq.png"></div><br>  Das Ergebnis aller Beleuchtungsdurchläufe wird im Renderziel des Formats R11G11B10F gespeichert.  So sieht das Ergebnis aus.  Ich habe eine tonale Korrektur der Ergebnisse durchgeführt, um den Effekt der gerichteten Beleuchtung auf der Ebene besser sichtbar zu machen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2a/28e/a63/f2a28ea6372642667b3778dfc32b193f.jpg"></div><br>  Alle entfernten Berge (im obigen Bild nicht dargestellt) werden ebenfalls durch gerichtetes Licht beleuchtet, sie werden jedoch als separater Fall hervorgehoben, damit die Beleuchtung besser gesteuert werden kann.  Einige sind skaliert, aber die weiter entfernten sind tatsächlich Betrüger mit geschickt erstellten Normal- und Albedokarten.  Sie haben spezielle gerichtete Lichtquellen, die nur die Berge betreffen. <br><br><h3>  Statische Beleuchtung </h3><br>  Shadow of Mordor verwendet eine sehr speicherintensive Implementierung der statischen Beleuchtung, bei der sehr großvolumige Texturen verwendet werden.  Das Bild unten zeigt drei statische Texturen für die Beleuchtungsstärke, mit der ein Teil dieses Bereichs diffus beleuchtet wird.  Jedes von ihnen ist eine riesige komprimierte Textur 512x512x128 BC6H, dh sie belegen 32 MB pro Textur oder 96 MB im Allgemeinen (wir spielen mit maximalen Qualitätseinstellungen).  Die Textur der Farbe gibt die Intensität an, die in das Voxel eintritt.  Die anderen beiden geben die Stärke oder Größe dieser Intensität entlang aller sechs Richtungen xyz und -xyz an, und die Normalen werden verwendet, um drei Komponenten auszuwählen (positive oder negative xyz, diejenigen, die am besten mit der Normalen übereinstimmen).  Nachdem wir diesen Vektor erstellt haben, nehmen wir sein Vektorprodukt durch das Quadrat der Normalen, und dies wird zum Skalierungsfaktor für die Intensität.  Die Formel lautet wie folgt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l9/yw/vk/l9ywvkgxuoti8bbppke_2c8o068.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ez/j3/uf/ezj3ufolhefyqxafjqskci0msho.png"></div><br>  Statische Lichtvolumina rendern auch eine kubische Karte für spiegelnde Beleuchtung, die wahrscheinlich in der Mitte des SLV erfasst wird.  Interessanterweise speichern Volumentexturen HDR-Werte, die in BC6H komprimiert sind, und kubische Karten werden im BC3-Format (DXT5) gespeichert, in dem keine Gleitkommawerte gespeichert werden können.  Um diese Einschränkung auszugleichen, behält der Alphakanal die Helligkeit bei, die dann von 1 bis 10 skaliert.  Dies ist eine etwas seltsame Entscheidung, und für mich sieht es eher nach einer Legacy-Implementierung aus.  Vergessen Sie nicht, dass das Spiel für Konsolen der vorherigen Generation veröffentlicht wurde, die die neuen HDR-Texturformate nicht unterstützen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k3/qo/z-/k3qoz-zblorjdxi7jyqthripztg.png"></div><br>  Die folgenden Bilder zeigen die Ergebnisse „vorher und nachher“ unter Berücksichtigung der Auswirkungen des Durchschnittsbilds.  Zur Visualisierung habe ich eine Tonwertkorrektur durchgeführt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4i/iq/yo/4iiqyosjg2tmdud840rxbhstofa.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/su/of/cd/suofcd-ls4myfuivd5vqb9ykbgi.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/37/rq/wb/37rqwb76ngards_rywaxhb_x9xw.png"></div><br><h3>  Atmosphärischer Nebel </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9af/086/c47/9af086c474cada9250daae007ec3c8bc.jpg"></div><br>  Shadow of Mordor hat ein Wetter- und Zeitsystem, dank dessen die Sonne scheint oder Regen durch das Spiel in Mordor strömt.  Dieses System wird durch die Summe der Komponenten gesteuert, und einer der wichtigsten ist Nebel.  Shadow of Mordor verwendet ein ziemlich einfaches, aber physikalisch einwandfreies Modell des atmosphärischen Nebels, einschließlich der einzelnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rayleigh-</a> Streuung sowie der Streuung durch ein kugelförmiges Teilchen (Mie-Streuung). <br><br>  Zunächst wird die Position der Kamera relativ zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erdmittelpunkt</a> berechnet.  Verschiedene trigonometrische Formeln ermöglichen es zu bestimmen, wo sich die Kamera in der Atmosphäre befindet, wo sich das Pixel befindet und welche Entfernung der Strahl in der Atmosphäre bei einer bestimmten maximalen atmosphärischen Höhe zurücklegt.  In unserem Fall befindet sich die Atmosphäre in einer Höhe von 65.000 Metern über der Oberfläche des Planeten.  Unter Berücksichtigung dieser Informationen werden Rayleigh- und sphärische Partikelkoeffizienten verwendet, um sowohl die Arten der Dichte der Nebelpartikel als auch ihre Farben zu berechnen.  Diese Dichten verdecken die bereits schattierten Pixel, streuen Licht, das von der schattierten Oberfläche in die Kamera eintritt, und tragen zum Nebel bei.  Bei der Simulation einer solchen Streuung werden Helligkeit und Richtung der Sonne berücksichtigt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ye/at/id/yeatidzdiemga1gntnm1zg9uz8k.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zj/39/zr/zj39zryuhmwdyadmcp0nb_g1uz8.png"></div><br><h3>  Verschlusszeit- und Tonkorrektur </h3><br>  Bei der Berechnung der Verschlusszeit wird ein ziemlich standardmäßiger Ansatz verwendet: Reduzieren der Auflösung des aus dem HDR-Hauptfarbpuffer berechneten Helligkeitspuffers nacheinander in eine Kette von Texturen, von denen jede halb so groß wie die vorherige Textur ist, beginnend mit einer Textur 1/3 des Hauptbildpuffers.  Mit dieser Verringerung der Auflösung werden 4 Abtastwerte entnommen, wobei die Werte benachbarter Pixel gemittelt werden, dh nachdem alle Durchschnittswerte in ein einzelnes Texel umgewandelt wurden, wird das Endergebnis zur durchschnittlichen Helligkeit.  Nachdem die Textur die Größe von 16 × 9 Texeln erreicht hat, wird ein Compute Shader gestartet, der alle verbleibenden Texel zusammenfasst.  Dieser Wert wird sofort im Tonkorrekturdurchlauf gelesen, um die Helligkeitswerte zu ändern. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ig/bi/h4/igbih41dc2x9aytucfgq1z_iuye.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/os/gw/t8/osgwt8co0pqgvomovsydsemapuw.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qh/bc/qv/qhbcqvqxy5hgvtn9x0c9kd1an6e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/g-/dw/fm/g-dwfm48oqtvuu1bizc1sikm7sq.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zg/8w/oz/zg8wozwpviq0nnt4-kef9b9azis.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/56/ik/dc/56ikdcoixmrbo0whghswhxdzxhk.png"></div><br>  Für die Tonkorrektur wird der Reinhardt-Operator verwendet, dessen optimierte Formel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> zu finden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ist</a> .  Im hlsl-Code sieht dies folgendermaßen aus: <br><br><pre><code class="cpp hljs">float3 hdrColor = tex2D(HDRTexture, uv.xy); hdrColor *= exposureValue; <span class="hljs-comment"><span class="hljs-comment">// This was calculated by the compute shader in the luminance downsampling pass float3 x = max(0.0, hdrColor - 0.004); float3 finalColor = (x * (6.2 * x + 0.5)) / (x * (6.2 * x + 1.7) + 0.06);</span></span></code> </pre> <br>  Wenn wir diese Kurve zeichnen, werden wir sehen, dass dieser Operator 10% der Weißwerte auch bei einem Eingabewert von 2,0 verwirft und gleichzeitig einen kleinen Teil des unteren Intervalls zwangsweise vollständig schwarz lässt.  Dies erzeugt ein entsättigtes, dunkles Bild. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc2/ea1/097/cc2ea10970239fb761b995496c049a8b.jpg" alt="Bild"></div><br><h3>  Alpha Stage </h3><br>  Der Alpha-Schritt ist etwas ungewöhnlich, da er Objekte direkt in den LDR-Puffer rendert.  Andere Spiele rendern sie ebenfalls im HDR-Puffer, damit sie am Verschluss teilnehmen können.  Wie dem auch sei, die zuvor berechnete Helligkeitstextur ist auf alle Alpha-beleuchteten Objekte beschränkt (in einigen Fällen wird beispielsweise bei lichtemittierenden Objekten die Verschlusszeit anhand der Shader-Konstanten und nicht anhand der Textur-Suche berechnet), und daher wird die Verschlusszeit beim Rendern automatisch angewendet nicht in der Nachbearbeitung durchgeführt.  Ein sehr spezieller Fall der Verwendung von Alpha in einem Spiel ist der Übergang in den Geistermodus (darin wird der Geist von Celebrimbor über dem Charakter des Spielers gerendert, der in den souveränen Ringen des LOTR-Universums geschmiedet ist. Das Spiel zeigt also, dass er immer in der Nähe ist, obwohl er unsichtbar ist).  Das Spiel übergibt mehrere Parameter an die Maschen beider Charaktere, die die Deckkraft steuern und es dem Spiel ermöglichen, Talion teilweise zu verdecken und nach und nach Celebrimore zu zeigen.  Andere Objekte im Spiel im Geistermodus rendern ebenfalls Geisterversionen über undurchsichtigen Objekten wie Feinden und Türmen.  Hier ist eine weitere Szene mit dem Übergang in die Geisterwelt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ux/ca/zs/uxcazsok9pqzuusfrb__dutdphw.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6g/1c/9e/6g1c9esdqit50db_mbck516ma-0.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/f_/dq/ss/f_dqss-avlzlyrb4s6_z6kqog0e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uw/yy/va/uwyyvakydfnsksy49ntfltpbwp8.png"></div><br><h3>  Regen </h3><br>  Im Hauptrahmen, den wir untersucht haben, gibt es keinen Regen, aber das Wetter ist ein so wichtiger Teil des Spiels, dass ich es hier erwähnen möchte.  Es wird in der GPU generiert und simuliert und direkt am Ende der Alpha-Phase gerendert.  Es wird ein Compute-Shader ausgeführt, der die Simulation ausführt und die Positionen in den Puffer schreibt.  Diese Positionen werden von einem anderen Shader eingenommen, der mit Hilfe eines instanziierten indirekten Anrufs so viele Quad-Instanzen rendert, wie die Positionen im vorherigen Durchgang berechnet wurden.  Der Vertex-Shader verfügt über ein einfaches Quad, das bei Bedarf verformt wird und sich in Richtung Kamera dreht.  Um zu verhindern, dass Regen in die Oberflächen eindringt, liest der Vertex-Shader auch Höhenkarten aus einer Draufsicht, sodass Sie alle Tropfen unter der überlappenden Oberfläche zurückweisen können.  Diese Höhenkarte wird direkt am Anfang des Rahmens gerendert.  Der gleiche Vertex-Shader teilt dem Pixel-Shader mit, woher das Sample aus der Drop-Textur stammt.  Befindet sich der Tropfen nahe an der Oberfläche, wird ein Texturbereich ausgewählt, der eine Begrüßungsanimation enthält.  Darüber hinaus führen Regentropfen Nebelberechnungen im Pixel-Shader durch, um sich nahtlos in den Rest der Szene einzufügen.  Hier ist ein Screenshot aus derselben Perspektive an einem regnerischen Tag. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xv/yv/ds/xvyvds_w25ybjxilgvr5crbcpo4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3c/ox/ax/3coxaxhejifprppkaheiahszfcm.png"></div><br>  Wenn der Regeneffekt aktiviert ist, wird der Spiegelpuffer global geändert, um nasse Oberflächen zu erzeugen, und Regenwellen werden in den normalen Puffer gerendert.  Die Animation ist zeitgesteuert, sodass nur ein Frame der geloopten Animation verwendet wird.  Der unten gezeigte normale Puffer wird geändert, um in den Puffer gerenderte Wellen anzuzeigen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ur/du/mz/urdumzhuebf1o2pnud_b2ztlfik.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p3/cv/t_/p3cvt_qq7vo9txgwycf7l2oec2y.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vc/3d/u3/vc3du3ytthqfsw1h7vwzr0tfxom.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6y/tk/rk/6ytkrkj0w38kvccrtrjpey95c_w.png"></div><br><h3>  Linseneffekte und Blüte </h3><br>  Nach Abschluss des Alpha-Renderings werden darüber Linseneffekte gerendert.  Eine Reihe von verschobenen Quads wird ab dem Punkt gerendert, von dem das gerichtete Licht kommt (in unserem Fall die Sonne).  Unmittelbar danach wird ein Bloom Pass durchgeführt.  Dies ist eine ziemlich Standardtechnik, die aus einer Reihe von verkleinerten und verschwommenen Texturen besteht, die Pixel enthalten, deren Helligkeit einen bestimmten Schwellenwert überschreitet.  Es werden zwei Bloom-Durchgänge verwendet, die mit der Gaußschen Unschärfe für die gesamte Szene und einer speziellen radialen Unschärfe, die nur für den Himmel gilt, üblich sind.  Radiale Unschärfe ist eine der Operationen, bei denen eine spezielle ID aus dem G-Puffer normaler Karten verwendet wird, da nur Pixel am Himmel berücksichtigt werden.  Als Bonus wird durch diese Unschärfe die Tiefenkarte abgetastet und es können kostengünstige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dämmerungsstrahlen erzeugt werden</a> .  Da wir zu diesem Zeitpunkt mit einem LDR-Puffer arbeiten, unterscheidet sich der Wert der Blütenschwelle vom Wert des HDR-Teppichs (Werte über der Schwelle, normalerweise 1,0, führen zur Berechnung), und dies bedeutet, dass der Wert der daraus erhaltenen Blüte geringfügig begrenzt ist.  In jedem Fall ist dies gut für das Spiel und hier sind die Ergebnisse.  In den folgenden Bildern sehen die Farben der Bloom-Mip-Textur etwas seltsam aus, da jedes Pixel durch die im Alphakanal enthaltene Helligkeit skaliert wird.  Diese Helligkeit wurde früher im Stadium der Tonwertkorrektur berechnet.  Beim endgültigen Zusammensetzen wird Bloom als <strong>bloom.rgb · bloom.a · bloomScale berechnet</strong> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h3/2y/ra/h32yra8lvz_-pxsab9raxyfobei.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/le/2k/dx/le2kdxxuaqtjrdnhdvxfobubyhw.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jb/kz/mk/jbkzmkd2ans3vxvs_we9eowudvs.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xs/gs/dg/xsgsdgnvhckxgckfhs7k4hvpc7u.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/v3/yr/hh/v3yrhhxazolya5nu8fn7id66p6k.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/q8/r1/wl/q8r1wlekxf0tae6ivo6bfyjngie.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gw/5c/tj/gw5ctjh8owpukokne73nskb4n48.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8k/te/sg/8ktesgsr6ser_l6ssaorfcpniww.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/j6/u6/ts/j6u6tsvqcjuwqqzepsfeogf330i.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ee/tf/vg/eetfvgkcuahvbbonuhfnpinh32w.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/m-/zw/bc/m-zwbcp4qvnr69vn1unq1clh3ws.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ei/ta/-s/eita-ssnu2cqzwkspcrjan42-ua.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/db/cb/cs/dbcbcsoo_znq2ex30ixasi-c8le.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i4/ja/ro/i4jarols6px4f0nnbai-rk5r87u.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/na/ag/mj/naagmjq8e75kxcxmyhberqpslag.png"></div><br><h3>  Antialiasing + Schärfentiefe </h3><br>  Zu diesen beiden Operationen gibt es nicht viel zu sagen, es werden branchenübliche Ansätze verwendet.  Ein einfacher Durchgang durch das FXAA-Antialiasing wird unmittelbar nach dem Zusammenstellen der Blüte mit dem LDR-Bild durchgeführt, und die Schärfentiefe wird unmittelbar danach durchgeführt.  Für die Schärfentiefe rendert das Spiel zwei verminderte verschwommene Versionen des endgültigen Puffers.  Dann wird die Pixeltiefe verwendet, um verschwommene und normale Bilder zu mischen, was den Effekt der Defokussierung ergibt.  Aus Gründen der Klarheit habe ich in dieser Aufnahme den Effekt der Schärfentiefe übertrieben.  Das Spiel verfügt über einen integrierten Screenshot-Modus, mit dem Sie diese Bedingungen einfach konfigurieren können. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ug/et/zf/ugetzfmh2jbbcpvrzb1e6dpwbhu.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p_/x4/fk/p_x4fkleolfxxnpvs9vnveywipy.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bi/vg/bp/bivgbpqa_nmzkx4zgiuzmu3nm6e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w2/vn/hg/w2vnhg6eoxe92rjat51qf65pggo.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uf/0g/kj/uf0gkjnripqq4ctkcpsremqrqnk.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bx/k5/z4/bxk5z47piwcgchqepehqpyypwgu.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ue/dc/xq/uedcxqx7svcjyq6g0-tp4uc1gho.png"></div><br><h3>  Bewegungsunschärfe </h3><br>  Bewegungsunschärfe besteht aus zwei Durchgängen.  Zunächst werden Daten aus der vorherigen und der aktuellen Kameraausrichtung in den Vollbild-Geschwindigkeitspuffer übertragen.  In diesem Fall werden zwei Kanäle der Textur im Bildschirmbereich mit Geschwindigkeit gefüllt.  Nun enthält Kanal r die Größe der Pixeländerung in horizontaler Richtung des Bildschirms, und Kanal g enthält die Größe in vertikaler Richtung.  Auf diese Weise werden beim Bewegen der Kamera radiale Streifen erhalten.  Der Charakter wird erneut gerendert und füllt diesmal den blauen Kanal basierend auf seinen aktuellen und vorherigen Posen, wie dies bei der Kamera der Fall ist.  Der blaue Kanal wird verwendet, um zu markieren, ob das Rendern gerendert werden soll oder nicht.  Der Alphakanal ist ebenfalls mit einem konstanten Wert (0,0598) gefüllt, aber ich habe seinen Wert oder seine Ziele nicht untersucht.  Die Geschwindigkeitspufferauflösung wird durch Mitteln über einen relativ großen Geschwindigkeitsbereich in der ursprünglichen Textur auf eine sehr kleine Textur reduziert.  Im letzten Durchgang gibt dies jedem Pixel eine ungefähre Vorstellung davon, wie der Unschärferadius in einem echten Unschärfedurchgang sein wird. <br><br>  Dann liest der Unschärfepass beide Geschwindigkeitstexturen, eine Tiefenkarte, den ursprünglichen Farbpuffer und die Rauschtextur.  Letzteres wird verwendet, um den Effekt eines Spiegelbildes zu verbergen, der bei dieser Art von Unschärfe mit großem Radius auftreten kann.  Dann wird der Bildpuffer mehrmals in der durch den Geschwindigkeitspuffer angegebenen Richtung abgetastet, die Farben werden gemittelt, was zu einer Unschärfe des Bildes in Richtung der Bewegungsvektoren führt.  Außerdem wird dieser Effekt entsprechend der Bildrate skaliert, mit der das Spiel arbeitet.  Für diese Aufnahme musste ich das Spiel auf 30 fps beschränken, da dies bei 60 fps und darüber kaum spürbar ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zn/4r/-7/zn4r-7rgnvx9zuh6asjnzqxknno.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hr/x_/yu/hrx_yug350grzjbnn6r6d9b7spa.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/94/i5/bc/94i5bcpjozmzuykcwfh9vksqjk8.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n7/mr/zo/n7mrzoppnprexpqv5h7uj-xobvu.png"></div><br><h3>  Farbkorrektur </h3><br>  Der letzte Durchgang der Farbkorrektur wird mit den „Farbwürfeln“ durchgeführt.  Ein Farbwürfel ist eine 3D-Textur, deren RGB-Komponenten an den xyz-Koordinaten der Textur ausgerichtet sind.  Diese xyz-Koordinaten enthalten die Farbe, durch die die ursprüngliche Farbe ersetzt werden muss.  In unserem Fall ist die Nachschlagetabelle (LUT) neutral (d. H. Die Koordinaten und die Farbe enthalten denselben Wert), daher habe ich dieselbe Szene mithilfe der Voreinstellungen geändert, die das Spiel im Kamera-Editor bereitstellt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-i/dk/rd/-idkrdltmru5ndotkyzhmdbwth4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/az/-x/it/az-xitiqseycg8t_mz0kuhjxh1m.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/em/p0/ds/emp0dsyarj3nhdi-s453p0p0rsa.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1e/9q/fa/1e9qfapyuezjdafa8licevb6csu.png"></div><br><h3>  Letzter Rahmen </h3><br>  Nach der Erstellung des Hauptrahmens in einem separaten Puffer wird die Benutzeroberfläche gerendert.  Dies stellt sicher, dass unabhängig von der für den hinteren Puffer ausgewählten Größe die Benutzeroberfläche in der nativen Fenstergröße immer klar und schön dargestellt wird, während das Spiel die Auflösung bei Bedarf ändern kann, um die Geschwindigkeit sicherzustellen.  Am Ende werden beide Texturen basierend auf den Alpha-Kanaldaten der Benutzeroberfläche zusammengemischt und dann in den endgültigen Bildpuffer gerendert, der zur Anzeige auf dem Bildschirm bereit ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cv/ba/t9/cvbat95whbpymp0cfpnjmohp_oo.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i0/y0/qm/i0y0qmb9x6liyqlpcd4vs2rli3y.png"></div><br>  Ich hoffe, Ihnen hat meine Analyse gefallen.  Ich möchte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Adrian Correge</a> für die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">großartige</a> Arbeit danken, die mich zum Studium der Grafik inspiriert hat, sowie den Mitarbeitern des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Monolith-</a> Studios für dieses wirklich unvergessliche Spiel. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430518/">https://habr.com/ru/post/de430518/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430506/index.html">Dunkle Kunst der Auferstehung: Wie man Daten von beschädigten Medien wiederherstellt</a></li>
<li><a href="../de430508/index.html">DevOps: Was ist das wirklich?</a></li>
<li><a href="../de430510/index.html">Wie schreibe ich Code, den jeder verstehen wird?</a></li>
<li><a href="../de430512/index.html">Wie Freiberufler leben: Arbeiten Sie nicht mit allwissenden Kunden zusammen und lassen Sie sich zögern</a></li>
<li><a href="../de430514/index.html">Blockchain Charity - DataArt gewinnt Malta Blockchain Summit Hackathon</a></li>
<li><a href="../de430520/index.html">Einführung in Spring Data MongoDB</a></li>
<li><a href="../de430522/index.html">Benötigen Sie eine Unternehmenskultur in der IT? Geständnis des Markenmanagers des Krasnodar-Studios Plarium</a></li>
<li><a href="../de430524/index.html">Neuronale Netzwerkarchitektur</a></li>
<li><a href="../de430526/index.html">Spielautomaten: Woher kamen sie in der UdSSR und wie sind sie angeordnet?</a></li>
<li><a href="../de430528/index.html">Programmieren mit PyUSB 1.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>