<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåÅ üëêüèº ü§≤üèæ Perkiraan penghitungan distribusi - paling sering penyortiran ulang üöø üçä üë©üèª‚Äçüé§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jumlah yang kurang lebih berbeda satu sama lain dijamin lebih dari seratus. Di antara mereka ada subkelompok algoritma yang minimal berbeda satu sama ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Perkiraan penghitungan distribusi - paling sering penyortiran ulang</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/478654/"> <a href="https://habr.com/ru/company/edison/blog/478654/"><img align="left" width="280" height="430" src="https://habrastorage.org/webt/sd/nz/sa/sdnzsaij33eps-i9dygobdrznxe.png"></a> <br clear="right">  Jumlah yang kurang lebih berbeda satu sama lain dijamin lebih dari seratus.  Di antara mereka ada subkelompok algoritma yang minimal berbeda satu sama lain, bertepatan dalam beberapa gagasan utama umum.  Faktanya, pada tahun-tahun yang berbeda, orang yang berbeda muncul dengan penyortiran yang sama lagi, berbeda dalam rincian yang tidak terlalu mendasar. <br><br>  Gagasan algoritmik seperti itu lebih sering ditemukan daripada yang lain. <br><br>  Setiap elemen dimasukkan <i>kira-kira di tempat</i> array di mana ia seharusnya berada.  Ternyata array yang <i>hampir dipesan</i> .  Di mana penyortiran berdasarkan sisipan diterapkan (paling efektif untuk memproses array yang hampir dipesan) atau area unordered lokal diproses secara rekursif oleh algoritma yang sama. <a name="habracut"></a><br><br><blockquote> <a href="https://www.edsd.ru/" title="Perangkat Lunak EDISON - pengembangan web"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="Perangkat Lunak EDISON - pengembangan web"></a> <br clear="right">  Artikel ini ditulis dengan dukungan EDISON, yang mengembangkan berbagai solusi untuk berbagai tugas: dari <a href="https://www.edsd.ru/virtualnaya-primerochnaya">program online mencoba pakaian toko multi-merek</a> hingga <a href="https://www.edsd.ru/peredacha-dannyh-s-pomoshhyu-svetodioda">sistem transmisi LED antara kapal sungai dan laut</a> . <br><br>  Kami menyukai teori algoritma!  ;-) </blockquote>  Untuk mengevaluasi kira-kira di mana Anda ingin meletakkan elemen, Anda perlu mencari tahu berapa banyak berbeda dari elemen rata-rata array.  Untuk melakukan ini, Anda perlu mengetahui nilai-nilai elemen minimum dan maksimum, baik, dan ukuran array. <br><br>  Array yang diurutkan seharusnya memiliki data yang benar-benar acak.  Semua penemu metode ini memiliki rumus yang sama: <br><br><div style="text-align:center;"><img width="460" height="81" src="https://habrastorage.org/webt/ik/qi/gt/ikqigtqyoqd41k5z3mfrjiwqwey.png"></div><br>  <b>k</b> adalah tempat perkiraan dalam array tempat elemen <b>A</b> ( <b>i</b> ) seharusnya berada <br>  <b>min</b> , <b>maks</b> - nilai elemen minimum dan maksimum dalam array <b>A</b> <br>  <b>Ukuran</b> - jumlah elemen dalam array <b>A</b> <br><br>  Ini ide yang umum.  Mari kita lihat variasi mana dari algoritma ini yang dilahirkan berulang kali. <br><br><h2>  Sorting King Solomon :: Sort Solomon </h2><br><div style="text-align:center;"><img width="608" height="294" src="https://habrastorage.org/webt/ds/ry/ga/dsrygazdx_xtt2hwbvvwjhd0bbo.gif"></div><br>  Metode ini (dan namanya yang indah) <a href="https://habr.com/ru/post/208088/">diusulkan oleh</a> pengguna <a href="https://habr.com/ru/users/v2008n/" class="user_link">V2008n</a> sekitar 5 tahun yang lalu.  Ada waktu untuk segalanya, ‚Äúada waktu untuk menaburkan batu dan ada waktu untuk mengumpulkan batu‚Äù (kata-kata Raja Salomo dari buku Pengkhotbah) - dan dalam algoritme, inilah yang terjadi.  Pertama, dengan bantuan rumus, kami menyebarkan elemen di tempat yang diinginkan dalam array.  Karena formula tidak memberikan tempat yang tepat, tetapi perkiraan, beberapa elemen yang dekat satu sama lain dalam nilai mengklaim beberapa posisi sekaligus.  Grup elemen lokal ini diurutkan berdasarkan sisipan dan kemudian disusun dalam urutan akhir. <br><br><h2>  Urutan interpolasi </h2><br>  "Tidak ada yang baru di bawah matahari," mengutip penulis yang sama lagi.  Wikipedia menjelaskan penyortiran dengan interpolasi, yang secara mencurigakan mengingatkan pada penyortiran Solomon.  Setiap ‚Äútumpukan batu‚Äù adalah susunan dinamis kecil tambahan, tempat elemen-elemen yang sama pentingnya berada.  Perbedaan utama adalah bahwa setelah ‚Äúpenghamburan batu‚Äù kelompok-kelompok elemen lokal yang tidak disortir ini diurutkan bukan oleh sisipan, tetapi dengan menyortir diri mereka dengan interpolasi (secara rekursif atau dalam satu lingkaran). <br><br>  Array yang dipesan adalah kumpulan data diskrit yang dapat dianggap sebagai himpunan terbatas dari nilai yang diketahui dari fungsi tertentu yang tidak diketahui.  Sebenarnya, perkiraan distribusi dari sudut pandang matematika komputasi - ini adalah interpolasi. <br><br><div class="spoiler">  <b class="spoiler_title">Urutan Interpolasi JavaScript - Loopback</b> <div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.interpolationSort = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> divideSize = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> end = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.length; divideSize[<span class="hljs-number"><span class="hljs-number">0</span></span>] = end; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(divideSize.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) {divide(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">A</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> size = divideSize.pop(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> start = end - size; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> min = A[start]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> max = A[start]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> temp = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = start + <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; end; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(A[i] &lt; min) { min = A[i]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(A[i] &gt; max) {max = A[i];} } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(min == max) { end = end - size; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bucket = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(size); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) {bucket[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>();} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = start; i &lt; end; i++) { p = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(((A[i] - min) / (max - min)) * (size - <span class="hljs-number"><span class="hljs-number">1</span></span>)); bucket[p].push(A[i]); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(bucket[i].length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; bucket[i].length; j++) {A[start++] = bucket[i][j];} divideSize.push(bucket[i].length); } } } } };</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Urutan interpolasi JavaScript - versi rekursif</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.bucketSort = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> start = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> size = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.length; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> min = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> max = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; size; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i] &lt; min) { min = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i] &gt; max) {max = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i];} } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(min != max) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bucket = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(size); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) {bucket[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>();} <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interpolation = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++){ interpolation = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(((<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i] - min) / (max - min)) * (size - <span class="hljs-number"><span class="hljs-number">1</span></span>)); bucket[interpolation].push(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i]); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(bucket[i].length &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) {bucket[i].bucketSort();} <span class="hljs-comment"><span class="hljs-comment">//Recursion for(var j = 0; j &lt; bucket[i].length; j++) {this[start++] = bucket[i][j];} } } };</span></span></code> </pre> </div></div><br><h3>  Sortir histogram :: Sortir histogram </h3><br>  Ini adalah optimasi penyortiran berdasarkan interpolasi, yang menghitung jumlah elemen yang dimiliki grup lokal yang tidak disortir.  Hitungan ini memungkinkan Anda untuk memasukkan item yang tidak disortir langsung ke dalam array yang dihasilkan (alih-alih mengelompokkannya ke dalam array kecil yang terpisah). <br><br><div class="spoiler">  <b class="spoiler_title">Sortir Bilah JavaScript</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.histogramSort = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> end = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.length; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sortedArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(end); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interpolation = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(end); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hitCount = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(end); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> divideSize = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(); divideSize[<span class="hljs-number"><span class="hljs-number">0</span></span>] = end; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(divideSize.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) {distribute(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">distribute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">A</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> size = divideSize.pop(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> start = end - size; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> min = A[start]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> max = A[start]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = start + <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; end; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A[i] &lt; min) { min = A[i]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A[i] &gt; max) {max = A[i];} } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (min == max) { end = end - size; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = start; i &lt; end; i++){hitCount[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = start; i &lt; end; i++) { interpolation[i] = start + <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(((A[i] - min) / (max - min)) * (size - <span class="hljs-number"><span class="hljs-number">1</span></span>)); hitCount[interpolation[i]]++; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = start; i &lt; end; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(hitCount[i] &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>){divideSize.push(hitCount[i]);} } hitCount[end - <span class="hljs-number"><span class="hljs-number">1</span></span>] = end - hitCount[end - <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = end - <span class="hljs-number"><span class="hljs-number">1</span></span>; i &gt; start; i--) { hitCount[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] = hitCount[i] - hitCount[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = start; i &lt; end; i++) { sortedArray[hitCount[interpolation[i]]] = A[i]; hitCount[interpolation[i]]++; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = start; i &lt; end; i++) {A[i] = sortedArray[i];} } } };</code> </pre> </div></div><br><h3>  Urutan tag interpolasi </h3><br>  Untuk lebih mengoptimalkan overhead, disarankan di sini untuk mengingat bukan jumlah elemen yang sama dalam kelompok yang tidak disortir, tetapi cukup menandai awal dari grup ini dengan bendera Benar / Salah.  Benar berarti bahwa subkelompok sudah diurutkan, dan Salah berarti belum. <br><br><div class="spoiler">  <b class="spoiler_title">Jenis interpolasi tagged JavaScript</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.InterpolaionTagSort = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> end = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.length; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(end &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> start = <span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Tag = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(end); <span class="hljs-comment"><span class="hljs-comment">//Algorithm step-1 for(var i = 0; i &lt; end; i++) {Tag[i] = false;} Divide(this); } //Algorithm step-2 while(end &gt; 1) { while(Tag[--start] == false){} //Find the next bucket's start Divide(this); } function Divide(A) { var min = A[start]; var max = A[start]; for(var i = start + 1; i &lt; end; i++) { if(A[i] &lt; min) { min = A[i]; } else { if(A[i] &gt; max ) {max = A[i];} } } if(min == max) { end = start; } else { //Algorithm step-3 Start to be the next bucket's end var interpolation = 0; var size = end - start; var Bucket = new Array(size);//Algorithm step-4 for(var i = 0; i &lt; size; i++) {Bucket[i] = new Array();} for(var i = start; i &lt; end; i++) { interpolation = Math.floor(((A[i] - min) / (max - min)) * (size - 1)); Bucket[interpolation].push(A[i]); } for(var i = 0; i &lt; size; i++) { if(Bucket[i].length &gt; 0) {//Algorithm step-5 Tag[start] = true; for(var j = 0; j &lt; Bucket[i].length; j++) {A[start++] = Bucket[i][j];} } } } }//Algorithm step-6 };</span></span></code> </pre> </div></div><br><h3>  Urutan tag interpolasi (di tempat) </h3><br>  Jika nilai-nilai elemen dalam array tidak diulang dan didistribusikan secara merata (secara kasar - jika data dalam bentuk yang diurutkan adalah seperti perkembangan aritmatika), maka Anda dapat mengurutkan dalam satu lintasan, menyortir tepat di tempatnya, tanpa memindahkan elemen ke array perantara. <br><br><div class="spoiler">  <b class="spoiler_title">Urutkan berdasarkan interpolasi dengan label (di tempat) dalam JavaScript</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.InPlaceTagSort = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.length; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Tag = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(n); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) {Tag[i] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> min = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> max = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; n; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i] &lt; min) { min = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i] &gt; max) {max = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i];} } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> temp = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(Tag[i] == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { p = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(((<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i] - min) / (max - min)) * (n - <span class="hljs-number"><span class="hljs-number">1</span></span>)); temp = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i]; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i] = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[p]; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[p] = temp; Tag[p] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } };</code> </pre> </div></div><br><h2>  Sortir Flash :: Flashsort </h2><br>  Suatu ketika, saya <a href="https://habr.com/ru/post/195968/">menulis</a> tentang penyortiran, yang ditemukan oleh profesor biofisika Neubert pada tahun 1998. <br><br>  Profesor menyarankan untuk mendistribusikan elemen ke dalam beberapa kelas terpisah (keanggotaan kelas ditentukan oleh ukuran elemen).  Dengan mengingat hal ini, rumusnya terlihat seperti ini: <br><br><div style="text-align:center;"><img width="408" height="68" src="https://habrastorage.org/webt/t4/m0/35/t4m0350wkzaul4zp1xy6eoturik.png"></div><br>  Alih-alih Ukuran (ukuran array), rumus menunjukkan <b>m</b> - jumlah kelas dimana kita mendistribusikan elemen-elemen array.  Rumus tidak menghitung kunci dalam array tempat elemen harus dilemparkan, tetapi nomor kelas tempat elemen tersebut berada. <br><br>  Penyortiran ini tidak buruk karena lebih hemat soal memori tambahan.  Redistribusi elemen terjadi pada tempatnya.  Hanya lokalisasi kelas yang disimpan secara terpisah (well, jika Anda melihat dari sudut yang berbeda, jumlah elemen milik kelas tertentu disimpan secara terpisah). <br><br>  Nah, sisanya adalah lagu yang sama. <br><br><div style="text-align:center;"><img width="684" height="190" src="https://habrastorage.org/webt/i_/4i/h0/i_4ih0amqa60afawupd2mykc4wo.gif"></div><br><div class="spoiler">  <b class="spoiler_title">Sortir Flash di Jawa</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * FlashSort.java - integer version * Translation of Karl-Dietrich Neubert's algorithm into Java by * Rosanne Zhang */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FlashSort</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] a; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] l; <span class="hljs-comment"><span class="hljs-comment">/* constructor @param size of the array to be sorted */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flashSort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ n = size; generateRandomArray(); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> start = System.currentTimeMillis(); partialFlashSort(); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> mid = System.currentTimeMillis(); insertionSort(); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> end = System.currentTimeMillis(); <span class="hljs-comment"><span class="hljs-comment">// print the time result System.out.println("Partial flash sort time : " + (mid - start)); System.out.println("Straight insertion sort time: " + (end - mid)); } /* Entry point */ public static void main(String[] args) { int size = 0; if (args.length == 0) { usage(); System.exit(1); } try { size = Integer.parseInt(args[0]); } catch (NumberFormatException nfe) { usage(); System.exit(1); } FlashSort.flashSort(size); } /* Print usage */ private static void usage() { System.out.println(); System.out.println("Usage: java FlashSort n "); System.out.println(" n is size of array to sort"); } /* Generate the random array */ private static void generateRandomArray() { a = new int[n]; for(int i=0; i &lt; n; i++) { a[i] = (int)(Math.random() * 5 * n); } m = n / 20; l = new int[m]; } /* Partial flash sort */ private static void partialFlashSort() { int i = 0, j = 0, k = 0; int anmin = a[0]; int nmax = 0; for(i=1; i &lt; n; i++) { if (a[i] &lt; anmin) anmin=a[i]; if (a[i] &gt; a[nmax]) nmax=i; } if(anmin == a[nmax]) return; double c1 = ((double)m - 1) / (a[nmax] - anmin); for(i=0; i &lt; n; i++) { k= (int) (c1 * (a[i] - anmin)); l[k]++; } for(k=1; k &lt; m; k++) { l[k] += l[k - 1]; } int hold = a[nmax]; a[nmax] = a[0]; a[0] = hold; int nmove = 0; int flash; j = 0; k = m - 1; while(nmove &lt; n - 1) { while(j &gt; (l[k] - 1)) { j++; k = (int) (c1 * (a[j] - anmin)); } flash = a[j]; while(!(j == l[k])) { k = (int) (c1 * (flash - anmin)); hold = a[l[k] - 1]; a[l[k] - 1] = flash; flash = hold; l[k]--; nmove++; } } } /* Straight insertion sort */ private static void insertionSort() { int i, j, hold; for(i = a.length - 3; i &gt;= 0; i--) { if(a[i + 1] &lt; a[i]) { hold = a[i]; j = i; while (a[j + 1] &lt; hold) { a[j] = a[j + 1]; j++; } a[j] = hold; } } } /* For checking sorting result and the distribution */ private static void printArray(int[] ary) { for(int i=0; i &lt; ary.length; i++) { if((i + 1) % 10 ==0) { System.out.println(ary[i]); } else { System.out.print(ary[i] + " "); } System.out.println(); } } }</span></span></code> </pre> </div></div><br><h2>  Approximate Sort :: Proxmap sort </h2><br>  Penyortiran ini adalah yang tertua dari yang disebutkan di sini, diperkenalkan pada tahun 1980 oleh Profesor Thomas Standish dari University of California.  Secara penampilan, tampaknya sangat berbeda, tetapi jika Anda perhatikan lebih dekat, semuanya sama. <br><br>  Algoritma beroperasi dengan konsep seperti <b>hit</b> - angka tertentu yang dekat nilainya dengan beberapa elemen array. <br>  Untuk menentukan apakah elemen array adalah hit, <b>fungsi aproksimasi</b> diterapkan ke elemen. <br><br>  Profesor Standish mengurutkan susunan bilangan real.  Fungsi aproksimasi adalah untuk membulatkan bilangan real ke bilangan bulat. <br>  Misalnya, jika array berisi elemen 2.8, 2, 2.1, 2.6, dll.  maka hit untuk angka-angka ini akan menjadi deuce. <br><br><div style="text-align:center;"><img width="619" height="389" src="https://habrastorage.org/webt/-o/i_/cc/-oi_ccg-cbvv2pxdb9cb2-fbdpg.gif"></div><br><br>  Prosedur umum: <br><br><ol><li>  Kami menerapkan fungsi perkiraan untuk setiap elemen, menentukan klik mana yang sesuai dengan elemen berikutnya. </li><li>  Jadi, untuk setiap klik, kita dapat menghitung jumlah elemen yang sesuai dengan klik ini. </li><li>  Mengetahui jumlah elemen untuk semua hit, kami menentukan lokalisasi hit (berbatasan di sebelah kiri) dalam array. </li><li>  Mengetahui pelokalan hit, kami menentukan lokalisasi setiap elemen. </li><li>  Setelah menentukan lokalisasi elemen, kami mencoba memasukkannya di tempatnya dalam array.  Jika tempat sudah diambil, maka kami memindahkan tetangga ke kanan (jika elemen lebih kecil dari mereka) untuk memberikan ruang bagi elemen.  Atau ke kanan kita memasukkan elemen itu sendiri (jika lebih dari tetangga). </li></ol><br>  Sebagai fungsi perkiraan, Anda dapat menetapkan satu berdasarkan sifat umum dari data dalam array.  Dalam implementasi modern penyortiran ini, hit biasanya ditentukan bukan dengan menggigit bagian pecahan, tetapi menggunakan formula favorit kami. <br><br><div class="spoiler">  <b class="spoiler_title">Jenis perkiraan JavaScript</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.ProxmapSort = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> start = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> end = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.length; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> A2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(end); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> MapKey = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(end); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hitCount = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(end); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = start; i &lt; end; i++) {hitCount[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> min = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[start]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> max = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[start]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = start+<span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; end; i++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i] &lt; min) { min = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i] &gt; max) {max = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i];} } } <span class="hljs-comment"><span class="hljs-comment">//Optimization 1.Save the MapKey[i]. for (var i = start; i &lt; end; i++) { MapKey[i] = Math.floor(((this[i] - min ) / (max - min)) * (end - 1)); hitCount[MapKey[i]]++; } //Optimization 2.ProxMaps store in the hitCount. hitCount[end-1] = end - hitCount[end - 1]; for(var i = end-1; i &gt; start; i--){ hitCount[i-1] = hitCount[i] - hitCount[i - 1]; } //insert A[i]=this[i] to A2 correct position var insertIndex = 0; var insertStart = 0; for(var i = start; i &lt; end; i++){ insertIndex = hitCount[MapKey[i]]; insertStart = insertIndex; while(A2[insertIndex] != null) {insertIndex++;} while(insertIndex &gt; insertStart &amp;&amp; this[i] &lt; A2[insertIndex - 1]) { A2[insertIndex] = A2[insertIndex - 1]; insertIndex--; } A2[insertIndex] = this[i]; } for(var i = start; i &lt; end; i++) {this[i] = A2[i];} };</span></span></code> </pre> </div></div><br><h2>  Penyortiran sisipan hash jenis: Menyortir hash </h2><br>  Baiklah, kami akan mengakhiri ulasan kami dengan algoritme <a href="https://habr.com/ru/post/203032/">yang</a> <a href="https://habr.com/ru/users/bobbykdas/" class="user_link">disarankan</a> <a href="https://habr.com/ru/post/203032/">oleh</a> bobbyKdas <a href="https://habr.com/ru/users/bobbykdas/" class="user_link">habraiser</a> 6 tahun yang lalu.  Ini adalah algoritma hybrid di mana, selain distribusi dan memasukkan, penggabungan juga ditambahkan. <br><br><ol><li>  Array dibagi secara setengah menjadi setengahnya, sampai pada suatu langkah ukuran setengah-setengah mencapai ukuran minimum (penulis tidak memiliki lebih dari 500 elemen). </li><li>  Pada tingkat rekursi terendah, algoritme yang akrab diterapkan pada masing-masing setengah subarray - menggunakan rumus yang sama, distribusi perkiraan terjadi di dalam subarray, dengan pengurutan berdasarkan sisipan bagian yang tidak disortir lokal. </li><li>  Setelah pengaturan dua bagian dari subarrays, mereka bergabung. </li><li>  Poin 3 (penggabungan setengah bagian yang diurutkan) diulangi saat naik melalui tingkat rekursi ke bagian paling atas, ketika array asli digabungkan dari dua bagian. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Urutkan dengan memasukkan hash di Jawa</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Arrays; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Date; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Random; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HashSort</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    static int SOURCELEN = 1000000; int source[] = new int[SOURCELEN]; //        int quick[] = new int[SOURCELEN]; //     static int SORTBLOCK = 500; static int k = 3; //  static int TMPLEN = (SOURCELEN &lt; SORTBLOCK * k) ? SORTBLOCK * k : SOURCELEN; int tmp[] = new int[TMPLEN]; //    static int MIN_VAL = 10; static int MAX_VAL = 1000000; int minValue = 0; int maxValue = 0; double hashKoef = 0; //      public void randomize() { int i; Random rnd = new Random(); for(i=0; i&lt;SOURCELEN; i++) { int rndValue = MIN_VAL + ((int)(rnd.nextDouble()*((double)MAX_VAL-MIN_VAL))); source[i] = rndValue; } } //         - public void findMinMax(int startIndex, int endIndex) { int i; minValue = source[startIndex]; maxValue = source[startIndex]; for(i=startIndex+1; i&lt;=endIndex; i++) { if( source[i] &gt; maxValue) { maxValue = source[i]; } if( source[i] &lt; minValue) { minValue = source[i]; } } hashKoef = ((double)(k-1)*0.9)*((double)(endIndex-startIndex)/((double)maxValue-(double)minValue)); } // (  - )      public void stickParts(int startIndex, int mediana, int endIndex) { int i=startIndex; int j=mediana+1; int k=0; //      -    while(i&lt;=mediana &amp;&amp; j&lt;=endIndex) { if(source[i]&lt;source[j]) { tmp[k] = source[i]; i++; } else { tmp[k] = source[j]; j++; } k++; } //     -      if( i&gt;mediana ) { while(j&lt;=endIndex) { tmp[k] = source[j]; j++; k++; } } //     -      if(j&gt;endIndex) { while(i&lt;=mediana) { tmp[k] = source[i]; i++; k++; } } System.arraycopy(tmp, 0, source, startIndex, endIndex-startIndex+1); } //        //         boolean shiftRight(int index) { int endpos = index; while( tmp[endpos] != 0) { endpos++; if(endpos == TMPLEN) return false; } while(endpos != index ) { tmp[endpos] = tmp[endpos-1]; endpos--; } tmp[endpos] = 0; return true; } //-    public int hash(int value) { return (int)(((double)value - (double)minValue)*hashKoef); } //        public void insertValue(int index, int value) { int _index = index; //  ,    //            - while(tmp[_index] != 0 &amp;&amp; tmp[_index] &lt;= value) { _index++; } //       ,    if( tmp[_index] != 0) { shiftRight(_index);//      } tmp[_index] = value;//  -   } //        public void extract(int startIndex, int endIndex) { int j=startIndex; for(int i=0; i&lt;(SORTBLOCK*k); i++) { if(tmp[i] != 0) { source[j] = tmp[i]; j++; } } } //   public void clearTMP() { if( tmp.length &lt; SORTBLOCK*k) { Arrays.fill(tmp, 0); } else { Arrays.fill(tmp, 0, SORTBLOCK*k, 0); } } //  public void hashingSort(int startIndex, int endIndex) { //1.          findMinMax(startIndex, endIndex); //2.    clearTMP(); //3.       - for(int i=startIndex; i&lt;=endIndex; i++) { insertValue(hash(source[i]), source[i]); } //4.         extract(startIndex, endIndex); } //         public void sortPart(int startIndex, int endIndex) { //    500,   - if((endIndex - startIndex) &lt;= SORTBLOCK ) { hashingSort(startIndex, endIndex); return; } //  &gt; 500         int mediana = startIndex + (endIndex - startIndex) / 2; sortPart(startIndex, mediana);//    sortPart(mediana+1, endIndex);//    stickParts(startIndex, mediana, endIndex);//   -   } //       public void sort() { sortPart(0, SOURCELEN-1); } public static void main(String[] args) { HashSort hs = new HashSort(); hs.randomize(); hs.sort(); } }</span></span></code> </pre> </div></div><br>  Rumus itu sendiri disebut fungsi hash, dan array bantu untuk perkiraan distribusi disebut tabel hash. <br><br><h2>  Referensi </h2><br><img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png">  <a href="https://en.wikipedia.org/wiki/Interpolation_sort">Interpolasi &amp; Histogram</a> , <a href="https://en.wikipedia.org/wiki/Flashsort">Flash</a> , <a href="https://en.wikipedia.org/wiki/Proxmap_sort">Proxmap</a> <br><br><img width="30" height="30" src="https://habrastorage.org/webt/jw/w-/qu/jww-queszzqnwmoa2hm-kfwu-9o.png">  <a href="https://habr.com/ru/post/208088/">Solomon</a> , <a href="https://habr.com/ru/post/203032/">Hash Table</a> , <a href="https://habr.com/ru/post/195968/">Flash</a> <br><br><h3>  Artikel Seri: </h3><br><ul><li>  <a href="https://habr.com/post/414447/">Aplikasi Excel AlgoLab.xlsm</a> </li><li>  <a href="https://habr.com/post/414653/">Pertukaran macam</a> </li><li>  <a href="https://habr.com/post/415935/">Urutan Penyisipan</a> </li><li>  <a href="https://habr.com/post/422085/">Sortir berdasarkan pilihan</a> </li><li>  <a href="https://habr.com/ru/post/431964/">Gabungkan Urusan</a> </li><li>  <a href="https://habr.com/ru/post/472466/">Urutkan berdasarkan distribusi</a> <ul><li>  <b>Menghitung jenis dengan perkiraan distribusi</b> </li><li>  <a href="https://habr.com/ru/post/481304/">Sortir Bendera Amerika</a> </li><li>  Pohon sufiks dalam penyortiran bitwise </li><li>  Membandingkan Penyortiran berdasarkan Distribusi </li></ul></li><li>  <a href="https://habr.com/ru/post/483786/">Sortasi Hibrid</a> </li></ul><br>  Penyortiran perkiraan muncul dalam aplikasi AlgoLab Excel (dalam hal ini, dalam array awal yang tidak disortir, bagian pecahan acak ditambahkan ke bilangan bulat).  Solomon dan Flash telah ada di sana untuk waktu yang lama, tetapi belum menerapkan interpolasi, hash, dan histogram. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id478654/">https://habr.com/ru/post/id478654/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id478640/index.html">Mobil otonom pada sumber terbuka</a></li>
<li><a href="../id478642/index.html">MOXA Nport - Tampilan Dalam</a></li>
<li><a href="../id478646/index.html">JetQuad: Pesawat Jet dengan Lepas Landas dan Pendaratan Vertikal</a></li>
<li><a href="../id478650/index.html">Dawn 3D</a></li>
<li><a href="../id478652/index.html">Struktur paket DNS</a></li>
<li><a href="../id478658/index.html">Bagaimana cara bangun? Alarm Cahaya Fajar Baru Plus</a></li>
<li><a href="../id478666/index.html">Kartu Suara USB pada YM3812</a></li>
<li><a href="../id478672/index.html">Pengujian dan Startup AI: Wawancara dengan Adam Carmi (Applitools)</a></li>
<li><a href="../id478680/index.html">Mengapa, dan yang paling penting, kemana orang pergi dari IT?</a></li>
<li><a href="../id478684/index.html">Pengantar SSD. Bagian 2. Antarmuka</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>