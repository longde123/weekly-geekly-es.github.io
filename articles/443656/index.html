<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔣 🎨 😸 Siguiendo los pasos de las calculadoras: calcular 🚽 🌓 👪</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Anteriormente realizamos revisiones de código de grandes paquetes matemáticos, por ejemplo, Scilab y Octave, por lo que las calculadoras se mantuviero...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Siguiendo los pasos de las calculadoras: calcular</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/443656/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/8-/gy/xn/8-gyxngfcuknt6ufomhpg4kpjry.png"></div><br>  Anteriormente realizamos revisiones de código de grandes paquetes matemáticos, por ejemplo, Scilab y Octave, por lo que las calculadoras se mantuvieron distantes como pequeñas utilidades, en las que es difícil cometer errores debido a su pequeña base de código.  Nos equivocamos al no haberles prestado atención.  El caso de publicar el código fuente de la calculadora de Windows mostró que en realidad todos estaban interesados ​​en discutir los tipos de errores que se ocultan en él.  Además, la cantidad de errores allí fue más que suficiente para escribir un artículo sobre eso.  Mis colegas y yo decidimos explorar el código de varias calculadoras populares, y resultó que el código de la calculadora de Windows no era tan malo (spoiler). <br><a name="habracut"></a><br><h2>  Introduccion </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Qalculate!</a>  es una calculadora de escritorio multiplataforma multipropósito.  Es fácil de usar, pero proporciona potencia y versatilidad normalmente reservadas para paquetes matemáticos complicados, así como herramientas útiles para las necesidades diarias (como conversión de moneda y cálculo de porcentajes).  El proyecto consta de dos componentes: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">libqalculate</a> (biblioteca y CLI) y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">qalculate-gtk</a> (GTK + UI).  El estudio incluyó solo el código libqalculate. <br><br>  Para comparar fácilmente el proyecto con la Calculadora de Windows, que hemos verificado recientemente, estoy citando el resultado de la utilidad Cloc para libqalculate: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/214/1f7/e35/2141f7e35bc5af14579e61f9bf4d907a.png"></div><br>  Considerando esto subjetivamente, hay más errores y son más críticos que en el código de la calculadora de Windows.  Sin embargo, recomendaría sacar conclusiones por su cuenta, después de leer esta descripción general del código. <br><br>  Por cierto, aquí hay un enlace a un artículo sobre la verificación de la calculadora de Microsoft: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Contando errores en la calculadora de Windows</a> ". <br><br>  La herramienta de análisis es el analizador de código estático <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PVS-Studio</a> .  Es un conjunto de soluciones para el control de calidad del código, búsqueda de errores y vulnerabilidades potenciales.  Los lenguajes compatibles incluyen: C, C ++, C # y Java.  Puede ejecutar el analizador en Windows, Linux y macOS. <br><br><h2>  Copiar y pegar errores tipográficos de nuevo! </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V523</a> La declaración 'then' es equivalente a la declaración 'else'.  Number.cc 4018 <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Number::square() { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mpfr_cmpabs(i_value-&gt;internalLowerFloat(), i_value-&gt;internalUpperFloat()) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { mpfr_sqr(f_tmp, i_value-&gt;internalLowerFloat(), MPFR_RNDU); mpfr_sub(f_rl, f_rl, f_tmp, MPFR_RNDD); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { mpfr_sqr(f_tmp, i_value-&gt;internalLowerFloat(), MPFR_RNDU); mpfr_sub(f_rl, f_rl, f_tmp, MPFR_RNDD); } .... }</code> </pre> <br>  El código es absolutamente el mismo en los bloques <i>if</i> y <i>else</i> <i>.</i>  Los fragmentos de código adyacentes son muy similares a este, pero se utilizan diferentes funciones en ellos: <i>internalLowerFloat ()</i> y <i>internalUpperFloat ()</i> .  Es seguro asumir que un desarrollador copió el código y se olvidó de corregir el nombre de la función aquí. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V501</a> Hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">subexpresiones</a> idénticas '! Mtr2.number (). IsReal ()' a la izquierda y a la derecha de '||'  operador  BuiltinFunctions.cc 6274 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> IntegrateFunction::calculate(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!mtr2.isNumber() || !mtr2.number().isReal() || !mtr.isNumber() || !mtr2.number().isReal()) b_unknown_precision = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; .... }</code> </pre> <br>  En este caso, aparecieron expresiones duplicadas debido al hecho de que en un lugar se escribió <i>mtr2 en</i> lugar de <i>mtr.</i>  Por lo tanto, una llamada de la función <i>mtr.number (). IsReal ()</i> está ausente en la condición. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V501</a> Hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">subexpresiones</a> idénticas 'vargs [1] .representsNonPositive ()' a la izquierda y a la derecha de '||'  operador  BuiltinFunctions.cc 5785 <br><br><br><br>  ¡Nunca habríamos encontrado defectos en este código manualmente!  Pero aquí los hay.  Además, en el archivo original, estos fragmentos están escritos en una sola línea.  El analizador ha detectado una expresión duplicada <i>vargs [1] .representsNonPositive ()</i> , que puede indicar un error tipográfico o, en consecuencia, un posible error. <br><br>  Aquí está la lista completa de lugares sospechosos, que apenas se pueden descifrar. <br><br><ul><li>  V501 Hay subexpresiones idénticas 'vargs [1] .representsNonPositive ()' a la izquierda y a la derecha de '||'  operador  BuiltinFunctions.cc 5788 </li><li>  V501 Hay subexpresiones idénticas 'anexar' a la izquierda y a la derecha del operador '&amp;&amp;'.  MathStructure.cc 1780 </li><li>  V501 Hay subexpresiones idénticas 'anexar' a la izquierda y a la derecha del operador '&amp;&amp;'.  MathStructure.cc 2043 </li><li>  V501 Hay subexpresiones idénticas '(* v_subs [v_order [1]]). Representa Negative (true)' a la izquierda y a la derecha del operador '&amp;&amp;'.  MathStructure.cc 5569 </li></ul><br><h2>  Bucle con condición incorrecta </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V534</a> Es probable que se compare una variable incorrecta dentro del operador 'for'.  Considere revisar 'i'.  MathStructure.cc 28741 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> MathStructure::isolate_x_sub(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; mvar-&gt;size(); i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((*mvar)[i].contains(x_var)) { mvar2 = &amp;(*mvar)[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mvar-&gt;isMultiplication()) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; mvar2-&gt;size(); i2++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((*mvar2)[i2].contains(x_var)) {mvar2 = &amp;(*mvar2)[i2]; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;} } } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } .... }</code> </pre> <br>  En el bucle interno, la variable <i>i2</i> representa un contador, pero debido a un error tipográfico se cometió un error: la variable <i>i</i> del bucle externo se usa en la condición de salida del bucle. <br><br><h2>  ¿Redundancia o un error? </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V590</a> Considere inspeccionar esta expresión.  La expresión es excesiva o contiene un error de imprenta.  Number.cc 6564 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Number::add(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Number &amp;o, MathOperation op) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i1 &gt;= COMPARISON_RESULT_UNKNOWN &amp;&amp; (i2 == COMPARISON_RESULT_UNKNOWN || i2 != COMPARISON_RESULT_LESS)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; .... }</code> </pre> <br>  Hace 3 años, después de haber visto ese código, escribí una hoja de trucos para mí y otros desarrolladores: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Expresiones lógicas en C / C ++. Errores cometidos por profesionales</a> ". Cuando me encuentro con ese código, me aseguro de que la nota no se ha vuelto menos relevante.  Puede consultar el artículo, encontrar un patrón del error correspondiente al código y descubrir todos los matices. <br><br>  En el caso de este ejemplo, iremos a la sección "Expresión == ||  ! = "Y descubra que la expresión <i>i2 == COMPARISON_RESULT_UNKNOWN</i> no afecta a nada. <br><br><h2>  Desreferencia de punteros no controlados </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V595</a> El puntero 'o_data' se utilizó antes de que se verificara contra nullptr.  Líneas de verificación: 1108, 1112. DataSet.cc 1108 <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span> DataObjectArgument::subprintlong() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> str = _(<span class="hljs-string"><span class="hljs-string">"an object from"</span></span>); str += <span class="hljs-string"><span class="hljs-string">" \""</span></span>; str += o_data-&gt;title(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= str += "\""; DataPropertyIter it; DataProperty *o = NULL; if(o_data) { // &lt;= o = o_data-&gt;getFirstProperty(&amp;it); } .... }</span></span></code> </pre> <br>  En una función, el puntero <i>o_data</i> se desreferencia tanto con un check como sin él.  Esto puede ser código redundante o un posible error.  Me estoy inclinando hacia lo último. <br><br>  Hay dos lugares similares: <br><br><ul><li>  V595 El puntero 'o_assumption' se utilizó antes de que se verificara contra nullptr.  Líneas de verificación: 229, 230. Variable.cc 229 </li><li>  V595 El puntero 'i_value' se utilizó antes de verificarlo con nullptr.  Líneas de verificación: 3412, 3427. Number.cc 3412 </li></ul><br><h2>  free () o eliminar []? </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V611</a> La memoria fue asignada usando el operador 'nuevo' pero fue liberada usando la función 'libre'.  Considere inspeccionar las lógicas de operación detrás de la variable 'remcopy'.  Number.cc 8123 <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Number::print(....) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!exact &amp;&amp; precision2 &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(try_infinite_series) { remcopy = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mpz_t</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// &lt;= mpz_init_set(*remcopy, remainder); } mpz_mul_si(remainder, remainder, base); mpz_tdiv_qr(remainder, remainder2, remainder, d); exact = (mpz_sgn(remainder2) == 0); if(!started) { started = (mpz_sgn(remainder) != 0); } if(started) { mpz_mul_si(num, num, base); mpz_add(num, num, remainder); } if(try_infinite_series) { if(started &amp;&amp; first_rem_check == 0) { remainders.push_back(remcopy); } else { if(started) first_rem_check--; mpz_clear(*remcopy); free(remcopy); // &lt;= } } .... } .... }</span></span></code> </pre> <br>  La memoria para la matriz de <i>remcopy</i> se asigna y libera de diferentes maneras, lo cual es un error grave. <br><br><h2>  Cambios perdidos </h2><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expand_partial_fractions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MathStructure &amp;m, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(b_poly &amp;&amp; !mquo.isZero()) { MathStructure m = mquo; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!mrem.isZero()) { m += mrem; m.last() *= mtest[i]; m.childrenUpdated(); } expand_partial_fractions(m, eo, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } .... }</code> </pre> <br>  La variable <i>m</i> en la función se pasa por referencia, lo que significa su modificación.  Sin embargo, el analizador ha detectado que el código contiene la variable con el mismo nombre, que se superpone al alcance del parámetro de la función, lo que permite la pérdida de cambios. <br><br><h2>  Punteros extraños </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V774</a> El puntero 'cu' se usó después de liberar la memoria.  Calculator.cc 3595 <br><br><pre> <code class="cpp hljs">MathStructure Calculator::convertToBestUnit(....) { .... CompositeUnit *cu = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompositeUnit(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"...."</span></span>); cu-&gt;add(....); Unit *u = getBestUnit(cu, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, eo.local_currency_conversion); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(u == cu) { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> cu; <span class="hljs-comment"><span class="hljs-comment">// &lt;= return mstruct_new; } delete cu; // &lt;= if(eo.approximation == APPROXIMATION_EXACT &amp;&amp; cu-&gt;hasApproximateRelationTo(u, true)) { // &lt;= if(!u-&gt;isRegistered()) delete u; return mstruct_new; } .... }</span></span></code> </pre> <br>  El analizador advierte que el código llama a un método del objeto <i>cu</i> justo después de desasignar la memoria.  Pero cuando se trata de lidiar con él, el código resulta aún más extraño.  En primer lugar, llamar a <i>delete cu</i> siempre ocurre, tanto en la condición como después de eso.  En segundo lugar, el código después de la condición implica que los punteros <i>u</i> y <i>cu</i> no son iguales, lo que significa que después de eliminar el objeto <i>cu</i> es bastante lógico usar el objeto <i>u</i> .  Lo más probable es que se haya cometido un error tipográfico en el código y el autor del código quería usar solo la variable <i>u</i> . <br><br><h2>  Uso de la función de búsqueda </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V797</a> La función 'buscar' se usa como si devolviera un tipo bool.  El valor de retorno de la función probablemente debería compararse con std :: string :: npos.  Unit.cc 404 <br><br><pre> <code class="cpp hljs">MathStructure &amp;AliasUnit::convertFromFirstBaseUnit(....) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i_exp != <span class="hljs-number"><span class="hljs-number">1</span></span>) mexp /= i_exp; ParseOptions po; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(isApproximate() &amp;&amp; suncertainty.empty() &amp;&amp; precision() == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sinverse.find(DOT) || svalue.find(DOT)) po.read_precision = READ_PRECISION_WHEN_DECIMALS; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> po.read_precision = ALWAYS_READ_PRECISION; } .... }</code> </pre> <br>  Aunque el código se puede compilar con éxito, parece sospechoso, ya que la función de <i>búsqueda</i> devuelve el número del tipo <i>std :: string :: size_type</i> .  La condición será verdadera si el punto se encuentra en cualquier parte de la cadena, excepto si el punto está al principio.  Es un cheque extraño.  No estoy seguro, pero, tal vez, este código debería reescribirse de la siguiente manera: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( sinverse.find(DOT) != <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos || svalue.find(DOT) != <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos) { po.read_precision = READ_PRECISION_WHEN_DECIMALS; }</code> </pre> <br><h2>  Posible fuga de memoria </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V701</a> realloc () posible fuga: cuando realloc () falla en la asignación de memoria, el puntero original 'buffer' se pierde.  Considere asignar realloc () a un puntero temporal.  util.cc 703 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">utf8_strdown</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *str, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> l)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> HAVE_ICU .... outlength = length + 4; buffer = (char*) realloc(buffer, outlength * sizeof(char)); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// &lt;= .... #else return NULL; #endif }</span></span></span></span></code> </pre> <br>  Cuando se trabaja con la función <i>realloc ()</i> , se recomienda utilizar un búfer intermedio, ya que en caso de que sea imposible asignar memoria, el puntero al área de memoria anterior se perderá irremediablemente. <br><br><h2>  Conclusión </h2><br>  El Qalculate!  El proyecto encabeza la lista de las mejores calculadoras gratuitas, mientras que contiene muchos errores graves.  Por otro lado, aún no hemos revisado sus competidores.  Intentaremos repasar todas las calculadoras populares. <br><br>  En cuanto a la comparación con la calidad de la calculadora del mundo de Windows, la utilidad de Microsoft parece más confiable y bien trabajada hasta ahora. <br><br>  Compruebe su propia "Calculadora": descargue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PVS-Studio</a> y pruébelo para su proyecto.  :-) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/443656/">https://habr.com/ru/post/443656/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443644/index.html">Roll huevos con unidad</a></li>
<li><a href="../443648/index.html">Documentación del usuario: qué lo hace malo y cómo solucionarlo</a></li>
<li><a href="../443650/index.html">Más o menos y sin tic. ¿Cuál es la diferencia entre los procesadores Intel Core de diferentes generaciones basados ​​en una arquitectura</a></li>
<li><a href="../443652/index.html">Todos los días en Outlook solo tengo harina ...</a></li>
<li><a href="../443654/index.html">Siguiendo el rastro de las calculadoras: calcular</a></li>
<li><a href="../443658/index.html">Configuración del clúster de Kubernetes HA en bare metal, monitoreo, registros y ejemplos de uso. Parte 3/3</a></li>
<li><a href="../443660/index.html">Expertos: "Un escáner 3D costará 10 veces más barato que un error con el control de calidad tradicional"</a></li>
<li><a href="../443662/index.html">Comprender el código limpio en Android</a></li>
<li><a href="../443664/index.html">Estación Meteorológica Arduino</a></li>
<li><a href="../443666/index.html">Nuestro enfoque para colorear hilos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>