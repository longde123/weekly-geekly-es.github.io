<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ô†Ô∏è üéØ ü§æ Pourquoi const n'acc√©l√®re-t-il pas le code C / C ++? üåÜ üëßüèΩ üí∑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a quelques mois, j'ai mentionn√© dans un article que c'√©tait un mythe, comme si const aide √† activer les optimisations du compilateur en C et C ++...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pourquoi const n'acc√©l√®re-t-il pas le code C / C ++?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/464777/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ck/cw/48/ckcw48o0aqklzf10gzhfqx8w3rw.jpeg"></div><br>  Il y a quelques mois, j'ai mentionn√© dans un article que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">c'√©tait un mythe, comme si const aide √† activer les optimisations du compilateur en C et C ++</a> .  J'ai d√©cid√© que cette d√©claration devait √™tre expliqu√©e, surtout parce que je croyais moi-m√™me en ce mythe auparavant.  Je commencerai par des exemples th√©oriques et artificiels, puis je passerai √† des exp√©riences et √† des tests bas√©s sur une v√©ritable base de code - SQLite. <br><a name="habracut"></a><br><h2>  Test simple </h2><br>  Commen√ßons par, comme il me semble, l'exemple le plus simple et le plus √©vident d'acc√©l√©rer le code C avec <code>const</code> .  Disons que nous avons deux d√©clarations de fonction: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *x)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constFunc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *x)</span></span></span></span>;</code> </pre> <br>  Et supposons qu'il existe deux versions du code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">byArg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, *x); func(x); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, *x); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constByArg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, *x); constFunc(x); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, *x); }</code> </pre> <br>  Pour ex√©cuter <code>printf()</code> , le processeur doit r√©cup√©rer <code>*x</code> de la m√©moire via un pointeur.  √âvidemment, l'ex√©cution de <code>constByArg()</code> peut √™tre l√©g√®rement plus rapide, car le compilateur sait que <code>*x</code> est une constante, il n'est donc pas n√©cessaire de charger √† nouveau sa valeur apr√®s que <code>constFunc()</code> ait fait.  Non?  Voyons le code assembleur g√©n√©r√© par GCC avec les optimisations activ√©es: <br><br><pre> <code class="bash hljs">$ gcc -S -Wall -O3 test.c $ view test.s</code> </pre> <br>  Et voici le r√©sultat complet de l'assembleur pour <code>byArg()</code> : <br><br><pre> <code class="plaintext hljs">byArg: .LFB23: .cfi_startproc pushq %rbx .cfi_def_cfa_offset 16 .cfi_offset 3, -16 movl (%rdi), %edx movq %rdi, %rbx leaq .LC0(%rip), %rsi movl $1, %edi xorl %eax, %eax call __printf_chk@PLT movq %rbx, %rdi call func@PLT # The only instruction that's different in constFoo movl (%rbx), %edx leaq .LC0(%rip), %rsi xorl %eax, %eax movl $1, %edi popq %rbx .cfi_def_cfa_offset 8 jmp __printf_chk@PLT .cfi_endproc</code> </pre> <br>  La seule diff√©rence entre le code assembleur g√©n√©r√© pour <code>byArg()</code> et <code>constByArg()</code> est que <code>constByArg()</code> a un <code>call constFunc@PLT</code> , comme dans le code source.  <code>const</code> lui-m√™me ne fait aucune diff√©rence. <br><br>  D'accord, c'√©tait GCC.  Peut-√™tre avons-nous besoin d'un compilateur plus intelligent.  Dis Clang. <br><br><pre> <code class="cpp hljs">$ clang -S -Wall -O3 -emit-llvm test.c $ view test.ll</code> </pre> <br>  Voici le code interm√©diaire.  Il est plus compact que l'assembleur, et je vais supprimer les deux fonctions, afin que vous compreniez ce que j'entends par ¬´aucune diff√©rence, sauf pour l'appel¬ª: <br><br><pre> <code class="cpp hljs">; Function Attrs: nounwind uwtable define dso_local <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @byArg(i32*) local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { %<span class="hljs-number"><span class="hljs-number">2</span></span> = load i32, i32* %<span class="hljs-number"><span class="hljs-number">0</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span>, !tbaa !<span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">3</span></span> = tail call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">4</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">4</span></span> x i8]* @.str, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>), i32 %<span class="hljs-number"><span class="hljs-number">2</span></span>) tail call <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @func(i32* %<span class="hljs-number"><span class="hljs-number">0</span></span>) #<span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">4</span></span> = load i32, i32* %<span class="hljs-number"><span class="hljs-number">0</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span>, !tbaa !<span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">5</span></span> = tail call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">4</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">4</span></span> x i8]* @.str, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>), i32 %<span class="hljs-number"><span class="hljs-number">4</span></span>) ret <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> } ; Function Attrs: nounwind uwtable define dso_local <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @constByArg(i32*) local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { %<span class="hljs-number"><span class="hljs-number">2</span></span> = load i32, i32* %<span class="hljs-number"><span class="hljs-number">0</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span>, !tbaa !<span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">3</span></span> = tail call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">4</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">4</span></span> x i8]* @.str, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>), i32 %<span class="hljs-number"><span class="hljs-number">2</span></span>) tail call <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @constFunc(i32* %<span class="hljs-number"><span class="hljs-number">0</span></span>) #<span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">4</span></span> = load i32, i32* %<span class="hljs-number"><span class="hljs-number">0</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span>, !tbaa !<span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">5</span></span> = tail call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">4</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">4</span></span> x i8]* @.str, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>), i32 %<span class="hljs-number"><span class="hljs-number">4</span></span>) ret <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> }</code> </pre> <br><h2>  Option qui (type) fonctionne </h2><br>  Et voici le code dans lequel la pr√©sence de <code>const</code> vraiment importante: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">localVar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, x); constFunc(&amp;x); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, x); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constLocalVar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">// const on the local variable printf("%d\n", x); constFunc(&amp;x); printf("%d\n", x); }</span></span></code> </pre> <br>  Le code assembleur pour <code>localVar()</code> , qui contient deux instructions optimis√©es en dehors de <code>constLocalVar()</code> : <br><br><pre> <code class="cpp hljs">localVar: .LFB25: .cfi_startproc subq $<span class="hljs-number"><span class="hljs-number">24</span></span>, %rsp .cfi_def_cfa_offset <span class="hljs-number"><span class="hljs-number">32</span></span> movl $<span class="hljs-number"><span class="hljs-number">42</span></span>, %edx movl $<span class="hljs-number"><span class="hljs-number">1</span></span>, %edi movq %fs:<span class="hljs-number"><span class="hljs-number">40</span></span>, %rax movq %rax, <span class="hljs-number"><span class="hljs-number">8</span></span>(%rsp) xorl %eax, %eax leaq .LC0(%rip), %rsi movl $<span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>(%rsp) call __printf_chk@PLT leaq <span class="hljs-number"><span class="hljs-number">4</span></span>(%rsp), %rdi call constFunc@PLT movl <span class="hljs-number"><span class="hljs-number">4</span></span>(%rsp), %edx <span class="hljs-meta"><span class="hljs-meta"># not in constLocalVar() xorl %eax, %eax movl $1, %edi leaq .LC0(%rip), %rsi # not in constLocalVar() call __printf_chk@PLT movq 8(%rsp), %rax xorq %fs:40, %rax jne .L9 addq $24, %rsp .cfi_remember_state .cfi_def_cfa_offset 8 ret .L9: .cfi_restore_state call __stack_chk_fail@PLT .cfi_endproc</span></span></code> </pre> <br>  Le middleware LLVM est un peu plus propre.  <code>load</code> avant le deuxi√®me appel √† <code>printf()</code> √©t√© optimis√© en dehors de <code>constLocalVar()</code> : <br><br><pre> <code class="cpp hljs">; Function Attrs: nounwind uwtable define dso_local <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @localVar() local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { %<span class="hljs-number"><span class="hljs-number">1</span></span> = alloca i32, align <span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">2</span></span> = bitcast i32* %<span class="hljs-number"><span class="hljs-number">1</span></span> to i8* call <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @llvm.lifetime.start.p0i8(i64 <span class="hljs-number"><span class="hljs-number">4</span></span>, i8* nonnull %<span class="hljs-number"><span class="hljs-number">2</span></span>) #<span class="hljs-number"><span class="hljs-number">4</span></span> store i32 <span class="hljs-number"><span class="hljs-number">42</span></span>, i32* %<span class="hljs-number"><span class="hljs-number">1</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span>, !tbaa !<span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">3</span></span> = tail call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">4</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">4</span></span> x i8]* @.str, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>), i32 <span class="hljs-number"><span class="hljs-number">42</span></span>) call <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @constFunc(i32* nonnull %<span class="hljs-number"><span class="hljs-number">1</span></span>) #<span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">4</span></span> = load i32, i32* %<span class="hljs-number"><span class="hljs-number">1</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span>, !tbaa !<span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">5</span></span> = call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">4</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">4</span></span> x i8]* @.str, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>), i32 %<span class="hljs-number"><span class="hljs-number">4</span></span>) call <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @llvm.lifetime.end.p0i8(i64 <span class="hljs-number"><span class="hljs-number">4</span></span>, i8* nonnull %<span class="hljs-number"><span class="hljs-number">2</span></span>) #<span class="hljs-number"><span class="hljs-number">4</span></span> ret <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> }</code> </pre> <br>  Ainsi, <code>constLocalVar()</code> r√©ussi √† ignorer le red√©marrage <code>*x</code> , mais vous remarquerez peut-√™tre quelque chose d'√©trange: dans les corps <code>localVar()</code> et <code>constLocalVar()</code> le m√™me appel √† <code>constFunc()</code> .  Si le compilateur peut comprendre que <code>constFunc()</code> n'a pas modifi√© <code>*x</code> dans <code>constLocalVar()</code> , alors pourquoi ne peut-il pas comprendre que le m√™me appel de fonction n'a pas modifi√© <code>*x</code> dans <code>localVar()</code> ? <br><br>  L'explication est pourquoi <code>const</code> en C n'est pas pratique √† utiliser comme optimisation.  En C, <code>const</code> a essentiellement deux significations possibles: <br><br><ul><li>  cela peut signifier qu'une variable est un pseudonyme en lecture seule pour certaines donn√©es, qui peuvent √™tre constantes ou non. <br></li><li>  ou cela peut signifier que la variable est vraiment une constante.  Si vous d√©tachez <code>const</code> d'un pointeur √† une valeur constante, puis que vous y √©crivez, vous obtiendrez un comportement ind√©fini.  En revanche, il n'y aura pas de probl√®me si <code>const</code> est un pointeur vers une valeur qui n'est pas une constante. <br></li></ul><br>  Voici un exemple explicatif d'impl√©mentation de <code>constFunc()</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// x is just a read-only pointer to something that may or may not be a constant void constFunc(const int *x) { // local_var is a true constant const int local_var = 42; // Definitely undefined behaviour by C rules doubleIt((int*)&amp;local_var); // Who knows if this is UB? doubleIt((int*)x); } void doubleIt(int *x) { *x *= 2; }</span></span></code> </pre><br>  <code>localVar()</code> donn√© √† <code>constFunc()</code> un pointeur <code>const</code> vers une variable non <code>const</code> .  Puisque la variable n'√©tait pas <code>const</code> initialement, <code>constFunc()</code> peut s'av√©rer √™tre un menteur et modifier la force avec force sans lancer UB.  Par cons√©quent, le compilateur ne peut pas supposer qu'apr√®s avoir renvoy√© <code>constFunc()</code> variable aura la m√™me valeur.  La variable dans <code>constLocalVar()</code> effet <code>const</code> , donc le compilateur ne peut pas supposer qu'elle ne sera pas modifi√©e, car cette fois ce <i>sera</i> UB pour <code>constFunc()</code> , de sorte que le compilateur d√©liera <code>const</code> et √©crit dans la variable. <br><br>  Les fonctions <code>byArg()</code> et <code>constByArg()</code> du premier exemple sont sans espoir, car le compilateur ne peut pas <code>constByArg()</code> si <code>*x</code> est <code>const</code> . <br><br>  Mais d'o√π vient l'incoh√©rence?  Si le compilateur peut supposer que <code>constFunc()</code> ne change pas son argument lorsqu'il est appel√© √† partir de <code>constLocalVar()</code> , alors il peut appliquer les m√™mes optimisations aux <code>constFunc()</code> , n'est-ce pas?  Non.  Le compilateur ne peut pas supposer que <code>constLocalVar()</code> sera jamais appel√© du tout.  Et si ce n'est pas le cas (par exemple, car il s'agit simplement d'un r√©sultat suppl√©mentaire du g√©n√©rateur de code ou de l'op√©ration de macro), <code>constFunc()</code> peut modifier les donn√©es en silence sans lancer UB. <br><br>  Vous devrez peut-√™tre lire les exemples et explications ci-dessus plusieurs fois.  Ne vous inqui√©tez pas, cela semble absurde - √ßa l'est.  Malheureusement, √©crire dans des variables <code>const</code> est le pire type d'UB: le plus souvent, le compilateur ne sait m√™me pas si ce sera UB.  Par cons√©quent, lorsque le compilateur voit <code>const</code> , il doit partir du fait que quelqu'un peut le modifier quelque part, ce qui signifie que le compilateur ne peut pas utiliser <code>const</code> pour l'optimisation.  En pratique, cela est vrai, car beaucoup de vrai code C contient un rejet de <code>const</code> dans le style "Je sais ce que je fais". <br><br>  En bref, il existe de nombreuses situations o√π le compilateur n'est pas autoris√© √† utiliser <code>const</code> pour l'optimisation, notamment la r√©cup√©ration de donn√©es d'une autre √©tendue √† l'aide d'un pointeur ou le placement de donn√©es sur un segment de m√©moire.  Ou pire encore, g√©n√©ralement dans des situations o√π le compilateur ne peut pas utiliser <code>const</code> , ce n'est pas n√©cessaire.  Par exemple, tout compilateur qui se respecte peut comprendre sans <code>const</code> que dans ce code <code>x</code> est une constante: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">42</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d %d\n"</span></span>, x, y); y += x; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d %d\n"</span></span>, x, y);</code> </pre> <br>  Donc <code>const</code> presque inutile pour l'optimisation, car: <br><br><ol><li>  √Ä quelques exceptions pr√®s, le compilateur est oblig√© de l'ignorer, car du code peut d√©lier l√©galement <code>const</code> . <br></li><li>  Dans la plupart des exceptions ci-dessus, le compilateur peut toujours comprendre que la variable est une constante. <br></li></ol><br><h2>  C ++ </h2><br>  Si vous √©crivez en C ++, <code>const</code> peut affecter la g√©n√©ration de code via une surcharge de fonction.  Vous pouvez avoir des surcharges <code>const</code> et non <code>const</code> de la m√™me fonction, et non <code>const</code> peut √™tre optimis√© (par un programmeur, pas un compilateur), par exemple, pour copier moins. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Needs to do more copying of data } void foo(const int *p) { // Doesn't need defensive copies } int main() { const int x = 42; // const-ness affects which overload gets called foo(&amp;x); return 0; }</span></span></code> </pre> <br>  D'une part, je ne pense pas que, dans la pratique, cela soit souvent appliqu√© dans le code C ++.  D'un autre c√¥t√©, pour que cela fasse vraiment une diff√©rence, un programmeur doit faire des hypoth√®ses qui ne sont pas disponibles pour le compilateur, car elles ne sont pas garanties par le langage. <br><br><h2>  Exp√©rimentez avec SQLite3 </h2><br>  Assez de th√©orie et d'exemples farfelus.  Quel effet <code>const</code> sur la base de code r√©elle?  J'ai d√©cid√© d'exp√©rimenter avec SQLite DB (version 3.30.0), car: <br><br><ul><li>  Il utilise <code>const.</code> </li><li>  Il s'agit d'une base de code non triviale (plus de 200 KLOC). <br></li><li>  En tant que base de donn√©es, il comprend un certain nombre de m√©canismes, commen√ßant par le traitement des valeurs de cha√Æne et se terminant par la conversion des nombres √† ce jour. <br></li><li>  Il peut √™tre test√© avec une charge limit√©e du processeur. <br></li></ul><br>  De plus, l'auteur et les programmeurs impliqu√©s dans le d√©veloppement ont d√©j√† pass√© des ann√©es √† am√©liorer la productivit√©, nous pouvons donc supposer qu'ils n'ont rien rat√© d'√©vident. <br><br><h3>  La pr√©paration </h3><br>  J'ai fait deux copies du <a href="">code source</a> .  Un compil√© en mode normal et le second pr√©trait√© √† l'aide d'un hack pour transformer <code>const</code> en une commande inactive: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> const</span></span></code> </pre> <br>  (GNU) <code>sed</code> peut ajouter ceci au-dessus de chaque fichier avec la commande <code>sed -i '1i#define const' *.c *.h</code> . <br><br>  SQLite complique un peu les choses, en utilisant des scripts pour g√©n√©rer du code lors de la construction.  Heureusement, les compilateurs introduisent beaucoup d'interf√©rences lors du m√©lange de code avec <code>const</code> et sans <code>const</code> , vous pouvez donc imm√©diatement remarquer et configurer les scripts pour ajouter mon code anti- <code>const</code> . <br><br>  La comparaison directe des codes compil√©s n'a pas de sens, car un petit changement peut affecter l'ensemble du sch√©ma de m√©moire, ce qui entra√Ænera un changement de pointeurs et d'appels de fonction dans tout le code.  Par cons√©quent, j'ai pris un cast d√©sassembl√© ( <code>objdump -d libSQLite3.so.0.8.6</code> ) comme taille du binaire et nom mn√©monique de chaque instruction.  Par exemple, cette fonction: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">000000000005</span></span>d570 &lt;SQLite3_blob_read&gt;: <span class="hljs-number"><span class="hljs-number">5</span></span>d570: <span class="hljs-number"><span class="hljs-number">4</span></span>c <span class="hljs-number"><span class="hljs-number">8</span></span>d <span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">59</span></span> a2 ff ff lea <span class="hljs-number"><span class="hljs-number">-0x5da7</span></span>(%rip),%r8 # <span class="hljs-number"><span class="hljs-number">577</span></span>d0 &lt;SQLite3BtreePayloadChecked&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>d577: e9 <span class="hljs-number"><span class="hljs-number">04</span></span> fe ff ff jmpq <span class="hljs-number"><span class="hljs-number">5</span></span>d380 &lt;blobReadWrite&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>d57c: <span class="hljs-number"><span class="hljs-number">0f</span></span> <span class="hljs-number"><span class="hljs-number">1f</span></span> <span class="hljs-number"><span class="hljs-number">40</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> nopl <span class="hljs-number"><span class="hljs-number">0x0</span></span>(%rax)</code> </pre> <br>  Se transforme en: <br><br><pre> <code class="cpp hljs">SQLite3_blob_read <span class="hljs-number"><span class="hljs-number">7l</span></span>ea <span class="hljs-number"><span class="hljs-number">5</span></span>jmpq <span class="hljs-number"><span class="hljs-number">4</span></span>nopl</code> </pre> <br>  Lors de la compilation, je n'ai pas modifi√© les param√®tres de l'assembly SQLite. <br><br><h3>  Analyse de code compil√© </h3><br>  Pour libSQLite3.so, la version avec <code>const</code> occupait 4 740 704 octets, environ 0,1% de plus que la version sans <code>const</code> avec 4 736 712 octets.  Dans les deux cas, 1374 fonctions ont √©t√© export√©es (sans compter les fonctions d'assistance de bas niveau dans le PLT) et 13 pr√©sentaient des diff√©rences dans les transtypages. <br><br>  Certaines modifications √©taient li√©es au hack de pr√©traitement.  Par exemple, voici l'une des fonctions modifi√©es (j'ai supprim√© certaines d√©finitions sp√©cifiques √† SQLite): <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LARGEST_INT64 (0xffffffff|(((int64_t)0x7fffffff)</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt;32)) #define SMALLEST_INT64 (((int64_t)-1) - LARGEST_INT64) static int64_t doubleToInt64(double r){ /* ** Many compilers we encounter do not define constants for the ** minimum and maximum 64-bit integers, or they define them ** inconsistently. And many do not understand the "LL" notation. ** So we define our own static constants here using nothing ** larger than a 32-bit integer constant. */ static const int64_t maxInt = LARGEST_INT64; static const int64_t minInt = SMALLEST_INT64; if( r&lt;=(double)minInt ){ return minInt; }else if( r&gt;=(double)maxInt ){ return maxInt; }else{ return (int64_t)r; } }</span></span></span></span></code> </pre> <br>  Si nous supprimons <code>const</code> , ces constantes se transforment en variables <code>static</code> .  Je ne comprends pas pourquoi quiconque ne se soucie pas de <code>const</code> rendre ces variables <code>static</code> .  Si nous supprimons √† la fois <code>static</code> et <code>const</code> , GCC les consid√©rera √† nouveau comme des constantes et nous obtiendrons le m√™me r√©sultat.  En raison de ces variables <code>static const</code> stat, les changements dans trois fonctions sur treize se sont r√©v√©l√©s faux, mais je ne les ai pas corrig√©s. <br><br>  SQLite utilise de nombreuses variables globales, et la majorit√© des vraies optimisations <code>const</code> sont li√©es √† cela: comme remplacer une comparaison par une variable par une comparaison avec une constante, ou faire reculer partiellement la boucle d'une √©tape (pour comprendre quel type d'optimisations ont √©t√© faites, j'ai utilis√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Radare</a> ).  Quelques changements ne valent pas la peine d'√™tre mentionn√©s.  <code>SQLite3ParseUri()</code> contient 487 instructions, mais <code>const</code> n'a apport√© qu'une seule modification: a pris ces deux comparaisons: <br><br><pre> <code class="cpp hljs">test %al, %al je &lt;SQLite3ParseUri+<span class="hljs-number"><span class="hljs-number">0x717</span></span>&gt; cmp $<span class="hljs-number"><span class="hljs-number">0x23</span></span>, %al je &lt;SQLite3ParseUri+<span class="hljs-number"><span class="hljs-number">0x717</span></span>&gt;</code> </pre> <br>  Et √©chang√©: <br><br><pre> <code class="cpp hljs">cmp $<span class="hljs-number"><span class="hljs-number">0x23</span></span>, %al je &lt;SQLite3ParseUri+<span class="hljs-number"><span class="hljs-number">0x717</span></span>&gt; test %al, %al je &lt;SQLite3ParseUri+<span class="hljs-number"><span class="hljs-number">0x717</span></span>&gt;</code> </pre> <br><h3>  Rep√®res </h3><br>  SQLite est livr√© avec un test de r√©gression pour mesurer les performances, et je l'ai ex√©cut√© des centaines de fois pour chaque version du code en utilisant les param√®tres de g√©n√©ration SQLite standard.  Temps d'ex√©cution en secondes: <br><br><div class="scrollable-table"><table><tbody><tr><td></td><td>  const <br></td><td>  Sans const <br></td></tr><tr><td>  Minimum <br></td><td>  10 658 <br></td><td>  10 803 <br></td></tr><tr><td>  M√©diane <br></td><td>  11 571 <br></td><td>  11,519 <br></td></tr><tr><td>  Maximum <br></td><td>  11 832 <br></td><td>  11 658 <br></td></tr><tr><td>  Moyenne <br></td><td>  11,531 <br></td><td>  11 492 <br></td></tr></tbody></table></div><br>  Personnellement, je ne vois pas beaucoup de diff√©rence.  J'ai supprim√© <code>const</code> de tout le programme, donc s'il y avait une diff√©rence notable, il √©tait facile de le remarquer.  Cependant, si les performances sont extr√™mement importantes pour vous, m√™me une petite acc√©l√©ration peut vous plaire.  Faisons une analyse statistique. <br><br>  J'aime utiliser le test Mann-Whitney U pour de telles t√¢ches. Il est similaire au test t plus connu, con√ßu pour d√©terminer les diff√©rences entre les groupes, mais est plus r√©sistant aux variations al√©atoires complexes qui se produisent lors de la mesure du temps sur les ordinateurs (en raison de changements de contexte impr√©visibles, d'erreurs dans pages de m√©moire, etc.).  Voici le r√©sultat: <br><br><div class="scrollable-table"><table><tbody><tr><th></th><th>  const </th><th>  Sans const </th></tr><tr><td>  N </td><td>  100 </td><td>  100 </td></tr><tr><td>  Cat√©gorie moyenne (rang moyen) </td><td>  121,38 </td><td>  79,62 </td></tr><tr><td>  Mann-whitney u </td><td></td><td>  2912 </td></tr><tr><td>  Z </td><td></td><td>  -5,10 </td></tr><tr><td>  Valeur p bilat√©rale </td><td></td><td>  &lt;10 <sup>-6</sup> <br></td></tr><tr><td>  La diff√©rence moyenne est HL <br></td><td></td><td>  -0,056 s. <br></td></tr><tr><td>  Intervalle de confiance √† 95% <br></td><td></td><td>  -0,077 ... -0,038 s. <br></td></tr></tbody></table></div><br>  Le test U a r√©v√©l√© une diff√©rence statistiquement significative dans les performances.  Mais - une surprise!  - La version sans <code>const</code> s'est av√©r√©e plus rapide, d'environ 60 ms, soit 0,5%.  Il semble que le petit nombre d '¬´optimisations¬ª effectu√©es ne valait pas l'augmentation du volume de code.  Il est peu probable que <code>const</code> activ√© des optimisations majeures, telles que l'auto-vectorisation.  Bien s√ªr, votre kilom√©trage peut d√©pendre de divers indicateurs du compilateur, ou de sa version, ou de la base de code, ou d'autre chose.  Mais il me semble honn√™te de dire que m√™me si <code>const</code> am√©lior√© les performances de C, je ne l'ai pas remarqu√©. <br><br><h2>  Alors, √† quoi sert const? </h2><br>  Pour tous ses d√©fauts, <code>const</code> en C / C ++ est utile pour assurer la s√©curit√© des types.  En particulier, si vous utilisez <code>const</code> en combinaison avec la s√©mantique de d√©placement et <code>std::unique_pointer</code> , vous pouvez impl√©menter la propri√©t√© explicite du pointeur.  L'incertitude de la propri√©t√© du pointeur √©tait un √©norme probl√®me dans les anciennes bases de code C ++ de plus de 100 KLOC, donc je suis reconnaissant de <code>const</code> pour le r√©soudre. <br><br>  Cependant, avant d'aller au-del√† de l'utilisation de <code>const</code> pour assurer la s√©curit√© des types.  J'ai entendu dire qu'il √©tait jug√© correct d'utiliser <code>const</code> plus activement possible pour am√©liorer les performances.  J'ai entendu dire que si les performances √©taient vraiment importantes, il fallait refactoriser le code pour ajouter plus de <code>const</code> , m√™me si le code devenait moins lisible.  Cela semblait raisonnable √† l'√©poque, mais depuis lors, j'ai r√©alis√© que ce n'√©tait pas vrai. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr464777/">https://habr.com/ru/post/fr464777/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr464761/index.html">Un petit mod transforme Tesla en station de vid√©osurveillance</a></li>
<li><a href="../fr464763/index.html">Benchmarks pour les serveurs sous Linux: une s√©lection d'outils ouverts</a></li>
<li><a href="../fr464765/index.html">Configuration de FreePBX + GoIP</a></li>
<li><a href="../fr464773/index.html">Typescript asynchrone dans une application Internet riche et des d√©corateurs pour le combattre</a></li>
<li><a href="../fr464775/index.html">21 septembre Badoo PHP Meetup # 3: Performances</a></li>
<li><a href="../fr464779/index.html">√Ä propos des abeilles h√©donistes, de la fa√ßon dont les gens les font fonctionner et des drones</a></li>
<li><a href="../fr464785/index.html">Avantages non comp√©titifs de Beeline</a></li>
<li><a href="../fr464787/index.html">Je suis s√ªr que le d√©veloppeur mobile senior ne viendra que sur recommandation</a></li>
<li><a href="../fr464791/index.html">Kubernetes pour la voiture: comment ouvrir l'acc√®s du d√©veloppeur √† l'ordinateur de bord et le s√©curiser</a></li>
<li><a href="../fr464795/index.html">Joyeux Quartusel, ou comment le processeur est arriv√© √† une telle vie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>