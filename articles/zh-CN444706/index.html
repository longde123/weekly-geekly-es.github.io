<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏍️ 💎 🔲 内部3D Facebook照片：视差着色器 ⏭️ 🦕 ☮️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在过去的几个月中，Facebook充斥了3D照片 。 如果您看不到它们，那么我将解释：3D照片是帖子内的图像，当滚动页面或将鼠标移到它们上方时，它们会平滑地改变角度。 

 在此功能出现前的几个月，Facebook用3D模型测试了类似的功能。 尽管您可以轻松了解Facebook如何渲染3D模型并根据...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>内部3D Facebook照片：视差着色器</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444706/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/653/7e9/cda/6537e9cdaff76aa8cc2716b8b53ecba9.gif" alt="图片"></div><br> 在过去的几个月中，Facebook充斥了<strong>3D照片</strong> 。 如果您看不到它们，那么我将解释：3D照片是帖子内的图像，当滚动页面或将鼠标移到它们上方时，它们会平滑地改变角度。 <br><br> 在此功能出现前的几个月，Facebook用3D模型测试了类似的功能。 尽管您可以轻松了解Facebook如何渲染3D模型并根据鼠标的位置旋转3D模型，但使用3D照片时，情况可能并非如此直观。 <br><br>  Facebook用于创建二维图像的三维度的技术有时称为<strong>高程图偏移量</strong> 。 它使用一种称为<strong>视差</strong>的光学现象。 <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">3D Facebook照片（GIF）的示例</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a06/0f6/cbd/a060f6cbde767809731fea11f26034a4.gif"></div></div></div><br><h2> 什么是视差 </h2><br> 如果您玩过《超级马里奥》，那么您确切地知道什么是视差。 尽管Mario的运行速度相同，但似乎背景中的远处物体移动得较慢（请参见下文）。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33a/b4f/3b3/33ab4f3b3e14cc710feb881f935d5162.gif"></div><br> 这种效果产生了一种幻觉，即某些元素（例如山和云）位于更远的地方。 之所以有效，是因为我们的大脑使用视差（以及其他视觉线索）来估计到远处物体的距离。 <br><br><div class="spoiler">  <b class="spoiler_title">大脑如何评估距离？</b> <div class="spoiler_text"> 假设人脑使用多种机制来估计距离。 在中短距离范围内，通过比较右眼和左眼可见物体的位置差异来计算距离。 这称为<strong>立体视觉，</strong>并且在自然界很普遍。 <br><br> 但是，对于足够远的物体，仅凭一个立体视觉是不够的。 山，云和恒星的差异太小，以至于不同的眼睛看不到明显的差异。 因此，相对视差起作用。 后台的对象移动少于前景的对象。 它们的相对运动使您可以设置相对距离。 <br><br> 在距离的感知中，使用了许多其他机制。 其中最著名的是大气雾度，它使远处的物体呈现蓝色。 在其他世界中，大多数这些大气线索都不存在，因此很难评估其他行星和月球上物体的规模。  YouTube用户Alex McCulgan在其<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener">Astrum</a>频道上对此进行了解释，表明确定视频中显示的月球物体的尺寸有多么困难。 <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/5yx3O9cZ5NM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><br><h2> 视差转变 </h2><br> 如果您熟悉线性代数，那么您可能知道3D旋转的数学是多么复杂和不平凡。 因此，有一种更简单的理解视差的方法，它只需要移动即可。 <br><br> 假设我们正在看一个多维数据集（见下文）。 如果我们精确地将其中心对齐，则正面和背面将看起来像两个大小不同的正方形。 这是<strong>前景</strong> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bac/1ac/714/bac1ac714202cd1fa2e3608646970dca.png"></div><br> 但是，如果我们向下移动摄像机或向上抬起立方体会发生什么？ 应用相同的原理，我们可以看到正面和背面相对于其先前位置发生了偏移。 更有趣的是，他们彼此之间已经相对移动。 离我们更远的背面，好像移动少了。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d8/25a/0e1/4d825a0e105c808d87e1b5995f2faef1.png"></div><br> 如果我们要计算投影范围内立方体的这些顶点的真实位置，那么我们将不得不认真考虑三角学。 但是，这并不是必须的。 如果摄影机的运动足够小，那么我们可以近似估计顶点的位移，并按其距离成比例地移动它们。 <br><br> 我们唯一需要确定的是规模。 如果我们向右移动X米，则看起来Y米以外的对象已经移动了Z米。 如果X保持较小，则视差将成为<strong>线性插值</strong>而不是三角函数的任务。 从本质上讲，这意味着我们可以根据像素与相机之间的距离移动像素来模拟3D旋转。 <br><br><h2> 生成深度图 </h2><br> 原则上，Facebook所做的与Super Mario中所做的没有太大不同。 对于给定的图片，某些像素会根据到相机的距离在运动方向上移动。 要创建Facebook的3D照片，您只需要照片本身和一张地图即可知道每个像素距相机的距离。 这样的地图具有预期的名称- <strong>“深度图”</strong> 。 根据上下文<strong>，</strong>它也称为<strong>高度图</strong> 。 <br><br> 拍摄照片非常简单，但是生成正确的深度图则要困难得多。 现代设备使用各种技术。 大多数情况下使用两个摄像头。 每个人都拍摄相同主题的照片，但视角略有不同。  <strong>立体视觉中</strong>使用相同的原理，人们用来评估中短距离的深度。 下图显示了iPhone 7如何从两个非常接近的图像创建深度图。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/903/ab0/c03/903ab0c0376f7978c771352d82b5f648.png"></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener">Peter Hedman</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener">Johannes Kopf</a>在SIGGRAPH2018上发表的文章<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener">Instant 3D Photography</a>中描述了这种重建的实现细节。 <br><br> 创建高质量的深度图后，模拟三维几乎成为一件微不足道的任务。 该技术的真正局限性在于，即使您可以重新创建粗糙的3D模型，它也缺少有关如何渲染原始照片中不可见的零件的信息。 目前，此问题无法解决，因此，在3D照片中可见的所有运动都微不足道。 <br><br> 我们熟悉3D照片的概念，并简要讨论了现代智能手机如何创建它们。 在第二部分中，我们将学习如何使用相同的技术使用着色器在Unity中实现3D照片。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/653/7e9/cda/6537e9cdaff76aa8cc2716b8b53ecba9.gif"></div><br><h2> 第2部分。视差着色器和深度图 </h2><br><h4> 着色器模板 </h4><br> 如果要使用着色器重新创建Facebook的3D照片，则必须首先决定要做什么。 由于此效果最适合2D图像，因此实现与Unity Sprite兼容的解决方案是合乎逻辑的。 我们将创建一个可以与<strong>Sprite Renderer</strong>一起使用的着色<strong>器</strong> 。 <br><br> 尽管可以从头开始创建这样的着色器，但通常最好从现成的模板开始。 最好通过复制现有的精灵漫反射着色器来开始前进，Unity默认将其用于所有精灵。 不幸的是，该引擎没有附带可自行编辑的<em>着色器</em>文件。 <br><br> 要获取它，您需要转到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener">Unity下载档案</a>并下载所使用引擎版本的“ <em>内置着色器”</em>包（见下文）。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d00/1b9/da8/d001b9da891e60ef4b93f89ffb8a9fda.png"></div><br> 解压缩软件包后，您可以查看Unity随附的所有着色器的源代码。 我们对<em>Sprites-Diffuse.shader</em>文件感兴趣，该文件默认情况下用于所有已创建<em>的Sprite</em> 。 <br><br><h2> 图片 </h2><br> 需要形式化的第二个方面是我们拥有的数据。 想象一下，我们既要设置动画图像，又要设置深度图。 后者将是黑白图像，其中黑白像素表示它们距相机的距离或距离。 <br><br> 本教程中使用的图像取自<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener">Dennis Hotson的</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener">Pickle cat</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener">项目</a> ，这无疑是您今天所能看到的最好的图像。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/03c/9ee/9c0/03c9ee9c0a5f15908ea183bf0b4bea98.png"></div><br> 与此图像相关联的高度图反映了猫的脸距相机的距离。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/54c/f5b/d2d/54cf5bd2d93144efb7371c3076b6541c.jpg"></div><br> 如此简单的深度图可以很容易地看到如何获得良好的效果。 这意味着为现有图像创建自己的深度图很容易。 <br><br><h2> 属性 </h2><br> 现在我们拥有所有资源，我们可以开始编写视差着色器代码。 如果将主图像导入为精灵，则Unity将通过<code>_MainTex</code>属性将其自动传递到着色器。 但是，我们需要使深度图可用于着色器。 这可以使用名为<code>_HeightTex</code>的新<strong>着色器属性</strong>来实现。 我故意决定不将其<code>_DepthTex</code>为<code>_DepthTex</code> ，以免将其与<strong>深度纹理</strong>混淆（这是用于渲染场景深度图的类似Unity概念）。 <br><br> 要更改效果的强度，我们还将添加<code>_Scale</code>属性。 <br><br><pre> <code class="cpp hljs">Properties { ... _HeightTex (<span class="hljs-string"><span class="hljs-string">"Heightmap (R)"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"gray"</span></span> {} _Scale (<span class="hljs-string"><span class="hljs-string">"Scale"</span></span>, Vector) = (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) }</code> </pre> <br> 这两个新属性还应该对应于两个具有相同名称的变量，需要将其添加到<code>CGPROGRAM</code> / <code>ENDCG</code> ： <br><br><pre> <code class="cpp hljs">sampler2D _HeightTex; fixed2 _Scale;</code> </pre> <br> 现在一切就绪，我们可以开始编写将执行偏移的代码。 <br><br> 第一步是从深度图采样值，这可以使用<code>tex2D</code>函数完成。 由于<code>_HeightTex</code>是黑白纹理，因此我们可以采用其红色通道并丢弃其余通道。 结果值测量从当前像素到相机的任意单位距离。 <br><br> 深度值介于 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>0</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/444706/&amp;usg=ALkJrhixTT-tNIH3ptGHTLy8GMkEac0BVg#MJMAIN-30" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>0</mn></math></span></span><script type="math/tex" id="MathJax-Element-1"> 0 </script> 之前 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/444706/&amp;usg=ALkJrhixTT-tNIH3ptGHTLy8GMkEac0BVg#MJMAIN-31" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-2"> 1 </script> 但我们将其延伸到 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo>&amp;#x2212;</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.971ex" height="2.057ex" viewBox="0 -728.2 1279 885.9" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/444706/&amp;usg=ALkJrhixTT-tNIH3ptGHTLy8GMkEac0BVg#MJMAIN-2212" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/444706/&amp;usg=ALkJrhixTT-tNIH3ptGHTLy8GMkEac0BVg#MJMAIN-31" x="778" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo>−</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-3"> -1 </script> 之前 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo>+</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.971ex" height="2.057ex" viewBox="0 -728.2 1279 885.9" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/444706/&amp;usg=ALkJrhixTT-tNIH3ptGHTLy8GMkEac0BVg#MJMAIN-2B" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/444706/&amp;usg=ALkJrhixTT-tNIH3ptGHTLy8GMkEac0BVg#MJMAIN-31" x="778" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-4"> + 1 </script>  。 这使您可以提供正（白色）和负（黑色）视差。 <br><br><h2> 理论 </h2><br> 为了在此阶段模拟视差效果，我们需要使用深度信息来移动图像的像素。 像素越近，需要移动的越强。 下图说明了此过程。 根据深度图的信息， <em>原始图像</em>的红色像素应向左移动两个像素。 同样，蓝色像素应向右移动两个像素。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/457/008/e69/457008e692048d9b5ef8eb2964f35fe2.png"></div><br> 尽管从<em>理论上讲</em>这应该可行，但是没有简单的方法可以在着色器中实现它。 事实是，着色器根据其原理只能更改<em>当前</em>像素的颜色。 当执行着色器代码时，它必须在屏幕上绘制一个特定的像素。 我们不能只是将像素移动到另一个地方或更改相邻像素的颜色。  <em>局部性的</em>这种<em>限制</em>提供了着色器的非常有效的并行操作，但是，如果可以<em>随机访问记录</em>到图像中的每个像素，则不允许我们实现所有琐碎的效果。 <br><br> 如果我们想精确，那么我们需要对所有相邻像素的深度图进行采样，以找出应该（如果应该）移动到当前位置的像素。 如果几个像素应位于同一位置，则可以平均它们的影响。 尽管这样的系统可以工作并提供最好的结果，但它效率极低，并且可能比我们最初使用的原始漫射着色器慢数百倍。 <br><br> 最好的替代方法是以下解决方案：从深度图获取当前像素的深度； 然后，如果需要将其<em>向右移动</em> ，则将当前颜色替换<em>为左侧</em>的像素（请参见下图）。 在这里，我们假设如果您想向右移动像素，那么左侧的相邻像素也应该以相同的方式移动。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/699/cc8/7c0/699cc87c06761842edfc77449c195b43.png"></div><br> 显而易见，这只是我们真正想要实现的目标的低成本近似。 但是，它非常有效，因为深度图通常证明是平滑的。 <br><br><h2> 代号 </h2><br> 按照上一节中描述的算法，我们可以使用简单<strong>的UV坐标偏移</strong>来实现视差着色器。 <br><br> 这将导致以下代码： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutput o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Displacement fixed height = tex2D(_HeightTex, IN.uv_MainTex).r; fixed2 displacement = _Scale * ((height - 0.5) * 2); fixed4 c = SampleSpriteTexture (IN.uv_MainTex - displacement) * IN.color; ... }</span></span></code> </pre> <br> 如下面的动画所示，该技术几乎可以处理几乎平坦的对象。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ba/0c4/b8f/8ba0c4b8fa0fc51bf86c0874139feedb.gif"></div><br> 但这确实适用于3D模型，因为为3D场景渲染深度纹理非常容易。 以下是3D渲染的图像及其深度图。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/701/179/d0f/701179d0f52d53b25f9d079d60dc8ae3.jpg"></div><br> 完成的结果如下所示： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51d/134/28c/51d13428ce1f6b84cbb6b62984f86fe4.gif"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN444706/">https://habr.com/ru/post/zh-CN444706/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN444692/index.html">MOSDROID＃16 Redmadrobot中的硫</a></li>
<li><a href="../zh-CN444694/index.html">正如我们预测的那样，将其视为自然灾害</a></li>
<li><a href="../zh-CN444696/index.html">使用PFCACHE技术提高节点上的容器密度</a></li>
<li><a href="../zh-CN444700/index.html">随机数据库。 Oracle企业数据质量-企业存储的盾牌和剑</a></li>
<li><a href="../zh-CN444704/index.html">局促的条件下，nanoCAD SPDS施工现场在建设和重建项目中的机会</a></li>
<li><a href="../zh-CN444708/index.html">带有GraphQL的PentQL应用程序</a></li>
<li><a href="../zh-CN444710/index.html">了解恒星共识协议</a></li>
<li><a href="../zh-CN444712/index.html">“对财务的非典型态度”-如果员工自己可以管理收入怎么办。 与Flant对话</a></li>
<li><a href="../zh-CN444714/index.html">我们如何超频CAD COMPASS-3D→第1部分</a></li>
<li><a href="../zh-CN444716/index.html">带有可折叠屏幕，售价2000美元的三星手机显示折痕</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>