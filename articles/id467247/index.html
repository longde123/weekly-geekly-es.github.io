<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏾 🙀 👯 Sebuah kisah tentang V8, React dan penurunan kinerja. Bagian 1 👨‍🔧 🐚 🎚️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Materi, bagian pertama dari terjemahan yang kami terbitkan hari ini, akan membahas bagaimana mesin JavaScript V8 memilih cara terbaik untuk mewakili b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sebuah kisah tentang V8, React dan penurunan kinerja. Bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/467247/">  Materi, bagian pertama dari terjemahan yang kami terbitkan hari ini, akan membahas bagaimana mesin JavaScript V8 memilih cara terbaik untuk mewakili berbagai nilai JS dalam memori, dan bagaimana hal ini memengaruhi mekanisme internal V8 terkait bekerja dengan apa yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">formulir benda</a> (Bentuk).  Semua ini akan membantu kami memilah esensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masalah kinerja Bereaksi</a> baru-baru ini. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/pu/wk/8i/puwk8ihuo_in6vqmeg86j2-5sxa.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Tipe data JavaScript</font> </h2><br>  Setiap nilai JavaScript hanya dapat memiliki satu dari delapan tipe data yang ada: <code>Number</code> , <code>String</code> , <code>Symbol</code> , <code>BigInt</code> , <code>Boolean</code> , <code>Undefined</code> , <code>Null</code> dan <code>Object</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36e/5e0/3fb/36e5e03fb481b601d2bb1cc61a1fa2f4.png"></div><br>  <i><font color="#999999">Tipe data JavaScript</font></i> <br><br>  Jenis nilai dapat ditentukan menggunakan operator <code>typeof</code> , tetapi ada satu pengecualian penting: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 'number' typeof 'foo'; // 'string' typeof Symbol('bar'); // 'symbol' typeof 42n; // 'bigint' typeof true; // 'boolean' typeof undefined; // 'undefined' typeof null; // 'object' -   ,     typeof { x: 42 }; // 'object'</span></span></code> </pre> <br>  Seperti yang Anda lihat, perintah <code>typeof null</code> mengembalikan <code>'object'</code> , bukan <code>'null'</code> , meskipun fakta bahwa <code>null</code> memiliki tipe sendiri - <code>Null</code> .  Untuk memahami alasan <code>typeof</code> perilaku ini, kami memperhitungkan fakta bahwa rangkaian semua tipe JavaScript dapat dibagi menjadi dua grup: <br><br><ul><li>  Objek (mis., Ketik <code>Object</code> ). </li><li>  Nilai-nilai primitif (yaitu, nilai-nilai non-objektif). </li></ul><br>  Dalam terang pengetahuan ini, ternyata <code>null</code> berarti "tidak ada nilai objek", sedangkan <code>undefined</code> berarti "tidak ada nilai". <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e9/8e6/c97/0e98e6c97b3e87411146a60f1c67cf8e.png"></div><br>  <i><font color="#999999">Nilai-nilai primitif, objek, null dan tidak terdefinisi</font></i> <br><br>  Mengikuti refleksi-refleksi ini dalam semangat Java, Brendan Eich mendesain JavaScript sehingga <code>typeof</code> operator akan mengembalikan <code>'object'</code> untuk nilai-nilai tipe-tipe yang terletak pada gambar sebelumnya di sebelah kanan.  Semua nilai objek dan <code>null</code> sampai di sini.  Itulah sebabnya ekspresi <code>typeof null === 'object'</code> benar, walaupun ada tipe terpisah <code>Null</code> dalam spesifikasi bahasa. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/23e/df7/0e2/23edf70e2101cc687a759653f150305d.png"></div><br>  <i><font color="#999999">Ekspresi typeof v === 'objek' benar</font></i> <br><br><h2>  <font color="#3AC1EF">Representasi Nilai</font> </h2><br>  Mesin JavaScript harus dapat mewakili nilai JavaScript apa pun dalam memori.  Namun, penting untuk dicatat bahwa tipe nilai dalam JavaScript terpisah dari bagaimana mesin JS merepresentasikannya dalam memori. <br><br>  Misalnya, nilai 42 dalam JavaScript adalah <code>number</code> jenis. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 'number'</span></span></code> </pre> <br>  Ada beberapa cara untuk merepresentasikan bilangan bulat seperti 42 di memori: <br><div class="scrollable-table"><table><tbody><tr><td>  Kiriman <br></td><td>  Bits <br></td></tr><tr><td>  8 bit, selain dua <br></td><td>  0010 1010 <br></td></tr><tr><td>  32 bit, dengan penambahan hingga dua <br></td><td>  0000 0000 0000 0000 0000 0010 1010 <br></td></tr><tr><td>  Packed binary-coded decimal (BCD) <br></td><td>  0100 0010 <br></td></tr><tr><td>  32 bit, nomor floating point IEEE-754 <br></td><td>  0 100 0010 0010 1000 0000 0000 0000 0000 <br></td></tr><tr><td>  64 bit, nomor floating point IEEE-754 <br></td><td>  0100 0000 0100 0101 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 <br></td></tr></tbody></table></div><br>  Menurut standar ECMAScript, angka adalah nilai floating point 64-bit, yang dikenal sebagai angka floating-point presisi ganda (Float64).  Namun, ini tidak berarti bahwa mesin JavaScript selalu menyimpan angka dalam tampilan Float64.  Itu akan sangat, sangat tidak efisien!  Engine dapat menggunakan representasi internal lainnya dari angka - selama perilaku nilai tersebut sama persis dengan bagaimana perilaku angka Float64. <br><br>  Sebagian besar angka dalam aplikasi JS nyata, ternyata, adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">indeks</a> array ECMAScript yang valid.  Yaitu - bilangan bulat dalam rentang dari 0 hingga 2 <sup>32</sup> -2. <br><br><pre> <code class="javascript hljs">array[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//      . array[42]; array[2**32-2]; //      .</span></span></code> </pre> <br>  Mesin JavaScript dapat memilih format optimal untuk mewakili nilai-nilai tersebut dalam memori.  Ini dilakukan untuk mengoptimalkan kode yang berfungsi dengan elemen array menggunakan indeks.  Prosesor yang melakukan operasi akses memori memerlukan indeks array tersedia sebagai angka yang disimpan dalam tampilan dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tambahan dua</a> .  Jika sebaliknya kami mewakili indeks array dalam bentuk nilai Float64, ini akan berarti pemborosan sumber daya sistem, karena mesin kemudian perlu mengkonversi angka Float64 ke format dengan penambahan dua dan sebaliknya setiap kali seseorang mengakses elemen array. <br><br>  Representasi angka 32-bit dengan penambahan hingga dua bermanfaat tidak hanya untuk mengoptimalkan kerja dengan array.  Secara umum, dapat dicatat bahwa prosesor melakukan operasi integer jauh lebih cepat daripada operasi yang menggunakan nilai floating point.  Itulah sebabnya dalam contoh berikut, siklus pertama tanpa masalah dua kali lebih cepat dibandingkan dengan siklus kedua. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; ++i) {  <span class="hljs-comment"><span class="hljs-comment">//  } for (let i = 0.1; i &lt; 1000.1; ++i) {  //  }</span></span></code> </pre> <br>  Hal yang sama berlaku untuk perhitungan menggunakan operator matematika. <br><br>  Misalnya, kinerja operator untuk mengambil sisa pembagian dari fragmen kode berikutnya tergantung pada angka apa yang terlibat dalam perhitungan. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> remainder = value % divisor; <span class="hljs-comment"><span class="hljs-comment">//  -  `value`  `divisor`   , //    .</span></span></code> </pre> <br>  Jika kedua operan diwakili oleh bilangan bulat, maka prosesor dapat menghitung hasilnya dengan sangat efisien.  Ada optimasi tambahan dalam V8 untuk kasus di mana operan <code>divisor</code> diwakili oleh angka yang merupakan kekuatan dua.  Untuk nilai yang direpresentasikan sebagai angka floating point, perhitungannya jauh lebih rumit dan membutuhkan waktu lebih lama. <br><br>  Karena operasi integer biasanya dilakukan jauh lebih cepat daripada operasi pada nilai floating-point, mungkin terlihat bahwa engine dapat selalu menyimpan semua integer dan semua hasil operasi integer dalam format dengan tambahan dua.  Sayangnya, pendekatan seperti itu akan melanggar spesifikasi naskah ECMAS.  Seperti yang telah disebutkan, standar menyediakan representasi angka dalam format Float64, dan beberapa operasi dengan bilangan bulat dapat menyebabkan tampilan hasil dalam bentuk angka floating-point.  Adalah penting bahwa dalam situasi seperti itu, mesin JS menghasilkan hasil yang benar. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Float64   53-  . //         . 2**53 === 2**53+1; // true // Float64   ,   -1 * 0   -0,  //           . -1*0 === -0; // true // Float64   Infinity,   , //     . 1/0 === Infinity; // true -1/0 === -Infinity; // true // Float64    NaN. 0/0 === NaN;</span></span></code> </pre> <br>  Meskipun dalam contoh sebelumnya semua angka di sisi kiri ekspresi adalah bilangan bulat, semua angka di sisi kanan ekspresi adalah nilai floating point.  Itulah sebabnya mengapa tidak ada operasi sebelumnya yang dapat dilakukan dengan benar menggunakan format 32-bit dengan tambahan hingga dua.  Mesin JavaScript harus memberi perhatian khusus untuk memastikan bahwa ketika melakukan operasi integer Anda mendapatkan yang benar (meskipun mampu terlihat tidak biasa - seperti dalam contoh sebelumnya) hasil Float64. <br><br>  Dalam kasus bilangan bulat kecil yang berada dalam kisaran representasi 31-bit bilangan bulat yang ditandatangani, V8 menggunakan representasi khusus yang disebut <code>Smi</code> .  Segala sesuatu yang bukan nilai <code>Smi</code> direpresentasikan sebagai nilai <code>HeapObject</code> , yang merupakan alamat beberapa entitas dalam memori.  Untuk nomor yang tidak termasuk dalam rentang <code>Smi</code> , kami memiliki jenis <code>HeapObject</code> - yang disebut <code>HeapNumber</code> . <br><br><pre> <code class="javascript hljs">-<span class="hljs-literal"><span class="hljs-literal">Infinity</span></span> <span class="hljs-comment"><span class="hljs-comment">// HeapNumber -(2**30)-1 // HeapNumber  -(2**30) // Smi       -42 // Smi        -0 // HeapNumber         0 // Smi       4.2 // HeapNumber        42 // Smi   2**30-1 // Smi     2**30 // HeapNumber  Infinity // HeapNumber       NaN // HeapNumber</span></span></code> </pre> <br>  Seperti yang Anda lihat dari contoh sebelumnya, beberapa nomor JS direpresentasikan sebagai <code>Smi</code> , dan beberapa sebagai <code>HeapNumber</code> .  Mesin V8 dioptimalkan dalam hal memproses angka <code>Smi</code> .  Faktanya adalah integer kecil sangat umum dalam program JS nyata.  Ketika bekerja dengan nilai-nilai <code>Smi</code> , tidak perlu mengalokasikan memori untuk masing-masing entitas.  Selain itu, penggunaannya memungkinkan Anda untuk melakukan operasi cepat dengan bilangan bulat. <br><br><h2>  <font color="#3AC1EF">Perbandingan Smi, HeapNumber dan MutableHeapNumber</font> </h2><br>  Mari kita bicara tentang seperti apa struktur internal dari mekanisme ini.  Misalkan kita memiliki objek berikut: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> o = {  <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-comment"><span class="hljs-comment">// Smi  y: 4.2, // HeapNumber };</span></span></code> </pre> <br>  Nilai 42 dari properti objek <code>x</code> dikodekan sebagai <code>Smi</code> .  Ini berarti dapat disimpan di dalam objek itu sendiri.  Untuk menyimpan nilai 4.2, di sisi lain, Anda harus membuat entitas terpisah.  Di objek, akan ada tautan ke entitas ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/116/718/f34/116718f3426bccd613dd35dc95be9739.png"></div><br>  <i><font color="#999999">Penyimpanan berbagai nilai</font></i> <br><br>  Misalkan kita menjalankan kode JavaScript berikut: <br><br><pre> <code class="javascript hljs">ox += <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ox   52 oy += 1; // oy   5.2</span></span></code> </pre> <br>  Dalam hal ini, nilai properti <code>x</code> dapat diperbarui di lokasi penyimpanannya.  Faktanya adalah bahwa nilai baru <code>x</code> adalah 52, dan angka ini berada dalam kisaran <code>Smi</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d8/400/d42/4d8400d42a2046c9727d4ff76ad2b483.png"></div><br>  <i><font color="#999999">Nilai baru properti x disimpan di tempat nilai sebelumnya disimpan.</font></i> <br><br>  Namun, nilai baru <code>y</code> , 5.2, tidak masuk ke dalam kisaran <code>Smi</code> , dan itu, di samping itu, berbeda dari nilai sebelumnya dari y - 4.2.  Akibatnya, V8 harus mengalokasikan memori untuk entitas <code>HeapNumber</code> baru dan referensi itu dari objek yang sudah ada. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ba/ecf/095/9baecf0951766c6e2781b552593b6b94.png"></div><br>  <i><font color="#999999">Entitas baru HeapNumber untuk menyimpan nilai y baru</font></i> <br><br>  Entitas <code>HeapNumber</code> tidak dapat diubah.  Ini memungkinkan Anda untuk mengimplementasikan beberapa optimasi.  Misalkan kita ingin mengatur properti objek <code>x</code> nilai properti <code>y</code> : <br><br><pre> <code class="javascript hljs">ox = oy; <span class="hljs-comment"><span class="hljs-comment">// ox   5.2</span></span></code> </pre> <br>  Saat melakukan operasi ini, kita bisa merujuk ke entitas <code>HeapNumber</code> sama, dan tidak mengalokasikan memori tambahan untuk menyimpan nilai yang sama. <br><br>  Salah satu kelemahan imunitas entitas HeapNuber adalah bahwa pemutakhiran bidang yang sering dengan nilai di luar rentang <code>Smi</code> lambat.  Ini ditunjukkan dalam contoh berikut: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   `HeapNumber`. const o = { x: 0.1 }; for (let i = 0; i &lt; 5; ++i) {  //    `HeapNumber`.  ox += 1; }</span></span></code> </pre> <br>  Saat memproses baris pertama, sebuah instance dari <code>HeapNumber</code> dibuat, nilai awalnya adalah 0,1.  Dalam inti siklus, nilai ini berubah menjadi 1.1, 2.1, 3.1, 4.1, dan akhirnya ke 5.1.  Akibatnya, dalam proses mengeksekusi kode ini, 6 contoh <code>HeapNumber</code> , lima di antaranya akan dikenai operasi pengumpulan sampah setelah selesainya loop. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d10/7e2/8f1/d107e28f181bf1eaf1fd57765bdfe49f.png"></div><br>  <i><font color="#999999">Entitas Banyak</font></i> <br><br>  Untuk menghindari masalah ini, V8 memiliki optimasi, yang merupakan mekanisme untuk memperbarui bidang numerik yang nilainya tidak sesuai dengan rentang <code>Smi</code> di tempat yang sama di mana mereka sudah disimpan.  Jika bidang numerik menyimpan nilai yang entitas <code>Smi</code> tidak cocok untuk penyimpanan, maka V8, dalam bentuk objek, menandai bidang ini sebagai <code>Double</code> dan mengalokasikan memori untuk entitas <code>MutableHeapNumber</code> , yang menyimpan nilai nyata yang diwakili dalam format Float64. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a17/c42/466/a17c42466cde98778836809e09df4da6.png"></div><br>  <i><font color="#999999">Menggunakan Entitas MutableHeapNumber</font></i> <br><br>  Akibatnya, setelah nilai bidang berubah, V8 tidak perlu lagi mengalokasikan memori untuk entitas <code>HeapNumber</code> baru.  Alih-alih, cukup tulis nilai baru ke entitas <code>MutableHeapNumber</code> ada. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c86/3bd/d1c/c863bdd1c81213b080d86bed079e9e5f.png"></div><br>  <i><font color="#999999">Menulis nilai baru ke MutableHeapNumber</font></i> <br><br>  Namun, pendekatan ini memiliki kekurangan.  Yaitu, karena nilai <code>MutableHeapNumber</code> dapat berubah, penting untuk memastikan bahwa sistem bekerja sedemikian rupa sehingga nilai-nilai ini berperilaku seperti yang disediakan dalam spesifikasi bahasa. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/176/be3/8ca/176be38cad03b4e4ab2881d7a9b67bfd.png"></div><br>  <i><font color="#999999">Kerugian MutableHeapNumber</font></i> <br><br>  Misalnya, jika Anda menetapkan nilai <code>ox</code> beberapa variabel lain <code>y</code> , maka Anda perlu memastikan bahwa nilai <code>y</code> tidak berubah dengan perubahan berikutnya pada <code>ox</code> .  Itu akan menjadi pelanggaran terhadap spesifikasi JavaScript!  Akibatnya, ketika mengakses <code>ox</code> , angka tersebut harus <code>HeapNumber</code> ulang ke nilai <code>HeapNumber</code> biasa sebelum diberikan <code>y</code> . <br><br>  Dalam hal angka floating-point, V8 melakukan operasi pengemasan di atas menggunakan mekanisme internal.  Tetapi dalam kasus bilangan bulat kecil, menggunakan <code>MutableHeapNumber</code> akan membuang-buang waktu karena <code>Smi</code> adalah cara yang lebih efisien untuk mewakili angka-angka tersebut. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// ""  `x`    object.x += 1; //   `x`  </span></span></code> </pre> <br>  Untuk menghindari penggunaan sumber daya sistem yang tidak efisien, yang perlu kita lakukan untuk bekerja dengan bilangan bulat kecil adalah menandai bidang terkait dalam bentuk objek sebagai <code>Smi</code> .  Akibatnya, nilai-nilai bidang ini, asalkan sesuai dengan rentang <code>Smi</code> , dapat diperbarui langsung di dalam objek. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b6a/d23/b96/b6ad23b9635e31d8f695d7170b8d3d7c.png"></div><br>  <i><font color="#999999">Bekerja dengan bilangan bulat yang nilainya berada dalam kisaran Smi</font></i> <br><br>  Dilanjutkan ... <br><br>  <b>Pembaca yang budiman!</b>  Pernahkah Anda mengalami masalah kinerja JavaScript yang disebabkan oleh fitur mesin JS? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/it/t5/3p/itt53pns2iucwylb3bwn1fmmtnu.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id467247/">https://habr.com/ru/post/id467247/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id467231/index.html">Memperkenalkan Masuk dengan Apple di aplikasi iOS Anda</a></li>
<li><a href="../id467237/index.html">Naikkan server DNS-over-HTTPS Anda</a></li>
<li><a href="../id467239/index.html">Perbedaan antara Data Scientist dan seorang remaja dalam mobil sport</a></li>
<li><a href="../id467241/index.html">Troli truk ROS. Bagian 4. Membuat simulasi robot menggunakan editor rviz dan gazebo</a></li>
<li><a href="../id467245/index.html">Dmitry Matskevich, Dbrain: tentang kewirausahaan sebagai cacat mental, AI, dan keamanan emosional</a></li>
<li><a href="../id467249/index.html">Sebuah kisah tentang V8, React dan penurunan kinerja. Bagian 2</a></li>
<li><a href="../id467251/index.html">Sandera COBOL dan Matematika. Bagian 1</a></li>
<li><a href="../id467253/index.html">Sandera COBOL dan Matematika. Bagian 2</a></li>
<li><a href="../id467255/index.html">Tiga Kesalahan Umum tentang Keamanan Yang Harus Diketahui Setiap Pengembang Tentang</a></li>
<li><a href="../id467257/index.html">Jangan menyimpan semua telur Anda dalam satu keranjang sekaligus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>