<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👩‍👦‍👦 🧜🏿 🧕🏽 Rust 1.31 und Rust 2018 Release ❔ 🔣 👐🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Rust-Entwicklungsteam freut sich, die Veröffentlichung einer neuen Version von Rust, 1.31.0, sowie von "Rust 2018" bekannt zu geben. Rust ist eine...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rust 1.31 und Rust 2018 Release</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432640/"><p>  Das Rust-Entwicklungsteam freut sich, die Veröffentlichung einer neuen Version von Rust, 1.31.0, sowie von "Rust 2018" bekannt zu geben.  Rust ist eine Programmiersprache, mit der jeder zuverlässige und effiziente Software erstellen kann. </p><br><p> Wenn Sie eine frühere Version von Rust mit <code>rustup</code> installiert <code>rustup</code> , müssen Sie nur Folgendes tun, um Rust auf Version 1.31.0 zu aktualisieren: </p><br><pre> <code class="bash hljs">$ rustup update stable</code> </pre> <br><p>  Wenn Sie <code>rustup</code> noch nicht installiert <code>rustup</code> , können Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">es</a> von der entsprechenden Seite unserer Website <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">installieren</a> .  <a href="">Detaillierte Versionshinweise für Rust 1.31.0</a> sind auf GitHub verfügbar. </p><br><h2 id="chto-voshlo-v-stabilnuyu-versiyu-1310">  Was ist in der stabilen Version 1.31.0 enthalten </h2><br><p>  Rust 1.31 ist wohl die bedeutendste Veröffentlichung seit Rust 1.0!  Die erste Iteration von „Rust 2018“ ist in dieser Version enthalten, aber dies ist nicht die einzige Innovation!  Die Überprüfung der Verbesserungen wird langwierig sein. Hier ist das Inhaltsverzeichnis: </p><br><ul><li>  <strong>Rost 2018</strong> <br><ul><li>  <strong>Nicht-lexikalische Lebenszeiten</strong> </li><li>  <strong>Module Systemänderungen</strong> </li></ul></li><li>  <strong>Zusätzliche Regeln für die Anzeige der Lebensdauer</strong> </li><li> <strong><code>const fn</code></strong> </li> <li>  <strong>Neue Werkzeuge</strong> </li><li>  <strong>Qualitätsprüfungen des Instrumentalcodes</strong> </li><li>  <strong>Die Dokumentation</strong> </li><li>  <strong>Facharbeitsgruppen</strong> </li><li>  <strong>Neue Website</strong> </li><li>  <strong>Stabilisierung der Standardbibliothek</strong> </li><li>  <strong>Frachtverbesserungen</strong> </li><li>  <strong>Entwickler freigeben</strong> </li></ul><a name="habracut"></a><br><h3 id="rust-2018">  Rost 2018 </h3><br><p>  Wir haben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zum ersten Mal im März</a> und dann <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Juli</a> über Rust 2018 geschrieben.  Einzelheiten dazu, <em>warum Sie</em> Rust 2018 benötigen, finden Sie in diesen Veröffentlichungen.  In dieser Rezension gibt es so viel zu erzählen, dass wir uns nur auf das konzentrieren, worum es bei Rust 2018 geht. Sie können es auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in einem Beitrag über Mozilla Hacks</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Übersetzung</a> ) lesen. </p><br><p>  Kurz gesagt, Rust 2018 ist eine Gelegenheit, all die Arbeit, die wir in den letzten drei Jahren geleistet haben, in ein zusammenhängendes Ganzes zu integrieren.  Rust 2018 ist mehr als nur eine Reihe von Sprachverbesserungen.  Zusätzlich zu ihnen enthält es: </p><br><ul><li>  Toolkit (Unterstützung in IDE, <code>rustfmt</code> , Clippy) </li><li>  Die Dokumentation </li><li>  Facharbeitsgruppen </li><li>  Neue Website </li></ul><br><p>  Darüber hinaus werden wir ausführlicher über all dies und über andere Innovationen sprechen. </p><br><p>  Erstellen wir mit Cargo ein neues Projekt: </p><br><pre> <code class="plaintext hljs">$ cargo new foo</code> </pre> <br><p>  Hier ist der Inhalt von <code>Cargo.toml</code> : </p><br><pre> <code class="plaintext hljs">[package] name = "foo" version = "0.1.0" authors = ["Your Name &lt;you@example.com&gt;"] edition = "2018" [dependencies]</code> </pre> <br><p>  Dem Abschnitt <code>[package]</code> ein neuer Schlüssel hinzugefügt: <code>edition</code> .  Bitte beachten Sie, dass es im Jahr <code>2018</code> installiert ist.  Sie können es auch im Jahr <code>2015</code> installieren. Dieser Wert wird standardmäßig festgelegt, wenn der Schlüssel fehlt. </p><br><p>  Durch die Verwendung von Rust 2018 werden einige neue Funktionen freigeschaltet, die in Rust 2015 nicht zulässig sind. </p><br><p>  Es ist wichtig zu beachten, dass jedes Paket im Modus 2015 oder 2018 sein kann und zusammenarbeitet.  Ihr Projekt der Ausgabe 2018 kann die Abhängigkeiten der Ausgabe 2015 verwenden, und das Projekt der Ausgabe 2015 kann die Abhängigkeiten der Ausgabe 2018 verwenden.  Dies stellt die Integrität des Ökosystems sicher und stellt sicher, dass alle neuen Funktionen optional sind, während die Kompatibilität mit vorhandenem Code erhalten bleibt.  Wenn Sie sich entscheiden, den Rust 2015-Code auf Rust 2018 zu portieren, können Änderungen automatisch über die <code>cargo fix</code> . </p><br><p>  Sie fragen sich vielleicht: Was ist mit den neuen Funktionen selbst?  Erstens werden sie auch in Rust 2015 hinzugefügt, wenn sie mit den Funktionen dieser Ausgabe kompatibel sind.  Daher bleibt der größte Teil der Sprache überall gleich.  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Redaktion</a> finden Sie die Mindestversion von <code>rustc</code> für jede neue Funktion und ihre anderen Anforderungen.  Es gibt jedoch einige große Neuerungen, die separat erwähnt werden müssen: nicht lexikalische Lebensdauern und einige Änderungen im Modulsystem. </p><br><h4 id="neleksicheskie-vremena-zhizni">  Nicht-lexikalische Lebenszeiten </h4><br><p>  Wenn Sie Rust in den letzten Jahren verfolgt haben, können Sie gelegentlich auf den Begriff "NLL" oder "nicht-lexikalische Lebenszeiten" stoßen.  Dies ist Jargon, was in einfachen Worten bedeutet: Der Kreditnehmer ist schlauer geworden und akzeptiert jetzt einen korrekten Code, den er zuvor abgelehnt hat.  Betrachten Sie ein Beispiel: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y = &amp;x; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> z = &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> x; }</code> </pre> <br><p>  Rust verwendet, um einen Kompilierungsfehler zu werfen: </p><br><pre> <code class="plaintext hljs">error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable --&gt; src/main.rs:5:18 | 4 | let y = &amp;x; | - immutable borrow occurs here 5 | 6 | let z = &amp;mut x; | ^ mutable borrow occurs here 7 | } | - immutable borrow ends here</code> </pre> <br><p>  Dies liegt daran, dass der Lebensbereich von Links "lexikalisch" definiert wurde;  Das heißt, das Ausleihen von <code>y</code> wurde als aktiv angesehen, bis <code>y</code> am Ende von <code>main</code> aus dem Gültigkeitsbereich kam, auch wenn wir <code>y</code> nie wieder innerhalb des Gültigkeitsbereichs verwenden.  Mit dem obigen Code ist alles in Ordnung, aber der Abhängigkeitsanalysator konnte dies nicht verstehen. </p><br><p>  Jetzt wird dieser Code gut kompiliert. </p><br><p>  Aber was ist, wenn wir <code>y</code> ?  Zum Beispiel so: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y = &amp;x; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> z = &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> x; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"y: {}"</span></span>, y); }</code> </pre> <br><p>  Rust gab Ihnen diesen Fehler: </p><br><pre> <code class="plaintext hljs">error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable --&gt; src/main.rs:5:18 | 4 | let y = &amp;x; | - immutable borrow occurs here 5 | let z = &amp;mut x; | ^ mutable borrow occurs here ... 8 | } | - immutable borrow ends here</code> </pre> <br><p>  In Rust 2018 wurde diese Fehlermeldung verbessert: </p><br><pre> <code class="plaintext hljs">error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable --&gt; src/main.rs:5:13 | 4 | let y = &amp;x; | -- immutable borrow occurs here 5 | let z = &amp;mut x; | ^^^^^^ mutable borrow occurs here 6 | 7 | println!("y: {}", y); | - borrow later used here</code> </pre> <br><p>  Anstatt anzugeben, wo <code>y</code> außerhalb des Gültigkeitsbereichs liegt, wird angezeigt, wo widersprüchliche Ausleihen auftreten.  Dies vereinfacht das Debuggen solcher Fehler erheblich. </p><br><p>  In Rust 1.31 ist dies eine Verbesserung exklusiv für Rust 2018. Wir planen, sie später zu Rust 2015 hinzuzufügen. </p><br><h4 id="izmeneniya-sistemy-moduley">  Module Systemänderungen </h4><br><p>  Das Modulsystem kann für Menschen, die Rust zum ersten Mal lernen, schwierig sein.  Natürlich gibt es immer etwas, dessen Beherrschung Zeit braucht.  Der Hauptgrund, warum Module für viele so peinlich sind, ist, dass trotz der einfachen und konsistenten Regeln, die das Modulsystem definieren, die Konsequenzen ihrer Verwendung widersprüchlich, mysteriös und unnatürlich erscheinen können. </p><br><p>  In der Ausgabe 2018 werden daher einige Änderungen an der Funktionsweise von Pfaden vorgenommen, wodurch das Modulsystem vereinfacht und verständlicher wird. </p><br><p>  Hier ist eine kurze Zusammenfassung: </p><br><ul><li>  <code>extern crate</code> fast nirgendwo anders mehr benötigt. </li><li>  Sie können Makros mithilfe von <code>use</code> importieren, anstatt das Attribut <code>#[macro_use]</code> . </li><li>  Absolute Pfade beginnen mit dem Namen des Containers, wobei sich das Schlüsselwort crate auf den aktuellen Container bezieht. </li><li>  <code>foo.rs</code> und das Unterverzeichnis <code>foo/</code> können nebeneinander existieren;  <code>mod.rs</code> nicht mehr erforderlich, wenn Submodule in einem Unterverzeichnis <code>mod.rs</code> . </li></ul><br><p>  Es sieht aus wie ein willkürliches Regelwerk, aber im Allgemeinen wurde das mentale Modell jetzt stark vereinfacht. </p><br><p>  Es gibt noch <em>viele</em> Details, alle Details finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Redaktionshandbuch</a> . </p><br><h3 id="dopolnitelnye-pravila-vyvoda-vremen-zhizni">  Zusätzliche Regeln für die Anzeige der Lebensdauer </h3><br><p>  Lassen Sie uns über die in beiden Editionen verfügbaren Verbesserungen sprechen: Wir haben einige zusätzliche Inferenzregeln für <code>impl</code> Blöcke und Funktionsdefinitionen hinzugefügt.  Code wie folgt: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; Reader <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> BufReader&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre> <br><p>  kann jetzt so geschrieben werden: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Reader <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> BufReader&lt;<span class="hljs-symbol"><span class="hljs-symbol">'_</span></span>&gt; { <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre> <br><p>  Lifetime <code>'_</code> zeigt immer noch, dass <code>BufReader</code> es als Parameter verwendet, aber wir müssen ihm keinen Namen mehr geben. </p><br><p>  Lebensdauern müssen noch in Strukturen definiert werden.  Wir müssen jedoch nicht mehr so ​​viel Code wie zuvor schreiben: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// Rust 2015 struct Ref&lt;'a, T: 'a&gt; { field: &amp;'a T } // Rust 2018 struct Ref&lt;'a, T&gt; { field: &amp;'a T }</span></span></code> </pre> <br><p>  Abhängigkeit <code>: 'a</code> wird ausgegeben.  Sie können es weiterhin explizit angeben, wenn Sie möchten.  Wir erwägen für die Zukunft andere Rückzugsmöglichkeiten an solchen Orten, haben aber bisher keine konkreten Pläne. </p><br><h3 id="const-fn"> <code>const fn</code> </h3> <br><p>  Rust hat mehrere Möglichkeiten, eine Funktion zu deklarieren: <code>fn</code> für gewöhnliche Funktionen, <code>unsafe fn</code> für unsichere Funktionen und externes <code>extern fn</code> für externe Funktionen.  Diese Version bietet eine neue Möglichkeit, eine Funktion zu deklarieren: <code>const fn</code> .  Es wird so verwendet: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> { x + <span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre> <br><p>  Eine konstante Funktion kann als normale Funktion aufgerufen werden, kann aber zusätzlich in jedem konstanten Kontext verwendet werden.  Es wird jedoch zur Kompilierungszeit und nicht während der Programmausführung ausgeführt.  Zum Beispiel: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SIX: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> = foo(<span class="hljs-number"><span class="hljs-number">5</span></span>);</code> </pre> <br><p>  Die <code>foo</code> Funktion wird zur Kompilierungszeit ausgeführt und <code>SIX</code> wird auf <code>6</code> . </p><br><p>  Konstante Funktionen können nicht alles, was normale Funktionen können: Sie müssen ein deterministisches Ergebnis haben.  Dies ist aus Gründen der Zuverlässigkeit wichtig.  In der aktuellen Form können konstante Funktionen eine minimale Teilmenge von Operationen ausführen.  Hier sind einige Beispiele dafür, was Sie darin tun können: </p><br><ul><li>  Verwenden Sie ganzzahlige Arithmetik- und Vergleichsoperationen </li><li>  Verwenden Sie alle logischen Operationen außer <code>&amp;&amp;</code> und <code>||</code> </li><li>  Entwerfen Sie Arrays, Strukturen, Aufzählungen und Tupel </li><li>  Rufen Sie andere konstante Funktionen auf </li><li>  Zugriff per Index in Arrays und Slices </li><li>  Zugriff auf die Felder von Strukturen und Tupeln </li><li>  Verwenden Sie Konstanten (aber keine statischen Werte und nicht einmal Verweise darauf). </li><li>  Verwenden Sie die Links <code>&amp;</code> und <code>*</code> </li><li>  Cast-Typen außer Cast-Raw-Zeiger auf Integer-Wert </li></ul><br><p>  Wir werden die Fähigkeiten konstanter Funktionen erweitern, aber der obige Satz reicht bereits aus, um <code>const fn</code> in der Praxis zu verwenden. </p><br><p>  Einzelheiten finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Handbuch</a> . </p><br><h3 id="novye-instrumenty">  Neue Werkzeuge </h3><br><p>  Die Ausgabe 2018 markiert den Beginn eines neuen Reifegrades für das Rust-Tool-Ökosystem.  Cargo, Rustdoc und Rustup sind seit Version 1.0 die Hauptwerkzeuge.  Mit der Ausgabe 2018 kommt eine neue Generation von Tools, die jetzt jeder nutzen kann: Clippy-, Rustfmt- und IDE-Unterstützung. </p><br><p>  Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>clippy</code></a> Static Code Analyzer ist jetzt in stabilem Rust erhältlich.  Sie können es über die <code>rustup component add clippy</code> installieren und mit dem <code>cargo clippy</code> .  Clippy hat jetzt Version 1.0 erhalten und hat die gleichen Stabilitätsgarantien für statische Prüfungen wie rustc.  Neue Schecks können hinzugefügt oder die Funktionalität der alten erweitert werden, aber die alten können nicht gelöscht werden (sie können nur als veraltet markiert werden).  Dies bedeutet, dass Code, der mit clippy kompiliert wird, weiterhin mit clippy kompiliert wird (vorausgesetzt, es werden keine Überprüfungen zum Generieren festgelegt <br>  Fehler über <code>deny</code> ), kann aber neue Warnungen erzeugen. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rustfmt</a> ist ein Tool zum Formatieren von Code in Rust.  Durch die automatische Code-Formatierung sparen Sie Zeit und bringen Ihren Code dem <a href="">offiziellen Rust-Stil</a> näher.  Sie können es über die <code>rustup component add rustfmt</code> installieren und den Befehl <code>rustup component add rustfmt</code> <code>cargo fmt</code> . </p><br><p>  Die aktuelle Version enthält Rustfmt 1.0.  Von nun an garantieren wir die Abwärtskompatibilität für Rustfmt: Wenn Sie Ihren Code heute formatieren, wird sich die Formatierung in Zukunft nicht ändern (nur für Standardparameter).  Abwärtskompatibilität bedeutet, dass es jetzt praktisch ist, Rustfmt auf Ihrem CI auszuführen (verwenden Sie <code>cargo fmt --check</code> ).  Versuchen Sie dies zusammen mit "Formatieren beim Speichern" im Editor, und Ihr Workflow wird revolutioniert. </p><br><p>  IDE-Unterstützung ist eine der am häufigsten nachgefragten Funktionen für Rust.  Jetzt gibt es mehrere hochwertige Lösungen: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Visual Studio Code</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IntelliJ</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Atom</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erhabener Text 3</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eclipse</a> </li></ul><br><p>  Die Supportarbeiten in der IDE sind noch nicht abgeschlossen.  Insbesondere die Code-Vervollständigung in RLS-basierten Editoren ist nicht auf dem neuesten Stand.  Wenn Sie jedoch hauptsächlich Unterstützung für Typen, Dokumentation und den "Übergang zur Definition" wünschen, sind Sie zufrieden. </p><br><h3 id="instrumentalnye-proverki-kachestva-koda-tool-lints">  Qualitätsprüfungen des Instrumentalcodes (Werkzeuglinien) </h3><br><p>  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rust 1.30 haben</a> wir "instrumentelle Attribute" wie <code>#[rustfmt::skip]</code> stabilisiert.  In Rust 1.31 haben wir so etwas stabilisiert: "Werkzeuglinien" wie <code>#[allow(clippy::bool_comparison)]</code> .  Auf diese Weise können Sie Namespaces für Überprüfungen angeben, um klarer zu machen, von welchen Tools sie stammen. </p><br><p>  Wenn Sie zuvor Clippy-Prüfungen verwendet haben, können Sie wie folgt migrieren: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//  #![cfg_attr(feature = "cargo-clippy", allow(bool_comparison))] //  #![allow(clippy::bool_comparison)]</span></span></code> </pre> <br><p>  Sie brauchen <code>cfg_attr</code> nicht mehr!  Sie erhalten jetzt auch Warnungen, mit denen Sie zur Verwendung des neuen Stils wechseln können. </p><br><h3 id="dokumentaciya">  Die Dokumentation </h3><br><p>  In diesem Jahr wurden einige Verbesserungen an Rustdoc vorgenommen, und das vollständig neu geschriebene Buch The Rust Programming Language wurde veröffentlicht.  Sie können eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Papierkopie bei No Starch Press</a> kaufen! </p><br><p>  Früher wurde es die „zweite Ausgabe“ des Buches genannt, aber da es die erste gedruckte Ausgabe wurde, sorgte dies für Verwirrung.  Schließlich soll die Printausgabe regelmäßig aktualisiert werden.  Am Ende wurde nach vielen Diskussionen mit No Starch beschlossen, das Buch auf der Website mit jeder Veröffentlichung zu aktualisieren, und No Starch nahm die Änderungen regelmäßig auf und druckte sie aus.  Das Buch verkauft sich ziemlich gut und bringt Geld für den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Black Girls Code ein</a> . </p><br><p>  Die neue Version des Buches finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><br><h3 id="predmetnye-rabochie-gruppy">  Facharbeitsgruppen </h3><br><p>  In diesem Jahr haben wir die Schaffung von vier Arbeitsgruppen angekündigt: </p><br><ul><li>  Netzwerkdienste </li><li>  Befehlszeilenanwendungen </li><li>  Webassembly </li><li>  Eingebettete Geräte </li></ul><br><p>  Die Gruppen haben sehr hart gearbeitet, um Rust in jedem dieser Bereiche besser zu machen.  Hier sind einige Erfolge: </p><br><ul><li>  Die Netzwerkdienste haben die Schnittstelle für Futures neu gestaltet und zusätzlich async / await.  Diese Verbesserungen wurden noch nicht veröffentlicht, aber wir sind schon nah dran! </li><li>  Das CLI-Team arbeitete an Bibliotheken und Dokumentationen, um Befehlszeilenanwendungen zu verbessern. </li><li>  WebAssembly hat viele erstklassige Tools für die Verwendung von Rust mit wasm veröffentlicht. </li><li>  Für eingebettete Geräte wurde es möglich, ARM auf einem stabilen Rust! </li></ul><br><p>  Mehr dazu erfahren Sie auf unserer neuen Seite! </p><br><h3 id="novyy-veb-sayt">  Neue Website </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Letzte Woche haben</a> wir eine neue Version unserer Website angekündigt.  Jetzt ist es die offizielle Version von rust-lang.org geworden! </p><br><p>  Um es zu schaffen, brauchten viele Menschen ein Jahr Arbeit.  Obwohl vor seiner Fertigstellung noch viel zu tun ist, sind wir stolz auf die geleistete Arbeit. </p><br><h3 id="stabilizaciya-standartnoy-biblioteki">  Stabilisierung der Standardbibliothek </h3><br><p>  Neue <code>From</code> Implementierungen wurden hinzugefügt: </p><br><ul><li>  <code>u8</code> implementiert jetzt <code>From&lt;NonZeroU8&gt;</code> , ähnlich für andere numerische Typen und deren <code>NonZero</code> Äquivalente </li><li>  <code>Option&lt;&amp;T&gt;</code> implementiert <code>From&lt;&amp;Option&lt;T&gt;&gt;</code> ähnlich wie <code>&amp;mut</code> </li></ul><br><p>  Folgende Funktionen wurden ebenfalls stabilisiert: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>slice::align_to</code></a> und sein veränderliches Gegenstück </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>slice::chunks_exact</code></a> sowie seine veränderlichen und <code>r</code> Gegenstücke (wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>slice::rchunks_exact_mut</code></a> ) in allen Kombinationen </li></ul><br><p>  Weitere <a href="">Informationen finden Sie in den</a> Versionshinweisen. </p><br><h3 id="uluchsheniya-v-cargo">  Frachtverbesserungen </h3><br><p>  Cargo lädt jetzt Pakete parallel über HTTP / 2. </p><br><p>  Da die <code>extern crate</code> jetzt optional ist, wäre es außerdem frustrierend, die <code>extern crate foo as bar;</code> zu schreiben <code>extern crate foo as bar;</code>  um die Abhängigkeit umzubenennen.  Daher können Sie dies in <code>Cargo.toml</code> tun: </p><br><pre> <code class="plaintext hljs">[dependencies] baz = { version = "0.1", package = "foo" }</code> </pre> <br><p>  oder gleichwertig: </p><br><pre> <code class="plaintext hljs">[dependencies.baz] version = "0.1" package = "foo"</code> </pre> <br><p>  Das <code>foo</code> Paket ist jetzt als <code>baz</code> zur Verwendung in Ihrem Code verfügbar. </p><br><p>  Weitere <a href="">Informationen finden Sie in den</a> Versionshinweisen. </p><br><h2 id="razrabotchiki-1310">  Entwickler 1.31.0 </h2><br><p>  Normalerweise danken wir am Ende der Überprüfung den <a href="">Personen, die zur Veröffentlichung beigetragen haben</a> .  Aber diesmal deckt diese Liste im Gegensatz zur Vergangenheit nicht alle Personen, die geholfen haben, und den gesamten Arbeitsaufwand vollständig ab.  Jede reguläre Veröffentlichung ist das Ergebnis von sechs Wochen Arbeit, aber diese Veröffentlichung ist der Höhepunkt von drei Jahren Bemühungen, die sich in der Vielzahl von Repositories widerspiegeln, die von einer großen Anzahl von Menschen erstellt wurden.  Wir haben uns gefreut, mit Ihnen allen zusammenzuarbeiten, und freuen uns auf die weitere Entwicklung von Rust in den nächsten drei Jahren. </p><br><p>  <em>Von einem Übersetzer: Ich danke den Mitgliedern der Rustycrate-Community und persönlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@dashadee</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">ozkriff</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">humbug</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">mvlabat</a> für ihre Hilfe bei der Übersetzung und beim Korrekturlesen.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de432640/">https://habr.com/ru/post/de432640/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de432630/index.html">Alles, was Sie über die Abfrageverarbeitung wissen wollten, aber schüchtern zu fragen waren</a></li>
<li><a href="../de432632/index.html">Die Geschichte von Lenny, dem beliebtesten Spam-Telefon-Troll des Internet-Trolls</a></li>
<li><a href="../de432634/index.html">Übersicht über fünf HTTP-Webentwicklungsbibliotheken</a></li>
<li><a href="../de432636/index.html">React Tutorial Teil 1: Kursübersicht, React, ReactDOM und JSX Gründe für die Popularität</a></li>
<li><a href="../de432638/index.html">Was ist neu in Upsource 2018.2?</a></li>
<li><a href="../de432642/index.html">Verwenden von DeviceLock DLP und Citrix Xen zur Steuerung von E-Mails auf Mobilgeräten</a></li>
<li><a href="../de432644/index.html">Intamsys FUNMAT HT Hochtemperatur-3D-Drucker auf einen Blick</a></li>
<li><a href="../de432646/index.html">Ausgewogene Top-Down- und Bottom-Up-Fusion</a></li>
<li><a href="../de432648/index.html">Wie wir in den Markt der Cloud-Anbieter eingetreten sind und uns in B2B verliebt haben. Fall MCS</a></li>
<li><a href="../de432650/index.html">Sammlung von Anforderungen für ein Softwareprojekt - ohne Schnitte</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>