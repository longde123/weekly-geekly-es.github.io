<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌒 🖊️ 🍓 我们如何以及为什么优化了用于清理Linux内核中SLAB缓存的算法 👨‍👨‍👦 👆🏽 🗻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="容器的日益普及及其与控制组的结合使用显示出严重的可伸缩性问题，这导致大型计算机的性能显着下降。 问题在于，SLAB高速缓存的旁路时间二次取决于容器的数量，并且在短时间内大量消耗内存的活动会导致系统进入繁忙的循环，从而消耗100％的处理器时间。 今天，我想告诉您，我们如何通过更改使用memcg控制组的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我们如何以及为什么优化了用于清理Linux内核中SLAB缓存的算法</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/virtuozzo/blog/435694/"> 容器的日益普及及其与控制组的结合使用显示出严重的可伸缩性问题，这导致大型计算机的性能显着下降。 问题在于，SLAB高速缓存的旁路时间二次取决于容器的数量，并且在短时间内大量消耗内存的活动会导致系统进入繁忙的循环，从而消耗100％的处理器时间。 今天，我想告诉您，我们如何通过更改使用memcg控制组的计费算法来使用SLAB缓存对象并优化shrink_slab（）函数来解决此问题。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/99b/7f3/83b/99b7f383beadeec2c814a6792e507b6c.jpg" alt="记忆清理"><br><a name="habracut"></a><br> 为什么会出现内核中的进程优化问题？ 一切始于这样一个事实：我们的一位客户积极使用容器和内存控制组（memcg），引起了人们对不时出现的处理器资源消耗高峰的关注。 正常的系统负载约为50％，在高峰时间占用了100％的处理器时间，几乎所有的负载都被内核消耗了（系统时间）。 <br> 该节点本身是多用户的，并在其上启动了大约200个OpenVZ容器。 分析表明，大量用户创建了嵌套的Docker容器和内存控制组的多级层次结构。 每个用户级别的顶级容器包含大约20个安装点和systemd创建的20个控制内存组（memcg）。 此外，上述Docker还创建了挂载点和控制组。 简而言之，该节点的负载很重，并且其负载要比我们所有其他客户的平均负载强得多。 我们有兴趣找出出现这些峰值的原因，因为在不那么忙碌的机器上也可能出现相同的问题，而这在机器上几乎不明显（例如，在5％的系统时间提供峰值，这会降低性能）。 <br><br> 通过操纵性能，我设法赶上了顶峰并消除了足迹。 事实证明，处理器的大部分时间都用于清除SLAB缓存，即超级块缓存： <br><br><pre><code class="markdown hljs"><span class="hljs-bullet"><span class="hljs-bullet">- </span></span>100,00% 0,00% kswapd0 [kernel.vmlinux] [k] kthread - 99,31% balance<span class="hljs-emphasis"><span class="hljs-emphasis">_pgdat - 82,11% shrink_</span></span>zone - 61,69% shrink<span class="hljs-emphasis"><span class="hljs-emphasis">_slab - 58,29% super_</span></span>cache<span class="hljs-emphasis"><span class="hljs-emphasis">_count + 54,56% list_</span></span>lru<span class="hljs-emphasis"><span class="hljs-emphasis">_count_</span></span>one</code> </pre> <br><br> 在这里有必要对此问题进行解释和详细介绍。 每个人都知道内核会在最终释放内存之前先缓存一段时间。 内核充分利用了这一原理。 例如，页面缓存包含与文件相关的数据页面，这在读取时极大地加快了对其的重复访问（因为您无需再次访问磁盘）。 在我们的案例中，问题出现在两个LRU列表（s_dentry_lru和s_inode_lru）中包含的超级块元数据缓存中。 <br><br>  <b>LRU（最近最少使用）</b> <b><br></b> <br>  struct lru_list指向一个链接列表数组，每个活动的memcg对应于此数组中的一个元素（list_lru_one）。 当某个内核不再使用某个SLAB对象时，内核会将其添加到数组的链表之一（取决于该对象所属的memcg，或大致来说，取决于创建该对象时使用的进程属于哪个memcg）。 数组本身描述如下（lru_list ::节点:: memcg_lrus）： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_lru_memcg</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rcu_head</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rcu</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* array of per cgroup lists, indexed by memcg_cache_id */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_lru_one</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lru</span></span></span><span class="hljs-class">[0];</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_lru_one</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_head</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* may become negative during memcg reparenting */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> nr_items; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> };</code> </pre><br>  lru [0]表示与ID为0的memcg相关的对象列表； <br>  lru [1]表示与ID为1的memcg相关的对象列表； <br>  ... <br>  lru [n]表示与ID为n的memcg相关的对象列表； <br><br>  LRU列表s_dentry_lru和s_inode_lru出现在我们的问题中，并且顾名思义，它们包含未使用的dentry和inode文件系统对象。 <br> 将来，如果系统中没有足够的内存或特定的memcg，则最终将释放某些列表项，并使用称为收缩器的特殊机制来执行此操作。 <br><br>  <b>收缩机</b> <b><br></b> <br> 当内核需要分配内存页面，但NUMA节点或系统上没有可用内存时，便开始了清理它的机制。 他正试图抛出或丢弃一定数量的磁盘：1）页面缓存中文件内容的页面；  2）与交换中的匿名内存相关的页面，以及3）缓存的SLAB对象（我们遇到的问题与它们有关）。 <br><br> 丢弃部分缓存的SLAB对象不会直接影响页面的释放：通常，它们的大小比页面大小小得多，并且一个页面包含数百个对象。 释放部分对象后，SLAB页面中将出现可用的内存间隙，可用于创建其他SLAB对象。 该算法被内核有意接受：它简单且非常有效。 有兴趣的读者可以在do_shrink_slab（）函数中查看用于选择要清洗的对象的一部分的公式。 <br><br> 此函数执行实际的部分对象清理，并以结构收缩器中传递给它的描述为指导： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_shrink_slab</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct shrink_control *shrinkctl, struct shrinker *shrinker, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> priority)</span></span></span><span class="hljs-function"> </span></span>{ … <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> freeable = shrinker-&gt;count_objects(shrinker, shrinkctl); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (freeable == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; total_scan = _(freeable); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (total_scan &gt;= batch_size) { <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> ret = shrinker-&gt;scan_objects(shrinker, shrinkctl); total_scan -= shrinkctl-&gt;nr_scanned; } ... }</code> </pre> <br> 关于收缩器超级块，这些功能的实现如下。 每个超级块都维护自己的s_dentry_lru和s_inode_lru与之相关的未使用对象的列表： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">super_block</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shrinker</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s_shrink</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* per-sb shrinker handle */</span></span> ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_lru</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s_dentry_lru</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_lru</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s_inode_lru</span></span></span><span class="hljs-class">;</span></span> … };</code> </pre> <br><br>  .count_objects方法返回对象数： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">super_cache_count</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct shrinker *shrink, struct shrink_control *sc)</span></span></span><span class="hljs-function"> </span></span>{ total_objects += list_lru_shrink_count(&amp;sb-&gt;s_dentry_lru, sc); total_objects += list_lru_shrink_count(&amp;sb-&gt;s_inode_lru, sc); <span class="hljs-comment"><span class="hljs-comment">/*     ) */</span></span> total_objects = vfs_pressure_ratio(total_objects); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total_objects; }</code> </pre> <br><br>  .scan_objects方法实际上释放对象： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">super_cache_scan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct shrinker *shrink, struct shrink_control *sc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*     s_dentry_lru */</span></span> prune_dcache_sb(sb, sc); <span class="hljs-comment"><span class="hljs-comment">/*     s_inode_lru */</span></span> prune_icache_sb(sb, sc); }</code> </pre> <br> 要释放的对象数在sc参数中传递。 另外，在那里显示了memcg，其对象应该从LRU中抛出： <br><br><pre> <b><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shrink_control</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nid; <span class="hljs-comment"><span class="hljs-comment">/* ID NUMA  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> nr_to_scan; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mem_cgroup</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">memcg</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* memcg */</span></span> };</code></b> </pre><br> 因此，prune_dcache_sb（）从数组struct list_lru_memcg :: lru []中选择一个链表，并对其进行处理。  Prune_icache_sb（）的作用相同。 <br><br>  <b>旧的收缩器旁路算法</b> <b><br></b> <br> 使用标准方法时，内存不足时会从SLAB中“弹出”对象 <br>  sc-&gt; target_mem_cgroup的发生情况如下： <br><br><pre> <code class="cpp hljs">shrink_node() { … <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mem_cgroup</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">root</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sc</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">target_mem_cgroup</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      sc-&gt;target_mem_cgroup  */</span></span> memcg = mem_cgroup_iter(root, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, &amp;reclaim); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { … shrink_slab(memcg, ...); … } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((memcg = mem_cgroup_iter(root, memcg, &amp;reclaim))); ... }</code> </pre><br> 我们遍历所有子memcg，并为每个子例程调用rinke_slab（）。 接下来，在rinkle_slab（）函数中，我们遍历所有收缩器，并为每个收缩器调用do_shrink_slab（）： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shrink_slab</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">gfp_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> gfp_mask, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nid, struct mem_cgroup *memcg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> priority)</span></span></span><span class="hljs-function"> </span></span>{ list_for_each_entry(shrinker, &amp;shrinker_list, <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shrink_control</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sc</span></span></span><span class="hljs-class"> = {</span></span> .nid = nid, .memcg = memcg, }; ret = do_shrink_slab(&amp;sc, shrinker, ...); } }</code> </pre><br> 回想一下，对于每个超级块，其自己的收缩器将添加到此列表中。 让我们计算一下200个容器（每个容器20个memcg和20个挂载点）的情况下do_shrink_slab（）会被调用多少次。 总共，我们有200 * 20个安装点和200 * 20个控制组。 如果最顶层的memcg中没有足够的内存，我们将被迫绕过其所有的子memcg（即，一般情况下的所有内容），并且对于它们中的每个memcg，都要从rinker_list中调用每个收缩器。 因此，内核将对do_shrink_slab（）函数进行200 * 20 * 200 * 20 = 16000000的调用。 <br><br> 而且，对该函数的绝大多数调用将是无用的：容器通常相互隔离，并且CT1将使用在CT2中创建的super_block2的可能性通常较低。 或者，是一样的，如果memcg1是CT1中的一个控制组，那么super_block2-&gt; s_dentry_lru-&gt; node-&gt; memcg_lrus-&gt; lru [memcg1_id]数组的对应元素将是一个空列表，为它调用do_shrink_slab（）没有意义。 <br><br> 可以使用一个简单的bash脚本对这个问题进行建模（此处使用了来自补丁集的数据，该数据随后传递给内核）： <br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$echo</span></span> 1 &gt; /sys/fs/cgroup/memory/memory.use_hierarchy <span class="hljs-variable"><span class="hljs-variable">$mkdir</span></span> /sys/fs/cgroup/memory/ct <span class="hljs-variable"><span class="hljs-variable">$echo</span></span> 4000M &gt; /sys/fs/cgroup/memory/ct/memory.kmem.limit_in_bytes <span class="hljs-variable"><span class="hljs-variable">$for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> `seq 0 4000`; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> mkdir /sys/fs/cgroup/memory/ct/<span class="hljs-variable"><span class="hljs-variable">$i</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $$ &gt; /sys/fs/cgroup/memory/ct/<span class="hljs-variable"><span class="hljs-variable">$i</span></span>/cgroup.procs; mkdir -ps/<span class="hljs-variable"><span class="hljs-variable">$i</span></span>; mount -t tmpfs <span class="hljs-variable"><span class="hljs-variable">$is</span></span>/<span class="hljs-variable"><span class="hljs-variable">$i</span></span>; touch s/<span class="hljs-variable"><span class="hljs-variable">$i</span></span>/file; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre><br> 让我们看看如果连续调用缓存重置过程5次会发生什么： <br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$time</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> 3 &gt; /proc/sys/vm/drop_caches</code> </pre> <br> 第一次迭代持续14秒，因为缓存的对象确实在内存中： <i>0.00用户13.78系统<b>0：13.78使用了</b> 99％的CPU。</i> <br> 尽管没有更多对象，但是第二次迭代需要5秒： <i>0.00user 5.59system <b>0：05.60经过</b> 99％的CPU。</i> <br> 第三次迭代耗时5秒： <i>0.00user 5.48系统<b>0：05.48经过</b> 99％CPU</i> <br> 第四次迭代耗时8秒： <i>0.00用户8.35系统<b>0：08.35已使用</b> 99％CPU</i> <br> 第五次迭代耗时8秒： <i>0.00用户8.34系统<b>0：08.35已使用</b> 99％CPU</i> <br><br> 显而易见，香草核所使用的收缩旁路算法不是最佳的，我们需要对其进行更改以更好地实现可伸缩性。 <br><br>  <b>新的收缩绕过算法</b> <b><br></b> <br> 通过新算法，我想要实现以下目标： <br><br><ol><li> 让他摆脱旧的缺点 </li><li> 不要添加新的锁。 仅在有意义时（即s_dentry_lru数组或s_inode_lru数组中的对应链表不为空）调用do_shrink_slab（），但不要直接访问链表存储器。 </li></ol><br> 显然，这只能由异构收缩器之上的新数据结构来提供（不仅有超级块的收缩器，还有本文未介绍的其他数据对象的收缩器。读者可以通过搜索关键字prealloc_shrinker（）来熟悉它们。在内核代码中）。 新的数据结构应允许对两种状态进行编码：“调用do_shrink_slab（）有意义”和“调用do_shrink_slab（）毫无意义”。 <br><br>  IDA类型数据结构被拒绝，因为 他们在自己内部使用锁。 位字段的数据结构完全适合此角色：它允许原子修饰单个位，并且与内存屏障结合使用，您可以构建有效的算法而无需使用锁。 <br><br> 每个收缩器都有自己的唯一ID（shrinker :: id），每个memcg都有一个位图，该位图能够包含当前注册的最大ID。 当第一个元素添加到s_dentry_lru-&gt;节点-&gt; memcg_lrus-&gt; lru [memcg_id]列表中时，相应的memcg位图将设置为1位，其数字为rinker-&gt; id。 与s_inode_id相同。 <br><br> 现在，可以优化shrink_slab（）中的循环以仅绕过必要的收缩器： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shrink_slab</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ … for_each_set_bit(i, <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>, shrinker_nr_max) { … shrinker = idr_find(&amp;shrinker_idr, i); … do_shrink_slab(&amp;sc, shrinker, priority); … } }</code> </pre><br>  （当收缩器进入状态时，也将执行位清理。“调用do_shrink_slab（）没有任何意义。有关更多详细信息，请参见Github <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">提交</a> 。 <br><br> 如果重复缓存重置测试，则使用新算法将显示出明显更好的结果： <br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$time</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> 3 &gt; /proc/sys/vm/drop_caches</code> </pre> <br> 第一次迭代： <i>0.00user 1.10系统<b>0：01.10已使用</b> 99％CPU</i> <i><br></i> 第二次迭代： <i>0.00user 0.00system <b>0：00.01经过</b> 64％CPU</i> <i><br></i> 第三次迭代： <i>0.00user 0.01system <b>0：00.01经过</b> 82％CPU</i> <i><br></i> 第四次迭代： <i>0.00user 0.00system <b>0：00.01经过</b> 64％CPU</i> <i><br></i> 第五次迭代： <i>0.00user 0.01system <b>0：00.01经过</b> 82％CPU</i> <br> 第二次到第五次迭代的持续时间为0.01秒， <b>比以前快548倍。</b> <br><br> 由于在计算机上内存不足时都会发生类似的重置缓存的操作，因此这种优化可以显着改善具有大量容器和内存控制组的计算机的操作。 香草核已接受<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一组补丁</a> （17个），您可以从4.19版开始在此处找到它。 <br><br> 在审查补丁的过程中，一位Google员工出现了，事实证明他们也有同样的问题。 因此，在不同类型的负载上进一步测试了补丁。 <br> 结果，补丁集从第9次迭代开始采用； 它进入香草核心大约需要4个月的时间。 也是今天，补丁集包含在我们自己的Virtuozzo 7内核中，从版本vz7.71.9开始 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN435694/">https://habr.com/ru/post/zh-CN435694/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN435684/index.html">橡树岭国家实验室解决了空间设备开发商的主要问题：: 238缺乏</a></li>
<li><a href="../zh-CN435686/index.html">Pavel Durov清算Telegram Messenger LLP</a></li>
<li><a href="../zh-CN435688/index.html">Flutter客户端服务器应用示例</a></li>
<li><a href="../zh-CN435690/index.html">[GraphQL有什么问题] ...以及如何处理</a></li>
<li><a href="../zh-CN435692/index.html">Y Combinator：“起初，一些最大的科技公司看起来像玩具”</a></li>
<li><a href="../zh-CN435696/index.html">上古：1997年计算机广告</a></li>
<li><a href="../zh-CN435698/index.html">编写自己的优秀内存管理器</a></li>
<li><a href="../zh-CN435700/index.html">8个最差的Vue.js面试问题</a></li>
<li><a href="../zh-CN435702/index.html">专利巨魔开始并获胜：我如何没有比赛</a></li>
<li><a href="../zh-CN435704/index.html">手机游戏的架构解决方案。 第2部分：命令及其队列</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>