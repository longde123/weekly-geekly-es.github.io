<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§¥ üëâüèº üë©üèæ‚Äçüé® M√©todos de otimiza√ß√£o de c√≥digo para Redd. Parte 1: efeito cache üë®üèΩ‚Äç‚öñÔ∏è üèáüèº üëêüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No primeiro artigo da s√©rie, promovi ativamente a ideia de que o desenvolvimento de c√≥digo para Redd √© secund√°rio e o projeto principal √© prim√°rio. O ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>M√©todos de otimiza√ß√£o de c√≥digo para Redd. Parte 1: efeito cache</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467353/"> No <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primeiro artigo da</a> s√©rie, promovi ativamente a ideia de que o desenvolvimento de c√≥digo para Redd √© secund√°rio e o projeto principal √© prim√°rio.  O Redd √© uma ferramenta auxiliar; portanto, gastar muito tempo com isso √© errado.  Ou seja, o desenvolvimento deve ocorrer rapidamente.  Mas isso n√£o significa que os programas resultantes n√£o devam ser √≥timos.  Na verdade, se eles n√£o forem otimizados, apenas a pot√™ncia do equipamento n√£o ser√° suficiente para implementar o sistema de teste desejado.  Portanto, o processo, como eu disse, deve ser r√°pido e f√°cil, mas o desenvolvedor deve sempre ter em mente alguns princ√≠pios de otimiza√ß√£o. <br><br><img src="https://habrastorage.org/webt/ky/gv/ge/kygvge7bilfbzntymcu3qzlk4mq.jpeg"><br><br>  Livros grossos foram publicados sobre otimiza√ß√£o.  Alguns desses livros s√£o √∫teis, outros j√° est√£o desatualizados, pois os princ√≠pios descritos neles h√° muito migraram para o est√°gio de otimiza√ß√£o autom√°tica ao criar c√≥digo ... Mas h√° algumas coisas que n√£o t√™m valor no desenvolvimento de programas comuns para processadores comuns, portanto, livros t√≠picos geralmente n√£o descrevem .  Vamos agora come√ßar a consider√°-los. <br><a name="habracut"></a><br><h2>  1. Introdu√ß√£o </h2><br>  At√© agora, escrevi sobre o princ√≠pio de "um problema - um artigo".  E os artigos foram obtidos no formato de palestras, afetando v√°rios t√≥picos ao mesmo tempo, unidos por um problema comum.  Mas alguns leitores disseram que esses artigos n√£o podiam ser lidos de uma s√≥ vez.  Portanto, agora tentaremos falar sobre apenas um t√≥pico em um artigo.  Tamb√©m √© mais f√°cil escrever assim.  Vamos ver, de repente ser√° mais conveniente para todos. <br><br>  Al√©m disso, delicie os misteriosos invasores.  Se um artigo √© publicado pela manh√£, o primeiro sinal negativo chega depois de um per√≠odo de tempo em que √© imposs√≠vel ler o texto inteiro.  Algu√©m faz isso puramente por princ√≠pio, poupando apenas t√≥picos sobre UDB e balalaica.  Se a publica√ß√£o n√£o foi pela manh√£, mas pela tarde, ele lan√ßa um sinal de menos com atraso.  O segundo menos chega durante o dia (e esse amigo, ali√°s, tamb√©m poupou t√≥picos sobre o UDB e a balalaica).  Haver√° mais artigos no novo formato, o que significa que haver√° momentos mais agrad√°veis ‚Äã‚Äãpara esse casal (embora, pessoalmente, para mim, como autor, fique triste e ofensivo por suas a√ß√µes). <br><br>  Artigos anteriores da s√©rie: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Desenvolvimento do ‚Äúfirmware‚Äù mais simples para FPGAs instalados no Redd e depura√ß√£o usando o teste de mem√≥ria como exemplo.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Desenvolvimento do ‚Äúfirmware‚Äù mais simples para FPGAs instalados em Redd.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2. C√≥digo do programa.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Desenvolvimento de n√∫cleo pr√≥prio para incorpora√ß√£o em um sistema de processador baseado em FPGA.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Desenvolvimento de programas para o processador central Redd no exemplo de acesso ao FPGA.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">As primeiras experi√™ncias usando o protocolo de streaming no exemplo da comunica√ß√£o da CPU e do processador no FPGA do Redd.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Merry Quartusel, ou como o processador ganhou vida.</a> </li></ol><br><h2>  Comportamento misterioso de um sistema t√≠pico </h2><br>  Vamos fazer o sistema de processador mais simples, incluindo um rel√≥gio, um processador Nios II / f, um controlador SDRAM e uma porta de sa√≠da.  √â assim que este sistema √© espartano no Platform Designer <br><br><img src="https://habrastorage.org/webt/mr/qt/hm/mrqthmfrz5vespqetdjwcguvclu.png"><br><br>  O c√≥digo do programa conter√° apenas uma fun√ß√£o, cujo corpo parece um tanto estranho, pois cont√©m muitas linhas repetidas, mas isso ser√° √∫til para n√≥s. <br><br><div class="spoiler">  <b class="spoiler_title">O c√≥digo est√° oculto porque √© muito apertado.</b> <div class="spoiler_text"><pre><code class="plaintext hljs">extern "C" { #include "sys/alt_stdio.h" #include &lt;system.h&gt; #include &lt;io.h&gt; } void MagicFunction() { while (1) { IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); } } int main() { MagicFunction(); /* Event loop never exits. */ while (1); return 0; }</code> </pre> <br></div></div><br>  Coloque um ponto de interrup√ß√£o na √∫ltima das linhas: <br><br><pre> <code class="plaintext hljs">IOWR (PIO_0_BASE,0,0);</code> </pre> <br>  no <b>MagicFunction</b> e execute o programa.  O que conseguimos na sa√≠da do porto?  Impulsos muito irregulares: <br><br><img src="https://habrastorage.org/webt/n7/qt/qj/n7qtqjkwhcioypjv02_7ir7k3es.png"><br><br>  O horror  Bem sim.  No entanto, clique no bot√£o "iniciar" novamente para concluir outra itera√ß√£o do loop.  E agora, na sa√≠da, vemos um belo meandro suave: <br><br><img src="https://habrastorage.org/webt/ez/nz/4k/eznz4kkvo8smagbksijd0tt4bso.png"><br><br>  Outra itera√ß√£o.  E mais um ... Meandro est√°vel.  Removemos o ponto de interrup√ß√£o e assistimos ao trabalho em din√¢mica - n√£o h√° mais interrup√ß√µes desse tipo.  Existem infinitas explos√µes de pulsos. <br><br>  Por que arrancamos impulsos na primeira passagem?  Um acidente?  N√£o.  Paramos a depura√ß√£o e a iniciamos novamente.  E novamente temos impulsos rasgados.  As lacunas sempre surgem na entrada do programa. <br><br><h2>  A pista est√° no cache </h2><br>  Na verdade, a solu√ß√£o para esse comportamento est√° no cache.  Nosso programa √© armazenado em SDRAM.  A busca do c√≥digo da SDRAM n√£o √© r√°pida.  √â necess√°rio dar um comando de leitura, √© necess√°rio dar um endere√ßo, e o endere√ßo consiste em duas partes.  Voc√™ tem que esperar um pouco.  Somente ent√£o o microcircuito fornecer√° os dados.  Para evitar tais atrasos todas as vezes, o microcircuito pode emitir n√£o um, mas v√°rias palavras consecutivas.  N√£o consideraremos os hor√°rios hoje, adiaremos para os seguintes artigos. <br><br>  Bem, no lado do n√∫cleo do processador, um cache foi criado por padr√£o.  Aqui est√£o suas configura√ß√µes: <br><br><img src="https://habrastorage.org/webt/n3/3b/cx/n33bcxjyhe2v_lvaiuqafjzvdoc.png"><br><br>  Na verdade, ocorrem atrasos no momento em que o carregamento em lote de instru√ß√µes do SDRAM para o cache est√° em andamento.  Nas pr√≥ximas itera√ß√µes, o c√≥digo j√° est√° no cache, portanto, o carregamento n√£o √© mais necess√°rio. <br><br>  O oscilograma mostra uma m√©dia de 8 entradas por porta (uma unidade √© gravada 4 vezes e zero √© gravada 4 vezes) por opera√ß√£o de carregamento.  Um comando - um comando assembler, que pode ser encontrado escolhendo o item de menu Janela-&gt; Mostrar Visualiza√ß√£o-&gt; Outro: <br><br><img src="https://habrastorage.org/webt/p-/xp/nh/p-xpnhdsqsklxoqa_ityjp2u-hu.png"><br><br>  e depois Depurar-&gt; Desmontagem: <br><br><img src="https://habrastorage.org/webt/2n/7c/in/2n7cinmvmt04ov-_ibduzwcv9zo.png"><br><br>  Aqui est√£o nossas strings e o c√≥digo de montagem correspondente: <br><br><img src="https://habrastorage.org/webt/_q/ox/wz/_qoxwz5u9qkgsn4gd5t0yuy4djw.png"><br><br>  8 equipes de 4 bytes cada.  Obtemos 32 bytes por linha de cache ... Examinamos nosso arquivo de ajuda favorito C: \ Work \ CachePlay \ software \ CachePlay_bsp \ system.he vemos: <br><br><pre> <code class="plaintext hljs">#define ALT_CPU_ICACHE_LINE_SIZE 32 #define ALT_CPU_ICACHE_LINE_SIZE_LOG2 5</code> </pre><br>  Os dados praticamente calculados coincidiram com a teoria.  Al√©m disso, a partir da documenta√ß√£o, segue-se que o tamanho da string n√£o pode ser alterado.  √â sempre igual a trinta e dois bytes. <br><br><h2>  Um pouco mais complicado experimento </h2><br>  Vamos tentar provocar um cache para reiniciar durante o trabalho estabelecido.  Vamos mudar um pouco o programa de teste.  N√≥s criamos duas fun√ß√µes e as chamamos da fun√ß√£o <b>main ()</b> , colocando um loop nela.  N√£o vou definir um ponto de interrup√ß√£o.  A prop√≥sito, se voc√™ tornar as fun√ß√µes completamente id√™nticas, o otimizador perceber√° isso e remover√° uma delas, portanto, pelo menos uma linha, mas elas devem diferir ... Isso √© o que escrevi no come√ßo: os otimizadores s√£o muito inteligentes agora. <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo do programa de teste modificado.</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">extern "C" { #include "sys/alt_stdio.h" #include &lt;system.h&gt; #include &lt;io.h&gt; } void MagicFunction1() { IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); } void MagicFunction2() { IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); } int main() { while (1) { MagicFunction1(); MagicFunction2(); } /* Event loop never exits. */ while (1); return 0; }</code> </pre><br></div></div><br>  Temos um resultado bastante bonito, j√° filmado no modo estabelecido do programa. <br><br><img src="https://habrastorage.org/webt/6q/ww/xa/6qwwxao-phas4ippal7a1hrhlik.png"><br><br>  E agora colocaremos uma nova fun√ß√£o entre esse par de fun√ß√µes, e n√£o vamos cham√°-lo, ser√° apenas colocado entre eles na mem√≥ria.  Agora vou tentar fazer com que ocupe mais espa√ßo ... O tamanho do cache √© de 4 kilobytes, ent√£o o tornamos igual a quatro kilobytes ... Basta inserir 1024 NOPs, cada um com 4 bytes de tamanho.  Mostrarei o final da primeira fun√ß√£o, a nova fun√ß√£o e o in√≠cio da segunda, para que fique claro como o programa muda: <br><br><pre> <code class="plaintext hljs">... IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); } #define Nops4 __asm__ volatile ("nop");__asm__ volatile ("nop");__asm__ volatile ("nop");__asm__ volatile ("nop"); #define Nops16 Nops4 Nops4 Nops4 Nops4 #define Nops64 Nops16 Nops16 Nops16 Nops16 #define Nops256 Nops64 Nops64 Nops64 Nops64 #define Nops1024 Nops256 Nops256 Nops256 Nops256 volatile void FuncBetween() { Nops1024 } void MagicFunction2() { IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); ...</code> </pre><br>  A l√≥gica do programa n√£o mudou, mas quando executada agora, temos pulsos rasgados <br><br><img src="https://habrastorage.org/webt/20/on/rq/20onrqyrzqtcdeiqjiulcaa0yuw.png"><br><br>  Farei uma pergunta ing√™nua: voamos para fora do cache e agora, √† medida que a lacuna aumenta, sempre haver√° carregamento?  Nem um pouco!  Altere o tamanho da fun√ß√£o "ruim", tornando-a igual a, digamos, cinco kilobytes.  Cinco a mais do que quatro, ainda estamos voando?  Ou n√£o?  Substitua a inser√ß√£o por esta: <br><br><pre> <code class="plaintext hljs">volatile void FuncBetween() { Nops1024 Nops256 }</code> </pre><br>  E novamente temos a beleza: <br><br><img src="https://habrastorage.org/webt/cz/hh/up/czhhupgwhqdrrddlaeyg8kv50yg.png"><br><br>  Ent√£o, o que determina a necessidade de carregar c√≥digo no cache?  Podemos prever algo ou cada vez que precisamos olhar para o fato?  Vamos nos aprofundar na teoria, com a qual o <b>Guia de Refer√™ncia do Processador Nios II</b> nos ajuda. <br><br><h2>  Pouco de teoria </h2><br>  √â assim que o campo de endere√ßo se divide no processador: <br><br><img src="https://habrastorage.org/webt/ba/kw/5_/bakw5_bz0uipk2kzstdfcjuiuvy.png"><br><br>  Como voc√™ pode ver, o endere√ßo est√° dividido em tr√™s partes.  Etiqueta, linha e deslocamento.  A dimens√£o do campo de deslocamento √© constante para o processador Nios II e √© sempre cinco bits, ou seja, pode endere√ßar 32 bytes.  A dimens√£o do campo "linha" depende do tamanho do cache especificado ao configurar o processador.  Na figura acima, √© bastante grande.  N√£o sei por que o documento tem uma dimens√£o t√£o grande.  Temos um tamanho de cache de 4 kilobytes, o que significa que a profundidade e o deslocamento total de bits s√£o 12 bits.  5 bits leva um deslocamento, para uma linha permanece 12-5 = 7 bits. <br><br>  Temos uma determinada tabela de 128 linhas, cada uma com 32 bytes de comprimento.  Vou dar, digamos, as 6 primeiras linhas: <br><div class="scrollable-table"><table><tbody><tr><th>  Campo Tag </th><th>  Campo "string" </th><th>  LSBs </th><th>  Onde obter </th></tr><tr><td>  N√£o √© importante </td><td>  0x00 </td><td>  0x000 a 0x01F </td><td>  Para a linha 0 do cache </td></tr><tr><td>  N√£o √© importante </td><td>  0x01 </td><td>  0x020 a 0x03F </td><td>  Cache da linha 1 </td></tr><tr><td>  N√£o √© importante </td><td>  0x02 </td><td>  0x040 a 0x05F </td><td>  Cache da linha 2 </td></tr><tr><td>  N√£o √© importante </td><td>  0x03 </td><td>  0x060 a 0x07F </td><td>  Cache da Linha 3 </td></tr><tr><td>  N√£o √© importante </td><td>  0x04 </td><td>  0x080 a 0x09F </td><td>  Cache da linha 4 </td></tr><tr><td>  N√£o √© importante </td><td>  0x05 </td><td>  0x0A0 a 0x0BF </td><td>  Cache da Linha 5 </td></tr><tr><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td></tr><tr><td>  N√£o √© importante </td><td>  0x7F </td><td>  0xFE0 a 0xFFF </td><td>  para a linha 127 do cache </td></tr></tbody></table></div><br>  E ent√£o nos voltamos para o endere√ßo 0x123 <b>004</b> .  Se voc√™ descartar a parte ‚Äún√£o importante‚Äù, o par ‚Äúlinha + deslocamento‚Äù √© 0x004.  Este √© o intervalo de zero linhas.  Os dados ser√£o carregados nesta linha.  E o trabalho adicional com dados do intervalo 0x123 <b>000</b> a 0x123 <b>01F</b> funcionar√° no cache.  Sob quais condi√ß√µes a string ser√° sobrecarregada?  Ao acessar qualquer outro endere√ßo que termine no intervalo de 0x000 a 0x01F.  Bem, isto √©, se voltarmos para o endere√ßo 0xABC <b>204</b> , tudo permanecer√° no lugar, porque o intervalo de endere√ßos inferiores n√£o se sobrep√µe ao nosso.  E 0xABC <b>804</b> n√£o vai estragar nada.  Por√©m, ao executar o c√≥digo a partir do endere√ßo 0xABC <b>004, isso</b> resultar√° no carregamento de novos conte√∫dos na linha de cache.  E a transi√ß√£o para o endere√ßo 0x123 <b>004 j√°</b> levar√° novamente a uma sobrecarga.  Se voc√™ pular constantemente entre 0xABC <b>004</b> e 0x123 <b>004</b> , a sobrecarga ocorrer√° continuamente. <br><br>  Vamos tentar descrever isso na forma de uma imagem.  Suponha que tenhamos apenas 8 linhas no cache; √© mais conveniente colori-las em cores diferentes.  Tornarei o tamanho da linha 0x10, √© mais conveniente pintar os endere√ßos na imagem (lembre-se de que no Nios II real o tamanho da linha √© sempre 0x20 bytes).  A mem√≥ria bate em p√°ginas condicionais com o mesmo tamanho das linhas de cache.  A p√°gina vermelha da mem√≥ria sempre ir√° para a linha vermelha do cache, da laranja para a laranja e assim por diante.  Assim, o conte√∫do antigo ser√° descarregado. <br><br><img src="https://habrastorage.org/webt/r0/he/sl/r0heslzwbiuxwjprhq4tnf-xela.png"><br><br>  Bem, na verdade, o comportamento do programa durante o experimento agora est√° claro.  Quando as fun√ß√µes foram separadas estritamente por 4 kilobytes, elas atingiram p√°ginas de cores semelhantes.  Portanto, o c√≥digo <br><br><pre> <code class="plaintext hljs"> while (1) { MagicFunction1(); MagicFunction2(); }</code> </pre><br>  levou ao carregamento do cache por uma quest√£o e depois por outra fun√ß√£o.  E quando o espa√ßamento n√£o era de 4, mas de 5 kilobytes, as fun√ß√µes eram espa√ßadas em blocos de cores diferentes.  N√£o houve conflito, tudo funcionou sem demora. <br><br><h2>  Conclus√µes </h2><br>  Quando li muitos anos atr√°s, h√° linhas de n√∫cleos Cortex A, Cortex R e Cortex M projetados para coisas produtivas, para trabalhar em tempo real e para trabalhar em sistemas baratos, respectivamente, no come√ßo eu n√£o entendi, mas qual √© a diferen√ßa .  N√£o, sistemas baratos s√£o compreens√≠veis, mas os dois primeiros s√£o quais s√£o as diferen√ßas?  No entanto, depois de jogar o n√∫cleo do Cortex A9 dispon√≠vel no FPGA Cyclone V SoC, senti todas as desvantagens do cache ao trabalhar com ferro.  Existem muitos caches no n√∫cleo do Cortex A ... E a previsibilidade do comportamento do sistema √© quase zero.  Mas o cache melhora o desempenho.  √Äs vezes, √© melhor que tudo funcione n√£o previsivelmente preciso, mas mais r√°pido do que previsivelmente lento.  Isso √© especialmente verdadeiro para a computa√ß√£o ou, por exemplo, a exibi√ß√£o de gr√°ficos. <br><br>  Mas o principal problema n√£o √© que as coisas descritas no artigo surjam, mas que o comportamento do sistema mudar√° de montagem para montagem, pois ningu√©m sabe o que aborda a fun√ß√£o que ocorrer√° ap√≥s adicionar ou remover o c√≥digo.  H√° 15 anos, no projeto do emulador de console de jogos da Sega para um decodificador de televis√£o a cabo, tivemos que criar um pr√©-processador inteiro que, ap√≥s cada edi√ß√£o, movesse as fun√ß√µes que emulavam os comandos do assembler da Motorola no n√∫cleo SPARC-8, para que o tempo de execu√ß√£o fosse sempre o mesmo (n√£o devido ao cache, caso contr√°rio, tudo nadou muito). <br><br>  Mas quando precisamos de previsibilidade?  Obviamente, durante a forma√ß√£o de diagramas de tempo programaticamente (lembre-se de que, em geral, nos FPGAs, √© poss√≠vel confiar isso tamb√©m ao equipamento, mas existem alguns detalhes com desenvolvimento r√°pido).  Mas, ao trabalhar com algoritmos computacionais, isso n√£o √© t√£o importante.  A menos que o algoritmo seja complexo, voc√™ precisa ter certeza de que as se√ß√µes cr√≠ticas n√£o causam sobrecarga constante de cache.  Na maioria dos casos, o cache n√£o cria problemas e a produtividade aumenta. <br><br>  No pr√≥ximo artigo, veremos como prever fun√ß√µes cr√≠ticas na mem√≥ria n√£o armazen√°vel em cache, que sempre √© executada na velocidade m√°xima, e discutir as vantagens impl√≠citas dos FPGAs em rela√ß√£o aos sistemas padr√£o decorrentes das tecnologias usadas neste processo. <br><br><h2>  Para os mais atentos </h2><br>  Um leitor corrosivo pode perguntar: "Por que o oscilograma foi rasgado insuficientemente ao inserir quatro kilobytes de c√≥digo?"  Tudo √© simples.  Se voc√™ inserir exatamente 4 kilobytes, obteremos os seguintes endere√ßos para colocar fun√ß√µes na mem√≥ria: <br><br><pre> <code class="plaintext hljs"> MagicFunction1(): 0200006c: movhi r2,1024 02000070: movi r4,1 02000074: addi r2,r2,4096 02000078: stwio r4,0(r2) 92 IOWR (PIO_0_BASE,0,0); 0200007c: mov r3,zero 02000080: stwio r3,0(r2) 93 IOWR (PIO_0_BASE,0,1); ... 120 IOWR (PIO_0_BASE,0,0); 020000f0: stwio r3,0(r2) 020000f4: ret 131 Nops1024 FuncBetween(): 020000f8: nop 020000fc: nop 02000100: nop 02000104: nop ... 020010ec: nop 020010f0: nop 020010f4: nop 020010f8: ret 135 IOWR (PIO_0_BASE,0,0); MagicFunction2(): 020010fc: movhi r2,1024 02001100: mov r4,zero 02001104: addi r2,r2,4096</code> </pre><br>  Para uma forma de onda perfeitamente ruim, √© necess√°rio inserir NOPs para que 4 kilobytes sejam o volume e o comprimento da fun√ß√£o <b>MagicFunction1 ()</b> .  N√£o importa o que voc√™ v√° para uma bela foto!  Mude a inser√ß√£o para isto: <br><br><pre> <code class="plaintext hljs">volatile void FuncBetween() { Nops256 Nops256 Nops256 Nops64 Nops64 Nops64 Nops16 Nops16 }</code> </pre><br>  Repetidamente, presto aten√ß√£o que o inserto n√£o recebe controle.  Simplesmente altera a posi√ß√£o das fun√ß√µes na mem√≥ria, uma em rela√ß√£o √† outra.  Com esta inser√ß√£o, obtemos o horror terr√≠vel desejado: <br><br><img src="https://habrastorage.org/webt/7d/by/om/7dbyomefuy0kgtjxmnysanc_lxm.png"><br><br>  Pareceu-me que esses detalhes inseridos no texto principal distra√≠am todos do texto principal, ent√£o eu os coloquei em um postscript. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt467353/">https://habr.com/ru/post/pt467353/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt467339/index.html">E, novamente, o 256¬∫ dia do ano</a></li>
<li><a href="../pt467343/index.html">Por que deixei o freelance: impress√µes do desenvolvedor de back-end ap√≥s 2 anos de "liberdade"</a></li>
<li><a href="../pt467345/index.html">Conhe√ßa os blogs de TI e 4 camadas de treinamento: uma entrevista com Sergei Abdulmanov, da Mosigra</a></li>
<li><a href="../pt467347/index.html">Livro ‚ÄúCriando contratos inteligentes Solidity para o blockchain Ethereum. Guia Pr√°tico</a></li>
<li><a href="../pt467349/index.html">Mudando um programador para a Est√¥nia: trabalho, dinheiro e custo de vida</a></li>
<li><a href="../pt467355/index.html">Entrevista com pesquisador de mercado e tend√™ncias de desenvolvimento de software na Europa Central e Oriental, Eugene Schwab-Chesaru</a></li>
<li><a href="../pt467357/index.html">PVS-Studio nas nuvens: Azure DevOps</a></li>
<li><a href="../pt467359/index.html">O PVS-Studio vai para as nuvens: Azure DevOps</a></li>
<li><a href="../pt467361/index.html">Esquecemos a delega√ß√£o em JavaScript. Delega√ß√£o de evento em reagir</a></li>
<li><a href="../pt467363/index.html">Usando fun√ß√µes personalizadas de perda e aprendendo m√©tricas de qualidade no Keras</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>