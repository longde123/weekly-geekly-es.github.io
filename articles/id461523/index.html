<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤱🏽 😩 🤲 WAL di PostgreSQL: 4. Pengaturan log 💠 🛀 🔂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jadi, kami berkenalan dengan perangkat buffer cache dan, menggunakan contohnya, kami menyadari bahwa ketika konten RAM hilang selama kegagalan, log pr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WAL di PostgreSQL: 4. Pengaturan log</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/461523/">  Jadi, kami berkenalan dengan perangkat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buffer cache</a> dan, menggunakan contohnya, kami menyadari bahwa ketika konten RAM hilang selama kegagalan, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">log pra-tulis</a> diperlukan untuk memulihkan.  Ukuran file log yang diperlukan dan waktu pemulihan terbatas karena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pos pemeriksaan yang</a> dieksekusi secara berkala. <br><br>  Dalam artikel sebelumnya, kita telah melihat sejumlah besar pengaturan penting yang terkait dengan jurnal dengan satu atau lain cara.  Dalam artikel ini (yang terakhir dalam seri ini), kami akan mempertimbangkan masalah penyetelan yang belum dibahas: level log dan tujuannya, serta keandalan dan kinerja logging. <br><br><h1>  Tingkat log </h1><br>  Tujuan utama dari prerecord log adalah untuk memberikan kemampuan untuk pulih dari kegagalan.  Tetapi, jika Anda masih harus membuat jurnal, itu dapat disesuaikan untuk tugas-tugas lain, menambahkan sejumlah informasi tambahan ke dalamnya.  Ada beberapa level logging.  Mereka diatur oleh parameter <em>wal_level</em> dan diatur sehingga log dari setiap level berikutnya mencakup semua yang masuk ke log dari level sebelumnya, ditambah sesuatu yang baru. <br><a name="habracut"></a><br><h2>  Minimal </h2><br>  Level minimum yang dimungkinkan ditetapkan oleh nilai <em>wal_level</em> = minimal dan menjamin pemulihan hanya setelah kegagalan.  Untuk menghemat ruang, operasi yang terkait dengan pemrosesan data massal (seperti CREATE TABLE AS SELECT atau CREATE INDEX) tidak dicatat.  Sebagai gantinya, data yang diperlukan segera ditulis ke disk, dan objek baru ditambahkan ke direktori sistem dan menjadi terlihat ketika transaksi dilakukan.  Jika kegagalan terjadi selama operasi, data yang sudah direkam tetap tidak terlihat dan tidak melanggar konsistensi.  Jika kegagalan terjadi setelah operasi selesai, semua yang diperlukan sudah pergi ke disk dan tidak perlu dicatat. <br><br>  Ayo lihat.  Pertama, atur level yang diperlukan (untuk ini Anda juga perlu mengubah parameter lain - <em>max_wal_senders</em> ). <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> wal_level = minimal; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> max_wal_senders = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main restart</code> </pre><br>  Perhatikan bahwa mengubah level memerlukan restart server. <br><br>  Ingat posisi saat ini di log: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/353927BC (1 row)</code> </pre><br>  Sekarang mari kita buat tabel (CREATE TABLE AS SELECT) dan tulis posisi di log lagi.  Jumlah data yang dipilih oleh pernyataan SELECT tidak masalah dalam kasus ini, jadi kami akan membatasi diri untuk satu baris. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> wallevel <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> n; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/353A7DFC (1 row)</code> </pre><br>  Dengan utilitas pg_waldump yang akrab, mari kita lihat entri log. <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_waldump -p /var/lib/postgresql/11/main/pg_wal -s 0/353927BC -e 0/353A7DFC</code> </pre><br>  Beberapa detail, tentu saja, mungkin berbeda dari peluncuran ke peluncuran, tetapi dalam kasus ini, inilah yang terjadi.  Entri manajer Heap2 merujuk pada pembersihan, di sini adalah pembersihan di halaman dari salah satu tabel dalam katalog sistem (objek sistem mudah dibedakan dengan mata telanjang dengan nomor "pendek" dalam rel): <br><br><pre> <code class="plaintext hljs">rmgr: Heap2 len (rec/tot): 59/ 7587, tx: 0, lsn: 0/353927BC, prev 0/35392788, desc: CLEAN remxid 101126, blkref #0: rel 1663/16386/1247 blk 8 FPW</code> </pre><br>  Lalu ada catatan tentang mendapatkan OID berikutnya untuk tabel yang akan kita buat: <br><br><pre> <code class="plaintext hljs">rmgr: XLOG len (rec/tot): 30/ 30, tx: 0, lsn: 0/35394574, prev 0/353927BC, desc: NEXTOID 82295</code> </pre><br>  Sekarang pembuatan tabel: <br><br><pre> <code class="plaintext hljs">rmgr: Storage len (rec/tot): 42/ 42, tx: 0, lsn: 0/35394594, prev 0/35394574, desc: CREATE base/16386/74103</code> </pre><br>  Namun, memasukkan data ke dalam tabel tidak dicatat.  Lalu ada banyak entri tentang memasukkan baris ke dalam tabel dan indeks yang berbeda - PostgreSQL ini mendaftarkan tabel yang dibuat dalam direktori sistem (saya berikan dalam bentuk singkatan): <br><br><pre> <code class="plaintext hljs">rmgr: Heap len (rec/tot): 203/ 203, tx: 101127, lsn: 0/353945C0, prev 0/35394594, desc: INSERT off 71, blkref #0: rel 1663/16386/1247 blk 8 rmgr: Btree len (rec/tot): 53/ 685, tx: 101127, lsn: 0/3539468C, prev 0/353945C0, desc: INSERT_LEAF off 37, blkref #0: rel 1663/16386/2703 blk 2 FPW ... rmgr: Btree len (rec/tot): 53/ 2393, tx: 101127, lsn: 0/353A747C, prev 0/353A6788, desc: INSERT_LEAF off 10, blkref #0: rel 1664/0/1233 blk 1 FPW</code> </pre><br>  Dan akhirnya, fiksasi transaksi: <br><br><pre> <code class="plaintext hljs">rmgr: Transaction len (rec/tot): 34/ 34, tx: 101127, lsn: 0/353A7DD8, prev 0/353A747C, desc: COMMIT 2019-07-23 18:59:34.923124 MSK</code> </pre><br><h2>  Replika </h2><br>  Ketika kami memulihkan sistem dari cadangan, kami mulai dari beberapa keadaan sistem file dan secara bertahap membawa data ke titik pemulihan, memutar ulang entri jurnal yang diarsipkan.  Jumlah catatan tersebut bisa sangat besar (misalnya, beberapa hari), yaitu periode pemulihan tidak akan mencakup satu titik kontrol, tetapi banyak.  Oleh karena itu, jelas bahwa tingkat minimum log tidak cukup - jika beberapa operasi tidak dicatat, kita tidak akan tahu bahwa itu perlu diulang.  Untuk memulihkan dari cadangan, <em>semua</em> operasi harus dicatat. <br><br>  Hal yang sama berlaku untuk replikasi - apa pun yang tidak dicatat tidak akan ditransfer ke replika dan tidak akan direproduksi.  Tetapi, jika kita ingin mengeksekusi permintaan pada replika, itu masih rumit. <br><br>  Pertama, kami memerlukan informasi tentang kunci eksklusif yang terjadi pada server utama, karena mungkin bertentangan dengan permintaan pada replika.  Kunci tersebut dicatat dan diterapkan pada replika (atas nama proses startup). <br><br>  Kedua, Anda harus dapat membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">snapshot data</a> , dan untuk ini, seingat kami, informasi tentang transaksi yang sedang berlangsung diperlukan.  Dalam kasus replika, kita berbicara tidak hanya tentang transaksi lokal, tetapi juga tentang transaksi di server utama.  Satu-satunya cara untuk mengirimkan informasi ini adalah dengan menuliskannya secara berkala ke log (ini terjadi setiap 15 detik). <br><br>  Level log, yang menjamin kemampuan untuk pulih dari cadangan dan kemungkinan replikasi fisik, ditentukan oleh nilai wal_level = <em>replika</em> .  (Sebelum versi 9.6, ada dua level arsip terpisah dan hot_standby, tetapi kemudian digabungkan menjadi satu yang umum.) <br><br>  Dimulai dengan PostgreSQL 10, level inilah yang ditetapkan secara default (dan sebelumnya minimal).  Karenanya, atur ulang parameter ke nilai default: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RESET</span></span> wal_level; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RESET</span></span> max_wal_senders;</code> </pre><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main restart</code> </pre><br>  Kami menghapus tabel dan mengulangi urutan tindakan yang sama persis seperti terakhir kali: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> wallevel; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/353AF21C (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> wallevel <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> n; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/353BE51C (1 row)</code> </pre><br>  Sekarang periksa entri jurnal. <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_waldump -p /var/lib/postgresql/11/main/pg_wal -s 0/353AF21C -e 0/353BE51C</code> </pre><br>  Membersihkan, mendapatkan OID, membuat tabel dan mendaftar di direktori sistem - untuk saat ini, semuanya seperti sebelumnya: <br><br><pre> <code class="plaintext hljs">rmgr: Heap2 len (rec/tot): 58/ 58, tx: 0, lsn: 0/353AF21C, prev 0/353AF044, desc: CLEAN remxid 101128, blkref #0: rel 1663/16386/1247 blk 8 rmgr: XLOG len (rec/tot): 30/ 30, tx: 0, lsn: 0/353AF258, prev 0/353AF21C, desc: NEXTOID 82298 rmgr: Storage len (rec/tot): 42/ 42, tx: 0, lsn: 0/353AF278, prev 0/353AF258, desc: CREATE base/16386/74106 rmgr: Heap len (rec/tot): 203/ 203, tx: 101129, lsn: 0/353AF2A4, prev 0/353AF278, desc: INSERT off 73, blkref #0: rel 1663/16386/1247 blk 8 rmgr: Btree len (rec/tot): 53/ 717, tx: 101129, lsn: 0/353AF370, prev 0/353AF2A4, … rmgr: Btree len (rec/tot): 53/ 2413, tx: 101129, lsn: 0/353BD954, prev 0/353BCC44, desc: INSERT_LEAF off 10, blkref #0: rel 1664/0/1233 blk 1 FPW</code> </pre><br>  Tapi sesuatu yang baru.  Catatan kunci eksklusif terkait dengan manajer Siaga - dalam hal ini, memblokir nomor transaksi (mengapa itu diperlukan, kami akan berbicara secara rinci dalam seri artikel berikutnya): <br><br><pre> <code class="plaintext hljs">rmgr: Standby len (rec/tot): 42/ 42, tx: 101129, lsn: 0/353BE2D8, prev 0/353BD954, desc: LOCK xid 101129 db 16386 rel 74106</code> </pre><br>  Dan ini adalah catatan tentang memasukkan baris ke dalam tabel kami (bandingkan rel nomor file dengan yang ditunjukkan di atas dalam catatan BUAT): <br><br><pre> <code class="plaintext hljs">rmgr: Heap len (rec/tot): 59/ 59, tx: 101129, lsn: 0/353BE304, prev 0/353BE2D8, desc: INSERT+INIT off 1, blkref #0: rel 1663/16386/74106 blk 0</code> </pre><br>  Catatan komitmen: <br><br><pre> <code class="plaintext hljs">rmgr: Transaction len (rec/tot): 421/ 421, tx: 101129, lsn: 0/353BE340, prev 0/353BE304, desc: COMMIT 2019-07-23 18:59:37.870333 MSK; inval msgs: catcache 74 catcache 73 catcache 74 catcache 73 catcache 50 catcache 49 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 snapshot 2608 relcache 74106 snapshot 1214</code> </pre><br>  Dan catatan lain, yang terjadi secara berkala dan tidak terikat pada transaksi yang diselesaikan, merujuk pada manajer Siaga dan melaporkan transaksi yang sedang berlangsung saat ini: <br><br><pre> <code class="plaintext hljs">rmgr: Standby len (rec/tot): 50/ 50, tx: 0, lsn: 0/353BE4E8, prev 0/353BE340, desc: RUNNING_XACTS nextXid 101130 latestCompletedXid 101129 oldestRunningXid 101130</code> </pre><br><h2>  Logis </h2><br>  Akhirnya, level terakhir diatur oleh nilai parameter <em>wal_level</em> = logical dan memberikan kemungkinan decoding logis dan replikasi logis.  Itu harus diaktifkan di server penerbitan. <br><br>  Dari sudut pandang entri jurnal, level ini praktis tidak berbeda dari replika - catatan yang terkait dengan asal replikasi dan entri logis sewenang-wenang yang dapat ditambahkan ke log aplikasi ditambahkan.  Pada dasarnya, decoding logis tergantung pada informasi tentang transaksi yang sedang berlangsung, karena Anda perlu membuat snapshot data untuk melacak perubahan dalam katalog sistem. <br><br>  Sekarang kita tidak akan membahas detail operasi pencadangan dan replikasi - ini adalah topik besar untuk serangkaian artikel terpisah. <br><br><h1>  Rekam keandalan </h1><br>  Jelas bahwa mekanisme penjurnalan harus dapat diandalkan dan memberikan jaminan kemungkinan pemulihan dalam situasi apa pun (tidak terkait, tentu saja, untuk merusak pembawa data).  Keandalan dipengaruhi oleh banyak faktor, di mana kami akan mempertimbangkan caching, korupsi data, dan atomitas rekaman. <br><br><h2>  Caching </h2><br>  Ada banyak cache di jalur data ke penyimpanan non-volatile (seperti hard disk drive). <br><br>  Ketika sebuah program (ada, tetapi dalam kasus kami PostgreSQL) meminta sistem operasi untuk menulis sesuatu ke disk, sistem operasi akan mentransfer data ke cache dalam RAM.  Perekaman aktual terjadi secara tidak sinkron, tergantung pada pengaturan penjadwal I / O sistem operasi. <br><br>  Ketika OS memutuskan untuk menulis data, mereka jatuh ke dalam cache drive (hard disk).  Drive elektronik juga dapat menunda perekaman, misalnya, mengumpulkan data dalam kelompok yang lebih menguntungkan untuk direkam pada saat bersamaan.  Dan jika pengontrol RAID digunakan, level caching lain muncul antara OS dan drive. <br><br>  Jadi, jika Anda tidak mengambil tindakan khusus, itu sama sekali tidak jelas kapan data akan benar-benar disimpan dengan aman.  Ini biasanya tidak penting, tetapi ada tempat-tempat penting di mana PostgreSQL perlu memastikan bahwa data ditulis dengan aman.  Pertama-tama, ini adalah penjurnalan (jika entri jurnal tidak mencapai disk, itu akan hilang bersama dengan sisa isi RAM) dan sebuah pos pemeriksaan (harus yakin bahwa halaman-halaman yang kotor benar-benar ditulis ke disk).  Tetapi ada situasi lain, katakanlah, pelaksanaan operasi non-jurnal pada tingkat minimum, dll. <br><br>  Sistem operasi menyediakan alat yang harus menjamin penulisan data segera ke memori non-volatile.  Ada beberapa opsi, tetapi turun menjadi dua opsi utama: perintah sinkronisasi diberikan setelah perekaman (fsync, fdatasync), atau ketika membuka file (atau menulisnya), bendera khusus diindikasikan untuk sinkronisasi atau bahkan perekaman langsung, melewati cache OS. <br><br>  Adapun log, utilitas pg_test_fsync memungkinkan Anda untuk memilih metode yang paling cocok untuk OS tertentu dan sistem file tertentu, dan itu diinstal dalam parameter konfigurasi <em>wal_sync_method</em> .  File biasa selalu disinkronkan menggunakan fsync. <br><br>  Poin halusnya adalah bahwa ketika memilih metode, karakteristik peralatan harus diperhitungkan.  Misalnya, jika Anda menggunakan pengontrol yang didukung oleh baterai cadangan, tidak ada alasan untuk tidak menggunakan cache, karena baterai akan menyimpan data jika terjadi kegagalan daya. <br><br><blockquote>  Dokumentasi berisi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">banyak detail</a> tentang hal ini. <br></blockquote><br>  Dalam kasus apa pun, sinkronisasi itu mahal dan berlangsung tidak lebih dari yang diperlukan (kami akan kembali ke masalah ini sedikit lebih rendah ketika kami berbicara tentang kinerja). <br><br>  Secara umum, sinkronisasi dapat dimatikan (parameter <em>fsync</em> bertanggung jawab untuk ini), tetapi dalam hal ini Anda harus melupakan keandalan penyimpanan.  Dengan menonaktifkan <em>fsync</em> , Anda setuju bahwa data dapat hilang kapan saja.  Mungkin satu-satunya pilihan yang masuk akal untuk menggunakan opsi ini adalah untuk sementara meningkatkan produktivitas, ketika data dapat dengan mudah dipulihkan dari sumber lain (misalnya, selama migrasi awal). <br><br><h2>  Korupsi data </h2><br>  Peralatan tidak sempurna dan data mungkin rusak pada media, saat mengirim data melalui kabel antarmuka, dll. Beberapa kesalahan ini diproses pada tingkat perangkat keras, tetapi beberapa tidak. <br><br>  Untuk mendeteksi masalah pada waktunya, entri jurnal selalu dilengkapi dengan checksum. <br><br>  Halaman data juga dapat dilindungi dengan checksum.  Untuk saat ini, ini hanya dapat dilakukan ketika cluster diinisialisasi, tetapi dalam PostgreSQL 12 akan dimungkinkan untuk menghidupkan dan mematikannya menggunakan utilitas pg_checksums (meskipun belum on the fly, tetapi hanya ketika server dihentikan). <br><br>  Dalam lingkungan produksi, checksum harus dimasukkan, meskipun perhitungan dan kontrolnya terlalu mahal.  Ini mengurangi kemungkinan bahwa kegagalan tidak akan terdeteksi pada waktunya. <br><br><blockquote>  Mengurangi, tetapi tidak menghilangkan. <br>  Pertama, checksum hanya diperiksa ketika mengakses halaman - oleh karena itu, kerusakan bisa tidak diketahui sampai masuk ke semua cadangan.  Itu sebabnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pg_probackup</a> memeriksa checksum dari semua halaman cluster selama cadangan. <br>  Kedua, halaman diisi dengan nol dianggap benar - jika sistem file keliru "membatalkan" file, ini mungkin tidak diperhatikan. <br>  Ketiga, checksum hanya melindungi lapisan utama file data.  Lapisan yang tersisa dan file lainnya (misalnya, status transaksi XACT) tidak dilindungi oleh apa pun. <br>  Sayang <br></blockquote><br>  Mari kita lihat cara kerjanya.  Pertama, pastikan checksum diaktifkan (perlu diingat bahwa ini tidak terjadi ketika menginstal paket pada sistem seperti Debian): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> data_checksums;</code> </pre><pre> <code class="plaintext hljs"> data_checksums ---------------- on (1 row)</code> </pre><br>  Parameter <em>data_checksums</em> hanya-baca. <br><br>  Berikut adalah file di mana tabel kami berada: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'wallevel'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath ---------------------- base/16386/24890 (1 row)</code> </pre><br>  Hentikan server dan ubah beberapa byte di halaman nol, misalnya, hapus entri log terakhir dari header LSN. <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main stop</code> </pre><br><pre> <code class="plaintext hljs">postgres$ dd if=/dev/zero of=/var/lib/postgresql/11/main/base/16386/24890 oflag=dsync conv=notrunc bs=1 count=8</code> </pre><pre> <code class="plaintext hljs">8+0 records in 8+0 records out 8 bytes copied, 0,0083022 s, 1,0 kB/s</code> </pre><br>  Pada prinsipnya, server tidak bisa dihentikan.  Cukup bahwa halaman ditulis ke disk dan dipaksa keluar dari cache (jika tidak server akan bekerja dengan halaman dari cache).  Tetapi skenario seperti itu lebih sulit untuk direproduksi. <br><br>  Sekarang kita mulai server dan mencoba membaca tabel. <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main start</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> wallevel;</code> </pre><pre> <code class="plaintext hljs">WARNING: page verification failed, calculated checksum 23222 but expected 50884 ERROR: invalid page in block 0 of relation base/16386/24890</code> </pre><br>  Tetapi bagaimana jika data tidak dapat dipulihkan dari cadangan?  Parameter <em>ign_checksum_failure</em> memungkinkan <em>Anda</em> mencoba membaca tabel, secara alami dengan risiko mendapatkan data yang terdistorsi. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> ignore_checksum_failure = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> wallevel;</code> </pre><pre> <code class="plaintext hljs">WARNING: page verification failed, calculated checksum 23222 but expected 50884 n --- 1 (1 row)</code> </pre><br>  Tentu saja, dalam hal ini, semuanya berjalan dengan baik, karena kami hanya mengacaukan judul halaman, dan bukan data itu sendiri. <br><br>  Dan satu hal lagi.  Ketika checksum diaktifkan, bit prompt dituliskan ke log (kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memeriksanya</a> sebelumnya), karena perubahan bit apa pun, bahkan yang tidak esensial, juga mengarah pada perubahan checksum.  Ketika checksum dimatikan, parameter <em>wal_log_hints</em> bertanggung jawab untuk menulis bit petunjuk ke <em>log</em> . <br><br>  Perubahan pada bit tooltip selalu dicatat sebagai <em>gambar halaman penuh</em> (FPI, gambar halaman penuh), yang meningkatkan ukuran log secara berurutan.  Dalam hal ini, masuk akal untuk mengaktifkan kompresi gambar penuh menggunakan parameter <em>wal_compression</em> (parameter ini muncul di versi 9.5).  Di bawah ini kita melihat angka-angka tertentu. <br><br><h2>  Catatan atomitas </h2><br>  Dan akhirnya, ada masalah atomitas catatan.  Halaman database membutuhkan setidaknya 8 KB (bisa 16 atau 32 KB), dan pada level rendah, perekaman terjadi dalam blok yang biasanya lebih kecil (biasanya 512 byte atau 4 KB).  Oleh karena itu, dalam hal terjadi kegagalan daya, halaman data dapat direkam sebagian.  Jelas bahwa selama pemulihan tidak masuk akal untuk menerapkan entri jurnal biasa ke halaman seperti itu. <br><br>  Untuk perlindungan, PostgreSQL memungkinkan Anda menulis ke log <em>gambar penuh halaman</em> ketika pertama kali diubah setelah dimulainya titik kontrol (gambar yang sama direkam ketika bit tooltip berubah).  Parameter <em>full_page_writes mengontrol ini</em> , dan diaktifkan secara default. <br><br>  Jika gambar halaman ditemukan selama pemulihan dalam log, itu tanpa syarat (tanpa pemeriksaan LSN) ditulis ke disk: ada lebih banyak kepercayaan di dalamnya, karena, seperti catatan log apa pun, itu dilindungi oleh checksum.  Dan entri jurnal yang sudah biasa diterapkan pada gambar yang benar dijamin ini. <br><br>  Meskipun PostgreSQL mengecualikan ruang yang tidak terisi dari gambar halaman penuh (kami sebelumnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">melihat</a> struktur blok), volume entri jurnal yang dihasilkan meningkat secara signifikan.  Seperti yang telah disebutkan, situasinya dapat ditingkatkan dengan mengompresi gambar penuh (parameter <em>wal_compression</em> ). <br><br>  Untuk merasakan perubahan ukuran log, kami akan melakukan percobaan sederhana menggunakan utilitas pgbench.  Mari kita inisialisasi: <br><br><pre> <code class="plaintext hljs">student$ pgbench -i test</code> </pre><pre> <code class="plaintext hljs">dropping old tables... creating tables... generating data... 100000 of 100000 tuples (100%) done (elapsed 0.15 s, remaining 0.00 s) vacuuming... creating primary keys... done.</code> </pre><br>  <em>Opsi full_page_writes</em> diaktifkan: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> full_page_writes;</code> </pre><pre> <code class="plaintext hljs"> full_page_writes ------------------ on (1 row)</code> </pre><br>  Jalankan breakpoint dan segera jalankan tes selama 30 detik. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CHECKPOINT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/38E04A08 (1 row)</code> </pre><br><pre> <code class="plaintext hljs">student$ pgbench -T 30 test</code> </pre><pre> <code class="plaintext hljs">starting vacuum...end. transaction type: &lt;builtin: TPC-B (sort of)&gt; scaling factor: 1 query mode: simple number of clients: 1 number of threads: 1 duration: 30 s number of transactions actually processed: 26851 latency average = 1.117 ms tps = 895.006720 (including connections establishing) tps = 895.095229 (excluding connections establishing)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3A69C478 (1 row)</code> </pre><br>  Ukuran Log: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(<span class="hljs-string"><span class="hljs-string">'0/3A69C478'</span></span>::pg_lsn - <span class="hljs-string"><span class="hljs-string">'0/38E04A08'</span></span>::pg_lsn);</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 25 MB (1 row)</code> </pre><br>  Sekarang matikan parameter full_page_writes: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> full_page_writes = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Dan ulangi percobaannya. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CHECKPOINT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3A69C530 (1 row)</code> </pre><br><pre> <code class="plaintext hljs">student$ pgbench -T 30 test</code> </pre><pre> <code class="plaintext hljs">starting vacuum...end. transaction type: &lt;builtin: TPC-B (sort of)&gt; scaling factor: 1 query mode: simple number of clients: 1 number of threads: 1 duration: 30 s number of transactions actually processed: 27234 latency average = 1.102 ms tps = 907.783080 (including connections establishing) tps = 907.895326 (excluding connections establishing)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3BE87658 (1 row)</code> </pre><br>  Ukuran Log: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(<span class="hljs-string"><span class="hljs-string">'0/3BE87658'</span></span>::pg_lsn - <span class="hljs-string"><span class="hljs-string">'0/3A69C530'</span></span>::pg_lsn);</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 24 MB (1 row)</code> </pre><br>  Ya, ukurannya telah menurun, tetapi sama sekali tidak sepenting yang diharapkan. <br><br>  Alasannya adalah bahwa cluster diinisialisasi dengan checksum di halaman data, dan karena itu Anda masih harus menulis gambar halaman penuh ke log ketika mengubah bit tooltip.  Data ini (dalam kasus kami) membentuk sekitar setengah dari total volume, yang dapat dilihat dengan melihat statistik: <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_waldump --stats -p /var/lib/postgresql/11/main/pg_wal -s 0/3A69C530 -e 0/3BE87658</code> </pre><pre> <code class="plaintext hljs">Type N (%) Record size (%) FPI size (%) ---- - --- ----------- --- -------- --- XLOG 1721 ( 1,03) 84329 ( 0,77) 13916104 (100,00) Transaction 27235 ( 16,32) 926070 ( 8,46) 0 ( 0,00) Storage 1 ( 0,00) 42 ( 0,00) 0 ( 0,00) CLOG 1 ( 0,00) 30 ( 0,00) 0 ( 0,00) Standby 4 ( 0,00) 240 ( 0,00) 0 ( 0,00) Heap2 27522 ( 16,49) 1726352 ( 15,76) 0 ( 0,00) Heap 109691 ( 65,71) 8169121 ( 74,59) 0 ( 0,00) Btree 756 ( 0,45) 45380 ( 0,41) 0 ( 0,00) -------- -------- -------- Total 166931 10951564 [44,04%] 13916104 [55,96%]</code> </pre><br>  Untuk kekompakan, saya menghapus nol baris dari tabel.  Perhatikan garis total (Total) dan bandingkan ukuran gambar penuh (ukuran FPI) dengan ukuran rekaman biasa (Ukuran rekam). <br><br>  Parameter <em>full_page_writes</em> hanya dapat dinonaktifkan jika sistem file dan perangkat keras yang digunakan sendiri menjamin perekaman atom.  Tapi, seperti yang bisa kita lihat, tidak ada alasan yang bagus untuk ini (dengan asumsi bahwa checksum dimasukkan). <br><br>  Sekarang mari kita lihat bagaimana kompresi membantu. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> full_page_writes = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> wal_compression = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Ulangi percobaan yang sama. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CHECKPOINT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3BE87710 (1 row)</code> </pre><br><pre> <code class="plaintext hljs">student$ pgbench -T 30 test</code> </pre><pre> <code class="plaintext hljs">starting vacuum...end. transaction type: &lt;builtin: TPC-B (sort of)&gt; scaling factor: 1 query mode: simple number of clients: 1 number of threads: 1 duration: 30 s number of transactions actually processed: 26833 latency average = 1.118 ms tps = 894.405027 (including connections establishing) tps = 894.516845 (excluding connections establishing)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3CBD3EA8 (1 row)</code> </pre><br>  Ukuran Log: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(<span class="hljs-string"><span class="hljs-string">'0/3CBD3EA8'</span></span>::pg_lsn - <span class="hljs-string"><span class="hljs-string">'0/3BE87710'</span></span>::pg_lsn);</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 13 MB (1 row)</code> </pre><br>  Kesimpulan: di hadapan sejumlah besar gambar halaman penuh (karena checksum atau <em>full_page_writes</em> , yaitu, hampir selalu), kemungkinan besar masuk akal untuk menggunakan kompresi meskipun faktanya ini memuat prosesor. <br><br><h1>  Performa </h1><br>  Selama operasi server normal, terjadi perekaman berkelanjutan file log.  Karena tidak ada akses acak, HDD biasa juga mengatasi tugas ini.  Namun sifat beban ini sangat berbeda dari cara file data diakses. <br><br>  Oleh karena itu, biasanya menguntungkan untuk menempatkan log pada disk fisik yang terpisah (atau array disk) yang dipasang pada sistem file server.  Alih-alih direktori $ PGDATA / pg_wal, Anda perlu membuat tautan simbolis ke direktori yang sesuai. <br><br><blockquote>  Ada beberapa situasi di mana file log tidak hanya perlu ditulis, tetapi juga dibaca.  Yang pertama adalah kasus pemulihan yang dapat dimengerti setelah kegagalan.  Yang kedua kurang sepele.  Ini terjadi jika replikasi streaming digunakan, dan replika tidak berhasil menerima entri jurnal saat masih dalam buffer RAM server utama.  Maka proses walsender harus membaca data yang diperlukan dari disk.  Kami akan membicarakan hal ini secara lebih rinci ketika kami mendapatkan replikasi. <br></blockquote><br>  Pencatatan terjadi dalam salah satu dari dua mode: <br><br><ul><li>  sinkron - ketika transaksi dilakukan, kelanjutan pekerjaan tidak mungkin sampai semua entri jurnal tentang transaksi ini ada di disk; </li><li>  asynchronous - transaksi selesai dengan segera, dan log ditulis di latar belakang. </li></ul><br>  Mode sinkron ditentukan oleh parameter <em>syncous_commit</em> dan diaktifkan secara default. <br><br>  Karena sinkronisasi dikaitkan dengan I / O yang nyata (lambat), maka bermanfaat untuk melakukannya sesedikit mungkin.  Untuk melakukan ini, proses servis yang menyelesaikan transaksi dan menulis log membutuhkan jeda singkat, ditentukan oleh parameter <em>commit_delay</em> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi ini hanya terjadi jika sistem memiliki setidaknya </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">commit_siblings</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> transaksi aktif. Taruhan di sini adalah pada kenyataan bahwa selama menunggu beberapa transaksi akan selesai dan akan memungkinkan untuk menyinkronkan catatan mereka dalam sekali jalan. Ini mirip dengan cara Anda memegang pintu elevator sehingga seseorang memiliki waktu untuk masuk ke dalam kabin. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameter defaultnya adalah </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">commit_siblings</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 5, dan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">commit_delay</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 0, jadi tidak ada tunggu yang sebenarnya. Perubahan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">commit_delay</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hanya berguna dalam sistem yang melakukan sejumlah besar pendek OLTP-transaksi.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kemudian proses mem-flush log ke disk ke LSN yang diperlukan (atau sedikit lebih jika entri baru ditambahkan selama waktu tunggu). Setelah itu, transaksi dianggap selesai. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan perekaman sinkron, ketahanan terjamin (huruf D dalam akronim ACID) - jika transaksi dilakukan, maka semua entri jurnalnya sudah ada di disk dan tidak akan hilang. Kelemahannya adalah perekaman sinkron meningkatkan waktu respons (perintah COMMIT tidak mengembalikan kontrol sampai sinkronisasi berakhir) dan mengurangi kinerja sistem. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tulisan asinkron dapat diperoleh dengan mengatur </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">syncous_commit</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = off (atau lokal). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selama perekaman asinkron, proses penulis log mengatur ulang entri jurnal, bergantian siklus tunggu (yang ditetapkan oleh parameter</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wal_writer_delay</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 200 </font><em><font style="vertical-align: inherit;">ms</font></em><font style="vertical-align: inherit;"> secara default). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bangun setelah menunggu berikutnya, proses memeriksa apakah halaman WAL lengkap telah muncul dari terakhir kali. Jika ada, maka proses mengabaikan halaman saat ini, tidak terisi, dan catatan hanya yang benar-benar terisi. (Benar, itu tidak selalu sekaligus: rekaman berhenti, mencapai akhir cache, dan berlanjut dari awal cache di waktu berikutnya.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika tidak satu halaman penuh, proses menulis halaman jurnal saat ini (tidak lengkap) - untuk alasan yang baik bangun? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algoritma ini bertujuan untuk tidak menyinkronkan halaman yang sama beberapa kali jika memungkinkan, yang penting untuk aliran perubahan yang besar.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perekaman asinkron lebih efisien daripada perekaman sinkron - perubahan yang dilakukan tidak menunggu perekaman. Namun, reliabilitas menurun: data yang diambil dapat menghilang jika terjadi kegagalan jika kurang dari 3 × </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wal_writer_delay</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> waktu </font><font style="vertical-align: inherit;">berlalu antara komit dan kegagalan </font><font style="vertical-align: inherit;">(yang, secara default, sedikit lebih dari setengah detik). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pilihan yang sulit - efisiensi atau keandalan - tetap ada pada administrator sistem. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Harap dicatat: tidak seperti mematikan sinkronisasi ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fsync</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = off), mode asinkron tidak menyebabkan ketidakmungkinan pemulihan. Jika terjadi kegagalan, sistem masih akan memulihkan keadaan yang konsisten, tetapi mungkin beberapa transaksi terbaru tidak ada di dalamnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameter </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Synchronous_commit</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dapat ditetapkan sebagai bagian dari transaksi individu. Ini memungkinkan Anda untuk meningkatkan produktivitas dengan mengorbankan keandalan hanya sebagian dari transaksi. Katakanlah, transaksi keuangan selalu harus diperbaiki secara sinkron, dan pesan obrolan terkadang dapat diabaikan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada kenyataannya, kedua mode ini bekerja bersama. Bahkan dengan komit sinkron, log transaksi panjang akan ditulis secara tidak sinkron untuk membebaskan buffer WAL. Dan jika, ketika mengatur ulang halaman dari cache buffer, ternyata entri jurnal yang sesuai belum pada disk, itu akan segera diatur ulang dalam mode sinkron. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mendapatkan gambaran tentang apa yang diberikan asynchronous commit, kami mencoba mengulangi tes pgbench dalam mode ini.</font></font><br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> synchronous_commit = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br><pre> <code class="plaintext hljs">student$ pgbench -T 30 test</code> </pre><pre> <code class="plaintext hljs">starting vacuum...end. transaction type: &lt;builtin: TPC-B (sort of)&gt; scaling factor: 1 query mode: simple number of clients: 1 number of threads: 1 duration: 30 s number of transactions actually processed: 45439 latency average = 0.660 ms tps = 1514.561710 (including connections establishing) tps = 1514.710558 (excluding connections establishing)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan komit sinkron, kami menerima sekitar 900 transaksi per detik (tps), dengan komit asinkron - 1500. Tentu saja, dalam sistem nyata di bawah beban riil rasionya akan berbeda, tetapi jelas bahwa pengaruhnya bisa sangat signifikan dengan transaksi pendek. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada titik ini, serangkaian artikel tentang penjurnalan berakhir. </font><font style="vertical-align: inherit;">Jika sesuatu yang penting tetap ada di belakang layar, jangan merasa sulit untuk menulis di komentar. </font><font style="vertical-align: inherit;">Terima kasih semuanya! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan kemudian kita akan memiliki petualangan yang menarik di dunia gembok, tapi itu cerita lain.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id461523/">https://habr.com/ru/post/id461523/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id461507/index.html">Mengapa kami memutuskan untuk meluncurkan StartupDrive akselerator perusahaan Gazprom Neft, dan siapa yang sudah melewatinya</a></li>
<li><a href="../id461509/index.html">Asisten Perjalanan: Pilihan gadget dan aksesori</a></li>
<li><a href="../id461511/index.html">Manajemen Ketergantungan Python: Perbandingan Pendekatan</a></li>
<li><a href="../id461517/index.html">Algoritma Copy-Paste Terbaik untuk C dan C ++. Haiku OS Cookbook</a></li>
<li><a href="../id461519/index.html">Algoritma Copy-Paste Terbaik untuk C dan C ++. Koleksi Resep OS Haiku</a></li>
<li><a href="../id461525/index.html">Bagaimana saya melakukan slider yang benar-benar adaptif (carousel)</a></li>
<li><a href="../id461527/index.html">Pengangkatan akustik DIY</a></li>
<li><a href="../id461531/index.html">Tic Tac Toe, Bagian 6: Labu dan Seledri / RabbitMQ</a></li>
<li><a href="../id461533/index.html">Visualisasi tidur tahun pertama anak pada pola selimut</a></li>
<li><a href="../id461535/index.html">C ++, FIX, Oracle, dan PL / SQL: apa yang perlu diketahui oleh spesialis TI untuk mendapatkan pekerjaan di bidang keuangan + peluang kerja nyata</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>