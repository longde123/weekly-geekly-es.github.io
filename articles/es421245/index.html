<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∂ üë®üèº‚Äç‚öñÔ∏è üíáüèø C #: un caso de uso para cualquier tarea üë©üèΩ‚Äçüåæ ‚õΩÔ∏è üçØ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! Seguimos hablando de programaci√≥n asincr√≥nica en C #. Hoy hablaremos sobre un caso de uso √∫nico o un escenario espec√≠fico del usuario adecu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C #: un caso de uso para cualquier tarea</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/421245/">  Hola Habr!  Seguimos hablando de programaci√≥n asincr√≥nica en C #.  Hoy hablaremos sobre un caso de uso √∫nico o un escenario espec√≠fico del usuario adecuado para cualquier tarea en el marco de la programaci√≥n asincr√≥nica.  Tocaremos los temas de sincronizaci√≥n, puntos muertos, configuraciones del operador, manejo de excepciones y mucho m√°s.  √önete ahora! <br><br><img src="https://habrastorage.org/webt/fn/3y/w8/fn3yw8b2lmo8cbbziqaiogmvsxy.jpeg"><a name="habracut"></a><br><br><blockquote>  <b>Art√≠culos relacionados anteriores</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Programaci√≥n as√≠ncrona C #: ¬øC√≥mo le va con el rendimiento?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Reemplazar Equals y GetHashCode.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬øPero es necesario?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬øQu√© se puede encontrar en el c√≥digo de otra persona?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Una selecci√≥n de materiales √∫tiles para .NET</a> </li></ul></blockquote><br>  Casi cualquier comportamiento no est√°ndar de los m√©todos as√≠ncronos en C # se puede explicar sobre la base de un escenario de usuario: la conversi√≥n de un c√≥digo s√≠ncrono existente a as√≠ncrono deber√≠a ser lo m√°s simple posible.  Debe poder agregar la palabra clave as√≠ncrona antes del tipo de retorno del m√©todo, agregar el sufijo as√≠ncrono al nombre de este m√©todo y agregar la palabra clave de espera aqu√≠ y en el √°rea de texto del m√©todo para obtener un m√©todo asincr√≥nico completamente funcional. <br><br><img width="550" src="https://habrastorage.org/webt/di/uw/i8/diuwi85jehdfov_iozovmreg59s.png"><br><br>  Un escenario "simple" cambia dr√°sticamente muchos aspectos del comportamiento de los m√©todos asincr√≥nicos: desde la planificaci√≥n de la duraci√≥n de una tarea hasta el manejo de excepciones.  El gui√≥n parece convincente y significativo, pero en su contexto, la simplicidad de los m√©todos asincr√≥nicos se vuelve muy enga√±osa. <br><br><h2>  Contexto de sincronizaci√≥n </h2><br>  El desarrollo de la interfaz de usuario (UI) es un √°rea donde el escenario anterior es especialmente importante.  Debido a las largas operaciones en el hilo de la interfaz de usuario, el tiempo de respuesta de las aplicaciones aumenta, en cuyo caso la programaci√≥n asincr√≥nica siempre se ha considerado una herramienta muy efectiva. <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buttonOk_ClickAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs args</span></span></span><span class="hljs-function">)</span></span> { textBox.Text = <span class="hljs-string"><span class="hljs-string">"Running.."</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 1 -- UI Thread var result = await _stockPrices.GetStockPricesForAsync("MSFT"); // 2 -- Usually non-UI Thread textBox.Text = "Result is: " + result; //3 -- Should be UI Thread }</span></span></code> </pre> <br>  El c√≥digo parece muy simple, pero hay un problema.  Existen restricciones para la mayor√≠a de las interfaces de usuario: los elementos de la interfaz de usuario solo se pueden cambiar mediante hilos especiales.  Es decir, en la l√≠nea 3 se produce un error si la duraci√≥n de la tarea est√° programada en el subproceso del grupo de subprocesos.  Afortunadamente, este problema se conoce desde hace mucho tiempo y el concepto de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un contexto de sincronizaci√≥n</a> apareci√≥ en .NET Framework 2.0. <br><br>  Cada interfaz de usuario proporciona utilidades especiales para ordenar tareas en uno o m√°s hilos de interfaz de usuario especializados.  Windows Forms usa el m√©todo <code>Control.Invoke</code> , WPF <code>Control.Invoke</code> m√©todo Dispatcher.Invoke, otros sistemas pueden acceder a otros m√©todos.  Los esquemas utilizados en todos estos casos son muy similares, pero difieren en detalles.  El contexto de sincronizaci√≥n le permite abstraerse de las diferencias al proporcionar una API para ejecutar el c√≥digo en un contexto "especial" que proporciona el procesamiento de detalles menores por tipos derivados como <code>WindowsFormsSynchronizationContext</code> , <code>DispatcherSynchronizationContext</code> , etc. <br><br>  Para resolver el problema de la afinidad de subprocesos, los programadores de C # decidieron ingresar al contexto de sincronizaci√≥n actual en la etapa inicial de la implementaci√≥n de m√©todos asincr√≥nicos y planificar todas las operaciones posteriores en este contexto.  Ahora, cada uno de los bloques entre las declaraciones de espera se ejecuta en el hilo de la interfaz de usuario, lo que hace posible implementar el script principal.  Sin embargo, esta soluci√≥n dio lugar a una serie de nuevos problemas. <br><br><h2>  Puntos muertos </h2><br>  Veamos un peque√±o fragmento de c√≥digo relativamente simple.  ¬øHay alg√∫n problema aqu√≠? <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// UI code private void buttonOk_Click(object sender, EventArgs args) { textBox.Text = "Running.."; var result = _stockPrices.GetStockPricesForAsync("MSFT").Result; textBox.Text = "Result is: " + result; } // StockPrices.dll public Task&lt;decimal&gt; GetStockPricesForAsync(string symbol) { await Task.Yield(); return 42; }</span></span></code> </pre> <br>  Este c√≥digo provoca un <b>punto muerto</b> .  El subproceso de interfaz de usuario inicia una operaci√≥n asincr√≥nica y espera el resultado sincr√≥nicamente.  Sin embargo, el m√©todo asincr√≥nico no se puede completar porque la segunda l√≠nea de <code>GetStockPricesForAsync</code> debe ejecutarse en el hilo de la interfaz de usuario que causa el punto muerto. <br><br>  Usted objetar√° que este problema es bastante f√°cil de resolver.  Si de hecho.  <code>Task.Result</code> prohibir todas las llamadas al <code>Task.Wait</code> <code>Task.Result</code> o <code>Task.Wait</code> del c√≥digo de la interfaz de usuario, sin embargo, el problema a√∫n puede ocurrir si el componente utilizado por dicho c√≥digo est√° esperando el resultado de la operaci√≥n del usuario sincr√≥nicamente: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// UI code private void buttonOk_Click(object sender, EventArgs args) { textBox.Text = "Running.."; var result = _stockPrices.GetStockPricesForAsync("MSFT").Result; textBox.Text = "Result is: " + result; } // StockPrices.dll public Task&lt;decimal&gt; GetStockPricesForAsync(string symbol) { // We know that the initialization step is very fast, // and completes synchronously in most cases, // let's wait for the result synchronously for "performance reasons". InitializeIfNeededAsync().Wait(); return Task.FromResult((decimal)42); } // StockPrices.dll private async Task InitializeIfNeededAsync() =&gt; await Task.Delay(1);</span></span></code> </pre> <br>  Este c√≥digo nuevamente causa un punto muerto.  C√≥mo resolverlo: <br><br><ul><li>  No debe bloquear el c√≥digo asincr√≥nico con <code>Task.Wait()</code> o <code>Task.Result</code> y </li><li>  use <code>ConfigureAwait(false)</code> en el c√≥digo de la biblioteca. </li></ul><br>  El significado de la primera recomendaci√≥n es claro, y la segunda lo explicaremos a continuaci√≥n. <br><br><h2>  Configurar declaraciones de espera </h2><br>  Hay dos razones por las que se produce un punto muerto en el √∫ltimo ejemplo: <code>Task.Wait()</code> en <code>GetStockPricesForAsync</code> y el uso indirecto del contexto de sincronizaci√≥n en los pasos posteriores en InitializeIfNeededAsync.  Aunque los programadores de C # no recomiendan bloquear llamadas a m√©todos asincr√≥nicos, es obvio que en la mayor√≠a de los casos este bloqueo todav√≠a se usa.  Los programadores de C # ofrecen la siguiente soluci√≥n a un problema de punto muerto: <code>Task.ConfigureAwait(continueOnCapturedContext:false)</code> . <br><br>  A pesar de la apariencia extra√±a (si una llamada al m√©todo se ejecuta sin un argumento con nombre, esto no significa nada en absoluto), esta soluci√≥n cumple su funci√≥n: proporciona una continuaci√≥n forzada de la ejecuci√≥n sin un contexto de sincronizaci√≥n. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPricesForAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> symbol</span></span></span><span class="hljs-function">)</span></span> { InitializeIfNeededAsync().Wait(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.FromResult((<span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span>)<span class="hljs-number"><span class="hljs-number">42</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeIfNeededAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1</span></span>).ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre> <br>  En este caso, la continuaci√≥n de la <code>Task.Delay(1</code> ) (aqu√≠ est√° la declaraci√≥n vac√≠a) se planifica en el subproceso del grupo de subprocesos y no en el subproceso de la interfaz de usuario, lo que elimina el punto muerto. <br><br><h2>  Deshabilitar el contexto de sincronizaci√≥n </h2><br>  S√© que <code>ConfigureAwait</code> realmente resuelve este problema, pero genera mucho m√°s.  Aqu√≠ hay un peque√±o ejemplo: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPricesForAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> symbol</span></span></span><span class="hljs-function">)</span></span> { InitializeIfNeededAsync().Wait(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.FromResult((<span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span>)<span class="hljs-number"><span class="hljs-number">42</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeIfNeededAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Initialize the cache field first await _cache.InitializeAsync().ConfigureAwait(false); // Do some work await Task.Delay(1); }</span></span></code> </pre> <br>  ¬øVes el problema?  Utilizamos <code>ConfigureAwait(false)</code> , por lo que todo deber√≠a estar bien.  Pero no es un hecho. <br><br>  <code>ConfigureAwait(false)</code> devuelve un objeto <code>ConfiguredTaskAwaitable</code> mesero personalizado, y sabemos que se usa solo si la tarea no se completa de forma sincr√≥nica.  Es decir, si <code>_cache.InitializeAsync()</code> finaliza sincr√≥nicamente, todav√≠a es posible un punto muerto. <br><br>  Para eliminar los puntos muertos, todas las tareas que esperan ser completadas deben ser "decoradas" con una llamada al m√©todo <code>ConfigureAwait(false)</code> .  Todo esto molesta y genera errores. <br><br>  Alternativamente, puede usar el objeto personalizado de camarero en todos los m√©todos p√∫blicos para deshabilitar el contexto de sincronizaci√≥n en el m√©todo asincr√≥nico: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buttonOk_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs args</span></span></span><span class="hljs-function">)</span></span> { textBox.Text = <span class="hljs-string"><span class="hljs-string">"Running.."</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = _stockPrices.GetStockPricesForAsync(<span class="hljs-string"><span class="hljs-string">"MSFT"</span></span>).Result; textBox.Text = <span class="hljs-string"><span class="hljs-string">"Result is: "</span></span> + result; } <span class="hljs-comment"><span class="hljs-comment">// StockPrices.dll public async Task&lt;decimal&gt; GetStockPricesForAsync(string symbol) { // The rest of the method is guarantee won't have a current sync context. await Awaiters.DetachCurrentSyncContext(); // We can wait synchronously here and we won't have a deadlock. InitializeIfNeededAsync().Wait(); return 42; }</span></span></code> </pre> <br>  <code>Awaiters.DetachCurrentSyncContext</code> devuelve el siguiente objeto de camarero personalizado: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> DetachSynchronizationContextAwaiter : ICriticalNotifyCompletion { <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Returns true if a current synchronization context is null. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> It means that the continuation is called only when a current context </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> is presented. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public bool IsCompleted =&gt; SynchronizationContext.Current == null; public void OnCompleted(Action continuation) { ThreadPool.QueueUserWorkItem(state =&gt; continuation()); } public void UnsafeOnCompleted(Action continuation) { ThreadPool.UnsafeQueueUserWorkItem(state =&gt; continuation(), null); } public void GetResult() { } public DetachSynchronizationContextAwaiter GetAwaiter() =&gt; this; } public static class Awaiters { public static DetachSynchronizationContextAwaiter DetachCurrentSyncContext() { return new DetachSynchronizationContextAwaiter(); } }</span></span></code> </pre> <br>  <code>DetachSynchronizationContextAwaiter</code> hace lo siguiente: el m√©todo as√≠ncrono funciona con un contexto de sincronizaci√≥n distinto de cero.  Pero si el m√©todo as√≠ncrono funciona sin un contexto de sincronizaci√≥n, la propiedad <code>IsCompleted</code> devuelve verdadero y la continuaci√≥n del m√©todo se realiza sincr√≥nicamente. <br><br>  Esto significa que los datos del servicio est√°n cerca de cero cuando el m√©todo asincr√≥nico se ejecuta desde un subproceso en el grupo de subprocesos, y el pago se realiza una vez para transferir la ejecuci√≥n desde el subproceso de la interfaz de usuario al subproceso desde el grupo de subprocesos. <br><br>  Otros beneficios de este enfoque se enumeran a continuaci√≥n. <br><br><ul><li>  <b>La probabilidad de error se reduce.</b>  <code>ConfigureAwait(false)</code> solo funciona si se aplica a todas las tareas que esperan ser completadas.  Vale la pena olvidar al menos una cosa, y puede producirse un punto muerto.  En el caso de un objeto de camarero personalizado, recuerde que todos los m√©todos de biblioteca p√∫blica deben comenzar con <code>Awaiters.DetachCurrentSyncContext()</code> .  Los errores son posibles aqu√≠, pero su probabilidad es mucho menor. </li><li>  <b>El c√≥digo resultante es m√°s declarativo y claro.</b>  El m√©todo <code>ConfigureAwait</code> con varias llamadas me parece menos legible (debido a elementos adicionales) y no lo suficientemente informativo para principiantes. </li></ul><br><h2>  Manejo de excepciones </h2><br>  ¬øCu√°l es la diferencia entre estas dos opciones? <br><br>  Tarea mayFail = Task.FromException (new ArgumentNullException ()); <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Case 1 try { await mayFail; } catch (ArgumentException e) { // Handle the error } // Case 2 try { mayFail.Wait(); } catch (ArgumentException e) { // Handle the error }</span></span></code> </pre> <br>  En el primer caso, todo cumple con las expectativas: el procesamiento de errores se realiza, pero en el segundo caso esto no sucede.  La biblioteca de tareas paralelas TPL est√° dise√±ada para la programaci√≥n as√≠ncrona y paralela, y la tarea / tarea puede representar el resultado de varias operaciones.  Es por eso que <code>Task.Result</code> y <code>Task.Wait()</code> siempre arrojan una <code>AggregateException</code> , que puede contener varios errores. <br><br>  Sin embargo, nuestro escenario principal lo cambia todo: el usuario deber√≠a poder agregar el operador as√≠ncrono / esperar sin tocar la l√≥gica de manejo de errores.  Es decir, la instrucci√≥n de espera debe ser diferente de <code>Task.Result</code> / <code>Task.Wait()</code> : debe quitar el contenedor de una excepci√≥n en la instancia <code>AggregateException</code> .  Hoy seleccionaremos la primera excepci√≥n. <br><br>  Todo est√° bien si todos los m√©todos basados ‚Äã‚Äãen Tarea son as√≠ncronos y no se utilizan c√°lculos paralelos para realizar tareas.  Pero en algunos casos, todo es diferente: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Task&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; task1 = Task.FromException&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException()); Task&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; task2 = Task.FromException&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException()); <span class="hljs-comment"><span class="hljs-comment">// await will rethrow the first exception await Task.WhenAll(task1, task2); } catch (Exception e) { // ArgumentNullException. The second error is lost! Console.WriteLine(e.GetType()); }</span></span></code> </pre> <br>  <code>Task.WhenAll</code> devuelve una tarea con dos errores, sin embargo, la instrucci√≥n de espera recupera y llena solo la primera. <br><br>  Hay dos formas de resolver este problema: <br><br><ol><li>  ver manualmente las tareas si tienen acceso, o </li><li>  configure la biblioteca TPL para forzar que la excepci√≥n se envuelva en otra <code>AggregateException</code> . </li></ol><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Task&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; task1 = Task.FromException&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException()); Task&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; task2 = Task.FromException&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException()); <span class="hljs-comment"><span class="hljs-comment">// t.Result forces TPL to wrap the exception into AggregateException await Task.WhenAll(task1, task2).ContinueWith(t =&gt; t.Result); } catch(Exception e) { // AggregateException Console.WriteLine(e.GetType()); }</span></span></code> </pre> <br><h2>  M√©todo vac√≠o as√≠ncrono </h2><br>  El m√©todo basado en tareas devuelve un token que puede usarse para procesar resultados en el futuro.  Si se pierde la tarea, el token se vuelve inaccesible para lectura por c√≥digo de usuario.  Una operaci√≥n asincr√≥nica que devuelve el m√©todo void arroja un error que no se puede manejar en el c√≥digo de usuario.  En este sentido, los tokens son in√∫tiles e incluso peligrosos, ahora lo veremos.  Sin embargo, nuestro escenario principal supone su uso obligatorio: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buttonOk_ClickAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs args</span></span></span><span class="hljs-function">)</span></span> { textBox.Text = <span class="hljs-string"><span class="hljs-string">"Running.."</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> _stockPrices.GetStockPricesForAsync(<span class="hljs-string"><span class="hljs-string">"MSFT"</span></span>); textBox.Text = <span class="hljs-string"><span class="hljs-string">"Result is: "</span></span> + result; }</code> </pre> <br>  Pero, ¬øqu√© <code>GetStockPricesForAsync</code> si <code>GetStockPricesForAsync</code> arroja un error?  Una excepci√≥n de m√©todo anulado as√≠ncrono no manejado se ordena en el contexto de sincronizaci√≥n actual, desencadenando el mismo comportamiento que para el c√≥digo s√≠ncrono (para obtener m√°s informaci√≥n, consulte el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">M√©todo ThrowAsync</a> en la p√°gina web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AsyncMethodBuilder.cs</a> ).  En los formularios Windows Forms, una excepci√≥n no controlada en el controlador de eventos activa el evento <code>Application.ThreadException</code> , para WPF, se activa el evento <code>Application.DispatcherUnhandledException</code> , etc. <br><br>  ¬øQu√© pasa si el m√©todo vac√≠o as√≠ncrono no obtiene el contexto de sincronizaci√≥n?  En este caso, una excepci√≥n no controlada provoca un bloqueo fatal de la aplicaci√≥n.  No activar√° el evento [ <code>TaskScheduler.UnobservedTaskException</code> ] que se est√° restaurando, pero activar√° el evento <code>AppDomain.UnhandledException</code> que no se restaurar√° y luego cerrar√° la aplicaci√≥n.  Esto sucede intencionalmente, y este es exactamente el resultado que necesitamos. <br><br>  Ahora echemos un vistazo a otra forma conocida: usar m√©todos de vac√≠o as√≠ncrono solo para los controladores de eventos de la interfaz de usuario. <br><br>  Desafortunadamente, el m√©todo de vac√≠o as√≠ncrono es f√°cil de llamar por accidente. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Task&lt;T&gt; ActionWithRetry&lt;T&gt;(Func&lt;Task&lt;T&gt;&gt; provider, Action&lt;Exception&gt; onError) { <span class="hljs-comment"><span class="hljs-comment">// Calls 'provider' N times and calls 'onError' in case of an error. } public async Task&lt;string&gt; AccidentalAsyncVoid(string fileName) { return await ActionWithRetry( provider: () =&gt; { return File.ReadAllTextAsync(fileName); }, // Can you spot the issue? onError: async e =&gt; { await File.WriteAllTextAsync(errorLogFile, e.ToString()); }); }</span></span></code> </pre> <br>  A primera vista, la expresi√≥n lambda es dif√≠cil de decir si la funci√≥n es un m√©todo basado en tareas o un m√©todo vac√≠o as√≠ncrono y, por lo tanto, un error puede arrastrarse a su base de c√≥digo, a pesar de la verificaci√≥n m√°s exhaustiva. <br><br><h2>  Conclusi√≥n </h2><br>  Muchos aspectos de la programaci√≥n asincr√≥nica en C # fueron influenciados por un solo escenario de usuario: simplemente convirtiendo el c√≥digo s√≠ncrono de una aplicaci√≥n de interfaz de usuario existente en as√≠ncrono: <br><br><ul><li>  La posterior ejecuci√≥n de m√©todos asincr√≥nicos se programa en el contexto de sincronizaci√≥n resultante, lo que puede causar puntos muertos. </li><li>  Para evitarlos, es necesario realizar llamadas a <code>ConfigureAwait(false)</code> en todas partes del c√≥digo de la biblioteca asincr√≥nica. </li><li>  esperar tarea;  produce el primer error, y esto complica la creaci√≥n de una excepci√≥n de procesamiento para la programaci√≥n paralela. </li><li>  Se han introducido m√©todos de vac√≠o as√≠ncrono para manejar eventos de interfaz de usuario, pero son f√°ciles de ejecutar por accidente, lo que har√° que la aplicaci√≥n se bloquee si se produce una excepci√≥n. </li></ul><br>  El queso gratis solo ocurre en una trampa para ratones.  La facilidad de uso a veces puede conducir a grandes dificultades en otras √°reas.  Si est√° familiarizado con el historial de programaci√≥n asincr√≥nica en C #, el comportamiento m√°s extra√±o ya no parece tan extra√±o, y la probabilidad de errores en el c√≥digo asincr√≥nico se reduce significativamente. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es421245/">https://habr.com/ru/post/es421245/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es421227/index.html">Descripci√≥n general de los marcos de desarrollo m√≥vil multiplataforma</a></li>
<li><a href="../es421229/index.html">Historia de mi dolor de cabeza</a></li>
<li><a href="../es421235/index.html">Gafas Magic Leap One: gafas por $ 2295 con capacidad de mantenimiento 3 de 10</a></li>
<li><a href="../es421241/index.html">El Banco Central solicita el bloqueo previo a la prueba de sitios maliciosos</a></li>
<li><a href="../es421243/index.html">LLTR Parte 2: Algoritmo para determinar la topolog√≠a de la red a partir de estad√≠sticas recopiladas</a></li>
<li><a href="../es421247/index.html">C√≥mo convertir gr√°ficos en sonido y por qu√© lo necesita</a></li>
<li><a href="../es421249/index.html">¬øPor qu√© los financieros de Wall Street trabajan demasiado? ¬øSe puede solucionar?</a></li>
<li><a href="../es421251/index.html">Sistema de respaldo</a></li>
<li><a href="../es421253/index.html">¬øPor qu√© necesitamos autos con cola?</a></li>
<li><a href="../es421255/index.html">Elon Musk abandon√≥ los planes para convertir a Tesla en una empresa privada</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>