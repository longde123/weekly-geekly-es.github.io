<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍚 🗂️ 🎛️ Kinerja Ujung Depan: Parsing Metrik Penting 🚏 🤝 ✌🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Biasanya, kinerja dipahami sebagai jumlah operasi untuk interval waktu tertentu, dan semakin banyak, semakin baik. Tetapi definisi seperti itu, dan pe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kinerja Ujung Depan: Parsing Metrik Penting</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/454920/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ou/4k/ny/ou4knymbtseyhgwt9_zcalajm4s.png"></div>  Biasanya, kinerja dipahami sebagai jumlah operasi untuk interval waktu tertentu, dan semakin banyak, semakin baik.  Tetapi definisi seperti itu, dan pendekatan secara keseluruhan, memiliki sedikit penerapan ke frontend, karena setiap pengguna akan memiliki "frontend" mereka sendiri.  Itulah yang ingin saya bicarakan, apa yang terjadi "di sana", dengan pengguna, di sisi lain, pada kenyataannya, dan bukan pada MacBook teratas Anda. <br><br>  Selain itu, saya akan mencoba mempertimbangkan secara singkat aturan umum untuk mengoptimalkan kode dan beberapa kesalahan yang perlu diperhatikan.  Saya juga akan memberi tahu Anda tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alat</a> yang membantu tidak hanya dalam pembuatan profil, tetapi juga di luar kotak mengumpulkan sekelompok metrik dasar tentang kinerja aplikasi Anda (dan saya harap Anda membaca posting ini sampai akhir). <br><a name="habracut"></a><br>  Pertama-tama, kita akan menentukan apa kinerja front-end, dan kemudian kita akan beralih ke bagaimana mengukurnya.  Jadi, seperti yang saya katakan, kami tidak akan mengukur beberapa ops / detik, kami membutuhkan data nyata yang dapat menjawab pertanyaan tentang apa yang sebenarnya terjadi dengan proyek kami di setiap tahap pekerjaannya.  Untuk melakukan ini, kita memerlukan serangkaian metrik berikut: <br><br><ul><li>  kecepatan unduh; </li><li>  waktu render pertama dan interaktivitas (Time To Interactive); </li><li>  kecepatan reaksi terhadap tindakan pengguna; </li><li>  FPS untuk pengguliran dan animasi; </li><li>  inisialisasi aplikasi; </li><li>  jika Anda memiliki SPA, maka Anda perlu mengukur waktu yang dihabiskan untuk beralih antar rute; </li><li>  konsumsi memori dan lalu lintas; </li><li>  dan ... cukup untuk saat ini. </li></ul><br>  Semua ini adalah metrik dasar, yang tanpanya tidak mungkin untuk memahami apa yang sebenarnya terjadi di front-end.  Dan tidak hanya di ujung depan, tetapi pada kenyataannya, dengan pengguna akhir.  Tetapi untuk mulai mengumpulkan metrik ini, pertama-tama Anda perlu belajar cara mengukurnya, jadi mari kita ingat metode apa yang ada untuk analisis kinerja. <br><br>  Hal pertama untuk memulai tentu saja adalah API Kinerja.  Yaitu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">performance.timing</a> , yang melaluinya Anda dapat mengetahui berapa lama pengguna untuk membuka proyek Anda.  Tetapi API Kinerja hanya mencakup sebagian dari metrik, sisanya harus diukur sendiri, dan untuk ini kami memiliki alat berikut: <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  <sub>Pro</sub> </th><th>  <sub>Cons</sub> </th></tr><tr><td>  <sub>console.time ('label')</sub> </td><td>  <sub>Bekerja di luar kotak.</sub> <sub><br><br></sub>  <sub>Ini ditampilkan di konsol.</sub> <sub><br><br></sub>  <sub>Muncul di DevTools -&gt; Kinerja -&gt; Waktu Pengguna.</sub> </td><td> Outputnya hanya di DevTools, tidak ada cara untuk mengirimkannya ke server (mis. Tidak ada cara untuk mendapatkan nilai untuk analisis lebih lanjut). <br><br>  Membutuhkan <code>console.timeEnd</code> dengan <code>label</code> asli. <br><br>  Tidak ada kode warna. <br><br>  Tidak ada pengelompokan (sesuatu seperti <code>console.group</code> / <code>groupEnd</code> ). </td></tr><tr><td>  performance.now () </td><td>  Kontrol penuh atas awal dan akhir. <br><br>  Anda dapat mengirim ke server. <br><br></td><td>  Tidak ada tampilan di konsol. <br><br>  Tidak ada tampilan di DevTools -&gt; Kinerja -&gt; Waktu Pengguna. <br><br>  Anda harus menyeret variabel "mulai". <br><br>  Tanpa pengelompokan. </td></tr><tr><td>  performance.mark / ukur </td><td>  Kontrol penuh atas awal dan akhir. <br><br>  Anda dapat mengirim ke server. <br><br>  Muncul di DevTools -&gt; Kinerja -&gt; Waktu Pengguna. </td><td>  Tidak ada tampilan di konsol. <br><br>  Untuk mengukur sesuatu, Anda perlu menetapkan tiga label unik dan memanggil dua metode, tetapi dengan cara yang baik Anda juga memerlukan <code>performance.clearMarks</code> dan <code>performance.clearMeasures</code> , yang membuat penggunaan menjadi sangat tidak nyaman. <br><br>  Tanpa pengelompokan. </td></tr></tbody></table></div>  Pada saat itu, saya menyadari bahwa Anda perlu melihat alat yang akan menggabungkan kelebihan di atas dan, jika mungkin, tidak memiliki minus.  Jadi ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PerfKeeper</a> . <br><br><br><h2>  Perfkeeper </h2><ul><li>  Kontrol penuh atas awal dan akhir. </li><li>  Anda dapat mengirim ke server. </li><li>  Ini ditampilkan di konsol. </li><li>  Mendukung DevTools -&gt; Kinerja -&gt; Waktu Pengguna. </li><li>  Ada pengelompokan. </li><li>  Ada pengkodean warna (serta unit pengukuran, mis., Anda dapat mengukur tidak hanya waktu). </li><li>  Mendukung ekstensi. </li></ul><br>  Sekarang saya tidak akan melukis API di sini, saya tidak menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> untuk ini, dan artikelnya bukan tentang itu, tetapi saya akan melanjutkan tentang cara mengumpulkan metrik. <br><br><br><h2>  Kecepatan Unduhan Halaman </h2>  Seperti yang sudah saya katakan, Anda dapat mengetahui kecepatan unduhan dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">performance.timing</a> , yang akan memungkinkan Anda untuk mengetahui siklus penuh dari awal pemuatan halaman (waktu untuk menyelesaikan DNS, menginstal Handshake HTTP, memproses permintaan) dan sampai halaman tersebut terisi penuh (DomReady dan OnLoad): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eaf/320/48c/eaf32048c515e0a77ebeaa63e862def4.png"><br><br>  Akibatnya, Anda harus mendapatkan serangkaian metrik berikut: <br><div class="scrollable-table"><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/051/23d/b6a/05123db6af6359cc9f364b939f22fbcf.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/0d7/297/cdb/0d7297cdbd0c28f16849706a72bc54b5.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/6c0/ddc/21b/6c0ddc21b01640151d9e48b0018f2190.png"></td></tr></tbody></table></div>  <i>Contoh ekstensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">navigasi</a> untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@ perf-tools / keeper</a> .</i> <br><br>  Tapi ini tidak cukup, kami hanya mendapatkan nilai-nilai dasar dan masih belum tahu apa yang sebenarnya memakan banyak waktu.  Dan untuk mengetahuinya, Anda perlu mengisi metrik HTML juga. <br><br>  Seperti yang sudah saya katakan, saya akan menunjukkan contoh menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PerfKeeper</a> , jadi hal pertama yang harus dilakukan adalah inline di <code>&lt;hed/&gt;</code> PerfKeeper itu sendiri (2,5 Kb) dan selanjutnya: <img src="https://habrastorage.org/getpro/habr/post_images/dc8/a62/0b1/dc8a620b1d143b6fd2d328fed332e6ee.png"><br><br>  Hasilnya, Anda akan melihat keindahan seperti itu di konsol: <br><img src="https://habrastorage.org/getpro/habr/post_images/463/655/c0c/463655c0c0b6d5c23f0edb0828a4040b.png" width="350"><br><br>  Ini adalah metode pengukuran kakek klasik, 100% berhasil.  Tetapi dunia tidak tinggal diam, dan untuk pengukuran yang lebih akurat kami sekarang memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API Timing Sumber Daya</a> (dan jika sumber daya berada pada domain <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Timing-Allow-Origin yang terpisah</a> untuk membantu Anda). <br><br>  Dan di sini ada baiknya berbicara tentang kesalahan klasik selama pemuatan awal halaman, yaitu: <br><br><ul><li>  kekurangan GZip dan HTTP / 2 (ya, ini masih umum); </li><li>  penggunaan font yang tidak masuk akal (terkadang font terhubung hanya untuk satu tajuk atau bahkan nomor telepon di footer 0_o); </li><li>  Kumpulan CSS / JS terlalu umum. </li></ul><br>  Cara mengoptimalkan pemuatan halaman: <br><br><ul><li>  gunakan Brotli (atau bahkan SDCH) sebagai ganti GZip, aktifkan HTTP / 2; </li><li>  Kumpulkan hanya CSS yang diperlukan (kritis) dan jangan lupa tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CSSO</a> ; </li><li>  meminimalkan ukuran bundel JS dengan memisahkan bundel INTI minimum, dan memuat sisanya sesuai permintaan, mis.  tidak serempak; </li><li>  memuat JS dan CSS dalam mode non-blocking, secara dinamis membuat <code>/&gt;  &lt;sript src="..."/&gt;</code> , idealnya memuat JS setelah konten utama; </li><li>  gunakan SVG sebagai ganti PNG, dan jika dikombinasikan dengan JS, itu akan menghilangkan XML yang berlebihan (misalnya, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">font-mengagumkan</a> ); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gunakan lazy loading</a> untuk kedua gambar dan iframe (di samping ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dukungan asli</a> akan muncul dalam waktu dekat). </li></ul><br><br><h2>  Waktu Rendering Pertama dan Interaktivitas (TTI) </h2>  Tahap selanjutnya setelah memuat adalah saat ketika pengguna melihat hasilnya, dan antarmuka beralih ke mode interaktif.  Untuk ini, kita memerlukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Timing Kinerja Paint</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PerformanceObserver</a> . <br><br>  Yang pertama adalah sederhana, kami memanggil <code>performance.getEntriesByType('paint')</code> dan kami mendapatkan dua metrik: <br><br><ul><li>  cat pertama - rendering pertama; </li><li>  first-contentful-paint - dan render pertama penuh. </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/ef7/230/acb/ef7230acbfdcace32596ce157bb00706.png" width="350"><br>  <i>Contoh ekstensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cat</a> untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@ perf-tools / keeper</a> .</i> <br><br>  Tetapi dengan metrik berikutnya, Time To Interactive, ini sedikit lebih menarik.  Tidak ada cara pasti untuk menentukan kapan aplikasi Anda menjadi interaktif, mis.  dapat diakses oleh pengguna, tetapi ini dapat secara tidak langsung dipahami oleh tidak adanya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">longtasks</a> : <br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">// TTI let ttiLastEntry: PerformanceEntry | undefined; let ttiPerfObserver: PerformanceObserver; try { ttiPerfObserver = new PerformanceObserver((list) =&gt; { ttiLastEntry = list.getEntries().pop(); }); ttiPerfObserver.observe({ entryTypes: ['longtask'], }); } catch (_) {} domReady(() =&gt; { // TTI Check if (ttiPerfObserver) { let tti: number; const check = () =&gt; { if (ttiLastEntry) { tti = ttiLastEntry.startTime + ttiLastEntry.duration; if (now() - tti &gt;= options.ttiDelay) { //  logntask  ,  , //     ;] send('tti', 'value', 0, tti); ttiPerfObserver.disconnect(); } else { setTimeout(check, options.ttiDelay); } } else if (tti) { send('tti', 'value', 0, tti); ttiPerfObserver.disconnect(); } else { //   logntask,         , //  ,       DOMReady! tti = now(); setTimeout(check, 500); } } //   check(); } });</span></span></code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/a03/dcb/6e1/a03dcb6e138ee982ab4cd90a2c1b7f09.png" width="350"><br>  <i>Contoh ekstensi kinerja untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@ perf-tools / keeper</a> .</i> <br><br>  Selain metrik dasar ini, metrik kesiapan aplikasi Anda juga diperlukan, mis.  di suatu tempat dalam kode Anda harus seperti ini: <pre> <code class="javascript hljs">Import { system } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@perf-tools/keeper'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">applicationBoot</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el, data</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Application(el, data); <span class="hljs-comment"><span class="hljs-comment">//     app.ready(() =&gt; { system.add('application-ready', 0, system.perf.now()); // ️application-ready: 3074.000ms }); return app; }</span></span></code> </pre> <br><br><h2>  Tingkat respons terhadap tindakan pengguna </h2>  Ada bidang besar untuk metrik dan sangat individual, jadi saya akan berbicara tentang dua bidang dasar yang cocok untuk proyek apa pun, yaitu: <br><br>  <b>peristiwa pertama</b> - waktu kejadian pertama, misalnya, klik pertama (membagi tempat pengguna menusuk), metrik ini sangat relevan untuk semua jenis hasil pencarian, daftar produk, umpan berita, dll.  Dengannya, Anda dapat mengontrol bagaimana waktu reaksi dan pengguna mengalir dari tindakan Anda (perubahan dalam: desain / fitur baru / optimasi, dll.) Berubah <img src="https://habrastorage.org/getpro/habr/post_images/31a/f2c/e7e/31af2ce7e1ed48f7bfc4cacc6a6ddb0e.png" width="350"><br>  <i>Contoh ekstensi kinerja untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@ perf-tools / keeper</a> .</i> <br><br>  <b>latensi</b> - tunda saat memproses beberapa acara, misalnya: <code>click</code> , <code>input</code> , <code>submit</code> , <code>scroll</code> , dll. <br><br>  Untuk mengukur penundaan, cukup gantung pengendali acara di <code>window</code> dengan <code>capture = true</code> dan gunakan <code>requestAnimationFrame</code> menghitung perbedaannya, ini akan menjadi penundaan: <pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(eventType, ({target}) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> start = now(); requestAnimationFrame(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> latency = now() - start; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (latency &gt;= minLatency) { <span class="hljs-comment"><span class="hljs-comment">// …. } }); }, true);</span></span></code> </pre><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e68/e3e/07d/e68e3e07d64825c3f07175625d477283.png" width="350"><br>  <i>Contoh ekstensi kinerja untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@ perf-tools / keeper</a> berfungsi ketika angka Fibonacci dihitung pada klik.</i> <br><br><br><h2>  FPS saat menggulir dan menghidupkan </h2>  Ini adalah metrik yang paling menarik, biasanya diukur melalui <code>requestAnimationFrame</code> , dan jika Anda perlu melakukan pengukuran FPS konstan, maka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FPSMeter</a> klasik akan melakukannya (walaupun terlalu optimis).  Tetapi itu tidak berfungsi sama sekali jika Anda perlu mengukur kelancaran pengguliran halaman, karena  dia butuh pemanasan.  Dan kemudian saya menemukan cara yang sangat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menarik</a> . <br><br>  Sebenarnya, kami hanya membuat div transparan (1x1px), menambahkan <code>transition: left 300ms linear</code> dan menjalankannya dari satu sudut ke sudut lainnya, dan ketika sedang dianimasikan, melalui <code>requestAnimationFrame</code> memeriksa kirinya yang asli, dan jika panjang baru berbeda dari yang sebelumnya, kemudian tingkatkan jumlah frame yang diberikan (jika tidak kita memiliki drawdown FPS). <br><br>  Dan itu tidak semua, jika Anda menggunakan FF, maka ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mozPaintCount</a> , yang bertanggung jawab atas jumlah frame yang diberikan, mis.  kita ingat "DO", dan pada <code>transitionend</code> kita menghitung perbedaannya. <br><br>  Total, tanpa pemanasan apa pun, kami tahu pasti apakah browser menggambar ulang bingkai atau tidak. <br><br>  Mereka segera menjanjikan API normal: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://wicg.github.io/frame-timing/</a> <div class="scrollable-table"><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/5c9/17b/d15/5c917bd15c349dd2101e10ce687294c5.png" width="350"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/964/4cc/6bb/9644cc6bb9c21671b5c7c7e34b596ff8.png" width="350"></td></tr></tbody></table></div>  <i>Contoh ekstensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fps</a> untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@ perf-tools / keeper</a> .</i> <br><br>  Optimisasi bergulir: <br><br><ul><li>  hal yang paling sederhana adalah tidak melakukan apa pun pada scroll, atau menunda eksekusi melalui <code>requestAnimationFrame</code> , atau bahkan <code>requestIdleCallback</code> ; </li><li>  sangat hati-hati menggunakan <code>pointer-events: none</code> , menyalakan dan mematikannya dapat memiliki efek sebaliknya, jadi lebih baik untuk melakukan percobaan A / B menggunakan <code>pointer-events</code> dan tanpa; </li><li>  jangan lupa tentang daftar tervirtualisasi, hampir semua mesin Lihat sekarang memiliki komponen seperti itu, tetapi sekali lagi, berhati-hatilah, elemen daftar seperti itu harus sesederhana mungkin, atau menggunakan "boneka" yang akan diganti dengan elemen nyata setelah pengguliran selesai.  Jika Anda menulis sendiri daftar tervirtualisasi, maka tidak ada HTML dalam dan jangan lupa tentang DOM Recycling (ini adalah saat Anda tidak membuat elemen DOM untuk setiap bersin, tetapi menggunakannya kembali). </li></ul><br><br><h2>  Inisialisasi aplikasi </h2>  Hanya ada satu aturan: detail sehingga Anda bisa menjawab dengan tepat apa yang telah menghabiskan waktu dari menginisialisasi aplikasi ke peluncuran akhir.  Akibatnya, Anda harus mendapatkan setidaknya metrik berikut: <br><br><ul><li>  berapa banyak waktu yang dibutuhkan untuk menyelesaikan setiap kecanduan; </li><li>  waktu untuk menerima dan menyiapkan data untuk aplikasi; </li><li>  membuat aplikasi dengan merinci berdasarkan blok. </li></ul><br>  Yaitu  pada output, Anda harus mendapatkan metrik yang dengannya Anda dapat melacak secara akurat fase apa yang sedang terjadi drawdown Anda. <br><br><div class="spoiler">  <b class="spoiler_title">Contoh kerja</b> <div class="spoiler_text">  <b>Konsol</b> <img src="https://habrastorage.org/getpro/habr/post_images/678/c35/91f/678c3591fc9c9d1b46481a67be2d4551.png"><br><br>  <b>Waktu pengguna</b> <img src="https://habrastorage.org/getpro/habr/post_images/b1e/67e/8c4/b1e67e8c408d8ad929ee6e404889a593.png"></div></div><br><br><br><h2>  Jika Anda memiliki SPA, Anda perlu mengukur waktu perutean </h2>  Pertama, harus ada metrik umum untuk mengevaluasi kinerja (waktu transit pada rute) secara keseluruhan, tetapi juga perlu untuk memiliki metrik untuk setiap rute (misalnya, kami memiliki "Daftar utas", "Membaca utas", "Cari", dll. d.), metrik itu sendiri harus dibagi menjadi metrik: <br><br><ul><li>  Menerima data (dengan rincian yang mana) <ul><li>  Pengolahan </li><li>  Perbarui </li></ul></li><li>  Render <ul><li>  Total aplikasi </li><li>  Blok (misalnya, bersama kami, itu akan menjadi: "Kolom kiri" (alias "Daftar folder"), "Bilah pencarian pintar", "Daftar surat" dan sejenisnya) </li></ul></li></ul><br>  Tanpa semua ini, tidak mungkin untuk memahami di mana masalah dimulai, jadi kami memiliki banyak modul di luar kotak dengan pengaturan waktu (misalnya, modul yang sama untuk XHR memiliki <code>startTime</code> dan <code>endTime</code> , yang dicatat secara otomatis). <br><br>  Tetapi metrik ini tidak cukup untuk menilai secara memadai apa yang terjadi.  Mereka terlalu umum karena  kita berbicara tentang SPA, maka Anda pasti memiliki semacam Runtime Cache (agar tidak pergi ke server lagi jika Anda sudah ada di sana), sehingga metrik kami dibagi lagi menjadi perutean dengan dan tanpa cache.  Namun, khususnya dalam kasus kami, kami membagi metrik dengan jumlah entitas di dalamnya.  Dengan kata lain, Anda tidak dapat menambahkan tampilan "Utas" dengan 1, 5, 10 atau 100+ huruf dalam satu metrik, jadi jika Anda memiliki daftar yang ditampilkan, Anda perlu memilih breakpoints dan selanjutnya memisahkan metrik. <br><br><br><h2>  Konsumsi memori dan lalu lintas </h2>  <b>Mari kita mulai dengan memori</b> .  Dan di sini kita menunggu kekecewaan besar.  Saat ini hanya ada kinerja.memory yang tidak standar (Chrome saja), yang memberikan angka sangat rendah.  Tetapi mereka masih perlu diukur dan perhatikan bagaimana aplikasi "mengalir" dari waktu ke waktu: <div class="scrollable-table"><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/985/6f9/3f0/9856f93f0823ac906bd1938f2cf1f11c.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/983/1bf/437/9831bf437924eb2ecf577f897d934e45.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/c08/e33/577/c08e335770d4fa05b70d8d653ae1b38f.png"></td></tr></tbody></table></div>  <i>Contoh ekstensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memori</a> untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@ perf-tools / keeper</a></i> <br><br>  <b>Lalu lintas</b>  Untuk menghitung lalu lintas, Anda perlu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Timing-Allow-Origin</a> (jika sumber daya berada di domain terpisah) dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API Timing Sumber Daya</a> , ini akan membantu tidak hanya untuk menghitung lalu lintas, tetapi juga untuk memerincinya: <br><br><ul><li>  protokol apa yang digunakan (HTTP / 1, HTTP / 2, dll.); </li><li>  jenis sumber daya yang dimuat; </li><li>  berapa lama untuk mengunduhnya; </li><li>  ukuran, apalagi, Anda dapat memahami apakah sumber daya dimuat di jaringan atau diambil dari cache. </li></ul><div class="scrollable-table"><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/c65/c03/c66/c65c03c660ea8d6bb70ee6597d643245.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/aa3/ba4/973/aa3ba4973933bebafe516ed63e779700.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/35a/a87/d0d/35aa87d0d53ca31ea88ad249bacd057a.png"></td></tr></tbody></table></div>  <i>Contoh ekstensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sumber daya</a> untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@ perf-tools / keeper</a> .</i> <br><br>  Apa yang menghitung traffic? <br><br><ul><li>  Yang paling penting adalah memungkinkan Anda untuk melihat gambar asli, dan tidak seperti biasanya dengan CSS + JS dan lebih dari itu, bagaimana "gambar" ini berubah seiring waktu. </li><li>  Kemudian Anda dapat menganalisis apa sebenarnya yang dimuat, membagi sumber daya ke dalam kelompok, dll. </li><li>  Seberapa baik caching bekerja untuk Anda. </li><li>  Apakah ada anomali, misalnya, setelah 15 menit operasi, misalnya, kode mengalami rekursi dan memuat beberapa sumber daya tanpa henti, memantau lalu lintas akan membantu dalam hal ini. </li></ul><br>  Nah, laporan catch-up dari rekan saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Igor Druzhinin</a> tentang topik ini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengevaluasi kualitas aplikasi - memantau konsumsi lalu lintas</a> <br><br><br><h2>  Analisis </h2>  Kami menyiapkan metrik, lalu apa?  Dan kemudian mereka perlu dikirim ke suatu tempat.  Dan di sini Anda dapat mengambil beberapa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Graphite dari Anda</a> , atau, sebagai permulaan, Anda dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Google Analytics</a> atau sejenisnya untuk pengumpulan data untuk keuntungan pribadi. <br><br>  Dan jangan lupa, itu tidak cukup hanya untuk mendapatkan grafik, untuk semua metrik penting harus ada persentil yang memungkinkan Anda untuk memahami, misalnya, berapa persen audiens yang memuat proyek untuk &lt;1s, &lt;2s, &lt;3s, &lt;5s, 5s + +, dll. <br><br><br><h2>  Menulis kode kinerja tinggi </h2>  Pada awalnya, saya ingin menulis sesuatu yang bermakna di sini, mereka mengatakan menggunakan WebWorker, jangan lupa <code>requestIdleCallback</code> atau sesuatu yang eksotis, misalnya, melalui Runtime Cache melalui tab browser menggunakan SharedWorker atau ServiceWorker (yang tidak hanya tentang caching, jika itu).  Tapi ini semua sangat abstrak, dan banyak topik dikalahkan hingga tidak mungkin, jadi tulis saja yang berikut ini: <br><br><ol><li>  Mulailah tutup kode Anda dengan metrik yang akan mengukur kinerjanya. </li><li>  Jangan percaya tolok ukur dengan jsperf.  Sebagian besar dari mereka ditulis dengan buruk, dan hanya diambil di luar konteks.  Tolok ukur terbaik adalah metrik nyata pada proyek, yang dengannya Anda akan melihat efek tindakan Anda. </li><li>  Ingatlah tentang persepsi produktivitas, atau lebih tepatnya Hukum Weber-Fechner.  Yaitu, jika Anda memulai pengoptimalan, maka jangan meluncurkan perubahan sampai menjadi lebih baik setidaknya 20%, jika tidak, pengguna tidak akan melihat.  Hukum juga bekerja berlawanan arah. </li><li>  Ketakutan tetap, terutama yang dihasilkan.  Mereka tidak hanya dapat menggantung browser, tetapi juga mendapatkan XSS, itulah sebabnya di Mail kami dilarang mem-parsing HTML menggunakan mereka, hanya melalui bypass DOM. </li><li>  Anda tidak perlu menggunakan array untuk memasukkan nilai dalam satu atau grup lain, untuk ini ada <code>object</code> atau <code>Set</code> (misalnya, <code>successSteps.includes(currentStep)</code> diperlukan <code>successSteps.hasOwnProperty(currentStep)</code> ), O (1) adalah segalanya. </li><li>  Ungkapan "Optimalisasi prematur adalah akar dari semua kejahatan" bukanlah tentang menulis apa pun yang Anda inginkan.  Jika Anda tahu cara terbaik, tulislah secara optimal. </li></ol><br><br><div class="spoiler">  <b class="spoiler_title">Saya akan menulis beberapa paragraf tentang kode dan pengoptimalannya</b> <div class="spoiler_text">  <b>DOM</b>  Sangat sering saya mendengar "Masalah di DOM" - ini, tentu saja, benar, tetapi mengingat bahwa hampir semua orang sekarang memiliki abstraksi atasnya.  Dialah yang menjadi penghambat, atau lebih tepatnya kode Anda, yang bertanggung jawab untuk pembentukan pandangan dan logika bisnis. <br><br>  Tetapi jika kita berbicara tentang DOM, misalnya, daripada menghapus sebuah fragmen dari DOM, lebih baik menyembunyikannya atau melepaskannya.  Jika Anda masih perlu menghapus, maka buat operasi ini di <code>requestIdleCallback</code> (jika mungkin), atau bagi proses penghancuran menjadi dua fase: sinkron dan asinkron. <br><br>  Saya akan segera melakukan reservasi, gunakan pendekatan ini dengan bijak, jika tidak Anda bisa menembak lutut Anda. <br><br>  Kami juga menggunakan teknik menarik lainnya pada daftar, misalnya, "Daftar utas".  Inti dari teknik ini adalah bahwa alih-alih satu "Daftar" global dan memperbarui datanya, kami menghasilkan "Daftar utas" untuk setiap "Folder".  Akibatnya, ketika pengguna menavigasi antara "Folder", satu daftar dihapus dari DOM (tidak dihapus), dan yang lainnya diperbarui sebagian atau tidak sama sekali.  Dan tidak semua, seperti halnya dengan "Daftar Tunggal". <br><br>  Semua ini memberikan respons instan terhadap tindakan pengguna. <br><br>  <b>Matematika</b>  Kami dengan mudah menghapus semua matematika di Worker atau WebAssembly, ini sudah bekerja sejak lama. <br><br>  <b>Transpillers</b> .  Oh, banyak yang bahkan tidak berpikir bahwa kode yang mereka tulis melewati transpiler.  Ya, mereka tahu tentang dia, tapi itu saja.  Tapi apa yang dia ubah menjadi mereka tidak lagi peduli.  Memang, di DevTools mereka melihat hasil peta sumber. <br><br>  Oleh karena itu, pelajari alat yang Anda gunakan, misalnya, babel yang sama di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">taman bermain</a> memiliki kesempatan untuk melihat apa yang menghasilkan kode tergantung pada preset yang dipilih, lihat saja <code>yeild</code> sama, <code>await</code> atau <code>for of</code> . <br><br>  <b>Seluk-beluk lidah</b> .  Bahkan lebih sedikit orang yang tahu tentang monomorfisme dari kode tersebut, atau klise mengapa <code>handleEvent</code> lambat dan ... Anda akhirnya menggunakan <code>handleEvent</code> ! <br><br>  <b>Data dan prapemanjangan</b> .  Lebih sedikit permintaan, lebih banyak caching.  Selain itu, sangat sering kita menggunakan teknik "tinjauan ke masa depan", inilah saat di latar belakang kita memuat data.  Misalnya, setelah merender "Daftar Thread", kami mulai memuat utas yang belum dibaca dalam "Folder" saat ini, sehingga ketika Anda mengkliknya, pengguna segera beralih ke "Baca" daripada "loader" lainnya.  Kami menggunakan teknik serupa tidak hanya untuk Data, tetapi juga untuk JS.  Misalnya, "Menulis Surat" adalah bundel besar (karena editor), dan tidak semua orang menulis surat sekaligus, jadi kami memuatnya di latar belakang, setelah aplikasi diinisialisasi. <br><br>  <b>Louders</b>  Saya tidak tahu mengapa, tetapi saya tidak melihat artikel yang mengajarkan bagaimana tidak membuat loader, melainkan mengambil presentasi dari "masa depan" Bereaksi, di mana banyak waktu dicurahkan untuk masalah ini dalam rangka Suspense.  Tetapi bagaimanapun juga, aplikasi yang ideal adalah tanpa loader, kami telah mencoba sejak lama di Mail untuk menunjukkannya hanya dalam situasi darurat. <br><br>  Secara umum, kami memiliki kebijakan seperti itu, tidak ada data, tidak ada tampilan, tidak ada yang menggambar semi-antarmuka, pertama kita memuat data dan hanya kemudian "menggambar".  Itulah sebabnya kami menggunakan "tinjauan ke masa depan" di mana pengguna akan pergi dan memuat data ini sehingga pengguna tidak melihat loader.  Selain itu, lapisan data kami, yang persisten, banyak membantu dalam tugas ini.  jika Anda meminta "Utas" di suatu tempat di satu tempat, maka pada saat Anda meminta dari tempat lain atau tempat yang sama, tidak akan ada permintaan, kami akan mengambil data dari Runtime Cache (lebih tepatnya, tautan ke data).  Jadi dalam segala hal, koleksi utas juga hanya tautan ke data. <br><br>  Tetapi jika Anda masih memutuskan untuk membuat loader, maka jangan lupa aturan dasar yang akan membuat loader Anda tidak terlalu mengganggu: <ul><li>  tidak perlu menunjukkan loader segera, pada saat mengirim permintaan, harus ada penundaan setidaknya 300-500 ms sebelum pertunjukan; </li><li>  Setelah menerima data, Anda tidak perlu menghapus loader dengan tajam, di sini sekali lagi harus ada penundaan. </li></ul><br>  Aturan sederhana ini diperlukan agar pemuat hanya muncul saat permintaan berat dan tidak "berkedip" setelah selesai.  Namun yang terpenting, loader terbaik adalah loader yang tidak muncul. </div></div><br><br>  Terima kasih atas perhatian Anda, itu saja, ukur, analisis, dan gunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PerfKeeper</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh langsung</a> ), serta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">twitter saya</a> , jika ada pertanyaan! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id454920/">https://habr.com/ru/post/id454920/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id454896/index.html">Mengapa saya mengubah freelance ke tim jarak jauh</a></li>
<li><a href="../id454904/index.html">Samsung Meluncurkan Kursus Jaringan Saraf Penglihatan Komputer Online Gratis</a></li>
<li><a href="../id454906/index.html">Peringkat platform pendidikan tambahan di TI: sesuai dengan hasil studi My Circle</a></li>
<li><a href="../id454916/index.html">Arsitektur jaringan saraf untuk mengimplementasikan algoritma RL dengan kemampuan untuk mengatur tindakan yang berjalan secara bersamaan</a></li>
<li><a href="../id454918/index.html">Cara menggabungkan punggung dua pengecer di SAP dalam 12 jam</a></li>
<li><a href="../id454922/index.html">Kisah tentang pelanggan asing dan fitur-fitur mereka bekerja di Rusia setelah UU PD</a></li>
<li><a href="../id454924/index.html">Pengaturan Otentikasi di Veeam Backup untuk Microsoft Office 365 v3</a></li>
<li><a href="../id454926/index.html">Semua yang Anda ketahui tentang word2vec tidak benar</a></li>
<li><a href="../id454928/index.html">Cara untuk Memintas Layar Kunci Windows pada Sesi RDP</a></li>
<li><a href="../id454930/index.html">Pengumpulan sampah di V8: cara kerja Orinoco GC baru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>