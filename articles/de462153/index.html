<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕵🏽 👶🏽 👃🏻 Unity Interactive Map Shader 👦🏾 ⛴️ 👲🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Tutorial geht es um interaktive Karten und deren Erstellung in Unity mithilfe von Shadern. 

 Dieser Effekt kann als Grundlage für komplexer...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unity Interactive Map Shader</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462153/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/511/6a1/e02/5116a1e02debfaa58afe0cddf3b4c6c9.png" alt="Bild"></div><br>  In diesem Tutorial geht es um <strong>interaktive Karten</strong> und deren Erstellung in Unity mithilfe von Shadern. <br><br>  Dieser Effekt kann als Grundlage für komplexere Techniken wie holographische Projektionen oder sogar einen Sandtisch aus dem Film "Black Panther" dienen. <br><br>  Eine Inspiration für dieses Tutorial ist der von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Baran Kahyaoglu</a> veröffentlichte Tweet, der ein Beispiel dafür zeigt, was er für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Mapbox erstellt</a> . <br><a name="habracut"></a><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="1118609807844442112"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-1" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="1118610439049494540"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br>  Die Szene (ohne Karte) wurde aus der Unity Visual Effect Graph-Raumschiff-Demo (siehe unten) entnommen, die hier heruntergeladen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">werden kann</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/rqMcPZoEc3U" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Teil 1. Scheitelpunktversatz </h2><br><h2>  Anatomie der Wirkung </h2><br>  Das erste, was Sie sofort bemerken können, ist, dass geografische Karten <em>flach sind</em> : Wenn sie als Texturen verwendet werden, fehlt ihnen die Dreidimensionalität, die ein reales 3D-Modell des entsprechenden Kartenbereichs haben würde. <br><br>  Sie können diese Lösung anwenden: Erstellen Sie ein 3D-Modell des Bereichs, der im Spiel benötigt wird, und wenden Sie dann eine Textur von der Karte darauf an.  Dies wird zur Lösung des Problems beitragen, nimmt jedoch viel Zeit in Anspruch und ermöglicht es nicht, den Effekt des „Scrollens“ aus dem Video Baran Kahyaoglu zu realisieren. <br><br>  Offensichtlich ist ein technischerer Ansatz am besten.  Glücklicherweise können Shader verwendet werden, um die Geometrie eines 3D-Modells zu ändern.  Mit ihrer Hilfe können Sie jedes Flugzeug in Täler und Berge der Region verwandeln, die wir brauchen. <br><br>  In diesem Tutorial verwenden wir eine Karte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">von Chillot</a> , Chilli, berühmt für seine charakteristischen Hügel.  Das Bild unten zeigt die Textur des Bereichs, der auf einem runden Netz aufgetragen ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a7/b64/0a6/5a7b640a60ca2ce42c9d4ee3f5c95150.png" width="797" height="346"></div><br>  Obwohl wir Hügel und Berge sehen, sind sie immer noch völlig flach.  Dies zerstört die Illusion des Realismus. <br><br><h2>  Extrudieren von Normalen </h2><br>  Der erste Schritt zur Verwendung von Shadern zum Ändern der Geometrie ist eine Technik, die als <strong>normale Extrusion bezeichnet wird</strong> .  Sie benötigt <strong>einen Scheitelpunktmodifikator</strong> : eine Funktion, mit der einzelne Scheitelpunkte eines 3D-Modells bearbeitet werden können. <br><br>  Die Art und Weise, wie der Vertex-Modifikator verwendet wird, hängt von der Art des verwendeten Shaders ab.  In diesem Tutorial ändern wir den <strong>Surface Standard Shader</strong> - einen der Shader-Typen, die Sie in Unity erstellen können. <br><br>  Es gibt viele Möglichkeiten, die Eckpunkte eines 3D-Modells zu bearbeiten.  Eine der ersten Methoden, die in den meisten Vertex-Shader-Tutorials beschrieben werden, ist das <strong>Extrudieren von Normalen</strong> .  Es besteht darin, jeden Scheitelpunkt nach außen zu drücken (zu <em>extrudieren</em> ), wodurch das 3D-Modell ein aufgeblähteres Aussehen erhält.  "Außerhalb" bedeutet, dass sich jeder Scheitelpunkt entlang der Richtung der Normalen bewegt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/275/3e4/fe3/2753e4fe3502d77d46d7205e1ec81809.png"></div><br>  Bei glatten Oberflächen funktioniert dies sehr gut, aber bei Modellen mit schlechten Scheitelpunktverbindungen kann diese Methode seltsame Artefakte erzeugen.  Dieser Effekt wird in einem meiner ersten Tutorials <strong>ausführlich</strong> erläutert: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Eine sanfte Einführung in Shader</a> , in der ich zeigte, wie <strong>ein</strong> 3D-Modell <strong>extrudiert</strong> und <strong>eingedrungen wird</strong> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a8/668/0e5/5a86680e5ab92b536d4999e693aed8cb.gif" width="485" height="278"></div><br>  Das Hinzufügen von extrudierten Normalen zu einem Oberflächen-Shader ist sehr einfach.  Jeder Surface Shader verfügt über eine <code>#pragma</code> , mit der zusätzliche Informationen und Befehle übertragen werden.  Ein solcher Befehl ist <code>vert</code> , was bedeutet, dass die <code>vert</code> Funktion verwendet wird, um jeden Scheitelpunkt des 3D-Modells zu verarbeiten. <br><br>  Der bearbeitete Shader lautet wie folgt: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf Standard fullforwardshadows addshadow vertex:vert ... float _Amount; ... void vert(inout appdata_base v) { v.vertex.xyz += v.normal * _Amount; }</span></span></code> </pre> <br>  Da wir die Position der Scheitelpunkte ändern, müssen wir auch <code>addshadow</code> wenn das Modell Schatten korrekt auf sich selbst werfen soll. <br><br><div class="spoiler">  <b class="spoiler_title">Was ist appdata_base?</b> <div class="spoiler_text">  Wie Sie sehen können, haben wir eine Funktion des Vertices-Modifikators ( <code>vert</code> ) hinzugefügt, der als Parameter eine <em>Struktur</em> namens <code>appdata_base</code> .  Diese Struktur speichert Informationen zu jedem einzelnen Scheitelpunkt des 3D-Modells.  Es enthält nicht nur <em>die Scheitelpunktposition</em> ( <code>v.vertex</code> ), sondern auch andere Felder, z. B. <em>die normale Richtung</em> ( <code>v.normal</code> ) und <em>Texturinformationen,</em> die dem Scheitelpunkt ( <code>v.texcoord</code> ) zugeordnet sind. <br><br>  In einigen Fällen reicht dies nicht aus, und wir benötigen möglicherweise andere Eigenschaften, z. B. die <em>Scheitelpunktfarbe</em> ( <code>v.color</code> ) und die <em>Tangentenrichtung</em> ( <code>v.tangent</code> ).  Vertex-Modifikatoren können mithilfe einer Vielzahl anderer <code>appdata_tan</code> werden, einschließlich <code>appdata_tan</code> und <code>appdata_full</code> , die auf Kosten eines geringen Leistungsaufwands mehr Informationen bereitstellen.  Weitere <code>appdata</code> zu <code>appdata</code> (und ihren Varianten) finden Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Unity3D-Wiki</a> . </div></div><br><div class="spoiler">  <b class="spoiler_title">Wie werden Werte von vert zurückgegeben?</b> <div class="spoiler_text">  Die Top-Funktion hat keinen Rückgabewert.  Wenn Sie mit der C # -Sprache vertraut sind, sollten Sie wissen, dass Strukturen als Wert übergeben werden. Wenn sich <code>v.vertex</code> ändert <code>v.vertex</code> wirkt sich dies nur auf die Kopie von <code>v</code> , deren Umfang durch den Hauptteil der Funktion begrenzt ist. <br><br>  <code>v</code> auch als <code>inout</code> deklariert, was bedeutet, dass es sowohl für die Eingabe als auch für die Ausgabe verwendet wird.  Alle Änderungen, die Sie vornehmen, ändern die Variable selbst, die wir an <code>vert</code> .  Die Schlüsselwörter <code>inout</code> und <code>out</code> sehr häufig in der Computergrafik verwendet und können grob mit <code>ref</code> und <code>out</code> in C # korreliert werden. </div></div><br><h2>  Extrudieren von Normalen mit Texturen </h2><br>  Der oben verwendete Code funktioniert korrekt, ist jedoch weit von dem gewünschten Effekt entfernt.  Der Grund ist, dass wir nicht alle Eckpunkte um den gleichen Betrag extrudieren möchten.  Wir möchten, dass die Oberfläche des 3D-Modells mit den Tälern und Bergen der entsprechenden geografischen Region übereinstimmt.  Zuerst müssen wir irgendwie Informationen darüber speichern und abrufen, wie viel jeder Punkt auf der Karte angehoben wird.  Wir möchten, dass das Extrudieren von der Textur beeinflusst wird, in der die Höhen der Landschaft codiert sind.  Solche Texturen werden oft als <strong>Höhenkarten bezeichnet</strong> , aber je nach Kontext werden sie auch als <strong>Tiefenkarten bezeichnet</strong> .  Nachdem wir Informationen über die Höhen erhalten haben, können wir die Extrusion der Ebene basierend auf der Höhenkarte ändern.  Wie in der Abbildung gezeigt, können wir so das Anheben und Absenken von Bereichen steuern. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f3/223/118/0f32231186763ee73f27bde4a1d2c5bf.png"></div><br>  Es ist ganz einfach, ein Satellitenbild des gewünschten geografischen Gebiets und eine zugehörige Höhenkarte zu finden.  Unten finden Sie die Satellitenkarte des Mars (oben) und die Höhenkarte (unten), die in diesem Tutorial verwendet wurden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b80/468/176/b804681769208dfc72ec69441d9f0986.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/266/f0c/b59/266f0cb59bb01a7f875d3323d526372a.png"></div><br>  Ich habe in einer anderen Reihe von Tutorials mit dem Titel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">"3D-Fotos von Facebook von innen: Parallaxen-Shader"</a> [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Übersetzung</a> in Habré] ausführlich über das Konzept der Tiefenkarte gesprochen. <br><br>  In diesem Tutorial wird davon ausgegangen, dass die Höhenkarte als Bild in Graustufen gespeichert ist, wobei Schwarzweiß niedrigeren und höheren Höhen entspricht.  Wir brauchen diese Werte auch, um <em>linear</em> zu skalieren, <em>dh</em> der Farbunterschied, beispielsweise bei <code>0.1</code> entspricht einem Höhenunterschied zwischen <code>0</code> und <code>0.1</code> oder zwischen <code>0.9</code> und <code>1.0</code> .  Bei Tiefenkarten ist dies nicht immer der Fall, da viele von ihnen Tiefeninformationen auf einer <em>logarithmischen Skala</em> speichern. <br><br>  Zum Abtasten einer Textur werden zwei Informationselemente benötigt: die Textur selbst und die <strong>UV-Koordinaten des</strong> Punktes, den wir abtasten möchten.  Auf Letzteres kann über das in der Struktur <code>texcoord</code> gespeicherte Feld <code>appdata_base</code> werden.  Dies ist die UV-Koordinate, die dem aktuell verarbeiteten Scheitelpunkt zugeordnet ist.  Die <code>tex2D</code> in einer <em>Oberflächenfunktion</em> erfolgt mit <code>tex2D</code> . Wenn wir uns jedoch in einer <code> </code> , ist <code>tex2Dlod</code> erforderlich. <br><br>  Im folgenden <code>_HeightMap</code> eine Textur namens <code>_HeightMap</code> verwendet, um den für jeden Scheitelpunkt durchgeführten Extrusionswert zu ändern: <br><br><pre> <code class="cpp hljs">sampler2D _HeightMap; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ fixed height = tex2Dlod(_HeightMap, float4(v.texcoord.xy, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)).r; vertex.xyz += v.normal * height * _Amount; }</code> </pre> <br>  Warum kann tex2D nicht als Scheitelpunktfunktion verwendet werden? <br>  Wenn Sie sich den Code ansehen, den Unity für Standard Surface Shader generiert, werden Sie feststellen, dass er bereits ein Beispiel für das Beispiel von Texturen enthält.  Insbesondere wird die <code>_MainTex</code> ( <code>_MainTex</code> ) in einer <em>Oberflächenfunktion</em> (genannt <code>surf</code> ) unter Verwendung der integrierten <code>tex2D</code> Funktion <code>tex2D</code> . <br><br>  Tatsächlich wird <code>tex2D</code> verwendet, um Pixel aus einer Textur <code>tex2D</code> , unabhängig davon, was darin gespeichert ist, Farbe oder Höhe.  Möglicherweise stellen Sie jedoch fest, dass <code>tex2D</code> nicht in einer Scheitelpunktfunktion verwendet werden kann. <br><br>  Der Grund ist, dass <code>tex2D</code> <em>nicht nur</em> Pixel aus der Textur liest.  Sie entscheidet auch, welche Version der Textur verwendet werden soll, abhängig von der Entfernung zur Kamera.  Diese Technik wird als <strong>Mipmapping bezeichnet</strong> : Sie ermöglicht kleinere Versionen einer einzelnen Textur, die automatisch in unterschiedlichen Entfernungen verwendet werden können. <br><br>  In der Oberflächenfunktion weiß der Shader bereits, welche <strong>MIP-Textur</strong> verwendet werden soll.  Diese Informationen sind möglicherweise noch nicht in der Scheitelpunktfunktion verfügbar, und daher kann <code>tex2D</code> nicht mit voller <code>tex2D</code> verwendet werden.  Im Gegensatz dazu kann der <code>tex2Dlod</code> Funktion zwei zusätzliche Parameter übergeben werden, die in diesem Tutorial einen Nullwert haben können. <br><br>  Das Ergebnis ist in den folgenden Bildern deutlich sichtbar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a7/b64/0a6/5a7b640a60ca2ce42c9d4ee3f5c95150.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0b/dbf/dad/c0bdbfdadf38764dd3d75ffb69d07dea.png"></div><br>  In diesem Fall kann eine leichte Vereinfachung vorgenommen werden.  Der zuvor überprüfte Code kann mit jeder Geometrie verwendet werden.  Wir können jedoch davon ausgehen, dass die Oberfläche absolut flach ist.  Tatsächlich möchten wir diesen Effekt wirklich auf das Flugzeug anwenden. <br><br>  Daher können Sie <code>v.normal</code> entfernen und durch <code>float3(0, 1, 0)</code> ersetzen: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ float3 normal = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); fixed height = tex2Dlod(_HeightMap, float4(v.texcoord.xy, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)).r; vertex.xyz += normal * height * _Amount; }</code> </pre> <br>  Wir könnten dies tun, weil alle Koordinaten in <code>appdata_base</code> im <code>appdata_base</code> gespeichert sind, <code>appdata_base</code> sie werden relativ zum Zentrum und zur Ausrichtung des 3D-Modells festgelegt.  Übergang, Drehung und Skalierung mit <em>Transformation</em> in Unity ändern Position, Drehung und Skalierung des Objekts, haben jedoch keinen Einfluss auf das ursprüngliche 3D-Modell. <br><br><h2>  Teil 2. Bildlaufeffekt </h2><br>  Alles, was wir oben gemacht haben, funktioniert ziemlich gut.  Bevor wir <code>getVertex</code> , extrahieren wir den Code, der zur Berechnung der neuen Scheitelpunkthöhe erforderlich ist, in eine separate Funktion <code>getVertex</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getVertex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float4 vertex, float2 texcoord)</span></span></span><span class="hljs-function"> </span></span>{ float3 normal = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); fixed height = tex2Dlod(_HeightMap, float4(texcoord, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)).r; vertex.xyz += normal * height * _Amount; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vertex; }</code> </pre> <br>  Dann hat die gesamte Funktion <code>vert</code> die Form: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ vertex = getVertex(v.vertex, v.texcoord.xy); }</code> </pre> <br>  Wir haben dies getan, weil wir unten die Höhe mehrerer Punkte berechnen müssen.  Aufgrund der Tatsache, dass diese Funktionalität in einer eigenen Funktion ausgeführt wird, wird der Code viel einfacher. <br><br><h2>  UV-Koordinatenberechnung </h2><br>  Dies führt uns jedoch zu einem anderen Problem.  Die Funktion <code>getVertex</code> hängt nicht nur von der Position des aktuellen Scheitelpunkts (v.vertex) ab, sondern auch von seinen UV-Koordinaten ( <code>v.texcoord</code> ). <br><br>  Wenn wir den Scheitelpunkthöhenversatz berechnen möchten, den die <code>vert</code> Funktion derzeit verarbeitet, sind beide Datenelemente in der Struktur <code>appdata_base</code> verfügbar.  Was passiert jedoch, wenn wir die Position eines benachbarten Punkts abtasten müssen?  In diesem Fall können wir die xyz-Position im <strong>Modellraum kennen</strong> , haben jedoch keinen Zugriff auf die UV-Koordinaten. <br><br>  Dies bedeutet, dass das vorhandene System den Höhenversatz nur für den aktuellen Scheitelpunkt berechnen kann.  Eine solche Einschränkung wird es uns nicht ermöglichen, weiterzumachen, daher müssen wir eine Lösung finden. <br><br>  Am einfachsten ist es, die UV-Koordinaten eines 3D-Objekts zu berechnen und die Position seines Scheitelpunkts zu kennen.  Dies ist eine sehr schwierige Aufgabe, und es gibt verschiedene Techniken, um sie zu lösen (eine der beliebtesten ist die <strong>triplanare Projektion</strong> ).  In diesem speziellen Fall müssen wir UV jedoch nicht an die Geometrie anpassen.  Wenn wir davon ausgehen, dass der Shader immer auf das flache Netz angewendet wird, wird die Aufgabe trivial. <br><br>  Wir können <em>UV-Koordinaten</em> (unteres Bild) aus den <em>Positionen der Eckpunkte</em> (oberes Bild) berechnen, da beide linear auf einem flachen Netz überlagert sind. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/147/614/a7a/147614a7a05ba08700aef85be89f3a53.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02f/ff8/c42/02fff8c42dae9fa7de4f7e9598843afe.png" width="359" height="210"></div><br>  Dies bedeutet, dass wir zur Lösung unseres Problems die <em>Komponenten XZ</em> <em>der Scheitelpunktposition</em> in die entsprechenden <em>UV-Koordinaten</em> umwandeln müssen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48a/607/6b0/48a6076b06650e1074dd5b0f2f7ed023.png" width="363" height="393"></div><br>  Diese Prozedur wird als <strong>lineare Interpolation bezeichnet</strong> .  Es wird auf meiner Website ausführlich besprochen (zum Beispiel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Die Geheimnisse der Farbinterpolation</a> ). <br><br>  In den meisten Fällen liegen die UV-Werte im Bereich von <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>0</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMAIN-30" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>0</mn></math></span></span><script type="math/tex" id="MathJax-Element-1"> 0 </script>  vorher <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMAIN-31" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-2"> 1 </script>  ;;  Im Gegensatz dazu sind die Koordinaten jedes Scheitelpunkts möglicherweise unbegrenzt.  Aus mathematischer Sicht benötigen wir für die Umstellung von XZ auf UV nur deren Grenzwerte: <br><br><ul><li><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>X</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.153ex" height="2.419ex" viewBox="0 -780.1 2218.6 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-58" x="0" y="0"></use><g transform="translate(828,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-69" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6E" x="1224" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>X</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-3"> X_ {min} </script>  , <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>X</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.409ex" height="2.419ex" viewBox="0 -780.1 2328.9 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-58" x="0" y="0"></use><g transform="translate(828,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-61" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-78" x="1408" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>X</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-4"> X_ {max} </script></li><li><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>Z</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.816ex" height="2.419ex" viewBox="0 -780.1 2073.6 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-5A" x="0" y="0"></use><g transform="translate(683,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-69" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6E" x="1224" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>Z</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-5"> Z_ {min} </script>  , <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>Z</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.072ex" height="2.419ex" viewBox="0 -780.1 2183.9 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-5A" x="0" y="0"></use><g transform="translate(683,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-61" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-78" x="1408" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>Z</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-6"> Z_ {max} </script></li><li><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>U</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.816ex" height="2.419ex" viewBox="0 -780.1 2073.6 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-55" x="0" y="0"></use><g transform="translate(683,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-69" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6E" x="1224" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>U</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-7"> U_ {min} </script>  , <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>U</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.072ex" height="2.419ex" viewBox="0 -780.1 2183.9 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-55" x="0" y="0"></use><g transform="translate(683,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-61" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-78" x="1408" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>U</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-8"> U_ {max} </script></li><li><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>V</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.584ex" height="2.419ex" viewBox="0 -780.1 1973.6 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-56" x="0" y="0"></use><g transform="translate(583,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-69" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6E" x="1224" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>V</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-9"> V_ {min} </script>  , <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>V</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.84ex" height="2.419ex" viewBox="0 -780.1 2083.9 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-56" x="0" y="0"></use><g transform="translate(583,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-61" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-78" x="1408" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>V</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-10"> V_ {max} </script></li></ul><br>  die unten gezeigt werden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87a/520/05c/87a52005ccc02b02403068fd3e075864.png" width="359" height="210"></div><br>  Diese Werte variieren je nach verwendetem Netz.  Auf der Unity-Ebene liegen die <em>UV-Koordinaten</em> im Bereich von <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>0</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMAIN-30" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>0</mn></math></span></span><script type="math/tex" id="MathJax-Element-11"> 0 </script>  vorher <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMAIN-31" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-12"> 1 </script>  und die <em>Koordinaten der Eckpunkte</em> liegen im Bereich von <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo>&amp;#x2212;</mo><mn>5</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.971ex" height="2.057ex" viewBox="0 -728.2 1279 885.9" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMAIN-2212" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMAIN-35" x="778" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo>−</mo><mn>5</mn></math></span></span><script type="math/tex" id="MathJax-Element-13"> -5 </script>  vorher <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-14-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo>+</mo><mn>5</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.971ex" height="2.057ex" viewBox="0 -728.2 1279 885.9" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMAIN-2B" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMAIN-35" x="778" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo>+</mo><mn>5</mn></math></span></span><script type="math/tex" id="MathJax-Element-14"> + 5 </script>  . <br><br>  Die Gleichungen zur Umwandlung von XZ in UV sind: <br><br>  (1) <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d2/e5c/a22/7d2e5ca229d8fc1c135aaa42e863fc9c.svg" alt="Bild"></div><br><br><div class="spoiler">  <b class="spoiler_title">Wie werden sie angezeigt?</b> <div class="spoiler_text">  Wenn Sie mit dem Konzept der linearen Interpolation nicht vertraut sind, können diese Gleichungen ziemlich einschüchternd wirken. <br><br>  Sie werden jedoch ganz einfach angezeigt.  Schauen wir uns nur ein Beispiel an. <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-15-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>U</mi></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.783ex" height="2.074ex" viewBox="0 -772.3 767.5 892.8" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-55" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>U</mi></math></span></span><script type="math/tex" id="MathJax-Element-15"> U </script>  .  Wir haben zwei Intervalle: eines hat Werte von <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-16-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>X</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.153ex" height="2.349ex" viewBox="0 -772.3 2218.6 1011.3" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.555ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-58" x="0" y="0"></use><g transform="translate(828,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-69" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6E" x="1224" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>X</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-16"> X_ {min} </script>  vorher <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-17-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>X</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.409ex" height="2.349ex" viewBox="0 -772.3 2328.9 1011.3" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.555ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-58" x="0" y="0"></use><g transform="translate(828,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-61" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-78" x="1408" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>X</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-17"> X_ {max} </script>  ein anderer aus <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-18-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>U</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.816ex" height="2.349ex" viewBox="0 -772.3 2073.6 1011.3" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.555ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-55" x="0" y="0"></use><g transform="translate(683,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-69" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6E" x="1224" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>U</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-18"> U_ {min} </script>  vorher <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-19-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>U</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.072ex" height="2.349ex" viewBox="0 -772.3 2183.9 1011.3" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.555ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-55" x="0" y="0"></use><g transform="translate(683,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-61" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-78" x="1408" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>U</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-19"> U_ {max} </script>  .  Eingehende Daten für die Koordinate <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-20-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>X</mi></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.98ex" height="2.074ex" viewBox="0 -772.3 852.5 892.8" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-58" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>X</mi></math></span></span><script type="math/tex" id="MathJax-Element-20"> X </script>  ist die Koordinate des aktuellen Scheitelpunkts, der verarbeitet wird, und die Ausgabe ist die Koordinate <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-21-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>U</mi></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.783ex" height="2.074ex" viewBox="0 -772.3 767.5 892.8" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-55" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>U</mi></math></span></span><script type="math/tex" id="MathJax-Element-21"> U </script>  wird verwendet, um die Textur abzutasten. <br><br>  Wir müssen die Eigenschaften der Proportionalität zwischen beibehalten <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-22-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>X</mi></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.98ex" height="2.074ex" viewBox="0 -772.3 852.5 892.8" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-58" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>X</mi></math></span></span><script type="math/tex" id="MathJax-Element-22"> X </script>  und sein Intervall und <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-23-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>U</mi></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.783ex" height="2.074ex" viewBox="0 -772.3 767.5 892.8" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-55" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>U</mi></math></span></span><script type="math/tex" id="MathJax-Element-23"> U </script>  und sein Intervall.  Zum Beispiel wenn <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-24-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>X</mi></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.98ex" height="2.074ex" viewBox="0 -772.3 852.5 892.8" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-58" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>X</mi></math></span></span><script type="math/tex" id="MathJax-Element-24"> X </script>  zählt dann 25% seines Intervalls <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-25-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>U</mi></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.783ex" height="2.074ex" viewBox="0 -772.3 767.5 892.8" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-55" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>U</mi></math></span></span><script type="math/tex" id="MathJax-Element-25"> U </script>  wird auch 25% seines Intervalls ausmachen. <br><br>  All dies ist in der folgenden Abbildung dargestellt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22a/784/da1/22a784da18e327b20b872699a901f0ec.png" width="292" height="202"></div><br>  Daraus können wir schließen, dass der Anteil des roten Segments in Bezug auf das Rosa dem Anteil zwischen dem blauen Segment und dem blauen Segment entsprechen sollte: <br><br>  (2) <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bcc/9e1/49e/bcc9e149ea65e83dd70345dd92784788.png" height="39" width="232"></div><br>  Jetzt können wir die oben gezeigte Gleichung transformieren, um zu erhalten <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-26-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>U</mi></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.783ex" height="2.074ex" viewBox="0 -772.3 767.5 892.8" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-55" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>U</mi></math></span></span><script type="math/tex" id="MathJax-Element-26"> U </script>  :: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/737/266/0fe/7372660fe877b0780e4cebc97a6f22f2.png" height="85" width="388"></div><br>  und diese Gleichung hat genau die gleiche Form wie oben gezeigt (1). </div></div><br>  Diese Gleichungen können wie folgt im Code implementiert werden: <br><br><pre> <code class="cpp hljs">float2 _VertexMin; float2 _VertexMax; float2 _UVMin; float2 _UVMax; <span class="hljs-function"><span class="hljs-function">float2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vertexToUV</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float4 vertex)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (vertex.xz - _VertexMin) / (_VertexMax - _VertexMin) * (_UVMax - _UVMin) + _UVMin; }</code> </pre> <br>  Jetzt können wir die Funktion <code>getVertex</code> , ohne <code>v.texcoord</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getVertex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float4 vertex)</span></span></span><span class="hljs-function"> </span></span>{ float3 normal = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); float2 texcoord = vertexToUV(vertex); fixed height = tex2Dlod(_HeightMap, float4(texcoord, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)).r; vertex.xyz += normal * height * _Amount; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vertex; }</code> </pre> <br>  Dann nimmt die gesamte Funktion <code>vert</code> die Form an: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ v.vertex = getVertex(v.vertex); }</code> </pre> <br><h3>  Bildlaufeffekt </h3><br>  Dank des von uns geschriebenen Codes wird die gesamte Karte auf dem Netz angezeigt.  Wenn wir die Anzeige verbessern wollen, müssen wir Änderungen vornehmen. <br><br>  Lassen Sie uns den Code etwas formalisieren.  Erstens müssen wir möglicherweise einen separaten Teil der Karte vergrößern, anstatt ihn als Ganzes zu betrachten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b5/1c3/bcd/0b51c3bcd59365527d3659564768b01b.png" width="530" height="309"></div><br>  Dieser Bereich kann durch zwei Werte definiert werden: seine Größe ( <code>_CropSize</code> ) und seine Position auf der Karte ( <code>_CropOffset</code> ), gemessen im <em>Scheitelpunktraum</em> (von <code>_VertexMin</code> bis <code>_VertexMax</code> ). <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Cropping float2 _CropSize; float2 _CropOffset;</span></span></code> </pre> <br>  Nachdem wir diese beiden Werte erhalten haben, können wir wieder die lineare Interpolation verwenden, sodass <code>getVertex</code> nicht für die aktuelle Position der Oberseite des 3D-Modells <code>getVertex</code> , sondern für den skalierten und übertragenen Punkt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0c/620/418/c0c620418088c383addcaa54328fe0fc.png" width="529" height="589"></div><br>  Relevanter Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ float2 croppedMin = _CropOffset; float2 croppedMax = croppedMin + _CropSize; <span class="hljs-comment"><span class="hljs-comment">// v.vertex.xz: [_VertexMin, _VertexMax] // cropped.xz : [croppedMin, croppedMax] float4 cropped = v.vertex; cropped.xz = (v.vertex.xz - _VertexMin) / (_VertexMax - _VertexMin) * (croppedMax - croppedMin) + croppedMin; v.vertex.y = getVertex(cropped); }</span></span></code> </pre> <br>  Wenn wir scrollen möchten, reicht es aus, <code>_CropOffset</code> über das Skript zu aktualisieren.  Aus diesem Grund wird der Kürzungsbereich verschoben und tatsächlich durch die Landschaft gescrollt. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MoveMap</span></span></span><span class="hljs-class"> :</span></span> MonoBehaviour { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Material Material; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 Speed; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 Offset; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CropOffsetID; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ CropOffsetID = Shader.PropertyToID(<span class="hljs-string"><span class="hljs-string">"_CropOffset"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Material.SetVector(CropOffsetID, Speed * Time.time + Offset); } }</code> </pre> <br>  Damit dies funktioniert, ist es sehr wichtig, den <strong>Umbruchmodus</strong> aller Texturen auf <strong>Wiederholen</strong> einzustellen.  Wenn dies nicht getan wird, können wir die Textur nicht schleifen. <br><br>  Für den Zoom / Zoom-Effekt reicht es aus, nur <code>_CropSize</code> ändern. <br><br><h2>  Teil 3. Geländeschattierung </h2><br><h2>  Flache Schattierung </h2><br>  Der gesamte Code, den wir geschrieben haben, funktioniert, hat aber ein ernstes Problem.  Das Modell zu beschatten ist irgendwie seltsam.  Die Oberfläche ist richtig gekrümmt, reagiert aber auf Licht, als wäre es flach. <br><br>  Dies ist in den folgenden Bildern sehr deutlich zu sehen.  Das obere Bild zeigt einen vorhandenen Shader.  Der untere Teil zeigt, wie es tatsächlich funktioniert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0b/dbf/dad/c0bdbfdadf38764dd3d75ffb69d07dea.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/511/6a1/e02/5116a1e02debfaa58afe0cddf3b4c6c9.png"></div><br>  Die Lösung dieses Problems kann eine große Herausforderung sein.  Aber zuerst müssen wir herausfinden, was der Fehler ist. <br><br>  Der normale Extrusionsvorgang hat die allgemeine Geometrie der ursprünglich verwendeten Ebene geändert.  Unity hat jedoch nur die Position der Scheitelpunkte geändert, nicht jedoch ihre normalen Richtungen.  <strong>Die Richtung der</strong> Scheitelpunktnormalen ist, wie der Name schon sagt, ein Einheitslängenvektor ( <em>Richtung</em> ), der senkrecht zur Oberfläche anzeigt.  <em>Normalen sind</em> notwendig, weil sie eine wichtige Rolle bei der Schattierung eines 3D-Modells spielen.  Sie werden von allen Oberflächen-Shadern verwendet, um zu berechnen, wie Licht von jedem Dreieck des 3D-Modells reflektiert werden soll.  Normalerweise ist dies notwendig, um die Dreidimensionalität des Modells zu verbessern. Beispielsweise wird Licht von einer ebenen Oberfläche reflektiert, genau wie es von einer gekrümmten Oberfläche reflektiert wird.  Dieser Trick wird häufig verwendet, um Low-Poly-Oberflächen glatter aussehen zu lassen als sie tatsächlich sind (siehe unten). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f6b/d7c/443/f6bd7c443381c1f0e133ee7b7bce05e1.png"></div><br>  In unserem Fall passiert jedoch das Gegenteil.  Die Geometrie ist gekrümmt und glatt, aber da alle Normalen nach oben gerichtet sind, wird das Licht vom Modell reflektiert, als wäre es flach (siehe unten): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/323/241/cde/323241cdef1b3a41604c579f4fdb509b.png"></div><br>  Weitere Informationen zur Rolle von Normalen bei der Objektschattierung finden Sie im Artikel über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Normal Mapping (Bump Mapping)</a> , in dem identische Zylinder trotz des gleichen 3D-Modells aufgrund unterschiedlicher Methoden zur Berechnung von Scheitelpunktnormalen sehr unterschiedlich aussehen (siehe unten). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b7/4fc/15f/1b74fc15f90516cc80b283953ef12373.png" width="315" height="243"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f93/544/d9c/f93544d9c95a70da71848897f0913676.png" width="347" height="254"></div><br>  Leider verfügen weder Unity noch die Sprache zum Erstellen von Shadern über eine integrierte Lösung zum automatischen Neuberechnen von Normalen.  Dies bedeutet, dass Sie sie abhängig von der lokalen Geometrie des 3D-Modells manuell ändern müssen. <br><br><h2>  Normale Berechnung </h2><br>  Die einzige Möglichkeit, das Schattierungsproblem zu beheben, besteht darin, die Normalen basierend auf der Oberflächengeometrie manuell zu berechnen.  Eine ähnliche Aufgabe wurde in einem Beitrag von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Vertex Displacement - Melting Shader Part 1</a> besprochen, in dem das Schmelzen von 3D-Modellen in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Cone Wars</a> simuliert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">wurde</a> . <br><br>  Obwohl der fertige Code in 3D-Koordinaten arbeiten muss, beschränken wir die Aufgabe vorerst auf nur zwei Dimensionen.  Stellen Sie sich vor, Sie müssen die <strong>Richtung der Normalen</strong> berechnen, die dem Punkt auf der 2D-Kurve entspricht (der große blaue Pfeil im folgenden Diagramm). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5a/405/6be/e5a4056be62b920d9721a84d7c050ee6.png" width="316" height="346"></div><br>  Aus geometrischer Sicht ist die <em>Richtung der Normalen</em> (großer blauer Pfeil) ein Vektor senkrecht zu der <strong>Tangente,</strong> die durch den für uns interessanten Punkt verläuft (eine dünne blaue Linie).  <em>Die Tangente</em> kann als Linie dargestellt werden, die sich auf der Krümmung des Modells befindet.  <strong>Ein Tangentenvektor</strong> ist ein <em>Einheitsvektor</em> , der auf einer Tangente liegt. <br><br>  Dies bedeutet, dass Sie zur Berechnung der Normalen zwei Schritte ausführen müssen: Suchen Sie zuerst die <em>Tangente</em> an den gewünschten Punkt.  Berechnen Sie dann den Vektor senkrecht dazu (dies ist die notwendige <em>Richtung der Normalen</em> ). <br><br><h3>  Tangentenberechnung </h3><br>  Um die <em>Normalität zu erhalten, müssen</em> wir zuerst die <em>Tangente</em> berechnen.  Sie kann angenähert werden, indem ein Punkt in der Nähe abgetastet und daraus eine Linie in der Nähe des Scheitelpunkts erstellt wird.  Je kleiner die Linie, desto genauer ist der Wert. <br><br>  Drei Schritte sind erforderlich: <br><br><ul><li>  Stufe 1. Bewegen Sie eine kleine Menge auf einer ebenen Fläche </li><li>  Schritt 2. Berechnen Sie die Höhe des neuen Punktes. </li><li>  Schritt 3. Verwenden Sie die Höhe des aktuellen Punkts, um die Tangente zu berechnen </li></ul><br>  All dies ist im Bild unten zu sehen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/46f/bd3/7e8/46fbd37e868d16ff7ec6f1a164377018.png"></div><br>  Damit dies funktioniert, müssen wir die Höhe von zwei Punkten berechnen, nicht von einem.  Zum Glück wissen wir bereits, wie das geht.  Im vorherigen Teil des Tutorials haben wir eine Funktion erstellt, die die Höhe einer Landschaft basierend auf einem Netzpunkt abtastet.  Wir haben es <code>getVertex</code> . <br><br>  Wir können den neuen Scheitelpunktwert am aktuellen Punkt und dann an zwei anderen nehmen.  Einer ist für die Tangente, der andere für die Tangente an zwei Punkten.  Mit ihrer Hilfe bekommen wir das Normale.  Wenn das ursprüngliche Netz, mit dem der Effekt erstellt wurde, flach ist (und in unserem Fall auch), benötigen wir keinen Zugriff auf <code>v.normal</code> und können einfach <code>float3(0, 0, 1)</code> für Tangente bzw. Tangente an zwei Punkte <code>float3(0, 0, 1)</code> und <code>float3(1, 0, 0)</code> .  Wenn wir dasselbe tun wollten, aber zum Beispiel für eine Kugel, wäre es viel schwieriger, zwei geeignete Punkte für die Berechnung der Tangente und der Tangente an zwei Punkte zu finden. <br><br><h3>  Vektorgrafiken </h3><br>  Nachdem wir die geeigneten Tangenten- und Tangentenvektoren für zwei Punkte erhalten haben, können wir die Normalen unter Verwendung einer Operation berechnen, die als <strong>Vektorprodukt bezeichnet wird</strong> .  Es gibt viele Definitionen und Erklärungen für eine Vektorarbeit und deren Funktionsweise. <br><br>  Ein Vektorprodukt empfängt zwei Vektoren und gibt einen neuen zurück.  Wenn zwei Anfangsvektoren Einheit waren (ihre Länge ist gleich Eins) und sie sich in einem Winkel von 90 befinden, befindet sich der resultierende Vektor bei 90 Grad relativ zu beiden. <br><br>  Dies kann zunächst verwirrend sein, kann jedoch grafisch wie folgt dargestellt werden: Das Vektorprodukt zweier Achsen erzeugt eine dritte.  Also <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-27-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>X</mi><mtext>&amp;#xA0;</mtext><mi>m</mi><mi>a</mi><mi>l</mi><mi>Y</mi><mo>=</mo><mi>Z</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="13.076ex" height="2.057ex" viewBox="0 -780.1 5630.1 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-58" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6D" x="1102" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-61" x="1981" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6C" x="2510" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-59" x="2809" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMAIN-3D" x="3850" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-5A" x="4906" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>X</mi><mtext>&nbsp;</mtext><mi>m</mi><mi>a</mi><mi>l</mi><mi>Y</mi><mo>=</mo><mi>Z</mi></math></span></span><script type="math/tex" id="MathJax-Element-27"> X \ mal Y = Z </script>  aber auch <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-28-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>X</mi><mtext>&amp;#xA0;</mtext><mi>m</mi><mi>a</mi><mi>l</mi><mi>Z</mi><mo>=</mo><mi>Y</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="13.076ex" height="2.057ex" viewBox="0 -780.1 5630.1 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-58" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6D" x="1102" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-61" x="1981" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6C" x="2510" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-5A" x="2809" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMAIN-3D" x="3810" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-59" x="4866" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>X</mi><mtext>&nbsp;</mtext><mi>m</mi><mi>a</mi><mi>l</mi><mi>Z</mi><mo>=</mo><mi>Y</mi></math></span></span><script type="math/tex" id="MathJax-Element-28"> X \ mal Z = Y </script>  , usw. <br><br>  Wenn wir einen ausreichend kleinen Schritt machen (im Code ist dies <code>offset</code> ), befinden sich die Vektoren der Tangente und der Tangente an zwei Punkte in einem Winkel von 90 Grad.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammen mit dem Normalenvektor bilden sie drei senkrechte Achsen, die entlang der Oberfläche des Modells ausgerichtet sind. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir das wissen, können wir den gesamten notwendigen Code schreiben, um den normalen Vektor zu berechnen und zu aktualisieren.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ float3 bitangent = float3(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); float3 tangent = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> offset = <span class="hljs-number"><span class="hljs-number">0.01</span></span>; float4 vertexBitangent = getVertex(v.vertex + float4(bitangent * offset, <span class="hljs-number"><span class="hljs-number">0</span></span>) ); float4 vertex = getVertex(v.vertex); float4 vertexTangent = getVertex(v.vertex + float4(tangent * offset, <span class="hljs-number"><span class="hljs-number">0</span></span>) ); float3 newBitangent = (vertexBitangent - vertex).xyz; float3 newTangent = (vertexTangent - vertex).xyz; v.normal = cross(newTangent, newBitangent); v.vertex.y = vertex.y; }</code> </pre> <br><h3>  Alles zusammenfügen </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt, da alles funktioniert, können wir den Scroll-Effekt zurückgeben. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// v.vertex.xz: [_VertexMin, _VertexMax] // cropped.xz : [croppedMin, croppedMax] float2 croppedMin = _CropOffset; float2 croppedMax = croppedMin + _CropSize; float4 cropped = v.vertex; cropped.xz = (v.vertex.xz - _VertexMin) / (_VertexMax - _VertexMin) * (croppedMax - croppedMin) + croppedMin; float3 bitangent = float3(1, 0, 0); float3 normal = float3(0, 1, 0); float3 tangent = float3(0, 0, 1); float offset = 0.01; float4 vertexBitangent = getVertex(cropped + float4(bitangent * offset, 0) ); float4 vertex = getVertex(cropped); float4 vertexTangent = getVertex(cropped + float4(tangent * offset, 0) ); float3 newBitangent = (vertexBitangent - vertex).xyz; float3 newTangent = (vertexTangent - vertex).xyz; v.normal = cross(newTangent, newBitangent); v.vertex.y = vertex.y; v.texcoord = float4(vertexToUV(cropped), 0,0); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und damit ist unser Effekt endlich abgeschlossen. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d9/b07/680/0d9b0768068b2329d53e22a71ff27dfb.gif" width="700" height="272"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wohin als nächstes gehen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieses Tutorial kann zur Grundlage für komplexere Effekte werden, beispielsweise für holographische Projektionen oder sogar für eine Kopie des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sandtisches</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aus dem Film "Black Panther".</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ecS1_-Y_uP8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Einheitspaket </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das vollständige Paket für dieses Tutorial kann auf </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patreon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> heruntergeladen </font><font style="vertical-align: inherit;">werden. Es enthält alle </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener"><font style="vertical-align: inherit;">Elemente</font></a><font style="vertical-align: inherit;"> , die zum Spielen des beschriebenen Effekts erforderlich sind.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462153/">https://habr.com/ru/post/de462153/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462141/index.html">Wagen für ein Rechenzentrum</a></li>
<li><a href="../de462145/index.html">Warum dauert das Abbestellen mehrere Tage?</a></li>
<li><a href="../de462147/index.html">Arbeiten mit der Navigation beim Refactoring eines Projekterbes in React Native</a></li>
<li><a href="../de462149/index.html">Zugriffsbeschränkungsmodus für Zubehör auf iOS-Geräten und deren Umgehung</a></li>
<li><a href="../de462151/index.html">5 Top-Kubernetes-Distributionen</a></li>
<li><a href="../de462155/index.html">Arbeiten Sie mit Worker "wie Sie möchten", nicht "so viel wie möglich".</a></li>
<li><a href="../de462159/index.html">Aufbau eines Gesichtserkennungssystems basierend auf Golang und OpenCV</a></li>
<li><a href="../de462161/index.html">Erleben Sie die Installation von Apache Airflow unter Windows 10</a></li>
<li><a href="../de462163/index.html">Technologien, die 2020 populär sein werden</a></li>
<li><a href="../de462165/index.html">Wie 25 Leute dazu gebracht wurden, für eine nicht existierende Spielefirma zu arbeiten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>