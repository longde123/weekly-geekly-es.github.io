<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïµüèΩ üë∂üèΩ üëÉüèª Unity Interactive Map Shader üë¶üèæ ‚õ¥Ô∏è üë≤üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Tutorial geht es um interaktive Karten und deren Erstellung in Unity mithilfe von Shadern. 

 Dieser Effekt kann als Grundlage f√ºr komplexer...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unity Interactive Map Shader</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462153/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/511/6a1/e02/5116a1e02debfaa58afe0cddf3b4c6c9.png" alt="Bild"></div><br>  In diesem Tutorial geht es um <strong>interaktive Karten</strong> und deren Erstellung in Unity mithilfe von Shadern. <br><br>  Dieser Effekt kann als Grundlage f√ºr komplexere Techniken wie holographische Projektionen oder sogar einen Sandtisch aus dem Film "Black Panther" dienen. <br><br>  Eine Inspiration f√ºr dieses Tutorial ist der von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Baran Kahyaoglu</a> ver√∂ffentlichte Tweet, der ein Beispiel daf√ºr zeigt, was er f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Mapbox erstellt</a> . <br><a name="habracut"></a><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="1118609807844442112"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-1" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="1118610439049494540"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br>  Die Szene (ohne Karte) wurde aus der Unity Visual Effect Graph-Raumschiff-Demo (siehe unten) entnommen, die hier heruntergeladen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">werden kann</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/rqMcPZoEc3U" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Teil 1. Scheitelpunktversatz </h2><br><h2>  Anatomie der Wirkung </h2><br>  Das erste, was Sie sofort bemerken k√∂nnen, ist, dass geografische Karten <em>flach sind</em> : Wenn sie als Texturen verwendet werden, fehlt ihnen die Dreidimensionalit√§t, die ein reales 3D-Modell des entsprechenden Kartenbereichs haben w√ºrde. <br><br>  Sie k√∂nnen diese L√∂sung anwenden: Erstellen Sie ein 3D-Modell des Bereichs, der im Spiel ben√∂tigt wird, und wenden Sie dann eine Textur von der Karte darauf an.  Dies wird zur L√∂sung des Problems beitragen, nimmt jedoch viel Zeit in Anspruch und erm√∂glicht es nicht, den Effekt des ‚ÄûScrollens‚Äú aus dem Video Baran Kahyaoglu zu realisieren. <br><br>  Offensichtlich ist ein technischerer Ansatz am besten.  Gl√ºcklicherweise k√∂nnen Shader verwendet werden, um die Geometrie eines 3D-Modells zu √§ndern.  Mit ihrer Hilfe k√∂nnen Sie jedes Flugzeug in T√§ler und Berge der Region verwandeln, die wir brauchen. <br><br>  In diesem Tutorial verwenden wir eine Karte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">von Chillot</a> , Chilli, ber√ºhmt f√ºr seine charakteristischen H√ºgel.  Das Bild unten zeigt die Textur des Bereichs, der auf einem runden Netz aufgetragen ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a7/b64/0a6/5a7b640a60ca2ce42c9d4ee3f5c95150.png" width="797" height="346"></div><br>  Obwohl wir H√ºgel und Berge sehen, sind sie immer noch v√∂llig flach.  Dies zerst√∂rt die Illusion des Realismus. <br><br><h2>  Extrudieren von Normalen </h2><br>  Der erste Schritt zur Verwendung von Shadern zum √Ñndern der Geometrie ist eine Technik, die als <strong>normale Extrusion bezeichnet wird</strong> .  Sie ben√∂tigt <strong>einen Scheitelpunktmodifikator</strong> : eine Funktion, mit der einzelne Scheitelpunkte eines 3D-Modells bearbeitet werden k√∂nnen. <br><br>  Die Art und Weise, wie der Vertex-Modifikator verwendet wird, h√§ngt von der Art des verwendeten Shaders ab.  In diesem Tutorial √§ndern wir den <strong>Surface Standard Shader</strong> - einen der Shader-Typen, die Sie in Unity erstellen k√∂nnen. <br><br>  Es gibt viele M√∂glichkeiten, die Eckpunkte eines 3D-Modells zu bearbeiten.  Eine der ersten Methoden, die in den meisten Vertex-Shader-Tutorials beschrieben werden, ist das <strong>Extrudieren von Normalen</strong> .  Es besteht darin, jeden Scheitelpunkt nach au√üen zu dr√ºcken (zu <em>extrudieren</em> ), wodurch das 3D-Modell ein aufgebl√§hteres Aussehen erh√§lt.  "Au√üerhalb" bedeutet, dass sich jeder Scheitelpunkt entlang der Richtung der Normalen bewegt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/275/3e4/fe3/2753e4fe3502d77d46d7205e1ec81809.png"></div><br>  Bei glatten Oberfl√§chen funktioniert dies sehr gut, aber bei Modellen mit schlechten Scheitelpunktverbindungen kann diese Methode seltsame Artefakte erzeugen.  Dieser Effekt wird in einem meiner ersten Tutorials <strong>ausf√ºhrlich</strong> erl√§utert: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Eine sanfte Einf√ºhrung in Shader</a> , in der ich zeigte, wie <strong>ein</strong> 3D-Modell <strong>extrudiert</strong> und <strong>eingedrungen wird</strong> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a8/668/0e5/5a86680e5ab92b536d4999e693aed8cb.gif" width="485" height="278"></div><br>  Das Hinzuf√ºgen von extrudierten Normalen zu einem Oberfl√§chen-Shader ist sehr einfach.  Jeder Surface Shader verf√ºgt √ºber eine <code>#pragma</code> , mit der zus√§tzliche Informationen und Befehle √ºbertragen werden.  Ein solcher Befehl ist <code>vert</code> , was bedeutet, dass die <code>vert</code> Funktion verwendet wird, um jeden Scheitelpunkt des 3D-Modells zu verarbeiten. <br><br>  Der bearbeitete Shader lautet wie folgt: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf Standard fullforwardshadows addshadow vertex:vert ... float _Amount; ... void vert(inout appdata_base v) { v.vertex.xyz += v.normal * _Amount; }</span></span></code> </pre> <br>  Da wir die Position der Scheitelpunkte √§ndern, m√ºssen wir auch <code>addshadow</code> wenn das Modell Schatten korrekt auf sich selbst werfen soll. <br><br><div class="spoiler">  <b class="spoiler_title">Was ist appdata_base?</b> <div class="spoiler_text">  Wie Sie sehen k√∂nnen, haben wir eine Funktion des Vertices-Modifikators ( <code>vert</code> ) hinzugef√ºgt, der als Parameter eine <em>Struktur</em> namens <code>appdata_base</code> .  Diese Struktur speichert Informationen zu jedem einzelnen Scheitelpunkt des 3D-Modells.  Es enth√§lt nicht nur <em>die Scheitelpunktposition</em> ( <code>v.vertex</code> ), sondern auch andere Felder, z. B. <em>die normale Richtung</em> ( <code>v.normal</code> ) und <em>Texturinformationen,</em> die dem Scheitelpunkt ( <code>v.texcoord</code> ) zugeordnet sind. <br><br>  In einigen F√§llen reicht dies nicht aus, und wir ben√∂tigen m√∂glicherweise andere Eigenschaften, z. B. die <em>Scheitelpunktfarbe</em> ( <code>v.color</code> ) und die <em>Tangentenrichtung</em> ( <code>v.tangent</code> ).  Vertex-Modifikatoren k√∂nnen mithilfe einer Vielzahl anderer <code>appdata_tan</code> werden, einschlie√ülich <code>appdata_tan</code> und <code>appdata_full</code> , die auf Kosten eines geringen Leistungsaufwands mehr Informationen bereitstellen.  Weitere <code>appdata</code> zu <code>appdata</code> (und ihren Varianten) finden Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Unity3D-Wiki</a> . </div></div><br><div class="spoiler">  <b class="spoiler_title">Wie werden Werte von vert zur√ºckgegeben?</b> <div class="spoiler_text">  Die Top-Funktion hat keinen R√ºckgabewert.  Wenn Sie mit der C # -Sprache vertraut sind, sollten Sie wissen, dass Strukturen als Wert √ºbergeben werden. Wenn sich <code>v.vertex</code> √§ndert <code>v.vertex</code> wirkt sich dies nur auf die Kopie von <code>v</code> , deren Umfang durch den Hauptteil der Funktion begrenzt ist. <br><br>  <code>v</code> auch als <code>inout</code> deklariert, was bedeutet, dass es sowohl f√ºr die Eingabe als auch f√ºr die Ausgabe verwendet wird.  Alle √Ñnderungen, die Sie vornehmen, √§ndern die Variable selbst, die wir an <code>vert</code> .  Die Schl√ºsselw√∂rter <code>inout</code> und <code>out</code> sehr h√§ufig in der Computergrafik verwendet und k√∂nnen grob mit <code>ref</code> und <code>out</code> in C # korreliert werden. </div></div><br><h2>  Extrudieren von Normalen mit Texturen </h2><br>  Der oben verwendete Code funktioniert korrekt, ist jedoch weit von dem gew√ºnschten Effekt entfernt.  Der Grund ist, dass wir nicht alle Eckpunkte um den gleichen Betrag extrudieren m√∂chten.  Wir m√∂chten, dass die Oberfl√§che des 3D-Modells mit den T√§lern und Bergen der entsprechenden geografischen Region √ºbereinstimmt.  Zuerst m√ºssen wir irgendwie Informationen dar√ºber speichern und abrufen, wie viel jeder Punkt auf der Karte angehoben wird.  Wir m√∂chten, dass das Extrudieren von der Textur beeinflusst wird, in der die H√∂hen der Landschaft codiert sind.  Solche Texturen werden oft als <strong>H√∂henkarten bezeichnet</strong> , aber je nach Kontext werden sie auch als <strong>Tiefenkarten bezeichnet</strong> .  Nachdem wir Informationen √ºber die H√∂hen erhalten haben, k√∂nnen wir die Extrusion der Ebene basierend auf der H√∂henkarte √§ndern.  Wie in der Abbildung gezeigt, k√∂nnen wir so das Anheben und Absenken von Bereichen steuern. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f3/223/118/0f32231186763ee73f27bde4a1d2c5bf.png"></div><br>  Es ist ganz einfach, ein Satellitenbild des gew√ºnschten geografischen Gebiets und eine zugeh√∂rige H√∂henkarte zu finden.  Unten finden Sie die Satellitenkarte des Mars (oben) und die H√∂henkarte (unten), die in diesem Tutorial verwendet wurden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b80/468/176/b804681769208dfc72ec69441d9f0986.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/266/f0c/b59/266f0cb59bb01a7f875d3323d526372a.png"></div><br>  Ich habe in einer anderen Reihe von Tutorials mit dem Titel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">"3D-Fotos von Facebook von innen: Parallaxen-Shader"</a> [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úbersetzung</a> in Habr√©] ausf√ºhrlich √ºber das Konzept der Tiefenkarte gesprochen. <br><br>  In diesem Tutorial wird davon ausgegangen, dass die H√∂henkarte als Bild in Graustufen gespeichert ist, wobei Schwarzwei√ü niedrigeren und h√∂heren H√∂hen entspricht.  Wir brauchen diese Werte auch, um <em>linear</em> zu skalieren, <em>dh</em> der Farbunterschied, beispielsweise bei <code>0.1</code> entspricht einem H√∂henunterschied zwischen <code>0</code> und <code>0.1</code> oder zwischen <code>0.9</code> und <code>1.0</code> .  Bei Tiefenkarten ist dies nicht immer der Fall, da viele von ihnen Tiefeninformationen auf einer <em>logarithmischen Skala</em> speichern. <br><br>  Zum Abtasten einer Textur werden zwei Informationselemente ben√∂tigt: die Textur selbst und die <strong>UV-Koordinaten des</strong> Punktes, den wir abtasten m√∂chten.  Auf Letzteres kann √ºber das in der Struktur <code>texcoord</code> gespeicherte Feld <code>appdata_base</code> werden.  Dies ist die UV-Koordinate, die dem aktuell verarbeiteten Scheitelpunkt zugeordnet ist.  Die <code>tex2D</code> in einer <em>Oberfl√§chenfunktion</em> erfolgt mit <code>tex2D</code> . Wenn wir uns jedoch in einer <code> </code> , ist <code>tex2Dlod</code> erforderlich. <br><br>  Im folgenden <code>_HeightMap</code> eine Textur namens <code>_HeightMap</code> verwendet, um den f√ºr jeden Scheitelpunkt durchgef√ºhrten Extrusionswert zu √§ndern: <br><br><pre> <code class="cpp hljs">sampler2D _HeightMap; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ fixed height = tex2Dlod(_HeightMap, float4(v.texcoord.xy, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)).r; vertex.xyz += v.normal * height * _Amount; }</code> </pre> <br>  Warum kann tex2D nicht als Scheitelpunktfunktion verwendet werden? <br>  Wenn Sie sich den Code ansehen, den Unity f√ºr Standard Surface Shader generiert, werden Sie feststellen, dass er bereits ein Beispiel f√ºr das Beispiel von Texturen enth√§lt.  Insbesondere wird die <code>_MainTex</code> ( <code>_MainTex</code> ) in einer <em>Oberfl√§chenfunktion</em> (genannt <code>surf</code> ) unter Verwendung der integrierten <code>tex2D</code> Funktion <code>tex2D</code> . <br><br>  Tats√§chlich wird <code>tex2D</code> verwendet, um Pixel aus einer Textur <code>tex2D</code> , unabh√§ngig davon, was darin gespeichert ist, Farbe oder H√∂he.  M√∂glicherweise stellen Sie jedoch fest, dass <code>tex2D</code> nicht in einer Scheitelpunktfunktion verwendet werden kann. <br><br>  Der Grund ist, dass <code>tex2D</code> <em>nicht nur</em> Pixel aus der Textur liest.  Sie entscheidet auch, welche Version der Textur verwendet werden soll, abh√§ngig von der Entfernung zur Kamera.  Diese Technik wird als <strong>Mipmapping bezeichnet</strong> : Sie erm√∂glicht kleinere Versionen einer einzelnen Textur, die automatisch in unterschiedlichen Entfernungen verwendet werden k√∂nnen. <br><br>  In der Oberfl√§chenfunktion wei√ü der Shader bereits, welche <strong>MIP-Textur</strong> verwendet werden soll.  Diese Informationen sind m√∂glicherweise noch nicht in der Scheitelpunktfunktion verf√ºgbar, und daher kann <code>tex2D</code> nicht mit voller <code>tex2D</code> verwendet werden.  Im Gegensatz dazu kann der <code>tex2Dlod</code> Funktion zwei zus√§tzliche Parameter √ºbergeben werden, die in diesem Tutorial einen Nullwert haben k√∂nnen. <br><br>  Das Ergebnis ist in den folgenden Bildern deutlich sichtbar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a7/b64/0a6/5a7b640a60ca2ce42c9d4ee3f5c95150.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0b/dbf/dad/c0bdbfdadf38764dd3d75ffb69d07dea.png"></div><br>  In diesem Fall kann eine leichte Vereinfachung vorgenommen werden.  Der zuvor √ºberpr√ºfte Code kann mit jeder Geometrie verwendet werden.  Wir k√∂nnen jedoch davon ausgehen, dass die Oberfl√§che absolut flach ist.  Tats√§chlich m√∂chten wir diesen Effekt wirklich auf das Flugzeug anwenden. <br><br>  Daher k√∂nnen Sie <code>v.normal</code> entfernen und durch <code>float3(0, 1, 0)</code> ersetzen: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ float3 normal = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); fixed height = tex2Dlod(_HeightMap, float4(v.texcoord.xy, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)).r; vertex.xyz += normal * height * _Amount; }</code> </pre> <br>  Wir k√∂nnten dies tun, weil alle Koordinaten in <code>appdata_base</code> im <code>appdata_base</code> gespeichert sind, <code>appdata_base</code> sie werden relativ zum Zentrum und zur Ausrichtung des 3D-Modells festgelegt.  √úbergang, Drehung und Skalierung mit <em>Transformation</em> in Unity √§ndern Position, Drehung und Skalierung des Objekts, haben jedoch keinen Einfluss auf das urspr√ºngliche 3D-Modell. <br><br><h2>  Teil 2. Bildlaufeffekt </h2><br>  Alles, was wir oben gemacht haben, funktioniert ziemlich gut.  Bevor wir <code>getVertex</code> , extrahieren wir den Code, der zur Berechnung der neuen Scheitelpunkth√∂he erforderlich ist, in eine separate Funktion <code>getVertex</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getVertex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float4 vertex, float2 texcoord)</span></span></span><span class="hljs-function"> </span></span>{ float3 normal = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); fixed height = tex2Dlod(_HeightMap, float4(texcoord, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)).r; vertex.xyz += normal * height * _Amount; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vertex; }</code> </pre> <br>  Dann hat die gesamte Funktion <code>vert</code> die Form: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ vertex = getVertex(v.vertex, v.texcoord.xy); }</code> </pre> <br>  Wir haben dies getan, weil wir unten die H√∂he mehrerer Punkte berechnen m√ºssen.  Aufgrund der Tatsache, dass diese Funktionalit√§t in einer eigenen Funktion ausgef√ºhrt wird, wird der Code viel einfacher. <br><br><h2>  UV-Koordinatenberechnung </h2><br>  Dies f√ºhrt uns jedoch zu einem anderen Problem.  Die Funktion <code>getVertex</code> h√§ngt nicht nur von der Position des aktuellen Scheitelpunkts (v.vertex) ab, sondern auch von seinen UV-Koordinaten ( <code>v.texcoord</code> ). <br><br>  Wenn wir den Scheitelpunkth√∂henversatz berechnen m√∂chten, den die <code>vert</code> Funktion derzeit verarbeitet, sind beide Datenelemente in der Struktur <code>appdata_base</code> verf√ºgbar.  Was passiert jedoch, wenn wir die Position eines benachbarten Punkts abtasten m√ºssen?  In diesem Fall k√∂nnen wir die xyz-Position im <strong>Modellraum kennen</strong> , haben jedoch keinen Zugriff auf die UV-Koordinaten. <br><br>  Dies bedeutet, dass das vorhandene System den H√∂henversatz nur f√ºr den aktuellen Scheitelpunkt berechnen kann.  Eine solche Einschr√§nkung wird es uns nicht erm√∂glichen, weiterzumachen, daher m√ºssen wir eine L√∂sung finden. <br><br>  Am einfachsten ist es, die UV-Koordinaten eines 3D-Objekts zu berechnen und die Position seines Scheitelpunkts zu kennen.  Dies ist eine sehr schwierige Aufgabe, und es gibt verschiedene Techniken, um sie zu l√∂sen (eine der beliebtesten ist die <strong>triplanare Projektion</strong> ).  In diesem speziellen Fall m√ºssen wir UV jedoch nicht an die Geometrie anpassen.  Wenn wir davon ausgehen, dass der Shader immer auf das flache Netz angewendet wird, wird die Aufgabe trivial. <br><br>  Wir k√∂nnen <em>UV-Koordinaten</em> (unteres Bild) aus den <em>Positionen der Eckpunkte</em> (oberes Bild) berechnen, da beide linear auf einem flachen Netz √ºberlagert sind. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/147/614/a7a/147614a7a05ba08700aef85be89f3a53.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02f/ff8/c42/02fff8c42dae9fa7de4f7e9598843afe.png" width="359" height="210"></div><br>  Dies bedeutet, dass wir zur L√∂sung unseres Problems die <em>Komponenten XZ</em> <em>der Scheitelpunktposition</em> in die entsprechenden <em>UV-Koordinaten</em> umwandeln m√ºssen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48a/607/6b0/48a6076b06650e1074dd5b0f2f7ed023.png" width="363" height="393"></div><br>  Diese Prozedur wird als <strong>lineare Interpolation bezeichnet</strong> .  Es wird auf meiner Website ausf√ºhrlich besprochen (zum Beispiel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Die Geheimnisse der Farbinterpolation</a> ). <br><br>  In den meisten F√§llen liegen die UV-Werte im Bereich von <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>0</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMAIN-30" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>0</mn></math></span></span><script type="math/tex" id="MathJax-Element-1"> 0 </script>  vorher <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMAIN-31" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-2"> 1 </script>  ;;  Im Gegensatz dazu sind die Koordinaten jedes Scheitelpunkts m√∂glicherweise unbegrenzt.  Aus mathematischer Sicht ben√∂tigen wir f√ºr die Umstellung von XZ auf UV nur deren Grenzwerte: <br><br><ul><li><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>X</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.153ex" height="2.419ex" viewBox="0 -780.1 2218.6 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-58" x="0" y="0"></use><g transform="translate(828,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-69" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6E" x="1224" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>X</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-3"> X_ {min} </script>  , <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>X</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.409ex" height="2.419ex" viewBox="0 -780.1 2328.9 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-58" x="0" y="0"></use><g transform="translate(828,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-61" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-78" x="1408" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>X</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-4"> X_ {max} </script></li><li><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>Z</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.816ex" height="2.419ex" viewBox="0 -780.1 2073.6 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-5A" x="0" y="0"></use><g transform="translate(683,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-69" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6E" x="1224" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>Z</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-5"> Z_ {min} </script>  , <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>Z</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.072ex" height="2.419ex" viewBox="0 -780.1 2183.9 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-5A" x="0" y="0"></use><g transform="translate(683,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-61" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-78" x="1408" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>Z</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-6"> Z_ {max} </script></li><li><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>U</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.816ex" height="2.419ex" viewBox="0 -780.1 2073.6 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-55" x="0" y="0"></use><g transform="translate(683,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-69" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6E" x="1224" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>U</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-7"> U_ {min} </script>  , <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>U</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.072ex" height="2.419ex" viewBox="0 -780.1 2183.9 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-55" x="0" y="0"></use><g transform="translate(683,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-61" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-78" x="1408" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>U</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-8"> U_ {max} </script></li><li><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>V</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.584ex" height="2.419ex" viewBox="0 -780.1 1973.6 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-56" x="0" y="0"></use><g transform="translate(583,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-69" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6E" x="1224" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>V</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-9"> V_ {min} </script>  , <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>V</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.84ex" height="2.419ex" viewBox="0 -780.1 2083.9 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-56" x="0" y="0"></use><g transform="translate(583,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-61" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-78" x="1408" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>V</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-10"> V_ {max} </script></li></ul><br>  die unten gezeigt werden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87a/520/05c/87a52005ccc02b02403068fd3e075864.png" width="359" height="210"></div><br>  Diese Werte variieren je nach verwendetem Netz.  Auf der Unity-Ebene liegen die <em>UV-Koordinaten</em> im Bereich von <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>0</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMAIN-30" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>0</mn></math></span></span><script type="math/tex" id="MathJax-Element-11"> 0 </script>  vorher <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMAIN-31" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-12"> 1 </script>  und die <em>Koordinaten der Eckpunkte</em> liegen im Bereich von <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo>&amp;#x2212;</mo><mn>5</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.971ex" height="2.057ex" viewBox="0 -728.2 1279 885.9" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMAIN-2212" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMAIN-35" x="778" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo>‚àí</mo><mn>5</mn></math></span></span><script type="math/tex" id="MathJax-Element-13"> -5 </script>  vorher <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-14-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo>+</mo><mn>5</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.971ex" height="2.057ex" viewBox="0 -728.2 1279 885.9" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMAIN-2B" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMAIN-35" x="778" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo>+</mo><mn>5</mn></math></span></span><script type="math/tex" id="MathJax-Element-14"> + 5 </script>  . <br><br>  Die Gleichungen zur Umwandlung von XZ in UV sind: <br><br>  (1) <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d2/e5c/a22/7d2e5ca229d8fc1c135aaa42e863fc9c.svg" alt="Bild"></div><br><br><div class="spoiler">  <b class="spoiler_title">Wie werden sie angezeigt?</b> <div class="spoiler_text">  Wenn Sie mit dem Konzept der linearen Interpolation nicht vertraut sind, k√∂nnen diese Gleichungen ziemlich einsch√ºchternd wirken. <br><br>  Sie werden jedoch ganz einfach angezeigt.  Schauen wir uns nur ein Beispiel an. <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-15-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>U</mi></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.783ex" height="2.074ex" viewBox="0 -772.3 767.5 892.8" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-55" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>U</mi></math></span></span><script type="math/tex" id="MathJax-Element-15"> U </script>  .  Wir haben zwei Intervalle: eines hat Werte von <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-16-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>X</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.153ex" height="2.349ex" viewBox="0 -772.3 2218.6 1011.3" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.555ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-58" x="0" y="0"></use><g transform="translate(828,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-69" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6E" x="1224" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>X</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-16"> X_ {min} </script>  vorher <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-17-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>X</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.409ex" height="2.349ex" viewBox="0 -772.3 2328.9 1011.3" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.555ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-58" x="0" y="0"></use><g transform="translate(828,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-61" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-78" x="1408" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>X</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-17"> X_ {max} </script>  ein anderer aus <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-18-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>U</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.816ex" height="2.349ex" viewBox="0 -772.3 2073.6 1011.3" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.555ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-55" x="0" y="0"></use><g transform="translate(683,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-69" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6E" x="1224" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>U</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-18"> U_ {min} </script>  vorher <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-19-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>U</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.072ex" height="2.349ex" viewBox="0 -772.3 2183.9 1011.3" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.555ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-55" x="0" y="0"></use><g transform="translate(683,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-61" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-78" x="1408" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>U</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-19"> U_ {max} </script>  .  Eingehende Daten f√ºr die Koordinate <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-20-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>X</mi></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.98ex" height="2.074ex" viewBox="0 -772.3 852.5 892.8" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-58" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>X</mi></math></span></span><script type="math/tex" id="MathJax-Element-20"> X </script>  ist die Koordinate des aktuellen Scheitelpunkts, der verarbeitet wird, und die Ausgabe ist die Koordinate <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-21-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>U</mi></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.783ex" height="2.074ex" viewBox="0 -772.3 767.5 892.8" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-55" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>U</mi></math></span></span><script type="math/tex" id="MathJax-Element-21"> U </script>  wird verwendet, um die Textur abzutasten. <br><br>  Wir m√ºssen die Eigenschaften der Proportionalit√§t zwischen beibehalten <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-22-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>X</mi></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.98ex" height="2.074ex" viewBox="0 -772.3 852.5 892.8" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-58" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>X</mi></math></span></span><script type="math/tex" id="MathJax-Element-22"> X </script>  und sein Intervall und <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-23-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>U</mi></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.783ex" height="2.074ex" viewBox="0 -772.3 767.5 892.8" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-55" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>U</mi></math></span></span><script type="math/tex" id="MathJax-Element-23"> U </script>  und sein Intervall.  Zum Beispiel wenn <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-24-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>X</mi></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.98ex" height="2.074ex" viewBox="0 -772.3 852.5 892.8" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-58" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>X</mi></math></span></span><script type="math/tex" id="MathJax-Element-24"> X </script>  z√§hlt dann 25% seines Intervalls <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-25-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>U</mi></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.783ex" height="2.074ex" viewBox="0 -772.3 767.5 892.8" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-55" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>U</mi></math></span></span><script type="math/tex" id="MathJax-Element-25"> U </script>  wird auch 25% seines Intervalls ausmachen. <br><br>  All dies ist in der folgenden Abbildung dargestellt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22a/784/da1/22a784da18e327b20b872699a901f0ec.png" width="292" height="202"></div><br>  Daraus k√∂nnen wir schlie√üen, dass der Anteil des roten Segments in Bezug auf das Rosa dem Anteil zwischen dem blauen Segment und dem blauen Segment entsprechen sollte: <br><br>  (2) <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bcc/9e1/49e/bcc9e149ea65e83dd70345dd92784788.png" height="39" width="232"></div><br>  Jetzt k√∂nnen wir die oben gezeigte Gleichung transformieren, um zu erhalten <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-26-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>U</mi></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.783ex" height="2.074ex" viewBox="0 -772.3 767.5 892.8" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-55" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>U</mi></math></span></span><script type="math/tex" id="MathJax-Element-26"> U </script>  :: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/737/266/0fe/7372660fe877b0780e4cebc97a6f22f2.png" height="85" width="388"></div><br>  und diese Gleichung hat genau die gleiche Form wie oben gezeigt (1). </div></div><br>  Diese Gleichungen k√∂nnen wie folgt im Code implementiert werden: <br><br><pre> <code class="cpp hljs">float2 _VertexMin; float2 _VertexMax; float2 _UVMin; float2 _UVMax; <span class="hljs-function"><span class="hljs-function">float2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vertexToUV</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float4 vertex)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (vertex.xz - _VertexMin) / (_VertexMax - _VertexMin) * (_UVMax - _UVMin) + _UVMin; }</code> </pre> <br>  Jetzt k√∂nnen wir die Funktion <code>getVertex</code> , ohne <code>v.texcoord</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getVertex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float4 vertex)</span></span></span><span class="hljs-function"> </span></span>{ float3 normal = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); float2 texcoord = vertexToUV(vertex); fixed height = tex2Dlod(_HeightMap, float4(texcoord, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)).r; vertex.xyz += normal * height * _Amount; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vertex; }</code> </pre> <br>  Dann nimmt die gesamte Funktion <code>vert</code> die Form an: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ v.vertex = getVertex(v.vertex); }</code> </pre> <br><h3>  Bildlaufeffekt </h3><br>  Dank des von uns geschriebenen Codes wird die gesamte Karte auf dem Netz angezeigt.  Wenn wir die Anzeige verbessern wollen, m√ºssen wir √Ñnderungen vornehmen. <br><br>  Lassen Sie uns den Code etwas formalisieren.  Erstens m√ºssen wir m√∂glicherweise einen separaten Teil der Karte vergr√∂√üern, anstatt ihn als Ganzes zu betrachten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b5/1c3/bcd/0b51c3bcd59365527d3659564768b01b.png" width="530" height="309"></div><br>  Dieser Bereich kann durch zwei Werte definiert werden: seine Gr√∂√üe ( <code>_CropSize</code> ) und seine Position auf der Karte ( <code>_CropOffset</code> ), gemessen im <em>Scheitelpunktraum</em> (von <code>_VertexMin</code> bis <code>_VertexMax</code> ). <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Cropping float2 _CropSize; float2 _CropOffset;</span></span></code> </pre> <br>  Nachdem wir diese beiden Werte erhalten haben, k√∂nnen wir wieder die lineare Interpolation verwenden, sodass <code>getVertex</code> nicht f√ºr die aktuelle Position der Oberseite des 3D-Modells <code>getVertex</code> , sondern f√ºr den skalierten und √ºbertragenen Punkt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0c/620/418/c0c620418088c383addcaa54328fe0fc.png" width="529" height="589"></div><br>  Relevanter Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ float2 croppedMin = _CropOffset; float2 croppedMax = croppedMin + _CropSize; <span class="hljs-comment"><span class="hljs-comment">// v.vertex.xz: [_VertexMin, _VertexMax] // cropped.xz : [croppedMin, croppedMax] float4 cropped = v.vertex; cropped.xz = (v.vertex.xz - _VertexMin) / (_VertexMax - _VertexMin) * (croppedMax - croppedMin) + croppedMin; v.vertex.y = getVertex(cropped); }</span></span></code> </pre> <br>  Wenn wir scrollen m√∂chten, reicht es aus, <code>_CropOffset</code> √ºber das Skript zu aktualisieren.  Aus diesem Grund wird der K√ºrzungsbereich verschoben und tats√§chlich durch die Landschaft gescrollt. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MoveMap</span></span></span><span class="hljs-class"> :</span></span> MonoBehaviour { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Material Material; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 Speed; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 Offset; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CropOffsetID; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ CropOffsetID = Shader.PropertyToID(<span class="hljs-string"><span class="hljs-string">"_CropOffset"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Material.SetVector(CropOffsetID, Speed * Time.time + Offset); } }</code> </pre> <br>  Damit dies funktioniert, ist es sehr wichtig, den <strong>Umbruchmodus</strong> aller Texturen auf <strong>Wiederholen</strong> einzustellen.  Wenn dies nicht getan wird, k√∂nnen wir die Textur nicht schleifen. <br><br>  F√ºr den Zoom / Zoom-Effekt reicht es aus, nur <code>_CropSize</code> √§ndern. <br><br><h2>  Teil 3. Gel√§ndeschattierung </h2><br><h2>  Flache Schattierung </h2><br>  Der gesamte Code, den wir geschrieben haben, funktioniert, hat aber ein ernstes Problem.  Das Modell zu beschatten ist irgendwie seltsam.  Die Oberfl√§che ist richtig gekr√ºmmt, reagiert aber auf Licht, als w√§re es flach. <br><br>  Dies ist in den folgenden Bildern sehr deutlich zu sehen.  Das obere Bild zeigt einen vorhandenen Shader.  Der untere Teil zeigt, wie es tats√§chlich funktioniert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0b/dbf/dad/c0bdbfdadf38764dd3d75ffb69d07dea.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/511/6a1/e02/5116a1e02debfaa58afe0cddf3b4c6c9.png"></div><br>  Die L√∂sung dieses Problems kann eine gro√üe Herausforderung sein.  Aber zuerst m√ºssen wir herausfinden, was der Fehler ist. <br><br>  Der normale Extrusionsvorgang hat die allgemeine Geometrie der urspr√ºnglich verwendeten Ebene ge√§ndert.  Unity hat jedoch nur die Position der Scheitelpunkte ge√§ndert, nicht jedoch ihre normalen Richtungen.  <strong>Die Richtung der</strong> Scheitelpunktnormalen ist, wie der Name schon sagt, ein Einheitsl√§ngenvektor ( <em>Richtung</em> ), der senkrecht zur Oberfl√§che anzeigt.  <em>Normalen sind</em> notwendig, weil sie eine wichtige Rolle bei der Schattierung eines 3D-Modells spielen.  Sie werden von allen Oberfl√§chen-Shadern verwendet, um zu berechnen, wie Licht von jedem Dreieck des 3D-Modells reflektiert werden soll.  Normalerweise ist dies notwendig, um die Dreidimensionalit√§t des Modells zu verbessern. Beispielsweise wird Licht von einer ebenen Oberfl√§che reflektiert, genau wie es von einer gekr√ºmmten Oberfl√§che reflektiert wird.  Dieser Trick wird h√§ufig verwendet, um Low-Poly-Oberfl√§chen glatter aussehen zu lassen als sie tats√§chlich sind (siehe unten). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f6b/d7c/443/f6bd7c443381c1f0e133ee7b7bce05e1.png"></div><br>  In unserem Fall passiert jedoch das Gegenteil.  Die Geometrie ist gekr√ºmmt und glatt, aber da alle Normalen nach oben gerichtet sind, wird das Licht vom Modell reflektiert, als w√§re es flach (siehe unten): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/323/241/cde/323241cdef1b3a41604c579f4fdb509b.png"></div><br>  Weitere Informationen zur Rolle von Normalen bei der Objektschattierung finden Sie im Artikel √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Normal Mapping (Bump Mapping)</a> , in dem identische Zylinder trotz des gleichen 3D-Modells aufgrund unterschiedlicher Methoden zur Berechnung von Scheitelpunktnormalen sehr unterschiedlich aussehen (siehe unten). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b7/4fc/15f/1b74fc15f90516cc80b283953ef12373.png" width="315" height="243"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f93/544/d9c/f93544d9c95a70da71848897f0913676.png" width="347" height="254"></div><br>  Leider verf√ºgen weder Unity noch die Sprache zum Erstellen von Shadern √ºber eine integrierte L√∂sung zum automatischen Neuberechnen von Normalen.  Dies bedeutet, dass Sie sie abh√§ngig von der lokalen Geometrie des 3D-Modells manuell √§ndern m√ºssen. <br><br><h2>  Normale Berechnung </h2><br>  Die einzige M√∂glichkeit, das Schattierungsproblem zu beheben, besteht darin, die Normalen basierend auf der Oberfl√§chengeometrie manuell zu berechnen.  Eine √§hnliche Aufgabe wurde in einem Beitrag von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Vertex Displacement - Melting Shader Part 1</a> besprochen, in dem das Schmelzen von 3D-Modellen in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Cone Wars</a> simuliert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">wurde</a> . <br><br>  Obwohl der fertige Code in 3D-Koordinaten arbeiten muss, beschr√§nken wir die Aufgabe vorerst auf nur zwei Dimensionen.  Stellen Sie sich vor, Sie m√ºssen die <strong>Richtung der Normalen</strong> berechnen, die dem Punkt auf der 2D-Kurve entspricht (der gro√üe blaue Pfeil im folgenden Diagramm). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5a/405/6be/e5a4056be62b920d9721a84d7c050ee6.png" width="316" height="346"></div><br>  Aus geometrischer Sicht ist die <em>Richtung der Normalen</em> (gro√üer blauer Pfeil) ein Vektor senkrecht zu der <strong>Tangente,</strong> die durch den f√ºr uns interessanten Punkt verl√§uft (eine d√ºnne blaue Linie).  <em>Die Tangente</em> kann als Linie dargestellt werden, die sich auf der Kr√ºmmung des Modells befindet.  <strong>Ein Tangentenvektor</strong> ist ein <em>Einheitsvektor</em> , der auf einer Tangente liegt. <br><br>  Dies bedeutet, dass Sie zur Berechnung der Normalen zwei Schritte ausf√ºhren m√ºssen: Suchen Sie zuerst die <em>Tangente</em> an den gew√ºnschten Punkt.  Berechnen Sie dann den Vektor senkrecht dazu (dies ist die notwendige <em>Richtung der Normalen</em> ). <br><br><h3>  Tangentenberechnung </h3><br>  Um die <em>Normalit√§t zu erhalten, m√ºssen</em> wir zuerst die <em>Tangente</em> berechnen.  Sie kann angen√§hert werden, indem ein Punkt in der N√§he abgetastet und daraus eine Linie in der N√§he des Scheitelpunkts erstellt wird.  Je kleiner die Linie, desto genauer ist der Wert. <br><br>  Drei Schritte sind erforderlich: <br><br><ul><li>  Stufe 1. Bewegen Sie eine kleine Menge auf einer ebenen Fl√§che </li><li>  Schritt 2. Berechnen Sie die H√∂he des neuen Punktes. </li><li>  Schritt 3. Verwenden Sie die H√∂he des aktuellen Punkts, um die Tangente zu berechnen </li></ul><br>  All dies ist im Bild unten zu sehen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/46f/bd3/7e8/46fbd37e868d16ff7ec6f1a164377018.png"></div><br>  Damit dies funktioniert, m√ºssen wir die H√∂he von zwei Punkten berechnen, nicht von einem.  Zum Gl√ºck wissen wir bereits, wie das geht.  Im vorherigen Teil des Tutorials haben wir eine Funktion erstellt, die die H√∂he einer Landschaft basierend auf einem Netzpunkt abtastet.  Wir haben es <code>getVertex</code> . <br><br>  Wir k√∂nnen den neuen Scheitelpunktwert am aktuellen Punkt und dann an zwei anderen nehmen.  Einer ist f√ºr die Tangente, der andere f√ºr die Tangente an zwei Punkten.  Mit ihrer Hilfe bekommen wir das Normale.  Wenn das urspr√ºngliche Netz, mit dem der Effekt erstellt wurde, flach ist (und in unserem Fall auch), ben√∂tigen wir keinen Zugriff auf <code>v.normal</code> und k√∂nnen einfach <code>float3(0, 0, 1)</code> f√ºr Tangente bzw. Tangente an zwei Punkte <code>float3(0, 0, 1)</code> und <code>float3(1, 0, 0)</code> .  Wenn wir dasselbe tun wollten, aber zum Beispiel f√ºr eine Kugel, w√§re es viel schwieriger, zwei geeignete Punkte f√ºr die Berechnung der Tangente und der Tangente an zwei Punkte zu finden. <br><br><h3>  Vektorgrafiken </h3><br>  Nachdem wir die geeigneten Tangenten- und Tangentenvektoren f√ºr zwei Punkte erhalten haben, k√∂nnen wir die Normalen unter Verwendung einer Operation berechnen, die als <strong>Vektorprodukt bezeichnet wird</strong> .  Es gibt viele Definitionen und Erkl√§rungen f√ºr eine Vektorarbeit und deren Funktionsweise. <br><br>  Ein Vektorprodukt empf√§ngt zwei Vektoren und gibt einen neuen zur√ºck.  Wenn zwei Anfangsvektoren Einheit waren (ihre L√§nge ist gleich Eins) und sie sich in einem Winkel von 90 befinden, befindet sich der resultierende Vektor bei 90 Grad relativ zu beiden. <br><br>  Dies kann zun√§chst verwirrend sein, kann jedoch grafisch wie folgt dargestellt werden: Das Vektorprodukt zweier Achsen erzeugt eine dritte.  Also <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-27-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>X</mi><mtext>&amp;#xA0;</mtext><mi>m</mi><mi>a</mi><mi>l</mi><mi>Y</mi><mo>=</mo><mi>Z</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="13.076ex" height="2.057ex" viewBox="0 -780.1 5630.1 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-58" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6D" x="1102" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-61" x="1981" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6C" x="2510" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-59" x="2809" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMAIN-3D" x="3850" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-5A" x="4906" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>X</mi><mtext>&nbsp;</mtext><mi>m</mi><mi>a</mi><mi>l</mi><mi>Y</mi><mo>=</mo><mi>Z</mi></math></span></span><script type="math/tex" id="MathJax-Element-27"> X \ mal Y = Z </script>  aber auch <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-28-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>X</mi><mtext>&amp;#xA0;</mtext><mi>m</mi><mi>a</mi><mi>l</mi><mi>Z</mi><mo>=</mo><mi>Y</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="13.076ex" height="2.057ex" viewBox="0 -780.1 5630.1 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-58" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6D" x="1102" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-61" x="1981" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-6C" x="2510" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-5A" x="2809" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMAIN-3D" x="3810" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjFM0283Ru4ydX2LL8gxPwS1GXxTg#MJMATHI-59" x="4866" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>X</mi><mtext>&nbsp;</mtext><mi>m</mi><mi>a</mi><mi>l</mi><mi>Z</mi><mo>=</mo><mi>Y</mi></math></span></span><script type="math/tex" id="MathJax-Element-28"> X \ mal Z = Y </script>  , usw. <br><br>  Wenn wir einen ausreichend kleinen Schritt machen (im Code ist dies <code>offset</code> ), befinden sich die Vektoren der Tangente und der Tangente an zwei Punkte in einem Winkel von 90 Grad.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammen mit dem Normalenvektor bilden sie drei senkrechte Achsen, die entlang der Oberfl√§che des Modells ausgerichtet sind. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir das wissen, k√∂nnen wir den gesamten notwendigen Code schreiben, um den normalen Vektor zu berechnen und zu aktualisieren.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ float3 bitangent = float3(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); float3 tangent = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> offset = <span class="hljs-number"><span class="hljs-number">0.01</span></span>; float4 vertexBitangent = getVertex(v.vertex + float4(bitangent * offset, <span class="hljs-number"><span class="hljs-number">0</span></span>) ); float4 vertex = getVertex(v.vertex); float4 vertexTangent = getVertex(v.vertex + float4(tangent * offset, <span class="hljs-number"><span class="hljs-number">0</span></span>) ); float3 newBitangent = (vertexBitangent - vertex).xyz; float3 newTangent = (vertexTangent - vertex).xyz; v.normal = cross(newTangent, newBitangent); v.vertex.y = vertex.y; }</code> </pre> <br><h3>  Alles zusammenf√ºgen </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt, da alles funktioniert, k√∂nnen wir den Scroll-Effekt zur√ºckgeben. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// v.vertex.xz: [_VertexMin, _VertexMax] // cropped.xz : [croppedMin, croppedMax] float2 croppedMin = _CropOffset; float2 croppedMax = croppedMin + _CropSize; float4 cropped = v.vertex; cropped.xz = (v.vertex.xz - _VertexMin) / (_VertexMax - _VertexMin) * (croppedMax - croppedMin) + croppedMin; float3 bitangent = float3(1, 0, 0); float3 normal = float3(0, 1, 0); float3 tangent = float3(0, 0, 1); float offset = 0.01; float4 vertexBitangent = getVertex(cropped + float4(bitangent * offset, 0) ); float4 vertex = getVertex(cropped); float4 vertexTangent = getVertex(cropped + float4(tangent * offset, 0) ); float3 newBitangent = (vertexBitangent - vertex).xyz; float3 newTangent = (vertexTangent - vertex).xyz; v.normal = cross(newTangent, newBitangent); v.vertex.y = vertex.y; v.texcoord = float4(vertexToUV(cropped), 0,0); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und damit ist unser Effekt endlich abgeschlossen. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d9/b07/680/0d9b0768068b2329d53e22a71ff27dfb.gif" width="700" height="272"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wohin als n√§chstes gehen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieses Tutorial kann zur Grundlage f√ºr komplexere Effekte werden, beispielsweise f√ºr holographische Projektionen oder sogar f√ºr eine Kopie des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sandtisches</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aus dem Film "Black Panther".</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ecS1_-Y_uP8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Einheitspaket </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das vollst√§ndige Paket f√ºr dieses Tutorial kann auf </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patreon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> heruntergeladen </font><font style="vertical-align: inherit;">werden. Es enth√§lt alle </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener"><font style="vertical-align: inherit;">Elemente</font></a><font style="vertical-align: inherit;"> , die zum Spielen des beschriebenen Effekts erforderlich sind.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462153/">https://habr.com/ru/post/de462153/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462141/index.html">Wagen f√ºr ein Rechenzentrum</a></li>
<li><a href="../de462145/index.html">Warum dauert das Abbestellen mehrere Tage?</a></li>
<li><a href="../de462147/index.html">Arbeiten mit der Navigation beim Refactoring eines Projekterbes in React Native</a></li>
<li><a href="../de462149/index.html">Zugriffsbeschr√§nkungsmodus f√ºr Zubeh√∂r auf iOS-Ger√§ten und deren Umgehung</a></li>
<li><a href="../de462151/index.html">5 Top-Kubernetes-Distributionen</a></li>
<li><a href="../de462155/index.html">Arbeiten Sie mit Worker "wie Sie m√∂chten", nicht "so viel wie m√∂glich".</a></li>
<li><a href="../de462159/index.html">Aufbau eines Gesichtserkennungssystems basierend auf Golang und OpenCV</a></li>
<li><a href="../de462161/index.html">Erleben Sie die Installation von Apache Airflow unter Windows 10</a></li>
<li><a href="../de462163/index.html">Technologien, die 2020 popul√§r sein werden</a></li>
<li><a href="../de462165/index.html">Wie 25 Leute dazu gebracht wurden, f√ºr eine nicht existierende Spielefirma zu arbeiten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>