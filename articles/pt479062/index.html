<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèø‚Äçü§ù‚Äçüßëüèª üë©üèø‚Äçü§ù‚Äçüë©üèΩ üßò Multithreading em Node.js. Loop de eventos ‚è≤Ô∏è üî• üõèÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Infa ser√° √∫til para desenvolvedores de JS que desejam entender profundamente a ess√™ncia de trabalhar com Node.js e Event Loop. Voc√™ pode controlar de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Multithreading em Node.js. Loop de eventos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479062/"><p>  Infa ser√° √∫til para desenvolvedores de JS que desejam entender profundamente a ess√™ncia de trabalhar com Node.js e Event Loop.  Voc√™ pode controlar de forma consciente e flex√≠vel o fluxo do programa (servidor da web). </p><br><p>  Compilei este artigo com base no meu relat√≥rio recente para colegas. <br>  No final do artigo, existem materiais √∫teis para estudo independente. </p><br><h3 id="kak-ustroena-nodejs-vozmozhnosti-asinhrona">  Como √© o Node.js.  Recursos ass√≠ncronos </h3><br><p>  Vejamos este c√≥digo: ele demonstra perfeitamente a sincroniza√ß√£o da execu√ß√£o do c√≥digo no Node.js.  Uma solicita√ß√£o √© feita em algum lugar no GitHub, em seguida, um arquivo √© lido e o resultado √© exibido no console.  O que est√° claro nesse c√≥digo s√≠ncrono? </p><br><p><img src="https://static.tildacdn.com/tild6636-3136-4462-b130-323161353738/1.png" alt="imagem"></p><a name="habracut"></a><br><p>  Suponha que este seja um servidor da web abstrato que execute opera√ß√µes em um roteador.  Se uma solicita√ß√£o de entrada chegar neste roteador, solicitamos mais, lemos o arquivo e o imprimimos no console.  Consequentemente, o tempo gasto em solicitar e ler um arquivo, o servidor ser√° bloqueado, n√£o poder√° processar outras solicita√ß√µes de entrada nem realizar√° outras opera√ß√µes. </p><br><p>  Quais s√£o as op√ß√µes para resolver este problema? </p><br><ol><li>  Multithreading </li><li>  E / S sem bloqueio </li></ol><br><p>  Para a primeira op√ß√£o (multithreading), h√° um bom exemplo com o servidor da web Apache vs Nginx. </p><br><p><img src="https://static.tildacdn.com/tild3135-6363-4633-b064-633962376236/2.png" alt="imagem"></p><br><p>  Anteriormente, o Apache gerava um fluxo para cada solicita√ß√£o recebida: quantas solicita√ß√µes havia, o mesmo n√∫mero de threads.  No momento, o Nginx tinha a vantagem de usar E / S sem bloqueio.  Aqui voc√™ pode ver que, com um aumento no n√∫mero de solicita√ß√µes recebidas, a quantidade de mem√≥ria consumida pelo Apache aumenta e, no pr√≥ximo slide, o n√∫mero de solicita√ß√µes processadas por segundo com o n√∫mero de conex√µes para o Nginx √© maior. </p><br><p><img src="https://static.tildacdn.com/tild3661-3539-4965-a435-393731333863/3.png" alt="imagem"></p><br><p>  <strong>√â claramente mostrado que a entrada / sa√≠da sem bloqueio √© mais eficiente.</strong> </p><br><p>  A entrada / sa√≠da sem bloqueio √© poss√≠vel gra√ßas aos sistemas operacionais modernos que fornecem esse mecanismo - um desmultiplexador de eventos. </p><br><p>  Um desmultiplexador √© um mecanismo que recebe uma solicita√ß√£o de um aplicativo, registra e executa. </p><br><p><img src="https://static.tildacdn.com/tild3239-6537-4639-b262-303866363230/4.png" alt="imagem"></p><br><p>  Na parte superior do diagrama, √© visto que temos um aplicativo e as opera√ß√µes s√£o executadas nele (seja lendo um arquivo).  Para isso, √© feita uma solicita√ß√£o ao desmultiplexador de eventos, um recurso √© enviado aqui (link para o arquivo), a opera√ß√£o desejada e o retorno de chamada.  O desmultiplexador de eventos registra essa solicita√ß√£o e retorna o controle diretamente ao aplicativo - portanto, n√£o √© bloqueado.  Em seguida, ele executa opera√ß√µes no arquivo e, depois disso, quando o arquivo √© lido, o retorno de chamada √© registrado na fila de execu√ß√£o.  Em seguida, o loop de eventos processa gradualmente de forma s√≠ncrona cada retorno de chamada dessa fila.  E, consequentemente, retorna o resultado ao aplicativo.  Al√©m disso (se necess√°rio), tudo √© feito novamente. </p><br><p>  <strong>Assim, gra√ßas a essa E / S sem bloqueio, o Node.js pode ser ass√≠ncrono.</strong> <strong><br></strong> </p><br><p>  Esclarecemos que, nesse caso, √© o sistema operacional que nos fornece entrada / sa√≠da sem bloqueio.  Para entrada / sa√≠da sem bloqueio (geralmente, em princ√≠pio, para opera√ß√µes de entrada / sa√≠da), inclu√≠mos solicita√ß√µes de rede e trabalhamos com arquivos. </p><br><p>  Esse √© o conceito geral de E / S sem bloqueio.  Quando surgiu a oportunidade, Ryan Dahl, desenvolvedor do Node.js., foi inspirado pela experi√™ncia do Nginx, que usava E / S sem bloqueio, e decidiu criar uma plataforma espec√≠fica para desenvolvedores.  A primeira coisa que ele precisava fazer era "fazer amigos" em sua plataforma com um desmultiplexador de eventos.  O problema era que o desmultiplexador era implementado de maneira diferente em cada sistema operacional e ele precisava escrever um wrapper, que mais tarde ficou conhecido como libuv.  Esta √© uma biblioteca escrita em C. Ele fornece uma interface √∫nica para trabalhar com esses desmultiplexadores de eventos. </p><br><h3 id="osobennosti-libuv-biblioteki">  Recursos da biblioteca Libuv </h3><br><p><img src="https://static.tildacdn.com/tild3165-6435-4730-b264-616531326535/5.png" alt="imagem"></p><br><p>  No Linux, em princ√≠pio, no momento, todas as opera√ß√µes com arquivos locais est√£o bloqueando.  Ou seja, parece que h√° entrada / sa√≠da sem bloqueio, mas √© precisamente ao trabalhar com arquivos locais que a opera√ß√£o ainda est√° bloqueando.  √â por isso que o libuv usa threads internamente para emular E / S sem bloqueio.  Quatro threads surgem da caixa e aqui precisamos tirar a conclus√£o mais importante: se executarmos 4 opera√ß√µes pesadas em arquivos locais, bloquearemos todo o aplicativo (√© no Linux, outros sistemas operacionais n√£o). </p><br><p><img src="https://static.tildacdn.com/tild3639-3865-4765-b565-636136653938/6.png" alt="imagem"></p><br><p>  Neste slide, vemos a arquitetura do Node.js.  Para interagir com o sistema operacional, a biblioteca libuv escrita em C √© usada;  Para compilar o c√≥digo JavaScript no c√≥digo da m√°quina, √© usado o mecanismo do Google V8, h√° tamb√©m uma biblioteca Node.jb Core, que cont√©m m√≥dulos para trabalhar com solicita√ß√µes de rede, um sistema de arquivos e um m√≥dulo para registro.  Que tudo isso interagiu, as Liga√ß√µes do Node.js s√£o gravadas.  Esses 4 componentes comp√µem a estrutura do Node.js.  O pr√≥prio mecanismo de loop de eventos est√° em libuv. </p><br><h3 id="event-loop">  Loop de eventos </h3><br><p><img src="https://static.tildacdn.com/tild6133-3435-4334-b037-623736653761/7.png" alt="imagem"></p><br><p>  Esta √© a representa√ß√£o mais simples da apar√™ncia do Event Loop.  H√° uma certa fila de eventos, h√° um ciclo intermin√°vel de eventos que executa opera√ß√µes de forma s√≠ncrona a partir da fila e as distribui ainda mais. </p><br><p>  <strong>Este slide mostra como o Loop de Eventos fica diretamente no Node.js.</strong> <br><img src="https://static.tildacdn.com/tild6535-3966-4634-a537-636236373930/9.png" alt="imagem"></p><br><p>  L√°, a implementa√ß√£o √© mais interessante e mais complicada.  Essencialmente, um loop de eventos √© um loop de eventos e √© infinito desde que haja algo a ser feito.  O loop de eventos no Node.js √© dividido em v√°rias fases.  (As fases do slide 8 devem ser comparadas com o c√≥digo-fonte do slide 9.) </p><br><p><img src="https://static.tildacdn.com/tild3639-6230-4232-b634-396363303036/10.png" alt="imagem"></p><br><h4 id="1-faza--taymery">  Fase 1 - Temporizadores </h4><br><p>  Essa fase √© realizada diretamente pelo Event Loop.  (Trecho de c√≥digo com uv_update_time) - aqui o hor√°rio em que o loop de eventos come√ßou a funcionar √© simplesmente atualizado. </p><br><p>  uv_run_timers - nesse m√©todo, a pr√≥xima a√ß√£o do timer √© executada.  H√° uma certa pilha, mais precisamente, um monte de cron√¥metros, que √© essencialmente o mesmo da fila em que os cron√¥metros est√£o localizados.  O cron√¥metro com o menor tempo √© obtido, comparado com o hor√°rio atual do loop de eventos e, se estiver na hora de executar esse cron√¥metro, seu retorno de chamada √© executado.  Vale a pena notar aqui que o Node.js possui uma implementa√ß√£o de setTimeout e existe setInterval.  Para libuv, isso √© essencialmente a mesma coisa, apenas setInterval ainda tem um sinalizador de repeti√ß√£o. </p><br><p>  <strong>Portanto, se esse cron√¥metro tiver um sinalizador de repeti√ß√£o, ele ser√° novamente colocado na fila de eventos e processado da mesma maneira.</strong> </p><br><h3 id="2-faza--io-callbacki">  Fase 2 - retornos de chamada de E / S </h3><br><p>  Aqui, precisamos retornar ao diagrama sobre entrada / sa√≠da sem bloqueio. </p><br><p>  Quando o desmultiplexador de eventos l√™ um arquivo e coloca na fila o retorno de chamada, ele apenas corresponde ao est√°gio de retorno de chamada de E / S.  Aqui, os retornos de chamada s√£o realizados para entrada / sa√≠da sem bloqueio, ou seja, essas s√£o exatamente as fun√ß√µes usadas ap√≥s uma solicita√ß√£o para um banco de dados ou outro recurso ou para ler / gravar um arquivo.  Eles s√£o realizados precisamente nesta fase. </p><br><p>  <strong>No slide 9, a execu√ß√£o da fun√ß√£o de retorno de chamada de E / S inicia a linha 367: ran_pending = uv_run_pending (loop).</strong> <strong><br></strong> </p><br><h3 id="3-faza--ozhidanie-podgotovka">  Fase 3 - espera, prepara√ß√£o </h3><br><p>  Essas s√£o opera√ß√µes internas para retornos de chamada, de fato, n√£o podemos influenciar a fase, apenas indiretamente.  Existe um processo.nextTick, seu retorno de chamada pode ser inadvertidamente executado na fase de prepara√ß√£o em espera.  process.nextTick √© executado na fase atual, ou seja, process.nextTick pode funcionar em absolutamente qualquer fase.  N√£o h√° ferramenta pronta para executar o c√≥digo na fase "aguardando, preparando" no Node.js. </p><br><p>  No slide 9, as linhas 368, 369 correspondem a esta fase: <br>  uv_run_idle (loop) - aguarde; <br>  uv_run_prepare (loop) - prepara√ß√£o. </p><br><h4 id="4-faza--opros">  Fase 4 - pesquisa </h4><br><p>  √â aqui que todo o c√≥digo que escrevemos em JS √© executado.  Inicialmente, todas as solicita√ß√µes que fazemos chegam aqui e √© aqui que o Node.js pode ser bloqueado.  Se qualquer opera√ß√£o de computa√ß√£o pesada chegar aqui, nesse est√°gio, nosso aplicativo poder√° congelar e aguardar at√© que essa opera√ß√£o seja conclu√≠da. <br>  <strong>No slide 9, a fun√ß√£o de pesquisa est√° na linha 370: uv_io_poll (loop, timeout).</strong> </p><br><h4 id="5-faza--proverka">  5 fase - verifica√ß√£o </h4><br><p>  H√° um timer setImmediate no Node.js, seus retornos de chamada s√£o executados nesta fase. <br>  <strong>No c√≥digo fonte, esta √© a linha 371: uv_run_check (loop).</strong> </p><br><h4 id="6-faza-poslednyaya--callbacki-sobytiy-close">  6 fases (√∫ltima) - eventos de retorno de chamada fechados </h4><br><p>  Por exemplo, um soquete da web precisa fechar a conex√£o; nessa fase, um retorno de chamada desse evento ser√° chamado. </p><br><p>  <strong>No c√≥digo fonte, esta √© a linha 372: uv_run_closing_handless (loop).</strong> </p><br><h3 id="i-v-itoge-event-loop-nodejs-vyglyadit-sleduyuschim-obrazom">  E, no final, o Event Loop Node.js √© o seguinte </h3><br><p><img src="https://static.tildacdn.com/tild6335-6631-4561-b732-376633616531/11.png" alt="imagem"></p><br><p>  Primeiro, na fila do cron√¥metro, o cron√¥metro √© executado, cujo per√≠odo se aproxima. </p><br><p>  Em seguida, os retornos de chamada de E / S s√£o executados. </p><br><p>  Em seguida, o c√≥digo √© a base, depois setImmediate e os eventos de fechamento. </p><br><p>  Depois disso, tudo se repete em um c√≠rculo.  Para demonstrar isso, vou abrir o c√≥digo.  Como ser√° realizado? </p><br><p><img src="https://static.tildacdn.com/tild6638-6163-4936-b032-633536393237/12.png" alt="imagem"></p><br><p>  Como n√£o temos temporizadores na linha, o loop de eventos continua.  Tamb√©m n√£o h√° retorno de chamada de E / S, portanto, imediatamente entramos na fase de pesquisa.  Todo o c√≥digo que est√° aqui √© executado inicialmente na fase de pesquisa.  Portanto, primeiro imprimimos script_start, setInterval √© colocado na fila do timer (n√£o executado, apenas colocado).  setTimeout tamb√©m √© colocado na fila do cron√¥metro e, em seguida, as promessas s√£o executadas: primeiro prometa 1 e depois prometa 2. </p><br><p>  No pr√≥ximo tick (loop de evento), retornamos ao est√°gio do timer, aqui na fila j√° existem 2 temporizadores: setInterval e setTimeout.  Ambos est√£o com atraso 0, respectivamente, est√£o prontos para execu√ß√£o. </p><br><p>  SetInterval √© executado (sa√≠da para o console) e setTimeout 1. N√£o h√° retornos de chamada de E / S sem bloqueio, haver√° uma fase de polling, a promessa 3 e a promessa 4 s√£o exibidas no console. </p><br><p>  Em seguida, o temporizador setTimeout √© registrado.  Isso encerra o tick, passa para o pr√≥ximo tick.  Existem temporizadores novamente, a sa√≠da para o console √© setInterval e setTimeout 2, depois a promessa 5 e a promessa 6 s√£o exibidas. </p><br><p>  <strong>Analisamos o Event Loop e agora podemos falar com mais detalhes sobre multithreading.</strong> </p><br><h3 id="mnogopotochnost--modul-worker_threads">  Threading - m√≥dulo worker_threads </h3><br><p>  O encadeamento apareceu no Node.js, gra√ßas ao m√≥dulo worker_threads na vers√£o 10.5.  E na 10¬™ vers√£o, foi lan√ßada exclusivamente com a chave - experimental-worker, e a partir da 11¬™ vers√£o foi poss√≠vel iniciar sem ela. </p><br><p>  O Node.js tamb√©m possui um m√≥dulo de cluster, mas n√£o gera threads - gera v√°rios outros processos.  Escalabilidade de aplicativos √© seu objetivo principal. </p><br><p><img src="https://static.tildacdn.com/tild3032-3166-4633-a462-316365303133/13.png" alt="imagem"></p><br><p>  Como √© o processo 1: <br>  1 processo Node.js, 1 encadeamento, 1 loop de evento, 1 mecanismo V8 e libuv. </p><br><p>  Se iniciarmos os threads X, ficar√° assim: <br>  1 processo Node.js, X threads, X Event Loops, mecanismos X V8 e X libuv. </p><br><h4 id="shematichno-eto-vyglyadit-sleduyuschim-obrazom">  Esquematicamente, tem a seguinte apar√™ncia </h4><br><p><img src="https://static.tildacdn.com/tild3439-3466-4132-a163-303062373338/14.png" alt="imagem"></p><br><h3 id="davayte-razberyom-primer">  Vamos dar um exemplo. </h3><br><p><img src="https://static.tildacdn.com/tild3639-3061-4664-a231-393561643333/15.png" alt="imagem"></p><br><p>  O servidor da Web mais simples no Express.  Existem 2 rotas'a - / e / opera√ß√£o de gordura. </p><br><p>  H√° tamb√©m uma fun√ß√£o generateRandomArr ().  Ela preenche a matriz com dois milh√µes de registros e os classifica.  Vamos iniciar o servidor. </p><br><p>  N√≥s fazemos um pedido para / fat-operation.  E naquele momento em que a opera√ß√£o de classifica√ß√£o da matriz √© executada, enviamos outra solicita√ß√£o para rotear /, mas para obter a resposta, precisamos esperar at√© que a matriz seja classificada.  Esta √© uma implementa√ß√£o cl√°ssica de thread √∫nico.  Agora conectamos o m√≥dulo worker_threads. </p><br><p><img src="https://static.tildacdn.com/tild3765-6461-4664-b065-333430396433/16.png" alt="imagem"></p><br><p>  N√≥s fazemos um pedido para / fat-operation e ent√£o - para /, do qual obtemos imediatamente a resposta - Ol√°, mundo! </p><br><p>  Para a opera√ß√£o de classifica√ß√£o da matriz, criamos um thread separado que possui sua pr√≥pria inst√¢ncia do Event Loop, e isso n√£o afeta a execu√ß√£o do c√≥digo no thread principal. </p><br><p>  Um encadeamento ser√° "destru√≠do" quando n√£o tiver opera√ß√µes para executar. </p><br><p>  N√≥s olhamos para o c√≥digo fonte.  Registramos o trabalhador na linha 26 e, se necess√°rio, passamos os dados para ele.  Nesse caso, n√£o estou transmitindo nada.  E ent√£o assinamos eventos: um erro e uma mensagem.  No trabalhador, a fun√ß√£o √© chamada, uma matriz de dois milh√µes de registros √© classificada.  Assim que √© ordenado, enviamos o resultado para o fluxo principal ok atrav√©s de post_message. </p><br><p><img src="https://static.tildacdn.com/tild3536-3636-4531-b064-663161303964/17.png" alt="imagem"></p><br><p>  No thread principal, captamos essa mensagem e enviamos o resultado para finalizar.  O trabalhador e o thread principal t√™m mem√≥ria comum, portanto, temos acesso a vari√°veis ‚Äã‚Äãglobais de todo o processo.  Quando transferimos dados do fluxo principal para o worker, o worker recebe apenas uma c√≥pia. </p><br><p>  Podemos descrever o fluxo principal e o fluxo de trabalho em um arquivo.  O m√≥dulo worker_threads fornece uma API atrav√©s da qual podemos determinar em qual thread o c√≥digo est√° executando no momento. </p><br><p><img src="https://static.tildacdn.com/tild3162-6264-4134-a363-663832656262/18.png" alt="imagem"></p><br><h4 id="dopolnitelnaya-informaciya">  Informa√ß√µes Adicionais </h4><br><p>  Compartilho links para recursos √∫teis e um link para a apresenta√ß√£o de Ryan Dahl quando ele apresentou o Event Loop (interessante ver). </p><br><p>  Loop de eventos </p><br><ol><li>  <a href="https://medium.com/devschacht/event-loop-timers-and-nexttick-18579cd122e0">Tradu√ß√£o de um artigo da documenta√ß√£o do Node.js.</a> </li><li>  <a href="https://blog.risingstack.com/node-js-at-scale-understanding-node-js-event-loop/">https://blog.risingstack.com/node-js-at-scale-understanding-node-js-event-loop/</a> </li><li>  <a href="https://habr.com/ru/post/336498/">https://habr.com/en/post/336498/</a> </li></ol><br><p>  Worker_threads </p><br><ol><li>  <a href="https://nodejs.org/api/worker_threads.html">https://nodejs.org/api/worker_threads.html#worker_threads_worker_workerdata</a> - API </li><li>  <a href="https://habr.com/ru/company/ruvds/blog/415659/">https://habr.com/ru/company/ruvds/blog/415659/</a> </li><li>  <a href="https://nodesource.com/blog/worker-threads-nodejs/">https://nodesource.com/blog/worker-threads-nodejs/</a> <a href="https://nodesource.com/blog/worker-threads-nodejs/"><br></a> </li><li>  <a href="https://www.slideshare.net/AartiParikh/original-slides-from-ryan-dahls-nodejs-intro-talk">Slides originais da apresenta√ß√£o de Ryan Dahl (por VPN)</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt479062/">https://habr.com/ru/post/pt479062/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt479052/index.html">[Supercomputa√ß√£o 2019]. Armazenamento em v√°rias nuvens como um aplicativo para novas unidades Kingston DC1000M</a></li>
<li><a href="../pt479054/index.html">Friday Mobile Poll</a></li>
<li><a href="../pt479056/index.html">Falar sobre a vida? Equipe DREAM no Pr√™mio Alexa Desafio Socialbot 3</a></li>
<li><a href="../pt479058/index.html">Monitorando como um processo de gerenciamento de eventos</a></li>
<li><a href="../pt479060/index.html">Por que o controle de qualidade √© uma boa carreira para um programador</a></li>
<li><a href="../pt479066/index.html">Designers industriais Tesla Cybertruck: por que ele √© t√£o bom e ruim</a></li>
<li><a href="../pt479068/index.html">An√°lise de incidentes em sistemas e redes de computadores</a></li>
<li><a href="../pt479070/index.html">Como Nadia se tornou Nadezhda Mikhailovna</a></li>
<li><a href="../pt479072/index.html">Navegador Firefox - 15¬∫ anivers√°rio: ascens√£o, queda e renascimento com foco na privacidade</a></li>
<li><a href="../pt479074/index.html">Est√° chegando a era dos servidores ARM?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>