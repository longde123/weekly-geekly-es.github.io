<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤵🏽 🕖 👩🏼‍🤝‍👨🏾 Centrifugo v2 - die Zukunft des Echtzeit-Messaging-Servers und der Bibliothek für Go 🍽️ 👩‍❤️‍👨 🔟</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einige Leser haben vielleicht schon einmal von Centrifugo gehört . Dieser Artikel konzentriert sich auf die Entwicklung der zweiten Version des Server...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Centrifugo v2 - die Zukunft des Echtzeit-Messaging-Servers und der Bibliothek für Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/avito/blog/416915/"><p>  Einige Leser haben vielleicht schon einmal von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Centrifugo gehört</a> .  Dieser Artikel konzentriert sich auf die Entwicklung der zweiten Version des Servers und der neuen Echtzeitbibliothek für die zugrunde liegende Go-Sprache. </p><br><p>  Ich heiße Alexander Emelin.  Letzten Sommer bin ich dem Avito-Team beigetreten, wo ich jetzt bei der Entwicklung des Avito Messenger-Backends helfe.  Die neue Arbeit, die in direktem Zusammenhang mit der schnellen Zustellung von Nachrichten an Benutzer steht, und die neuen Kollegen haben mich dazu inspiriert, weiter am Open-Source-Projekt Centrifugo zu arbeiten. </p><br><p><img src="https://habrastorage.org/webt/cl/mo/yt/clmoytonrzc4exvj6eeky8j-zw4.jpeg"></p><a name="habracut"></a><br><p>  Kurz gesagt - dies ist ein Server, der die Aufgabe übernimmt, konstante Verbindungen von Benutzern Ihrer Anwendung aufrechtzuerhalten.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Websocket-</a> oder SockJS- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Polyfill wird</a> als Transport verwendet. Wenn keine Websocket-Verbindung hergestellt werden kann, können Eventsource-, XHR-Streaming-, Long-Polling- und andere HTTP-basierte Transporte ausgeführt werden.  Clients abonnieren Kanäle, für die das Backend über die Centrifuge-API neue Nachrichten veröffentlicht, sobald sie entstehen. Anschließend werden die Nachrichten an Benutzer übermittelt, die den Kanal abonniert haben.  Mit anderen Worten, es ist ein PUB / SUB-Server. </p><br><p><img src="https://habrastorage.org/webt/-c/ws/k-/-cwsk-n9eulxk4cd7v9berdltzy.png"></p><br><p> Derzeit wird der Server in einer relativ großen Anzahl von Projekten verwendet.  Darunter befinden sich beispielsweise einige Mail.Ru-Projekte (Intranet, Technopark / Technosphere-Schulungsplattformen, Zertifizierungszentrum usw.) mit Centrifugo, einem schönen Dashboard an der Rezeption im Büro von Badoo Moskau, und 350.000 Benutzer sind gleichzeitig mit dem spot.im-Dienst verbunden zur Zentrifuge. </p><br><p>  Einige Links zu früheren Artikeln über den Server und seine Anwendung für diejenigen, die zuerst von dem Projekt erfahren: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tauchen Sie ein in Centrifugo</a> , </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zentrifuge - 3,5 Millionen U / min</a> , </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sowie ein Artikel in englischer Sprache, der über die Geschichte des Projekts und die Motivation für sein Erscheinen berichtet</a> . </li></ul><br><p>  Ich habe im Dezember letzten Jahres mit der Arbeit an der zweiten Version begonnen und mache bis heute weiter.  Mal sehen, was passiert.  Ich schreibe diesen Artikel nicht nur, um das Projekt irgendwie bekannt zu machen, sondern auch, um vor der Veröffentlichung von Centrifugo v2 ein etwas konstruktiveres Feedback zu erhalten - jetzt gibt es Raum für Manöver und rückwärts inkompatible Änderungen. </p><br><h1 id="real-time-biblioteka-dlya-go">  Echtzeitbibliothek für Go </h1><br><p>  In der Go-Community stellt sich von Zeit zu Zeit die Frage: Gibt es Alternativen zu socket.io on Go?  Manchmal bemerkte ich, wie Entwicklern als Reaktion darauf geraten wird, sich auf Centrifugo zu konzentrieren.  Centrifugo ist jedoch ein selbst gehosteter Server, keine Bibliothek - der Vergleich ist nicht fair.  Ich wurde auch mehrmals gefragt, ob Centrifugo-Code zum Schreiben von Echtzeitanwendungen in Go wiederverwendet werden kann.  Und die Antwort war: theoretisch möglich, aber ich konnte die Abwärtskompatibilität der API interner Pakete nicht auf eigenes Risiko garantieren.  Es ist klar, dass es für niemanden einen Grund gibt, dies zu riskieren, und Gabeln ist auch eine Option.  Außerdem würde ich nicht sagen, dass die API für interne Pakete im Allgemeinen für eine solche Verwendung vorbereitet wurde. </p><br><p>  Daher bestand eine der ehrgeizigen Aufgaben, die ich bei der Arbeit an der zweiten Version des Servers lösen wollte, darin, den Serverkern in Go in eine separate Bibliothek zu unterteilen.  Ich halte dies für sinnvoll, wenn man bedenkt, wie viele Funktionen die Zentrifuge hat, um an die Produktion angepasst zu werden.  Es sind sofort viele Funktionen verfügbar, mit denen skalierbare Echtzeitanwendungen erstellt werden können, sodass Entwickler keine eigenen Lösungen mehr schreiben müssen.  Ich habe bereits früher über diese Funktionen geschrieben und werde im Folgenden auch einige davon skizzieren. </p><br><p>  Ich werde versuchen, ein weiteres Plus der Existenz einer solchen Bibliothek zu rechtfertigen.  Die meisten Centrifugo-Benutzer sind Entwickler, die Backends in Sprachen / Frameworks mit schlechter Parallelitätsunterstützung schreiben (z. B. Django / Flask / Laravel / ...): Arbeiten Sie nach Möglichkeit mit vielen dauerhaften Verbindungen auf nicht offensichtliche oder ineffiziente Weise.  Dementsprechend können nicht alle Benutzer bei der Entwicklung eines in Go geschriebenen Servers helfen (kitschig wegen mangelnder Sprachkenntnisse).  Daher kann auch eine sehr kleine Community von Go-Entwicklern in der Bibliothek bei der Entwicklung des Centrifugo-Servers helfen. </p><br><p>  Das Ergebnis ist eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zentrifugenbibliothek</a> .  Dies ist immer noch WIP, aber absolut alle Funktionen, die in der Beschreibung auf Github angegeben sind, sind implementiert und funktionieren.  Da die Bibliothek eine ziemlich umfangreiche API bietet, bevor ich die Abwärtskompatibilität garantiere, würde ich gerne einige erfolgreiche Beispiele für die Verwendung in realen Projekten auf Go hören.  Es gibt noch keine.  Sowie erfolglos :).  Es gibt keine. </p><br><p>  Ich verstehe, dass ich durch die Benennung der Bibliothek auf die gleiche Weise wie der Server für immer mit Verwirrung umgehen werde.  Ich denke jedoch, dass dies die richtige Wahl ist, da Clients (wie z. B. centrifuge-js, centrifuge-go) sowohl mit der Centrifuge-Bibliothek als auch mit dem Centrifugo-Server arbeiten.  Außerdem ist der Name in den Köpfen der Benutzer bereits fest verankert, und ich möchte diese Assoziationen nicht verlieren.  Und doch werde ich zur besseren Übersicht noch einmal klarstellen: </p><br><ul><li>  Zentrifuge - eine Bibliothek für die Go-Sprache, </li><li>  Centrifugo ist eine schlüsselfertige Lösung, ein separater Service, der in Version 2 auf der Centrifuge-Bibliothek basiert. </li></ul><br><p>  Aufgrund seines Designs geht Centrifugo (ein eigenständiger Dienst, der nichts über Ihr Backend weiß) davon aus, dass der Nachrichtenfluss über den Echtzeittransport vom Server zum Client erfolgt.  Was meinst du  Wenn der Benutzer beispielsweise eine Nachricht in den Chat schreibt, muss diese Nachricht zuerst an das Anwendungs-Backend (z. B. AJAX im Browser) gesendet, auf der Backend-Seite validiert, bei Bedarf in der Datenbank gespeichert und dann an die Centrifuge-API gesendet werden.  Die Bibliothek hebt diese Einschränkung auf, sodass Sie den bidirektionalen Austausch asynchroner Nachrichten zwischen dem Server und dem Client sowie RPC-Aufrufe organisieren können. </p><br><p><img src="https://habrastorage.org/webt/jf/_d/er/jf_dervpzmkl2fuprcse34ayoke.png"></p><br><p>  Schauen wir uns ein einfaches Beispiel an: Wir implementieren einen kleinen Server auf Go mithilfe der Centrifuge-Bibliothek.  Der Server empfängt Nachrichten von Browser-Clients über Websocket, der Client verfügt über ein Textfeld, in das Sie eine Nachricht eingeben können, drücken Sie die Eingabetaste - und die Nachricht wird an alle Benutzer gesendet, die den Kanal abonniert haben.  Das heißt, die einfachste Version des Chats.  Es schien mir am bequemsten, dies in Form eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kerns zu platzieren</a> . </p><br><p>  Sie können wie gewohnt laufen: </p><br><pre><code class="go hljs">git clone https:<span class="hljs-comment"><span class="hljs-comment">//gist.github.com/2f1a38ae2dcb21e2c5937328253c29bf.git cd 2f1a38ae2dcb21e2c5937328253c29bf go get -u github.com/centrifugal/centrifuge go run main.go</span></span></code> </pre> <br><p>  Gehen Sie dann zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http: // localhost: 8000</a> und öffnen Sie mehrere Browser-Registerkarten. </p><br><p>  Wie Sie sehen können, tritt der Einstiegspunkt in die Geschäftslogik der Anwendung auf, wenn die Rückruffunktionen <code>On().Connect()</code> hängen bleiben: </p><br><pre> <code class="go hljs">node.On().Connect(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, client *centrifuge.Client, e centrifuge.ConnectEvent)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">centrifuge</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConnectReply</span></span></span></span> { client.On().Disconnect(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e centrifuge.DisconnectEvent)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">centrifuge</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DisconnectReply</span></span></span></span> { log.Printf(<span class="hljs-string"><span class="hljs-string">"client disconnected"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> centrifuge.DisconnectReply{} }) log.Printf(<span class="hljs-string"><span class="hljs-string">"client connected via %s"</span></span>, client.Transport().Name()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> centrifuge.ConnectReply{} })</code> </pre> <br><p>  Der auf Rückrufen basierende Ansatz schien mir für die Interaktion mit der Bibliothek am bequemsten zu sein.  Außerdem wird bei der Implementierung des <a href="">Socket-io-Servers auf Go</a> ein ähnlicher, nur schwach typisierter Ansatz verwendet.  Wenn Sie plötzlich darüber nachdenken, wie die API idiomatischer gemacht werden könnte, würde ich mich freuen zu hören. </p><br><p>  Dies ist ein sehr einfaches Beispiel, das nicht alle Funktionen der Bibliothek demonstriert.  Jemand kann bemerken, dass es für solche Zwecke einfacher ist, eine Bibliothek für die Arbeit mit Websocket zu verwenden.  Zum Beispiel Gorilla Websocket.  Das ist eigentlich so.  Selbst in diesem Fall müssen Sie jedoch einen anständigen Teil des Servercodes aus dem Beispiel im Gorilla Websocket-Repository kopieren.  Was ist, wenn: </p><br><ul><li>  Sie müssen die Anwendung auf mehrere Computer skalieren. </li><li>  oder Sie benötigen nicht einen gemeinsamen Kanal, sondern mehrere - und Benutzer können diese dynamisch abonnieren und abbestellen, während Sie in Ihrer Anwendung navigieren. </li><li>  oder Sie müssen arbeiten, wenn die Websocket-Verbindung nicht hergestellt werden konnte (es gibt keine Unterstützung im Client-Browser, es gibt eine Browser-Erweiterung, eine Art Proxy auf dem Weg zwischen dem Client und dem Server unterbricht die Verbindung). </li><li>  oder Sie müssen Nachrichten wiederherstellen, die der Client während kurzer Unterbrechungen der Internetverbindung verpasst hat, ohne die Hauptdatenbank zu laden. </li><li>  oder Sie benötigen die Kontrolle über die Benutzerautorisierung im Kanal, </li><li>  oder Sie müssen die permanente Verbindung von Benutzern trennen, die in der Anwendung deaktiviert sind. </li><li>  oder Sie benötigen Informationen darüber, wer sich gerade auf dem Kanal befindet oder welche Ereignisse jemand vom Kanal abonniert / abgemeldet hat. </li><li>  oder benötigen Sie Metriken und Überwachung? </li></ul><br><p>  Die Centrifuge-Bibliothek kann Ihnen dabei helfen - tatsächlich hat sie alle grundlegenden Funktionen geerbt, die zuvor in Centrifugo verfügbar waren.  Weitere Beispiele für die oben genannten Punkte finden Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github</a> . </p><br><p>  Das starke Erbe von Centrifugo kann ein Minus sein, da die Bibliothek alle Servermechaniken übernommen hat, die recht originell sind und möglicherweise für jemanden nicht offensichtlich oder mit unnötigen Funktionen überladen erscheinen.  Ich habe versucht, den Code so zu organisieren, dass nicht verwendete Funktionen die Gesamtleistung nicht beeinträchtigen. </p><br><p>  Es gibt einige Optimierungen in der Bibliothek, die eine effizientere Nutzung der Ressourcen ermöglichen.  Dies kombiniert mehrere Nachrichten in einem Websocket-Frame, um beim Schreiben von Systemaufrufen zu speichern, oder verwendet beispielsweise Gogoprotobuf, um Protobuf-Nachrichten und andere zu serialisieren.  Apropos Protobuf. </p><br><h1 id="binarnyy-protobuf-protokol">  Binäres Protobuf-Protokoll </h1><br><p>  Ich wollte wirklich, dass Centrifugo mit Binärdaten arbeitet ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">und nicht nur mit mir</a> ), daher wollte ich in der neuen Version zusätzlich zu dem auf JSON basierenden ein Binärprotokoll hinzufügen.  Nun wird das gesamte Protokoll als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Protobuf-Schema beschrieben</a> .  Dies ermöglichte es uns, es strukturierter zu gestalten und einige nicht offensichtliche Entscheidungen im Protokoll der ersten Version zu überdenken. </p><br><p>  Ich denke, Sie müssen nicht lange sagen, was die Vorteile von Protobuf gegenüber JSON sind - Kompaktheit, Serialisierungsgeschwindigkeit, strenges Schema.  Es gibt einen Nachteil in Form von Unleserlichkeit, aber jetzt haben Benutzer die Möglichkeit zu entscheiden, was für sie in einer bestimmten Situation wichtiger ist. </p><br><p>  Im Allgemeinen sollte der vom Centrifugo-Protokoll bei Verwendung von Protobuf anstelle von JSON erzeugte Datenverkehr um das ~ 2-fache abnehmen (ohne Anwendungsdaten).  Der CPU-Verbrauch in meinen synthetischen Lasttests verringerte sich im Vergleich zu JSON um das ~ 2-fache.  Diese Zahlen sprechen eigentlich wenig darüber, was in der Praxis alles vom Lastprofil einer bestimmten Anwendung abhängt. </p><br><p>  Aus Gründen des Interesses habe ich einen Computer mit Debian 9.4 und 32 Intel® Xeon® Platinum 8168 CPU bei 2,70 GHz vCPU-Benchmark gestartet, mit dem wir die Bandbreite der Client-Server-Interaktion bei Verwendung des JSON-Protokolls und des Protobuf-Protokolls vergleichen konnten.  Es gab 1000 Abonnenten für 1 Kanal.  In diesem Kanal wurden Nachrichten in 4 Streams veröffentlicht und an alle Abonnenten übermittelt.  Die Größe jeder Nachricht betrug 128 Bytes. </p><br><p>  Ergebnisse für JSON: </p><br><pre> <code class="go hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> run main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> -s ws:<span class="hljs-comment"><span class="hljs-comment">//localhost:8000/connection/websocket -n 1000 -ns 1000 -np 4 channel Starting benchmark [msgs=1000, msgsize=128, pubs=4, subs=1000] Centrifuge Pub/Sub stats: 265,900 msgs/sec ~ 32.46 MB/sec Pub stats: 278 msgs/sec ~ 34.85 KB/sec [1] 73 msgs/sec ~ 9.22 KB/sec (250 msgs) [2] 71 msgs/sec ~ 9.00 KB/sec (250 msgs) [3] 71 msgs/sec ~ 8.90 KB/sec (250 msgs) [4] 69 msgs/sec ~ 8.71 KB/sec (250 msgs) min 69 | avg 71 | max 73 | stddev 1 msgs Sub stats: 265,635 msgs/sec ~ 32.43 MB/sec [1] 273 msgs/sec ~ 34.16 KB/sec (1000 msgs) ... [1000] 277 msgs/sec ~ 34.67 KB/sec (1000 msgs) min 265 | avg 275 | max 278 | stddev 2 msgs</span></span></code> </pre> <br><p>  Ergebnisse für den Fall Protobuf: </p><br><pre> <code class="go hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> run main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> -s ws:<span class="hljs-comment"><span class="hljs-comment">//localhost:8000/connection/websocket?format=protobuf -n 100000 -ns 1000 -np 4 channel Starting benchmark [msgs=100000, msgsize=128, pubs=4, subs=1000] Centrifuge Pub/Sub stats: 681,212 msgs/sec ~ 83.16 MB/sec Pub stats: 685 msgs/sec ~ 85.69 KB/sec [1] 172 msgs/sec ~ 21.57 KB/sec (25000 msgs) [2] 171 msgs/sec ~ 21.47 KB/sec (25000 msgs) [3] 171 msgs/sec ~ 21.42 KB/sec (25000 msgs) [4] 171 msgs/sec ~ 21.42 KB/sec (25000 msgs) min 171 | avg 171 | max 172 | stddev 0 msgs Sub stats: 680,531 msgs/sec ~ 83.07 MB/sec [1] 681 msgs/sec ~ 85.14 KB/sec (100000 msgs) ... [1000] 681 msgs/sec ~ 85.13 KB/sec (100000 msgs) min 680 | avg 680 | max 685 | stddev 1 msgs</span></span></code> </pre><br><p>  Möglicherweise stellen Sie fest, dass der Durchsatz einer solchen Installation bei Protobuf mehr als doppelt so hoch ist.  Das Client-Skript finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> - dies ist das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nats-Benchmark-Skript, das an die Realität von Centrifuge angepasst ist</a> . </p><br><p>  Es ist auch erwähnenswert, dass die Leistung der JSON-Serialisierung auf dem Server mit demselben Ansatz wie bei gogoprotobuf - Pufferpool und Codegenerierung - "hochgepumpt" werden kann. Derzeit wird JSON durch ein Paket aus der auf Reflect basierenden Go-Standardbibliothek serialisiert.  In Centrifugo wird beispielsweise die erste Version von JSON mithilfe einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bibliothek</a> , die <a href="">einen Pufferpool</a> bereitstellt, manuell serialisiert.  Ähnliches kann in Zukunft im Rahmen der zweiten Version getan werden. </p><br><p>  Hervorzuheben ist, dass Protobuf auch bei der Kommunikation mit dem Server über einen Browser verwendet werden kann.  Der Javascript-Client verwendet hierfür die Bibliothek protobuf.js.  Da die protobufjs-Bibliothek sehr umfangreich ist und die Anzahl der Benutzer im Binärformat mithilfe des Webpacks und seines Tree-Shaking-Algorithmus gering ist, generieren wir zwei Versionen des Clients - eine nur mit JSON-Protokollunterstützung und die andere mit JSON- und Protobuf-Unterstützung.  In anderen Umgebungen, in denen die Größe der Ressourcen keine so wichtige Rolle spielt, können sich Kunden keine Sorgen um diese Trennung machen. </p><br><h1 id="json-web-token-jwt">  JSON Web Token (JWT) </h1><br><p>  Eines der Probleme bei der Verwendung eines eigenständigen Servers wie Centrifugo besteht darin, dass er nichts über Ihre Benutzer und deren Authentifizierungsmethode sowie über die Art des Sitzungsmechanismus weiß, den Ihr Backend verwendet.  Und Sie müssen die Verbindung irgendwie authentifizieren. </p><br><p>  Zu diesem Zweck wurde in der ersten Version von Centrifuge beim Verbinden die SHA-256-HMAC-Signatur verwendet, die auf einem geheimen Schlüssel basiert, der nur dem Backend und der Centrifuge bekannt ist.  Dadurch wurde sichergestellt, dass die vom Kunden übermittelte Benutzer-ID wirklich ihm gehört. </p><br><p>  Vielleicht war die korrekte Übertragung von Verbindungsparametern und die Erzeugung eines Tokens eine der Hauptschwierigkeiten bei der Integration von Centrifugo in das Projekt. </p><br><p>  Als die Zentrifuge erschien, war <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der JWT-Standard</a> noch nicht so beliebt.  Jetzt, einige Jahre später, stehen Bibliotheken für die JWT-Generation für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die beliebtesten Sprachen zur Verfügung</a> .  Die Hauptidee von JWT ist genau das, was die Zentrifuge benötigt: Bestätigung der Authentizität der übertragenen Daten.  In der zweiten Version von HMAC wurde die Verwendung von JWT durch eine manuell generierte Signatur ersetzt.  Dies ermöglichte es, die Notwendigkeit der Unterstützung von Hilfsfunktionen für die korrekte Generierung von Token in Bibliotheken für verschiedene Sprachen zu beseitigen. </p><br><p>  In Python kann beispielsweise ein Token für die Verbindung mit Centrifugo wie folgt generiert werden: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> jwt <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time token = jwt.encode({<span class="hljs-string"><span class="hljs-string">"user"</span></span>: <span class="hljs-string"><span class="hljs-string">"42"</span></span>, <span class="hljs-string"><span class="hljs-string">"exp"</span></span>: int(time.time()) + <span class="hljs-number"><span class="hljs-number">10</span></span>*<span class="hljs-number"><span class="hljs-number">60</span></span>}, <span class="hljs-string"><span class="hljs-string">"secret"</span></span>).decode() print(token)</code> </pre> <br><p>  Es ist wichtig zu beachten, dass Sie den Benutzer bei Verwendung der Centrifuge-Bibliothek mithilfe der nativen Go-Methode authentifizieren können - innerhalb der Middleware.  Beispiele befinden sich im Repository. </p><br><h1 id="grpc">  GRPC </h1><br><p>  Während der Entwicklung habe ich versucht, bidirektionales GRPC-Streaming als Transportmittel für die Kommunikation zwischen Client und Server zu verwenden (zusätzlich zu Websocket- und HTTP-basierten SockJS-Fallbacks).  Was kann ich sagen  Er hat gearbeitet.  Ich habe jedoch kein einziges Szenario gefunden, in dem bidirektionales GRPC-Streaming besser wäre als Websocket.  Ich habe mich hauptsächlich mit Servermetriken befasst: Datenverkehr, der über die Netzwerkschnittstelle generiert wird, CPU-Verbrauch durch den Server mit einer großen Anzahl eingehender Verbindungen, Speicherverbrauch pro Verbindung. </p><br><p>  GRPC hat in jeder Hinsicht gegen Websocket verloren: </p><br><ul><li>  GRPC generiert in ähnlichen Szenarien 20% mehr Verkehr. </li><li>  GRPC verbraucht 2-3 mal mehr CPU (abhängig von der Konfiguration der Verbindungen - alle haben unterschiedliche Kanäle oder alle einen Kanal abonniert). </li><li>  GRPC verbraucht viermal so viel RAM pro Verbindung.  Bei 10.000 Verbindungen verbrauchte der Websocket-Server beispielsweise 500 MB Speicher und GRPC-2 GB. </li></ul><br><p>  Die Ergebnisse waren ziemlich ... erwartet.  Im Allgemeinen sah ich in GRPC als Client-Transport nicht viel Sinn - und löschte den Code mit gutem Gewissen bis vielleicht zu besseren Zeiten. </p><br><p>  GRPC ist jedoch gut darin, wofür es hauptsächlich erstellt wurde - Code zu generieren, mit dem Sie RPC-Aufrufe zwischen Diensten mithilfe eines vorgegebenen Schemas tätigen können.  Daher bietet die Zentrifuge neben der HTTP-API jetzt auch GRPC-basierte API-Unterstützung, um beispielsweise neue Nachrichten auf dem Kanal und andere verfügbare Server-API-Methoden zu veröffentlichen. </p><br><h1 id="slozhnosti-s-klientami">  Schwierigkeiten mit Kunden </h1><br><p>  Durch die in der zweiten Version vorgenommenen Änderungen wurde die obligatorische Unterstützung von Bibliotheken für die Server-API entfernt - die Integration auf der Serverseite wurde einfacher, das Client-Protokoll im Projekt wurde jedoch geändert und verfügt über eine ausreichende Anzahl von Funktionen.  Dies macht die Implementierung von Kunden ziemlich schwierig.  Für die zweite Version haben wir jetzt einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Client für Javascript</a> , der in Browsern funktioniert und mit NodeJS und React-Native funktionieren sollte.  Es gibt einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Client auf Go,</a> der auf seiner Basis und auf der Basis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Gomobile-Projektordner</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">für iOS und Android erstellt wurde</a> . </p><br><p>  Für vollkommenes Glück gibt es nicht genügend native Bibliotheken für iOS und Android.  Für die erste Version von Centrifugo wurden sie von Leuten aus der Open-Source-Community gekauft.  Ich möchte glauben, dass so etwas jetzt passieren wird. </p><br><p>  Ich habe kürzlich mein Glück versucht, indem ich einen Antrag auf ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MOSS-Stipendium von Mozilla</a> gesendet habe, um in die Kundenentwicklung zu investieren, wurde aber abgelehnt.  Der Grund ist die unzureichend aktive Community auf Github.  Leider stimmt das, aber wie Sie sehen, unternehme ich einige Schritte, um die Situation zu verbessern. </p><br><p><img src="https://habrastorage.org/webt/y4/3q/kc/y43qkcl_yp7fjdgalrqvuzw5hl0.jpeg"></p><br><h1 id="zaklyuchenie">  Fazit </h1><br><p>  Ich habe nicht alle Funktionen angekündigt, die in Centrifugo v2 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verfügbar sein werden</a> . Weitere Informationen finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ausgabe zu Github</a> .  Die Serverfreigabe hat noch nicht stattgefunden, wird aber bald erfolgen.  Es gibt noch unvollendete Momente, einschließlich der Notwendigkeit, die Dokumentation zu vervollständigen.  Der Prototyp der Dokumentation kann hier eingesehen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> .  Wenn Sie ein Centrifugo-Benutzer sind, ist jetzt der richtige Zeitpunkt, um die zweite Version des Servers zu beeinflussen.  Eine Zeit, in der es nicht so beängstigend ist, etwas zu zerbrechen, um es später besser zu machen.  Für Interessierte: Die Entwicklung konzentriert sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf den c2-Zweig</a> . </p><br><p>  Es fällt mir schwer zu beurteilen, wie stark die Nachfrage nach der Centrifuge-Bibliothek, die Centrifugo v2 zugrunde liegt, gefragt sein wird.  Im Moment freue ich mich, dass ich es auf den aktuellen Stand bringen konnte.  Der wichtigste Indikator für mich ist jetzt die Antwort auf die Frage "Würde ich diese Bibliothek selbst in meinem persönlichen Projekt verwenden?"  Meine Antwort lautet ja.  Bei der Arbeit?  Ja  Daher glaube ich, dass andere Entwickler es zu schätzen wissen. </p><br><p>  PS Ich möchte mich bei den Leuten bedanken, die bei der Arbeit und beim Rat geholfen haben - Dmitry Korolkov, Artemy Ryabinkov, Oleg Kuzmin.  Ohne dich wäre es eng. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416915/">https://habr.com/ru/post/de416915/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416905/index.html">Boston Dynamics SpotMini Präsentation</a></li>
<li><a href="../de416907/index.html">Theorie des Glücks. Das Gesetz der Zebra- und Alien-Warteschlange</a></li>
<li><a href="../de416909/index.html">PostgreSQL-Sitzungsverlauf - neue pgsentinel-Erweiterung</a></li>
<li><a href="../de416911/index.html">Chatbots sollten der nächste Durchbruch sein: Was ist schief gelaufen?</a></li>
<li><a href="../de416913/index.html">Was sollte der Administrator beim Wechsel in die Cloud vergessen - und was muss er lernen?</a></li>
<li><a href="../de416917/index.html">Siebte Traurigkeit</a></li>
<li><a href="../de416919/index.html">Burger King und verdeckte Bildschirmaufnahme Ihres Telefons</a></li>
<li><a href="../de416921/index.html">Wie Hunderttausende von Antennen in einem Teleskop zusammenkommen</a></li>
<li><a href="../de416925/index.html">Was wir über Ant Design wissen</a></li>
<li><a href="../de416927/index.html">Schuh-Startups - und warum Silicon Valley sie so liebt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>