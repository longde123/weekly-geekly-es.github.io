<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úäüèª üöµ üòê Schnelle Festkomma-Mathematik f√ºr Finanzanwendungen in Java üë©üèº‚Äçüè´ üë®üèª‚Äç‚öïÔ∏è üßîüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es ist kein Geheimnis, dass Finanzinformationen (Konten, Buchungen und andere Buchhaltung) mit Gleitkommazahlen nicht sehr freundlich sind, und viele ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schnelle Festkomma-Mathematik f√ºr Finanzanwendungen in Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425565/"><p>  Es ist kein Geheimnis, dass Finanzinformationen (Konten, Buchungen und andere Buchhaltung) mit Gleitkommazahlen nicht sehr freundlich sind, und viele Artikel empfehlen die Verwendung einer Festkomma-Arithmetik.  In Java wird dieses Format tats√§chlich nur durch die BigDecimal-Klasse dargestellt, die aus Leistungsgr√ºnden nicht immer verwendet werden kann.  Wir m√ºssen nach Alternativen suchen.  Dieser Artikel beschreibt eine selbstgeschriebene Java-Bibliothek zum Ausf√ºhren von arithmetischen Operationen f√ºr Zahlen mit fester Genauigkeit.  Die Bibliothek wurde f√ºr die Verwendung in leistungsstarken Finanzanwendungen erstellt und erm√∂glicht es Ihnen, mit einer Genauigkeit von 9 Dezimalstellen zu arbeiten und dabei eine akzeptable Leistung beizubehalten.  Ein Link zu den Quellen und Benchmarks befindet sich am Ende des Artikels. </p><a name="habracut"></a><br><h1 id="arifmetika-s-plavayuschey-tochkoy">  Gleitkomma-Arithmetik </h1><br><p>  Moderne Computer k√∂nnen arithmetische Operationen nur mit begrenzter Genauigkeit ausf√ºhren.  Dies sind diskrete Ger√§te, die m√∂glicherweise nicht mit allen m√∂glichen Zahlen arbeiten, sondern nur mit einer abz√§hlbaren Teilmenge davon.  Das gebr√§uchlichste Format f√ºr die Arbeit mit reellen Zahlen im Computerspeicher ist Gleitkomma (Bin√§rpunkt) - Gleitkomma (Bin√§rpunkt), wenn Zahlen in der Form M * 2 ^ E gespeichert sind, wobei M und E eine ganzzahlige Mantisse und die Reihenfolge der Zahl sind.  Einige Zahlen, wie z. B. 0,1, k√∂nnen in diesem Format jedoch nicht genau dargestellt werden.  Daher h√§ufen sich bei komplexen Berechnungen zwangsl√§ufig einige Fehler an.  Das hei√üt, das Ergebnis der Maschinenberechnung, beispielsweise 0,1 + 0,1 + 0,1, stimmt nicht mit der mathematisch korrekten 0,3 √ºberein.  In Anbetracht des oben Gesagten k√∂nnen Sie beim Programmieren komplexer Arithmetik verschiedene Strategien verfolgen: </p><br><p>  Strategie 1 - ignorieren.  Ignorieren Sie den Fehler, betrachten Sie alle Operationen als ideal mathematisch und hoffen Sie, dass die verf√ºgbare Genauigkeit f√ºr akzeptable Ergebnisse ausreicht.  Die h√§ufigste Option. </p><br><p>  Strategie 2 - akribisch berechnen.  Formeln zur Berechnung von Maschinenfehlern sind seit Jahrzehnten bekannt.  Sie erm√∂glichen es, den relativen Fehler einer arithmetischen Operation von oben abzusch√§tzen.  Wahrscheinlich ist dies das, was Sie f√ºr eine ernsthafte numerische Simulation tun m√ºssen.  Das Problem ist, dass es sehr zeitaufw√§ndig ist.  Tats√§chlich muss jedem + - * / Zeichen im Code eine Fehlerberechnung beigef√ºgt sein.  Sie m√ºssen alle Abh√§ngigkeiten zwischen den Berechnungen ber√ºcksichtigen und den Vorgang jedes Mal wiederholen, wenn Sie den Code √§ndern. </p><br><p>  Strategie 3 - Verwenden Sie einen Dezimalpunkt (Gleitkomma) anstelle eines Bin√§rpunkts.  Speichern Sie die Zahlen in der Form M * 10 ^ E.  Dies l√∂st nicht die Fehlerprobleme (die Mantisse ist immer noch auf eine endliche Anzahl von signifikanten Stellen gerundet), aber zumindest alle ‚Äûeinfachen‚Äú Zahlen f√ºr eine Person (wie 1.1) werden jetzt genau im Speicher dargestellt.  Die R√ºckzahlung wird Leistung sein.  Jede Normalisierung von Zahlen (dh eine √§quivalente Abnahme der Mantisse und eine Zunahme der Ordnung) erfordert eine Division durch eine Potenz von 10, was im Gegensatz zu einer Division durch eine Potenz von 2 nicht sehr schnell ist. Und Sie m√ºssen viel normalisieren - bei jeder Addition oder Subtraktion mit unterschiedlichen Ordnungen. </p><br><p>  Strategie 4 - Verwenden Sie einen festen Punkt (festen Dezimalpunkt).  Vereinfachung von Strategie 3, wenn wir die Reihenfolge E festlegen. In diesem Fall ist eine Normalisierung f√ºr die Addition / Subtraktion nicht erforderlich.  Au√üerdem haben alle Berechnungen den gleichen absoluten Fehler.  Dieser Artikel ist dieser Strategie gewidmet. </p><br><h1 id="arifmetika-s-fiksirovannoy-tochkoy">  Festkomma-Arithmetik </h1><br><p>  Im Gegensatz zur Physik, in der relative Fehler wichtig sind, wird im Finanzbereich nur das Absolute ben√∂tigt.  Wenn dem Kunden nach einer komplexen Finanztransaktion 1.000.000,23 USD in Rechnung gestellt werden, w√§hrend er 1.000.000,18 USD erwartet, k√∂nnen einige Schwierigkeiten auftreten.  Erkl√§rungen wie "Warum brauchen Sie Genauigkeit in 8 signifikanten Stellen?"  darf nicht reiten.  Dabei geht es nicht um 5 Cent Verlust (im Gegenteil, ‚Äûzugunsten‚Äú des Kunden ist nicht viel besser), sondern um Inkonsistenzen in der Rechnungslegung.  Daher sind die Regeln f√ºr Berechnungen und Rundungen zwischen den Parteien klar festgelegt, und Artefakte aus der Verwendung von Double- und Float-Variablen erschweren manchmal das Leben. </p><br><p>  Java hat eine Standardklasse f√ºr Festkomma-Arithmetik - BigDecimal.  Es gibt zwei Probleme: Es ist langsam (aufgrund seiner Universalit√§t) und es ist nicht stabil.  Nichtstabilit√§t bedeutet, dass jede Operation ein Objekt auf dem Heap zuweist.  Das Ausw√§hlen und Freigeben eines Objekts dauert etwas, aber intensive Berechnungen im ‚Äûhei√üen‚Äú Code f√ºhren zu einer angemessenen Belastung des GC, was in einigen F√§llen nicht akzeptabel ist.  Sie k√∂nnen sich auf Escape-Analyse und Skalierung verlassen, aber sie sind sehr instabil in dem Sinne, dass selbst eine geringf√ºgige √Ñnderung des Codes oder der JIT (z. B. das verz√∂gerte Laden einer neuen Schnittstellenimplementierung) die gesamte Inline-Struktur auf den Kopf stellen kann und die Methode vor einer Minute einwandfrei funktioniert hat. pl√∂tzlich beginnt w√ºtend Erinnerung zuzuweisen. <br>  UPD aufgrund von Fragen in den Kommentaren: <strong>Der Hauptgrund f√ºr den</strong> Verzicht auf BigDecimal und BigInteger ist keineswegs eine geringe Rechenleistung, sondern mangelnde Stabilit√§t und Auswahl von Objekten. </p><br><p>  Die beschriebene Bibliothek ist das Ergebnis der M√ºdigkeit, die Festkomma-Nicht-Speicher-Arithmetik f√ºr jeden neuen Arbeitgeber von Grund auf neu zu schreiben, und ich habe beschlossen, meine eigene Bibliothek f√ºr das sp√§tere Insourcing zu schreiben. </p><br><p>  Ich werde sofort ein Anwendungsbeispiel zeigen, bevor ich mit den Implementierungsdetails fortfahre: </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sample</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Decimal margin; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Quantity cumQuantity = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Quantity(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Quantity contraQuantity = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Quantity(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Quantity cumContraQuantity = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Quantity(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Price priceWithMargin = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Price(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Price avgPrice = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Price(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sample</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> marginBp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// 1 + margin / 10000 this.margin = Decimal.create(marginBp).divRD(10000L).add(1); } public Price calculateAvgPrice(Quantity[] quantities, Price[] prices) { cumQuantity.set(0); contraQuantity.set(0); // avg = sum(q * p * margin) / sum(q) for (int i = 0; i &lt; quantities.length; i++) { cumQuantity.add(quantities[i]); priceWithMargin.set(prices[i]).mulRD(margin); contraQuantity.set(quantities[i]).mulRD(priceWithMargin); cumContraQuantity.add(contraQuantity); } return avgPrice.quotientRD(cumContraQuantity, cumQuantity); } public static void main(String[] args) throws ParseException { Price p1 = Price.create("1.5"); Price p2 = Price.create(1.6); Quantity q1 = Quantity.create("100"); Quantity q2 = Quantity.create(200); // apply 0.05% margin to the prices Sample sample = new Sample(5); System.out.println(sample.calculateAvgPrice(new Quantity[]{q1, q2}, new Price[]{p1, p2})); } }</span></span></code> </pre> <br><h1 id="ideya-realizacii">  Implementierungsidee </h1><br><p>  Wir brauchen also einen ver√§nderlichen Wrapper eines ganzzahligen Grundelements, genauer gesagt eines Long'a, der uns fast 19 signifikante Stellen gibt (genug f√ºr die Ganzzahl und den Bruchteil).  Langfristig meinen wir N Dezimalstellen.  Beispielsweise wird bei N = 2 die Zahl 2,56 als 256 (bin√§r 100000000) gespeichert.  Negative Zahlen werden standardm√§√üig in zus√§tzlichem Code gespeichert: </p><br><p>  <em>-2,56</em> <br>  <strong>-256</strong> </p><br><p>  (Im Folgenden werden <em>kursiv</em> ‚Äûmathematische‚Äú Zahlen und Berechnungen und <strong>in Fettdruck</strong> ihre interne Darstellung angegeben.) </p><br><p>  Es erschien mir auch n√ºtzlich, NaN als separaten Wert einzugeben, der bei Rechenfehlern (anstelle einer Ausnahme oder eines M√ºlls) zur√ºckgegeben wird.  <em>NaN</em> wird intern als <strong>Long.MIN_VALUE dargestellt</strong> , durch alle Operationen "weitergegeben" und erm√∂glicht die Bestimmung der Vorzeichenumkehr f√ºr alle verbleibenden Zahlen. </p><br><p>  Versuchen wir, die Algorithmen der arithmetischen Operationen f√ºr den Fall zu sch√§tzen, in dem N = 2 ist. </p><br><p>  Addition und Subtraktion erfordern keine zus√§tzlichen Gesten. Verwenden Sie einfach die Werte wie sie sind: </p><br><p>  <em>1,20 + 2,30 = 3,50</em> <br>  <strong>120 + 230 = 350</strong> </p><br><p>  Multiplikation und Division erfordern eine zus√§tzliche Normalisierung, dh Multiplikation / Division mit 10 ^ N (in unserem Beispiel mit 100). </p><br><p>  <em>1,20 * 2,00 = 2,40</em> <br>  <strong>120 * 200/100 = 240</strong> </p><br><p>  <em>1,20 / 2,00 = 0,60</em> <br>  <strong>100 * 120/200 = 60</strong> </p><br><p>  Zus√§tzliche Aufteilung ist nicht die schnellste Operation.  In diesem Fall ist dies jedoch eine Division durch eine Konstante, da wir zuvor N = 2 und 10 ^ N = 100 festgelegt haben.  Die Division durch Konstante, insbesondere durch ‚Äûsch√∂n‚Äú (Typ 10), wird in der CPU intensiv optimiert und ist viel schneller als die Division durch eine Zufallszahl.  Wir dividieren jedes Mal durch 10, wenn wir eine Zahl in eine Zeichenfolge konvertieren (z. B. in den Protokollen), und die CPU-Hersteller wissen davon ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">weitere Einzelheiten zu Optimierungen finden</a> Sie unter "Division durch eine Konstante"). </p><br><p>  Um das Verst√§ndnis dessen, was wir tun, zu festigen, werde ich noch eine Operation geben: un√§re Umkehrung einer Zahl, dh 1 / x.  Dies ist ein Sonderfall der Teilung. Sie m√ºssen nur 1,00 in unserem Format einreichen und vergessen nicht, zu normalisieren: </p><br><p>  <em>1,00 / 2,00 = 0,50</em> <br>  <strong>100 * 100/200 = 50</strong> </p><br><p>  Nun, obwohl alles recht einfach ist, versuchen wir, die Details zu untersuchen. </p><br><h1 id="okruglenie">  Rundung </h1><br><p>  Versuchen wir eine andere Zahl zu ziehen: </p><br><p>  <em>1,00 / 3,00 = 0,33</em> <br>  <strong>100 * 100/300 = 33</strong> </p><br><p>  Ein ehrliches mathematisches Ergebnis liegt zwischen 0,33 und 0,34, aber wir k√∂nnen es uns nicht genau vorstellen.  Welchen Weg umrunden?  Normalerweise auf 0 gerundet, und dies ist der schnellste Weg (Hardware unterst√ºtzt).  Zur√ºck zu den tats√§chlichen finanziellen Problemen ist dies jedoch nicht immer der Fall.  Bei der Verarbeitung von Transaktionen mit einem Kunden erfolgt die Rundung in der Regel "zugunsten des Kunden".  Das hei√üt, der Preis wird aufgerundet, wenn der Kunde verkauft, und gesenkt, wenn der Kunde kauft.  Es k√∂nnen jedoch auch andere Optionen erforderlich sein, z. B. das arithmetische Runden auf die n√§chste Zahl mit Untertypen (halb hoch, halb runter, halb gerade), um Buchhaltungsinkonsistenzen zu minimieren.  Oder f√ºr negative Preise auf ¬± unendlich runden (f√ºr einige Finanzinstrumente).  Java BigDecimal enth√§lt bereits eine Liste der Standardrundungsmodi, und die beschriebene Bibliothek unterst√ºtzt alle.  UNNECESSARY gibt NaN zur√ºck, wenn der Vorgang unerwartet gerundet werden muss. </p><br><p>  Im Aufrundungsmodus sollte unsere Berechnung Folgendes ergeben: </p><br><p>  <em>1,00 / 3,00 = 0,34</em> <br>  <strong>100 * 100/300 + 1 = 34</strong> </p><br><p>  Wie finde ich heraus, was Sie zum Hinzuf√ºgen einer Einheit ben√∂tigen?  Sie ben√∂tigen den Rest der Division 10.000% 300 = 100. Das ist so langsam wie die Division selbst.  Wenn Sie in einer Zeile in den Code "a / b; a% b" schreiben, erkennt JIT gl√ºcklicherweise, dass keine 2 Unterteilungen erforderlich sind, sondern nur ein Assembler-Div-Befehl, der 2 Zahlen zur√ºckgibt (Quotient und Rest). </p><br><p>  Andere Rundungsoptionen sind etwas komplizierter, k√∂nnen aber auch anhand des Rests und des Divisors berechnet werden. </p><br><p>  In der API habe ich absichtlich die Rundung erw√§hnt, wo immer sie auftritt, entweder als Parameter oder als Rund- <strong>D-</strong> eigenes Suffix in Methoden, bei denen der Standardwert Null ist. </p><br><h1 id="perepolnenie">  √úberlauf </h1><br><p>  Wir kommen zum schwierigsten Teil.  Erinnern Sie sich noch einmal an unsere Multiplikation: </p><br><p>  <em>1,20 * 2,00 = 2,40</em> <br>  <strong>120 * 200/100 = 240</strong> </p><br><p>  Stellen Sie sich jetzt vor, wir sind in den 1980er Jahren und haben 16-Bit-Prozessoren.  Das hei√üt, es steht uns nur Short mit einem Maximalwert von 65535 zur Verf√ºgung. Die erste Multiplikation l√§uft √ºber und ist gleich 240000 &amp; 0xFFFF = 44392 (wenn sie nicht vorzeichenbehaftet ist, mit einem Vorzeichen ist sie auch negativ), was das Ergebnis f√ºr uns bricht. </p><br><p>  Es wird nicht funktionieren.  Wir haben 2 normale Argumente (passen in unseren Wertebereich) und das gleiche normale erwartete Ergebnis, aber wir laufen zur H√§lfte √ºber.  Genau die gleiche Situation ist mit einem 64-Bit-Long'om m√∂glich, nur Zahlen brauchen mehr. </p><br><p>  In den 1980er Jahren w√ºrden wir eine Multiplikation ben√∂tigen, die ein 32-Bit-Ergebnis ergibt.  Heute brauchen wir eine Multiplikation mit einem 128-Bit-Ergebnis.  Am √§rgerlichsten ist, dass beide Multiplikationen in den Assemblern 8086 und x86-64 verf√ºgbar sind, aber wir k√∂nnen sie nicht von Java aus verwenden!  JNI verursacht selbst bei einem Hack mit schnellem JavaCritical einen Overhead von mehreren zehn Nanosekunden, f√ºhrt zu Schwierigkeiten bei der Bereitstellung und Kompatibilit√§t und friert den GC f√ºr die Dauer des Aufrufs ein.  Au√üerdem m√ºssten wir irgendwie ein 128-Bit-Ergebnis von der nativen Methode zur√ºckgeben, und das Schreiben unter Bezugnahme auf ein Array (im Speicher) ist eine zus√§tzliche Verz√∂gerung. </p><br><p>  Im Allgemeinen musste ich manuelle Multiplikation und Division schreiben.  Spalte  Ich brauchte 2 Hilfsoperationen: </p><br><ol><li>  A (64) * B (64) = T (128);  T (128) / N (32) = Q (64), R (32) - als Teil des festen Multiplikationspunktes A * B. </li><li>  N (32) * A (64) = T (96);  T (96) / B (64) = Q (64), R (64) - als Teil der Festpunktteilung A / B. <br>  (In Klammern wird die Dimension der Daten in Bits angegeben. T ist eine tempor√§re Variable, die nicht √ºberlaufen darf.) </li></ol><br><p>  Beide Operationen geben den Quotienten und den Rest zur√ºck (eine als Ergebnis der Methode, die zweite im Objektfeld).  Sie k√∂nnen auch √ºberlaufen, aber nur im letzten Schritt, wenn dies unvermeidlich ist.  Hier ein Beispiel (aus den 1980er Jahren): </p><br><p>  <em>500,00 / 0,50 = 1000,00</em> <br>  <strong>100 * 50.000 / 50 = 100.000</strong> - √úberlauf! </p><br><p>  Die Spaltenteilung a la Knut ist nicht der einfachste Algorithmus.  Au√üerdem sollte es auch relativ schnell sein.  Daher besteht der Code beider Operationen aus Hunderten von Zeilen ziemlich strenger Bitmagie. Ich werde viel Zeit brauchen, um mich wieder daran zu erinnern, was genau dort passiert.  Ich zog sie in eine separate Klasse und kommentierte sie ausf√ºhrlich, so gut ich konnte. </p><br><p>  Der Multiplikationsalgorithmus ist nicht auf das Aufrufen von Operation 1 beschr√§nkt, aber der verbleibende Code ist nicht so kompliziert und f√ºgt nur Unterst√ºtzung f√ºr negative Zahlen, Rundungen und NaN hinzu. </p><br><p>  Normalerweise (au√üer in besonderen F√§llen) enthalten beide Operationen 4 Multiplikationen und 2 Divisionen.  Operation 1 ist deutlich schneller als 2, da diese Unterteilungen darin durch eine Konstante sind. </p><br><p>  √úbrigens, wenn jemand es bemerkt hat, ist N (32) unser 10 ^ N f√ºr die Normalisierung.  Es ist 32-Bit, woraus folgt, dass N maximal 9 sein kann. In den realen Anwendungen, die ich gesehen habe, wurden 2, 4 oder 8 Dezimalstellen verwendet.  Ich habe nicht mehr als 9 gesehen, das sollte also reichen.  Wenn Sie 10 ^ N 64-Bit erstellen, wird der Code noch komplizierter (und verlangsamt sich). </p><br><h1 id="neskolko-raznyh-tochnostey">  Mehrere unterschiedliche Pr√§zision </h1><br><p>  Manchmal ist es notwendig, eine Operation f√ºr Argumente mit einer anderen Anzahl von Dezimalstellen auszuf√ºhren.  Geben Sie mindestens Operationen mit der √ºblichen L√§nge ein. </p><br><p>  Z.B: </p><br><p>  <em>2,0000 (N = 4) + 3,00 (N = 2) = 5,0000 (N = 4)</em> <br>  <strong>20.000 + 300 * 100 = 50.000</strong> </p><br><p>  <em>3,00 (N = 2) + 2,0000 (N = 4) = 5,00 (N = 2)</em> <br>  <strong>300 + 20.000 / 100 = 500</strong> </p><br><p>  In diesem Fall ist eine zus√§tzliche Normalisierung eines der Argumente erforderlich.  Beachten Sie, dass beide Operationen mathematisch √§quivalent sind, aber aufgrund der unterschiedlichen Genauigkeit des Ergebnisses unterschiedlich berechnet werden.  Es ist auch erw√§hnenswert, dass die zweite Operation im Allgemeinen eine Rundung erfordert. </p><br><p>  Die Anzahl der Dezimalstellen wird NICHT im Objekt gespeichert.  Stattdessen wird f√ºr jede Genauigkeit eine separate Unterklasse angenommen.  Klassennamen k√∂nnen gesch√§ftsorientiert sein, z. B. Preis (N = 8), Menge (N = 2).  Und sie k√∂nnen verallgemeinert werden: Dezimal1, Dezimal2, Dezimal3, ... Je gr√∂√üer die Genauigkeit, desto kleiner der Bereich der gespeicherten Werte, desto kleiner ist der Dezimalbereich 9: ¬± 9223372036.  Es wird davon ausgegangen, dass eine oder zwei Klassen ausreichen, um die erforderliche Funktionalit√§t abzudecken. In diesem Fall wird die abstrakte Methode getScale h√∂chstwahrscheinlich devirtualisiert und inline.  Mit Unterklassen (anstelle eines zus√§tzlichen Felds) k√∂nnen Sie die Genauigkeit der Argumente und des Ergebnisses genau angeben und auf m√∂gliche Rundungen in der Kompilierungsphase hinweisen. </p><br><p>  Die Bibliothek erm√∂glicht Operationen mit maximal 2 (aber nicht 3) unterschiedlicher Genauigkeit.  Das hei√üt, entweder muss die Genauigkeit der beiden Argumente √ºbereinstimmen, oder die Genauigkeit eines der Argumente und des Ergebnisses.  Auch hier w√ºrde die Unterst√ºtzung von 3 verschiedenen Genauigkeiten den Code erheblich verlangsamen und die API komplizieren.  Als Argumente k√∂nnen Sie ein regul√§res Long √ºbergeben, f√ºr das eine Genauigkeit von N = 0 angenommen wird. </p><br><p>  <em>2,0000 / 3,0 = 0,6667</em> - ok (2 unterschiedliche Pr√§zision) <br>  <em>2/3 = 0,6667</em> - ok (lange Argumente, Dezimalergebnis) <br>  <em>2 / 3.0 = 0.6667</em> - unm√∂glich!  (3 verschiedene Pr√§zision) </p><br><h1 id="dostoinstva-i-nedostatki">  Vor- und Nachteile </h1><br><p>  Offensichtlich ist das von der Bibliothek durchgef√ºhrte High-Bit-Computing langsamer als das von der Hardware unterst√ºtzte.  Der Overhead ist jedoch nicht so gro√ü (siehe Benchmarks unten). </p><br><p>  Aufgrund der fehlenden √úberladung von Operatoren in Java erschwert die Verwendung von Methoden anstelle von arithmetischen Operatoren die Wahrnehmung von Code. </p><br><p>  Auf dieser Grundlage wird die Bibliothek normalerweise an Orten verwendet, an denen der Verlust der absoluten Genauigkeit kritisch ist.  Zum Beispiel die Berechnung genauer Finanzstatistiken unter Ber√ºcksichtigung aktueller Finanzindikatoren (Handelspositionen, PnL, ausgef√ºhrte Auftr√§ge).  Beim Netzwerkaustausch von Finanzinformationen zwischen Systemen ist es auch bequemer, Formate mit einem Dezimalpunkt (anstelle von bin√§r) zu verwenden. </p><br><p>  Komplexe mathematische Algorithmen (Modellierung, Statistik, Prognose) lassen sich in der Regel standardm√§√üig doppelt doppelt ausf√ºhren, da ihr Ergebnis auf jeden Fall nicht absolut genau ist. </p><br><h1 id="kod-i-benchmarki">  Code und Benchmarks </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code</a> </p><br><table><tbody><tr><th>  Benchmark </th><th>  Modus </th><th>  Cnt </th><th>  Punktzahl </th><th>  Fehler </th><th>  Einheiten <br></th></tr><tr><td>  DecimalBenchmark.control </td><td>  avgt </td><td>  200 </td><td>  10.072 </td><td>  ¬± 0,074 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.multiplyNative </td><td>  avgt </td><td>  200 </td><td>  10.625 </td><td>  ¬± 0,142 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.multiplyMyDecimal </td><td>  avgt </td><td>  200 </td><td>  35.840 </td><td>  ¬± 0,121 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.multiplyBigDecimal </td><td>  avgt </td><td>  200 </td><td>  126.098 </td><td>  ¬± 0,408 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.quotientNative </td><td>  avgt </td><td>  200 </td><td>  70,728 </td><td>  ¬± 0,230 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.quotientMyDecimal </td><td>  avgt </td><td>  200 </td><td>  138,581 </td><td>  ¬± 7,102 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.quotientBigDecimal </td><td>  avgt </td><td>  200 </td><td>  179.650 </td><td>  ¬± 0,849 </td><td>  ns / op <br></td></tr></tbody></table><br><p>  Im Allgemeinen ist die Multiplikation viermal schneller als BigDecimal, die Division 1,5.  Die Teilungsrate h√§ngt <em>stark</em> von den Argumenten ab, daher die Streuung der Werte. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425565/">https://habr.com/ru/post/de425565/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425555/index.html">Charles Nutter √ºber dynamische Sprachen in der JVM unter jug.msk.ru</a></li>
<li><a href="../de425557/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 10: Symbolische Ausf√ºhrung, Teil 1</a></li>
<li><a href="../de425559/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 10: Symbolische Ausf√ºhrung, Teil 3</a></li>
<li><a href="../de425561/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 10: Symbolische Ausf√ºhrung, Teil 2</a></li>
<li><a href="../de425563/index.html">Kalifornien verbietet den Verkauf von IoT-Ger√§ten mit oder ohne einfache Passw√∂rter</a></li>
<li><a href="../de425569/index.html">PCB-Funktionstests</a></li>
<li><a href="../de425571/index.html">Sichern eines Webservers unter Linux</a></li>
<li><a href="../de425575/index.html">Neuroinflammation</a></li>
<li><a href="../de425581/index.html">Jetpack 11. Oktober 1961: Der Pr√§sident √∂ffnete den Mund ...</a></li>
<li><a href="../de425583/index.html">Alles, was Robomobile noch verbl√ºfft, angefangen bei M√∂wen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>