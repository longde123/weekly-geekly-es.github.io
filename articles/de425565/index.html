<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✊🏻 🚵 😐 Schnelle Festkomma-Mathematik für Finanzanwendungen in Java 👩🏼‍🏫 👨🏻‍⚕️ 🧔🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es ist kein Geheimnis, dass Finanzinformationen (Konten, Buchungen und andere Buchhaltung) mit Gleitkommazahlen nicht sehr freundlich sind, und viele ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schnelle Festkomma-Mathematik für Finanzanwendungen in Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425565/"><p>  Es ist kein Geheimnis, dass Finanzinformationen (Konten, Buchungen und andere Buchhaltung) mit Gleitkommazahlen nicht sehr freundlich sind, und viele Artikel empfehlen die Verwendung einer Festkomma-Arithmetik.  In Java wird dieses Format tatsächlich nur durch die BigDecimal-Klasse dargestellt, die aus Leistungsgründen nicht immer verwendet werden kann.  Wir müssen nach Alternativen suchen.  Dieser Artikel beschreibt eine selbstgeschriebene Java-Bibliothek zum Ausführen von arithmetischen Operationen für Zahlen mit fester Genauigkeit.  Die Bibliothek wurde für die Verwendung in leistungsstarken Finanzanwendungen erstellt und ermöglicht es Ihnen, mit einer Genauigkeit von 9 Dezimalstellen zu arbeiten und dabei eine akzeptable Leistung beizubehalten.  Ein Link zu den Quellen und Benchmarks befindet sich am Ende des Artikels. </p><a name="habracut"></a><br><h1 id="arifmetika-s-plavayuschey-tochkoy">  Gleitkomma-Arithmetik </h1><br><p>  Moderne Computer können arithmetische Operationen nur mit begrenzter Genauigkeit ausführen.  Dies sind diskrete Geräte, die möglicherweise nicht mit allen möglichen Zahlen arbeiten, sondern nur mit einer abzählbaren Teilmenge davon.  Das gebräuchlichste Format für die Arbeit mit reellen Zahlen im Computerspeicher ist Gleitkomma (Binärpunkt) - Gleitkomma (Binärpunkt), wenn Zahlen in der Form M * 2 ^ E gespeichert sind, wobei M und E eine ganzzahlige Mantisse und die Reihenfolge der Zahl sind.  Einige Zahlen, wie z. B. 0,1, können in diesem Format jedoch nicht genau dargestellt werden.  Daher häufen sich bei komplexen Berechnungen zwangsläufig einige Fehler an.  Das heißt, das Ergebnis der Maschinenberechnung, beispielsweise 0,1 + 0,1 + 0,1, stimmt nicht mit der mathematisch korrekten 0,3 überein.  In Anbetracht des oben Gesagten können Sie beim Programmieren komplexer Arithmetik verschiedene Strategien verfolgen: </p><br><p>  Strategie 1 - ignorieren.  Ignorieren Sie den Fehler, betrachten Sie alle Operationen als ideal mathematisch und hoffen Sie, dass die verfügbare Genauigkeit für akzeptable Ergebnisse ausreicht.  Die häufigste Option. </p><br><p>  Strategie 2 - akribisch berechnen.  Formeln zur Berechnung von Maschinenfehlern sind seit Jahrzehnten bekannt.  Sie ermöglichen es, den relativen Fehler einer arithmetischen Operation von oben abzuschätzen.  Wahrscheinlich ist dies das, was Sie für eine ernsthafte numerische Simulation tun müssen.  Das Problem ist, dass es sehr zeitaufwändig ist.  Tatsächlich muss jedem + - * / Zeichen im Code eine Fehlerberechnung beigefügt sein.  Sie müssen alle Abhängigkeiten zwischen den Berechnungen berücksichtigen und den Vorgang jedes Mal wiederholen, wenn Sie den Code ändern. </p><br><p>  Strategie 3 - Verwenden Sie einen Dezimalpunkt (Gleitkomma) anstelle eines Binärpunkts.  Speichern Sie die Zahlen in der Form M * 10 ^ E.  Dies löst nicht die Fehlerprobleme (die Mantisse ist immer noch auf eine endliche Anzahl von signifikanten Stellen gerundet), aber zumindest alle „einfachen“ Zahlen für eine Person (wie 1.1) werden jetzt genau im Speicher dargestellt.  Die Rückzahlung wird Leistung sein.  Jede Normalisierung von Zahlen (dh eine äquivalente Abnahme der Mantisse und eine Zunahme der Ordnung) erfordert eine Division durch eine Potenz von 10, was im Gegensatz zu einer Division durch eine Potenz von 2 nicht sehr schnell ist. Und Sie müssen viel normalisieren - bei jeder Addition oder Subtraktion mit unterschiedlichen Ordnungen. </p><br><p>  Strategie 4 - Verwenden Sie einen festen Punkt (festen Dezimalpunkt).  Vereinfachung von Strategie 3, wenn wir die Reihenfolge E festlegen. In diesem Fall ist eine Normalisierung für die Addition / Subtraktion nicht erforderlich.  Außerdem haben alle Berechnungen den gleichen absoluten Fehler.  Dieser Artikel ist dieser Strategie gewidmet. </p><br><h1 id="arifmetika-s-fiksirovannoy-tochkoy">  Festkomma-Arithmetik </h1><br><p>  Im Gegensatz zur Physik, in der relative Fehler wichtig sind, wird im Finanzbereich nur das Absolute benötigt.  Wenn dem Kunden nach einer komplexen Finanztransaktion 1.000.000,23 USD in Rechnung gestellt werden, während er 1.000.000,18 USD erwartet, können einige Schwierigkeiten auftreten.  Erklärungen wie "Warum brauchen Sie Genauigkeit in 8 signifikanten Stellen?"  darf nicht reiten.  Dabei geht es nicht um 5 Cent Verlust (im Gegenteil, „zugunsten“ des Kunden ist nicht viel besser), sondern um Inkonsistenzen in der Rechnungslegung.  Daher sind die Regeln für Berechnungen und Rundungen zwischen den Parteien klar festgelegt, und Artefakte aus der Verwendung von Double- und Float-Variablen erschweren manchmal das Leben. </p><br><p>  Java hat eine Standardklasse für Festkomma-Arithmetik - BigDecimal.  Es gibt zwei Probleme: Es ist langsam (aufgrund seiner Universalität) und es ist nicht stabil.  Nichtstabilität bedeutet, dass jede Operation ein Objekt auf dem Heap zuweist.  Das Auswählen und Freigeben eines Objekts dauert etwas, aber intensive Berechnungen im „heißen“ Code führen zu einer angemessenen Belastung des GC, was in einigen Fällen nicht akzeptabel ist.  Sie können sich auf Escape-Analyse und Skalierung verlassen, aber sie sind sehr instabil in dem Sinne, dass selbst eine geringfügige Änderung des Codes oder der JIT (z. B. das verzögerte Laden einer neuen Schnittstellenimplementierung) die gesamte Inline-Struktur auf den Kopf stellen kann und die Methode vor einer Minute einwandfrei funktioniert hat. plötzlich beginnt wütend Erinnerung zuzuweisen. <br>  UPD aufgrund von Fragen in den Kommentaren: <strong>Der Hauptgrund für den</strong> Verzicht auf BigDecimal und BigInteger ist keineswegs eine geringe Rechenleistung, sondern mangelnde Stabilität und Auswahl von Objekten. </p><br><p>  Die beschriebene Bibliothek ist das Ergebnis der Müdigkeit, die Festkomma-Nicht-Speicher-Arithmetik für jeden neuen Arbeitgeber von Grund auf neu zu schreiben, und ich habe beschlossen, meine eigene Bibliothek für das spätere Insourcing zu schreiben. </p><br><p>  Ich werde sofort ein Anwendungsbeispiel zeigen, bevor ich mit den Implementierungsdetails fortfahre: </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sample</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Decimal margin; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Quantity cumQuantity = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Quantity(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Quantity contraQuantity = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Quantity(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Quantity cumContraQuantity = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Quantity(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Price priceWithMargin = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Price(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Price avgPrice = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Price(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sample</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> marginBp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// 1 + margin / 10000 this.margin = Decimal.create(marginBp).divRD(10000L).add(1); } public Price calculateAvgPrice(Quantity[] quantities, Price[] prices) { cumQuantity.set(0); contraQuantity.set(0); // avg = sum(q * p * margin) / sum(q) for (int i = 0; i &lt; quantities.length; i++) { cumQuantity.add(quantities[i]); priceWithMargin.set(prices[i]).mulRD(margin); contraQuantity.set(quantities[i]).mulRD(priceWithMargin); cumContraQuantity.add(contraQuantity); } return avgPrice.quotientRD(cumContraQuantity, cumQuantity); } public static void main(String[] args) throws ParseException { Price p1 = Price.create("1.5"); Price p2 = Price.create(1.6); Quantity q1 = Quantity.create("100"); Quantity q2 = Quantity.create(200); // apply 0.05% margin to the prices Sample sample = new Sample(5); System.out.println(sample.calculateAvgPrice(new Quantity[]{q1, q2}, new Price[]{p1, p2})); } }</span></span></code> </pre> <br><h1 id="ideya-realizacii">  Implementierungsidee </h1><br><p>  Wir brauchen also einen veränderlichen Wrapper eines ganzzahligen Grundelements, genauer gesagt eines Long'a, der uns fast 19 signifikante Stellen gibt (genug für die Ganzzahl und den Bruchteil).  Langfristig meinen wir N Dezimalstellen.  Beispielsweise wird bei N = 2 die Zahl 2,56 als 256 (binär 100000000) gespeichert.  Negative Zahlen werden standardmäßig in zusätzlichem Code gespeichert: </p><br><p>  <em>-2,56</em> <br>  <strong>-256</strong> </p><br><p>  (Im Folgenden werden <em>kursiv</em> „mathematische“ Zahlen und Berechnungen und <strong>in Fettdruck</strong> ihre interne Darstellung angegeben.) </p><br><p>  Es erschien mir auch nützlich, NaN als separaten Wert einzugeben, der bei Rechenfehlern (anstelle einer Ausnahme oder eines Mülls) zurückgegeben wird.  <em>NaN</em> wird intern als <strong>Long.MIN_VALUE dargestellt</strong> , durch alle Operationen "weitergegeben" und ermöglicht die Bestimmung der Vorzeichenumkehr für alle verbleibenden Zahlen. </p><br><p>  Versuchen wir, die Algorithmen der arithmetischen Operationen für den Fall zu schätzen, in dem N = 2 ist. </p><br><p>  Addition und Subtraktion erfordern keine zusätzlichen Gesten. Verwenden Sie einfach die Werte wie sie sind: </p><br><p>  <em>1,20 + 2,30 = 3,50</em> <br>  <strong>120 + 230 = 350</strong> </p><br><p>  Multiplikation und Division erfordern eine zusätzliche Normalisierung, dh Multiplikation / Division mit 10 ^ N (in unserem Beispiel mit 100). </p><br><p>  <em>1,20 * 2,00 = 2,40</em> <br>  <strong>120 * 200/100 = 240</strong> </p><br><p>  <em>1,20 / 2,00 = 0,60</em> <br>  <strong>100 * 120/200 = 60</strong> </p><br><p>  Zusätzliche Aufteilung ist nicht die schnellste Operation.  In diesem Fall ist dies jedoch eine Division durch eine Konstante, da wir zuvor N = 2 und 10 ^ N = 100 festgelegt haben.  Die Division durch Konstante, insbesondere durch „schön“ (Typ 10), wird in der CPU intensiv optimiert und ist viel schneller als die Division durch eine Zufallszahl.  Wir dividieren jedes Mal durch 10, wenn wir eine Zahl in eine Zeichenfolge konvertieren (z. B. in den Protokollen), und die CPU-Hersteller wissen davon ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">weitere Einzelheiten zu Optimierungen finden</a> Sie unter "Division durch eine Konstante"). </p><br><p>  Um das Verständnis dessen, was wir tun, zu festigen, werde ich noch eine Operation geben: unäre Umkehrung einer Zahl, dh 1 / x.  Dies ist ein Sonderfall der Teilung. Sie müssen nur 1,00 in unserem Format einreichen und vergessen nicht, zu normalisieren: </p><br><p>  <em>1,00 / 2,00 = 0,50</em> <br>  <strong>100 * 100/200 = 50</strong> </p><br><p>  Nun, obwohl alles recht einfach ist, versuchen wir, die Details zu untersuchen. </p><br><h1 id="okruglenie">  Rundung </h1><br><p>  Versuchen wir eine andere Zahl zu ziehen: </p><br><p>  <em>1,00 / 3,00 = 0,33</em> <br>  <strong>100 * 100/300 = 33</strong> </p><br><p>  Ein ehrliches mathematisches Ergebnis liegt zwischen 0,33 und 0,34, aber wir können es uns nicht genau vorstellen.  Welchen Weg umrunden?  Normalerweise auf 0 gerundet, und dies ist der schnellste Weg (Hardware unterstützt).  Zurück zu den tatsächlichen finanziellen Problemen ist dies jedoch nicht immer der Fall.  Bei der Verarbeitung von Transaktionen mit einem Kunden erfolgt die Rundung in der Regel "zugunsten des Kunden".  Das heißt, der Preis wird aufgerundet, wenn der Kunde verkauft, und gesenkt, wenn der Kunde kauft.  Es können jedoch auch andere Optionen erforderlich sein, z. B. das arithmetische Runden auf die nächste Zahl mit Untertypen (halb hoch, halb runter, halb gerade), um Buchhaltungsinkonsistenzen zu minimieren.  Oder für negative Preise auf ± unendlich runden (für einige Finanzinstrumente).  Java BigDecimal enthält bereits eine Liste der Standardrundungsmodi, und die beschriebene Bibliothek unterstützt alle.  UNNECESSARY gibt NaN zurück, wenn der Vorgang unerwartet gerundet werden muss. </p><br><p>  Im Aufrundungsmodus sollte unsere Berechnung Folgendes ergeben: </p><br><p>  <em>1,00 / 3,00 = 0,34</em> <br>  <strong>100 * 100/300 + 1 = 34</strong> </p><br><p>  Wie finde ich heraus, was Sie zum Hinzufügen einer Einheit benötigen?  Sie benötigen den Rest der Division 10.000% 300 = 100. Das ist so langsam wie die Division selbst.  Wenn Sie in einer Zeile in den Code "a / b; a% b" schreiben, erkennt JIT glücklicherweise, dass keine 2 Unterteilungen erforderlich sind, sondern nur ein Assembler-Div-Befehl, der 2 Zahlen zurückgibt (Quotient und Rest). </p><br><p>  Andere Rundungsoptionen sind etwas komplizierter, können aber auch anhand des Rests und des Divisors berechnet werden. </p><br><p>  In der API habe ich absichtlich die Rundung erwähnt, wo immer sie auftritt, entweder als Parameter oder als Rund- <strong>D-</strong> eigenes Suffix in Methoden, bei denen der Standardwert Null ist. </p><br><h1 id="perepolnenie">  Überlauf </h1><br><p>  Wir kommen zum schwierigsten Teil.  Erinnern Sie sich noch einmal an unsere Multiplikation: </p><br><p>  <em>1,20 * 2,00 = 2,40</em> <br>  <strong>120 * 200/100 = 240</strong> </p><br><p>  Stellen Sie sich jetzt vor, wir sind in den 1980er Jahren und haben 16-Bit-Prozessoren.  Das heißt, es steht uns nur Short mit einem Maximalwert von 65535 zur Verfügung. Die erste Multiplikation läuft über und ist gleich 240000 &amp; 0xFFFF = 44392 (wenn sie nicht vorzeichenbehaftet ist, mit einem Vorzeichen ist sie auch negativ), was das Ergebnis für uns bricht. </p><br><p>  Es wird nicht funktionieren.  Wir haben 2 normale Argumente (passen in unseren Wertebereich) und das gleiche normale erwartete Ergebnis, aber wir laufen zur Hälfte über.  Genau die gleiche Situation ist mit einem 64-Bit-Long'om möglich, nur Zahlen brauchen mehr. </p><br><p>  In den 1980er Jahren würden wir eine Multiplikation benötigen, die ein 32-Bit-Ergebnis ergibt.  Heute brauchen wir eine Multiplikation mit einem 128-Bit-Ergebnis.  Am ärgerlichsten ist, dass beide Multiplikationen in den Assemblern 8086 und x86-64 verfügbar sind, aber wir können sie nicht von Java aus verwenden!  JNI verursacht selbst bei einem Hack mit schnellem JavaCritical einen Overhead von mehreren zehn Nanosekunden, führt zu Schwierigkeiten bei der Bereitstellung und Kompatibilität und friert den GC für die Dauer des Aufrufs ein.  Außerdem müssten wir irgendwie ein 128-Bit-Ergebnis von der nativen Methode zurückgeben, und das Schreiben unter Bezugnahme auf ein Array (im Speicher) ist eine zusätzliche Verzögerung. </p><br><p>  Im Allgemeinen musste ich manuelle Multiplikation und Division schreiben.  Spalte  Ich brauchte 2 Hilfsoperationen: </p><br><ol><li>  A (64) * B (64) = T (128);  T (128) / N (32) = Q (64), R (32) - als Teil des festen Multiplikationspunktes A * B. </li><li>  N (32) * A (64) = T (96);  T (96) / B (64) = Q (64), R (64) - als Teil der Festpunktteilung A / B. <br>  (In Klammern wird die Dimension der Daten in Bits angegeben. T ist eine temporäre Variable, die nicht überlaufen darf.) </li></ol><br><p>  Beide Operationen geben den Quotienten und den Rest zurück (eine als Ergebnis der Methode, die zweite im Objektfeld).  Sie können auch überlaufen, aber nur im letzten Schritt, wenn dies unvermeidlich ist.  Hier ein Beispiel (aus den 1980er Jahren): </p><br><p>  <em>500,00 / 0,50 = 1000,00</em> <br>  <strong>100 * 50.000 / 50 = 100.000</strong> - Überlauf! </p><br><p>  Die Spaltenteilung a la Knut ist nicht der einfachste Algorithmus.  Außerdem sollte es auch relativ schnell sein.  Daher besteht der Code beider Operationen aus Hunderten von Zeilen ziemlich strenger Bitmagie. Ich werde viel Zeit brauchen, um mich wieder daran zu erinnern, was genau dort passiert.  Ich zog sie in eine separate Klasse und kommentierte sie ausführlich, so gut ich konnte. </p><br><p>  Der Multiplikationsalgorithmus ist nicht auf das Aufrufen von Operation 1 beschränkt, aber der verbleibende Code ist nicht so kompliziert und fügt nur Unterstützung für negative Zahlen, Rundungen und NaN hinzu. </p><br><p>  Normalerweise (außer in besonderen Fällen) enthalten beide Operationen 4 Multiplikationen und 2 Divisionen.  Operation 1 ist deutlich schneller als 2, da diese Unterteilungen darin durch eine Konstante sind. </p><br><p>  Übrigens, wenn jemand es bemerkt hat, ist N (32) unser 10 ^ N für die Normalisierung.  Es ist 32-Bit, woraus folgt, dass N maximal 9 sein kann. In den realen Anwendungen, die ich gesehen habe, wurden 2, 4 oder 8 Dezimalstellen verwendet.  Ich habe nicht mehr als 9 gesehen, das sollte also reichen.  Wenn Sie 10 ^ N 64-Bit erstellen, wird der Code noch komplizierter (und verlangsamt sich). </p><br><h1 id="neskolko-raznyh-tochnostey">  Mehrere unterschiedliche Präzision </h1><br><p>  Manchmal ist es notwendig, eine Operation für Argumente mit einer anderen Anzahl von Dezimalstellen auszuführen.  Geben Sie mindestens Operationen mit der üblichen Länge ein. </p><br><p>  Z.B: </p><br><p>  <em>2,0000 (N = 4) + 3,00 (N = 2) = 5,0000 (N = 4)</em> <br>  <strong>20.000 + 300 * 100 = 50.000</strong> </p><br><p>  <em>3,00 (N = 2) + 2,0000 (N = 4) = 5,00 (N = 2)</em> <br>  <strong>300 + 20.000 / 100 = 500</strong> </p><br><p>  In diesem Fall ist eine zusätzliche Normalisierung eines der Argumente erforderlich.  Beachten Sie, dass beide Operationen mathematisch äquivalent sind, aber aufgrund der unterschiedlichen Genauigkeit des Ergebnisses unterschiedlich berechnet werden.  Es ist auch erwähnenswert, dass die zweite Operation im Allgemeinen eine Rundung erfordert. </p><br><p>  Die Anzahl der Dezimalstellen wird NICHT im Objekt gespeichert.  Stattdessen wird für jede Genauigkeit eine separate Unterklasse angenommen.  Klassennamen können geschäftsorientiert sein, z. B. Preis (N = 8), Menge (N = 2).  Und sie können verallgemeinert werden: Dezimal1, Dezimal2, Dezimal3, ... Je größer die Genauigkeit, desto kleiner der Bereich der gespeicherten Werte, desto kleiner ist der Dezimalbereich 9: ± 9223372036.  Es wird davon ausgegangen, dass eine oder zwei Klassen ausreichen, um die erforderliche Funktionalität abzudecken. In diesem Fall wird die abstrakte Methode getScale höchstwahrscheinlich devirtualisiert und inline.  Mit Unterklassen (anstelle eines zusätzlichen Felds) können Sie die Genauigkeit der Argumente und des Ergebnisses genau angeben und auf mögliche Rundungen in der Kompilierungsphase hinweisen. </p><br><p>  Die Bibliothek ermöglicht Operationen mit maximal 2 (aber nicht 3) unterschiedlicher Genauigkeit.  Das heißt, entweder muss die Genauigkeit der beiden Argumente übereinstimmen, oder die Genauigkeit eines der Argumente und des Ergebnisses.  Auch hier würde die Unterstützung von 3 verschiedenen Genauigkeiten den Code erheblich verlangsamen und die API komplizieren.  Als Argumente können Sie ein reguläres Long übergeben, für das eine Genauigkeit von N = 0 angenommen wird. </p><br><p>  <em>2,0000 / 3,0 = 0,6667</em> - ok (2 unterschiedliche Präzision) <br>  <em>2/3 = 0,6667</em> - ok (lange Argumente, Dezimalergebnis) <br>  <em>2 / 3.0 = 0.6667</em> - unmöglich!  (3 verschiedene Präzision) </p><br><h1 id="dostoinstva-i-nedostatki">  Vor- und Nachteile </h1><br><p>  Offensichtlich ist das von der Bibliothek durchgeführte High-Bit-Computing langsamer als das von der Hardware unterstützte.  Der Overhead ist jedoch nicht so groß (siehe Benchmarks unten). </p><br><p>  Aufgrund der fehlenden Überladung von Operatoren in Java erschwert die Verwendung von Methoden anstelle von arithmetischen Operatoren die Wahrnehmung von Code. </p><br><p>  Auf dieser Grundlage wird die Bibliothek normalerweise an Orten verwendet, an denen der Verlust der absoluten Genauigkeit kritisch ist.  Zum Beispiel die Berechnung genauer Finanzstatistiken unter Berücksichtigung aktueller Finanzindikatoren (Handelspositionen, PnL, ausgeführte Aufträge).  Beim Netzwerkaustausch von Finanzinformationen zwischen Systemen ist es auch bequemer, Formate mit einem Dezimalpunkt (anstelle von binär) zu verwenden. </p><br><p>  Komplexe mathematische Algorithmen (Modellierung, Statistik, Prognose) lassen sich in der Regel standardmäßig doppelt doppelt ausführen, da ihr Ergebnis auf jeden Fall nicht absolut genau ist. </p><br><h1 id="kod-i-benchmarki">  Code und Benchmarks </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code</a> </p><br><table><tbody><tr><th>  Benchmark </th><th>  Modus </th><th>  Cnt </th><th>  Punktzahl </th><th>  Fehler </th><th>  Einheiten <br></th></tr><tr><td>  DecimalBenchmark.control </td><td>  avgt </td><td>  200 </td><td>  10.072 </td><td>  ± 0,074 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.multiplyNative </td><td>  avgt </td><td>  200 </td><td>  10.625 </td><td>  ± 0,142 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.multiplyMyDecimal </td><td>  avgt </td><td>  200 </td><td>  35.840 </td><td>  ± 0,121 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.multiplyBigDecimal </td><td>  avgt </td><td>  200 </td><td>  126.098 </td><td>  ± 0,408 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.quotientNative </td><td>  avgt </td><td>  200 </td><td>  70,728 </td><td>  ± 0,230 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.quotientMyDecimal </td><td>  avgt </td><td>  200 </td><td>  138,581 </td><td>  ± 7,102 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.quotientBigDecimal </td><td>  avgt </td><td>  200 </td><td>  179.650 </td><td>  ± 0,849 </td><td>  ns / op <br></td></tr></tbody></table><br><p>  Im Allgemeinen ist die Multiplikation viermal schneller als BigDecimal, die Division 1,5.  Die Teilungsrate hängt <em>stark</em> von den Argumenten ab, daher die Streuung der Werte. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425565/">https://habr.com/ru/post/de425565/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425555/index.html">Charles Nutter über dynamische Sprachen in der JVM unter jug.msk.ru</a></li>
<li><a href="../de425557/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 10: Symbolische Ausführung, Teil 1</a></li>
<li><a href="../de425559/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 10: Symbolische Ausführung, Teil 3</a></li>
<li><a href="../de425561/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 10: Symbolische Ausführung, Teil 2</a></li>
<li><a href="../de425563/index.html">Kalifornien verbietet den Verkauf von IoT-Geräten mit oder ohne einfache Passwörter</a></li>
<li><a href="../de425569/index.html">PCB-Funktionstests</a></li>
<li><a href="../de425571/index.html">Sichern eines Webservers unter Linux</a></li>
<li><a href="../de425575/index.html">Neuroinflammation</a></li>
<li><a href="../de425581/index.html">Jetpack 11. Oktober 1961: Der Präsident öffnete den Mund ...</a></li>
<li><a href="../de425583/index.html">Alles, was Robomobile noch verblüfft, angefangen bei Möwen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>