<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõåüèø üëßüèº üë≤üèæ Seg√∫n tengo entendido, como muchos dulces, o la clasificaci√≥n de los productos por cheque en la solicitud üçì ‚òùüèæ üïû</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Desaf√≠o 
 En este art√≠culo, queremos hablar sobre c√≥mo creamos una soluci√≥n para clasificar los nombres de productos de los recibos en la aplicaci√≥n p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Seg√∫n tengo entendido, como muchos dulces, o la clasificaci√≥n de los productos por cheque en la solicitud</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430216/"><h2>  Desaf√≠o </h2><br>  En este art√≠culo, queremos hablar sobre c√≥mo creamos una soluci√≥n para clasificar los nombres de productos de los recibos en la aplicaci√≥n para registrar los gastos de cheques y el asistente de compras.  Quer√≠amos darles a los usuarios la oportunidad de ver estad√≠sticas sobre compras, recopiladas autom√°ticamente sobre la base de recibos escaneados, a saber, distribuir todos los productos comprados por el usuario por categor√≠a.  Porque obligar al usuario a agrupar productos de forma independiente ya es el siglo pasado.  Existen varios enfoques para resolver este problema: puede intentar aplicar algoritmos de agrupamiento con diferentes formas de representaci√≥n vectorial de palabras o algoritmos de clasificaci√≥n cl√°sicos.  No hemos inventado nada nuevo, y en este art√≠culo solo queremos compartir una peque√±a gu√≠a sobre una posible soluci√≥n al problema, ejemplos de c√≥mo no hacerlo, un an√°lisis de por qu√© otros m√©todos no funcionaron y qu√© problemas podr√≠a encontrar en el proceso. <br><a name="habracut"></a><br><h2>  Agrupamiento </h2><br>  Uno de los problemas era que los nombres de los productos que obtenemos de los cheques no siempre son f√°ciles de descifrar, incluso para una persona.  Es poco probable que sepa qu√© tipo de producto con el nombre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"UTRUSTA krnsht"</a> se compr√≥ en una de las tiendas rusas.  Los verdaderos conocedores del dise√±o sueco ciertamente nos responder√°n de inmediato: Soporte para el horno de Utrust, pero mantener a tales especialistas en la sede es bastante costoso.  Adem√°s, no ten√≠amos una muestra etiquetada y preparada adecuada para nuestros datos, en la que pudi√©ramos capacitar al modelo.  Por lo tanto, primero hablaremos sobre c√≥mo, en ausencia de datos para el entrenamiento, aplicamos algoritmos de agrupamiento y por qu√© no nos gust√≥. <br><br>  Dichos algoritmos se basan en la medici√≥n de distancias entre objetos, lo que requiere su representaci√≥n vectorial o el uso de una m√©trica para medir la similitud de las palabras (por ejemplo, la distancia de Levenshtein).  En este paso, la dificultad radica en la representaci√≥n vectorial significativa de los nombres.  Es problem√°tico extraer propiedades de los nombres que describir√°n completa y exhaustivamente el producto y su relaci√≥n con otros productos. <br><br>  La opci√≥n m√°s f√°cil es usar Tf-Idf, pero en este caso la dimensi√≥n del espacio vectorial es bastante grande, y el espacio en s√≠ es escaso.  Adem√°s, este enfoque no extrae ninguna informaci√≥n adicional de los nombres.  Por lo tanto, en un grupo puede haber muchos productos de diferentes categor√≠as, unidos por una palabra com√∫n, como, por ejemplo, "papa" o "ensalada": <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pb/uh/bd/pbuhbdnf0bwmwvy0ywqwapil018.png"></div><br>  Tampoco podemos controlar qu√© grupos se ensamblar√°n.  Lo √∫nico que se puede indicar es la cantidad de cl√∫steres (si se utilizan algoritmos basados ‚Äã‚Äãen picos de no densidad en el espacio).  Pero si especifica una cantidad demasiado peque√±a, se forma un cl√∫ster enorme, que contendr√° todos los nombres que no caben en otros cl√∫steres.  Si especifica uno suficientemente grande, luego de que el algoritmo funcione, tendremos que examinar cientos de cl√∫steres y combinarlos en categor√≠as sem√°nticas a mano. <br><br>  Las siguientes tablas proporcionan informaci√≥n sobre los cl√∫steres que utilizan los algoritmos KMeans y Tf-Idf para la representaci√≥n vectorial.  De estas tablas vemos que las distancias entre los centros de los grupos son menores que la distancia promedio entre los objetos y los centros de los grupos a los que pertenecen.  Dichos datos pueden explicarse por el hecho de que en el espacio de los vectores no hay picos de densidad obvios y los centros de los grupos est√°n ubicados alrededor del c√≠rculo, donde la mayor√≠a de los objetos se encuentran fuera de este c√≠rculo.  Adem√°s, se forma un grupo, que contiene la mayor√≠a de los vectores.  Lo m√°s probable en este grupo son los nombres que contienen palabras que se encuentran con m√°s frecuencia que otras entre todos los productos de diferentes categor√≠as. <br><br><table><caption>  Tabla 1. Distancias entre grupos. </caption><tbody><tr><th>  Racimo </th><th>  C1 </th><th>  C2 </th><th>  C3 </th><th>  C4 </th><th>  C5 </th><th>  C6 </th><th>  C7 </th><th>  C8 </th><th>  C9 </th></tr><tr><th>  C1 </th><td>  0.0 </td><td>  0,502 </td><td>  0.354 </td><td>  0.475 </td><td>  0,481 </td><td>  0,527 </td><td>  0,498 </td><td>  0,501 </td><td>  0,524 </td></tr><tr><th>  C2 </th><td>  0,502 </td><td>  0.0 </td><td>  0.614 </td><td>  0,685 </td><td>  0,696 </td><td>  0,728 </td><td>  0,706 </td><td>  0,709 </td><td>  0,725 </td></tr><tr><th>  C3 </th><td>  0.354 </td><td>  0.614 </td><td>  0.0 </td><td>  0,590 </td><td>  0,597 </td><td>  0.635 </td><td>  0.610 </td><td>  0.613 </td><td>  0.632 </td></tr><tr><th>  C4 </th><td>  0.475 </td><td>  0,685 </td><td>  0,590 </td><td>  0.0 </td><td>  0,673 </td><td>  0,709 </td><td>  0,683 </td><td>  0,687 </td><td>  0.699 </td></tr><tr><th>  C5 </th><td>  0,481 </td><td>  0,696 </td><td>  0,597 </td><td>  0,673 </td><td>  0.0 </td><td>  0,715 </td><td>  0,692 </td><td>  0,694 </td><td>  0.711 </td></tr><tr><th>  C6 </th><td>  0,527 </td><td>  0,727 </td><td>  0.635 </td><td>  0,709 </td><td>  0,715 </td><td>  0.0 </td><td>  0,726 </td><td>  0,728 </td><td>  0,741 </td></tr><tr><th>  C7 </th><td>  0,498 </td><td>  0,706 </td><td>  0.610 </td><td>  0,683 </td><td>  0,692 </td><td>  0,725 </td><td>  0.0 </td><td>  0,707 </td><td>  0,714 </td></tr><tr><th>  C8 </th><td>  0,501 </td><td>  0,709 </td><td>  0.612 </td><td>  0,687 </td><td>  0,694 </td><td>  0,728 </td><td>  0,707 </td><td>  0.0 </td><td>  0,725 </td></tr><tr><th>  C9 </th><td>  0,524 </td><td>  0,725 </td><td>  0.632 </td><td>  0.699 </td><td>  0.711 </td><td>  0,741 </td><td>  0,714 </td><td>  0,725 </td><td>  0.0 </td></tr></tbody></table><br><table><caption>  Tabla 2. Informaci√≥n breve sobre cl√∫steres </caption><tbody><tr><th>  Racimo </th><th>  Numero de objetos </th><th>  Distancia media </th><th>  Distancia minima </th><th>  Distancia m√°xima </th></tr><tr><th>  C1 </th><td>  62530 </td><td>  0,999 </td><td>  0,041 </td><td>  1.001 </td></tr><tr><th>  C2 </th><td>  2159 </td><td>  0.864 </td><td>  0,527 </td><td>  0.964 </td></tr><tr><th>  C3 </th><td>  1099 </td><td>  0.934 </td><td>  0,756 </td><td>  0,993 </td></tr><tr><th>  C4 </th><td>  1292 </td><td>  0.879 </td><td>  0,733 </td><td>  0.980 </td></tr><tr><th>  C5 </th><td>  746 </td><td>  0.875 </td><td>  0,731 </td><td>  0.965 </td></tr><tr><th>  C6 </th><td>  2451 </td><td>  0.847 </td><td>  0,719 </td><td>  0,994 </td></tr><tr><th>  C7 </th><td>  1133 </td><td>  0.866 </td><td>  0,724 </td><td>  0,996 </td></tr><tr><th>  C8 </th><td>  876 </td><td>  0.863 </td><td>  0,704 </td><td>  0,999 </td></tr><tr><th>  C9 </th><td>  1879 </td><td>  0.849 </td><td>  0,526 </td><td>  0,981 </td></tr></tbody></table><br><br>  Pero en algunos lugares los grupos resultan ser bastante decentes, como, por ejemplo, en la imagen a continuaci√≥n: casi todos los productos son comida para gatos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oh/uy/5p/ohuy5p_bgiignp9ah_gokvvbzs4.png"></div><br><br>  Doc2Vec es otro de los algoritmos que le permiten representar textos en forma vectorial.  Usando este enfoque, cada nombre ser√° descrito por un vector de menor dimensi√≥n que usando Tf-Idf.  En el espacio vectorial resultante, los textos similares estar√°n cerca uno del otro, y los diferentes estar√°n muy lejos. <br><br>  Este enfoque puede resolver el problema de gran dimensi√≥n y espacio descargado obtenido por el m√©todo Tf-Idf.  Para este algoritmo, utilizamos la opci√≥n m√°s simple de tokenizaci√≥n: dividimos el nombre en palabras separadas y tomamos sus formas iniciales.  Fue entrenado en datos de esta manera: <br><br><pre><code class="python hljs">max_epochs = <span class="hljs-number"><span class="hljs-number">100</span></span> vec_size = <span class="hljs-number"><span class="hljs-number">20</span></span> alpha = <span class="hljs-number"><span class="hljs-number">0.025</span></span> model = doc2vec.Doc2Vec(vector_size=vec_size, alpha=alpha, min_alpha=<span class="hljs-number"><span class="hljs-number">0.00025</span></span>, min_count=<span class="hljs-number"><span class="hljs-number">1</span></span>, dm =<span class="hljs-number"><span class="hljs-number">1</span></span>) model.build_vocab(train_corpus) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> epoch <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(max_epochs): print(<span class="hljs-string"><span class="hljs-string">'iteration {0}'</span></span>.format(epoch)) model.train(train_corpus, total_examples=model.corpus_count, epochs=model.iter) <span class="hljs-comment"><span class="hljs-comment"># decrease the learning rate model.alpha -= 0.0002 # fix the learning rate, no decay model.min_alpha = model.epochs</span></span></code> </pre> <br>  Pero con este enfoque, obtuvimos vectores que no llevan informaci√≥n sobre el nombre; con el mismo √©xito, puede usar valores aleatorios.  Aqu√≠ hay un ejemplo del funcionamiento del algoritmo: la imagen muestra productos similares en la opini√≥n del algoritmo al "pan Borodino de la forma n pn 0.45k". <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qd/m9/lp/qdm9lplwaidbilivtpb3jjskopo.png"></div><br>  Quiz√°s el problema est√© en la longitud y el contexto de los nombres: el pase en el nombre "__ club. Banana 200ml" puede ser yogurt, jugo o una lata grande de crema.  Puede lograr un mejor resultado utilizando un enfoque diferente para la tokenizaci√≥n de nombres.  No ten√≠amos experiencia en el uso de este m√©todo, y cuando los primeros intentos fallaron, ya encontramos un par de conjuntos marcados con nombres de productos, por lo que decidimos abandonar temporalmente este m√©todo y cambiar a algoritmos de clasificaci√≥n. <br><br><h2>  Clasificaci√≥n </h2><br><h3>  Preprocesamiento de datos </h3><br>  Los nombres de los productos de los cheques nos llegan de una manera no siempre clara: el lat√≠n y el cir√≠lico se mezclan en palabras.  Por ejemplo, la letra "a" se puede reemplazar por "a" en lat√≠n, y esto aumenta el n√∫mero de nombres √∫nicos; por ejemplo, las palabras "leche" y "leche" se considerar√°n diferentes.  Los nombres tambi√©n contienen muchos otros errores tipogr√°ficos y abreviaturas. <br><br>  Examinamos nuestra base de datos y encontramos errores t√≠picos en los nombres.  En esta etapa, prescindimos de las expresiones regulares, con la ayuda de las cuales limpiamos los nombres y los llevamos a una cierta visi√≥n general.  Con este enfoque, el resultado aumenta aproximadamente un 7%.  Junto con una opci√≥n simple de clasificador SGD basada en la funci√≥n de p√©rdida de Huber con par√°metros retorcidos, obtuvimos una precisi√≥n del 81% para F1 (precisi√≥n promedio para todas las categor√≠as de productos). <br><br><pre> <code class="python hljs">sgd_model = SGDClassifier() parameters_sgd = { <span class="hljs-string"><span class="hljs-string">'max_iter'</span></span>:[<span class="hljs-number"><span class="hljs-number">100</span></span>], <span class="hljs-string"><span class="hljs-string">'loss'</span></span>:[<span class="hljs-string"><span class="hljs-string">'modified_huber'</span></span>], <span class="hljs-string"><span class="hljs-string">'class_weight'</span></span>:[<span class="hljs-string"><span class="hljs-string">'balanced'</span></span>], <span class="hljs-string"><span class="hljs-string">'penalty'</span></span>:[<span class="hljs-string"><span class="hljs-string">'l2'</span></span>], <span class="hljs-string"><span class="hljs-string">'alpha'</span></span>:[<span class="hljs-number"><span class="hljs-number">0.0001</span></span>] } sgd_cv = GridSearchCV(sgd_model, parameters_sgd,n_jobs=<span class="hljs-number"><span class="hljs-number">-1</span></span>) sgd_cv.fit(tf_idf_data, prod_cat) sgd_cv.best_score_, sgd_cv.best_params_</code> </pre> <br>  Adem√°s, no olvide que algunas categor√≠as de personas compran con m√°s frecuencia que otras: por ejemplo, "T√© y dulces" y "Verduras y frutas" son mucho m√°s populares que "Servicios" y "Cosm√©ticos".  Con tal distribuci√≥n de datos, es mejor usar algoritmos que le permitan establecer pesos (grado de importancia) para cada clase.  El peso de la clase se puede determinar inversamente con el valor igual a la relaci√≥n entre el n√∫mero de productos en la clase y el n√∫mero total de productos.  Pero no tiene que pensarlo, porque en la implementaci√≥n de estos algoritmos, es posible determinar autom√°ticamente el peso de las categor√≠as. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ty/o9/pk/tyo9pkfhw-ibby5jopobc5okotc.png"></div><br><h2>  Obteniendo nuevos datos para entrenamiento </h2><br>  Nuestra aplicaci√≥n requer√≠a categor√≠as ligeramente diferentes a las que se usaron en la competencia, y los nombres de los productos de nuestra base de datos fueron significativamente diferentes de los presentados en el concurso.  Por lo tanto, necesit√°bamos marcar los productos de nuestros recibos.  Intentamos hacer esto por nuestra cuenta, pero nos dimos cuenta de que incluso si conectamos a todo nuestro equipo, tomar√° mucho tiempo.  Por lo tanto, decidimos usar el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Toloka" de Yandex</a> . <br><br>  All√≠ usamos esta forma de asignaci√≥n: <br><br><ul><li>  en cada celda presentamos un producto, cuya categor√≠a debe definirse </li><li>  su hipot√©tica categor√≠a definida por uno de nuestros modelos anteriores </li><li>  campo de respuesta (si la categor√≠a propuesta era incorrecta) </li></ul><br>  Creamos instrucciones detalladas con ejemplos que explicaban las caracter√≠sticas de cada categor√≠a, y tambi√©n utilizamos m√©todos de control de calidad: un conjunto con respuestas est√°ndar que se mostraban junto con las tareas habituales (implementamos las respuestas est√°ndar nosotros mismos, marcando varios cientos de productos).  Seg√∫n los resultados de las respuestas a estas tareas, los usuarios que marcaron incorrectamente los datos fueron eliminados.  Sin embargo, para todo el proyecto, prohibimos solo tres de los m√°s de 600 usuarios. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fx/ib/xt/fxibxt-v5h7vouodjoffwtl6egy.png"></div><br>  Con los nuevos datos, obtuvimos un modelo que mejor se adaptaba a nuestros datos, y la precisi√≥n aument√≥ un poco m√°s (en ~ 11%) y ya obtuvo un 92%. <br><br><h2>  Modelo final </h2><br>  Comenzamos el proceso de clasificaci√≥n con una combinaci√≥n de datos de varios conjuntos de datos con Kaggle - 74%, despu√©s de lo cual mejoramos el preprocesamiento - 81%, recopilamos un nuevo conjunto de datos - 92% y finalmente mejoramos el proceso de clasificaci√≥n: inicialmente, usando regresi√≥n log√≠stica obtenemos probabilidades preliminares de bienes pertenecientes SGD dio mayor precisi√≥n a las categor√≠as basadas en los nombres de los productos, pero a√∫n ten√≠a grandes valores en las funciones de p√©rdida, lo que afect√≥ gravemente los resultados del clasificador final.  Adem√°s, combinamos los datos obtenidos con otros datos sobre el producto (precio del producto, la tienda en la que fue comprado, estad√≠sticas de la tienda, cheque y otra metainformaci√≥n), y XGBoost est√° capacitado en todo este volumen de datos, lo que dio una precisi√≥n del 98% (aumento otro 6%).  Al final result√≥ que, la mayor contribuci√≥n fue hecha por la calidad de la muestra de capacitaci√≥n. <br><br><h2>  Corriendo en el servidor </h2><br>  Para acelerar la implementaci√≥n, creamos un servidor simple en Flask to Docker.  Hubo un m√©todo que recibi√≥ bienes del servidor que necesitaba ser categorizado y ya devolvi√≥ bienes con categor√≠as.  Por lo tanto, nos integramos f√°cilmente en el sistema existente, cuyo centro era Tomcat, y no tuvimos que hacer cambios en la arquitectura, solo le agregamos un bloque m√°s. <br><br><h2>  Fecha de lanzamiento </h2><br>  Hace unas semanas publicamos un lanzamiento de categorizaci√≥n en Google Play (aparecer√° en la App Store despu√©s de un tiempo).  Result√≥ as√≠: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h1/tj/ie/h1tjiekixykrb_liuwftfnd8ufy.png" width="50%"></div><br>  En futuras versiones, planeamos agregar la capacidad de corregir categor√≠as, lo que nos permitir√° recopilar r√°pidamente errores de categorizaci√≥n y volver a entrenar el modelo de categorizaci√≥n (mientras lo hacemos nosotros mismos). <br><br>  Concursos mencionados en Kaggle: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">www.kaggle.com/c/receipt-categorisation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">www.kaggle.com/c/market-basket-analysis</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">www.kaggle.com/c/prod-price-prediction</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es430216/">https://habr.com/ru/post/es430216/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es430204/index.html">Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 18: "Navegaci√≥n privada en Internet", Parte 1</a></li>
<li><a href="../es430206/index.html">Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 18: Navegaci√≥n privada en Internet, Parte 2</a></li>
<li><a href="../es430208/index.html">Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 18: "Navegaci√≥n privada en Internet", parte 3</a></li>
<li><a href="../es430210/index.html">Pon a prueba mi paciencia por Check Point Security Academy</a></li>
<li><a href="../es430212/index.html">OpenSceneGraph: conceptos b√°sicos de la geometr√≠a de la escena</a></li>
<li><a href="../es430218/index.html">Optimizaci√≥n de energ√≠a STM32: una gu√≠a pr√°ctica</a></li>
<li><a href="../es430220/index.html">C√≥mo convertir un hub usb "centenario" en un dispositivo inteligente administrado y ahorrar $ 300</a></li>
<li><a href="../es430222/index.html">Ingeniero Senior en busca de trabajo. C√≥mo pas√© por 20 entrevistas con RRHH y lo que pienso al respecto</a></li>
<li><a href="../es430224/index.html">Trastorno esquizot√≠pico: una mirada al interior</a></li>
<li><a href="../es430226/index.html">De var b a entrevista</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>