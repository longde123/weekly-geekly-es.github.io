<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüë©‚Äçüë¶‚Äçüë¶ üíÉüèª ü¶Ö DMA: mythes et r√©alit√© ü¶Ä üíº ü§µüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√©sentation 
 Dans un article pr√©c√©dent ( ¬´Partie 2: Utilisation de blocs UDB Cypress PSoC pour r√©duire le nombre d'interruptions dans une imprimante...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>DMA: mythes et r√©alit√©</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437112/"><img src="https://habrastorage.org/webt/m4/12/q3/m412q3b8zbug620xzvv0the7ix0.jpeg"><br><br><h2>  Pr√©sentation </h2><br>  Dans un article pr√©c√©dent ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´Partie 2: Utilisation de blocs UDB Cypress PSoC pour r√©duire le nombre d'interruptions dans une imprimante 3D¬ª</a> ), j'ai not√© un fait tr√®s int√©ressant: si une machine dans UDB supprimait trop rapidement des donn√©es de FIFO, elle r√©ussissait √† remarquer l'√©tat qu'il y avait de nouvelles il n'y a pas de donn√©es dans FIFO, apr√®s quoi elles passent dans un faux √©tat <b>Idle</b> .  Bien s√ªr, j'√©tais int√©ress√© par ce fait.  J'ai montr√© les r√©sultats ouverts √† un groupe de connaissances.  Une personne a r√©pondu que tout cela √©tait tout √† fait √©vident et a m√™me cit√© les raisons.  Les autres n'√©taient pas moins surpris que moi au d√©but de la recherche.  Certains experts ne trouveront donc rien de nouveau ici, mais ce serait bien de porter ces informations √† la disposition du grand public afin que tous les programmeurs de microcontr√¥leurs les aient en t√™te. <br><a name="habracut"></a><br>  Non pas que ce soit une panne d'une sorte de couverture.  Il s'est av√©r√© que tout cela est bien document√©, mais le probl√®me est que ce n'est pas dans l'ensemble, mais dans des documents suppl√©mentaires.  Et personnellement, j'√©tais dans une ignorance heureuse, croyant que le DMA est un sous-syst√®me tr√®s agile qui peut augmenter consid√©rablement l'efficacit√© des programmes, car il y a un transfert syst√©matique de donn√©es sans distraire l'incr√©ment de registre et organiser le cycle avec les m√™mes commandes.  Quant √† l'am√©lioration de l'efficacit√© - tout est vrai, mais en raison de choses l√©g√®rement diff√©rentes. <br><br>  Mais tout d'abord. <br><br><h2>  Exp√©riences avec Cypress PSoC </h2><br>  Faisons une machine simple.  Il aura conditionnellement deux √©tats: l'√©tat inactif et l'√©tat dans lequel il tombera lorsqu'il y aura au moins un octet de donn√©es dans FIFO.  En entrant dans cet √©tat, il prendra simplement ces donn√©es, puis √©chouera √† nouveau dans un √©tat de repos.  Le mot ¬´conditionnel¬ª que je n'ai pas cit√© accidentellement.  Nous avons deux FIFO, donc je vais cr√©er deux de ces √©tats, un pour chaque FIFO, pour m'assurer qu'ils sont compl√®tement identiques dans leur comportement.  Le graphique de transition pour la machine s'est av√©r√© comme ceci: <br><br><img src="https://habrastorage.org/webt/pv/cu/1q/pvcu1qmbxk9zkbgxk8u51unthpe.png"><br><br>  Les indicateurs de sortie de l'√©tat inactif sont d√©finis comme suit: <br><br><img src="https://habrastorage.org/webt/h8/re/rp/h8rerphupbsfvawmjiwgwqr_thw.png"><br><br>  N'oubliez pas de soumettre les bits du num√©ro d'√©tat aux entr√©es Datapath: <br><br><img src="https://habrastorage.org/webt/ze/dz/ab/zedzab8iuaoxnu0esg32xwwga3g.png"><br><br>  √Ä l'ext√©rieur, nous √©mettons deux groupes de signaux: une paire de signaux que FIFO a de l'espace libre (pour que DMA puisse commencer √† y t√©l√©charger des donn√©es), et quelques signaux que FIFO est vide (pour afficher ce fait sur un oscilloscope). <br><br><img src="https://habrastorage.org/webt/ts/bm/dn/tsbmdn-puyugsmixnsipf81pboa.png"><br><br>  ALU prendra simplement fictivement des donn√©es de FIFO: <br><br><img src="https://habrastorage.org/webt/px/5s/_w/px5s_wj1zqwjedrk0h7ty7tbu_4.png"><br><br>  Permettez-moi de vous montrer les d√©tails de l'√©tat "0001": <br><br><img src="https://habrastorage.org/webt/mb/-s/j0/mb-sj05-chkdijmqn3mue8hmjnk.png"><br><br>  J'ai √©galement r√©gl√© la largeur du bus, qui √©tait dans le projet sur lequel j'ai remarqu√© cet effet, 16 bits: <br><br><img src="https://habrastorage.org/webt/sa/hc/br/sahcbrgearj6wnw5-4lykaew1qy.png"><br><br>  Nous passons au sch√©ma du projet lui-m√™me.  Ext√©rieurement, je donne non seulement des signaux indiquant que le FIFO est vide, mais aussi des impulsions d'horloge.  Cela me permettra de me passer de mesures de curseur sur un oscilloscope.  Je peux simplement prendre des mesures avec mon doigt. <br><br><img src="https://habrastorage.org/webt/b-/8v/iq/b-8viqzbm1isamdkiljvmwevwme.png"><br><br>  Apparemment, j'ai fait une vitesse d'horloge de 24 m√©gahertz.  La fr√©quence centrale du processeur est exactement la m√™me.  Plus la fr√©quence est basse, moins il y a d'interf√©rences sur un oscilloscope chinois (officiellement il a une bande de 250 MHz, mais ensuite des m√©gahertz chinois), et toutes les mesures seront effectu√©es par rapport aux impulsions d'horloge.  Quelle que soit la fr√©quence, le syst√®me fonctionnera toujours √† leur √©gard.  J'aurais r√©gl√© un m√©gahertz, mais l'environnement de d√©veloppement m'a interdit d'entrer une valeur de fr√©quence centrale de processeur inf√©rieure √† 24 MHz. <br><br>  Maintenant, le test.  Pour √©crire sur FIFO0, j'ai fait cette fonction: <br><br><pre><code class="plaintext hljs">void WriteTo0FromROM() { static const uint16 steps[] = { 0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001, 0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001 }; //  DMA  ,      uint8 channel = DMA_0_DmaInitialize (sizeof(steps[0]),1,HI16(steps),HI16(JustReadFromFIFO_1_Datapath_1_F0_PTR)); CyDmaChRoundRobin (channel,1); //       ,       uint8 td = CyDmaTdAllocate(); //       .  ,    . CyDmaTdSetConfiguration(td, sizeof(steps), CY_DMA_DISABLE_TD, TD_INC_SRC_ADR / TD_AUTO_EXEC_NEXT); //       CyDmaTdSetAddress(td, LO16((uint32)steps), LO16((uint32)JustReadFromFIFO_1_Datapath_1_F0_PTR)); //      CyDmaChSetInitialTd(channel, td); //         CyDmaChEnable(channel, 1); }</code> </pre> <br>  Le mot ROM dans le nom de la fonction est d√ª au fait que le tableau √† envoyer est stock√© dans la zone ROM, et le Cortex M3 a une architecture Harvard.  La vitesse d'acc√®s au bus RAM et au bus ROM peut varier, je voulais le v√©rifier, j'ai donc une fonction similaire pour envoyer un tableau depuis la RAM (le tableau des <b>√©tapes</b> n'a pas de modificateur de <b>const statique</b> dans son corps).  Eh bien, il y a la m√™me paire de fonctions pour l'envoi vers FIFO1, le registre r√©cepteur y est diff√©rent: pas F0, mais F1.  Sinon, toutes les fonctions sont identiques.  Comme je n'ai pas remarqu√© beaucoup de diff√©rence dans les r√©sultats, je consid√©rerai les r√©sultats de l'appel exact de la fonction ci-dessus.  Une impulsion d'horloge jaune, sortie bleue <b>FIFO0empty</b> . <br><br><img src="https://habrastorage.org/webt/ko/65/0j/ko650jp1nj58h1nm5dzal4bzdhw.png"><br><br>  Tout d'abord, v√©rifiez la plausibilit√© de la raison pour laquelle la FIFO est remplie sur deux cycles d'horloge.  Voyons ce site plus en d√©tail: <br><br><img src="https://habrastorage.org/webt/ox/fi/x_/oxfix_l8jpspyxgbiumrlagm9ma.png"><br><br>  Sur le bord 1, les donn√©es tombent dans FIFO, le drapeau <b>FIFO0enmpty</b> tombe.  Sur le bord 2, l'automate entre dans l'√©tat <b>GetDataFromFifo1</b> .  Au bord 3, dans cet √©tat, les donn√©es de FIFO sont copi√©es dans le registre ALU, FIFO est vid√©, le drapeau <b>FIFO0empty</b> est de nouveau <b>lev√©</b> .  Autrement dit, la forme d'onde se comporte de mani√®re plausible, vous pouvez compter sur elle le cycle d'horloge.  Nous obtenons 9 pi√®ces. <br><br><img src="https://habrastorage.org/webt/fc/mq/bj/fcmqbjhfee7mf7u7_xnkgyspq18.png"><br><br>  <b>Au total, dans la zone inspect√©e, il faut 9 cycles d'horloge pour copier un mot de donn√©es de la RAM vers l'UDB en utilisant le DMA.</b> <br><br>  Et maintenant la m√™me chose, mais avec l'aide du c≈ìur du processeur.  Tout d'abord, un code id√©al difficilement r√©alisable dans la vie r√©elle: <br><br><pre> <code class="plaintext hljs"> volatile uint16_t* ptr = (uint16_t*)JustReadFromFIFO_1_Datapath_1_F0_PTR; ptr[0] = 0; ptr[0] = 0;</code> </pre><br>  ce qui va se transformer en code assembleur: <br><br><pre> <code class="plaintext hljs"> ldr r3, [pc, #8] ; (90 &lt;main+0xc&gt;) movs r2, #0 strh r2, [r3, #0] strh r2, [r3, #0] bn 8e &lt;main+0xa&gt; .word 0x40006898</code> </pre><br>  Pas de pauses, pas de cycles suppl√©mentaires.  Deux paires de mesures d'affil√©e ... <br><br><img src="https://habrastorage.org/webt/ms/po/gq/mspogqifm21mt0o34s0ltbh1fyu.png"><br><br>  Rendons le code un peu plus r√©el (avec la surcharge d'organisation du cycle, la r√©cup√©ration des donn√©es et l'incr√©mentation des pointeurs): <br><br><pre> <code class="plaintext hljs">void SoftWriteTo0FromROM() { //         . //         static const uint16 steps[] = { 0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001, 0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001 }; uint16_t* src = steps; volatile uint16_t* dest = (uint16_t*)JustReadFromFIFO_1_Datapath_1_F0_PTR; for (int i=sizeof(steps)/sizeof(steps[0]);i&gt;0;i--) { *dest = *src++; } }</code> </pre><br>  code assembleur re√ßu: <br><br><pre> <code class="plaintext hljs"> ldr r3, [pc, #14] ; (9c &lt;CYDEV_CACHE_SIZE&gt;) ldr r0, [pc, #14] ; (a0 &lt;CYDEV_CACHE_SIZE+0x4&gt;) add.w r1, r3, #28 ; 0x28 ldrh.w r2, [r3], #2 cmp r3, r1 strh r2, [r0, #0] bne.n 8e &lt;main+0xa&gt;</code> </pre><br>  Sur l'oscillogramme, nous ne voyons que 7 cycles par cycle contre neuf dans le cas du DMA: <br><br><img src="https://habrastorage.org/webt/h5/5k/y0/h55ky0f4pfsfaco90dvfgahwwki.png"><br><br><h2>  Un peu de mythe </h2><br>  Pour √™tre honn√™te, ce fut √† l'origine un choc pour moi.  Je suis en quelque sorte habitu√© √† croire que le m√©canisme DMA vous permet de transf√©rer des donn√©es rapidement et efficacement.  1/9 de la fr√©quence du bus n'est pas si rapide.  Mais il s'est av√©r√© que personne ne le cachait.  Le document TRM pour PSoC 5LP contient m√™me un certain nombre de consid√©rations th√©oriques, et le document ¬´AN84810 - Sujets DMA avanc√©s PSoC 3 et PSoC 5LP¬ª d√©crit en d√©tail le processus d'acc√®s √† DMA.  La latence est √† bl√¢mer.  Le cycle d'√©change avec le bus prend un certain nombre de ticks.  En effet, ce sont ces mesures qui jouent un r√¥le d√©terminant dans la survenance d'un retard.  En g√©n√©ral, personne ne cache rien, mais vous devez le savoir. <br><br>  <b>Si le fameux GPIF utilis√© dans FX2LP (une autre architecture fabriqu√©e par Cypress) ne limite rien, alors la limite de vitesse est due aux latences qui se produisent lors de l'acc√®s au bus.</b> <br><br><h2>  V√©rification DMA sur STM32 </h2><br>  J'√©tais tellement impressionn√© que j'ai d√©cid√© de mener une exp√©rience sur STM32.  Un STM32F103 ayant le m√™me noyau de processeur Cortex M3 a √©t√© pris comme lapin exp√©rimental.  Il n'a pas d'UDB √† partir duquel des signaux de service pourraient √™tre d√©riv√©s, mais il est tout √† fait possible de v√©rifier le DMA.  Qu'est-ce qu'un GPIO?  Il s'agit d'un ensemble de registres dans un espace d'adressage commun.  C‚Äôest bien.  Nous configurons le DMA en mode de copie ¬´m√©moire-m√©moire¬ª, en sp√©cifiant la m√©moire r√©elle (ROM ou RAM) comme source, et le registre de donn√©es GPIO sans l'incr√©ment d'adresse comme r√©cepteur.  Nous y enverrons alternativement 0 ou 1, et fixerons le r√©sultat avec un oscilloscope.  Pour commencer, j'ai choisi le port B, c'√©tait plus facile de s'y connecter sur la maquette. <br><br><img src="https://habrastorage.org/webt/od/u2/es/odu2esatrpusmpi8od4ecfaftk8.png"><br><br>  J'ai vraiment aim√© compter les mesures avec un doigt, pas avec des curseurs.  Est-il possible de faire de m√™me sur ce contr√¥leur?  Tout √† fait!  Prenez la fr√©quence d'horloge de r√©f√©rence pour l'oscilloscope de la jambe MCO, qui est connect√©e au port PA8 sur le STM32F10C8T6.  Le choix des sources pour ce cristal pas cher n'est pas g√©nial (le m√™me STM32F103, mais plus impressionnant, il donne bien plus d'options), nous enverrons un signal SYSCLK √† cette sortie.  √âtant donn√© que la fr√©quence sur le MCO ne peut pas √™tre sup√©rieure √† 50 MHz, nous r√©duirons la vitesse d'horloge globale du syst√®me √† 48 MHz.  Nous multiplierons la fr√©quence du quartz 8 MHz non par 9, mais par 6 (puisque 6 * 8 = 48): <br><br><img src="https://habrastorage.org/webt/0x/de/1a/0xde1acpu3rpgslyseaw2kcysc4.png"><br><br><div class="spoiler">  <b class="spoiler_title">M√™me texte:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void SystemClock_Config(void) { RCC_OscInitTypeDef RCC_OscInitStruct; RCC_ClkInitTypeDef RCC_ClkInitStruct; RCC_PeriphCLKInitTypeDef PeriphClkInit; /**Initializes the CPU, AHB and APB busses clocks */ RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; // RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9; RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL6; if (HAL_RCC_OscConfig(&amp;RCC_OscInitStruct) != HAL_OK) { _Error_Handler(__FILE__, __LINE__); }</code> </pre><br></div></div><br>  Nous programmerons l'AGC en utilisant la biblioth√®que <b>mcucpp</b> de Konstantin Chizhov (√† partir de maintenant je conduirai tous les appels √† l'√©quipement via cette merveilleuse biblioth√®que): <br><br><pre> <code class="plaintext hljs"> //  MCO Mcucpp::Clock::McoBitField::Set (0x4); //   MCO    Mcucpp::IO::Pa8::SetConfiguration (Mcucpp::IO::Pa8::Port::AltFunc); //     Mcucpp::IO::Pa8::SetSpeed (Mcucpp::IO::Pa8::Port::Fastest);</code> </pre><br>  Eh bien, maintenant, nous d√©finissons la sortie du tableau de donn√©es dans le GPIOB: <br><br><pre> <code class="plaintext hljs">typedef Mcucpp::IO::Pb0 dmaTest0; typedef Mcucpp::IO::Pb1 dmaTest1; ... //  GPIOB      dmaTest0::ConfigPort::Enable(); dmaTest0::SetDirWrite(); dmaTest1::ConfigPort::Enable(); dmaTest1::SetDirWrite(); uint16_t dataForDma[]={0x0000,0x8001,0x0000,0x8001,0x0000, 0x8001,0x0000,0x8001,0x0000,0x8001,0x0000,0x8001,0x0000,0x8001}; typedef Mcucpp::Dma1Channel1 channel; //    dmaTest1::Set(); dmaTest1::Clear(); dmaTest1::Set(); // ,    DMA channel::Init (channel::Mem2Mem|channel::MSize16Bits|channel::PSize16Bits|channel::PeriphIncriment,(void*)&amp;GPIOB-&gt;ODR,dataForDma,sizeof(dataForDma)/2); while (1) { } }</code> </pre><br>  La forme d'onde r√©sultante est tr√®s similaire √† celle du PSoC. <br><br><img src="https://habrastorage.org/webt/ee/nl/2i/eenl2ix0_9zgzgaaxxeffbjzwjk.png"><br><br>  Au milieu, une grande bosse bleue.  Il s'agit du processus d'initialisation DMA.  Les impulsions bleues de gauche ont √©t√© re√ßues uniquement par logiciel sur PB1.  √âtirez-les plus large: <br><br><img src="https://habrastorage.org/webt/9l/y8/tp/9ly8tp_8hj1vohrh6jcnyktfa_a.png"><br><br>  2 mesures par impulsion.  Le fonctionnement du syst√®me est conforme aux attentes.  Mais maintenant, regardons la plus grande zone marqu√©e sur la forme d'onde principale avec un fond bleu fonc√©.  √Ä ce stade, le bloc DMA est d√©j√† en cours d'ex√©cution. <br><br><img src="https://habrastorage.org/webt/jw/fu/ds/jwfudsdqtgwfunc3htoczgrw5eg.png"><br><br>  10 cycles par changement de ligne GPIO.  En fait, le travail va de pair avec la RAM et le programme est boucl√© dans un cycle constant.  Il n'y a aucun appel √† la RAM depuis le c≈ìur du processeur.  Le bus est compl√®tement √† la disposition de l'unit√© DMA, mais 10 cycles.  Mais en fait, les r√©sultats ne sont pas tr√®s diff√©rents de ceux vus sur le PSoC, alors commencez simplement √† chercher des notes d'application li√©es √† DMA sur STM32.  Il y en avait plusieurs.  Il y a AN2548 sur F0 / F1, il y a AN3117 sur L0 / L1 / L3, il y a AN4031 sur F2 / F4 / F77.  Il y en a peut-√™tre d'autres ... <br><br>  Mais, n√©anmoins, nous voyons qu‚Äôici aussi, la latence est √† bl√¢mer.  De plus, l'acc√®s par lots F103 au bus avec DMA est impossible.  Ils sont possibles pour F4, mais pas plus que pour quatre mots.  L√† encore, le probl√®me de latence se posera. <br><br>  Essayons d'ex√©cuter les m√™mes actions, mais √† l'aide d'un enregistrement de programme.  Ci-dessus, nous avons vu que l'enregistrement direct sur les ports se fait instantan√©ment.  Mais le record √©tait plut√¥t parfait.  Rang√©es: <br><br><pre> <code class="plaintext hljs">//    dmaTest1::Set(); dmaTest1::Clear(); dmaTest1::Set();</code> </pre><br>  sous r√©serve de ces param√®tres d'optimisation (vous devez sp√©cifier l'optimisation pour le temps): <br><br><img src="https://habrastorage.org/webt/zz/cs/vt/zzcsvtte2m06u7tzhkfefvfa8wg.png"><br><br>  transform√© en code assembleur suivant: <br><br><pre> <code class="plaintext hljs"> STR r6,[r2,#0x00] MOV r0,#0x20000 STR r0,[r2,#0x00] STR r6,[r2,#0x00]</code> </pre><br>  Dans la copie r√©elle, il y aura un appel √† la source, au r√©cepteur, un changement dans la variable de boucle, une ramification ... En g√©n√©ral, beaucoup de surcharge (ce qui, comme on le croit, soulage simplement le DMA).  Quelle sera la vitesse des changements dans le port?  Nous √©crivons donc: <br><br><pre> <code class="plaintext hljs">uint16_t* src = dataForDma; uint16_t* dest = (uint16_t*)&amp;GPIOB-&gt;ODR; for (int i=sizeof(dataForDma)/sizeof(dataForDma[0]);i&gt;0;i--) { *dest = *src++; }</code> </pre><br>  Ce code C ++ se transforme en un tel code d'assembly: <br><br><pre> <code class="plaintext hljs"> MOVS r1,#0x0E LDRH r3,[r0],#0x02 STRH r3,[r2,#0x00] LDRH r3,[r0],#0x02 SUBS r1,r1,#2 STRH r3,[r2,#0x00] CMP r1,#0x00 BGT 0x080032A8</code> </pre><br>  Et nous obtenons: <br><br><img src="https://habrastorage.org/webt/oj/m5/1d/ojm51d2qjhkz_rii2zfb4zvzdos.png"><br><br>  8 mesures dans le demi-cycle sup√©rieur et 6 dans la moiti√© inf√©rieure (j'ai v√©rifi√©, le r√©sultat est r√©p√©t√© pour toutes les demi-p√©riodes).  La diff√©rence est survenue car l'optimiseur a effectu√© 2 copies par it√©ration.  Par cons√©quent, 2 mesures dans l'une des demi-p√©riodes s'ajoutent √† l'activit√© de la succursale. <br><br>  <b>En gros, avec la copie de logiciels, 14 mesures sont d√©pens√©es pour copier deux mots contre 20 mesures sur le m√™me, mais par DMA.</b>  <b>Le r√©sultat est assez document√©, mais tr√®s inattendu pour ceux qui n'ont pas encore lu la litt√©rature √©tendue.</b> <br><br>  Bon.  Mais que se passe-t-il si vous commencez √† √©crire des donn√©es dans deux flux DMA √† la fois?  Quelle vitesse va chuter?  Connectez le rayon bleu √† PA0 et r√©√©crivez le programme comme suit: <br><br><pre> <code class="plaintext hljs">typedef Mcucpp::Dma1Channel1 channel1; typedef Mcucpp::Dma1Channel2 channel2; // ,    DMA channel1::Init (channel1::Mem2Mem|channel1::MSize16Bits|channel1::PSize16Bits|channel1::PeriphIncriment,(void*)&amp;GPIOB-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel2::Init (channel2::Mem2Mem|channel2::MSize16Bits|channel2::PSize16Bits|channel2::PeriphIncriment,(void*)&amp;GPIOA-&gt;ODR,dataForDma,sizeof(dataForDma)/2);</code> </pre><br>  Examinons d'abord la nature des impulsions: <br><br><img src="https://habrastorage.org/webt/vu/ki/pg/vukipghxkaqqtxdnvz4a2qjp1wu.png"><br><br>  Pendant que le deuxi√®me canal est r√©gl√©, la vitesse de copie du premier est plus √©lev√©e.  Ensuite, lors de la copie par paire, la vitesse diminue.  Lorsque le premier canal est termin√©, le second commence √† fonctionner plus rapidement.  Tout est logique, il ne reste plus qu'√† savoir exactement combien la vitesse baisse. <br><br>  Bien qu'il n'y ait qu'un seul canal, l'enregistrement prend de 10 √† 12 mesures (les chiffres flottent). <br><br><img src="https://habrastorage.org/webt/iw/1l/lk/iw1llkwh0nki1yczmva7gzxgrgk.png"><br><br>  Pendant la collaboration, nous obtenons 16 cycles par enregistrement dans chaque port: <br><br><img src="https://habrastorage.org/webt/f6/vf/o3/f6vfo3mgv4mpos2kdrrwmo9dzsm.png"><br><br>  Autrement dit, la vitesse n'est pas r√©duite de moiti√©.  Mais que faire si vous commencez √† √©crire en trois fils √† la fois?  Nous ajoutons du travail avec PC15, car PC0 n'est pas sorti (c'est pourquoi pas 0, 1, 0, 1 ..., mais 0x0000,0x8001, 0x0000, 0x8001 ... sont √©mis dans le tableau). <br><br><pre> <code class="plaintext hljs">typedef Mcucpp::Dma1Channel1 channel1; typedef Mcucpp::Dma1Channel2 channel2; typedef Mcucpp::Dma1Channel3 channel3; // ,    DMA channel1::Init (channel1::Mem2Mem|channel1::MSize16Bits|channel1::PSize16Bits|channel1::PeriphIncriment,(void*)&amp;GPIOB-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel2::Init (channel2::Mem2Mem|channel2::MSize16Bits|channel2::PSize16Bits|channel2::PeriphIncriment,(void*)&amp;GPIOA-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel3::Init (channel3::Mem2Mem|channel3::MSize16Bits|channel3::PSize16Bits|channel3::PeriphIncriment,(void*)&amp;GPIOC-&gt;ODR,dataForDma,sizeof(dataForDma)/2);</code> </pre><br>  Ici, le r√©sultat est tellement inattendu que j'√©teins le faisceau affichant la fr√©quence d'horloge.  Nous n'avons pas de temps pour les mesures.  Nous regardons la logique du travail. <br><br><img src="https://habrastorage.org/webt/zo/u3/5s/zou35sqtetrlryln8lxe04tdkwy.png"><br><br>  Jusqu'√† ce que la premi√®re cha√Æne ait termin√© ses travaux, la troisi√®me n'a pas commenc√© √† fonctionner.  Trois canaux en m√™me temps ne fonctionnent pas!  Quelque chose sur ce sujet peut √™tre d√©duit d'AppNote √† DMA, il dit que F103 n'a que deux moteurs dans un bloc (et nous copions en utilisant un bloc de DMA, le second est maintenant inactif et le volume de l'article est d√©j√† tel que je peux l'utiliser) Je ne le ferai pas).  Nous r√©√©crivons l'exemple de programme afin que le troisi√®me canal d√©marre plus t√¥t que tout le monde: <br><br><img src="https://habrastorage.org/webt/bs/ld/kc/bsldkce9ztqrbk15x7e1omcharg.png"><br><br><div class="spoiler">  <b class="spoiler_title">M√™me texte:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">// ,    DMA channel3::Init (channel3::Mem2Mem|channel3::MSize16Bits|channel3::PSize16Bits|channel3::PeriphIncriment,(void*)&amp;GPIOC-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel1::Init (channel1::Mem2Mem|channel1::MSize16Bits|channel1::PSize16Bits|channel1::PeriphIncriment,(void*)&amp;GPIOB-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel2::Init (channel2::Mem2Mem|channel2::MSize16Bits|channel2::PSize16Bits|channel2::PeriphIncriment,(void*)&amp;GPIOA-&gt;ODR,dataForDma,sizeof(dataForDma)/2);</code> </pre><br></div></div><br>  L'image changera comme suit: <br><br><img src="https://habrastorage.org/webt/jg/wr/_2/jgwr_2kidbaoxg_-17muiyvo3n4.png"><br><br>  La troisi√®me cha√Æne a √©t√© lanc√©e, elle a m√™me collabor√© avec la premi√®re, mais √† mesure que la deuxi√®me est entr√©e dans l'entreprise, la troisi√®me a √©t√© supplant√©e jusqu'√† ce que la premi√®re cha√Æne soit termin√©e. <br><br><h2>  Un peu de priorit√©s </h2><br>  En fait, l'image pr√©c√©dente est li√©e aux priorit√©s de DMA, il y en a.  Si tous les canaux de travail ont la m√™me priorit√©, leurs num√©ros entrent en jeu.  Dans une priorit√© donn√©e, celle qui en a le plus petit nombre est celle qui a la priorit√©.  Essayons le troisi√®me canal pour indiquer une priorit√© globale diff√©rente, en l'√©levant au-dessus de tous les autres (en cours de route, nous augmenterons √©galement la priorit√© du deuxi√®me canal): <br><br><img src="https://habrastorage.org/webt/40/qo/c5/40qoc5ngwnq2tenzpmcc2ornd4w.png"><br><br><div class="spoiler">  <b class="spoiler_title">M√™me texte:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">channel3::Init (channel3::PriorityVeryHigh|channel3::Mem2Mem|channel3::MSize16Bits|channel3::PSize16Bits|channel3::PeriphIncriment,(void*)&amp;GPIOC-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel1::Init (channel1::Mem2Mem|channel1::MSize16Bits|channel1::PSize16Bits|channel1::PeriphIncriment,(void*)&amp;GPIOB-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel2::Init (channel1::PriorityVeryHigh|channel2::Mem2Mem|channel2::MSize16Bits|channel2::PSize16Bits|channel2::PeriphIncriment,(void*)&amp;GPIOA-&gt;ODR,dataForDma,sizeof(dataForDma)/2);</code> </pre><br></div></div><br>  D√©sormais, le premier qui √©tait le plus cool sera d√©savantag√©. <br><br><img src="https://habrastorage.org/webt/te/mq/_7/temq_7wguw109a0t-oi_rsi3jju.png"><br><br>  Au total, nous voyons que m√™me en jouant dans les priorit√©s, STM32F103 ne peut pas lancer plus de deux threads sur un bloc DMA.  En principe, le troisi√®me thread peut √™tre ex√©cut√© sur le c≈ìur du processeur.  Cela nous permettra de comparer les performances. <br><br><pre> <code class="plaintext hljs">// ,    DMA channel3::Init (channel3::Mem2Mem|channel3::MSize16Bits|channel3::PSize16Bits|channel3::PeriphIncriment,(void*)&amp;GPIOC-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel2::Init (channel2::Mem2Mem|channel2::MSize16Bits|channel2::PSize16Bits|channel2::PeriphIncriment,(void*)&amp;GPIOA-&gt;ODR,dataForDma,sizeof(dataForDma)/2); uint16_t* src = dataForDma; uint16_t* dest = (uint16_t*)&amp;GPIOB-&gt;ODR; for (int i=sizeof(dataForDma)/sizeof(dataForDma[0]);i&gt;0;i--) { *dest = *src++; }</code> </pre><br>  Tout d'abord, l'image g√©n√©rale, qui montre que tout fonctionne en parall√®le et que le c≈ìur du processeur a la vitesse de copie la plus √©lev√©e: <br><br><img src="https://habrastorage.org/webt/yq/bc/ah/yqbcahagnawdxrr70dh7zvbetmo.png"><br><br>  Et maintenant, je vais donner √† chacun la possibilit√© de compter les mesures √† un moment o√π tous les flux de copie sont actifs: <br><br> <a href=""><img src="https://habrastorage.org/webt/_m/m9/2b/_mm92b5yfgjltz6cizilmdtg4d4.png"></a> <br><br><h2>  Le c≈ìur du processeur priorise tous </h2><br>  Revenons maintenant au fait que pendant le fonctionnement √† deux threads, alors que le deuxi√®me canal √©tait r√©gl√©, le premier donnait des donn√©es pour un nombre diff√©rent de cycles d'horloge.  Ce fait est √©galement bien document√© dans AppNote sur DMA.  Le fait est que lors de la configuration du deuxi√®me canal, des demandes √† la RAM ont √©t√© p√©riodiquement envoy√©es, et le c≈ìur du processeur a une priorit√© plus √©lev√©e lors de l'acc√®s √† la RAM que le c≈ìur DMA.  Lorsque le processeur a demand√© des donn√©es, le DMA a supprim√© les cycles d'horloge, il a re√ßu les donn√©es avec un retard, par cons√©quent, il a copi√© plus lentement.  Faisons la derni√®re exp√©rience pour aujourd'hui.  Apportons le travail √† un plus r√©el.  Apr√®s le d√©marrage de DMA, nous n'entrerons pas dans un cycle vide (lorsqu'il n'y a certainement pas d'acc√®s √† la RAM), mais effectuerons une op√©ration de copie de la RAM vers la RAM, mais cette op√©ration ne concernera pas le fonctionnement des c≈ìurs DMA: <br><br><pre> <code class="plaintext hljs">channel1::Init (channel1::Mem2Mem|channel1::MSize16Bits|channel1::PSize16Bits|channel1::PeriphIncriment,(void*)&amp;GPIOB-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel2::Init (channel2::Mem2Mem|channel2::MSize16Bits|channel2::PSize16Bits|channel2::PeriphIncriment,(void*)&amp;GPIOA-&gt;ODR,dataForDma,sizeof(dataForDma)/2); uint32_t src1[0x200]; uint32_t dest1 [0x200]; while (1) { uint32_t* src = src1; uint32_t* dest = dest1; for (int i=sizeof(src1)/sizeof(src1[0]);i&gt;0;i--) { *dest++ = *src++; } }</code> </pre><br> <a href=""><img src="https://habrastorage.org/webt/ks/k-/c6/ksk-c6feobygy2krzseq0nlka78.png"></a> <br><br>  √Ä certains endroits, le cycle s'√©tendait de 16 √† 17 mesures.  J'avais peur que ce soit pire. <br><br><h2>  Commencez √† tirer des conclusions </h2><br>  En fait, nous nous tournons vers ce que je voulais dire. <br><br>  Je pars de loin.  Il y a quelques ann√©es, en commen√ßant √† √©tudier STM32, j'ai √©tudi√© les versions de MiddleWare pour USB qui existaient √† l'√©poque et je me suis demand√© pourquoi les d√©veloppeurs avaient supprim√© le transfert de donn√©es via DMA.  Il √©tait √©vident qu'au d√©part, une telle option √©tait en vue, puis elle a √©t√© retir√©e dans les arri√®re-cours, et √† la fin il n'y a eu que des rudiments.  Maintenant, je commence √† soup√ßonner que je comprends les d√©veloppeurs. <br><br>  Dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">premier article sur UDB,</a> j'ai dit que m√™me si UDB peut fonctionner avec des donn√©es parall√®les, il est peu probable qu'il puisse remplacer GPIF par lui-m√™me, car le bus USB PSoC fonctionne √† pleine vitesse par rapport √† haute vitesse pour FX2LP.  Il s'av√®re qu'il existe un facteur limitant plus s√©rieux.  DMA n'a tout simplement pas le temps de fournir des donn√©es √† la m√™me vitesse que le GPIF, m√™me au sein du contr√¥leur, sans tenir compte du bus USB. <br><br>  Comme vous pouvez le voir, il n'y a pas de DMA d'entit√© unique.  Tout d'abord, chaque fabricant fait sa propre voie.  Non seulement cela, m√™me un fabricant pour diff√©rentes familles peut varier l'approche de la construction de DMA.  Si vous pr√©voyez de charger s√©rieusement cet appareil, vous devez soigneusement examiner si les besoins seront satisfaits. <br><br>  Probablement, il est n√©cessaire de diluer le flux pessimiste avec une remarque optimiste.  Je vais m√™me la mettre en valeur. <br><br>  <b>Les contr√¥leurs DMA des Cortex M vous permettent d'augmenter les performances du syst√®me sur le principe des fameux Javelins: ¬´Lancez et oubliez¬ª.</b>  <b>Oui, la copie de donn√©es par logiciel est un peu plus rapide.</b>  <b>Mais si vous avez besoin de copier plusieurs threads, aucun optimiseur ne peut faire en sorte que le processeur les pilote tous sans la surcharge des boucles de rechargement et de rotation des registres.</b>  <b>De plus, pour les ports lents, le processeur doit toujours attendre la disponibilit√©, et DMA le fait au niveau mat√©riel.</b> <br><br>  Mais m√™me ici, diverses nuances sont possibles.  Si le port n'est que relativement lent ... Eh bien, disons, un SPI fonctionnant √† la fr√©quence la plus √©lev√©e possible, alors il y a th√©oriquement des situations o√π le DMA n'a pas le temps de collecter des donn√©es √† partir du tampon et un d√©bordement se produit.  Ou vice versa - mettez les donn√©es dans le registre tampon.  Lorsque le flux de donn√©es est unique, il est peu probable que cela se produise, mais quand il y en a beaucoup, nous avons vu quelles superpositions √©tonnantes peuvent se produire.  Pour y faire face, vous devez d√©velopper des t√¢ches non pas s√©par√©ment, mais en combinaison.  Et les testeurs essaient de provoquer de tels probl√®mes (un travail si destructeur pour les testeurs). <br><br>  Encore une fois, personne ne cache ces donn√©es.  Mais pour une raison quelconque, tout cela n'est g√©n√©ralement pas contenu dans le document principal, mais dans les notes d'application.  Ma t√¢che √©tait donc d'attirer l'attention des programmeurs sur le fait que le DMA n'est pas une panac√©e, mais juste un outil pratique. <br><br>  Mais, bien s√ªr, non seulement les programmeurs, mais aussi les d√©veloppeurs de mat√©riel.  Disons que dans notre organisation, un grand complexe logiciel et mat√©riel est en cours de d√©veloppement pour le d√©bogage √† distance des syst√®mes embarqu√©s.  L'id√©e est que quelqu'un d√©veloppe un appareil, mais veut commander le ¬´firmware¬ª sur le c√¥t√©.  Et pour une raison quelconque, ne peut pas fournir d'√©quipement sur le c√¥t√©.  Il peut √™tre volumineux, il peut √™tre co√ªteux, il peut √™tre unique et ¬´vous en avez besoin¬ª, diff√©rents groupes peuvent travailler avec lui dans diff√©rents fuseaux horaires, fournissant une sorte de travail √† plusieurs √©quipes, il peut √™tre constamment √©voqu√© ... En g√©n√©ral, vous pouvez trouver des raisons beaucoup, notre groupe a laiss√© cette t√¢che pour acquise. <br><br>  En cons√©quence, le complexe de d√©bogage devrait √™tre capable de simuler autant de p√©riph√©riques externes que possible, de la simulation triviale des pressions de boutons aux diff√©rents protocoles SPI, I2C, CAN, 4-20 mA et autres, pour que, gr√¢ce √† eux, les √©mulateurs puissent recr√©er diff√©rents comportements des externes blocs connect√©s √† l'√©quipement en cours de d√©veloppement (j'ai personnellement fait √† un moment donn√© beaucoup de simulateurs pour le d√©bogage au sol des accessoires pour h√©licopt√®res, sur notre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">site Web les cas correspondants sont recherch√©s par le mot Cassel Aero</a> ). <br><br>  Et donc, dans les exigences techniques pour le d√©veloppement de certaines exigences.  Tant de SPI, tant d'I2C, tant de GPIO.  Ils doivent fonctionner √† telles et telles fr√©quences extr√™mes.  Tout semble clair.  Nous avons mis STM32F4 et ULPI pour travailler avec USB en mode HS.  La technologie est √©prouv√©e.  Mais voici un long week-end avec les vacances de novembre, que j'ai d√©couvert avec UDB.  Voir que quelque chose n'allait pas, le soir, j'ai obtenu les r√©sultats pratiques qui sont donn√©s au d√©but de cet article.  Et j'ai r√©alis√© que tout, bien s√ªr, √©tait super, mais pas pour ce projet.  Comme je l'ai d√©j√† not√©, lorsque les performances maximales possibles du syst√®me approchent de la limite sup√©rieure, tout doit √™tre con√ßu non pas s√©par√©ment, mais dans un complexe. <br><br>  Mais ici, la conception int√©gr√©e des t√¢ches ne peut pas √™tre en principe.       ,  ‚Äî   .           .    ,         FTDI.    --      ,       USB .  H√©las.        DMA. , , ,    ,      ‚Äì  ,   . <br><br>   .        DMA   (,    10:    1    , ,    1 ,  10  )     . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr437112/">https://habr.com/ru/post/fr437112/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr437102/index.html">Nouvelle rencontre de champions Lego: Lego Boost</a></li>
<li><a href="../fr437104/index.html">Introscope: enfin, tests unitaires tr√®s paresseux</a></li>
<li><a href="../fr437106/index.html">IT dans la zone .it</a></li>
<li><a href="../fr437108/index.html">La plupart des textes sur Internet sont √©crits par des fous.</a></li>
<li><a href="../fr437110/index.html">Les nanomat√©riaux changent notre monde et nous n'avons toujours pas de proc√©dures pour v√©rifier leur s√©curit√©</a></li>
<li><a href="../fr437114/index.html">Webinaire ouvert: ¬´SSH / NC / Socat: trucs et astuces¬ª</a></li>
<li><a href="../fr437116/index.html">AWS, MongoDB et les r√©alit√©s √©conomiques de l'open source</a></li>
<li><a href="../fr437118/index.html">AI et 2048. Partie 1: M√©thode Monte Carlo</a></li>
<li><a href="../fr437120/index.html">Chaise de bureau cor√©enne: sensations Harachair Miracle</a></li>
<li><a href="../fr437122/index.html">Nommer les choses</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>