<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üå† ü§õüèø üßÄ Libro "{No sabes JS} Tipos y construcciones gramaticales" üè§ üë© ü§æüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Independientemente de la experiencia de programaci√≥n de JavaScript que tenga, lo m√°s probable es que no comprenda completamente el lenguaje. Esta gu√≠a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Libro "{No sabes JS} Tipos y construcciones gramaticales"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/456730/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/un/r1/ll/unr1llifhhvkguhuc2sq4tll6ly.jpeg" align="left" alt="imagen"></a>  Independientemente de la experiencia de programaci√≥n de JavaScript que tenga, lo m√°s probable es que no comprenda completamente el lenguaje.  Esta gu√≠a concisa explora los tipos m√°s profundamente que todos los libros existentes: aprender√° c√≥mo funcionan los tipos, los problemas de su conversi√≥n y aprender√° a usar nuevas funciones. <br><br>  Al igual que otros libros de la serie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"You Don't Know JS"</a> , muestra aspectos no triviales del lenguaje de los que los programadores de JavaScript prefieren mantenerse alejados (o suponen que no existen).  Armado con este conocimiento, lograr√° un verdadero dominio de JavaScript. <br><a name="habracut"></a><br><h3>  Extracto  La igualdad es estricta y no estricta. </h3><br>  La igualdad no estricta es verificada por el operador ==, y la igualdad estricta por el operador ===.  Ambos operadores se utilizan para comparar dos valores de "igualdad", pero la elecci√≥n de la forma (estricta / no estricta) conduce a diferencias muy importantes en el comportamiento, especialmente en la forma en que se toma la decisi√≥n sobre la igualdad. <br><br>  Hay una idea err√≥nea com√∫n sobre estos dos operadores: "== verifica la igualdad de valor y === verifica la igualdad de ambos valores y tipos".  Suena razonable <br>  pero inexacto  Innumerables libros y blogs de JavaScript de buena reputaci√≥n dicen exactamente eso, pero desafortunadamente todos est√°n equivocados. <br><br>  La descripci√≥n correcta es: "== permite la conversi√≥n de tipos cuando se verifica la igualdad, y === proh√≠be la conversi√≥n de tipos". <br><br><h3>  Rendimiento de verificaci√≥n de igualdad </h3><br>  Detente y piensa en c√≥mo la primera explicaci√≥n (imprecisa) difiere de la segunda (exacta). <br>  En la primera explicaci√≥n, parece obvio que el operador === hace m√°s trabajo que == porque tambi√©n necesita verificar el tipo. <br><br>  En la segunda explicaci√≥n, el operador == hace m√°s trabajo, porque con diferentes tipos tiene que pasar por la conversi√≥n de tipos. <br><br>  No caigas en la trampa en la que muchos caen.  No piense que esto afectar√° de alguna manera la velocidad del programa, y ‚Äã‚Äã== ser√° significativamente m√°s lento ===.  Aunque la conversi√≥n lleva algo de tiempo, lleva una cuesti√≥n de microsegundos (s√≠, millon√©simas de segundo). <br><br>  Si est√° comparando dos valores del mismo tipo, == y === use el mismo algoritmo, por lo que si no tiene en cuenta las peque√±as diferencias en la implementaci√≥n del motor, deben realizar uno <br>  y el mismo trabajo <br><br>  Si est√° comparando dos valores de diferentes tipos, el rendimiento no es un factor importante.  Tiene que preguntarse algo m√°s: si estoy comparando dos valores, ¬øquiero que ocurra la conversi√≥n de tipos o no? <br><br>  Si necesita una conversi√≥n, use igualdad no estricta ==, y si la conversi√≥n no es deseable, use igualdad estricta ===. <br><br><blockquote>  Ambos operadores, == y ===, verifican los tipos de sus operandos.  La diferencia es c√≥mo responden a la falta de coincidencia de tipos. </blockquote><br><h3>  Verificaci√≥n de igualdad abstracta </h3><br>  El comportamiento del operador == se define en la secci√≥n 11.9.3 de la especificaci√≥n ES5 ("Algoritmo de verificaci√≥n de igualdad abstracta").  Aqu√≠ hay un algoritmo detallado pero simple, con una lista expl√≠cita de todas las combinaciones posibles de tipos y m√©todos de conversi√≥n de tipos (si es necesario) que deben aplicarse en cada combinaci√≥n. <br><br><blockquote> Cuando alguien condena la conversi√≥n de tipo (impl√≠cita) como demasiado compleja y contiene demasiados defectos para un uso pr√°ctico √∫til, condena las reglas de la "verificaci√≥n de igualdad abstracta".  Por lo general, se dice que este mecanismo es demasiado complicado y poco natural para el estudio y uso pr√°cticos, y que crea errores en los programas JS en lugar de simplificar la lectura del c√≥digo. <br><br>  Creo que esta es una suposici√≥n err√≥nea, porque ustedes, lectores, son desarrolladores competentes que escriben algoritmos, es decir, c√≥digo (y tambi√©n lo leen y entienden), todo el d√≠a.  Por esta raz√≥n, tratar√© de explicar la "prueba de igualdad abstracta" en palabras simples.  Sin embargo, tambi√©n recomiendo leer la secci√≥n 11.9.3 de la especificaci√≥n ES5.  Creo que te sorprender√° lo l√≥gico que est√° todo all√≠. </blockquote><br>  De hecho, la primera secci√≥n (11.9.3.1) establece que si dos valores comparados son del mismo tipo, se comparan de una manera simple y natural.  Por ejemplo, 42 es solo 42, y la cadena "abc" es solo "abc". <br><br>  Algunas excepciones menores a tener en cuenta: <br><br><ul><li>  El valor de NaN nunca es igual a s√≠ mismo (ver cap√≠tulo 2). </li><li>  +0 y -0 son iguales entre s√≠ (ver cap√≠tulo 2). </li></ul><br>  La √∫ltima secci√≥n en la secci√≥n 11.9.3.1 est√° dedicada a una prueba rigurosa de == igualdad con objetos (incluidas funciones y matrices).  Dos de estos valores son iguales <i>solo</i> si ambos se refieren exactamente al <i>mismo valor</i> .  No se realiza conversi√≥n de tipo. <br><br><blockquote>  Una verificaci√≥n de igualdad estricta === se define de manera id√©ntica a 11.9.3.1, incluida la provisi√≥n para dos valores de objeto.  Este hecho es muy poco conocido, pero == y === se comportan completamente id√©nticos al comparar dos objetos. </blockquote><br>  El resto del algoritmo en 11.9.3 indica que la igualdad suelta == se puede usar para comparar dos tipos diferentes de valores, uno o ambos requerir√°n <br>  conversi√≥n impl√≠cita  Como resultado de la conversi√≥n, las designaciones se convierten a un tipo, despu√©s de lo cual se pueden comparar directamente para la igualdad por identidad simple <br>  valores <br><br><blockquote>  ¬°La operaci√≥n de un control d√©bil de la desigualdad! = Se determina exactamente como uno esperar√≠a;  de hecho, la operaci√≥n == est√° completamente implementada, seguida del c√°lculo <br>  negaci√≥n de resultado.  ¬°Lo mismo se aplica a la operaci√≥n de verificar estrictamente la desigualdad! ==. </blockquote><br><h3>  Comparaci√≥n: cadenas y n√∫meros </h3><br>  Para demostrar la conversi√≥n de ==, primero cree ejemplos de cadenas y n√∫meros, que se realiz√≥ anteriormente en este cap√≠tulo: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-string"><span class="hljs-string">"42"</span></span>; a === b; <span class="hljs-comment"><span class="hljs-comment">// false a == b; // true</span></span></code> </pre> <br>  Como se esperaba, la comprobaci√≥n a === b falla porque la conversi√≥n no est√° permitida y los valores 42 y "42" son diferentes. <br><br>  Sin embargo, en la segunda comparaci√≥n a == b, se utiliza la igualdad no estricta;  Esto significa que si los tipos son diferentes, el algoritmo de comparaci√≥n realizar√° una conversi√≥n impl√≠cita de uno <br>  o ambos <br><br>  Pero, ¬øqu√© tipo de conversi√≥n se realiza aqu√≠?  ¬øEl valor a, es decir, 42, se convertir√° en una cadena, o el valor b "42" se convertir√° en un n√∫mero?  La especificaci√≥n ES5 en las secciones 11.9.3.4‚Äì5 dice: <br><br><ol><li>  Si Tipo (x) es de tipo N√∫mero y Tipo (y) es de tipo Cadena, devuelve el resultado de la comparaci√≥n x == ToNumber (y). </li><li>  Si Tipo (x) es de tipo Cadena y Tipo (y) es de tipo N√∫mero, devuelva el resultado de la comparaci√≥n ToNumber (x) == y. </li></ol><br><blockquote>  En la especificaci√≥n, se usan nombres formales de los tipos de N√∫mero y Cadena, mientras que en el libro para los tipos primitivos, generalmente se usa el n√∫mero de notaci√≥n y la cadena.  No confunda el caso del s√≠mbolo de n√∫mero en la especificaci√≥n con la funci√≥n incorporada de n√∫mero ().  Para nuestros prop√≥sitos, el caso de los caracteres en el nombre del tipo no juega un papel, significan lo mismo. </blockquote><br>  La especificaci√≥n dice que el valor "42" se convierte en un n√∫mero para comparaci√≥n.  Acerca de c√≥mo se realiza la conversi√≥n, ya se describi√≥ anteriormente, y espec√≠ficamente cuando se describe la operaci√≥n abstracta ToNumber.  En este caso, es bastante obvio <br>  que los dos valores resultantes de 42 son iguales. <br><br><h3>  Comparaci√≥n: cualquier cosa con booleanos </h3><br>  Una de las trampas m√°s peligrosas en la conversi√≥n impl√≠cita de tipo == se encuentra al intentar comparar directamente los valores con verdadero o falso. <br><br>  Un ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-string"><span class="hljs-string">"42"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; a == b; <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br>  Espera, ¬øqu√© est√° pasando aqu√≠?  Sabemos que "42" es el verdadero significado (ver m√°s arriba en este cap√≠tulo).  ¬øC√≥mo resulta que compararlo con verdadero con la declaraci√≥n de igualdad estricta == <br>  no da verdad? <br><br>  La raz√≥n es simple y enga√±osamente astuta al mismo tiempo.  Es f√°cil de entender mal, muchos desarrolladores de JS no hacen el esfuerzo de entenderlo completamente. <br><br>  Una vez m√°s citamos la especificaci√≥n, secciones 11.9.3.6‚Äì7: <br><br><ol><li>  Si Tipo (x) es de tipo booleano, devuelve el resultado de la comparaci√≥n ToNumber (x) == y. </li><li>  Si Tipo (y) es de tipo booleano, devuelve el resultado de la comparaci√≥n x == ToNumber (y). </li></ol><br>  Veamos que hay aqu√≠.  Primer paso: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-string"><span class="hljs-string">"42"</span></span>; x == y; <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br>  El tipo (x) realmente pertenece al tipo booleano, por lo que se realiza la operaci√≥n ToNumber (x), que convierte verdadero a 1. Ahora se calcula la condici√≥n 1 == "42".  Los tipos siguen siendo diferentes, por lo tanto (casi recursivamente) el algoritmo se repite;  como en el caso anterior, "42" se convierte a 42, y la condici√≥n 1 == 42 es obviamente falsa. <br><br>  Si intercambia operandos, el resultado seguir√° siendo el mismo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-string"><span class="hljs-string">"42"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; x == y; <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br>  Esta vez, Tipo (y) es de tipo booleano, por lo que ToNumber (y) da 0. La condici√≥n "42" == 0 se convierte recursivamente en 42 == 0, que, por supuesto, es falsa. <br><br>  En otras palabras, el valor "42" no es == verdadero ni == falso.  A primera vista, esta afirmaci√≥n parece completamente impensable.  ¬øC√≥mo puede el significado no ser ni verdadero ni falso? <br><br>  Pero este es el problema!  Est√°s haciendo la pregunta equivocada.  Aunque en realidad no es tu culpa, es el cerebro el que te est√° enga√±ando. <br><br>  El valor "42" es realmente cierto, pero la construcci√≥n "42" == verdadero no realiza una prueba booleana / transformada, lo que sea que diga su cerebro.  "42" no se convierte a booleano (verdadero);  en cambio, verdadero se convierte en 1, y luego "42" se convierte en 42. <br><br>  Te guste o no, ToBoolean no se usa en absoluto aqu√≠, por lo que la verdad o falsedad de "42" no es importante para la operaci√≥n ==.  Es importante comprender c√≥mo se comporta el algoritmo de comparaci√≥n == en todas las diferentes combinaciones de tipos.  Si el valor booleano est√° en un lado, siempre se convierte primero en un n√∫mero. <br><br>  Si esto te parece extra√±o, no est√°s solo.  Personalmente, recomiendo nunca, nunca, bajo ninguna circunstancia, usar == verdadero o == falso.  Nunca <br><br>  Pero recuerda que solo estoy hablando de == aqu√≠.  Las construcciones === verdadero y === falso no permiten la conversi√≥n de tipos, por lo que est√°n protegidas de la conversi√≥n oculta ToNumber. <br><br>  Un ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-string"><span class="hljs-string">"42"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  (  !): if (a == true) { // .. } //   (  !): if (a === true) { // .. } //   ( ): if (a) { // .. } //  ( ): if (!!a) { // .. } //   ( ): if (Boolean( a )) { // .. }</span></span></code> </pre> <br>  Si evita == verdadero o == falso (igualdad suelta con booleano) en su c√≥digo, nunca tendr√° que preocuparse por esta trampa de verdad / falsedad. <br><br><h3>  Comparaci√≥n: nulo con indefinido </h3><br>  Otro ejemplo de conversi√≥n impl√≠cita ocurre cuando usa la igualdad lax == entre valores nulos e indefinidos.  Nuevamente, citar√© la especificaci√≥n ES5, <br>  secciones 11.9.3.2‚Äì3: <br><br><ol><li>  Si x contiene nulo e y contiene indefinido, devuelve verdadero. </li><li>  Si x contiene indefinido e y contiene nulo, devuelve verdadero. </li></ol><br>  Nulo e indefinido en comparaci√≥n con el operador no estricto == son iguales entre s√≠ (es decir, se convierten entre s√≠) y no hay otros valores en todo el idioma. <br><br>  Para nosotros, esto significa que nulo e indefinido puede considerarse indistinguible para fines de comparaci√≥n si utiliza el operador de prueba de igualdad no estricto ==, que permite su conversi√≥n impl√≠cita mutua: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b; a == b; <span class="hljs-comment"><span class="hljs-comment">// true a == null; // true b == null; // true a == false; // false b == false; // false a == ""; // false b == ""; // false a == 0; // false b == 0; // false</span></span></code> </pre> <br>  La conversi√≥n entre nulo e indefinido es segura y predecible, y ning√∫n otro valor puede dar falsos positivos para tal verificaci√≥n.  Recomiendo usar esta conversi√≥n para que nulo e indefinido no difieran en el programa y se interpreten como un valor √∫nico. <br><br>  Un ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = doSomething(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// .. }</span></span></code> </pre> <br>  La comprobaci√≥n nula a == solo pasa si doSomething () devuelve nulo o indefinido y falla por cualquier otro valor (incluyendo 0, falso y ""). <br><br>  ¬°La forma expl√≠cita de esta verificaci√≥n, que proh√≠be cualquier tipo de conversiones de este tipo, parece (en mi opini√≥n) mucho m√°s fea y puede funcionar un poco menos eficientemente! <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = doSomething(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a === <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> || a === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// .. }</span></span></code> </pre> <br>  Creo que la forma a == nulo es otro ejemplo de una situaci√≥n en la que una conversi√≥n impl√≠cita facilita la lectura del c√≥digo, pero lo hace de manera confiable y segura. <br><br><h3>  Comparaci√≥n: objetos y no objetos </h3><br>  Si se compara un objeto / funci√≥n / matriz con una primitiva escalar simple (cadena, n√∫mero o booleano), la especificaci√≥n ES5 dice lo siguiente (secci√≥n 11.9.3.8‚Äì9): <br><br><ol><li>  Si Tipo (x) es de tipo Cadena o N√∫mero, y Tipo (y) es de tipo Objeto, devuelve el resultado de la comparaci√≥n x == ToPrimitive (y). </li><li>  Si Tipo (x) es de tipo Objeto y Tipo (y) es de tipo Cadena o N√∫mero, devuelve el resultado de la comparaci√≥n ToPrimitive (x) == y. </li></ol><br><blockquote>  Es posible que haya notado que en estas secciones de la especificaci√≥n solo se mencionan String y Number, pero no Boolean.  El hecho es que, como se mencion√≥ anteriormente, las secciones 11.9.3.6‚Äì7 aseguran que cualquier operando booleano se represente primero como N√∫mero. </blockquote><br>  Un ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = [ <span class="hljs-number"><span class="hljs-number">42</span></span> ]; a == b; <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br>  Para el valor [42], se llama a la operaci√≥n abstracta ToPrimitive (consulte "Operaciones abstractas"), que da el resultado "42".  A partir de este momento, la condici√≥n simple "42" == 42 permanece, que, como ya hemos descubierto, se convierte en 42 == 42, de modo que ayb son iguales hasta la conversi√≥n de tipos. <br><br><blockquote>  Como era de esperar, todas las caracter√≠sticas de la operaci√≥n abstracta ToPrimitive discutida anteriormente en este cap√≠tulo ((toString (), valueOf ()) tambi√©n son aplicables en este caso. Esto puede ser muy √∫til si tiene una estructura de datos compleja y desea defina un m√©todo especializado valueOf () para √©l, que deber√° proporcionar un valor simple con el prop√≥sito de verificar la igualdad. </blockquote><br>  El Cap√≠tulo 3 examin√≥ el "desempaquetado" de un contenedor de objetos alrededor de un valor primitivo (como en una nueva Cadena ("abc"), por ejemplo), lo que resulta en el retorno de la primitiva subyacente <br>  valor ("abc").  Este comportamiento est√° relacionado con la transformaci√≥n ToPrimitive en el algoritmo ==: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-string"><span class="hljs-string">"abc"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>( a ); <span class="hljs-comment"><span class="hljs-comment">//  ,  `new String( a )` a === b; // false a == b; // true</span></span></code> </pre> <br>  a == b da verdadero porque b es convertido (o "desempaquetado") por la operaci√≥n ToPrimitive al valor primitivo escalar simple base "abc", que coincide con el valor de a. <br><br>  Hay algunos valores para los que esto no es as√≠ debido a otras reglas primordiales en el algoritmo ==.  Un ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>( a ); <span class="hljs-comment"><span class="hljs-comment">//  ,  `Object()` a == b; // false var c = undefined; var d = Object( c ); //  ,  `Object()` c == d; // false var e = NaN; var f = Object( e ); //  ,  `new Number( e )` e == f; // false</span></span></code> </pre> <br>  Los valores nulo e indefinido no se pueden empaquetar (no tienen un contenedor de objetos equivalente), por lo que Object (nulo) no es fundamentalmente diferente de Object (): ambas llamadas crean el habitual <br>  ny objeto <br><br>  NaN se puede empaquetar en el contenedor de objetos Number equivalente, pero cuando == causa el desempaquetado, la comparaci√≥n NaN == NaN falla porque el valor de NaN nunca es igual a s√≠ mismo (vea el cap√≠tulo 2). <br><br>  ¬ªSe puede encontrar m√°s informaci√≥n sobre el libro en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el sitio web del editor</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Contenidos</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Extracto</a> <br><br>  Cup√≥n de 25% de descuento para vendedores ambulantes - <b>JavaScript</b> <br><br>  Tras el pago de la versi√≥n en papel del libro, se env√≠a un libro electr√≥nico por correo electr√≥nico. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/456730/">https://habr.com/ru/post/456730/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../456712/index.html">Registro selectivo de tr√°fico para servicios SOAP</a></li>
<li><a href="../456714/index.html">Comprender los n√∫meros de coma flotante (parte 0)</a></li>
<li><a href="../456716/index.html">Datos no muy grandes</a></li>
<li><a href="../456722/index.html">Recetas PostgreSQL: Programador de tareas as√≠ncrono</a></li>
<li><a href="../456724/index.html">5 maneras extremadamente simples de acelerar significativamente su aplicaci√≥n VueJS</a></li>
<li><a href="../456732/index.html">Ser un mentor</a></li>
<li><a href="../456736/index.html">Recetas PostgreSQL: cURL: obtener, publicar y ... correo electr√≥nico</a></li>
<li><a href="../456738/index.html">Redes neuronales y aprendizaje profundo, cap√≠tulo 1: uso de redes neuronales para reconocer n√∫meros escritos a mano</a></li>
<li><a href="../456740/index.html">Inmersi√≥n en redes neuronales convolucionales. Parte 5/1 - 9</a></li>
<li><a href="../456744/index.html">10 problemas que resolv√≠ con recordatorios en mi tel√©fono inteligente</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>