<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎸 ⚕️ 🚶 Blockchain ohne Zwischenhändler: Wie wir Wertpapiere an eine verteilte Registrierung gesendet haben 🌲 👶 👩🏼‍🎨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Alle wirtschaftlichen Aktivitäten basieren historisch auf Vermittlern. Jede einfache Transaktion zwischen den beiden Parteien wird von der Beteiligung...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Blockchain ohne Zwischenhändler: Wie wir Wertpapiere an eine verteilte Registrierung gesendet haben</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/442692/">  Alle wirtschaftlichen Aktivitäten basieren historisch auf Vermittlern.  Jede einfache Transaktion zwischen den beiden Parteien wird von der Beteiligung verschiedener Vermittler begleitet - Banken, Börsen, Clearingstellen usw.  Der Ausschluss von Vermittlern würde die Interaktion wahrscheinlich effizienter machen.  Warum also nicht versuchen, eine neue, dezentrale Infrastruktur auf der Basis der Blockchain aufzubauen, in der die Teilnehmer an der Transaktion direkt arbeiten können?  In diesem Beitrag werden wir darüber sprechen, wie wir unsere Reise zu einer solchen Infrastruktur begonnen haben: Wir haben Blockchain-Transaktionen entwickelt und schließlich Repos durchgeführt - ein durch Wertpapiere gesichertes Gelddarlehen. <br><br><img src="https://habrastorage.org/webt/5y/08/en/5y08enodezvkfd1qngslkh-pl4y.png"><br><a name="habracut"></a><br><h2>  Kurzfristige Anleihen </h2><br>  Unsere erste außerbörsliche Finanztransaktion in der Blockchain war die Emission einer kurzfristigen Anleihe des MTS-Mobilfunkbetreibers unter Beteiligung des National Settlement Depository (NSD).  Dies ist eine Art "Zentralbank" aller Verwahrstellen.  Verwahrstellen sind Infrastrukturvermittler, die Aufzeichnungen über Wertpapierinhaber führen und diese ausgeben. <br><br>  Bei dieser Transaktion zeichnete MTS in der Blockchain einen Ausdruck des Willens zum Verkauf von Wertpapieren an die Sberbank auf und bestätigte in der Blockchain seine Zustimmung zu den Bedingungen der Transaktion, indem sie die Funktion eines intelligenten Vertrags aufrief.  Die von beiden Parteien unterzeichneten Gegenaufträge gingen bei NSD ein, die sie in ihren Buchhaltungssystemen ausführte.  Darüber hinaus wurden in der Blockchain die Konten der Transaktionsteilnehmer in Wertpapieren und Geld angezeigt. <br><br>  In diesem Projekt haben wir die Open-Source-Plattform <i>Hyperledger Fabric 1.1</i> ausgewählt, mit der geschlossene Blockchain-Lösungen für Unternehmen erstellt werden können.  Öffentliche Blockchains sind hier nicht geeignet, da wir den Datenschutz gewährleisten müssen.  Wir waren mit solchen Einschränkungen im Factoring-Pilotprojekt der Sberbank mit M. Video konfrontiert, das in der Ethereum-Blockchain implementiert wurde.  Im Gegensatz dazu können Sie mit Hyperledger Fabric alle Teilnehmer einer Transaktion in einem dedizierten Kanal platzieren, in dem sie alle erforderlichen Informationen austauschen und mit intelligenten Verträgen mit vollem Funktionsumfang verarbeiten können. <br><br>  Der Quellcode des MTS-Anleiheprojekts wurde öffentlich auf GitHub hochgeladen.  Ohne auf den Arbeitsalgorithmus einzugehen, können Sie verstehen, dass die Blockchain im Lebenszyklus einer Transaktion eine eher bescheidene Rolle als Transport von Clearing-Aufträgen erhielt.  Auf der anderen Seite haben sich aufgrund dieser Anweisungen die Kontensalden geändert. Aus Sicht der Geschäftslogik war dies also interessanter als ein einfacher elektronischer Dokumentenverwaltungsdienst. <br><br>  Der Hauptvorteil der Lösung war die Vielseitigkeit.  Das System „zwei Gegenparteien und ein Registrar“ deckt nahezu alle Transaktionen auf dem OTC-Markt ab und mit geringfügigen Änderungen - die meisten kommerziellen Transaktionen im Allgemeinen. <br><br><h2>  REPO 1.0 </h2><br>  In einem neuen Projekt zur Blockchain haben wir beschlossen, zu zeigen, wie ein Pensionsgeschäft in einem dezentralen System implementiert werden kann - ein Darlehen von Geld gegen Wertpapiere.  In der Regel werden diese und andere OTC-Transaktionen über Vermittler abgewickelt - Verwahrstellen, Clearingstellen und Makler. <br><br>  In diesem Projekt haben wir einen Pensionsvertrag zwischen der Sberbank und einem ausländischen Partner abgeschlossen.  Es wurde bereits Hyperledger Fabric Version 1.2 verwendet.  Im Vergleich zu MTS-Anleihen hatten wir zwei Unterschiede: <br><br><ul><li>  Nur zwei an der Blockchain verbundene Parteien der Transaktion, deren Verwahrstellen - Euroclear und Clearstream - alle Bestellungen über herkömmliche Datenübertragungskanäle von den Backoffices der Sberbank und ihrer Gegenpartei erhalten haben. <br></li><li>  Im Smart-Vertrag haben wir eine komplexe Geschäftslogik implementiert: Tägliche Angebote der Sicherheiten, die als Sicherheit für das Darlehen dienten, wurden in die Blockchain heruntergeladen, und der Smart-Vertrag berechnete den Bedarf und die Höhe der vorzeitigen Rückzahlung unter Berücksichtigung der geänderten Kosten für Sicherheiten, Rabatt, Kalender der Ausstiegsbörsen und anderer Parameter.  Eine solche P2P-Synchronisation von Berechnungsalgorithmen zwischen Teilnehmern kann ohne eine verteilte Registrierung nicht erreicht werden.  Dies ist viel bequemer als eine unabhängige Berechnung von Verpflichtungen und Beträgen durch jede Seite - keine zeitaufwändigen Abstimmungen, keine Bestätigungen. <br></li></ul><br>  Zwischen den Gegenparteien organisierten sie einen Chat und einen Workflow innerhalb des Kanals.  Daten darüber wurden in der Blockchain gespeichert.  Nach jeder Änderung in der verteilten Registrierung erhielten die Channel-Mitglieder eine E-Mail-Benachrichtigung. <br><br>  "REPO 1.0" haben wir von der rechtlichen Seite ausgearbeitet.  Mit Hilfe einer großen Anwaltskanzlei wurde eine Analyse der Fälle des High Court of London durchgeführt.  Darüber hinaus verwendeten das EDS der Bank und ihrer Gegenpartei unterschiedliche kryptografische Algorithmen. <br><br><h3>  Wie funktioniert REPO 1.0? </h3><br>  Jede Partei der Transaktion hat einen eigenen Blockchain-Knoten.  Alle Knoten sind in einem P2P-Netzwerk miteinander verbunden.  Angenommen, Sie müssen einen Deal machen.  Wir setzen einen intelligenten Vertrag zwischen den Parteien der Transaktion ein, in dem das Finanzinstrument vollständig beschrieben wird. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f42/e38/b7e/f42e38b7e23eac1217952790f217a4e9.png"><br><br>  Nach Vertragsabschluss unsererseits unterschreibt der Händler den Vertrag.  Der Kunde überprüft und unterschreibt auch den Vertrag.  Anschließend werden die Signaturen überprüft und verifiziert.  In diesem Fall wurde die Transaktion nach englischem Recht durchgeführt, die Daten auf der elektronischen digitalen Signatur wurden in das GMRA-Dokument eingegeben.  Für die Unterzeichnung durch den Kunden muss überprüft werden, ob eine autorisierte Person im Unterschriftenzertifikat vorhanden ist.  Schließlich akzeptiert der Kunde den Vertrag und stimmt allen Bedingungen zu.  Sie können einem unterzeichneten Vertrag beliebig viele Dokumente hinzufügen. <br><br>  Danach erhält der Vertrag den Status "in Arbeit".  Der "in Bearbeitung" -Vertrag wird beim Laden neuer Marktpreise automatisch neu berechnet.  Wenn der Vertrag ein Wertpapier enthält, wird der Marktpreis genommen, der Loan-to-Value (LTV) neu berechnet - das Verhältnis des Kreditbetrags zum Wert des Wertpapiers in Wertpapieren.  LTV ist einer der Schlüsselbegriffe in einer Repo-Transaktion, dessen Bedeutung im Vertrag festgelegt ist.  Der Aktienkurs ist stark gestiegen - und der LTV wird niedriger als der in GMRA angegebene (wenn es um englisches Recht geht).  Dementsprechend gibt die Bank Wertpapiere an den Kunden zurück (als eine der Optionen), da sich unter Berücksichtigung neuer Preise herausstellt, dass die Bank über eine höhere Sicherheit verfügt. <br><br>  Wenn der LTV jedoch größer wird, können Sie mit dem Programm eine Sicherheitenmitteilung ausdrucken - eine Benachrichtigung an den Kunden über die Notwendigkeit, zusätzliche Sicherheiten (Aktien oder Geld) zu leisten, damit der LTV-Wert zum ursprünglichen Wert zurückkehrt.  Bisher konnte die Benachrichtigung über Sicherheiten nur per Post gesendet werden, es wurden separate Dokumente dafür erstellt, und während der Erstellung dieser Dokumente konnte sich der LTV erneut ändern.  Jetzt sehen wir die gleichen Berechnungen mit dem Kunden online, wir können leicht interagieren. <br><br>  Darüber hinaus legt das Programm jeden Tag den Preis für den Rückkauf von Wertpapieren unter Berücksichtigung der Zinsen fest.  Wenn der Kunde beim Laden des Marktpreises damit nicht einverstanden ist, sieht er sich das vollständige Neuberechnungsprotokoll an - was war, was wurde, welcher Preis wurde geladen, woher er kam.  Und dann beginnt die Chat-Diskussion. <br><br><h2>  REPO 2.0 </h2><br>  Wir wollten, dass unser REPO in der Blockchain in der Lage ist, die Bewegung von Real Assets basierend auf unserer internen Logik zu initiieren.  In REPO 1.0 konnten wir dies jedoch aufgrund organisatorischer Schwierigkeiten beim Anschluss westlicher Verwahrstellen noch nicht erreichen.  Also haben wir den neuen Repo 2.0-Piloten gestartet.  Er hatte zwei Ziele: <br><br><ul><li>  Die Transaktion sollte unter Beteiligung von zwei Parteien und der Verwahrstelle durchgeführt werden, um die Infrastruktur des MTS-Anleihenprojekts optimal zu nutzen. <br></li><li>  Die Blockchain muss befugt sein, Sicherheiten neu zu bewerten und einen Margin Call einzurichten, der automatisch von einem mit einem verteilten Netzwerk verbundenen Depot ausgeführt werden kann. <br></li></ul><br>  NSD wollte sich sofort mit dem Projekt verbinden.  Um eine in der Blockchain initiierte Transaktion auf dem konservativen Gebiet der Bundesgesetze für den heimischen Finanzmarkt zu landen, haben wir mit Anwälten eine fünfseitige Zusatzvereinbarung zur Vereinbarung über die Verwaltung elektronischer Dokumente geschlossen.  Es wurde von allen Parteien der Transaktion und NSD unterzeichnet. <br><br>  NSD fungierte bei dieser Transaktion als Clearingstelle.  Er führte alle Anweisungen zum Transport von Geldern und Wertpapieren aus.  Diese Transaktion wurde nach russischem Recht abgeschlossen. <br><br>  Der Kunde nahm den Vertrag mit einer elektronischen Unterschrift an.  Dann wurde die Vereinbarung von der Sberbank mit ihrer Unterschrift akzeptiert - sie überprüfte die Übereinstimmung aller Parameter mit den erforderlichen Werten und der Autorität der Person, die vom Kunden akzeptiert hatte.  Danach ging der Vertrag in Arbeit.  NSD hat Marktdaten hochgeladen, Smart Contract neu berechnet. <br><br><h3>  Wie funktioniert REPO 2.0? </h3><br>  Um das Netzwerk bereitzustellen und mit der Client-Schnittstelle mit dem Kettencode zu interagieren, haben wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fabric Starter-</a> Lösung verwendet.  Anstelle der Standard-GRPC-Schnittstelle für HLF wird eine REST-API bereitgestellt, die in unserem Fall die Komplexität der Integration erheblich reduziert. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/07a/86a/997/07a86a997c7017a122b03aad7995f6ad.png"><br><br>  Das Netzwerk wurde wie folgt aufgebaut.  Jede der drei Seiten startete nach der Vorinstallation auf dem Docker-Server Fabric Starter, der Container mit den Komponenten des Knotens erstellte.  Zu diesen Komponenten gehörten ein externer Peer für die Interaktion mit anderen Organisationen und ein REST-API-Service, über den der Knoten mit der Clientanwendung interagierte.  Beim Start von Starter wurde auch das Blockchain-Netzwerk konfiguriert und ein privater Kanal erstellt, in dem der Kettencode mit Endorsement-Richtlinie installiert wurde.  In unserem Fall muss jede Transaktion die Signaturen aller drei Teilnehmer haben. <br><br>  Während der Testphase wurde Docker Swarm verwendet, um die Verbindung der Server der Teilnehmer zu organisieren. Um jedoch ein echtes Geschäft abzuschließen, wechselten sie zu DNS.  Die Plattform selbst ist für den Nachrichtentransport verantwortlich, Daten werden mit TLS-Verschlüsselung über das Internet übertragen. <br><br><h2>  Die technische Seite des Problems </h2><br>  Der Prozess der Entwicklung einer verteilten Anwendung auf HLF beginnt ganz traditionell - mit Datenstrukturen und einem Kettencode (in der Tat einer Reihe gespeicherter Prozeduren), dessen Aufruf zum Erhalt, Ändern oder Lesen dieser Strukturen aus dem Hauptbuch führt.  Die Plattform ermöglicht die Verwendung verschiedener Programmiersprachen für die Entwicklung von Kettencodes und DBMS für die lokale Speicherung.  Wir bevorzugen Go bzw. CouchDB. <br><br>  Das zentrale Wesen für Repo-Projekte in unserem Datenmodell ist der Vertrag selbst und seine Nebenverpflichtungen.  Sie wurden für jeden der beiden Piloten sowie für Margin Calls erstellt.  Diese Architektur war ein Fortschritt im Vergleich zum MTS-Bindungsmodell, das auf dem Wesen der „Ordnung“ basierte.  Es wurden auch unabhängige Objekte für Wertpapiere erstellt, die somit teilweise mit einem Token versehen wurden.  Bei der Entwicklung des Experiments mit Kontoverwaltung und virtueller Tokenisierung von Geld haben wir uns entschlossen, eine der nächsten Versionen der Lösung zu verschieben. <br><br>  Die Hauptfunktionen unserer Lösung: <br><br><ul><li>  Erstellen Sie einen Vertrag. <br></li><li>  Unterzeichnen Sie mit Ihrem EDS einen Vertrag, in dem die Annahme der Vertragsbedingungen bestätigt wird. <br></li><li>  Laden Sie die Marktpreise herunter und berechnen Sie den Wert der Sicherheiten neu.  Die Abweichung von der festgelegten Schwelle führte zur Schaffung einer neuen Margin-Call-Verpflichtung. <br></li><li>  Den Status der Verpflichtung widerspiegeln. <br></li></ul><br>  Auf der technischen Seite ist das Neubewertungsverfahren hier am interessantesten.  Lassen Sie es uns genauer analysieren. <br><br>  Im Geschäftsprozess sollte das Verfahren einmal täglich gestartet werden, nachdem Oracle (im Pilotprojekt von „REPO 2.0“ von NSD) die aktualisierten Wertpapierkurse in das System hochgeladen hat. <br><br><pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *CIBContract)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">recalculationData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stub shim.ChaincodeStubInterface, loadData *loadDataType, curDay </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pb</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Response</span></span></span></span> {...}</code> </pre> <br>  Der Hauptzyklus des Verfahrens durchläuft alle Wertpapiere, für die die Quotes aktualisiert wurden. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, securities := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> loadData.Securities {...}</code> </pre> <br>  Als nächstes werden mehrere Überprüfungen durchgeführt.  Wenn beispielsweise der Austausch, bei dem die Marktdaten eingegangen sind, heute einen freien Tag hat, sollte keine Nachzählung erfolgen. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> t.checkHoliday(stub, contract.Settings.Calendars) == <span class="hljs-string"><span class="hljs-string">"yes"</span></span> { hisYes := historyType{curDay, <span class="hljs-string"><span class="hljs-string">"LoadData. Calendar"</span></span>, <span class="hljs-string"><span class="hljs-string">"System"</span></span>, <span class="hljs-string"><span class="hljs-string">"LoadData. Today is holiday ! No load market data to contract !"</span></span>} ... contract.History = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(contract.History, hisYes) … err = stub.PutState(contrID, contractJSONasBytes) }</code> </pre><br>  Zur Berechnung des aktualisierten Anleihepreises wird die aufgelaufene Kuponrendite (NDC) zum geladenen Nettopreis addiert.  Das Pilotprojekt unterstützte das 30/360-Schema zur Berechnung der NKD. <br><br><pre> <code class="go hljs">priceIzm = <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(securities.Price + <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(securities.CouponRate)*<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(settlementDate.Year()) - <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(dateStart.Year()))*<span class="hljs-number"><span class="hljs-number">360</span></span> + (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(settlementDate.Month()) - <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(dateStart.Month()))*<span class="hljs-number"><span class="hljs-number">30</span></span> + (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(settlementDate.Day()) - <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(dateStart.Day())))*<span class="hljs-number"><span class="hljs-number">100</span></span>/<span class="hljs-number"><span class="hljs-number">360</span></span>/<span class="hljs-number"><span class="hljs-number">100</span></span>) curCurrVal = priceIzm</code> </pre><br>  Wenn sich die Transaktionswährung von der Währung unterscheidet, in der das Wertpapier notiert ist, wird eine Umtauschumrechnung durchgeführt. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> contract.GeneralTerms.PurchasePrice.Currency != securities.Currency { curCurrName = securities.Currency + <span class="hljs-string"><span class="hljs-string">"-"</span></span> + contract.GeneralTerms.PurchasePrice.Currency               <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, currency := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> loadData.Currencies {              <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> currency.Name == curCurrName {                           curCurrVal = priceIzm * currency.Value } } }</code> </pre><br>  Jetzt müssen wir den LTV berechnen.  Behalten Sie den alten Koeffizientenwert für die Geschichte bei. <br><br><pre> <code class="go hljs">oldCurLTV := contract.MarginingTerms.CurrentLTV</code> </pre> <br>  Margin Calls, die während der Laufzeit der Transaktion ausgeführt werden, müssen berücksichtigt werden.  Anforderungen können von beiden Seiten kommen und in zwei Formen: <br><br><ul><li>  Wertpapiere.  Der Kreditnehmer macht zusätzliche Sicherheiten im Falle eines Rückgangs des Marktpreises des Wertpapiers.  Der Gläubiger gibt im Falle einer Preiserhöhung einen Teil der Sicherheit zurück. <br></li><li>  Geld.  Der Kreditnehmer zahlt vorzeitig den Teil des Kredits zurück, der nicht mehr durch billigere Sicherheiten gedeckt ist.  Der Kreditgeber erhöht den Kreditbetrag als Reaktion auf eine Wertsteigerung der Sicherheiten. <br></li></ul><br>  Im ersten Fall wird die Höhe der Wertpapiere in den Sicherheiten einfach aktualisiert.  Und um damit Geld zu verdienen, ist es auch notwendig, die in den zusätzlichen Bedingungen der Transaktion angegebene Rentabilität zu erzielen. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, addCollateral := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> contract.MarginingTerms.AddCollateral { currSumCollateral := addCollateral.Sum + (addCollateral.Sum*contract.MarginingTerms.RateOnCashMargin*<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(deltaColDate) / <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(contract.MarginingTerms.Basis))/<span class="hljs-number"><span class="hljs-number">100</span></span> ... allSumCollateral = allSumCollateral + currSumCollateral ... ht := historyType{curDay, System<span class="hljs-string"><span class="hljs-string">", "</span></span>LoadData. Recalculation data(addCollateral) Contract <span class="hljs-string"><span class="hljs-string">" + contrID + "</span></span> - currSumCollateral: <span class="hljs-string"><span class="hljs-string">" + strconv.FormatFloat(float64(currSumCollateral), 'f', 2, 64) ... }        ... contract.History = append(contract.History, ht) }</span></span></code> </pre> <br>  Wir berechnen den Gesamtbetrag des Rückkaufs - tatsächlich ist dies der Betrag des Darlehens mit Zinsen, den wir zurückzahlen müssen. <br><br><pre> <code class="go hljs">rePurchasePriceCur := contract.GeneralTerms.PurchasePrice.Sum + (contract.GeneralTerms.PurchasePrice.Sum*contract.GeneralTerms.RepoRate*<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(deltaSigningDate)/<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(contract.MarginingTerms.Basis))/<span class="hljs-number"><span class="hljs-number">100</span></span></code> </pre><br>  Nun berechnen wir den LTV-Koeffizienten.  Subtrahieren Sie dazu das Wertpapier in bar vom Rückkaufpreis und dividieren Sie den resultierenden Wert durch den Gesamtwert der Wertpapiere im Wertpapier.  Vom Gläubiger gutgeschriebene Beträge sind mit einem „-“ gekennzeichnet und werden zum Rückkaufpreis hinzugerechnet. <br><br><pre> <code class="go hljs">contract.MarginingTerms.CurrentLTV = (rePurchasePriceCur - allSumCollateral) * <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) / (<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(contract.GeneralTerms.PurchasedSecurities.Quantity) * curCurrVal)</code> </pre><br>  Schließlich berechnen wir die Auslöser im Vertrag.  Mit derselben Prozedur werden Margin Call Order-Objekte erstellt, wenn der LTV-Wert vom angegebenen Korridor abweicht. <br><br><pre> <code class="go hljs">contract = t.checkTriggerEvents(stub, <span class="hljs-string"><span class="hljs-string">"LoadData"</span></span>, contract, curDay, securities)</code> </pre><br>  Schreiben Sie Informationen in den Verlauf, um sie auf der Benutzeroberfläche anzuzeigen. <br><br><pre> <code class="go hljs">ht := historyType{curDay, <span class="hljs-string"><span class="hljs-string">"System"</span></span>, <span class="hljs-string"><span class="hljs-string">"LoadData. Recalculation data(change curLTV, ADTV) Contract "</span></span> + contrID + <span class="hljs-string"><span class="hljs-string">" - oldCurLTV: "</span></span> + strconv.FormatFloat(<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(oldCurLTV), <span class="hljs-string"><span class="hljs-string">'f'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>) + <span class="hljs-string"><span class="hljs-string">", newCurLTV: "</span></span> + strconv.FormatFloat(<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(contract.MarginingTerms.CurrentLTV), <span class="hljs-string"><span class="hljs-string">'f'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>)...} contract.History = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(contract.History, ht)</code> </pre> <br><h2>  Zusammenfassend </h2><br>  Ein solches System kann nicht nur mit Wertpapieren und Verträgen funktionieren, sondern auch in anderen Szenarien.  Zum Beispiel bei Stromversorgungen, bei denen es unterschiedliche Tarife gibt, unterschiedliche Verbindungen zu unterschiedlichen Zeiten.  Oder mit Factoring - Kreditvergabe an Lieferanten durch Signale des Warenversands.  In der Wirtschaft gibt es viele Anwenderfälle, in denen jeder seine eigenen Datenquellen verwendet, die überprüft werden müssen. <br><br>  Unser Ziel ist es, ein Netzwerk zu schaffen, das Banken bundesweit miteinander und mit ihren Kunden verbindet und mithilfe intelligenter Verträge Verträge beschreibt, die nicht Krypto, sondern die traditionelle Wirtschaft - Finanzinstrumente - betreffen.  Ein solches Netzwerk wird stabil und offen sein, und wie es in einem P2P-Netzwerk sein sollte, wird hier niemand einen besonderen Status haben. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442692/">https://habr.com/ru/post/de442692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de442682/index.html">Was Sie eingeben und wie Sie ein C ++ - Projekt zusammenstellen</a></li>
<li><a href="../de442684/index.html">Ausgewogene Site-Leistung. Teil 3: Inhalt</a></li>
<li><a href="../de442686/index.html">DataPower-Lernprogramm</a></li>
<li><a href="../de442688/index.html">Scala-Datenanalyse - ein dringender Bedarf oder eine angenehme Gelegenheit?</a></li>
<li><a href="../de442690/index.html">Mondmission "Bereshit" - Selfie auf dem Hintergrund der Erde</a></li>
<li><a href="../de442694/index.html">Einer der Streaming-Giganten startete in Indien und zog in einer Woche eine Million Nutzer an</a></li>
<li><a href="../de442696/index.html">S for Security: Internetsicherheit von Dingen und Berichten bei InoThings ++ 2019</a></li>
<li><a href="../de442698/index.html">Moskauer U-Bahn-Anwendung für den Windows Store</a></li>
<li><a href="../de442700/index.html">Lohnt es sich, sich mit mobilen Solarkraftwerken zu befassen?</a></li>
<li><a href="../de442702/index.html">Über die Magistratur von Tinkoff.ru bei MIPT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>