<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏒 🕗 🐵 Bekerja dengan zona waktu dalam JavaScript ♓️ ⏭️ 🧖🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Baru-baru ini, saya sedang mengerjakan tugas menambahkan zona waktu ke perpustakaan kalender JS yang dikelola oleh tim saya. Saya sangat menyadari duk...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bekerja dengan zona waktu dalam JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/438286/"><img src="https://habrastorage.org/getpro/habr/post_images/540/5d5/588/5405d55887909032bc8016afe3f65796.jpg"><br><br>  Baru-baru ini, saya sedang mengerjakan tugas menambahkan zona waktu ke perpustakaan kalender JS yang dikelola oleh tim saya.  Saya sangat menyadari dukungan zona waktu yang tidak berguna dalam JavaScript, tetapi saya berharap bahwa abstrak objek data yang ada akan membuatnya mudah untuk menyelesaikan sebagian besar kesulitan. <br><br>  Namun, mimpi saya menjadi debu.  Ketika saya mempelajari tugas itu, saya menyadari bahwa sangat sulit untuk bekerja dengan zona waktu dalam bahasa ini.  Sangat sulit untuk mengimplementasikan sesuatu yang lebih rumit daripada sekadar memformat tampilan waktu dan menghitung tanggal menggunakan operasi kompleks (fungsi kalender).  Saya mendapatkan pengalaman berharga dalam memecahkan masalah ini, dan ini memerlukan kesulitan baru. <br><br>  Pada artikel ini saya ingin membahas apa yang saya temukan dan bagaimana menyelesaikannya.  Sementara saya menulis teks, saya menyadari bahwa alasan semua kesulitan adalah pemahaman saya yang buruk tentang topik zona waktu.  Mengingat kesadaran ini, saya mengusulkan pertama untuk berbicara secara rinci tentang definisi dan standar, dan baru kemudian beralih ke JavaScript. <br><a name="habracut"></a><br><h2>  Apa itu zona waktu? </h2><br>  Zona waktu adalah wilayah geografis yang menggunakan waktu lokal yang sama yang ditetapkan oleh pemerintah.  Banyak negara terkait sepenuhnya dengan zona waktu tertentu, dan di wilayah negara-negara besar, seperti Rusia dan Amerika Serikat, beberapa zona waktu digunakan.  Sangat mengherankan bahwa meskipun Cina juga cukup besar, ia hanya menerima satu zona waktu.  Terkadang ini mengarah pada situasi aneh ketika matahari terbit di bagian barat negara itu dimulai sekitar jam 10 pagi. <br><br><h2>  GMT, UTC dan Offset </h2><br><h4>  GMT </h4><br>  Waktu lokal Korea Selatan ditetapkan sebagai <code>GMT+09:00</code> .  GMT adalah singkatan dari Greenwich Mean Time (GMT), yaitu kali ini di jam Royal Observatory di Greenwich, Inggris.  Terletak di meridian utama.  Sinyal radio sistem GMT mulai mengudara pada 5 Februari 1924, dan itu sendiri berubah menjadi standar dunia pada 1 Januari 1972. <br><br><h4>  UTC </h4><br>  Banyak orang berpikir bahwa GMT dan UTC adalah hal yang sama, sering menggunakannya sebagai sistem yang dapat dipertukarkan.  Tapi ini sebuah kesalahan.  Sistem UTC muncul pada tahun 1972 sebagai cara untuk mengkompensasi efek rotasi Bumi.  Sistem ini didasarkan pada Waktu Atom Internasional, dihitung dengan frekuensi getaran elektromagnetik atom cesium.  Dengan kata lain, UTC adalah pengganti yang lebih akurat untuk GMT.  Walaupun perbedaan waktu nyata antara kedua sistem sangat kecil, lebih baik bagi pengembang perangkat lunak untuk mengandalkan UTC. <br><br>  Fakta menarik: ketika UTC masih dikembangkan, disarankan di negara-negara berbahasa Inggris untuk menyebutnya CUT (Waktu Universal Terkoordinasi), dan di negara-negara berbahasa Prancis - TUC (Temps Universal Coordonn).  Namun, tidak ada kamp yang bisa menang, dan mereka sepakat untuk memanggil sistem UTC, ejaan dari kedua opsi yang diusulkan (C, T dan U). <br><br><h4>  Offset </h4><br>  <code>+09:00</code> dalam <code>UTC+09:00</code> berarti waktu setempat adalah 9 jam lebih awal dari waktu UTC standar.  Yaitu, ketika jam 9 malam di Korea Selatan, itu siang di wilayah UTC.  Perbedaan antara waktu UTC standar dan waktu lokal disebut "offset", yang dinyatakan sebagai nilai positif atau negatif: <code>+09:00</code> , <code>-03:00</code> , dll. <br><br>  Di banyak negara, sudah lazim untuk memberi zona waktu nama unik kepada Anda.  Sebagai contoh, zona waktu Korea Selatan disebut KST (Waktu Standar Korea), offsetnya dinyatakan sebagai <code>KST = UTC+09:00</code> .  Namun, offset <code>+09:00</code> digunakan tidak hanya oleh Korea Selatan, tetapi juga oleh Jepang, Indonesia, dan banyak negara lain, oleh karena itu, hubungan antara offset dan sabuk dinyatakan bukan sebagai 1: 1, tetapi sebagai 1: N.  Daftar negara dengan offset <code>+09:00</code> disajikan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Beberapa offset beroperasi tidak hanya selama berjam-jam.  Misalnya, di Korea Utara, waktu standar adalah <code>+08:30</code> , sementara di Australia di beberapa daerah <code>+8:45</code> , <code>+09:30</code> dan <code>+10:30</code> . <br><br>  Daftar lengkap offset UTC ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h2>  Zona Waktu! == offset? </h2><br>  Seperti yang saya katakan, kami menggunakan nama zona waktu (KST, JST) dengan offset sebagai dipertukarkan, tanpa membedakan di antara mereka.  Tetapi akan keliru untuk mempertimbangkan waktu yang sama dan pergeseran wilayah tertentu.  Ada beberapa alasan: <br><br><h4>  Daylight Saving Time (DST) </h4><br>  Di beberapa negara, istilah ini tidak diketahui, tetapi di banyak negara, waktu musim panas dipraktekkan, terutama di Eropa.  Untuk ini, istilah internasional DST diadopsi - Daylight Saving Time.  Ini berarti menggerakkan jam di musim panas selama satu jam lebih cepat dari waktu standar relatif. <br><br>  Misalnya, California menggunakan PST (Waktu Standar Pasifik) di musim dingin dan PDT (Waktu Siang Pasifik, <code>UTC-07:00</code> ) di musim dingin.  Di Amerika Serikat dan Kanada, istilah Waktu Pasifik (PT, Waktu Pasifik) digunakan untuk wilayah yang menggunakan dua zona waktu. <br><br>  Kapan waktu musim panas mulai dan berakhir?  Itu semua tergantung negara.  Misalnya, di AS dan Kanada hingga 2006, DST digunakan mulai jam 2 pagi pada hari Minggu pertama bulan April hingga jam 12 pagi pada hari Minggu terakhir bulan Oktober.  Dan sejak 2007, waktu musim panas mulai dihitung dari 2 malam pada hari Minggu kedua bulan Maret hingga 2 malam pada hari Minggu pertama bulan November.  Di Eropa, berbagai negara mempraktikkan penggunaan progresif DST tergantung pada setiap zona waktu. <br><br><h4>  Apakah zona waktu berubah? </h4><br>  Setiap negara sendiri menentukan zona waktu mana yang akan digunakan, sehingga waktu setempat dapat berubah karena alasan politik dan / atau ekonomi.  Misalnya, di Amerika Serikat, perbatasan DST diubah pada 2007 karena George W. Bush memulai kebijakan energi pada 2005.  Mesir dan Rusia digunakan untuk beralih ke waktu musim panas, tetapi telah meninggalkannya sejak 2011. <br><br>  Dalam beberapa kasus, pemerintah dapat mengubah tidak hanya waktu musim panas, tetapi juga waktu standar.  Sebagai contoh, Samoa sebelumnya menggunakan offset <code>UTC-10:00</code> , tetapi kemudian mereka beralih ke <code>UTC+14:00</code> untuk mengurangi kerugian dalam perdagangan karena perbedaan waktu dengan Australia dan Selandia Baru.  Keputusan ini menyebabkan hilangnya nyawa negara sepanjang hari - 30 Desember 2011, seperti dilansir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">surat kabar di seluruh dunia</a> . <br><br>  Di Belanda, offset <code>+0:19:32.13</code> digunakan sejak 1909, sejak 1937 negara tersebut beralih ke <code>+00:20</code> , dan dari 1940 hingga <code>+01:00</code> , sejak saat itu waktu utama tidak berubah di sana. <br><br><h2>  Zona Waktu 1: Offset N </h2><br>  Jadi, zona waktu dapat memiliki satu atau lebih offset.  Waktu mana yang diterima sebagai standar tergantung pada alasan politik dan / atau ekonomi saat ini di negara tertentu. <br><br>  Dalam kehidupan sehari-hari, ini tidak menimbulkan kesulitan sampai Anda mencoba mensistematisasikan data ini berdasarkan beberapa aturan.  Bayangkan Anda ingin mengatur waktu standar pada ponsel cerdas Anda menggunakan semacam bias.  Jika Anda tinggal di wilayah yang menerapkan waktu musim panas, maka ponsel cerdas Anda harus tahu persis kapan harus bolak-balik.  Artinya, Anda perlu membangun hubungan antara waktu standar dan musim panas dalam satu zona waktu (misalnya, Waktu Pasifik). <br><br>  Tetapi ini tidak dapat dilakukan dengan beberapa aturan sederhana.  Misalnya, ketika di AS pada 2007, awal dan akhir DST diubah, pada 31 Mei 2006 ia seharusnya menggunakan PDT ( <code>-07:00</code> ) sebagai waktu standar, dan pada 31 Maret 2007 - PST ( <code>-08:00</code> ).  Ternyata untuk merujuk ke zona waktu tertentu, Anda perlu mengetahui seluruh sejarah perubahan zona waktu atau tanggal perubahan aturan waktu musim panas. <br><br>  Anda dapat mengatakan: "Zona waktu di New York adalah PST ( <code>-08:00</code> )."  Namun, perlu diklarifikasi: "Zona waktu saat ini di New York adalah PST."  Selain itu, untuk implementasi sistem yang akurat, Anda perlu menggunakan ekspresi yang lebih akurat.  Lupakan istilah "zona waktu".  Anda harus mengatakan: "Sekarang di New York, PST digunakan sebagai waktu standar." <br><br>  Jadi apa yang harus kita gunakan daripada offset untuk menentukan zona waktu suatu wilayah tertentu?  Nama wilayah ini.  Lebih tepatnya, Anda harus mengelompokkan dalam satu zona waktu satu wilayah di mana mereka beralih sama ke musim panas dan waktu standar.  Anda dapat menggunakan nama seperti PT (Waktu Pasifik), tetapi mereka hanya menggabungkan waktu standar saat ini dan waktu musim panas, dan tidak selalu memperhitungkan semua perubahan historis.  Selain itu, karena PT hanya beredar di Amerika Serikat dan Kanada, Anda harus mengandalkan standar yang ditetapkan dari organisasi terkemuka untuk memastikan universalitas perangkat lunak Anda. <br><br><h2>  Database Zona Waktu IANA </h2><br>  Saya harus mengakui bahwa informasi tentang zona waktu lebih merupakan basis data, bukan seperangkat aturan, karena informasi ini harus mengandung semua perubahan historis yang relevan.  Ada beberapa database standar yang dirancang untuk menyelesaikan tugas yang berkaitan dengan zona waktu.  Paling sering, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Basis Data Zona Waktu IANA digunakan</a> , dan biasanya disebut basis data tz (atau tzdata).  Basis data berisi data historis tentang perubahan waktu standar dan DST di seluruh dunia.  Selain itu, ini diatur sehingga memungkinkan untuk memeriksa semua data historis dan memastikan waktu akurat mulai dari waktu Unix ( <code>1970.01/01 00:00:00</code> ).  Meskipun Anda dapat menemukan informasi dalam database bahkan sebelum tahun 1970, keakuratannya tidak dijamin. <br><br>  Konvensi penamaan menggunakan aturan wilayah / tempat.  Nama benua atau lautan (Asia, Amerika, Samudra Pasifik) biasanya digunakan sebagai wilayah, dan nama-nama kota utama (Seoul, New York) sebagai tempat.  Alasannya adalah bahwa kota biasanya lebih lama dari negara.  Misalnya, zona waktu Korea Selatan adalah <code>Asia/Seoul</code> dan Jepang <code>Asia/Tokyo</code> .  Meskipun kedua negara menggunakan offset <code>UTC+09:00</code> , waktu lokal mereka berubah secara berbeda, sehingga mereka dibagi ke dalam zona waktu yang berbeda. <br><br>  Basis IANA dijalankan oleh banyak komunitas pengembang dan sejarawan.  Data historis yang baru ditemukan segera dimasukkan ke dalamnya dan kebijakan saat ini diperbarui, sehingga database saat ini dapat dianggap sebagai sumber yang paling dapat diandalkan.  Selain itu, ini digunakan di bawah tenda oleh banyak sistem Unix, termasuk Linux dan MacOS, serta sejumlah bahasa pemrograman populer, termasuk Java dan PHP. <br><br>  Harap dicatat bahwa Windows menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">database Microsoft</a> .  Namun, itu tidak akurat dalam hal data historis dan hanya didukung oleh Microsoft sendiri.  Oleh karena itu, basisnya kurang dapat diandalkan dibandingkan dengan basis IANA. <br><br><h2>  JavaScript dan IANA </h2><br>  Fungsionalitas terkait zona waktu diimplementasikan dalam JavaScript secara tiba-tiba.  Secara default, bahasa tersebut menggunakan sabuk wilayah saat ini (lebih tepatnya, sabuk yang dipilih selama instalasi OS), dan tidak ada cara untuk mengubahnya.  Selain itu, bahkan spesifikasi untuk standar basis data dalam JavaScript tidak jelas, dan Anda sendiri akan memahami ini jika Anda memutuskan untuk berurusan dengan spesifikasi untuk ES2015.  Tentang zona waktu lokal dan ketersediaan DST, hanya ada beberapa pernyataan yang tidak jelas.  Sebagai contoh, DST didefinisikan sebagai berikut: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ECMAScript 2015 - Penyesuaian Waktu Siang Hari</a> . <br><br><blockquote>  Ini adalah algoritme yang bergantung pada implementasi yang menggunakan informasi zona waktu terbaik yang tersedia untuk menentukan pengaturan DaylightSavingTA (t) waktu siang hari lokal, yang dihitung dalam milidetik.  Implementasi ECMAScript akan membantu Anda menentukan pengaturan waktu musim panas lokal yang lebih baik. </blockquote><br>  Sepertinya mereka hanya berkata, "Dudes, cobalah untuk membuatnya bekerja."  Antara lain, Anda harus menyelesaikan masalah kompatibilitas dengan browser yang berbeda.  Anda berkata, "Benar-benar kacau!" Dan kemudian bacalah baris berikut: <br><br><blockquote>  Catatan: kami sarankan Anda menggunakan informasi dari basis data zona waktu IANA <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://www.iana.org/time-zones/</a> dalam implementasi Anda. </blockquote><br>  Ya  Spesifikasi ECMA memberi Anda bola dengan rekomendasi bersahaja untuk menggunakan basis data IANA, karena JavaScript tidak memiliki basis data standar khusus.  Akibatnya, browser yang berbeda menggunakan operasi mereka sendiri dengan zona waktu, yang sering tidak kompatibel satu sama lain, untuk menghitung waktu.  Kemudian, di ECMA, untuk API internasional, opsi untuk menggunakan data IANA dalam format ECMA-402 <code>Intl.DateTimeFormat</code> .  Tetapi opsi ini jauh lebih tidak dapat diandalkan daripada analog dalam bahasa pemrograman lain. <br><br><h2>  Zona waktu di lingkungan server-klien </h2><br>  Pertimbangkan skenario sederhana: kita perlu menentukan zona waktu.  Misalkan kita membuat kalender yang akan memproses informasi waktu.  Ketika pengguna di lingkungan klien memasukkan tanggal dan waktu di jendela registrasi, tanggal tersebut ditransfer ke server dan disimpan dalam database.  Kemudian klien menerima dari server tanggal yang terdaftar dalam jadwal untuk ditampilkan di layar. <br><br>  Di sini Anda perlu memutuskan sesuatu.  Bagaimana jika beberapa klien yang mengakses server berada di zona waktu yang berbeda?  Acara dalam jadwal, yang didaftarkan di Seoul pada 10 Maret 2017 pukul 23.30, di New York harus ditampilkan sebagai 10 Maret 2017 pukul 9.30.  Agar server dapat melayani klien dari zona waktu yang berbeda, jadwal yang disimpan di dalamnya harus berisi nilai absolut yang tidak bergantung pada zona.  Setiap server memiliki cara sendiri untuk menyimpan nilai-nilai tersebut, pertanyaan ini berada di luar cakupan artikel, karena semuanya tergantung pada server atau database tertentu.  Secara umum, tanggal dan waktu yang ditransmisikan dari klien ke server harus disajikan baik dalam bentuk nilai berdasarkan pada offset tunggal (biasanya UTC), atau dalam bentuk nilai yang berisi informasi tentang zona waktu lingkungan klien. <br><br>  Biasanya, data tersebut dikirim sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">waktu Unix</a> dalam format UTC atau sesuai dengan standar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ISO-8601</a> dengan informasi offset.  Jika dalam contoh kami, kami mengonversi Seoul 21.30 pada 10 Maret 2017 ke waktu Unix, maka kami mendapatkan nilai integer <code>1489113000</code> .  Dan dalam format ISO-8601, nilai string adalah <code>2017–03–10T11:30:00+09:00</code> . <br><br>  Jika Anda menggunakan JavaScript di lingkungan peramban, Anda harus mengonversi nilai yang dimasukkan seperti yang dijelaskan di atas, lalu mengonversi kembali untuk mencocokkan zona waktu pengguna.  Penting untuk menyelesaikan kedua masalah ini.  Dari sudut pandang bahasa pemrograman, operasi pertama disebut "parsing", dan yang kedua adalah "pemformatan".  Sekarang mari kita lihat bagaimana hal ini dilakukan dalam JavaScript. <br><br>  Bahkan ketika Anda bekerja dengan JS di lingkungan server menggunakan Node.js, Anda mungkin perlu mengurai data yang diterima dari klien.  Tetapi karena zona waktu server dan database biasanya disinkronkan, dan pemformatan ditugaskan untuk klien, dalam lingkungan browser Anda perlu memutuskan beberapa faktor.  Lebih lanjut saya akan menjelaskan sehubungan dengan lingkungan browser. <br><br><h2>  Objek Tanggal JavaScript </h2><br>  Tugas yang melibatkan pekerjaan dengan waktu atau waktu tertentu diselesaikan dengan menggunakan objek <code>Date</code> .  Ini adalah objek asli yang didefinisikan dalam ECMAScript, seperti <code>Array</code> atau <code>Function</code> .  Artinya, sebagian besar, diimplementasikan menggunakan kode asli seperti C ++.  API dijelaskan dengan baik dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi MDN</a> .  Kelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">java.util.Date</a> dari Java memiliki dampak besar pada objek, sehingga mewarisi beberapa properti yang tidak diinginkan, seperti karakteristik data yang bisa berubah dan satu bulan mulai dari nol. <br><br>  Di bawah tenda, objek <code>Date</code> JavaScript bekerja dengan waktu menggunakan nilai absolut dalam format waktu-Unix.  Tetapi konstruktor dan metode seperti fungsi <code>parse()</code> , <code>getHour()</code> , <code>setHour()</code> dan lainnya dipengaruhi oleh zona waktu klien (lebih tepatnya, sabuk yang ditentukan dalam OS di mana browser berjalan).  Jadi, jika Anda membuat objek <code>Date</code> secara langsung menggunakan data yang dimasukkan pengguna, maka zona waktu lokal klien akan tercermin dalam data ini. <br><br>  Seperti yang saya sebutkan, JavaScript tidak memberikan cara apa pun untuk mengubah zona waktu secara sewenang-wenang.  Karenanya, kami menganggap bahwa kami dapat langsung menggunakan nilai zona waktu yang ditentukan di browser. <br><br><h2>  Membuat Objek Tanggal Menggunakan Input Pengguna </h2><br>  Mari kita kembali ke contoh pertama.  Misalkan seorang pengguna memasukkan waktu Seoul pada perangkatnya pada jam 11.30 pada tanggal 11 Maret 2017. Data ini disimpan sebagai lima angka: 2017, 2, 11, 11 dan 30 - masing-masing tahun, bulan, hari, jam dan menit (sejak bulan dimulai dari 0, itu nilainya harus 3-1 = 2).  Menggunakan konstruktor, Anda dapat dengan mudah membuat objek <code>Date</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(<span class="hljs-number"><span class="hljs-number">2017</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>); d1.toString(); <span class="hljs-comment"><span class="hljs-comment">// Sat Mar 11 2017 11:30:00 GMT+0900 (KST)</span></span></code> </pre> <br>  Jika Anda melihat nilai yang dikembalikan oleh <code>d1.toString()</code> , Anda akan melihat bahwa nilai absolut dari objek yang dibuat adalah 11:00 pada 11 Maret 2017, itu dihitung menggunakan pencampuran <code>+09:00</code> (KST). <br><br>  Anda dapat menggunakan data string di konstruktor.  Jika Anda menerapkannya ke <code>Date</code> , objek memanggil <code>Date.parse()</code> internal dan <code>Date.parse()</code> benar.  Fitur ini mendukung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">spesifikasi RFC2888</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ISO-8601</a> .  Tetapi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi MDN untuk Date.parse ()</a> mengatakan bahwa nilai yang dikembalikan oleh metode ini tergantung pada browser, dan format tipe string dapat memengaruhi nilai akhir yang tepat.  Karena itu, lebih baik tidak menggunakan metode ini.  Misalnya, di Safari dan Internet Explorer, nilai string seperti <code>2015–10–12 12:00:00</code> mengembalikan <code>NaN</code> , sementara di Chrome dan Firefox mengembalikan nilai zona waktu lokal.  Dalam beberapa situasi, nilai berbasis UTC dikembalikan. <br><br><h2>  Membuat Objek Tanggal Menggunakan Data Server </h2><br>  Misalkan Anda ingin menerima data dari server.  Jika mereka dalam bentuk waktu Unix numerik, maka Anda cukup menggunakan konstruktor untuk membuat objek <code>Date</code> .  Saya belum menyebutkan bahwa ketika konstruktor <code>Date</code> menerima nilai tunggal sebagai parameter tunggal, itu menghitung nilai waktu Unix dalam milidetik (catatan: JS memproses waktu Unix dalam milidetik. Ini berarti bahwa nilai kedua harus dikalikan dengan 1000).  Saat menjalankan kode berikut, kami mendapatkan nilai yang sama seperti pada contoh sebelumnya: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(<span class="hljs-number"><span class="hljs-number">1489199400000</span></span>); d1.toString(); <span class="hljs-comment"><span class="hljs-comment">// Sat Mar 11 2017 11:30:00 GMT+0900 (KST)</span></span></code> </pre> <br>  Dan jika bukan waktu Unix gunakan tipe string ISO-8601?  Seperti yang saya jelaskan di atas, maka metode <code>Date.parse()</code> menjadi tidak dapat diandalkan dan lebih baik tidak menggunakannya.  Namun, dimulai dengan ECMAScript 5, Anda dapat menggunakan konstruksi string dalam format ISO-8601 di konstruktor <code>Date</code> di Internet Explorer 9.0 dan lebih tinggi. <br><br>  Jika Anda tidak menggunakan browser terbaru, maka pastikan <code>Z</code> di akhir nilai.  Tanpanya, browser lama Anda dapat menginterpretasikan nilai berdasarkan waktu setempat, bukan UTC.  Berikut adalah contoh penggunaan di Internet Explorer 10: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(<span class="hljs-string"><span class="hljs-string">'2017-03-11T11:30:00'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(<span class="hljs-string"><span class="hljs-string">'2017-03-11T11:30:00Z'</span></span>); d1.toString(); <span class="hljs-comment"><span class="hljs-comment">// "Sat Mar 11 11:30:00 UTC+0900 2017" d2.toString(); // "Sat Mar 11 20:30:00 UTC+0900 2017"</span></span></code> </pre> <br>  Menurut spesifikasi, dalam kedua kasus nilai yang sama harus diperoleh.  Tetapi mereka berbeda.  Di browser yang lebih baru, nilainya akan sama.  Untuk mencegah masalah ini, selalu tambahkan <code>Z</code> di akhir baris jika informasi zona waktu tidak tersedia. <br><br><h2>  Membuat Tanggal untuk Lulus ke Server </h2><br>  Sekarang Anda dapat menggunakan <code>Date</code> dibuat sebelumnya, dengan bebas mengambil atau menambah waktu berdasarkan zona waktu setempat.  Hanya pada akhir pemrosesan jangan lupa untuk mengkonversi data ke format sebelumnya sebelum mengembalikannya ke server. <br><br>  Jika ini waktu Unix, Anda dapat menggunakan metode <code>getTime()</code> (jangan lupa tentang milidetik). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(<span class="hljs-number"><span class="hljs-number">2017</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>); d1.getTime(); <span class="hljs-comment"><span class="hljs-comment">// 1489199400000</span></span></code> </pre> <br>  Bagaimana dengan nilai string dalam format ISO-8601?  Seperti yang saya katakan, Internet Explorer 9.0 dan di atasnya mendukung ECMAScript 5, dan versi yang lebih baru mendukung ISO-8601.  Oleh karena itu, menggunakan metode <code>toISOString()</code> atau <code>toJSON()</code> , Anda dapat membuat string di ISO-8601 ( <code>toJSON()</code> dapat digunakan untuk panggilan rekursif dengan <code>JSON.stringify()</code> dan lainnya).  Kedua metode memberikan hasil yang sama, kecuali saat memproses data yang tidak valid: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(<span class="hljs-number"><span class="hljs-number">2017</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>); d1.toISOString(); <span class="hljs-comment"><span class="hljs-comment">// "2017-03-11T02:30:00.000Z" d1.toJSON(); // "2017-03-11T02:30:00.000Z" const d2 = new Date('Hello'); d2.toISOString(); // Error: Invalid Date d2.toJSON(); // null</span></span></code> </pre> <br>  Anda dapat menggunakan metode <code>toGMTString()</code> atau <code>toUTCString()</code> untuk membuat string UTC.  Ini akan menghasilkan nilai yang sesuai dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RFC-1123</a> . <br><br>  Objek <code>Date</code> termasuk <code>toString()</code> , <code>toLocaleString()</code> dan metode ekstensi mereka.  Tetapi mereka sedikit berguna, karena mereka digunakan terutama untuk mengembalikan string berdasarkan zona waktu lokal, dan nilai yang dikembalikan tergantung pada browser dan OS. <br><br><h2>  Ubah zona waktu lokal Anda </h2><br>  Seperti yang Anda lihat, ada semacam dukungan zona waktu di JS.              ?           ?      , JS       .         ,         .   .  ,   . <br><br>      .       .     11.30 11  2017       - .     Unix-    ,  -   <code>-05:00</code> .    ,       . <br><br>       <code>getTimeZoneOffset()</code> .   API  JavaScript,        .        : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> seoul = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(<span class="hljs-number"><span class="hljs-number">1489199400000</span></span>); seoul.getTimeZoneOffset(); <span class="hljs-comment"><span class="hljs-comment">// -540</span></span></code> </pre> <br>  <code>-540</code> ,     540   .    ,      ( <code>+09:00</code> ).  , ,    .          -,   <code>60 * 5 = 300</code> .   <code>840</code>       <code>Date</code> .     <code>getXX</code>       .       : <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">formatDate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">date</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> date.getFullYear() + <span class="hljs-string"><span class="hljs-string">'/'</span></span> + (date.getMonth() + <span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-string"><span class="hljs-string">'/'</span></span> + date.getDate() + <span class="hljs-string"><span class="hljs-string">' '</span></span> + date.getHours() + <span class="hljs-string"><span class="hljs-string">':'</span></span> + date.getMinutes(); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> seoul = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(<span class="hljs-number"><span class="hljs-number">1489199400000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ny = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(<span class="hljs-number"><span class="hljs-number">1489199400000</span></span> - (<span class="hljs-number"><span class="hljs-number">840</span></span> * <span class="hljs-number"><span class="hljs-number">60</span></span> * <span class="hljs-number"><span class="hljs-number">1000</span></span>)); formatDate(seoul); <span class="hljs-comment"><span class="hljs-comment">// 2017/3/11 11:30 formatDate(ny); // 2017/3/10 21:30</span></span></code> </pre> <br> <code>formatDate()</code>              -. ,    .        ,      ?  , .   ,      —   ,     .                ( ). <br><br><h2>      </h2><br>       ,     . ,       -,      11  15 .    <code>setDate()</code>   <code>Date</code> ,    ,    . <br><br><pre> <code class="javascript hljs">ny.setDate(<span class="hljs-number"><span class="hljs-number">15</span></span>); formatDate(ny); <span class="hljs-comment"><span class="hljs-comment">// 2017/3/15 21:30</span></span></code> </pre> <br>  ,    .  ,      ?   ,       <code>getTime()</code>  <code>getISOString()</code> .     ,      . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> time = ny.getTime() + (<span class="hljs-number"><span class="hljs-number">840</span></span> * <span class="hljs-number"><span class="hljs-number">60</span></span> * <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 1489631400000</span></span></code> </pre> <br>   ,      ,         .             <code>Date</code>   ?  Tidak.    <code>Date</code>        11-  15-,   4  ( <code>24 * 4 * 60 * 60 * 1000</code> ).      -     10-  15-,    5  ( <code>24* 5 * 60 * 60 * 1000</code> ).             . <br><br>     .     ,     .   -     12 ,   15  2017  <code>-04:00</code> ,   <code>-05:00</code> .      ,    780 ,   60  ,   . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> time = ny.getTime() + (<span class="hljs-number"><span class="hljs-number">780</span></span> * <span class="hljs-number"><span class="hljs-number">60</span></span> * <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 1489627800000</span></span></code> </pre> <br>   ,        -      ,         . <br><br>  ,                .    ,    ,   ,       .       ,     ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> IANA</a> . <br><br>         ,         <code>Date</code>      ,        .  ,   .         ,        .    .        JS    .     . <br><br><h2> Moment Timezone </h2><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Moment</a> —  JavaScript-,   .    API     ,        .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Moment Timezone</a> ,     .     IANA        API,         . <br><br>           .  ,         .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . <br><br> ,  Moment Timezone: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> seoul = moment(<span class="hljs-number"><span class="hljs-number">1489199400000</span></span>).tz(<span class="hljs-string"><span class="hljs-string">'Asia/Seoul'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ny = moment(<span class="hljs-number"><span class="hljs-number">1489199400000</span></span>).tz(<span class="hljs-string"><span class="hljs-string">'America/New_York'</span></span>); seoul.format(); <span class="hljs-comment"><span class="hljs-comment">// 2017-03-11T11:30:00+09:00 ny.format(); // 2017-03-10T21:30:00-05:00 seoul.date(15).format(); // 2017-03-15T11:30:00+09:00 ny.date(15).format(); // 2017-03-15T21:30:00-04:00</span></span></code> </pre> <br>  <code>seoul</code>  ,   <code>ny</code>   <code>-05:00</code>  <code>-04:00</code> .     <code>format()</code> ,      ISO-8601,     .       . <br><br><h2>  Kesimpulan </h2><br>   API  ,   JavaScript,     .          ,         API,   Internet Explorer 9  .     ,     .                  ,     <code>getTimezoneOffset()</code> .        ,     .     Moment Timezone. <br><br>     ,   ,   .      :  .   ,    ,    ,   .      ,      JavaScript    .   ,      . <br><br><h2>   </h2><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pluralsight: Date and Time Fundamentals</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wikipedia: timezone</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wikipedia: DST</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wikipedia: Unix Time</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wikipedia: ISO-8601</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IANA timezone Database</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Microsoft Daylight Saving Time &amp; Time Zone Blog</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MDN: Date API</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">java.util.Date API</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Moment Timezone</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RFC-1123</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RFC2888</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id438286/">https://habr.com/ru/post/id438286/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id438270/index.html">Love Kubernetes di Mail.ru Group: 14 Februari</a></li>
<li><a href="../id438272/index.html">Bagaimana kami mengirim SMS dari gua</a></li>
<li><a href="../id438274/index.html">Definisi "kepribadian beracun" di TI</a></li>
<li><a href="../id438278/index.html">Mengajar anak-anak ke program</a></li>
<li><a href="../id438280/index.html">"Menghapus" objek di Django</a></li>
<li><a href="../id438288/index.html">Perlindungan tanpa rasa takut. Keamanan Memori dalam Karat</a></li>
<li><a href="../id438290/index.html">Post-mortem dengan GGJ-2019: bagaimana cara mendapatkan gundukan, tetapi tetap membuat game</a></li>
<li><a href="../id438292/index.html">Otomasi Apartemen dengan HomePod, Raspberry Pi dan Node.js</a></li>
<li><a href="../id438294/index.html">Menemukan Stream Twitch dalam Pertandingan PUBG</a></li>
<li><a href="../id438296/index.html">OpenSceneGraph: Sistem Plugin</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>