<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👼🏻 🚈 👲🏿 Bagaimana cara berbagi arsitektur dan implementasi tanpa pertengkaran 👮 🥗 🏊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Menciptakan sistem baru adalah proses multi-tahap: elaborasi konsep dan desain, desain arsitektur, implementasi, pengujian, rilis. Desain dan implemen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana cara berbagi arsitektur dan implementasi tanpa pertengkaran</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435386/"><p>  Menciptakan sistem baru adalah proses multi-tahap: elaborasi konsep dan desain, desain arsitektur, implementasi, pengujian, rilis.  Desain dan implementasi arsitektur adalah tahapan yang menjadi perhatian utama pengembang. </p><br><p>  Kebanyakan pengembang suka terlibat dalam arsitektur, memikirkan bagaimana sistem atau bagiannya akan diatur dari awal.  Jika seseorang yang telah memikirkan arsitektur sistem dan akan mengimplementasikannya, tidak ada masalah dengan motivasi: programmer akan menerima kepuasan dari realisasi ide-idenya.  Tetapi jika satu pemikiran arsitektur, dan yang lain akan terlibat dalam implementasi, maka yang terakhir mungkin memiliki kemarahan alami: mereka memikirkan segalanya untuk saya, tetapi bisakah saya melakukan apa yang tertulis? </p><br><p><img src="https://habrastorage.org/webt/vj/ii/ox/vjiioxfop6iqofh1irlgn_kuueo.jpeg"></p><br><p>  Bagaimana menghindari situasi seperti itu, mengapa implementasi bisa tidak kalah menarik daripada penjabaran arsitektur, dan kadang-kadang lebih, akan dibahas dalam artikel ini. </p><a name="habracut"></a><br><h1 id="vvedenie">  Pendahuluan </h1><br><p>  Arsitektur yang dipikirkan dengan matang dapat digunakan sebagai dasar untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tugas pemecahan</a> : implementasi setiap komponen yang cukup terpisah menjadi subtugas yang terpisah. </p><br><p>  Misalnya, jika ada saluran pipa untuk permintaan pemrosesan, yang disusun secara arsitektur dalam gaya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pipa &amp; filter</a> , maka subtugas akan menjadi implementasi dari setiap langkah pemrosesan (setiap langkah memiliki subtugas sendiri) dan subtugas lain untuk menghubungkan semua langkah bersama. </p><br><p>  Meskipun arsitektur yang dipikirkan dengan matang dan pengelompokan menjadi subtugas memberikan gambaran umum tentang cara membuat sistem dan memungkinkan Anda untuk mengevaluasi biaya tenaga kerja, mereka tidak cukup untuk mengimplementasikan rencana tersebut.  Deskripsi subtugas akan mengatakan apa yang harus dilakukan komponen, mungkin berisi persyaratan untuk kecepatan dan konsumsi memori, tetapi tidak akan memberikan instruksi komprehensif tentang cara melakukannya. </p><br><p>  Faktanya adalah bahwa ada banyak opsi untuk membuat komponen yang memenuhi persyaratan yang ditentukan.  Banyak tergantung pada bagaimana itu akan diterapkan: fleksibilitas kode, ekstensibilitasnya, kemudahan dukungan, dll.  Kami mendekati konsep <em>desain kode</em> . </p><br><h1 id="koncepciya-dizayna-koda">  Konsep Desain Kode </h1><br><p>  Terkadang desain kode disebut arsitektur atau organisasi kode, terkadang bahkan hanya arsitektur.  Saya tetap berpegang pada <em>desain kode</em> istilah karena kontras dengan arsitektur sistem dan menarik garis yang jelas di antara mereka.  Untuk lebih spesifik, pertimbangkan sebuah contoh. </p><br><p>  Katakanlah kita sedang mengembangkan backend situs yang mendapatkan popularitas.  Jumlah server telah melampaui beberapa puluh, pemirsa bertambah, dan kami memutuskan bahwa kami ingin mengumpulkan analitik tentang perilaku pengguna di situs: popularitas halaman mengunjungi, frekuensi penggunaan fitur tergantung pada profil pengguna, dll. </p><br><p>  Sejumlah masalah arsitektur dan teknologi muncul: di mana menyimpan metrik, cara mentransfernya melalui jaringan, apa yang harus dilakukan jika toko metrik tidak tersedia, bagaimana layanan backend akan mencatat metrik, dll.  Arsitektur hanya perlu menjawab pertanyaan-pertanyaan ini, menentukan komponen solusi dan menetapkan persyaratan untuknya. </p><br><p>  Misalkan kita telah mengembangkan arsitektur: kita akan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">InfluxDB</a> sebagai penyimpanan, transfer metrik melalui jaringan menggunakan UDP ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">telegraf</a> , dan untuk menghindari ketidaktersediaan penyimpanan, kita akan menyimpan metrik dalam Kafka yang direplikasi di beberapa server.  Semua metrik akan menjalankan layanan backend -&gt; telegraf -&gt; Kafka -&gt; InfluxDB.  Untuk menulis metrik, backend memutuskan untuk menulis modul yang mengimplementasikan fungsi transfer metrik di telegraf menggunakan UDP. </p><br><p>  Modul untuk merekam metrik adalah komponen terpisah dari sistem, penulisan adalah sub-tugas terpisah yang dapat dipercayakan kepada pengembang.  Subtugas ini memiliki banyak solusi dan pertanyaan yang perlu dijawab: metrik akan dikirim secara sinkron atau tidak sinkron;  bagaimana akses simultan beberapa thread backend akan disinkronkan, apa yang akan menjadi kelas / fungsi utama. </p><br><p>  Pertanyaan-pertanyaan ini berada di luar deskripsi arsitektur solusi, tetapi jawaban mereka memiliki konsekuensi yang luas.  Sebagai contoh, jika selama operasi solusi menjadi jelas bahwa tumpukan teknologi tidak optimal dan Anda perlu mengganti telegraf dengan solusi alternatif, maka pembagian modul yang salah ke dalam kelas tidak akan memungkinkan hal ini tanpa menulis ulang seluruh modul.  Jawaban atas pertanyaan-pertanyaan ini adalah <strong>domain dari desain kode</strong> . </p><br><p>  <strong>Pengembangan desain kode adalah tahap desain terpisah</strong> , yang terletak antara pengembangan arsitektur sistem dan pengkodean.  Menggambar garis antara arsitektur dan desain kode memungkinkan Anda untuk merancang sistem tanpa mempertimbangkan semua detail dan mengevaluasi biaya tenaga kerja dalam waktu yang terbatas.  Di sisi lain, menyoroti pengembangan desain kode sebagai tahap implementasi terpisah memungkinkan Anda untuk meningkatkan kualitas implementasi sistem, mengurangi biaya perbaikan lebih lanjut, dan meningkatkan kemudahan dukungan. </p><br><p>  Kebutuhan untuk memikirkan desain kode pada tahap implementasi sebelum pengkodean <strong>membuat implementasi menarik</strong> : tugas-tugas merancang desain kode bisa tidak kalah menarik daripada merancang seluruh sistem di tingkat arsitektur.  Gagasan ini diungkapkan oleh Brooks di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bulan mitos manusia</a> . </p><br><p>  Tentu saja, menggambar garis antara arsitektur dan desain kode mungkin tidak mudah, mari kita melihat lebih dekat masalah ini. </p><br><h1 id="granica-mezhdu-arhitekturoy-i-dizaynom-koda">  Batas antara arsitektur dan desain kode </h1><br><p>  Secara ideologis, desain arsitektur dan kode berada pada level desain yang berbeda: arsitektur dipikirkan pada tahap paling awal, ketika ada sedikit kepastian, dan memikirkan desain kode menambah detail.  Dengan demikian, mereka dieksekusi pada titik yang berbeda dalam waktu: arsitektur lebih dekat ke awal, dan desain kode selama implementasi subtugas. </p><br><p>  Menggambar batas antara dua tahap desain ini tergantung pada sejumlah faktor, berikut adalah yang utama: </p><br><ul><li>  Sejauh mana komponen mempengaruhi sistem.  Kadang-kadang perangkat seluruh sistem dapat secara signifikan bergantung pada perangkat komponen individualnya.  Dalam hal ini, Anda perlu mendesain komponen pada tahap pengembangan arsitektur, dan bukan pada tahap implementasi. </li><li>  Kehadiran antarmuka yang jelas untuk komponen.  Dimungkinkan untuk mengisolasi desain komponen sebagai subtugas hanya jika ia dengan jelas mendefinisikan apa yang harus dilakukan komponen ini dan bagaimana ia akan berinteraksi dengan bagian lain dari sistem. </li><li>  Perkiraan realistis dari upaya untuk melengkapi subtugas.  Tugas itu mungkin terlalu besar untuk dapat mengevaluasi biaya tenaga kerja dengan akurasi yang memadai.  Dalam hal ini, lebih baik untuk merancang tugas secara lebih rinci dan memecahnya menjadi subtugas sendiri untuk memberikan penilaian biaya tenaga kerja yang lebih memadai. </li></ul><br><p>  Ada beberapa kasus khusus di mana Anda dapat menarik garis yang baik antara desain arsitektur dan desain kode. </p><br><p>  <strong>Komponen memiliki API yang ketat.</strong> <br>  Sebagai contoh, dalam praktik saya ada tugas: untuk mengimplementasikan di atas UNIX socket API untuk menangkap / melepaskan sumber daya OS yang digunakan oleh daemon yang ada.  Tugas ini muncul dalam kerangka arsitektur yang dipilih untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fitur epik</a> baru.  Dalam kerangka arsitektur, itu agak tingkat tinggi untuk menggambarkan API, dan desain rinci dilakukan kemudian, selama implementasi. </p><br><p>  <strong>Modul / kelas dengan antarmuka yang diberikan</strong> <br>  Cara termudah untuk mendelegasikan desain bagian dari sistem monolitik adalah dengan menyoroti modul atau kelas, mendeskripsikan antarmuka dan tugasnya.  Modul yang dialokasikan sebagai subtugas yang terpisah tidak boleh terlalu besar.  Sebagai contoh, perpustakaan klien untuk akses ke database shard tidak diragukan lagi merupakan modul yang terpisah, tetapi tugas mengimplementasikan perpustakaan ini akan sulit untuk dievaluasi dengan biaya tenaga kerja tanpa desain yang lebih rinci.  Di sisi lain, tugas menerapkan kelas yang terlalu kecil akan sepele.  Misalnya, jika subtugas “untuk mengimplementasikan fungsi yang memeriksa keberadaan folder yang diberikan oleh jalur yang diberikan” muncul, maka arsitekturnya dipikirkan dengan sangat rinci. </p><br><p>  <strong>Komponen kecil dengan persyaratan tetap</strong> <br>  Jika komponen cukup kecil dan masalah yang diselesaikannya ditentukan secara ketat, maka biaya tenaga kerja untuk implementasi dapat diperkirakan dengan akurasi yang cukup, dan implementasi komponen itu sendiri akan meninggalkan ruang untuk desain.  Contoh: proses yang berjalan pada mahkota dan menghapus file dan direktori lama secara rekursif di jalur yang diberikan. </p><br><h1 id="antipatterny">  Antipatterns </h1><br><p>  Ada beberapa skenario ketika distribusi antara pemikiran arsitektur dan implementasi tidak benar, beberapa di antaranya dibahas di bawah ini. </p><br><p>  <strong>Semuanya dirancang dengan detail terkecil.</strong> <br>  Diagram UML terperinci dibangun, tanda tangan dari masing-masing metode dari setiap kelas ditentukan, algoritma untuk menerapkan metode individual dijelaskan ... Menurut deskripsi terperinci seperti itu, Anda dapat mengimplementasikan sistem dengan paling cepat, sungguh, karena semuanya direncanakan dengan detail sedemikian rupa sehingga tidak ada ruang untuk kreativitas sama sekali, ambil dan lakukan tertulis  Jika tujuannya adalah agar pengembang membuat kode apa yang mereka katakan kepadanya secepat mungkin, maka ya, Anda bisa. </p><br><p>  Namun, jika Anda menggali sedikit lebih dalam, itu akan menjadi jelas sejumlah kekurangan dalam organisasi kerja dalam nada ini.  Pertama, untuk mendesain segala sesuatu dalam detail seperti itu, Anda harus menghabiskan banyak waktu pada desain itu sendiri.  Apa yang biasanya dipikirkan pengembang sebelum implementasi, arsitek akan pikirkan dalam skema ini: semua desain bergeser lebih dekat ke awal proyek, yang dapat meningkatkan durasinya.  Lagi pula, jika Anda tidak memecah pekerjaan desain menjadi bagian-bagian, maka Anda tidak akan dapat memparalelkannya.  Kedua, kurangnya pekerjaan desain selama implementasi akan sangat mengurangi motivasi pengembang: melakukan apa yang mereka katakan dapat bermanfaat bagi pemula, tetapi pengembang yang berpengalaman akan bosan.  Ketiga, pendekatan ini umumnya dapat mengurangi kualitas output: sistem, yang tidak dibagi menjadi komponen yang cukup independen, akan lebih sulit untuk dipertahankan dan dikembangkan. </p><br><p>  <strong>Arsitektur selalu dirancang oleh satu pengembang, sisanya</strong> <del>  <strong>samping merokok</strong> </del>  <strong>hanya sadar</strong> <br>  Pertama-tama, beberapa kasus harus dicatat ketika ini dapat bermanfaat.  Pertama, ini adalah tim di mana ada banyak pemula dan hanya satu programmer yang berpengalaman.  Dalam hal ini, pemula tidak memiliki pengalaman yang cukup untuk mendesain arsitektur untuk melakukan pekerjaan dengan kualitas yang memadai, sementara pada saat yang sama, implementasi arsitektur yang dipikirkan dengan matang akan membantu mereka untuk meningkatkan level mereka.  Kedua, ini adalah proyek besar yang melibatkan beberapa tim.  Kemudian desain arsitektur proyek dibagi menjadi dua tingkatan: arsitek memikirkannya secara keseluruhan, dan masing-masing tim - arsitektur komponen dalam area tanggung jawabnya. </p><br><p>  Tetapi pertimbangkan satu tim yang terdiri dari spesialis yang cukup berpengalaman.  Jika tugas arsitektural akan selalu ditugaskan hanya untuk satu, katakanlah, pengembang yang paling berpengalaman, maka pengembang lain tidak akan dapat sepenuhnya mengungkapkan kemampuan mereka.  Arsitektur sistem akan satu sisi, karena setiap orang memiliki serangkaian teknik yang ia terapkan.  Jika pengembang yang berbeda memikirkan arsitektur komponen / subsistem yang berbeda, ini akan memfasilitasi pertukaran pengalaman dan pengembangan anggota tim.  Bahkan anggota tim yang tidak terlalu berpengalaman kadang-kadang harus diberikan tugas arsitektur: ini akan meningkatkan level mereka dan meningkatkan keterlibatan mereka dalam proyek. </p><br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><p>  Kehadiran tahap desain dalam implementasi adalah faktor utama yang membuat tugas implementasi menarik.  Tentu saja, ada yang lain: penggunaan teknologi baru, tugas penelitian, tetapi mereka, sebagai aturan, jauh lebih jarang terjadi.  Jika tugas implementasi tidak memerlukan desain dan akan terdiri dari pengkodean sederhana, maka ini akan sangat memengaruhi motivasi pengembang dan tidak akan mengizinkan penggunaan keterampilan mereka. </p><br><p>  Merancang desain kode pada tahap implementasi memungkinkan Anda untuk dengan cepat membuat estimasi yang memadai tentang biaya tenaga kerja, lebih memaralelkan pekerjaan, dan secara umum meningkatkan kualitas sistem. <br>  Kebutuhan untuk merancang desain kode selama implementasi adalah apa yang membuat implementasi bekerja menarik di mata pengembang. </p><br><p>  Tidak ada salahnya melakukan kesalahan, tidak termasuk pekerjaan desain dari penerapan subtugas, sama seperti Anda tidak harus selalu mempercayakan tugas arsitektur hanya kepada pengembang yang paling berpengalaman. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id435386/">https://habr.com/ru/post/id435386/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id435372/index.html">Beberapa kata tentang FastPath dan FastTrack di MikroTik</a></li>
<li><a href="../id435374/index.html">Matematika di Gamedev sederhana. Triangulasi dan Triangle.Net di Unity</a></li>
<li><a href="../id435376/index.html">Ruang 2019: kapal berawak, roket baru, dan wahana bulan</a></li>
<li><a href="../id435380/index.html">Akun gratis di GitHub akan dapat [hampir] tanpa batasan bekerja dengan repositori pribadi</a></li>
<li><a href="../id435384/index.html">Bagaimana saya membuat game online saya. Bagian 1: Jaringan</a></li>
<li><a href="../id435388/index.html">Internet di Kuba. Dari revolusi ke revolusi</a></li>
<li><a href="../id435390/index.html">Mesin 3D di dalam query SQL</a></li>
<li><a href="../id435394/index.html">Hasil fisik tahun ini</a></li>
<li><a href="../id435398/index.html">Meta-games: Pengalaman saya dalam membuat kontes untuk manajer penjualan</a></li>
<li><a href="../id435400/index.html">Hadiah $ 1 Juta Diumumkan untuk WhatsApp dan Informasi Hack iMessage</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>