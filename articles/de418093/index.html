<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤵🏻 🙏🏻 🛋️ MIT-Kurs "Computer Systems Security". Vorlesung 3: Pufferüberläufe: Exploits und Schutz, Teil 2 🔖 🤚🏽 🍊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Massachusetts Institute of Technology. Vorlesung # 6.858. "Sicherheit von Computersystemen." Nikolai Zeldovich, James Mickens. 2014 Jahr 
 Computer Sy...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MIT-Kurs "Computer Systems Security". Vorlesung 3: Pufferüberläufe: Exploits und Schutz, Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/418093/"><h3>  Massachusetts Institute of Technology.  Vorlesung # 6.858.  "Sicherheit von Computersystemen."  Nikolai Zeldovich, James Mickens.  2014 Jahr </h3><br>  Computer Systems Security ist ein Kurs zur Entwicklung und Implementierung sicherer Computersysteme.  Die Vorträge behandeln Bedrohungsmodelle, Angriffe, die die Sicherheit gefährden, und Sicherheitstechniken, die auf jüngsten wissenschaftlichen Arbeiten basieren.  Zu den Themen gehören Betriebssystemsicherheit, Funktionen, Informationsflussmanagement, Sprachsicherheit, Netzwerkprotokolle, Hardwaresicherheit und Sicherheit von Webanwendungen. <br><br>  Vorlesung 1: „Einführung: Bedrohungsmodelle“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 2: „Kontrolle von Hackerangriffen“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 3: „Pufferüberläufe: Exploits und Schutz“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <a name="habracut"></a><br><br>  Interessanterweise kann ein Angreifer nicht zu einer bestimmten Adresse springen, obwohl wir hauptsächlich fest codierte Adressen verwenden.  Was er tut, wird als "Haufenangriff" bezeichnet, und wenn Sie ein schlechter Mensch sind, wird es Ihnen ziemlich viel Spaß machen.  Bei einem solchen Angriff beginnt ein Hacker, Tonnen von Shell-Code dynamisch zuzuweisen und ihn einfach zufällig in den Speicher einzugeben.  Dies ist besonders effektiv, wenn Sie dynamisch Hochsprachen wie JavaScript verwenden.  Somit befindet sich der Tag-Reader in einer engen Schleife und generiert einfach eine große Anzahl von Zeilen Shell-Code und füllt dann eine Reihe davon. <br><br>  Der Angreifer kann die genaue Position der Zeilen nicht bestimmen, er wählt einfach 10 MB Zeilen Shell-Code aus und macht einen beliebigen Sprung.  Und wenn er irgendwie einen der <b>Ret-</b> Zeiger steuern kann, besteht die Möglichkeit, dass er im Shell-Code „landet“. <br><br><img src="https://habrastorage.org/webt/jl/7-/8x/jl7-8xckq3eq6z_wf2_m2alslzg.jpeg"><br><br>  Sie können einen Trick verwenden, der als <b>NOP-Rutsche</b> , <b>NOP-Schlitten</b> oder <b>NOP-Rampe bezeichnet wird</b> , wobei <b>NOP</b> <b>Anweisungen ohne Bedienung</b> oder leere Leerlaufbefehle sind.  Dies bedeutet, dass der Ausführungsfluss des Prozessorbefehls immer dann zu seinem endgültigen, gewünschten Ziel „rutscht“, wenn das Programm an eine beliebige Stelle auf der Folie zur Speicheradresse wechselt. <br><br>  Stellen Sie sich vor, wenn Sie eine Shell-Codezeile haben und an eine zufällige Stelle in dieser Zeile gehen, funktioniert dies möglicherweise nicht, da Sie den Angriff nicht richtig einsetzen können. <br><br>  Aber vielleicht das Zeug , dass Sie in einem Stapel gelegt, meist nur eine Tonne <b>des NOP,</b> aber in der sehr Sie einen Shell - Code am Ende haben.  Das ist eigentlich ziemlich klug, weil es bedeutet, dass Sie jetzt tatsächlich an den richtigen Ort gelangen können, an dem Sie springen.  Denn wenn Sie in eines dieser <b>NOPs springen</b> , passiert es einfach "Boom, Boom, Boom, Boom, Boom, Boom, Boom", und dann gelangen Sie in den Shell-Code. <br><br>  Es scheint, als hätten sich die Leute das ausgedacht, was Sie wahrscheinlich in unserem Team sehen.  Sie erfinden so etwas, und das ist das Problem.  Dies ist also eine andere Möglichkeit, einige zufällige Dinge zu umgehen, indem Sie einfach die Randomisierung Ihrer Codes robust machen, wenn dies sinnvoll ist. <br><br>  Daher haben wir einige Arten von Zufälligkeiten besprochen, die Sie verwenden können.  Es gibt einige dumme Ideen, die auch bei Menschen entstanden sind.  Jetzt wissen Sie also, dass Sie beim Tätigen eines Systemaufrufs, beispielsweise mit der Funktion <b>syscall libc</b> , grundsätzlich eine eindeutige Nummer übergeben, die den gewünschten Systemaufruf darstellt.  Vielleicht ist die <b>Gabelfunktion</b> 7, der <b>Schlaf</b> ist 8 oder so ähnlich. <br><br>  Dies bedeutet, dass ein Angreifer, wenn er die Adresse dieser <b>Syscall-</b> Anweisung herausfinden und irgendwie darauf <b>zugreifen</b> kann, einfach die Systemrufnummer ersetzen kann, die er direkt verwenden möchte.  Sie können sich vorstellen, dass Sie jedes Mal, wenn das Programm ausgeführt wird, eine dynamische Zuordnung von <b>Syscall-</b> Nummern <b>zu</b> gültigen <b>Syscalls erstellen</b> , um die Erfassung durch den Angreifer zu erschweren. <br><br><img src="https://habrastorage.org/webt/nq/l6/ob/nql6obzl82-6vvdgdkt6iuhzs8g.jpeg"><br><br>  Es gibt sogar einige avantgardistische Vorschläge, die Hardware so zu ändern, dass das Gerät den <b>xor-</b> Verschlüsselungsschlüssel enthält, der für <b>xor-</b> dynamische Funktionen verwendet wird.  Stellen Sie sich vor, dass jedes Mal, wenn Sie ein Programm kompilieren, alle Anweisungscodes einen bestimmten <b>xor-</b> Schlüssel erhalten.  Dieser Schlüssel wird im Geräteregister gespeichert, wenn Sie das Programm zum ersten Mal herunterladen. Danach führt das Gerät bei jeder Ausführung des Befehls automatisch eine <b>XOR-</b> Operation damit aus, bevor Sie mit diesem Befehl fortfahren.  Das Gute an diesem Ansatz ist, dass ein Angreifer diesen Schlüssel selbst dann nicht erkennt, wenn er Shell-Code generieren kann.  Daher wird es für ihn sehr schwierig sein, herauszufinden, was genau in Erinnerung bleiben muss. <br><br>  <b>Teilnehmerin:</b> Wenn er den Code erhalten kann, kann er auch <b>xor verwenden</b> , um den Code wieder in eine Anweisung <b>umzuwandeln</b> . <br><br>  <b>Professor:</b> Ja, das ist das kanonische Problem, richtig.  Dies ist etwas ähnlich wie bei <b>BROP-</b> Angriffen, wenn wir den Ort des Codes zufällig zu <b>bestimmen</b> scheinen, der Angreifer ihn jedoch "fühlen" und herausfinden kann, was passiert.  Man kann sich vorstellen, dass ein Angreifer, wenn er beispielsweise eine Teilsequenz von Code kennt, die er in einer Binärdatei zu finden erwartet, versucht, die <b>xor-</b> Operation für diese Datei zu verwenden, um den Schlüssel zu extrahieren. <br><br>  Im Wesentlichen haben wir alle Arten von Randomisierungsangriffen besprochen, von denen ich Ihnen heute erzählen wollte.  Bevor wir mit der Programmierung fortfahren, sollten wir diskutieren, welche dieser Schutzmethoden in der Praxis verwendet werden.  Es stellt sich heraus, dass sowohl <b>GCC</b> als auch Visual Studio <b>standardmäßig</b> den <b>Stack Canaries-</b> Ansatz enthalten.  Dies ist eine sehr beliebte und sehr berühmte Gemeinde.  Wenn Sie sich Linux und Windows ansehen, nutzen sie auch Dinge wie nicht ausführbaren Speicher und Adressraum-Randomisierung.  Zwar ist das <b>Baggy-Bounds-</b> System bei ihnen nicht so beliebt, wahrscheinlich aufgrund der Kosten für Speicher, Prozessor, Fehlalarme usw., über die wir bereits gesprochen haben.  Im Grunde haben wir untersucht, wie das Pufferüberlaufproblem verhindert werden kann. <br><br>  Jetzt sprechen wir über <b>ROP</b> , Reverse-Oriented Programming.  Ich habe Ihnen heute bereits gesagt, was es bedeutet, den Adressraum zufällig zu ordnen und die Ausführung von Daten zu verhindern - es wird gelesen, geschrieben und ausgeführt.  Das sind eigentlich sehr mächtige Dinge.  Weil die Randomisierung verhindert, dass ein Angreifer versteht, wo sich unsere fest codierten Adressen befinden.  Die Möglichkeit, die Ausführung von Daten zu verhindern, stellt sicher, dass ein Angreifer nicht einfach darauf springen und ihn ausführen kann, selbst wenn Sie den Shell-Code auf den Stapel legen. <br><br>  All dies sieht ziemlich fortschrittlich aus, aber Hacker entwickeln ständig Angriffsmethoden gegen solche fortschrittlichen Verteidigungslösungen. <br><br>  Was ist also die Essenz der rückwärtsgerichteten Programmierung? <br><br>  Was wäre, wenn ein Angreifer, anstatt nur während eines Angriffs neuen Code zu erstellen, die vorhandenen Codeteile kombinieren und sie dann auf abnormale Weise miteinander kombinieren könnte?  Schließlich wissen wir, dass das Programm Tonnen solchen Codes enthält. <br><br><img src="https://habrastorage.org/webt/fd/76/08/fd7608uferkfub0zyknpa6w1vfk.jpeg"><br><br>  Zum Glück oder leider hängt alles davon ab, auf welcher Seite Sie stehen.  Wenn Sie einige interessante Codeausschnitte finden und miteinander kombinieren können, erhalten Sie so etwas wie die <b>Turing-</b> Sprache, in der der Angreifer im Wesentlichen tun kann, was er will. <br><br>  Schauen wir uns ein sehr einfaches Beispiel an, das Ihnen zunächst bekannt vorkommt, sich dann aber schnell in etwas Verrücktes verwandelt. <br><br>  Nehmen wir an, wir haben das folgende Programm.  Lassen Sie uns also eine Art Funktion haben, und was für den Angreifer praktisch ist, hier ist diese nette <b>Run-Shell-</b> Funktion.  Dies ist also nur ein Aufruf an das System. Es führt den Befehl <b>bin / bash aus</b> und endet.  Als nächstes haben wir einen kanonischen Pufferüberlaufprozess oder leider eine Funktion, die die Erstellung eines Puffers ankündigt und dann eine dieser unsicheren Funktionen verwendet, um den Puffer mit Bytes zu füllen. <br><br><img src="https://habrastorage.org/webt/7r/os/et/7rosetpoais8blpdvc_-7mfkg7u.jpeg"><br><br>  Wir wissen also, dass hier ein Pufferüberlauf ohne Probleme auftritt.  Das Interessante ist jedoch, dass wir diese <b>Run-Shell-</b> Funktion haben, aber es ist schwierig, sie auf eine Weise zu erreichen, die auf Pufferüberläufen basiert.  Wie könnte ein Angreifer kann den Befehl <b>ausführen Shell auslösen?</b> <br><br>  Zunächst kann der Angreifer das Programm zerlegen, <b>GDB</b> starten und die Adresse dieses Dings in der ausführbaren Datei herausfinden.  Sie kennen diese Methoden wahrscheinlich aus der Laborarbeit.  Während eines Pufferüberlaufs kann ein Angreifer diese Adresse übernehmen, in den generierten Pufferüberlauf einfügen und überprüfen, ob die Funktion zur <b>Ausführungsshell zurückkehrt</b> . <br><br>  Um es klar zu machen, werde ich es zeichnen.  Sie haben also einen Stapel, der so aussieht: Unten befindet sich ein übergelaufener Puffer, darüber ein Indikator für gespeicherte Lücken und darüber die Rücksprungadresse für <b>prosess_msg</b> .  Unten links haben wir einen neuen Stapelzeiger, der die Funktion initiiert, darüber einen neuen Unterbrechungszeiger, dann den Stapelzeiger, der verwendet wird, und noch höher ist der Unterbrechungszeiger des vorherigen Frames.  Es kommt mir alles ziemlich bekannt vor. <br><br><img src="https://habrastorage.org/webt/qf/ee/vg/qfeevg9_wr3ctwybpgx8acjcpeq.jpeg"><br><br>  Wie gesagt, während des Angriffs wurde <b>GDB</b> verwendet, um herauszufinden, wie die Adresse der <b>Run-Shell lautet</b> .  Wenn der Puffer überläuft, können wir einfach die Adresse der <b>Run-Shell</b> hier rechts einfügen.  Dies ist eigentlich eine ziemlich einfache Erweiterung dessen, was wir bereits wissen, wie man es macht.  Im Wesentlichen bedeutet dies, dass wir, wenn wir einen Befehl haben, der die Shell startet, und wenn wir die Binärdatei zerlegen können, um herauszufinden, wo sich diese Adresse befindet, sie einfach in dieses Überlaufarray am unteren Rand des Stapels einfügen können.  Es ist ziemlich einfach. <br><br>  Dies war also ein äußerst leichtfertiges Beispiel, da der Programmierer aus irgendeinem verrückten Grund diese Funktion hier einsetzte und dem Angreifer damit ein echtes Geschenk machte. <br>  Nehmen wir nun an, anstatt dieses Ding <b>run_shell aufzurufen</b> , nennen wir es <b>run_boring</b> und führen dann einfach den <b>Befehl / bin / ls aus</b> .  Wir haben jedoch nichts verloren, da oben die Zeichenfolge <b>char * bash_path angezeigt wird</b> , die den Pfad zu diesem <b>bin / bash</b> <b>angibt</b> . <br><br><img src="https://habrastorage.org/webt/1d/u1/a2/1du1a2wtfwbzgtyul4bknzikpti.jpeg"><br><br>  Das Interessanteste daran ist, dass ein Angreifer, der <b>ls</b> ausführen möchte, das Programm "analysieren" und den Speicherort von <b>run_boring finden</b> kann. Dies macht überhaupt keinen Spaß.  Tatsächlich haben wir jedoch eine Zeile im Speicher, die auf den Pfad der Shell verweist. Außerdem wissen wir noch etwas Interessantes.  Dies bedeutet, dass selbst wenn das Programm das System nicht mit dem Argument <b>/ bin / ls</b> aufruft, dennoch eine Art Aufruf erfolgt. <br><br>  So wissen wir, dass das System in irgendeiner Weise mit diesem Programm verbunden sein sollte <b>- System ( „/ bin / ls</b> “).  Daher können wir diese beiden <b>void-</b> Operationen verwenden, um das System tatsächlich mit diesem <b>char * bash_path-Argument zu verknüpfen</b> .  Als erstes gehen wir in <b>GDB</b> und finden heraus, wo sich dieses <b>System ("/ bin / ls")</b> im Bild des Binärprozesses befindet.  Gehen Sie einfach zu <b>GDB</b> , geben Sie <b>print_system ein</b> und erhalten Sie Informationen zum Offset.  Dies ist ziemlich einfach und Sie können dasselbe für <b>bash_path tun</b> .  Das heißt, Sie verwenden einfach <b>GDB</b> , um herauszufinden, wo dieses Ding lebt. <br><br>  Sobald Sie fertig sind, müssen Sie etwas anderes tun.  Denn jetzt müssen wir wirklich irgendwie herausfinden, wie wir das System mit dem von uns gewählten Argument aufrufen können.  Und die Art und Weise, wie wir dies tun, besteht im Wesentlichen darin, den aufrufenden Rahmen für das System zu verfälschen.  Wenn Sie sich erinnern, verwenden sowohl der Compiler als auch die Hardware einen Frame, um den Stack-Aufruf zu implementieren. <br><br>  Wir wollen so etwas wie das, was ich in dieser Abbildung dargestellt habe, auf dem Stapel anordnen.  Tatsächlich werden wir ein System fälschen, das auf dem Stapel hätte sein sollen, aber kurz bevor es seinen Code tatsächlich ausführt. <br><br>  Hier haben wir also das Argument des Systems, dies ist die Zeile, die wir ausführen möchten.  Unten haben wir eine Zeile, in die das System zurückkehren soll, wenn die Zeile mit dem Argument abgeschlossen ist.  Das System erwartet, dass der Stapel unmittelbar vor Beginn der Ausführung so aussieht. <br><br><img src="https://habrastorage.org/webt/7r/ik/vp/7rikvpe59gsq0xdlubuhbew1juu.jpeg"><br><br>  Früher haben wir angenommen, dass es beim Übergeben der Funktion keine Argumente gibt, aber jetzt sieht es etwas anders aus.  Wir müssen nur sicherstellen, dass das <b>Argument</b> in dem von uns erstellten Überlaufcode enthalten ist.  Wir müssen nur sicherstellen, dass sich dieser gefälschte <b>Aufrufrahmen</b> in diesem Array befindet.  Daher wird unsere Arbeit wie folgt sein.  Denken Sie daran, dass der Stapelüberlauf von unten nach oben verläuft. <br><br><img src="https://habrastorage.org/webt/kh/by/g7/khbyg7us4ir4ydv6ossc2-bbnd0.jpeg"><br><br>  Zuerst geben wir hier die Systemadresse ein.  Und obendrein werden wir eine <b>Junk-Absenderadresse platzieren</b> .  Dies ist der Ort, an dem das System nach Beendigung zurückkehrt.  Diese Adresse ist eine zufällige Menge von Bytes.  Darüber setzen wir die Adresse <b>bash_path</b> .  Was passiert, wenn der Puffer jetzt überläuft? <br><br>  Nachdem <b>prosess_msg</b> die Ziellinie erreicht hat, wird er sagen: "OK, dies ist der Ort, an den ich zurückkehren sollte"!  Der Systemcode wird weiterhin ausgeführt, er wird höher und sieht den von uns erstellten gefälschten Anrufrahmen.  Für das System wird nichts Erstaunliches passieren, es heißt: "Ja, hier ist das Argument, das ich ausführen möchte, ist <b>bin / bash</b> ", es führt es aus und es ist bereit - der Angreifer hat die Shell erobert! <br><br>  Was haben wir jetzt gemacht?  Ich nutzte das Wissen über die <b>Aufrufkonvention</b> , <b>die Aufrufkonvention</b> , als Plattform zum Erstellen von gefälschten Stapelrahmen oder gefälschten Rahmennamen, würde ich sagen.  Mit diesen gefälschten <b>Aufrufrahmen</b> können wir jede Funktion ausführen, auf die verwiesen wird und die bereits von der Anwendung definiert wurde. <br><br>  Die nächste Frage, die wir stellen sollten, lautet: Was ist, wenn das Programm diese Zeile <b>char * bash_path</b> überhaupt nicht hat?  Ich stelle fest, dass diese Zeile fast immer im Programm vorhanden ist.  Nehmen wir jedoch an, wir leben in einer umgekehrten Welt, und sie ist immer noch nicht da.  Was könnten wir also tun, um diese Zeile in ein Programm aufzunehmen? <br><br>  Das erste , was kann zu tun getan werden kann, ist die richtige Adresse für <b>bash_path angeben,</b> es höhere Platzierung, aber in diesem Bereich unser Stapel, Einfügen gibt es drei Elemente, von denen jedes eine Größe von 4 Bytes hat: <br><br>  <b>/ 0</b> <b><br></b>  <b>/ pat</b> <b><br></b>  <b>/ bin</b> <br><br><img src="https://habrastorage.org/webt/7y/ko/bo/7ykobou1yi5jzfppu2w0ok6b0zs.jpeg"><br><br>  Aber auf jeden Fall kommt unser Zeiger hierher und - boom!  - Die Sache ist erledigt.  Auf diese Weise können Sie jetzt Argumente aufrufen, indem Sie sie einfach in Ihren Shell-Code einfügen.  Erschreckend, nicht wahr?  Und das alles ist vor einem vollständigen <b>BROP-</b> Angriff aufgebaut.  Bevor Sie jedoch auf einen vollständigen <b>BROP-</b> Angriff <b>hinweisen</b> , müssen Sie verstehen, wie Sie die bereits im Code enthaltenen <b>Elemente</b> einfach miteinander <b>verketten</b> .  Wenn ich diese abgelegte Absenderadresse hier habe, möchten wir nur auf die Shell zugreifen.  Wenn Sie jedoch ein Angreifer sind, können Sie diese Absenderadresse oder Absenderadresse an etwas weiterleiten, das wirklich verwendet werden kann.  Und wenn Sie dies getan haben, können Sie mehrere Funktionen in einer Reihe zu einer Reihe zusammenfassen, mehrere Zeichen einer Funktion in einer Reihe.  Dies ist in der Tat eine sehr mächtige Option. <br><br>  Denn wenn wir einfach die Absenderadresse für den Sprung festlegen, stürzt das Programm danach normalerweise ab, was wir vielleicht nicht wollen.  Daher lohnt es sich, einige dieser Dinge miteinander zu verknüpfen, um interessantere Dinge mit dem Programm zu tun. <br><br>  Angenommen, unser Ziel ist es, das System beliebig oft aufzurufen.  Wir wollen dies nicht nur einmal tun, wir werden es beliebig oft tun.  Wie kann das gemacht werden? <br><br>  Dazu verwenden wir zwei Informationen, die wir bereits erhalten können.  Wir wissen, wie man die Systemadresse erhält - Sie müssen nur in <b>GDB</b> schauen und sie dort finden.  Wir wissen auch, wie man die Adresse dieser Zeile, <b>bin / bash, findet</b> .  Um diesen Angriff mit mehreren Aufrufen des Systems auszulösen, müssen Gadgets verwendet werden.  Dies bringt uns näher an das, was in <b>BROP</b> passiert. <br><br>  Was wir jetzt brauchen, ist die Adresse dieser beiden <b>Codeoperationen</b> zu finden: <b>pop% eax</b> und <b>ret</b> .  Der erste entfernt die Oberseite des Stapels und legt ihn im <b>eax-</b> Register ab, und der zweite legt ihn in den <b>eip-</b> Befehlszeiger.  Dies nennen wir das Gadget.  Es sieht aus wie ein kleiner Satz von Montageanweisungen, mit denen ein Angreifer ehrgeizigere Angriffe ausführen kann. <br><br><img src="https://habrastorage.org/webt/r4/nw/c6/r4nwc61pbprp8gv2gof8kxdj0uw.jpeg"><br><br>  Diese Gadgets sind Standardwerkzeuge, mit denen Hacker beispielsweise Binärdateien finden.  Es ist auch einfach, eines dieser Gadgets zu finden, vorausgesetzt, Sie haben eine Kopie der Binärdatei, und wir haben uns nicht um die Randomisierung gekümmert.  Diese Dinge sind sehr leicht zu finden, ebenso wie die Adresse des Systems und so weiter. <br><br>  Wenn wir eines dieser Geräte haben, warum können wir es dann verwenden?  Natürlich, um Böses zu tun!  Dazu können Sie Folgendes tun. <br><br>  Angenommen, wir ändern unseren Stapel so, dass er so aussieht. Der Exploit wird nach wie vor von unten nach oben gerichtet.  Als erstes platzieren wir hier die Systemadresse und darüber die Adresse des <b>Pop / Ret-</b> Gadgets.  Noch höher setzen wir die Adresse von <b>bash_path</b> und wiederholen dann alles: Von oben platzieren wir erneut die Adresse des Systems, die Adresse des Gadgets <b>pop / ret</b> und die Adresse von <b>bash_path</b> . <br><br><img src="https://habrastorage.org/webt/f6/ti/zh/f6tizhirkpxkzrwjeavzjc6uulc.jpeg"><br><br>  Was wird hier jetzt passieren?  Es wird ein wenig kompliziert sein, daher sind die Notizen dieser Vorlesung im Internet verfügbar, und im Moment können Sie einfach hören, was hier passiert, aber als ich das zum ersten Mal verstand, war es wie zu verstehen, dass der Weihnachtsmann nicht existierte! <br><br>  Wir beginnen an der Stelle, an der sich der Eintrag befindet, und kehren zu dem System zurück, in dem die <b>ret-</b> Anweisung das Element mit dem Befehl <b>pop</b> aus dem Stapel entfernen wird. Jetzt befindet sich der obere Rand des Stapelzeigers hier.  Also entfernen wir das Element mit <b>pop</b> und geben dann die <b>ret-</b> Prozedur zurück, die die Steuerung an die vom Stapel ausgewählte Rücksprungadresse überträgt, und diese Rücksprungadresse wird dort mit dem <b>Aufrufbefehl platziert</b> .  Wir rufen also erneut das System an und dieser Vorgang kann immer wieder wiederholt werden. <br><br><img src="https://habrastorage.org/webt/js/mz/oz/jsmzoz4p8_mrqlskie75rmdgcnu.jpeg"><br><br>  Es ist klar, dass wir diese Sequenz in Beziehung setzen können, um eine beliebige Anzahl von Dingen auszuführen.  Im Wesentlichen erhält der Kernel eine sogenannte umgekehrte Programmierung.  Bitte beachten Sie, dass wir auf diesem Stapel nichts ausgeführt haben.  Wir haben alles getan, um die Ausführung von Daten zu verhindern, ohne etwas zu zerstören.  Wir haben nur einen unerwarteten Sprung gemacht, um das zu tun, was wir wollen.  Eigentlich ist es sehr, sehr, sehr klug. <br><br>  Interessant ist, dass wir dieses neue Modell für die Datenverarbeitung auf hohem Niveau identifiziert haben.  ,   ,     ,       .     ,  ,    .  , -       .     ,       ,   .          ,       .         .  ,        .  ,    ,     <b>stack canaries.</b> <br><br>   ,  «»  ,      .  ,  ,  «»    <b>ret address</b>   <b>saved %ebp</b> ,    -   ,   «».  ,        <b>ret</b> ,   ,       «»,  ,    - .    <b>stack canaries</b> . <br><br>  ,    «».         ,   . ,     «»? <br><br> ,    ,  ,      . <br> ,   ,  ,   «»  ,    «»  «». <br><br>  ,    ,  ,    «»     ,   ,    . <br>   ,    -  ,     «»         ,         .    ,   ?           ? <br>   ,       <b>fork</b>    .   , <b>fork</b>     .    ,   ,    ,      <b>fork</b> ,      ,  ,       ,       «»   .     ,       <b>stack canaries</b> . <br><br>       «»?      .  ,    ,     ,   «».  «»    .                . <br><br><img src="https://habrastorage.org/webt/ql/h1/ol/qlh1olpcbsug9nbtozpjevlll7u.jpeg"><br><br> ,    ,     –    ,      «».         , ,      0.    ,  «»,      .    ,  : <br><br> «,      «»!     ,      0.  «»!  1 –  «»,  2 –   . ,    2- .  ,     ,  «». <br><br><img src="https://habrastorage.org/webt/tx/xp/rc/txxprcve2i3lgkwslbdrluiv-sk.jpeg"><br><br>    ,   ,      ,     . <br><br>      «»,   ,    ,     .     ,          ,      «». <br><br> 57:10  <br><br> : <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MIT-Kurs "Computer Systems Security".</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> 3: « :   »,  3</a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/xSQxaie_h1o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . <br><br>  Vielen Dank für Ihren Aufenthalt bei uns.  Gefällt dir unser Artikel?  Möchten Sie weitere interessante Materialien sehen?  Unterstützen Sie uns, indem Sie eine Bestellung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aufgeben</a> oder sie Ihren Freunden empfehlen. <b>Habr-Benutzer erhalten 30% Rabatt auf ein einzigartiges Analogon von Einstiegsservern, das wir für Sie erfunden haben:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die ganze Wahrheit über VPS (KVM) E5-2650 v4 (6 Kerne) 10 GB DDR4 240 GB SSD 1 Gbit / s $ 20 oder wie teilt man den Server?</a>  (Optionen sind mit RAID1 und RAID10, bis zu 24 Kernen und bis zu 40 GB DDR4 verfügbar). <br><br>  <b>Dell R730xd 2 mal günstiger?</b>  Nur wir haben <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2 x Intel Dodeca-Core Xeon E5-2650v4 128 GB DDR4 6 x 480 GB SSD 1 Gbit / s 100 TV von 249 US-Dollar</a> in den Niederlanden und den USA!</b>  Lesen Sie mehr über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Aufbau eines Infrastrukturgebäudes.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Klasse mit Dell R730xd E5-2650 v4 Servern für 9.000 Euro für einen Cent?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418093/">https://habr.com/ru/post/de418093/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418083/index.html">Einfacher Server mit GraphQL anstelle von REST, Implementierung in Java</a></li>
<li><a href="../de418085/index.html">Versprechen in JavaScript verwenden</a></li>
<li><a href="../de418087/index.html">80% der Selbstbedienungskassen sind gefährdet</a></li>
<li><a href="../de418089/index.html">SolidCraft CNC-Fräsmaschine Übersicht</a></li>
<li><a href="../de418091/index.html">Liste der Artikel und Literatur zu NAS</a></li>
<li><a href="../de418095/index.html">Über das Gerät der eingebauten Testfunktionalität in Rust (Übersetzung)</a></li>
<li><a href="../de418099/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 3: Pufferüberläufe: Exploits und Schutz, Teil 3</a></li>
<li><a href="../de418101/index.html">Etymologie der IT-Begriffe</a></li>
<li><a href="../de418103/index.html">Der Chef von Roscosmos erinnerte sich an seine erste Rakete und teilte Pläne für die Zukunft</a></li>
<li><a href="../de418105/index.html">Warum das Öffnen von YouTube in Firefox oder Edge fünfmal länger dauern kann als in Google Chrome</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>