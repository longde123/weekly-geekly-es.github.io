<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤µğŸ» ğŸ™ğŸ» ğŸ›‹ï¸ MIT-Kurs "Computer Systems Security". Vorlesung 3: PufferÃ¼berlÃ¤ufe: Exploits und Schutz, Teil 2 ğŸ”– ğŸ¤šğŸ½ ğŸŠ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Massachusetts Institute of Technology. Vorlesung # 6.858. "Sicherheit von Computersystemen." Nikolai Zeldovich, James Mickens. 2014 Jahr 
 Computer Sy...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MIT-Kurs "Computer Systems Security". Vorlesung 3: PufferÃ¼berlÃ¤ufe: Exploits und Schutz, Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/418093/"><h3>  Massachusetts Institute of Technology.  Vorlesung # 6.858.  "Sicherheit von Computersystemen."  Nikolai Zeldovich, James Mickens.  2014 Jahr </h3><br>  Computer Systems Security ist ein Kurs zur Entwicklung und Implementierung sicherer Computersysteme.  Die VortrÃ¤ge behandeln Bedrohungsmodelle, Angriffe, die die Sicherheit gefÃ¤hrden, und Sicherheitstechniken, die auf jÃ¼ngsten wissenschaftlichen Arbeiten basieren.  Zu den Themen gehÃ¶ren Betriebssystemsicherheit, Funktionen, Informationsflussmanagement, Sprachsicherheit, Netzwerkprotokolle, Hardwaresicherheit und Sicherheit von Webanwendungen. <br><br>  Vorlesung 1: â€EinfÃ¼hrung: Bedrohungsmodelleâ€œ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 2: â€Kontrolle von Hackerangriffenâ€œ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 3: â€PufferÃ¼berlÃ¤ufe: Exploits und Schutzâ€œ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <a name="habracut"></a><br><br>  Interessanterweise kann ein Angreifer nicht zu einer bestimmten Adresse springen, obwohl wir hauptsÃ¤chlich fest codierte Adressen verwenden.  Was er tut, wird als "Haufenangriff" bezeichnet, und wenn Sie ein schlechter Mensch sind, wird es Ihnen ziemlich viel SpaÃŸ machen.  Bei einem solchen Angriff beginnt ein Hacker, Tonnen von Shell-Code dynamisch zuzuweisen und ihn einfach zufÃ¤llig in den Speicher einzugeben.  Dies ist besonders effektiv, wenn Sie dynamisch Hochsprachen wie JavaScript verwenden.  Somit befindet sich der Tag-Reader in einer engen Schleife und generiert einfach eine groÃŸe Anzahl von Zeilen Shell-Code und fÃ¼llt dann eine Reihe davon. <br><br>  Der Angreifer kann die genaue Position der Zeilen nicht bestimmen, er wÃ¤hlt einfach 10 MB Zeilen Shell-Code aus und macht einen beliebigen Sprung.  Und wenn er irgendwie einen der <b>Ret-</b> Zeiger steuern kann, besteht die MÃ¶glichkeit, dass er im Shell-Code â€landetâ€œ. <br><br><img src="https://habrastorage.org/webt/jl/7-/8x/jl7-8xckq3eq6z_wf2_m2alslzg.jpeg"><br><br>  Sie kÃ¶nnen einen Trick verwenden, der als <b>NOP-Rutsche</b> , <b>NOP-Schlitten</b> oder <b>NOP-Rampe bezeichnet wird</b> , wobei <b>NOP</b> <b>Anweisungen ohne Bedienung</b> oder leere Leerlaufbefehle sind.  Dies bedeutet, dass der AusfÃ¼hrungsfluss des Prozessorbefehls immer dann zu seinem endgÃ¼ltigen, gewÃ¼nschten Ziel â€rutschtâ€œ, wenn das Programm an eine beliebige Stelle auf der Folie zur Speicheradresse wechselt. <br><br>  Stellen Sie sich vor, wenn Sie eine Shell-Codezeile haben und an eine zufÃ¤llige Stelle in dieser Zeile gehen, funktioniert dies mÃ¶glicherweise nicht, da Sie den Angriff nicht richtig einsetzen kÃ¶nnen. <br><br>  Aber vielleicht das Zeug , dass Sie in einem Stapel gelegt, meist nur eine Tonne <b>des NOP,</b> aber in der sehr Sie einen Shell - Code am Ende haben.  Das ist eigentlich ziemlich klug, weil es bedeutet, dass Sie jetzt tatsÃ¤chlich an den richtigen Ort gelangen kÃ¶nnen, an dem Sie springen.  Denn wenn Sie in eines dieser <b>NOPs springen</b> , passiert es einfach "Boom, Boom, Boom, Boom, Boom, Boom, Boom", und dann gelangen Sie in den Shell-Code. <br><br>  Es scheint, als hÃ¤tten sich die Leute das ausgedacht, was Sie wahrscheinlich in unserem Team sehen.  Sie erfinden so etwas, und das ist das Problem.  Dies ist also eine andere MÃ¶glichkeit, einige zufÃ¤llige Dinge zu umgehen, indem Sie einfach die Randomisierung Ihrer Codes robust machen, wenn dies sinnvoll ist. <br><br>  Daher haben wir einige Arten von ZufÃ¤lligkeiten besprochen, die Sie verwenden kÃ¶nnen.  Es gibt einige dumme Ideen, die auch bei Menschen entstanden sind.  Jetzt wissen Sie also, dass Sie beim TÃ¤tigen eines Systemaufrufs, beispielsweise mit der Funktion <b>syscall libc</b> , grundsÃ¤tzlich eine eindeutige Nummer Ã¼bergeben, die den gewÃ¼nschten Systemaufruf darstellt.  Vielleicht ist die <b>Gabelfunktion</b> 7, der <b>Schlaf</b> ist 8 oder so Ã¤hnlich. <br><br>  Dies bedeutet, dass ein Angreifer, wenn er die Adresse dieser <b>Syscall-</b> Anweisung herausfinden und irgendwie darauf <b>zugreifen</b> kann, einfach die Systemrufnummer ersetzen kann, die er direkt verwenden mÃ¶chte.  Sie kÃ¶nnen sich vorstellen, dass Sie jedes Mal, wenn das Programm ausgefÃ¼hrt wird, eine dynamische Zuordnung von <b>Syscall-</b> Nummern <b>zu</b> gÃ¼ltigen <b>Syscalls erstellen</b> , um die Erfassung durch den Angreifer zu erschweren. <br><br><img src="https://habrastorage.org/webt/nq/l6/ob/nql6obzl82-6vvdgdkt6iuhzs8g.jpeg"><br><br>  Es gibt sogar einige avantgardistische VorschlÃ¤ge, die Hardware so zu Ã¤ndern, dass das GerÃ¤t den <b>xor-</b> VerschlÃ¼sselungsschlÃ¼ssel enthÃ¤lt, der fÃ¼r <b>xor-</b> dynamische Funktionen verwendet wird.  Stellen Sie sich vor, dass jedes Mal, wenn Sie ein Programm kompilieren, alle Anweisungscodes einen bestimmten <b>xor-</b> SchlÃ¼ssel erhalten.  Dieser SchlÃ¼ssel wird im GerÃ¤teregister gespeichert, wenn Sie das Programm zum ersten Mal herunterladen. Danach fÃ¼hrt das GerÃ¤t bei jeder AusfÃ¼hrung des Befehls automatisch eine <b>XOR-</b> Operation damit aus, bevor Sie mit diesem Befehl fortfahren.  Das Gute an diesem Ansatz ist, dass ein Angreifer diesen SchlÃ¼ssel selbst dann nicht erkennt, wenn er Shell-Code generieren kann.  Daher wird es fÃ¼r ihn sehr schwierig sein, herauszufinden, was genau in Erinnerung bleiben muss. <br><br>  <b>Teilnehmerin:</b> Wenn er den Code erhalten kann, kann er auch <b>xor verwenden</b> , um den Code wieder in eine Anweisung <b>umzuwandeln</b> . <br><br>  <b>Professor:</b> Ja, das ist das kanonische Problem, richtig.  Dies ist etwas Ã¤hnlich wie bei <b>BROP-</b> Angriffen, wenn wir den Ort des Codes zufÃ¤llig zu <b>bestimmen</b> scheinen, der Angreifer ihn jedoch "fÃ¼hlen" und herausfinden kann, was passiert.  Man kann sich vorstellen, dass ein Angreifer, wenn er beispielsweise eine Teilsequenz von Code kennt, die er in einer BinÃ¤rdatei zu finden erwartet, versucht, die <b>xor-</b> Operation fÃ¼r diese Datei zu verwenden, um den SchlÃ¼ssel zu extrahieren. <br><br>  Im Wesentlichen haben wir alle Arten von Randomisierungsangriffen besprochen, von denen ich Ihnen heute erzÃ¤hlen wollte.  Bevor wir mit der Programmierung fortfahren, sollten wir diskutieren, welche dieser Schutzmethoden in der Praxis verwendet werden.  Es stellt sich heraus, dass sowohl <b>GCC</b> als auch Visual Studio <b>standardmÃ¤ÃŸig</b> den <b>Stack Canaries-</b> Ansatz enthalten.  Dies ist eine sehr beliebte und sehr berÃ¼hmte Gemeinde.  Wenn Sie sich Linux und Windows ansehen, nutzen sie auch Dinge wie nicht ausfÃ¼hrbaren Speicher und Adressraum-Randomisierung.  Zwar ist das <b>Baggy-Bounds-</b> System bei ihnen nicht so beliebt, wahrscheinlich aufgrund der Kosten fÃ¼r Speicher, Prozessor, Fehlalarme usw., Ã¼ber die wir bereits gesprochen haben.  Im Grunde haben wir untersucht, wie das PufferÃ¼berlaufproblem verhindert werden kann. <br><br>  Jetzt sprechen wir Ã¼ber <b>ROP</b> , Reverse-Oriented Programming.  Ich habe Ihnen heute bereits gesagt, was es bedeutet, den Adressraum zufÃ¤llig zu ordnen und die AusfÃ¼hrung von Daten zu verhindern - es wird gelesen, geschrieben und ausgefÃ¼hrt.  Das sind eigentlich sehr mÃ¤chtige Dinge.  Weil die Randomisierung verhindert, dass ein Angreifer versteht, wo sich unsere fest codierten Adressen befinden.  Die MÃ¶glichkeit, die AusfÃ¼hrung von Daten zu verhindern, stellt sicher, dass ein Angreifer nicht einfach darauf springen und ihn ausfÃ¼hren kann, selbst wenn Sie den Shell-Code auf den Stapel legen. <br><br>  All dies sieht ziemlich fortschrittlich aus, aber Hacker entwickeln stÃ¤ndig Angriffsmethoden gegen solche fortschrittlichen VerteidigungslÃ¶sungen. <br><br>  Was ist also die Essenz der rÃ¼ckwÃ¤rtsgerichteten Programmierung? <br><br>  Was wÃ¤re, wenn ein Angreifer, anstatt nur wÃ¤hrend eines Angriffs neuen Code zu erstellen, die vorhandenen Codeteile kombinieren und sie dann auf abnormale Weise miteinander kombinieren kÃ¶nnte?  SchlieÃŸlich wissen wir, dass das Programm Tonnen solchen Codes enthÃ¤lt. <br><br><img src="https://habrastorage.org/webt/fd/76/08/fd7608uferkfub0zyknpa6w1vfk.jpeg"><br><br>  Zum GlÃ¼ck oder leider hÃ¤ngt alles davon ab, auf welcher Seite Sie stehen.  Wenn Sie einige interessante Codeausschnitte finden und miteinander kombinieren kÃ¶nnen, erhalten Sie so etwas wie die <b>Turing-</b> Sprache, in der der Angreifer im Wesentlichen tun kann, was er will. <br><br>  Schauen wir uns ein sehr einfaches Beispiel an, das Ihnen zunÃ¤chst bekannt vorkommt, sich dann aber schnell in etwas VerrÃ¼cktes verwandelt. <br><br>  Nehmen wir an, wir haben das folgende Programm.  Lassen Sie uns also eine Art Funktion haben, und was fÃ¼r den Angreifer praktisch ist, hier ist diese nette <b>Run-Shell-</b> Funktion.  Dies ist also nur ein Aufruf an das System. Es fÃ¼hrt den Befehl <b>bin / bash aus</b> und endet.  Als nÃ¤chstes haben wir einen kanonischen PufferÃ¼berlaufprozess oder leider eine Funktion, die die Erstellung eines Puffers ankÃ¼ndigt und dann eine dieser unsicheren Funktionen verwendet, um den Puffer mit Bytes zu fÃ¼llen. <br><br><img src="https://habrastorage.org/webt/7r/os/et/7rosetpoais8blpdvc_-7mfkg7u.jpeg"><br><br>  Wir wissen also, dass hier ein PufferÃ¼berlauf ohne Probleme auftritt.  Das Interessante ist jedoch, dass wir diese <b>Run-Shell-</b> Funktion haben, aber es ist schwierig, sie auf eine Weise zu erreichen, die auf PufferÃ¼berlÃ¤ufen basiert.  Wie kÃ¶nnte ein Angreifer kann den Befehl <b>ausfÃ¼hren Shell auslÃ¶sen?</b> <br><br>  ZunÃ¤chst kann der Angreifer das Programm zerlegen, <b>GDB</b> starten und die Adresse dieses Dings in der ausfÃ¼hrbaren Datei herausfinden.  Sie kennen diese Methoden wahrscheinlich aus der Laborarbeit.  WÃ¤hrend eines PufferÃ¼berlaufs kann ein Angreifer diese Adresse Ã¼bernehmen, in den generierten PufferÃ¼berlauf einfÃ¼gen und Ã¼berprÃ¼fen, ob die Funktion zur <b>AusfÃ¼hrungsshell zurÃ¼ckkehrt</b> . <br><br>  Um es klar zu machen, werde ich es zeichnen.  Sie haben also einen Stapel, der so aussieht: Unten befindet sich ein Ã¼bergelaufener Puffer, darÃ¼ber ein Indikator fÃ¼r gespeicherte LÃ¼cken und darÃ¼ber die RÃ¼cksprungadresse fÃ¼r <b>prosess_msg</b> .  Unten links haben wir einen neuen Stapelzeiger, der die Funktion initiiert, darÃ¼ber einen neuen Unterbrechungszeiger, dann den Stapelzeiger, der verwendet wird, und noch hÃ¶her ist der Unterbrechungszeiger des vorherigen Frames.  Es kommt mir alles ziemlich bekannt vor. <br><br><img src="https://habrastorage.org/webt/qf/ee/vg/qfeevg9_wr3ctwybpgx8acjcpeq.jpeg"><br><br>  Wie gesagt, wÃ¤hrend des Angriffs wurde <b>GDB</b> verwendet, um herauszufinden, wie die Adresse der <b>Run-Shell lautet</b> .  Wenn der Puffer Ã¼berlÃ¤uft, kÃ¶nnen wir einfach die Adresse der <b>Run-Shell</b> hier rechts einfÃ¼gen.  Dies ist eigentlich eine ziemlich einfache Erweiterung dessen, was wir bereits wissen, wie man es macht.  Im Wesentlichen bedeutet dies, dass wir, wenn wir einen Befehl haben, der die Shell startet, und wenn wir die BinÃ¤rdatei zerlegen kÃ¶nnen, um herauszufinden, wo sich diese Adresse befindet, sie einfach in dieses Ãœberlaufarray am unteren Rand des Stapels einfÃ¼gen kÃ¶nnen.  Es ist ziemlich einfach. <br><br>  Dies war also ein Ã¤uÃŸerst leichtfertiges Beispiel, da der Programmierer aus irgendeinem verrÃ¼ckten Grund diese Funktion hier einsetzte und dem Angreifer damit ein echtes Geschenk machte. <br>  Nehmen wir nun an, anstatt dieses Ding <b>run_shell aufzurufen</b> , nennen wir es <b>run_boring</b> und fÃ¼hren dann einfach den <b>Befehl / bin / ls aus</b> .  Wir haben jedoch nichts verloren, da oben die Zeichenfolge <b>char * bash_path angezeigt wird</b> , die den Pfad zu diesem <b>bin / bash</b> <b>angibt</b> . <br><br><img src="https://habrastorage.org/webt/1d/u1/a2/1du1a2wtfwbzgtyul4bknzikpti.jpeg"><br><br>  Das Interessanteste daran ist, dass ein Angreifer, der <b>ls</b> ausfÃ¼hren mÃ¶chte, das Programm "analysieren" und den Speicherort von <b>run_boring finden</b> kann. Dies macht Ã¼berhaupt keinen SpaÃŸ.  TatsÃ¤chlich haben wir jedoch eine Zeile im Speicher, die auf den Pfad der Shell verweist. AuÃŸerdem wissen wir noch etwas Interessantes.  Dies bedeutet, dass selbst wenn das Programm das System nicht mit dem Argument <b>/ bin / ls</b> aufruft, dennoch eine Art Aufruf erfolgt. <br><br>  So wissen wir, dass das System in irgendeiner Weise mit diesem Programm verbunden sein sollte <b>- System ( â€/ bin / ls</b> â€œ).  Daher kÃ¶nnen wir diese beiden <b>void-</b> Operationen verwenden, um das System tatsÃ¤chlich mit diesem <b>char * bash_path-Argument zu verknÃ¼pfen</b> .  Als erstes gehen wir in <b>GDB</b> und finden heraus, wo sich dieses <b>System ("/ bin / ls")</b> im Bild des BinÃ¤rprozesses befindet.  Gehen Sie einfach zu <b>GDB</b> , geben Sie <b>print_system ein</b> und erhalten Sie Informationen zum Offset.  Dies ist ziemlich einfach und Sie kÃ¶nnen dasselbe fÃ¼r <b>bash_path tun</b> .  Das heiÃŸt, Sie verwenden einfach <b>GDB</b> , um herauszufinden, wo dieses Ding lebt. <br><br>  Sobald Sie fertig sind, mÃ¼ssen Sie etwas anderes tun.  Denn jetzt mÃ¼ssen wir wirklich irgendwie herausfinden, wie wir das System mit dem von uns gewÃ¤hlten Argument aufrufen kÃ¶nnen.  Und die Art und Weise, wie wir dies tun, besteht im Wesentlichen darin, den aufrufenden Rahmen fÃ¼r das System zu verfÃ¤lschen.  Wenn Sie sich erinnern, verwenden sowohl der Compiler als auch die Hardware einen Frame, um den Stack-Aufruf zu implementieren. <br><br>  Wir wollen so etwas wie das, was ich in dieser Abbildung dargestellt habe, auf dem Stapel anordnen.  TatsÃ¤chlich werden wir ein System fÃ¤lschen, das auf dem Stapel hÃ¤tte sein sollen, aber kurz bevor es seinen Code tatsÃ¤chlich ausfÃ¼hrt. <br><br>  Hier haben wir also das Argument des Systems, dies ist die Zeile, die wir ausfÃ¼hren mÃ¶chten.  Unten haben wir eine Zeile, in die das System zurÃ¼ckkehren soll, wenn die Zeile mit dem Argument abgeschlossen ist.  Das System erwartet, dass der Stapel unmittelbar vor Beginn der AusfÃ¼hrung so aussieht. <br><br><img src="https://habrastorage.org/webt/7r/ik/vp/7rikvpe59gsq0xdlubuhbew1juu.jpeg"><br><br>  FrÃ¼her haben wir angenommen, dass es beim Ãœbergeben der Funktion keine Argumente gibt, aber jetzt sieht es etwas anders aus.  Wir mÃ¼ssen nur sicherstellen, dass das <b>Argument</b> in dem von uns erstellten Ãœberlaufcode enthalten ist.  Wir mÃ¼ssen nur sicherstellen, dass sich dieser gefÃ¤lschte <b>Aufrufrahmen</b> in diesem Array befindet.  Daher wird unsere Arbeit wie folgt sein.  Denken Sie daran, dass der StapelÃ¼berlauf von unten nach oben verlÃ¤uft. <br><br><img src="https://habrastorage.org/webt/kh/by/g7/khbyg7us4ir4ydv6ossc2-bbnd0.jpeg"><br><br>  Zuerst geben wir hier die Systemadresse ein.  Und obendrein werden wir eine <b>Junk-Absenderadresse platzieren</b> .  Dies ist der Ort, an dem das System nach Beendigung zurÃ¼ckkehrt.  Diese Adresse ist eine zufÃ¤llige Menge von Bytes.  DarÃ¼ber setzen wir die Adresse <b>bash_path</b> .  Was passiert, wenn der Puffer jetzt Ã¼berlÃ¤uft? <br><br>  Nachdem <b>prosess_msg</b> die Ziellinie erreicht hat, wird er sagen: "OK, dies ist der Ort, an den ich zurÃ¼ckkehren sollte"!  Der Systemcode wird weiterhin ausgefÃ¼hrt, er wird hÃ¶her und sieht den von uns erstellten gefÃ¤lschten Anrufrahmen.  FÃ¼r das System wird nichts Erstaunliches passieren, es heiÃŸt: "Ja, hier ist das Argument, das ich ausfÃ¼hren mÃ¶chte, ist <b>bin / bash</b> ", es fÃ¼hrt es aus und es ist bereit - der Angreifer hat die Shell erobert! <br><br>  Was haben wir jetzt gemacht?  Ich nutzte das Wissen Ã¼ber die <b>Aufrufkonvention</b> , <b>die Aufrufkonvention</b> , als Plattform zum Erstellen von gefÃ¤lschten Stapelrahmen oder gefÃ¤lschten Rahmennamen, wÃ¼rde ich sagen.  Mit diesen gefÃ¤lschten <b>Aufrufrahmen</b> kÃ¶nnen wir jede Funktion ausfÃ¼hren, auf die verwiesen wird und die bereits von der Anwendung definiert wurde. <br><br>  Die nÃ¤chste Frage, die wir stellen sollten, lautet: Was ist, wenn das Programm diese Zeile <b>char * bash_path</b> Ã¼berhaupt nicht hat?  Ich stelle fest, dass diese Zeile fast immer im Programm vorhanden ist.  Nehmen wir jedoch an, wir leben in einer umgekehrten Welt, und sie ist immer noch nicht da.  Was kÃ¶nnten wir also tun, um diese Zeile in ein Programm aufzunehmen? <br><br>  Das erste , was kann zu tun getan werden kann, ist die richtige Adresse fÃ¼r <b>bash_path angeben,</b> es hÃ¶here Platzierung, aber in diesem Bereich unser Stapel, EinfÃ¼gen gibt es drei Elemente, von denen jedes eine GrÃ¶ÃŸe von 4 Bytes hat: <br><br>  <b>/ 0</b> <b><br></b>  <b>/ pat</b> <b><br></b>  <b>/ bin</b> <br><br><img src="https://habrastorage.org/webt/7y/ko/bo/7ykobou1yi5jzfppu2w0ok6b0zs.jpeg"><br><br>  Aber auf jeden Fall kommt unser Zeiger hierher und - boom!  - Die Sache ist erledigt.  Auf diese Weise kÃ¶nnen Sie jetzt Argumente aufrufen, indem Sie sie einfach in Ihren Shell-Code einfÃ¼gen.  Erschreckend, nicht wahr?  Und das alles ist vor einem vollstÃ¤ndigen <b>BROP-</b> Angriff aufgebaut.  Bevor Sie jedoch auf einen vollstÃ¤ndigen <b>BROP-</b> Angriff <b>hinweisen</b> , mÃ¼ssen Sie verstehen, wie Sie die bereits im Code enthaltenen <b>Elemente</b> einfach miteinander <b>verketten</b> .  Wenn ich diese abgelegte Absenderadresse hier habe, mÃ¶chten wir nur auf die Shell zugreifen.  Wenn Sie jedoch ein Angreifer sind, kÃ¶nnen Sie diese Absenderadresse oder Absenderadresse an etwas weiterleiten, das wirklich verwendet werden kann.  Und wenn Sie dies getan haben, kÃ¶nnen Sie mehrere Funktionen in einer Reihe zu einer Reihe zusammenfassen, mehrere Zeichen einer Funktion in einer Reihe.  Dies ist in der Tat eine sehr mÃ¤chtige Option. <br><br>  Denn wenn wir einfach die Absenderadresse fÃ¼r den Sprung festlegen, stÃ¼rzt das Programm danach normalerweise ab, was wir vielleicht nicht wollen.  Daher lohnt es sich, einige dieser Dinge miteinander zu verknÃ¼pfen, um interessantere Dinge mit dem Programm zu tun. <br><br>  Angenommen, unser Ziel ist es, das System beliebig oft aufzurufen.  Wir wollen dies nicht nur einmal tun, wir werden es beliebig oft tun.  Wie kann das gemacht werden? <br><br>  Dazu verwenden wir zwei Informationen, die wir bereits erhalten kÃ¶nnen.  Wir wissen, wie man die Systemadresse erhÃ¤lt - Sie mÃ¼ssen nur in <b>GDB</b> schauen und sie dort finden.  Wir wissen auch, wie man die Adresse dieser Zeile, <b>bin / bash, findet</b> .  Um diesen Angriff mit mehreren Aufrufen des Systems auszulÃ¶sen, mÃ¼ssen Gadgets verwendet werden.  Dies bringt uns nÃ¤her an das, was in <b>BROP</b> passiert. <br><br>  Was wir jetzt brauchen, ist die Adresse dieser beiden <b>Codeoperationen</b> zu finden: <b>pop% eax</b> und <b>ret</b> .  Der erste entfernt die Oberseite des Stapels und legt ihn im <b>eax-</b> Register ab, und der zweite legt ihn in den <b>eip-</b> Befehlszeiger.  Dies nennen wir das Gadget.  Es sieht aus wie ein kleiner Satz von Montageanweisungen, mit denen ein Angreifer ehrgeizigere Angriffe ausfÃ¼hren kann. <br><br><img src="https://habrastorage.org/webt/r4/nw/c6/r4nwc61pbprp8gv2gof8kxdj0uw.jpeg"><br><br>  Diese Gadgets sind Standardwerkzeuge, mit denen Hacker beispielsweise BinÃ¤rdateien finden.  Es ist auch einfach, eines dieser Gadgets zu finden, vorausgesetzt, Sie haben eine Kopie der BinÃ¤rdatei, und wir haben uns nicht um die Randomisierung gekÃ¼mmert.  Diese Dinge sind sehr leicht zu finden, ebenso wie die Adresse des Systems und so weiter. <br><br>  Wenn wir eines dieser GerÃ¤te haben, warum kÃ¶nnen wir es dann verwenden?  NatÃ¼rlich, um BÃ¶ses zu tun!  Dazu kÃ¶nnen Sie Folgendes tun. <br><br>  Angenommen, wir Ã¤ndern unseren Stapel so, dass er so aussieht. Der Exploit wird nach wie vor von unten nach oben gerichtet.  Als erstes platzieren wir hier die Systemadresse und darÃ¼ber die Adresse des <b>Pop / Ret-</b> Gadgets.  Noch hÃ¶her setzen wir die Adresse von <b>bash_path</b> und wiederholen dann alles: Von oben platzieren wir erneut die Adresse des Systems, die Adresse des Gadgets <b>pop / ret</b> und die Adresse von <b>bash_path</b> . <br><br><img src="https://habrastorage.org/webt/f6/ti/zh/f6tizhirkpxkzrwjeavzjc6uulc.jpeg"><br><br>  Was wird hier jetzt passieren?  Es wird ein wenig kompliziert sein, daher sind die Notizen dieser Vorlesung im Internet verfÃ¼gbar, und im Moment kÃ¶nnen Sie einfach hÃ¶ren, was hier passiert, aber als ich das zum ersten Mal verstand, war es wie zu verstehen, dass der Weihnachtsmann nicht existierte! <br><br>  Wir beginnen an der Stelle, an der sich der Eintrag befindet, und kehren zu dem System zurÃ¼ck, in dem die <b>ret-</b> Anweisung das Element mit dem Befehl <b>pop</b> aus dem Stapel entfernen wird. Jetzt befindet sich der obere Rand des Stapelzeigers hier.  Also entfernen wir das Element mit <b>pop</b> und geben dann die <b>ret-</b> Prozedur zurÃ¼ck, die die Steuerung an die vom Stapel ausgewÃ¤hlte RÃ¼cksprungadresse Ã¼bertrÃ¤gt, und diese RÃ¼cksprungadresse wird dort mit dem <b>Aufrufbefehl platziert</b> .  Wir rufen also erneut das System an und dieser Vorgang kann immer wieder wiederholt werden. <br><br><img src="https://habrastorage.org/webt/js/mz/oz/jsmzoz4p8_mrqlskie75rmdgcnu.jpeg"><br><br>  Es ist klar, dass wir diese Sequenz in Beziehung setzen kÃ¶nnen, um eine beliebige Anzahl von Dingen auszufÃ¼hren.  Im Wesentlichen erhÃ¤lt der Kernel eine sogenannte umgekehrte Programmierung.  Bitte beachten Sie, dass wir auf diesem Stapel nichts ausgefÃ¼hrt haben.  Wir haben alles getan, um die AusfÃ¼hrung von Daten zu verhindern, ohne etwas zu zerstÃ¶ren.  Wir haben nur einen unerwarteten Sprung gemacht, um das zu tun, was wir wollen.  Eigentlich ist es sehr, sehr, sehr klug. <br><br>  Interessant ist, dass wir dieses neue Modell fÃ¼r die Datenverarbeitung auf hohem Niveau identifiziert haben.  ,   ,     ,       .     ,  ,    .  , -       .     ,       ,   .          ,       .         .  ,        .  ,    ,     <b>stack canaries.</b> <br><br>   ,  Â«Â»  ,      .  ,  ,  Â«Â»    <b>ret address</b>   <b>saved %ebp</b> ,    -   ,   Â«Â».  ,        <b>ret</b> ,   ,       Â«Â»,  ,    - .    <b>stack canaries</b> . <br><br>  ,    Â«Â».         ,   . ,     Â«Â»? <br><br> ,    ,  ,      . <br> ,   ,  ,   Â«Â»  ,    Â«Â»  Â«Â». <br><br>  ,    ,  ,    Â«Â»     ,   ,    . <br>   ,    -  ,     Â«Â»         ,         .    ,   ?           ? <br>   ,       <b>fork</b>    .   , <b>fork</b>     .    ,   ,    ,      <b>fork</b> ,      ,  ,       ,       Â«Â»   .     ,       <b>stack canaries</b> . <br><br>       Â«Â»?      .  ,    ,     ,   Â«Â».  Â«Â»    .                . <br><br><img src="https://habrastorage.org/webt/ql/h1/ol/qlh1olpcbsug9nbtozpjevlll7u.jpeg"><br><br> ,    ,     â€“    ,      Â«Â».         , ,      0.    ,  Â«Â»,      .    ,  : <br><br> Â«,      Â«Â»!     ,      0.  Â«Â»!  1 â€“  Â«Â»,  2 â€“   . ,    2- .  ,     ,  Â«Â». <br><br><img src="https://habrastorage.org/webt/tx/xp/rc/txxprcve2i3lgkwslbdrluiv-sk.jpeg"><br><br>    ,   ,      ,     . <br><br>      Â«Â»,   ,    ,     .     ,          ,      Â«Â». <br><br> 57:10  <br><br> : <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MIT-Kurs "Computer Systems Security".</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> 3: Â« :   Â»,  3</a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/xSQxaie_h1o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . <br><br>  Vielen Dank fÃ¼r Ihren Aufenthalt bei uns.  GefÃ¤llt dir unser Artikel?  MÃ¶chten Sie weitere interessante Materialien sehen?  UnterstÃ¼tzen Sie uns, indem Sie eine Bestellung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aufgeben</a> oder sie Ihren Freunden empfehlen. <b>Habr-Benutzer erhalten 30% Rabatt auf ein einzigartiges Analogon von Einstiegsservern, das wir fÃ¼r Sie erfunden haben:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die ganze Wahrheit Ã¼ber VPS (KVM) E5-2650 v4 (6 Kerne) 10 GB DDR4 240 GB SSD 1 Gbit / s $ 20 oder wie teilt man den Server?</a>  (Optionen sind mit RAID1 und RAID10, bis zu 24 Kernen und bis zu 40 GB DDR4 verfÃ¼gbar). <br><br>  <b>Dell R730xd 2 mal gÃ¼nstiger?</b>  Nur wir haben <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2 x Intel Dodeca-Core Xeon E5-2650v4 128 GB DDR4 6 x 480 GB SSD 1 Gbit / s 100 TV von 249 US-Dollar</a> in den Niederlanden und den USA!</b>  Lesen Sie mehr Ã¼ber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Aufbau eines InfrastrukturgebÃ¤udes.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Klasse mit Dell R730xd E5-2650 v4 Servern fÃ¼r 9.000 Euro fÃ¼r einen Cent?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418093/">https://habr.com/ru/post/de418093/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418083/index.html">Einfacher Server mit GraphQL anstelle von REST, Implementierung in Java</a></li>
<li><a href="../de418085/index.html">Versprechen in JavaScript verwenden</a></li>
<li><a href="../de418087/index.html">80% der Selbstbedienungskassen sind gefÃ¤hrdet</a></li>
<li><a href="../de418089/index.html">SolidCraft CNC-FrÃ¤smaschine Ãœbersicht</a></li>
<li><a href="../de418091/index.html">Liste der Artikel und Literatur zu NAS</a></li>
<li><a href="../de418095/index.html">Ãœber das GerÃ¤t der eingebauten TestfunktionalitÃ¤t in Rust (Ãœbersetzung)</a></li>
<li><a href="../de418099/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 3: PufferÃ¼berlÃ¤ufe: Exploits und Schutz, Teil 3</a></li>
<li><a href="../de418101/index.html">Etymologie der IT-Begriffe</a></li>
<li><a href="../de418103/index.html">Der Chef von Roscosmos erinnerte sich an seine erste Rakete und teilte PlÃ¤ne fÃ¼r die Zukunft</a></li>
<li><a href="../de418105/index.html">Warum das Ã–ffnen von YouTube in Firefox oder Edge fÃ¼nfmal lÃ¤nger dauern kann als in Google Chrome</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>