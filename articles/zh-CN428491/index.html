<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👊🏼 👩🏻‍🤝‍👨🏼 👨🏽 主动Oracle数据库性能优化 🗓️ 🧔🏻 👨🏿‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="当我们谈论主动优化时，我们遇到的第一件事是不知道需要优化什么。 “这样做，我不知道是什么。” 



- 没有经典算法。 
- 问题尚未出现（未知），人们只能猜测可能在哪里。 
- 我们需要找到系统中的一些潜在弱点。 
- 尝试在这些地方优化查询性能。 
 主动优化的主要目标 

 主动优化的主要任...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>主动Oracle数据库性能优化</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/428491/"> 当我们谈论主动优化时，我们遇到的第一件事是不知道需要优化什么。  “这样做，我不知道是什么。” <br><br><ul><li> 没有经典算法。 </li><li> 问题尚未出现（未知），人们只能猜测可能在哪里。 </li><li> 我们需要找到系统中的一些潜在弱点。 </li><li> 尝试在这些地方优化查询性能。 </li></ul><br><h3> 主动优化的主要目标 <br></h3><br> 主动优化的主要任务与被动优化的任务不同，如下： <br><br><ul><li> 消除数据库中的瓶颈； </li><li> 减少数据库资源消耗。 </li></ul><br> 最后一刻是最根本的。 在无功优化的情况下，我们没有整体减少资源消耗的任务，而只有使功能的响应时间处于可接受范围内的任务。 <br><br><img src="https://habrastorage.org/webt/zl/eg/b5/zlegb5nfhfvxy9bajfsxkv3u7ao.png"><br><br> 如果您使用作战服务器，则对性能事件的含义有一个很好的了解。 您需要退出所有内容并快速解决问题。  RNKO Payment Center LLC与许多代理商合作，对于他们来说，尽可能少地出现问题非常重要。  HighLoad ++ Siberia的Alexander Makarov讲述了为显着减少性能事件而采取的措施。 主动优化可以解救。 以及为什么以及如何在战斗服务器上生产它，请阅读下文。 <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/r_/kt/zz/r_ktzzegcm2xca_nrh4yusjtpqy.png"><br><br>  <strong>关于演讲者：</strong> RNKO Payment Center LLC，Oracle数据库的首席管理员Alexander Makarov（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">AL_IG_Makarov</a> ）。 尽管有这个职位，行政管理却很少，主要任务与综合体的维护及其开发有关，特别是与解决性能问题有关。 <br><br><h1> 战斗数据库的优化是否积极主动？ <br></h1><br> 首先，我们将处理此报告称为“主动性能优化”的术语。 有时，您可能会遇到这样的观点：主动优化是在甚至启动应用程序之前就进行问题区域分析的时候。 例如，我们发现某些查询不能最佳地工作，因为索引不足或查询使用的算法无效，因此这项工作是在测试服务器上完成的。 <br><br> 尽管如此，我们在RNCO的<strong>战斗服务器上</strong>还是做了这个项目。 我很多次听到：“如何？ 您是在战斗服务器上完成的-这意味着它不是主动的性能优化！” 在这里，我们需要回顾一下ITIL中培养的方法。 从ITIL的角度来看，我们有： <br><br><ul><li> 绩效事件已经发生； </li><li> 我们为防止性能事故发生而采取的措施。 </li></ul><br> 从这个意义上讲，我们的行动是积极主动的。 尽管我们正在战斗服务器上解决问题，但问题本身尚未出现：事件没有发生，我们没有奔跑，也没有尝试在短时间内解决此问题。 <br><br> 因此，在此报告中，主动性<strong>在ITIL的意义上</strong>被理解为<strong>主动性</strong> ，我们在性能事件发生之前就解决了问题。 <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/y68RLr825VE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1> 参考点 <br></h1><br>  RNKO“付款中心”为2个大型系统提供服务： <br><br><ul><li> 苏格兰皇家银行零售银行； </li><li>  CFT银行。 </li></ul><br> 这些系统上的负载的性质是混合的（DSS + OLTP）：有些东西可以很快运行，有报告，中等负载。 <br><br> 我们面临这样一个事实，即不经常发生，而是以一定的频率发生性能事件。 那些使用战斗服务器的人可以想象它是什么。 这意味着您需要退出所有内容并快速解决问题，因为此时客户端无法接收该服务，某些东西根本无法工作，或者工作非常缓慢。 <br><br> 由于很多代理商和客户都与我们的组织息息相关，因此这对我们非常重要。 如果我们不能快速解决性能事件，那么我们的客户将遭受一种或另一种痛苦。 例如，他们将无法补充卡或进行转帐。 因此，我们想知道如何解决这些偶发的性能事件。 当您需要放下所有东西并解决问题时以这种方式工作-这并不完全正确。 我们使用冲刺并制定冲刺工作计划。 绩效事件的出现也偏离了工作计划。 <br><br> 必须为此做些事情！ <br><br><h1> 优化方法 <br></h1><br> 我们思考并了解了主动优化技术。 但是在谈论前摄性优化之前，我必须先谈谈经典的反应式优化。 <br><br><h2> 反应性优化 <br></h2><br> 场景很简单，有一架战斗服务器发生了一些事情：他们启动了报告，客户收到了陈述，这时数据库上正在进行活动，突然有人决定更新某种庞大的目录。 系统开始减速。 此刻，客户来了，说：“我不能做到这一点或那件事”-我们需要找到他不能做到这一点的原因。 <br><br>  <strong>经典动作算法：</strong> <br><br><ol><li> 重现该问题。 </li><li> 找到问题点。 </li><li> 优化问题所在。 </li></ol><br> 在被动方法的框架内，主要任务不是寻找根本原因并加以消除，而是使系统正常工作。 根本原因的消除可以在以后解决。 最主要的是快速恢复服务器，以便客户端可以接收服务。 <br><br><h3> 反应式优化的主要目标 <br></h3><br> 在反应式优化中，可以区分两个主要目标： <br><br>  1. <strong>减少响应时间</strong> 。 <br><br> 例如，必须在某个预定时间内执行一项操作，例如接收报告，声明，交易。 必须确保接收服务的时间返回到客户端可接受的范围。 也许该服务的工作速度比平常慢一些，但是对于客户而言，这是可以接受的。 然后，我们认为性能事件已被消除，我们开始着手研究根本原因。 <br><br>  2. <strong>批处理期间每单位时间处理的对象数增加</strong> 。 <br><br> 在进行交易的批处理时，有必要减少批处理中一个对象的处理时间。 <br><br>  <strong>反应性方法的优点：</strong> <br><br>  ● <em>各种工具和技术</em>是被动方法的主要优点。 <br><br> 我们可以使用监视工具来直接了解问题所在：CPU，线程，内存不足或磁盘系统滑移，或者日志处理缓慢。 有许多工具和技术可用于研究Oracle数据库中的当前性能问题。 <br><br>  ● <em>所需的响应时间</em>是另一个优点。 <br><br> 在进行此类工作的过程中，我们将情况带到可接受的响应时间，也就是说，我们不会尝试将其降低到最小值，但是我们会达到一定的值，并且在执行此操作后便会完成，因为我们认为已经达到可接受的极限。 <br><br>  <strong>被动方法的缺点：</strong> <br><br><ul><li>  <em>性能事件仍然存在</em> -这是被动方法的最大缺点，因为我们无法始终找到根本原因。 尽管我们取得了令人满意的表现，但她仍可以呆在某个地方，躺在更深的地方。 </li></ul><br> 如果尚未发生绩效事故，该如何处理？ 让我们尝试制定如何进行主动优化以防止这种情况的发生。 <br><br><h2> 主动优化 <br></h2><br> 我们遇到的第一件事是，尚不清楚需要优化什么。  “这样做，我不知道是什么。” <br><br><ul><li> 没有经典算法。 </li><li> 问题尚未出现（未知），人们只能猜测可能在哪里。 </li><li> 我们需要找到系统中的一些潜在弱点。 </li><li> 尝试在这些地方优化查询性能。 </li></ul><br><h3> 主动优化的主要目标 <br></h3><br> 主动优化的主要任务与被动优化的任务不同，如下： <br><br><ul><li> 消除数据库中的瓶颈； </li><li> 减少数据库资源消耗。 </li></ul><br> 最后一刻是最根本的。 在无功优化的情况下，我们没有整体减少资源消耗的任务，而只有使功能的响应时间处于可接受范围内的任务。 <br><br><h3> 如何在数据库中查找瓶颈？ <br></h3><br> 当我们开始考虑这个问题时，许多子任务立即出现。 有必要进行： <br><br><ul><li>  CPU测试 </li><li> 对读取/记录进行负载测试； </li><li> 通过活动会话数进行压力测试； </li><li> 在...等上进行负载测试 </li></ul><br> 如果我们尝试在测试综合系统上模拟这些问题，则可能会遇到这样的事实，即测试服务器上出现的问题与战斗系统无关。 造成这种情况的原因很多，首先是测试服务器通常较弱。 可以将测试服务器制作为实战服务器的精确副本，这是很好的做法，但这不能保证以相同的方式重现负载，因为您需要准确地重现用户活动以及影响最终负载的更多不同因素。 如果您尝试模拟这种情况，那么总的来说，没有人可以保证战斗服务器上会发生完全相同的事情。 <br><br> 如果在一种情况下问题是由于新注册表到达而引起的，则在另一种情况下可能是由于用户启动了执行大型排序的大型报表而引起的，因此临时表空间被填满，并且结果，系统开始变慢。 即，原因可以不同，并且并非总是能够预测它们。 因此， <strong>我们</strong>几乎从一开始<strong>就放弃了在测试服务器上搜索瓶颈的尝试</strong> 。 我们仅依靠战斗服务器及其上发生的一切。 <br><br> 在这种情况下该怎么办？ 首先，让我们尝试了解最有可能缺少的资源。 <br><br><h3> 减少数据库资源消耗 <br></h3><br> 基于我们拥有的工业园区， <strong>在磁盘读取和CPU中观察到最常见的资源不足</strong> 。 因此，首先，我们将精确地寻找这些方面的弱点。 <br><br> 第二个重要问题：如何寻找东西？ <br> 这个问题很重要。 我们将Oracle Enterprise Edition与Diagnostic Pack选项一起使用，并且为自己找到了这样的工具<b>-AWR报告</b> （在其他Oracle版本中，您可以使用<b>STATSPACK报告</b> ）。 在PostgreSQL中有一个类似的pgstatspack，有Andrey Zubkov的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pg_profile</a> 。 据我了解，最后一种产品只是在去年才出现并开始开发。 对于MySQL，我找不到类似的工具，但我不是MySQL专家。 <br><br> 该方法本身不依赖于任何特定种类的数据库。 如果可以从某些报告中获取有关系统负载的信息，那么使用我现在将要讨论的技术，您可以<strong>在任何基础</strong>上进行主动优化工作。 <br><br><h3>  <strong>优化前五项业务</strong> <br></h3><br> 我们在RNCO付款中心开发并使用的主动优化技术包括四个阶段。 <br><br>  <strong>第1阶段。我们在尽可能长的时间内收到AWR报告。</strong> <br><br> 需要最大可能的时间长度来平均一周中不同日期的负载，有时有时会非常不同。 例如，过去一周的注册中心于星期二到达苏格兰皇家银行零售银行，开始进行处理，整天的工作量比平均水平高出大约2-3倍。 在其他日子，负载较小。 <br><br> 如果已知系统具有某些特定信息-某些天负载更大，某些天-更少，那么您需要分别接收这些时间段的报告，并分别使用它们以优化特定的时间间隔。 如果您需要优化服务器的整体状况，则可以获得当月的大报告，并查看服务器实际消耗的资源。 <br><br> 有时会遇到非常意外的情况。 例如，对于CFT银行，检查报告服务器队列的请求可能位于前10位。 此外，此请求是正式的，不执行任何业务逻辑，而仅检查是否存在执行报告。 <br><br>  <strong>阶段2。我们查看以下部分：</strong> <br><br><ul><li> 按经过时间排序的SQL-按运行时排序的SQL查询； </li><li>  SQL按CPU时间排序-用于CPU使用情况； </li><li> 由Gets排序的SQL-通过逻辑读取； </li><li>  SQL按读取顺序排序-用于物理读取。 </li></ul><br> 根据需要研究SQL的其余部分。 <br><br>  <strong>第3阶段。我们确定父操作和依赖于父操作的请求。</strong> <br><br>  AWR报告有单独的部分，其中根据Oracle版本的不同，在每个部分中显示15个或更多的顶级查询。 但是Oracle在AWR报告中的这些查询显示出一团糟。 <br> 例如，有一个父操作，其中有3个顶级查询。  Oracle在AWR报告中将显示父操作和所有这三个查询。 因此，您需要对此列表进行分析，并查看特定请求所指的是什么，并将其分组。 <br><br>  <strong>第4阶段。我们优化了前5个操作。</strong> <br><br> 进行此类分组后，输出是一个操作列表，您可以从中选择最困难的操作。 我们仅限于5个操作（不是请求，即操作）。 如果系统更复杂，那么您可以承担更多。 <br><br><h3> 常见查询设计错误 <br></h3><br> 在应用这项技术的过程中，我们整理了一些典型的设计错误清单。 有些错误是如此简单，以至似乎不可能。 <br><br>  ● <strong>索引不足→全面扫描</strong> <br> 例如，在非常偶然的情况下，没有关于战斗计划的索引。 我们有一个具体的示例，其中长时间没有索引就可以快速进行查询。 但是进行了全面扫描，并且随着表的大小逐渐增加，查询开始工作的速度变慢了，从一个季度到另一个季度，查询花费了更长的时间。 最后，我们注意了他，结果发现索引不存在。 <br><br>  ● <strong>大选择→全面扫描</strong> <br> 第二个常见错误是大数据样本-全扫描的经典案例。 所有人都知道，只有在真正合理的情况下才应使用全面扫描。 有时，在某些情况下，如果发现完全扫描，则可以不进行完全扫描，例如，将过滤条件从pl / sql代码转移到查询中。 <br><br>  ● <strong>无效索引→长INDEX RANGE SCAN</strong> <br> 也许这甚至是最常见的错误，出于某种原因他们很少说-所谓的无效索引（长索引扫描，长INDEX RANGE SCAN）。 例如，我们有一个注册表表。 在请求中，我们尝试查找该代理的所有注册表，并最终添加某种过滤条件，例如，在一定时期内，使用特定数量或使用特定客户。 在这种情况下，出于普遍使用的原因，索引通常仅建立在“ agent”字段上。 结果如下图所示：例如，在工作的第一年中，座席在此表中有100个条目，第二年已经有1000个条目，第二年可能有10,000个条目。 一段时间后，这些记录变为100,000。显然，该请求开始缓慢运行，因为在该请求中，您不仅需要添加代理标识符本身，而且还需要添加一些其他过滤器（在这种情况下，按日期）。 否则，事实证明，随着该代理的注册处数量的增加，样本量会逐年增加。 必须在索引级别解决此问题。 如果数据太多，那么我们应该已经考虑了分区的方向。 <br><br>  ● <strong>不必要的分发代码分支</strong> <br> 这也是一个奇怪的情况，但是尽管如此，它还是发生了。 我们查看最上面的查询，然后在那里看到一些奇怪的查询。 我们来到开发人员那里说：“我们找到了一些要求，让我们找出来，看看可以做什么。” 开发人员认为，然后过了一会儿说：“此代码分支不应在您的系统上。 您不使用此功能。” 然后，开发人员建议您打开一些特殊设置，以解决代码的这一部分。 <br><br><h3> 个案研究 <br></h3><br> 现在，我想考虑一下我们实际实践中的两个例子。 当我们处理最重要的查询时，我们当然首先要考虑这样一个事实，即应该有一些繁琐，繁琐的复杂操作。 实际上，并非总是如此。 有时在某些情况下，非常简单的查询属于最重要的操作。 <br><br><h4> 例子1 <br></h4><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> o.* <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> rnko_dep_reestr_in_oper o <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> o.type_oper = <span class="hljs-string"><span class="hljs-string">'proc'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> o.ean_rnko <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> l.ean_rnko <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> rnko_dep_link l <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> l.s_rnko = :<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> o.date_oper_bnk <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>, o.date_reg <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ROWNUM</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br> 在此示例中，查询仅包含两个表，而这些表不是很重的表-只有几百万个记录。 看起来会更容易吗？ 但是，请求达到了顶峰。 <br><br> 让我们尝试找出他的问题所在。 <br><br> 下面是来自企业管理器云控制的图片-有关此请求的统计数据（Oracle有这样的工具）。 可以看出，此请求有固定的负载（上图）。 侧面的数字1表示平均不超过一个会话正在运行。 绿色图显示该<strong>请求仅使用CPU</strong> ，这很有趣。 <br><br><img src="https://habrastorage.org/webt/cd/jl/tm/cdjltmcxv_hgjn7ykitlcdjwdes.jpeg"><br><br> 让我们尝试找出这里发生了什么？ <br><br><img src="https://habrastorage.org/webt/gk/h9/8r/gkh98r5cr3dprhk49xl0d3-y1nm.jpeg"><br><br> 上表是根据要求提供统计信息的表格。 近70万次发射-这不会让任何人感到惊讶。 但是，从12月15日的“首次加载时间”到12月22日的“最后一次加载时间”（参见上图）的时间间隔为一周。 如果计算每秒的启动次数，那么<strong>查询平均每秒执行一次</strong> 。 <br><br> 我们进一步看。 查询执行时间为0.93秒，即 不到一秒钟，那太好了。 我们可以高兴-请求并不繁重。 尽管如此，他还是名列前茅，这意味着他消耗了大量资源。 它在哪里消耗大量资源？ <br><br> 该表有一行用于逻辑读数。 我们看到，一次启动需要近8000个块（通常1个块为8 KB）。 事实证明，每秒处理一次的请求从内存加载大约64 MB的数据。 这里有些问题，我们需要了解。 <br><br> 让我们看一下计划：进行全面扫描。 好吧，让我们继续前进。 <br><br><pre> <code class="sql hljs"> Plan hash value: 634977963 <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------- | Id | Operation | Name | ------------------------------------------------------------------- | 0 | SELECT STATEMENT | | |* 1 | COUNT STOPKEY | | | 2 | VIEW | | |* 3 | SORT ORDER BY STOPKEY | | | 4 | NESTED LOOPS | | | 5 | TABLE ACCESS BY INDEX ROWID| RNKO_DEP_LINK | |* 6 | INDEX UNIQUE SCAN | UK_RNKODEPLINK$S_RNKO | |* 7 | TABLE ACCESS FULL | RNKO_DEP_REESTR_IN_OPER | ------------------------------------------------------------------- Predicate Information (identified by operation id): 1 - filter(ROWNUM=1) 3 - filter(ROWNUM=1) 6 - access("L"."S_RNKO"=:1) 7 - filter(("O"."TYPE_OPER"='proc' AND "O"."EAN_RNKO"="L"."EAN_RNKO"))</span></span></code> </pre><br> 在rnko_dep_reestr_in_oper表中，只有500万行，其平均行长为150个字节。 但是事实证明，连接的字段没有足够的索引-子查询通过ean_rnko字段连接到请求，而该字段没有索引！ <br><br> 而且，即使他出现，实际上情况也不会很好。 该长索引扫描（长INDEX RANGE SCAN）将发生。  ean_rnko是代理的内部标识符。 代理注册表会累积，并且每年该请求选择的数据量将增加，而请求的速度将减慢。 <br><br>  <strong>解决方案：</strong>为ean_rnko和date_reg字段创建索引，要求开发人员在此请求中按日期限制扫描深度。 然后，您可以至少在某种程度上保证查询性能将保持在大致相同的边界上，因为样本大小将被限制为固定的时间间隔，并且不需要读取整个表。 这是很重要的一点，看看发生了什么。 <br><img src="https://habrastorage.org/webt/zl/eg/b5/zlegb5nfhfvxy9bajfsxkv3u7ao.png"><br><br> 经过优化后，运行时间变得小于百分之一秒（0.93），平均块数比以前减少了8.5-1000倍。 <br><br><h4> 例子2 <br></h4><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> loy$barcodes t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> t.id_processing = :b1 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> t.id_rec_out <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> t.barcode <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> t.status = <span class="hljs-string"><span class="hljs-string">'u'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> t.id_card <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span></code> </pre><br> 我从说起故事开始，通常是在查询顶部出现一些复杂的情况。 上面是一个对一个表（！）进行“复杂”查询的示例，它也进入了顶部查询：) ID_PROCESSING字段上有一个索引！ <br> 此查询中有3个IS NULL条件，并且众所周知，此类条件未编制索引（在这种情况下，您不能使用索引）。 另外，只有两个相等类型的条件（通过ID_PROCESSING和STATUS）。 <br><br> 可能，查看此查询的开发人员首先会建议在ID_PROCESSING和STATUS上建立索引。 但是，鉴于将要选择的数据量（会有很多），该解决方案将不起作用。 <br><br> 但是，该请求消耗大量资源，这意味着需要做一些事情才能使其更快地工作。 让我们尝试找出原因。 <br><img src="https://habrastorage.org/webt/wt/s4/cx/wts4cxw4pwappessb8lypge_uzg.png"><br><br> 上面的统计数据是1天，从中可以看出请求每5分钟启动一次。 主要资源消耗是CPU和磁盘读取。 在具有查询启动次数统计信息的图表下方，可以看到一切都井井有条-启动次数几乎不会随时间变化-情况相当稳定。 <br><img src="https://habrastorage.org/webt/5x/09/ge/5x09gen-19peucgd4eu430ichrq.png"><br><br> 如果进一步看，您会发现查询时间有时会相差很大-多次，这已经很重要了。 <br><img src="https://habrastorage.org/webt/ue/tj/mx/uetjmxbf2hbrv6kvzojoshoisyy.png"><br><br> 接下来让我们弄清楚。 <br><br>  Oracle Enterprise Manager具有SQL监视实用程序。 使用此实用程序，您可以根据请求实时查看资源消耗情况。 <br><img src="https://habrastorage.org/webt/ap/j6/k-/apj6k--jewoeighhu8_7edfkiu8.png"><br><br> 以上报告有问题。 首先，我们应该对“实际行数”列中的“索引范围扫描”（底部线）显示1700万行这一事实感兴趣。 大概值得考虑。 <br><br> 如果我们进一步看一下实施计划，结果发现，在计划的下一个项目之后，在这1,700万行中，仅剩下1705条，问题是，为什么选择1,700万？ 最终样品中剩余约0.01％，即<strong>显然效率低下，做了不必要的工作</strong> 。 此外，这项工作每5分钟完成一次。 这是问题所在！ 因此，此请求命中了最前面的查询。 <br><br> 让我们尝试解决这个非同寻常的问题。 首先乞求自己的索引效率很低，因此您需要提出一些棘手的问题并克服IS NULL条件。 <br><br><h4> 新指数 <br></h4><br> 我们与开发人员进行了协商，认为并做出了以下决定：我们创建了一个功能索引，其中包含一个ID_PROCESSING列，该列在请求中具有相等条件，并且我们将所有其他字段作为该函数的参数包括在内： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> gc.loy$barcod_unload_i <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> gc.loy$barcodes (gc.loy_barcodes_ic_unload(id_rec_out, barcode, id_card, <span class="hljs-keyword"><span class="hljs-keyword">status</span></span>), id_processing);  function loy_barcodes_ic_unload( pIdRecOut in loy$barcodes.id_rec_out%type, pBarcode in loy$barcodes.barcode%type, pIdCard in loy$barcodes.id_card%type, pStatus in loy$barcodes.status%type) return varchar2 deterministic is vRes varchar2(1) := ''; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pIdRecOut <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pBarcode <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pIdCard <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pStatus = <span class="hljs-string"><span class="hljs-string">'U'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> vRes := pStatus; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; return vRes; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> loy_barcodes_ic_unload;</code> </pre><br> 此函数的类型是确定性的，也就是说，对于同一组参数，它始终给出相同的答案。 我们确保该函数始终返回一个值-在这种情况下为“ U”。 当所有这些条件都满足时，将发出“ U”，如果不满足，则发出NULL。 这样的功能索引使得可以有效地过滤数据。 <br><br> 应用该索引得出以下结果： <br><br><img src="https://habrastorage.org/webt/xh/wj/nb/xhwjnbiaw-hvj7uumjpwr9uu-mi.png"><br><br> 在这里，一栏是一个快照，它们每半小时在数据库中完成一次。 我们已经实现了我们的目标，该指数确实非常有效。 让我们看看定量特征： <br><br><table width="408"><tbody><tr><td width="408" colspan="3"> 平均请求统计 <br><br></td></tr><tr><td width="174"></td><td width="124">  <strong>之前</strong> <br><br></td><td width="110">  <strong>之后</strong> <br><br></td></tr><tr><td width="174"> 经过时间，秒 <br><br></td><td width="124">  143.21 <br><br></td><td width="110">  60.7 <br><br></td></tr><tr><td width="174">  CPU时间，秒 <br><br></td><td width="124">  33.23 <br><br></td><td width="110">  45.38 <br><br></td></tr><tr><td width="174"> 缓冲区获取块 <br><br></td><td width="124">  6`288`237.67 <br><br></td><td width="110">  1`589`836 <br><br></td></tr><tr><td width="174"> 磁盘读取块 <br><br></td><td width="124">  266`600.33 <br><br></td><td width="110">  2`680 <br><br></td></tr></tbody></table><br> 运行时间减少了2.5倍，资源消耗（缓冲区获取）减少了大约4。从磁盘读取的数据块数量大大减少。 <br><br><h3> 主动优化结果 <br></h3><br> 我们已经收到： <br><br><ul><li> 减轻数据库的负担； </li><li> 提高数据库的稳定性； </li><li> 大大减少了软件性能事件的数量。 </li></ul><br>  <strong>表演事件减少了10倍</strong> 。 这是一个主观的金额，在苏格兰皇家银行-零售银行综合大楼每月发生1-2次事件之前，但现在我们几乎已经将其遗忘了。 <br><br> 这就提出了一个问题-软件性能事件如何处理？ 我们没有直接与他们打交道吗？ <br><br> 返回上一个时间表。 如果您还记得，曾经进行过全面扫描，则需要在内存中存储大量块。 由于请求是定期执行的，因此所有这些块都存储在Oracle缓存中。 事实证明，如果这时数据库中出现高负载，例如有人开始主动使用内存，则将需要缓存来存储数据块。 因此，用于我们请求的部分数据将被挤出，这意味着我们将不得不进行物理读取。 如果您进行物理读取，查询运行时间将立即大大增加。 <br><br> 逻辑读取正在使用内存，它会很快发生，并且对磁盘的任何访问速度都很慢（如果您查看时间，以毫秒为单位）。 如果您很幸运，并且操作系统的高速缓存或阵列高速缓存中有此数据，那么它仍将是数十微秒。 从Oracle的缓存中读取数据要快得多。 <br><br> 当我们摆脱了全盘扫描时，在缓存（Buffer Cache）中存储如此大量块的需求就消失了。 当这些资源不足时，请求或多或少是稳定的。 旧索引不再有如此大的峰值。 <br><br>  <strong>主动优化摘要：</strong> <br><br><ul><li> 初始查询优化应在测试服务器上进行，以查看查询及其业务逻辑的工作方式，以免做多余的事情。 这些作品仍然存在。 </li><li> 但是定期（每隔几个月一次）从服务器中删除满负荷报告，搜索数据库中的热门查询和操作并对其进行优化是有意义的。 </li></ul><br>  <strong>有许多工具可用于获取Oracle数据库中的统计信息：</strong> <br><br><ul><li>  AWR报告（DBMS_WORKLOAD_REPOSITORY.awr_report_html）； </li><li> 企业管理器云控制12c（SQL详细信息）； </li><li>  SQL详细信息活动报告（DBMS_PERF.report_sql）; </li><li>  SQL监视（EMCC中的选项卡）； </li><li>  SQL监视报告（DBMS_SQLTUNE.report_sql_monitor *）。 </li></ul><br> 其中一些工具可在控制台中使用，也就是说，它们不与企业管理器绑定。 <br><br><div class="spoiler">  <b class="spoiler_title">Oracle收集统计信息的工具示例</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/d9/nk/rr/d9nkrrmgv-omldaqotcf1vxxub0.png"><br><br><ul><li> 上方的图表显示了与此请求一起工作的会话数。 </li><li> 左侧的方框显示了该请求从何处启动，位于哪个模块中。 </li><li> 左下-有关使用共享池的信息。 </li><li> 右图显示了系统中的等待事件。 在这种情况下，只有CPU。 </li><li> 右下-最有趣-具有质量特征的板，在分析性能问题时最重要。 </li></ul><br><img src="https://habrastorage.org/webt/h-/xw/en/h-xwenxxptrffbthe3bsj-dl0n4.png"><br><br>  SQL监视实时显示所有情况（绿色齿轮在旋转，查询现在正在运行）。 <br><img src="https://habrastorage.org/webt/ke/3n/vg/ke3nvg_q8afcbolkbcxdnkg3qaa.png"><br><br> 以上是SQL监控报告的内部内容。 它实时显示执行的查询行以及读取的行数（“实际行数”列）。 在这种情况下，INDEX RANGE SCAN已经计算了500万。 <br><br><img src="https://habrastorage.org/webt/ow/39/j1/ow39j1yvfaecppovtbgjb8tgsaq.png"><br><br>  SQL Monitoring Report文本工具，其中包含一些信息（并非全部）。 <br><img src="https://habrastorage.org/webt/br/zu/py/brzupy-mengmdxvh_cppnsogl0w.png"><br></div></div><br>  <strong>奖励：</strong> RNCO“付款中心”和CFT <strong>的</strong>专家为在新西伯利亚举行的会议做好了充分的准备，做了一些有用的报道，还组织了一个真正的出口电台。 两天来，专家，演讲者和组织者设法访问了CFT电台。 您可以通过添加条目来回到西伯利亚的夏天，这是各部分的链接： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Kubernetes：优缺点</a> ；  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数据科学与机器学习</a> ;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DevOps</a> 。 <br><br><blockquote> 在11月8日和9日已经在莫斯科举行的HighLoad ++上，将会有更多有趣的事情。 该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">计划</a>包括<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">合作伙伴的</a>高负荷项目，大师班，会议和活动的所有方面的报告，他们将分享专家的建议并发现令人惊讶的地方。 请务必写出最有趣的文章，并在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">时事通讯中进行</a>通知，以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">取得</a>联系！ <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN428491/">https://habr.com/ru/post/zh-CN428491/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN428477/index.html">对于那些选择防火墙的人</a></li>
<li><a href="../zh-CN428481/index.html">数字合同：非律师快速指南</a></li>
<li><a href="../zh-CN428485/index.html">大多数令人讨厌的人是无关紧要的广告和公共场所使用小工具的人</a></li>
<li><a href="../zh-CN428487/index.html">为什么Ruby on Rails很好，以及它如何加快开发速度</a></li>
<li><a href="../zh-CN428489/index.html">图标的稀薄程度。 Sketch Pro，渲染功能和具有线条粗细的游戏</a></li>
<li><a href="../zh-CN428493/index.html">Git Subrepo</a></li>
<li><a href="../zh-CN428495/index.html">我做了13年的足球模拟器</a></li>
<li><a href="../zh-CN428497/index.html">Noolite SUF-1-300定制无线调光器</a></li>
<li><a href="../zh-CN428499/index.html">令人毛骨悚然的蓝色巨人可以揭示恒星进化的秘密</a></li>
<li><a href="../zh-CN428501/index.html">DartUP：12月1日在圣彼得堡举行的有关Dart和Flutter的第一次俄语会议</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>