<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üß£ ü•ï ‚öñÔ∏è Detec√ß√£o de borda em tempo real usando FPGA üçÜ üë®üèΩ‚Äçü§ù‚Äçüë®üèº üë©üèø‚Äçü§ù‚Äçüë©üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introdu√ß√£o 


 Nosso projeto implementa um sistema de detec√ß√£o de borda em tempo real, com base na captura de quadros de imagem de uma c√¢mera OV767...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Detec√ß√£o de borda em tempo real usando FPGA</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431326/"><h2 id="introduction">  1. Introdu√ß√£o </h2><br><p>  Nosso projeto implementa um sistema de detec√ß√£o de borda em tempo real, com base na captura de quadros de imagem de uma c√¢mera OV7670 e no seu streaming para um monitor VGA ap√≥s a aplica√ß√£o de um filtro em escala de cinza e do operador Sobel.  Nosso design √© constru√≠do em uma placa FPGA Cyclone IV, que nos permite otimizar o desempenho usando os poderosos recursos do hardware de baixo n√≠vel e c√°lculos paralelos, o que √© importante para atender aos requisitos do sistema em tempo real. </p><br><p>  Usamos a placa de desenvolvimento ZEOWAA FPGA, baseada no ciclone IV (EP4CE6E22C8N).  Al√©m disso, usamos o Quartus Prime Lite Edition como ambiente de desenvolvimento e o Verilog HDL como linguagem de programa√ß√£o.  Al√©m disso, usamos a interface VGA integrada para acionar o monitor VGA e o GPIO (pinos gerais para entrada e sa√≠da) para conectar o hardware externo √† nossa placa. </p><br><p><img src="https://habrastorage.org/webt/j4/0g/l0/j40gl0a_funpi7k3om89bkjy2xc.png" alt="Placa de desenvolvimento ZEOWAA FPGA"></p><a name="habracut"></a><br><h2 id="architecture">  Arquitetura </h2><br><p>  Nosso design √© dividido em 3 partes principais: </p><br><ol><li>  Lendo os pixels de dados da c√¢mera. </li><li>  Implementando nosso algoritmo de detec√ß√£o de borda (conversor de escala de cinza e operador Sobel). </li><li>  Exibindo a imagem final atrav√©s da interface com um monitor VGA. </li></ol><br><p>  Al√©m disso, existe um armazenamento de mem√≥ria intermedi√°rio entre a leitura / grava√ß√£o dos dados e a opera√ß√£o nesses dados.  Para esse fim, implementamos dois buffers que funcionam como espa√ßo tempor√°rio para pixels antes de serem usados. </p><br><p><img src="https://habrastorage.org/webt/-m/ra/4n/-mra4ni51g8heajqfmzauskcbtu.jpeg" alt="A arquitetura implementada"></p><br><p>  Observe que, depois de tirarmos o pixel da c√¢mera, n√£o o armazenamos diretamente no buffer de mem√≥ria intermedi√°rio.  Em vez disso, a convertemos para a escala de cinza e a armazenamos no buffer.  Isso ocorre porque o armazenamento de pixels em escala de cinza de 8 bits requer menos mem√≥ria do que o armazenamento dos pixels coloridos de 16 bits.  Al√©m disso, temos outro buffer que armazena os dados ap√≥s a aplica√ß√£o do operador Sobel para prepar√°-los para serem exibidos no monitor. </p><br><p>  Aqui est√£o os detalhes sobre a implementa√ß√£o de nossa arquitetura: </p><cut></cut><br><h5 id="camera">  Camera </h5><br><p>  Usamos a c√¢mera OV7670, que √© um dos m√≥dulos de c√¢mera mais baratos que encontramos.  Al√©m disso, esta c√¢mera pode funcionar em 3.3V e n√£o precisa de protocolos de comunica√ß√£o dif√≠ceis, como I2c ou SPI, para extrair os dados da imagem.  Requer apenas interface SCCB, que √© semelhante √† interface I2c, para definir a configura√ß√£o da c√¢mera em termos de formato de cor (RGB565, RGB555, YUV, YCbCr 4: 2: 2), resolu√ß√£o (VGA, QVGA, QQVGA, CQ, QCIF) e muitas outras configura√ß√µes. </p><br><p><img src="https://habrastorage.org/webt/hj/47/uk/hj47ukzo4cqixn0tyzwegoerumg.jpeg" alt="M√≥dulo de c√¢mera OV7670"></p><br><p>  O v√≠deo consiste em quadros que est√£o sendo alterados a uma taxa espec√≠fica.  Um quadro √© uma imagem que consiste em linhas e colunas de pixels, onde cada pixel √© representado por valores de cores.  Neste projeto, usamos a configura√ß√£o padr√£o da c√¢mera em que o tamanho do quadro √© a resolu√ß√£o VGA 640 x 480 (0,3 megapixels) e o formato de cor do pixel √© RGB565 (5 bits para vermelho, 6 bits para azul, 5 bits para verde) ) e a taxa de altera√ß√£o dos quadros √© de 30 fps. </p><br><p>  Abaixo, as conex√µes da c√¢mera ao FPGA usando o GPIO existente na placa de desenvolvimento: </p><br><table><thead><tr><th>  Pin na c√¢mera </th><th>  pino no FPGA </th><th>  Descri√ß√£o do produto </th><th>  Pin na c√¢mera </th><th>  pino no FPGA </th><th>  Descri√ß√£o do produto </th></tr></thead><tbody><tr><td>  3.3V </td><td>  3.3V </td><td>  Fonte de Alimenta√ß√£o (+) </td><td>  GND </td><td>  GND </td><td>  N√≠vel de fornecimento terrestre (-) </td></tr><tr><td>  Sdioc </td><td>  GND </td><td>  Rel√≥gio SCCB </td><td>  SDIOD </td><td>  GND </td><td>  Dados SCCB </td></tr><tr><td>  VSYNC </td><td>  P31 </td><td>  Sincroniza√ß√£o vertical </td><td>  Href </td><td>  P55 </td><td>  Sincroniza√ß√£o horizontal </td></tr><tr><td>  PCLK </td><td>  P23 </td><td>  Rel√≥gio de pixel </td><td>  Xclk </td><td>  P54 </td><td>  Rel√≥gio do sistema de entrada (25 MHz) </td></tr><tr><td>  D7 </td><td>  P46 </td><td>  8¬∫ bit de dados </td><td>  D6 </td><td>  P44 </td><td>  S√©timo bit de dados </td></tr><tr><td>  D5 </td><td>  P43 </td><td>  6¬∫ bit de dados </td><td>  D4 </td><td>  P42 </td><td>  Quinto bit de dados </td></tr><tr><td>  D3 </td><td>  P39 </td><td>  4¬∫ bit de dados </td><td>  D2 </td><td>  P38 </td><td>  Terceiro bit de dados </td></tr><tr><td>  D1 </td><td>  P34 </td><td>  Segundo bit de dados </td><td>  D0 </td><td>  P33 </td><td>  1¬∫ bit de dados </td></tr><tr><td>  RESET (ativo baixo) </td><td>  3.3V </td><td>  Redefinir pino </td><td>  PWDN </td><td>  GND </td><td>  Pino de desligamento </td></tr></tbody></table><br><p>  Observe que n√£o usamos a interface SCCB para configura√ß√£o.  Ent√£o, colocamos seus fios correspondentes no ch√£o para evitar qualquer sinal flutuante que possa afetar os dados. </p><br><p>  Para fornecer o rel√≥gio de 25MHz para a c√¢mera, usamos PLL (Phase-Locked Loop), que √© um sistema de controle de frequ√™ncia em loop fechado para fornecer o rel√≥gio necess√°rio a partir dos 50MHz fornecidos pela placa.  Para implementar o PLL, usamos a ferramenta de cat√°logo IP interno no software Quartus. </p><cut></cut><br><p>  Esta c√¢mera usa o sinal de sincroniza√ß√£o vertical (VSYNC) para controlar o processo de envio do quadro e o sinal de sincroniza√ß√£o horizontal (HREF) para controlar o envio de cada linha do quadro.  Esta c√¢mera usa apenas 8 linhas de dados (D0-D7) para transferir os bits que representam os valores de cor do pixel, pois ela divide o valor do pixel RGB de 16 bits em 2 partes (8 bits) e envia cada uma separadamente. </p><br><p>  As figuras abaixo da folha de dados do m√≥dulo da c√¢mera OV7670 ilustram os sinais da sincroniza√ß√£o vertical e horizontal. </p><br><p><img src="https://habrastorage.org/webt/vu/9-/nr/vu9-nr2blv5dnrfezs1dsuja8ns.png" alt="Temporiza√ß√£o do quadro VGA"></p><br><p><img src="https://habrastorage.org/webt/q8/bb/nj/q8bbnji2ajbs3nxklpstw55mip8.png" alt="Temporiza√ß√£o horizontal"></p><br><p><img src="https://habrastorage.org/webt/sr/qt/5n/srqt5n3eoriiopfeq0icnpnf4z0.png" alt="Diagrama de tempo de sa√≠da RGB565"></p><br><h5 id="grayscale-converter">  Conversor de escala de cinza </h5><br><p>  Para produzir uma imagem em escala de cinza a partir de sua imagem colorida original, muitos fatores devem ser levados em considera√ß√£o, pois a imagem pode perder contraste, nitidez, sombra e estrutura.  Al√©m disso, a imagem deve preservar a lumin√¢ncia relativa do espa√ßo de cores.  V√°rias t√©cnicas lineares e n√£o lineares s√£o usadas para converter a imagem colorida em escala de cinza.  Dessa forma, para atingir nosso objetivo, usamos a convers√£o colorim√©trica (preserva√ß√£o da luminosidade perceptiva) em escala de cinza representada na seguinte equa√ß√£o: </p><br><p><img src="https://habrastorage.org/webt/xo/na/bk/xonabkl8jpwg5zixxk9yl6hr8lw.png"></p><br><p>  Para aprimorar o desempenho em termos de c√°lculos, √© mais r√°pido usar o operador shift.  Portanto, a equa√ß√£o acima pode ser reduzida para o seguinte: </p><cut></cut><br><p><img src="https://habrastorage.org/webt/sm/6s/nr/sm6snrzc5z7nem3fsgamwy81xis.png"></p><br><p>  Como resultado, ap√≥s capturar um valor de pixel (565 RGB) da c√¢mera, ele pode ser convertido imediatamente em um valor de pixel em escala de cinza de 8 bits, aplicando a f√≥rmula da convers√£o.  A imagem em escala de cinza √© mais f√°cil de armazenar na mem√≥ria e r√°pida o suficiente para atender √† funcionalidade do nosso sistema em tempo real, pois sua complexidade √© aproximadamente logar√≠tmica e o FPGA pode torn√°-lo ainda mais r√°pido acessando a mem√≥ria em paralelo.  Depois disso, a imagem armazenada est√° pronta para implementar o algoritmo de detec√ß√£o de borda. </p><br><h5 id="intermediate-memory-the-buffer">  Mem√≥ria intermedi√°ria (o buffer) </h5><br><p>  Temos dois buffers, o primeiro √© usado para armazenar os pixels ap√≥s convert√™-los em escala de cinza e seu tamanho (8 bits x 150 x 150) e o segundo √© usado para armazenar os pixels ap√≥s a aplica√ß√£o do operador Sobel e o limite para o valor de sa√≠da e seu tamanho (1 bit x 150 x 150).  Infelizmente, os buffers de 150 x 150 n√£o armazenam a imagem inteira da c√¢mera, mas armazenam apenas parte dela. </p><br><p>  Escolhemos o tamanho de nossos buffers como 150 x 150 por causa da limita√ß√£o da mem√≥ria do ciclone IV, pois ele possui apenas 276,480 Kbit, enquanto nossos dois buffers recebem 202,500 Kbit (150 x 150 x 9), o que equivale a 73,24% da mem√≥ria original do o ciclone IV e o restante da mem√≥ria s√£o usados ‚Äã‚Äãpara armazenar o algoritmo e a arquitetura.  Al√©m disso, tentamos (170 x 170) como um tamanho para nossos buffers, que retiram 94,07% da mem√≥ria, o que n√£o deixa espa√ßo suficiente na implementa√ß√£o do algoritmo. </p><cut></cut><br><p>  Nossos buffers s√£o a verdadeira RAM de porta dupla, que pode ler e gravar em diferentes ciclos de clock simultaneamente.  Aqui, criamos nossa implementa√ß√£o em vez de usar a ferramenta de cat√°logo IP no software Quartus para ter mais flexibilidade na implementa√ß√£o.  Al√©m disso, integramos os dois buffers em apenas um m√≥dulo em vez de ter m√≥dulos diferentes. </p><br><h5 id="sobel-operator">  Operador Sobel </h5><br><p>  Utilizamos um primeiro operador de detec√ß√£o de borda derivada, que √© um operador de gradiente de √°rea da matriz que determina a mudan√ßa de lumin√¢ncia entre diferentes pixels.  Para ser mais preciso, por ser um m√©todo direto e eficiente em termos de uso de mem√≥ria e complexidade de tempo, usamos o operador de gradiente Sobel que usa o n√∫cleo 3x3 centralizado em um pixel escolhido para representar a for√ßa da borda.  O operador Sobel √© a magnitude do gradiente calculado por: </p><br><p><img src="https://habrastorage.org/webt/1e/-8/aj/1e-8ajvp7o58vzzhc6d5euzljfa.png" alt="Equa√ß√£o G"></p><br><p>  Onde Gx e Gy podem ser representados usando m√°scaras de convolu√ß√£o: </p><br><p><img src="https://habrastorage.org/webt/gq/3e/tb/gq3etbpr2ioaxrpzgmtbk8p0ppg.png" alt="Matrizes de convolu√ß√£o Gx e Gy"></p><cut></cut><br><p>  Observe que os pixels mais pr√≥ximos do centro da m√°scara recebem mais peso.  Al√©m disso, G <sub>x</sub> e G <sub>y</sub> podem ser calculados da seguinte forma: </p><br><p><img src="https://habrastorage.org/webt/ji/wt/us/jiwtusibcq8rngnqe3hvy3kbzgu.png" alt="Equa√ß√µes Gx e GY"></p><br><p>  Onde pi √© o pixel correspondente na seguinte matriz e o valor de pi √© um valor em escala de cinza de 8 bits: </p><br><p><img src="https://habrastorage.org/webt/-0/cd/4s/-0cd4stky-xqnhkaeulsuvujbam.png" alt="matriz de pixels"></p><br><p>  √â uma pr√°tica comum aproximar a magnitude do gradiente do operador Sobel por valores absolutos: </p><br><p><img src="https://habrastorage.org/webt/jq/ga/tr/jqgatrro-agy4-hdyu_92umzdgi.png" alt="a equa√ß√£o"></p><br><p>  Essa aproxima√ß√£o √© mais f√°cil de implementar e mais r√°pida de calcular, o que novamente serve √† nossa funcionalidade em termos de tempo e mem√≥ria. </p><br><p>  Aqui est√° o diagrama de blocos do operador Sobel, que recebe 9 (8 bits) pixels como entrada e produz um valor de pixel (8 bits): </p><cut></cut><br><p><img src="https://habrastorage.org/webt/l4/eg/9w/l4eg9warlvign4ibbjq3ptcuvg4.jpeg" alt="N√∫cleo de Sobel"></p><br><p>  E aqui est√° o diagrama de blocos detalhado da implementa√ß√£o do operador Sobel. </p><br><p><img src="https://habrastorage.org/webt/tg/0o/pg/tg0opgzckrosd2eaanar-jisy14.jpeg" alt="N√∫cleo detalhado de Sobel"></p><br><h5 id="vga-monitor">  Monitor VGA </h5><br><p>  Nossa placa de desenvolvimento possui uma interface VGA incorporada, capaz de exibir apenas 8 cores no monitor VGA, pois possui apenas 3 bits para controlar as cores atrav√©s de um bit para vermelho, um para verde e um para azul.  Isso tornou nossa depura√ß√£o mais dif√≠cil, pois nos impede de exibir a imagem da c√¢mera diretamente no monitor.  Portanto, usamos um limite para converter os pixels em valor de 1 bit, para que seja poss√≠vel exibir a imagem. </p><br><p>  A interface VGA funciona como a c√¢mera, pois opera pixel por pixel do canto superior esquerdo ao canto inferior direito.  Usando a sincroniza√ß√£o vertical e horizontal, podemos sincronizar os sinais que controlam o fluxo de pixels. </p><br><p>  O sinal de sincroniza√ß√£o vertical √© usado para representar o √≠ndice da linha, enquanto o sinal de sincroniza√ß√£o horizontal √© usado para representar o √≠ndice da coluna.  Al√©m disso, ambos os sinais usam a varanda frontal, o pulso de sincroniza√ß√£o e a varanda traseira como sinais de sincroniza√ß√£o para separar a linha antiga da nova linha no sinal de sincroniza√ß√£o horizontal e o quadro antigo do novo quadro no sinal de sincroniza√ß√£o vertical. </p><cut></cut><br><p><img src="https://habrastorage.org/webt/uv/3f/gv/uv3fgvrj_y9yuabjdhuxhvek0ak.png" alt="Diagrama de tempo do sinal VGA"></p><br><p>  Usamos a interface de sinal VGA padr√£o (640 x 480 a 60 MHz).  Todas as especifica√ß√µes padr√£o do sinal s√£o descritas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </p><br><h2 id="testing">  Teste </h2><br><p>  Antes de juntar tudo e testar o sistema em tempo real.  Primeiro tivemos que testar cada parte separadamente.  Inicialmente, verificamos os valores e sinais que v√™m da c√¢mera exibindo certos valores de pixel.  Ent√£o, com a ajuda do OpenCV usando a linguagem de programa√ß√£o Python, pudemos aplicar o filtro Sobel em v√°rias imagens para comparar os resultados com nosso algoritmo e verificar a exatid√£o de nossa l√≥gica.  Al√©m disso, testamos nossos buffers e driver VGA exibindo v√°rias imagens est√°ticas no monitor VGA ap√≥s aplicar o operador Sobel e o limiar.  Al√©m disso, alterando o valor do limite, a precis√£o da imagem √© afetada. </p><cut></cut><br><p>  O c√≥digo python que usamos: </p><br><pre><code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># This code is made to test the accuracy of our algorithm on FPGA import cv2 #import opencv library f = open("sample.txt",'w') # Open file to write on it the static image initialization lines img = cv2.imread('us.jpg') # Read the image which has our faces and its size 150x150 gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) #convert to grayscale sobelx = cv2.Sobel(gray,cv2.CV_64F,1,0,ksize=3) #x-axis sobel operator sobely = cv2.Sobel(gray,cv2.CV_64F,0,1,ksize=3) #y-axis sobel operator abs_grad_x = cv2.convertScaleAbs(sobelx) abs_grad_y = cv2.convertScaleAbs(sobely) grad = abs_grad_x + abs_grad_y for i in range(0,150): for x in range(0,150): #read the pixels of the grayscaled image and Store them into file with specific format to initialize the buffer in FPGA code f.write("data_a[{:d}]&lt;=8'd{:d};\n".format(i*150+x,gray[i][x])) #apply threshold to be exactly like the code on FPGA if(grad[i][x] &lt; 100): grad[i][x] = 255 else: grad[i][x] = 0 cv2.imshow("rgb", img) #Show the real img cv2.imshow("gray",gray) #Show the grayscale img cv2.imshow("sobel",grad)#Show the result img cv2.waitKey(0) #Stop the img to see it</span></span></code> </pre> <cut></cut><br><h2 id="results">  Resultados </h2><br><p>  Como resultado de nossa implementa√ß√£o, obtivemos um sistema de detec√ß√£o de borda em tempo real que produz uma imagem de 150x150 ap√≥s a aplica√ß√£o do filtro em escala de cinza e do operador Sobel.  O sistema implementado fornece 30 fps.  A c√¢mera funciona com um rel√≥gio de 25 MHz e o sistema, em geral, cumpre os prazos em tempo real sem atraso percept√≠vel.  Al√©m disso, o valor limite pode afetar a quantidade de detalhes e o ru√≠do na imagem final. </p><br><p>  Aqui est√° uma compara√ß√£o entre o operador Sobel no FPGA e o operador sobel OpenCV: </p><br><p><img src="https://habrastorage.org/webt/pg/sl/rc/pgslrcclisueu2qpfghaav-yju8.png" alt="Compara√ß√£o"></p><br><p>  Abaixo est√° um v√≠deo ilustrativo dos resultados: </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/3a5/ea2/d49/3a5ea2d49eeb6e23f9ca4a64921d287a.jpg" alt="V√≠deo do projeto"></a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aqui</a> est√° o link do reposit√≥rio no Github, que possui todos os c√≥digos-fonte. </p><br><h2 id="future-improvements">  Melhorias futuras </h2><br><p>  Como estamos usando o FPGA Cyclone IV, estamos limitados √† sua capacidade de mem√≥ria e ao n√∫mero de portas l√≥gicas.  Portanto, como uma melhoria futura, podemos usar uma fonte de mem√≥ria externa ou implementar nosso trabalho em outra placa para exibir todos os pixels da imagem recebida da c√¢mera. </p><br><p>  Al√©m disso, embora o operador Sobel seja r√°pido e simples de implementar, √© notavelmente sens√≠vel ao ru√≠do.  Para eliminar o ru√≠do produzido, podemos usar um filtro de ru√≠do como o filtro mediano n√£o linear que funciona perfeitamente bem com o nosso sistema se tivermos mem√≥ria suficiente para implementar um terceiro buffer.  Isso produzir√° uma imagem mais suave com os recursos n√≠tidos removidos. </p><br><p>  Dessa forma, usamos a interface VGA integrada do FPGA, que s√≥ pode produzir uma imagem de 3 bits.  Portanto, n√£o foi poss√≠vel exibir a imagem em escala de cinza, pois ela precisa de 8 bits para ser exibida.  Como resultado, implementar outra interface ou usar uma placa mais poderosa aumentar√° a flexibilidade de exibir a imagem. </p><cut></cut><br><h2 id="conclusion">  Conclus√£o </h2><br><p>  Conseguimos usar nosso conhecimento e compreens√£o de conceitos cruciais em sistemas embarcados como m√°quinas de estado, paralelismo de computa√ß√£o e interface de hardware e software para criar um aplicativo eficiente de detec√ß√£o de borda que atenda aos nossos objetivos. </p><br><h2 id="acknowledgment">  Agradecimentos </h2><br><p>  Este projeto √© constru√≠do por uma equipe composta por dois estudantes: <strong>Hussein Youness</strong> e <strong>Hany Hamed</strong> no primeiro ano de bacharel em Ci√™ncia da Computa√ß√£o na <strong>Universidade de Innopolis,</strong> na R√∫ssia. </p><br><p>  Este projeto faz parte do curso de <strong>Arquitetura</strong> da <strong>Computa√ß√£o no</strong> outono de 2018 na <strong>Universidade de Innopolis</strong> . </p><br><div class="spoiler">  <b class="spoiler_title">Refer√™ncias</b> <div class="spoiler_text"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://eu.mouser.com/ProductDetail/Intel-Altera/EP4CE6E22C8N?qs=jblrfmjbeiF2FLmcokX%252bDw%3D%3D</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://www.voti.nl/docs/OV7670.pdf</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://embeddedprogrammer.blogspot.com/2012/07/hacking-ov7670-camera-module-sccb-cheat.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://www.intel.com/content/www/us/en/programmable/support/support-resources/operation-and-testing/pll-and-clock-management/pll-basics.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://knowledge.ni.com/KnowledgeArticleDetails?id=kA00Z000000P9T3SAK</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/ug/ug_megafunction_overview.pdf</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/ug/ug_ram_rom.pdf</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://www.tannerhelland.com/3643/grayscale-image-algorithm-vb6/</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://www.cse.usf.edu/~r1k/MachineVisionBook/MachineVision.files/MachineVision_Chapter5.pdf</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://www.digikey.com/eewiki/pages/viewpage.action?pageId=15925278</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://tinyvga.com/vga-timing/640x480@60Hz</a> </p></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt431326/">https://habr.com/ru/post/pt431326/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt431316/index.html">Vota√ß√£o na segunda vers√£o beta do Relat√≥rio Revisado 7 sobre Esquema de Linguagem Algor√≠tmica (Linguagem Grande)</a></li>
<li><a href="../pt431318/index.html">Cadeia de transpiladores Python ‚Üí 11l ‚Üí C ++ [para acelerar o c√≥digo Python e mais]</a></li>
<li><a href="../pt431320/index.html">Estudo IFR: o n√∫mero de rob√¥s industriais na R√∫ssia ainda √© insignificante</a></li>
<li><a href="../pt431322/index.html">Itera√ß√µes do ciclo: como foi a confer√™ncia do HolyJS e o que dizer da pr√≥xima</a></li>
<li><a href="../pt431324/index.html">A Microsoft oferece uma alternativa para caracteres personalizados</a></li>
<li><a href="../pt431328/index.html">Kotlin, IT na Est√¥nia e (de repente) o t√∫nel entre Tallinn e Helsinque: uma entrevista com Anton Keks</a></li>
<li><a href="../pt431330/index.html">Fim de semana m√≥vel: Mobius transmiss√£o gratuita</a></li>
<li><a href="../pt431332/index.html">Vis√£o geral dos relat√≥rios DotNext 2018 mais interessantes: vers√£o EastBanc Technologies</a></li>
<li><a href="../pt431334/index.html">Huawei: prote√ß√£o do avi√£o de controle</a></li>
<li><a href="../pt431338/index.html">O livro "DNA. A hist√≥ria da revolu√ß√£o gen√©tica ‚Äù</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>