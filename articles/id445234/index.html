<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§‘ğŸ¿â€ğŸ¤â€ğŸ§‘ğŸ¾ ğŸ€ â—¼ï¸ Pengecualian python sekarang dianggap anti-pola ğŸ¼ ğŸ‘©ğŸ¼â€ğŸ¤â€ğŸ‘¨ğŸ» ğŸ˜›</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apa itu pengecualian? Dari namanya jelas - mereka muncul ketika pengecualian terjadi dalam program. Anda mungkin bertanya mengapa pengecualian merupak...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengecualian python sekarang dianggap anti-pola</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/445234/">  Apa itu pengecualian?  Dari namanya jelas - mereka muncul ketika pengecualian terjadi dalam program.  Anda mungkin bertanya mengapa pengecualian merupakan anti-pola, dan bagaimana kaitannya dengan mengetik?  Saya mencoba <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mencari tahu</a> , dan sekarang saya ingin membicarakan ini dengan Anda, harazhiteli. <br><br><h2>  Masalah Pengecualian </h2><br>  Sulit menemukan kekurangan pada apa yang Anda hadapi setiap hari.  Kebiasaan dan kebutaan mengubah bug menjadi fitur, tetapi mari kita coba melihat pengecualian dengan pikiran terbuka. <br><br><h3>  Pengecualian sulit dikenali </h3><br>  Ada dua jenis pengecualian: "eksplisit" dibuat dengan memanggil <code>raise</code> langsung dalam kode yang Anda baca;  "Tersembunyi" tersembunyi dalam fungsi, kelas, metode yang digunakan. <br><br>  Masalahnya adalah bahwa pengecualian â€œtersembunyiâ€ sangat sulit untuk diperhatikan.  Mari saya tunjukkan contoh fungsi murni: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first: float, second: float)</span></span></span><span class="hljs-function"> -&gt; float:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first / second</code> </pre><br>  Fungsi ini hanya membagi satu nomor dengan yang lain, mengembalikan <code>float</code> .  Jenis dicentang dan Anda dapat menjalankan sesuatu seperti ini: <br><br><pre> <code class="python hljs">result = divide(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) print(<span class="hljs-string"><span class="hljs-string">'x / y = '</span></span>, result)</code> </pre><br>  Pernahkah Anda memperhatikan?  Bahkan, pelaksanaan program tidak akan pernah mencapai <code>print</code> , karena membagi 1 dengan 0 adalah operasi yang mustahil, itu akan meningkatkan <code>ZeroDivisionError</code> .  Ya, kode seperti itu aman, tetapi tidak bisa digunakan. <br><a name="habracut"></a><br>  Untuk memperhatikan masalah potensial bahkan dalam kode yang sederhana dan mudah dibaca, orang perlu pengalaman.  Apa pun di Python dapat berhenti bekerja dengan berbagai jenis pengecualian: pembagian, pemanggilan fungsi, <code>int</code> , <code>str</code> , generator, iterator dalam loop, akses ke atribut atau kunci.  Bahkan <code>raise something()</code> dapat menyebabkan crash.  Selain itu, saya bahkan tidak menyebutkan operasi input dan output.  Dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengecualian yang dicentang tidak akan lagi didukung</a> dalam waktu dekat. <br><br><h3>  Memulihkan perilaku normal pada tempatnya tidak dimungkinkan </h3><br>  Tetapi tepatnya untuk kasus seperti itu, kami memiliki pengecualian.  Mari kita menangani <code>ZeroDivisionError</code> dan kodenya akan menjadi tipe aman. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first: float, second: float)</span></span></span><span class="hljs-function"> -&gt; float:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first / second <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ZeroDivisionError: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span></code> </pre><br>  Sekarang semuanya baik-baik saja.  Tetapi mengapa kita mengembalikan 0?  Kenapa tidak 1 atau tidak sama sekali?  Tentu saja, dalam kebanyakan kasus, mendapatkan <code>None</code> sama buruknya (jika tidak lebih buruk) sebagai pengecualian, tetapi Anda masih harus mengandalkan logika bisnis dan opsi untuk menggunakan fungsi tersebut. <br><br>  Apa sebenarnya yang kami bagikan?  Angka sewenang-wenang, ada unit atau uang tertentu?  Tidak setiap opsi mudah diramalkan dan dipulihkan.  Mungkin ternyata bahwa lain kali Anda menggunakan satu fungsi, ternyata Anda memerlukan logika pemulihan yang berbeda. <br><br><blockquote>  Kesimpulan yang menyedihkan: solusi untuk setiap masalah adalah individual, tergantung pada konteks penggunaan tertentu. </blockquote><br>  Tidak ada peluru perak untuk berurusan dengan <code>ZeroDivisionError</code> sekali dan untuk semua.  Dan kita tidak berbicara tentang kemungkinan I / O kompleks dengan permintaan dan batas waktu berulang. <br><br>  Mungkin itu tidak perlu untuk menangani pengecualian di mana mereka muncul?  Mungkin hanya membuangnya ke proses eksekusi kode - seseorang akan mengetahuinya nanti.  Dan kemudian kita dipaksa untuk kembali ke keadaan saat ini. <br><br><h3>  Proses eksekusi tidak jelas </h3><br>  Yah, mari kita berharap orang lain menangkap pengecualian dan mungkin menanganinya.  Misalnya, sistem dapat meminta pengguna untuk mengubah nilai yang dimasukkan, karena tidak dapat dibagi dengan 0. Dan fungsi <code>divide</code> tidak boleh secara eksplisit bertanggung jawab untuk memulihkan dari kesalahan. <br><br>  Dalam hal ini, Anda perlu memeriksa di mana kami menangkap pengecualian.  Ngomong-ngomong, bagaimana cara menentukan dengan tepat di mana ia akan diproses?  Apakah mungkin untuk pergi ke tempat yang tepat dalam kode?  Ternyata tidak, <strong>itu tidak mungkin</strong> . <br><br>  Tidak mungkin untuk menentukan baris kode mana yang akan dieksekusi setelah pengecualian dilemparkan.  Berbagai jenis pengecualian dapat ditangani dengan opsi pengecualian yang berbeda, dan beberapa pengecualian dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diabaikan</a> .  Dan Anda bisa melempar pengecualian tambahan di modul lain yang akan dijalankan sebelumnya, dan secara umum akan mematahkan semua logika. <br><br>  Misalkan ada dua utas independen dalam suatu aplikasi: utas reguler yang berjalan dari atas ke bawah, dan utas pengecualian yang berjalan sesuai keinginan.  Bagaimana cara membaca dan memahami kode ini? <br><br>  Hanya dengan debugger diaktifkan dalam mode "tangkap semua pengecualian". <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8k/bn/do/8kbndolwukkaluarfk3vpexws2w.png"></div><br>  Pengecualian, seperti <code>goto</code> terkenal, merobek struktur program. <br><br><h3>  Pengecualian tidak eksklusif </h3><br>  Mari kita lihat contoh lain: kode akses HTTP API jarak jauh yang biasa: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch_user_profile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user_id: int)</span></span></span><span class="hljs-function"> -&gt; 'UserProfile':</span></span> <span class="hljs-string"><span class="hljs-string">"""Fetches UserProfile dict from foreign API."""</span></span> response = requests.get(<span class="hljs-string"><span class="hljs-string">'/api/users/{0}'</span></span>.format(user_id)) response.raise_for_status() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response.json()</code> </pre><br>  Dalam contoh ini, secara harfiah semuanya bisa salah.  Berikut adalah sebagian daftar kemungkinan kesalahan: <br><br><ul><li>  Jaringan mungkin tidak tersedia dan permintaan tidak akan dieksekusi sama sekali. </li><li>  Server mungkin tidak berfungsi. </li><li>  Server mungkin terlalu sibuk, batas waktu akan terjadi. </li><li>  Server mungkin memerlukan otentikasi. </li><li>  API mungkin tidak memiliki URL seperti itu. </li><li>  Pengguna yang tidak ada dapat ditransfer. </li><li>  Mungkin tidak cukup hak. </li><li>  Server mungkin macet karena kesalahan internal saat memproses permintaan Anda </li><li>  Server dapat mengembalikan respons yang tidak valid atau rusak. </li><li>  Server dapat mengembalikan JSON tidak valid yang tidak dapat diuraikan. </li></ul><br>  Daftar ini terus dan terus, begitu banyak potensi masalah terletak pada kode dari tiga baris yang disayangkan.  Kita dapat mengatakan bahwa itu umumnya hanya bekerja dengan peluang keberuntungan, dan jauh lebih mungkin untuk jatuh dengan pengecualian. <br><br><h2>  Bagaimana cara melindungi diri sendiri? </h2><br>  Sekarang kami telah memastikan bahwa pengecualian dapat merusak kode, mari cari tahu cara menghilangkannya.  Untuk menulis kode tanpa kecuali, ada pola yang berbeda. <br><br><ul><li>  Di mana-mana menulis <code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">except Exception: pass</a></code> .  Jalan buntu.  <strong>Jangan lakukan itu.</strong> </li><li>  Kembali tidak <code>None</code>  Terlalu jahat.  Akibatnya, Anda harus memulai hampir setiap baris dengan <code>if something is not None:</code> dan semua logika akan hilang di balik sampah pemeriksaan pembersihan, atau Anda akan menderita <code>TypeError</code> sepanjang waktu.  Bukan pilihan yang bagus. </li><li>  Tulis kelas untuk kasus penggunaan khusus.  Misalnya, <code>User</code> kelas dasar dengan subkelas untuk kesalahan seperti <code>UserNotFound</code> dan <code>MissingUser</code> .  Pendekatan ini dapat digunakan dalam beberapa situasi tertentu, seperti <code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AnonymousUser</a></code> di Django, tetapi membungkus semua kesalahan yang mungkin terjadi di kelas tidak realistis.  Ini akan mengambil terlalu banyak pekerjaan dan model domain akan menjadi kompleks yang tak terbayangkan. </li><li>  Gunakan wadah untuk membungkus variabel atau nilai kesalahan yang dihasilkan dalam pembungkus dan terus bekerja dengan nilai wadah.  Inilah sebabnya kami membuat proyek <code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@dry-python/return</a></code> .  Sehingga fungsinya mengembalikan sesuatu yang bermakna, diketik, dan aman. </li></ul><br>  Mari kita kembali ke contoh pembagian, yang mengembalikan 0 ketika kesalahan terjadi. Bisakah kita secara eksplisit menunjukkan bahwa fungsi tidak berhasil tanpa mengembalikan nilai numerik tertentu? <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> returns.result <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Result, Success, Failure <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first: float, second: float)</span></span></span><span class="hljs-function"> -&gt; Result[float, ZeroDivisionError]:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Success(first / second) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ZeroDivisionError <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> exc: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Failure(exc)</code> </pre><br>  Kami menyertakan nilai dalam salah satu dari dua pembungkus: <code>Success</code> atau <code>Failure</code> .  Kelas-kelas ini diwarisi dari kelas basis <code>Result</code> .  Jenis nilai yang dikemas dapat ditentukan dalam anotasi dengan fungsi yang dikembalikan, misalnya, <code>Result[float, ZeroDivisionError]</code> mengembalikan <code>Success[float]</code> atau <code>Failure[ZeroDivisionError]</code> . <br><br>  Apa yang ini berikan pada kita?  Lebih banyak <strong>pengecualian tidak luar biasa, tetapi merupakan masalah yang diharapkan</strong> .  Juga, membungkus pengecualian dalam <code>Failure</code> memecahkan masalah kedua: kompleksitas mengidentifikasi pengecualian potensial. <br><br><pre> <code class="python hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> + divide(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment"># =&gt; mypy error: Unsupported operand types for + ("int" and "Result[float, ZeroDivisionError]")</span></span></code> </pre><br>  Sekarang mereka mudah dikenali.  Jika Anda melihat <code>Result</code> dalam kode, maka fungsi tersebut dapat mengeluarkan pengecualian.  Dan Anda bahkan tahu tipenya di muka. <br><br>  Selain itu, perpustakaan ini sepenuhnya diketik dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kompatibel dengan PEP561</a> .  Artinya, mypy akan memperingatkan Anda jika Anda mencoba mengembalikan sesuatu yang tidak cocok dengan tipe yang dinyatakan. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> returns.result <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Result, Success, Failure <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first: float, second: float)</span></span></span><span class="hljs-function"> -&gt; Result[float, ZeroDivisionError]:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Success(<span class="hljs-string"><span class="hljs-string">'Done'</span></span>) <span class="hljs-comment"><span class="hljs-comment"># =&gt; error: incompatible type "str"; expected "float" except ZeroDivisionError as exc: return Failure(0) # =&gt; error: incompatible type "int"; expected "ZeroDivisionError"</span></span></code> </pre><br><h3>  Bagaimana cara bekerja dengan wadah? </h3><br>  Ada dua <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">metode</a> : <br><br><ul><li>  <code>map</code> untuk fungsi yang mengembalikan nilai normal; </li><li>  <code>bind</code> untuk fungsi yang mengembalikan wadah lain. </li></ul><br><pre> <code class="python hljs">Success(<span class="hljs-number"><span class="hljs-number">4</span></span>).bind(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> number: Success(number / <span class="hljs-number"><span class="hljs-number">2</span></span>)) <span class="hljs-comment"><span class="hljs-comment"># =&gt; Success(2) Success(4).map(lambda number: number + 1) # =&gt; Success(5)</span></span></code> </pre><br>  Keindahannya adalah bahwa kode ini akan melindungi Anda dari skrip yang gagal, karena <code>.bind</code> dan <code>.map</code> tidak akan dieksekusi untuk kontainer dengan <code>Failure</code> : <br><br><pre> <code class="python hljs">Failure(<span class="hljs-number"><span class="hljs-number">4</span></span>).bind(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> number: Success(number / <span class="hljs-number"><span class="hljs-number">2</span></span>)) <span class="hljs-comment"><span class="hljs-comment"># =&gt; Failure(4) Failure(4).map(lambda number: number / 2) # =&gt; Failure(4)</span></span></code> </pre><br>  Sekarang Anda bisa berkonsentrasi pada proses eksekusi yang benar dan memastikan bahwa kondisi yang salah tidak akan merusak program di tempat yang tidak terduga.  Dan selalu ada peluang untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menentukan kondisi yang salah, memperbaikinya</a> , dan kembali ke jalur yang telah dipahami dari proses tersebut. <br><br><pre> <code class="python hljs">Failure(<span class="hljs-number"><span class="hljs-number">4</span></span>).rescue(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> number: Success(number + <span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-comment"><span class="hljs-comment"># =&gt; Success(5) Failure(4).fix(lambda number: number / 2) # =&gt; Success(2)</span></span></code> </pre><br>  Dalam pendekatan kami, "semua masalah diselesaikan secara individual," dan "proses eksekusi sekarang transparan."  Nikmati pemrograman yang mengendarai rel! <br><br><h3>  Tetapi bagaimana cara memperluas nilai dari wadah? </h3><br>  Memang, jika Anda bekerja dengan fungsi yang tidak tahu apa-apa tentang wadah, Anda perlu nilai sendiri.  Kemudian Anda dapat menggunakan metode <code>.unwrap()</code> atau <code>.value_or()</code> : <br><br><pre> <code class="python hljs">Success(<span class="hljs-number"><span class="hljs-number">1</span></span>).unwrap() <span class="hljs-comment"><span class="hljs-comment"># =&gt; 1 Success(0).value_or(None) # =&gt; 0 Failure(0).value_or(None) # =&gt; None Failure(1).unwrap() # =&gt; Raises UnwrapFailedError()</span></span></code> </pre><br>  Tunggu, kami harus menyingkirkan pengecualian, dan sekarang ternyata semua panggilan <code>.unwrap()</code> dapat menyebabkan pengecualian lain? <br><br><h3>  Bagaimana tidak memikirkan UnwrapFailedErrors? </h3><br>  Oke, mari kita lihat bagaimana hidup dengan pengecualian baru.  Pertimbangkan contoh ini: Anda perlu memeriksa input pengguna dan membuat dua model dalam database.  Setiap langkah dapat diakhiri dengan pengecualian, itulah sebabnya semua metode dibungkus dalam <code>Result</code> : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> returns.result <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Result, Success, Failure <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreateAccountAndUser</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Creates new Account-User pair."""</span></span> <span class="hljs-comment"><span class="hljs-comment"># </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> we need to create a pipeline of these methods somehow... def _validate_user( self, username: str, email: str, ) -&gt; Result['UserSchema', str]: """Returns an UserSchema for valid input, otherwise a Failure.""" def _create_account( self, user_schema: 'UserSchema', ) -&gt; Result['Account', str]: """Creates an Account for valid UserSchema's. Or returns a Failure.""" def _create_user( self, account: 'Account', ) -&gt; Result['User', str]: """Create an User instance. If user already exists returns Failure."""</span></span></code> </pre><br>  Pertama, Anda tidak perlu memperluas nilai-nilai dalam logika bisnis Anda sendiri sama sekali: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreateAccountAndUser</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Creates new Account-User pair."""</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__call__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, username: str, email: str)</span></span></span><span class="hljs-function"> -&gt; Result['User', str]:</span></span> <span class="hljs-string"><span class="hljs-string">"""Can return a Success(user) or Failure(str_reason)."""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._validate_user( username, email, ).bind( self._create_account, ).bind( self._create_user, ) <span class="hljs-comment"><span class="hljs-comment"># ...</span></span></code> </pre><br>  Semuanya akan bekerja tanpa masalah, tidak ada pengecualian akan <code>.unwrap()</code> , karena <code>.unwrap()</code> tidak digunakan.  Tetapi apakah mudah untuk membaca kode seperti itu?  Tidak.  Dan apa alternatifnya?  <code>@pipeline</code> : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> result.functions <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pipeline <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreateAccountAndUser</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Creates new Account-User pair."""</span></span> @pipeline <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__call__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, username: str, email: str)</span></span></span><span class="hljs-function"> -&gt; Result['User', str]:</span></span> <span class="hljs-string"><span class="hljs-string">"""Can return a Success(user) or Failure(str_reason)."""</span></span> user_schema = self._validate_user(username, email).unwrap() account = self._create_account(user_schema).unwrap() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._create_user(account) <span class="hljs-comment"><span class="hljs-comment"># ...</span></span></code> </pre><br>  Sekarang kode ini dibaca dengan baik.  Begini caranya <code>.unwrap()</code> dan <code>@pipeline</code> bekerja bersama: setiap kali metode <code>.unwrap()</code> gagal dan <code>Failure[str]</code> , dekorator <code>@pipeline</code> menangkapnya dan mengembalikan <code>Failure[str]</code> sebagai nilai yang dihasilkan.  Ini adalah bagaimana saya mengusulkan untuk menghapus semua pengecualian dari kode dan membuatnya benar-benar aman dan diketik. <br><br><h2>  Bungkus semuanya </h2><br>  Oke, sekarang kami akan menerapkan alat baru, misalnya, dengan permintaan HTTP API.  Ingat bahwa setiap baris dapat memberikan pengecualian?  Dan tidak ada cara untuk membuat mereka mengembalikan wadah dengan <code>Result</code> .  Tapi Anda bisa menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dekorator @safe</a> untuk membungkus fungsi yang tidak aman dan membuatnya aman.  Di bawah ini adalah dua opsi kode yang melakukan hal yang sama: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> returns.functions <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> safe @safe <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first: float, second: float)</span></span></span><span class="hljs-function"> -&gt; float:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first / second <span class="hljs-comment"><span class="hljs-comment"># is the same as: def divide(first: float, second: float) -&gt; Result[float, ZeroDivisionError]: try: return Success(first / second) except ZeroDivisionError as exc: return Failure(exc)</span></span></code> </pre><br>  Yang pertama, dengan <code>@safe</code> , lebih mudah dan lebih baik untuk dibaca. <br><br>  Hal terakhir yang harus dilakukan dalam contoh permintaan API adalah menambahkan dekorator <code>@safe</code> .  Hasilnya adalah kode berikut: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> returns.functions <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pipeline, safe <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> returns.result <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Result <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FetchUserProfile</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Single responsibility callable object that fetches user profile."""</span></span> <span class="hljs-comment"><span class="hljs-comment">#: You can later use dependency injection to replace `requests` #: with any other http library (or even a custom service). _http = requests @pipeline def __call__(self, user_id: int) -&gt; Result['UserProfile', Exception]: """Fetches UserProfile dict from foreign API.""" response = self._make_request(user_id).unwrap() return self._parse_json(response) @safe def _make_request(self, user_id: int) -&gt; requests.Response: response = self._http.get('/api/users/{0}'.format(user_id)) response.raise_for_status() return response @safe def _parse_json(self, response: requests.Response) -&gt; 'UserProfile': return response.json()</span></span></code> </pre><br>  <strong>Untuk meringkas cara menyingkirkan pengecualian dan mengamankan kode</strong> : <br><br><ul><li>  Gunakan pembungkus <code>@safe</code> untuk semua metode yang dapat menimbulkan pengecualian.  Ini akan mengubah tipe fungsi yang <code>Result[OldReturnType, Exception]</code> ke <code>Result[OldReturnType, Exception]</code> . </li><li>  Gunakan <code>Result</code> sebagai wadah untuk mentransfer nilai dan kesalahan ke dalam abstraksi sederhana. </li><li>  Gunakan <code>.unwrap()</code> untuk memperluas nilai dari wadah. </li><li>  Gunakan <code>@pipeline</code> untuk membuat <code>.unwrap</code> panggilan <code>.unwrap</code> lebih mudah dibaca. </li></ul><br>  Dengan mematuhi aturan-aturan ini, kita dapat melakukan hal yang persis sama - hanya aman dan mudah dibaca.  Semua masalah dengan pengecualian diselesaikan: <br><br><ul><li>  <strong>"Pengecualian sulit dikenali</strong> . <strong>"</strong>  Sekarang mereka dibungkus dalam wadah <code>Result</code> diketik, yang membuatnya benar-benar transparan. </li><li>  <strong>"Memulihkan perilaku normal di tempat adalah tidak mungkin</strong> . <strong>"</strong>  Sekarang Anda dapat dengan aman mendelegasikan proses pemulihan ke pemanggil.  Untuk kasus seperti itu, ada <code>.fix()</code> dan <code>.rescue()</code> . </li><li>  <strong>"Urutan eksekusi tidak jelas</strong> . <strong>"</strong>  Sekarang mereka menyatu dengan aliran bisnis yang biasa.  Dari awal hingga akhir. </li><li>  <strong>"Pengecualian tidak luar biasa</strong> . <strong>"</strong>  Kami tahu!  Dan kami berharap ada sesuatu yang salah dan siap untuk apa pun. </li></ul><br><h3>  Gunakan Kasus dan Batasan </h3><br>  Jelas, Anda tidak dapat menggunakan pendekatan ini di semua kode Anda.  Ini akan <strong>terlalu aman</strong> untuk sebagian besar situasi sehari-hari dan tidak kompatibel dengan perpustakaan atau kerangka kerja lainnya.  Tetapi Anda harus menulis bagian terpenting dari logika bisnis Anda persis seperti yang saya tunjukkan, untuk memastikan operasi sistem Anda yang benar dan memfasilitasi dukungan di masa depan. <br><br><blockquote>  Apakah topik tersebut membuat Anda berpikir atau bahkan tampak holivarny?  Datang ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Moscow Python Conf ++</a> pada 5 April, kita akan membahas!  Selain saya, Artyom Malyshev, pendiri proyek dry-python dan pengembang inti Django Channels, akan ada di sana.  Dia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">akan berbicara</a> lebih banyak tentang dry-python dan logika bisnis. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id445234/">https://habr.com/ru/post/id445234/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id445220/index.html">AMD Radeon VII: Chip High-End (Bagian 3)</a></li>
<li><a href="../id445222/index.html">Dapatkan tawaran dalam 1 hari untuk tim backend pada Hari Kosmonautika</a></li>
<li><a href="../id445226/index.html">Pengembangan roket yang mampu mencapai bulan akan menelan biaya Rusia 740 miliar rubel</a></li>
<li><a href="../id445228/index.html">Kriptografi di Jawa. Kelas Mac</a></li>
<li><a href="../id445230/index.html">Pendaftaran untuk konferensi IT II untuk pemula SMARTRHINO-2019 dimulai</a></li>
<li><a href="../id445236/index.html">â€œExtreme NOW Forum 2019â€: Pendaftaran Terbuka</a></li>
<li><a href="../id445238/index.html">Tumbuh besar: 10 laporan teratas Mobius 2018 Moskow</a></li>
<li><a href="../id445240/index.html">Bagaimana cara memindahkan, mengunggah, dan mengintegrasikan data yang sangat besar secara murah dan cepat? Apa itu optimasi pushdown?</a></li>
<li><a href="../id445242/index.html">Pengalaman dengan Coroutines dan Retrofit2</a></li>
<li><a href="../id445244/index.html">â€œPermainan uang di luar blockchain harus matiâ€</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>