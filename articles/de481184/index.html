<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚¨áÔ∏è üïù ‚óªÔ∏è Die 10 h√§ufigsten Fehler in Java-Projekten im Jahr 2019 üßîüèª ü§î üçé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="2019 neigt sich dem Ende zu und das PVS-Studio-Team blickt auf die Erfolge dieses Jahres zur√ºck. Anfang 2019 erweiterten wir die Diagnosefunktionen un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die 10 h√§ufigsten Fehler in Java-Projekten im Jahr 2019</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/481184/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/n2/uy/oe/n2uyoeo7ko6owq_omdtzx419gty.png"></div><br>  2019 neigt sich dem Ende zu und das PVS-Studio-Team blickt auf die Erfolge dieses Jahres zur√ºck.  Anfang 2019 erweiterten wir die Diagnosefunktionen unseres Analysators um Java-Unterst√ºtzung, mit der wir auch Java-Projekte √ºberpr√ºfen und √ºberpr√ºfen konnten.  Wir haben in diesem Jahr viele Fehler gefunden, und hier sind unsere 10 h√§ufigsten Fehler, die in Java-Projekten gefunden wurden. <br><a name="habracut"></a><br><br><h2>  Nr  10: Byte mit Vorzeichen </h2><br>  Quelle: <a href="https://www.viva64.com/en/b/0663/">Analyse des Apache Dubbo RPC Frameworks durch den PVS-Studio Static Code Analyzer</a> <br><br>  <a href="https://www.viva64.com/en/w/v6007/">V6007</a> Ausdruck 'endKey [i] &lt;0xff' ist immer wahr.  OptionUtil.java (32) <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> ByteSequence </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prefixEndOf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ByteSequence prefix)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] endKey = prefix.getBytes().clone(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = endKey.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; i--) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (endKey[i] &lt; <span class="hljs-number"><span class="hljs-number">0xff</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= endKey[i] = (byte) (endKey[i] + 1); return ByteSequence.from(Arrays.copyOf(endKey, i + 1)); } } return ByteSequence.from(NO_PREFIX_END); }</span></span></code> </pre> <br>  Viele Programmierer glauben, dass der <i>Bytetyp</i> nicht vorzeichenbehaftet ist.  Dies ist in der Tat in vielen Programmiersprachen der Fall.  Dies gilt beispielsweise f√ºr C #.  Bei Java ist das nicht der Fall. <br><br>  In der <i>Bedingung endKey [i] &lt;0xff</i> wird eine Variable vom Typ <i>Byte</i> mit der hexadezimal dargestellten Zahl 255 (0xff) verglichen.  Der Entwickler hat wahrscheinlich vergessen, dass der Bereich des Java- <i>Bytetyps</i> [-128, 127] ist.  Diese Bedingung ist immer wahr, und die <i>for-</i> Schleife verarbeitet immer nur das letzte Element des <i>endKey-</i> Arrays. <br><br><h2>  Nr  9: Zwei in einem </h2><br>  Quelle: <a href="https://www.viva64.com/en/b/0621/">PVS-Studio f√ºr Java ist auf dem Vormarsch.</a>  <a href="https://www.viva64.com/en/b/0621/">N√§chste Station ist Elasticsearch</a> <br><br>  <a href="https://www.viva64.com/en/w/v6007/">V6007</a> Ausdruck '(int) x &lt;0' ist immer falsch.  BCrypt.java (429) <br><br>  <a href="https://www.viva64.com/en/w/v6025/">V6025</a> M√∂glicherweise liegt der Index '(int) x' au√üerhalb des <a href="https://www.viva64.com/en/w/v6025/">zul√§ssigen Bereichs</a> .  BCrypt.java (431) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">char64</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)x &gt; index_64.length) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> index_64[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)x]; }</code> </pre> <br>  Rabatt!  Eine Methode - zwei Bugs!  Das erste hat mit dem <i>char-</i> Typ zu tun: Da er in Java nicht signiert ist, ist die <i>(int) x &lt;0-</i> Bedingung immer falsch.  Der zweite Fehler ist die gew√∂hnliche Indizierung au√üerhalb der Grenzen des Arrays <i>index_64,</i> wenn <i>(int) x == index_64.length ist</i> .  Dies geschieht aufgrund der Bedingung <i>(int) x&gt; index_64.length</i> .  Der Fehler kann behoben werden, indem der Operator '&gt;' in '&gt; =' <i>ge√§ndert wird</i> : <i>(int) x&gt; = index_64.length</i> . <br><br><h2>  Nr  8: Eine L√∂sung und ihre Auswirkungen </h2><br>  Quelle: <a href="https://www.viva64.com/en/b/0626/">Analyse des Codes der CUBA-Plattform mit PVS-Studio</a> <br><br>  <a href="https://www.viva64.com/en/w/v6007/">V6007</a> Ausdruck 'previousMenuItemFlatIndex&gt; = 0' ist immer wahr.  CubaSideMenuWidget.java (328) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> MenuItemWidget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findNextMenuItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MenuItemWidget currentItem)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;MenuTreeNode&gt; menuTree = buildVisibleTree(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); List&lt;MenuItemWidget&gt; menuItemWidgets = menuTreeToList(menuTree); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> menuItemFlatIndex = menuItemWidgets.indexOf(currentItem); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> previousMenuItemFlatIndex = menuItemFlatIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousMenuItemFlatIndex &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= return menuItemWidgets.get(previousMenuItemFlatIndex); } return null; }</span></span></code> </pre> <br>  Der Autor der <i>findNextMenuItem-</i> Methode wollte den von der <i>indexOf-</i> Methode zur√ºckgegebenen Wert -1 <i>entfernen</i> , wenn die <i>menuItemWidgets-</i> Liste kein <i>currentItem</i> enth√§lt.  Dazu addiert der Programmierer 1 zum Ergebnis von <i>indexOf</i> (der Variable <i>menuItemFlatIndex</i> ) und schreibt den resultierenden Wert in die Variable <i>previousMenuItemFlatIndex</i> , die dann in der Methode verwendet wird.  Das Hinzuf√ºgen von -1 erweist sich als schlechte L√∂sung, da es gleichzeitig zu mehreren Fehlern f√ºhrt: <br><br><ul><li>  Die Anweisung <i>return null</i> wird niemals ausgef√ºhrt, da der Ausdruck <i>previousMenuItemFlatIndex&gt; = 0</i> immer true ist.  Daher gibt die <i>findNextMenuItem-</i> Methode immer aus der <i>if-</i> Anweisung zur√ºck. </li><li>  Eine <i>IndexOutOfBoundsException</i> wird <i>ausgel√∂st</i> , wenn die <i>menuItemWidgets-</i> Liste leer ist, da das Programm versucht, auf das erste Element der leeren Liste zuzugreifen. </li><li>  Eine <i>IndexOutOfBoundsException</i> wird <i>ausgel√∂st</i> , wenn das Argument <i>currentItem</i> das letzte Element der <i>menuItemWidget-</i> Liste ist. </li></ul><br><h2>  Nr  7: Aus nichts eine Datei machen </h2><br>  Quelle: <a href="https://www.viva64.com/en/b/0688/">Huawei Cloud: Heute ist es im PVS-Studio bew√∂lkt</a> <br><br>  <a href="https://www.viva64.com/en/w/v6008/">V6008</a> M√∂gliche Null-Dereferenzierung von 'dataTmpFile'.  CacheManager.java (91) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">putToCache</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PutRecordsRequest putRecordsRequest)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dataTmpFile == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || !dataTmpFile.exists()) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { dataTmpFile.createNewFile(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } catch (IOException e) { LOGGER.error("Failed to create cache tmp file, return.", e); return; } } .... }</span></span></code> </pre> <br>  Beim Schreiben der <i>putToCache-</i> Methode machte der Programmierer einen Tippfehler in der Bedingung <i>dataTmpFile == null ||</i>  <i>! dataTmpFile.exists ()</i> vor dem Erstellen einer neuen Datei <i>dataTmpFile.createNewFile ()</i> : Sie haben den Operator '==' anstelle von '! =' geschrieben.  Dieser Tippfehler f√ºhrt beim Aufrufen der <i>createNewFile-</i> Methode zum <i>Ausl√∂sen</i> einer <i>NullPointerException</i> .  So sieht die Bedingung mit dem korrigierten Tippfehler aus: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dataTmpFile != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || !dataTmpFile.exists())</code> </pre> <br>  Sie k√∂nnten denken: "Nun, okay, wir k√∂nnen uns jetzt entspannen." Noch nicht! <br><br>  Nachdem ein Fehler behoben wurde, tauchte ein weiterer auf.  Beim Aufrufen der Methode <i>dataTmpFile.exists () wird</i> m√∂glicherweise eine <i>NullPointerException</i> ausgel√∂st.  Um dies zu beheben, m√ºssen wir das '||' ersetzen  Operator mit '&amp;&amp;'.  Dies ist die endg√ºltige Version der Bedingung, nach allen Korrekturen: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dataTmpFile != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; !dataTmpFile.exists())</code> </pre> <br><h2>  Nr  6: Ein sehr seltsamer Logikfehler </h2><br>  Quelle: <a href="https://www.viva64.com/en/b/0603/">PVS-Studio f√ºr Java</a> <br><br>  <a href="https://www.viva64.com/en/w/v6007/">V6007</a> [CWE-570] Der Ausdruck "0" .equals (text) "ist immer falsch.  ConvertIntegerToDecimalPredicate.java 46 <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">satisfiedBy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull PsiElement element)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-meta"><span class="hljs-meta">@NonNls</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String text = expression.getText().replaceAll(<span class="hljs-string"><span class="hljs-string">"_"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (text == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || text.length() &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"0"</span></span>.equals(text) || <span class="hljs-string"><span class="hljs-string">"0L"</span></span>.equals(text) || <span class="hljs-string"><span class="hljs-string">"0l"</span></span>.equals(text)) {<span class="hljs-comment"><span class="hljs-comment">// &lt;= return false; } return text.charAt(0) == '0'; }</span></span></code> </pre> <br>  Das Interessante an dieser Methode ist, dass sie einen offensichtlichen logischen Fehler enth√§lt.  Wenn die <i>satisfiedBy-</i> Methode nach der ersten <i>if-</i> Anweisung nicht zur√ºckgegeben wird, bedeutet dies, dass die <i>Textzeichenfolge</i> mindestens zwei Zeichen lang ist.  Dies bedeutet auch, dass die allererste Pr√ºfung von <i>"0" .equals (text)</i> in der n√§chsten <i>if-</i> Anweisung bedeutungslos ist.  Was der Programmierer damit eigentlich gemeint hat, bleibt ein R√§tsel. <br><br><h2>  Nr  5: Was f√ºr eine Wendung! </h2><br>  Quelle: <a href="https://www.viva64.com/en/b/0657/">PVS-Studio besucht Apache Hive</a> <br><br>  <a href="https://www.viva64.com/en/w/v6034/">V6034 Die</a> Verschiebung um den Wert 'bitShiftsInWord - 1' kann mit der Gr√∂√üe des Typs 'bitShiftsInWord - 1' = [-1 ... 30] inkonsistent sein.  UnsignedInt128.java (1791) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shiftRightDestructive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wordShifts, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bitShiftsInWord, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> roundUp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wordShifts == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; bitShiftsInWord == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> (wordShifts &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> (bitShiftsInWord &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> (bitShiftsInWord &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wordShifts &gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>) { zeroClear(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> shiftRestore = <span class="hljs-number"><span class="hljs-number">32</span></span> - bitShiftsInWord; <span class="hljs-comment"><span class="hljs-comment">// check this because "123 &lt;&lt; 32" will be 123. final boolean noRestore = bitShiftsInWord == 0; final int roundCarryNoRestoreMask = 1 &lt;&lt; 31; final int roundCarryMask = (1 &lt;&lt; (bitShiftsInWord - 1)); // &lt;= .... }</span></span></code> </pre> <br>  Mit den Eingabeargumenten <i>wordShifts = 3</i> und <i>bitShiftsInWord = 0</i> wird die Variable <i>roundCarryMask</i> , die das Ergebnis der bitweisen Verschiebung <i>(1 &lt;&lt; (bitShiftsInWord - 1)) speichert</i> , zu einer negativen Zahl.  Der Entwickler hat das wahrscheinlich nicht erwartet. <br><br><h2>  Nr  4: K√∂nnen wir bitte die Ausnahmen sehen? </h2><br>  Quelle: <a href="https://www.viva64.com/en/b/0657/">PVS-Studio besucht Apache Hive</a> <br><br>  <a href="https://www.viva64.com/en/w/v6051/">V6051</a> Die Verwendung der Anweisung 'return' im Block 'finally' kann zum Verlust nicht behandelter Ausnahmen f√ºhren.  ObjectStore.java (9080) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> List&lt;MPartitionColumnStatistics&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMPartitionColumnStatistics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> NoSuchObjectException, MetaException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> committed = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... <span class="hljs-comment"><span class="hljs-comment">/*some actions*/</span></span> committed = commitTransaction(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { LOG.error(<span class="hljs-string"><span class="hljs-string">"Error retrieving statistics via jdo"</span></span>, ex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ex <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> MetaException) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> (MetaException) ex; } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MetaException(ex.getMessage()); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!committed) { rollbackTransaction(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Lists.newArrayList(); } } }</code> </pre> <br>  Die Deklaration der Methode <i>getMPartitionColumnStatistics</i> ist irref√ºhrend, da sie besagt, dass sie eine Ausnahme <i>ausl√∂sen</i> k√∂nnte.  Unabh√§ngig davon, welche Ausnahme im <i>try-</i> Block generiert wird, ist die <i>festgeschriebene</i> Variable immer <i>false</i> , sodass die <i>return-</i> Anweisung im <i>finally-</i> Block einen Wert zur√ºckgibt, w√§hrend alle ausgel√∂sten Ausnahmen verloren gehen und au√üerhalb der Methode nicht verarbeitet werden k√∂nnen.  Daher kann keine der in dieser Methode ausgel√∂sten Ausnahmen sie verlassen. <br><br><h2>  Nr  3: Hokuspokus oder Versuch, eine neue Maske zu bekommen </h2><br>  Quelle: <a href="https://www.viva64.com/en/b/0657/">PVS-Studio besucht Apache Hive</a> <br><br>  <a href="https://www.viva64.com/en/w/v6034/">V6034 Die</a> Verschiebung um den Wert 'j' kann mit der Gr√∂√üe des Typs inkonsistent sein: 'j' = [0 ... 63].  IoTrace.java (272) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logSargResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> stripeIx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] rgsToRead)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, valOffset = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; elements; ++i, valOffset += <span class="hljs-number"><span class="hljs-number">64</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> val = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">64</span></span>; ++j) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ix = valOffset + j; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rgsToRead.length == ix) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!rgsToRead[ix]) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; val = val | (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; j); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } .... } .... }</span></span></code> </pre> <br>  Auch dieser Fehler hat mit einer bitweisen Verschiebung zu tun, aber nicht nur das.  Die Variable <i>j</i> wird als Z√§hler √ºber den Bereich [0 ... 63] in der inneren <i>for-</i> Schleife verwendet.  Dieser Z√§hler nimmt an einer bitweisen Verschiebung <i>1 &lt;&lt; j teil</i> .  Alles scheint in Ordnung zu sein, aber hier kommt das Integer-Literal '1' vom Typ <i>int</i> (ein 32-Bit-Wert) ins Spiel.  Aus diesem Grund beginnt die bitweise Verschiebung, die zuvor zur√ºckgegebenen Werte zur√ºckzugeben, wenn der Wert der Variablen <i>j</i> 31 √ºberschritten hat. Wenn dieses Verhalten nicht dem vom Programmierer gew√ºnschten entspricht, muss der Wert 1 als <i>long dargestellt werden</i> : <i>1L &lt;&lt; j</i> oder <i>(long) 1 &lt;&lt; j</i> . <br><br><h2>  Nr  2: Initialisierungsreihenfolge </h2><br>  Quelle: <a href="https://www.viva64.com/en/b/0688/">Huawei Cloud: Heute ist es im PVS-Studio bew√∂lkt</a> <br><br>  <a href="https://www.viva64.com/en/w/v6050/">V6050 Klasseninitialisierungszyklus</a> ist vorhanden.  Die Initialisierung von 'INSTANCE' erscheint vor der Initialisierung von 'LOG'.  UntrustedSSL.java (32), UntrustedSSL.java (59), UntrustedSSL.java (33) <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UntrustedSSL</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> UntrustedSSL INSTANCE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UntrustedSSL(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger LOG = LoggerFactory.getLogger(UntrustedSSL.class); .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UntrustedSSL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable t) { LOG.error(t.getMessage(), t); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } } }</span></span></code> </pre> <br>  Die Reihenfolge, in der Felder in einer Klasse deklariert werden, macht einen Unterschied, da sie in derselben Reihenfolge initialisiert werden, in der sie deklariert wurden.  Das Vergessen dieser Tatsache f√ºhrt zu schwer fassbaren Fehlern wie den oben genannten. <br><br>  Der Analysator weist darauf hin, dass das statische Feld <i>LOG</i> zum Zeitpunkt der Initialisierung auf den Wert <i>null</i> dereferenziert wird, was dazu f√ºhrt, dass eine Reihe von Ausnahmen <i>ausgel√∂st wird</i> : <i>NullPointerException</i> -&gt; <i>ExceptionInInitializerError</i> . <br><br>  Aber warum hat das statische Feld <i>LOG</i> beim Aufruf des Konstruktors den Wert <i>null</i> ? <br><br>  Der <i>ExceptionInInitializerError</i> ist der Hinweis.  Der Konstruktor initialisiert das statische Feld <i>INSTANCE</i> , das vor dem Feld <i>LOG</i> deklariert ist.  Aus diesem Grund wird das <i>LOG-</i> Feld beim Aufruf des Konstruktors noch nicht initialisiert.  Damit dieser Code ordnungsgem√§√ü funktioniert, muss das <i>LOG-</i> Feld vor dem Aufruf initialisiert werden. <br><br><h2>  Erstens: Kopieren-Einf√ºgen-orientierte Programmierung </h2><br>  Quelle: <a href="https://www.viva64.com/en/b/0697/">Apache Hadoop Code Qualit√§t: Production VS Test</a> <br><br>  <a href="https://www.viva64.com/en/w/v6072/">V6072</a> Es wurden zwei √§hnliche Codefragmente gefunden.  M√∂glicherweise ist dies ein Tippfehler, und die Variable 'localFiles' sollte anstelle von 'localArchives' verwendet werden.  LocalDistributedCacheManager.java (183), LocalDistributedCacheManager.java (178), LocalDistributedCacheManager.java (176), LocalDistributedCacheManager.java (181) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JobConf conf, JobID jobId)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">// Update the configuration object with localized data. if (!localArchives.isEmpty()) { conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils .arrayToString(localArchives.toArray(new String[localArchives // &lt;= .size()]))); } if (!localFiles.isEmpty()) { conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils .arrayToString(localFiles.toArray(new String[localArchives // &lt;= .size()]))); } .... }</span></span></code> </pre> <br>  Der erste Platz in unserer Top-10-Liste geht an das Kopieren und Einf√ºgen bzw. an einen Fehler, der auf die nachl√§ssige Verwendung dieser Technik zur√ºckzuf√ºhren ist.  Die zweite <i>if-</i> Anweisung √§hnelt einer Kopie der ersten, wobei einige der Variablen ge√§ndert wurden: <br><br><ul><li>  <i>localArchives</i> wurde in <i>localFiles</i> ge√§ndert. </li><li>  <i>MRJobConfig.CACHE_LOCALARCHIVES</i> wurde in <i>MRJobConfig.CACHE_LOCALFILES</i> ge√§ndert. </li></ul><br>  Aber der Programmierer hat es geschafft, auch in dieser einfachen Operation einen Fehler zu machen: Die <i>if-</i> Anweisung in der Zeile, auf die der Analysator <i>hinweist</i> , verwendet weiterhin die Variable <i>localArchives</i> anstelle der scheinbar beabsichtigten Variablen <i>localFiles</i> . <br><br><h2>  Fazit </h2><br>  Die Behebung von Fehlern, die in sp√§teren Entwicklungsphasen oder nach der Ver√∂ffentlichung auftreten, erfordert eine Menge Ressourcen.  Mit dem statischen Analysator PVS-Studio k√∂nnen Sie Fehler in der Codierungsphase erkennen, was die Arbeit erheblich vereinfacht und verbilligt.  Viele <a href="https://www.viva64.com/en/customers/">Unternehmen</a> haben bereits das Leben ihrer Entwickler erleichtert, indem sie den Analysator regelm√§√üig einsetzen.  Wenn Sie Ihren Job wirklich genie√üen m√∂chten, probieren Sie <a href="https://www.viva64.com/en/pvs-studio-download/">PVS-Studio aus</a> . <br><br>  Wir werden nicht damit aufh√∂ren und planen, unser Tool weiter zu verbessern und zu verbessern.  Seien Sie gespannt auf neue Diagnosen und Artikel mit noch interessanteren Fehlern im n√§chsten Jahr. <br><br>  Ich sehe dich wie Abenteuer!  Zuerst haben Sie <a href="https://habr.com/en/company/pvs-studio/blog/481174/">2019</a> die <a href="https://habr.com/en/company/pvs-studio/blog/481174/">Top 10 Bugs in C #</a> besiegt, und jetzt haben Sie auch Java gemeistert!  Willkommen auf der n√§chsten Ebene - dem Artikel √ºber die <a href="https://habr.com/en/company/pvs-studio/blog/481188/">besten Fehler in C ++ - Projekten im Jahr 2019</a> . <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/24/2j/ex/242jexzqwnmth1lyfcrr8icxmms.png"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481184/">https://habr.com/ru/post/de481184/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481174/index.html">Die 10 h√§ufigsten Fehler in C # -Projekten im Jahr 2019</a></li>
<li><a href="../de481176/index.html">Kuriere Yandex.Food and Delivery Club brauchen eine Gewerkschaft</a></li>
<li><a href="../de481178/index.html">Top 10 Bugs in C # -Projekten f√ºr 2019</a></li>
<li><a href="../de481180/index.html">M√ºssen Entwickler Vorschl√§ge von Benutzern erhalten?</a></li>
<li><a href="../de481182/index.html">Istio Service Mesh Beitr√§ge Serie</a></li>
<li><a href="../de481186/index.html">Top 10 Bugs in Java-Projekten f√ºr 2019</a></li>
<li><a href="../de481188/index.html">Die 10 h√§ufigsten Fehler in C ++ - Projekten im Jahr 2019</a></li>
<li><a href="../de481190/index.html">Top 10 Bugs in C ++ Projekten f√ºr 2019</a></li>
<li><a href="../de481200/index.html">Sprachsteuerung und VoiceOver: So passen Sie die Anwendung f√ºr Blinde oder Standbilder an</a></li>
<li><a href="../de481202/index.html">Antiquit√§ten: das Prinzip des M√ºllsammelns und die Ergebnisse von 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>