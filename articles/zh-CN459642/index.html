<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤤 ♦️ 👐🏼 在不牺牲效率的情况下安全访问C ++中的注册字段（以CortexM为例） 🚶🏽 🤷 ↩️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="图 取自www.extremetech.com/wp-content/uploads/2016/07/MegaProcessor-Feature.jpg 

 大家身体健康！ 

 在上一篇文章中，我研究了使用具有C ++的CortexM内核的微控制器的寄存器访问问题，并展示了一些问题的简单解决方案...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在不牺牲效率的情况下安全访问C ++中的注册字段（以CortexM为例）</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459642/"><img src="https://habrastorage.org/webt/et/ni/fl/etnifl3hcinjjsqt8skfvv6km5q.png" alt="图片"><br>  <sub>图</sub>  <sub>取自<a href="">www.extremetech.com/wp-content/uploads/2016/07/MegaProcessor-Feature.jpg</a></sub> <br><br> 大家身体健康！ <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在上一篇文章中，</a>我研究了使用具有C ++的CortexM内核的微控制器的寄存器访问问题，并展示了一些问题的简单解决方案。 <br><br> 今天，我想展示一下如何使用从SVD文件生成的C ++类，在不牺牲效率的情况下确保安全访问寄存器及其字段。 <br><br> 您感兴趣的每个人都欢迎加入。 会有很多代码。 <br><a name="habracut"></a><br><h3> 引言 </h3><br> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">C ++硬件寄存器访问Redux</a>文章中，Ken Smith演示了如何安全有效地使用寄存器，甚至以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github.com/kensmith/cppmmio</a>为例进行了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">演示</a> 。 <br> 然后，几个人提出了这个想法，例如， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">尼古拉斯·豪瑟</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Niklas Hauser）进行了精彩的评论，</a>并提出了另外几种安全访问寄存器的方法。 <br><br> 其中一些思想已经在各种库中实现，尤其是在<a href="">modm中</a> 。 永远可以在现实生活中使用所有这些句子。 但是在开发这些库时，外围设备和寄存器的描述才刚刚开始标准化，因此，为了使寄存器描述的主要工作由程序员来完成，已经做了一些事情。 同样，某些解决方案在代码和微控制器资源方面也不有效。 <br><br> 如今，ARM微控制器的每个制造商都以SVD格式提供了所有寄存器的描述。 头文件可以从这些描述中生成；因此，可以创建一个简单的寄存器描述，而不是一个简单的寄存器描述，但是同时创建，可以提高代码的可靠性。 而且，输出文件可以使用任何语言（C，C ++甚至是<a href="">D）都非常好</a> <br><br> 但是，让我们先来了解一下什么是通常安全访问寄存器的原因，以及为什么根本没有必要。 可以通过简单的综合（最有可能的是但很可能的示例）上显示说明： <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      GPIOA //,    AHB1ENR RCC-&gt;APB1ENR |= RCC_AHB1ENR_GPIOAEN ; //    ,      RCC-&gt;AHB1ENR = RCC_AHB1ENR_GPIOAEN; //,  TIM1    APB2 RCC-&gt;APB1ENR |= RCC_APB1ENR_TIM2EN | RCC_APB2ENR_TIM1EN; // - ,        . auto result = GPIOA-&gt;BSRR ; if (result &amp; GPIO_BSRR_BS1) { //do something } //-     .   ... GPIOA-&gt;IDR = GPIO_IDR_ID5 ; }</span></span></code> </pre> <br> 所有这些情况在实践中都是可能的，我肯定从我的学生那里看到了类似的情况。 如果您可以避免犯这样的错误，那将是很好的。 <br><br> 在我看来，当代码看起来很整洁并且不需要注释时，它会更加令人愉悦。 例如，即使您非常了解STM32F411微控制器，也不总是可能了解这段代码中发生的事情： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ uint32 temp = GPIOA-&gt;OSPEEDR ; temp &amp;=~ GPIO_OSPEEDR_OSPEED0_Msk ; temp = (GPIO_OSPEEDR_OSPEED0_0 | GPIO_OSPEEDR_OSPEED0_1) ; GPIOA-&gt;OSPEEDR = temp; }</code> </pre><br> 没有评论在这里不能做。 该代码将GPIOA.0端口的工作频率设置为最大（来自<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">mctMaks的</a>澄清：实际上，此参数会影响前端的上升时间（即其陡峭度），并且意味着该端口可以正常处理给定的数字信号（VeryLow \ Low \ Medium \（高）频率）。 <br><br> 让我们尝试摆脱这些缺点。 <br><br><h3> 注册抽象 </h3><br> 首先，您需要从程序员和程序的角度弄清楚寄存器是什么。 <br><br> 寄存器具有地址，长度或大小，访问方式：某些寄存器可以写入，某些只能读取，而大多数则可以读写。 <br><br> 另外，寄存器可以表示为一组字段。 一个字段可以由一位或几位组成，位于寄存器的任何位置。 <br><br> 因此，以下字段特征对我们很重要：长度或大小（ <b>width</b>或<b>size</b> ），距寄存器开头的<b>偏移量</b> （ <b>offset</b> ）和值。 <br><br> 字段值是字段可以占用的所有可能数量的空间，它取决于字段的长度。 即 如果该字段的长度为2，则有4个可能的字段值（0,1,2,3）。 像寄存器一样，字段和字段值也具有访问模式（读，写，读和写） <br><br> 为了更加清楚，让我们从STM32F411微控制器获取TIM1 CR1寄存器。 从示意图上看，它看起来像这样： <br><br><img src="https://habrastorage.org/webt/sr/da/i4/srdai4a4hmphkmhrulcvdcx9r3u.png" alt="图片"><br><br><ul><li>  Bit 0 CEN：启用计数器 <br>  0：计数器使能： <b>禁用</b> <br>  1：计数器关闭： <b>启用</b> <br></li><li>  UDIS位1：启用/禁用UEV事件 <br>  0：启用UEV事件： <b>启用</b> <br>  1：UEV事件关闭： <b>禁用</b> <br></li><li>  URS位2：选择UEV事件生成源 <br>  0：溢出或设置UG时生成UEV： <b>任意</b>位 <br>  1：仅在溢出时生成UEV： <b>溢出</b> <br></li><li>  Bit 3 OPM：一次性操作 <br>  0：在UEV： <b>ContinueAfterUEV</b>事件之后，计时器继续计数 <br>  1：在UEV： <b>StopAfterUEV事件</b>后计时器停止 <br></li><li>  Bit 4 DIR：计数方向 <br>  0：直接帐户： <b>递增</b>帐户 <br>  1： <b>倒数</b> ： <b>倒数</b> <br></li><li> 位6：5 CMS：对齐模式 <br>  0：对齐模式0： <b>CenterAlignedMode0</b> <br>  1：对齐模式1： <b>CenterAlignedMode1</b> <br>  2：对齐方式2： <b>CenterAlignedMode2</b> <br>  3：对齐模式3： <b>CenterAlignedMode3</b> <br></li><li>  Bit 7 APRE：ARR寄存器的预加载模式 <br>  0：TIMx_ARR寄存器未缓冲： <b>ARRNotBuffered</b> <br>  1：TIMx_ARR寄存器未缓冲： <b>ARRBuffered</b> <br></li><li> 位8：9 CKD：时钟分频器 <br>  0：tDTS = tCK_INT： <b>ClockDevidedBy1</b> <br>  1：tDTS = 2 * tCK_INT： <b>ClockDevidedBy2</b> <br>  2：tDTS = 4 * tCK_INT： <b>ClockDevidedBy4</b> <br>  3：保留： <b>保留</b> <br></li></ul><br> 例如，此处的CEN是一个1位字段，相对于寄存器的开头偏移为0。  <b>启用</b> （1）和<b>禁用</b> （0）是其可能的值。 <br><br> 我们不会专注于该寄存器的每个字段专门负责什么，对于我们来说重要的是，每个字段和字段值都有一个名称，该名称带有语义负载，并且从中我们可以从原则上理解它的作用。 <br><br> 我们必须同时访问寄存器和字段及其值。 因此，以非常近似的形式，寄存器抽象可以由以下类表示： <br><br><img src="https://habrastorage.org/webt/pi/kr/-s/pikr-sq7lnpo9c6uilrmghdzd5a.png" alt="图片"><br><br> 除了类之外，对我们来说也很重要的是，寄存器和各个字段都具有某些属性，寄存器具有地址，大小，访问方式（只读，只写或两者兼有）。 <br> 该字段具有大小，偏移量以及访问模式。 另外，该字段应包含指向其所属寄存器的链接。 <br><br> 字段值必须具有到该字段的链接和一个附加属性-值。 <br><br> 因此，在更详细的版本中，我们的抽象将如下所示： <br><br><img src="https://habrastorage.org/webt/m4/3u/mb/m43umbc8vceiuila8_komovib38.png"><br><br> 除了属性之外，我们的抽象还应该具有修改和访问方法。 为简单起见，我们只限于安装/编写和阅读方法。 <br><br><img src="https://habrastorage.org/webt/uy/d7/sb/uyd7sb-z-tggllnj4knjf_rfhi4.png" alt="图片"><br><br> 当我们决定大小写抽象时，我们需要检查这种抽象如何对应于SVD文件中描述的内容。 <br><br><h3> 系统视图描述（SVD）文件 </h3><br>  CMSIS系统表示描述格式（CMSIS-SVD）是基于ARM Cortex-M处理器的微控制器寄存器的正式描述。 系统表示形式的描述中包含的信息实际上与设备参考手册中的数据相对应。 在这种文件中对寄存器的描述既可以包含高级信息，也可以包含寄存器中字段的单个位的用途。 <br><br> 在示意图上，可以通过以下方案（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">位于Keil网站上）</a>来描述此类文件中信息的详细程度： <br><br><img src="https://habrastorage.org/webt/1s/oq/6d/1soq6disxizzaj8hvyaovxs9_pm.png" alt="图片"><br><br> 说明SVD文件由制造商提供，并在调试期间用于显示有关微控制器和寄存器的信息。 例如，IAR使用它们在“视图”-&gt;“注册”面板中显示信息。 文件本身位于文件夹Program Files（x86）\ IAR Systems \ Embedded Workbench 8.3 \ arm \ config \ debugger中。 <br><br>  JetBrains的Clion还在调试期间使用svd文件显示寄存器信息。 <br><br> 您始终可以从制造商的网站下载说明。  <a href="">在这里您可以获取STM32F411微控制器的SVD文件</a> <br><br> 通常，SVD格式是制造商支持的标准。 让我们看看SVD中的描述级别是什么。 <br><br> 总共区分出5个级别：设备级别，微控制器级别，寄存器级别，字段级别，枚举值级别。 <br><br><ul><li>  <b>设备级别</b> ：系统视图的顶级描述是设备。 在此级别上，将描述与整个设备有关的属性。 例如，设备名称，描述或版本。 最小可寻址单元以及数据总线的位深度。 可以在此级别为整个设备设置寄存器属性的默认值，例如寄存器大小，重置值和访问权限，并由较低级别的描述隐式继承。 </li><li>  <b>微控制器级别：</b> CPU部分描述了微控制器的内核及其功能。 如果使用SVD文件创建设备头文件，则此部分是必需的。 </li><li>  <b>外围层</b> ：外围设备是寄存器的命名集合。 外围设备被映射到设备地址空间中的特定基址。 </li><li>  <b>寄存器级别</b> ：寄存器是属于外围设备的命名可编程资源。 寄存器被映射到设备地址空间中的特定地址。 该地址是相对于基本外围设备地址的。 另外，对于寄存器，指示访问模式（读/写）。 </li><li>  <b>字段级别</b> ：如上所述，寄存器可以分为不同功能的位-字段。 此级别包含同一寄存器内唯一的字段名称，它们的大小，相对于寄存器开头的偏移量以及访问模式。 </li><li>  <b>枚举字段值的级别</b> ：实际上，它们是命名字段值，可在C，C ++，D等中使用，以方便使用。 </li></ul><br> 实际上，SVD文件是带有系统完整描述的普通xml文件。 例如， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>有svd文件转换器到C代码，可为每个外围设备和寄存器生成C友好的头文件和结构。 <br><br> 还有一个用Phyton编写的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">cmsis-svd</a> SVD文件解析器，它的作用类似于将文件中的数据反序列化为Phython类对象，然后可以方便地在代码生成程序中使用。 <br><br> 可以在扰流板下面查看STM32F411微控制器的寄存器描述示例： <br><br><div class="spoiler">  <b class="spoiler_title">寄存器CR1定时器TIM1的示例</b> <div class="spoiler_text"><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">peripheral</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span>TIM1<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">description</span></span></span><span class="hljs-tag">&gt;</span></span>Advanced-timers<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">description</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupName</span></span></span><span class="hljs-tag">&gt;</span></span>TIM<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupName</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">baseAddress</span></span></span><span class="hljs-tag">&gt;</span></span>0x40010000<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">baseAddress</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">addressBlock</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">offset</span></span></span><span class="hljs-tag">&gt;</span></span>0x0<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">offset</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">size</span></span></span><span class="hljs-tag">&gt;</span></span>0x400<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">size</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">usage</span></span></span><span class="hljs-tag">&gt;</span></span>registers<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">usage</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">addressBlock</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">registers</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">register</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span>CR1<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">displayName</span></span></span><span class="hljs-tag">&gt;</span></span>CR1<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">displayName</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">description</span></span></span><span class="hljs-tag">&gt;</span></span>control register 1<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">description</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">addressOffset</span></span></span><span class="hljs-tag">&gt;</span></span>0x0<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">addressOffset</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">size</span></span></span><span class="hljs-tag">&gt;</span></span>0x20<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">size</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">access</span></span></span><span class="hljs-tag">&gt;</span></span>read-write<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">access</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">resetValue</span></span></span><span class="hljs-tag">&gt;</span></span>0x0000<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">resetValue</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">fields</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">field</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span>CKD<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">description</span></span></span><span class="hljs-tag">&gt;</span></span>Clock division<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">description</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bitOffset</span></span></span><span class="hljs-tag">&gt;</span></span>8<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bitOffset</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bitWidth</span></span></span><span class="hljs-tag">&gt;</span></span>2<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bitWidth</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">field</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">field</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span>ARPE<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">description</span></span></span><span class="hljs-tag">&gt;</span></span>Auto-reload preload enable<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">description</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bitOffset</span></span></span><span class="hljs-tag">&gt;</span></span>7<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bitOffset</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bitWidth</span></span></span><span class="hljs-tag">&gt;</span></span>1<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bitWidth</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">field</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">field</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span>CMS<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">description</span></span></span><span class="hljs-tag">&gt;</span></span>Center-aligned mode selection<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">description</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bitOffset</span></span></span><span class="hljs-tag">&gt;</span></span>5<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bitOffset</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bitWidth</span></span></span><span class="hljs-tag">&gt;</span></span>2<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bitWidth</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">field</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">field</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span>DIR<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">description</span></span></span><span class="hljs-tag">&gt;</span></span>Direction<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">description</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bitOffset</span></span></span><span class="hljs-tag">&gt;</span></span>4<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bitOffset</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bitWidth</span></span></span><span class="hljs-tag">&gt;</span></span>1<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bitWidth</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">field</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">field</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span>OPM<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">description</span></span></span><span class="hljs-tag">&gt;</span></span>One-pulse mode<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">description</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bitOffset</span></span></span><span class="hljs-tag">&gt;</span></span>3<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bitOffset</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bitWidth</span></span></span><span class="hljs-tag">&gt;</span></span>1<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bitWidth</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">field</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">field</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span>URS<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">description</span></span></span><span class="hljs-tag">&gt;</span></span>Update request source<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">description</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bitOffset</span></span></span><span class="hljs-tag">&gt;</span></span>2<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bitOffset</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bitWidth</span></span></span><span class="hljs-tag">&gt;</span></span>1<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bitWidth</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">field</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">field</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span>UDIS<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">description</span></span></span><span class="hljs-tag">&gt;</span></span>Update disable<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">description</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bitOffset</span></span></span><span class="hljs-tag">&gt;</span></span>1<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bitOffset</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bitWidth</span></span></span><span class="hljs-tag">&gt;</span></span>1<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bitWidth</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">field</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">field</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span>CEN<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">description</span></span></span><span class="hljs-tag">&gt;</span></span>Counter enable<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">description</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bitOffset</span></span></span><span class="hljs-tag">&gt;</span></span>0<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bitOffset</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bitWidth</span></span></span><span class="hljs-tag">&gt;</span></span>1<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bitWidth</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">field</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">fields</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">register</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">register</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br></div></div><br> 如您所见，除了字段的特定位的值的描述之外，还有所有抽象所需的信息。 <br><br> 并非所有制造商都希望花时间对他们的系统进行完整的描述，因此，正如您所看到的，ST不想描述字段值并将此负担转移给客户程序员。 但是TI会照顾客户，并完整描述系统，包括字段值的描述。 <br><br> 上面显示了SVD描述的格式与我们的案例抽象非常一致。 该文件包含所有必要的信息，以完整描述寄存器。 <br><br><h3> 实作 </h3><br><h4> 报名 </h4><br> 现在，我们已经对寄存器进行了抽象，并且以制造商的svd形式对寄存器进行了描述，该描述非常适合这种抽象，我们可以直接进行实现。 <br><br> 我们的实现应与C代码一样有效且用户友好。 我希望对寄存器的访问看起来尽可能清晰，例如： <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TIM1::CR1::CKD::DividedBy2::IsSet()) { TIM1::ARR::Set(<span class="hljs-number"><span class="hljs-number">10</span></span>_ms) ; TIM1::CR1::CEN::Enable::Set() ; }</code> </pre><br> 回想一下，为了访问整数寄存器地址，您需要使用reinterpret_cast： <br><br><pre> <code class="cpp hljs">*<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *&gt;(<span class="hljs-number"><span class="hljs-number">0x40010000</span></span>) = (<span class="hljs-number"><span class="hljs-number">1U</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5U</span></span>) ;</code> </pre> <br> 上面已经描述了寄存器类，它必须具有地址，大小和访问方式，以及两个<code>Get()</code>和<code>Set()</code>方法： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      template&lt;uint32_t address, size_t size, typename AccessMode&gt; struct RegisterBase { static constexpr auto Addr = address ; using Type = typename RegisterType&lt;size&gt;::Type ; // Set     , //     __forceinline template&lt;typename T = AccessMode, class = typename std::enable_if_t&lt;std::is_base_of&lt;WriteMode, T&gt;::value&gt;&gt; inline static void Set(Type value) { *reinterpret_cast&lt;volatile Type *&gt;(address) = value ; } // Get    , //    ,    __forceinline template&lt;typename T = AccessMode, class = typename std::enable_if_t&lt;std::is_base_of&lt;ReadMode, T&gt;::value&gt;&gt; inline static Type Get() { return *reinterpret_cast&lt;volatile Type *&gt;(address) ; } } ;</span></span></code> </pre> <br> 我们将地址，寄存器长度和访问模式传递给模板参数（这也是一个类）。 使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SFINAE</a>机制，即<code>enable_if</code>元函数，我们将为不支持它们的寄存器“抛出” <code>Set()</code>或<code>Get()</code>访问函数。 例如，如果寄存器是只读的，那么我们将把<code>ReadMode</code>类型<code>ReadMode</code>给模板参数， <code>enable_if</code>将检查access是否是<code>ReadMode</code>的后继<code>ReadMode</code> ，如果不是，它将创建一个受控错误（类型T无法显示），并且编译器将不包括<code>Set()</code>方法。 <code>Set()</code>这样的寄存器。 仅用于写入的寄存器也是如此。 <br><br> 对于访问控制，我们将使用以下类： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    struct WriteMode {}; struct ReadMode {}; struct ReadWriteMode: public WriteMode, public ReadMode {};</span></span></code> </pre> <br> 寄存器的大小不同：8、16、32、64位，我们分别设置类型： <br><br><div class="spoiler">  <b class="spoiler_title">寄存器类型取决于大小</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> size&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegisterType</span></span></span><span class="hljs-class"> {</span></span>} ; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegisterType</span></span></span><span class="hljs-class">&lt;8&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Type = <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> ; } ; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegisterType</span></span></span><span class="hljs-class">&lt;16&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Type = <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> ; } ; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegisterType</span></span></span><span class="hljs-class">&lt;32&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Type = <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ; } ; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegisterType</span></span></span><span class="hljs-class">&lt;64&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Type = <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> ; } ;</code> </pre> <br></div></div><br> 之后，对于TIM1计时器，您可以通过以下方式定义CR1寄存器和例如EGR寄存器： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TIM1</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CR1</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RegisterBase&lt;<span class="hljs-number"><span class="hljs-number">0x40010000</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>, ReadWriteMode&gt; { } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EGR</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RegisterBase&lt;<span class="hljs-number"><span class="hljs-number">0x40010014</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>, WriteMode&gt; { } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ TIM1::CR1::Set(<span class="hljs-number"><span class="hljs-number">10</span></span>) ; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> reg = TIM1::CR1::Get() ; <span class="hljs-comment"><span class="hljs-comment">// ,     reg = TIM1::EGR::Get() }</span></span></code> </pre><br> 由于编译器仅针对从<code>ReadMode</code>继承访问模式的寄存器显示<code>Get()</code>方法，而对于从<code>ReadMode</code>继承访问模式的寄存器显示<code>Set()</code>方法，如果错误使用访问方法，则在编译阶段会收到错误消息。 而且，如果您使用现代开发工具（例如Clion），那么即使在编码阶段，您也会在代码分析器中看到警告： <br><br><img src="https://habrastorage.org/webt/vc/we/gu/vcwegu6a0vulgfcvzjkaum9ac4a.png" alt="图片"><br><br> 好了，现在访问寄存器变得更加安全，我们的代码不允许您执行该寄存器不可接受的操作，但是我们想走得更远，而不是引用整个寄存器，而是引用其字段。 <br><br><h4> 领域 </h4><br> 该字段而不是地址具有相对于寄存器开头的移位值。 另外，为了知道字段值必须带到的地址或类型，它必须具有指向寄存器的链接： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//        template&lt;typename Reg, size_t offset, size_t size, typename AccessMode&gt; struct RegisterField { using RegType = typename Reg::Type ; using Register = Reg ; static constexpr RegType Offset = offset ; static constexpr RegType Size = size ; using Access = AccessMode ; template&lt;typename T = AccessMode, class = typename std::enable_if_t&lt;std::is_base_of&lt;WriteMode, T&gt;::value&gt;&gt; static void Set(RegType value) { assert(value &lt; (1U &lt;&lt; size)) ; //CriticalSection cs ; //    RegType newRegValue = *reinterpret_cast&lt;RegType *&gt;(Register::Address) ; //       newRegValue &amp;= ~ (((1U &lt;&lt; size) - 1U) &lt;&lt; offset); //    newRegValue |= (value &lt;&lt; offset) ; //      *reinterpret_cast&lt;RegType *&gt;(Reg::Address) = newRegValue ; } __forceinline template&lt;typename T = AccessMode, class = typename std::enable_if_t&lt;std::is_base_of&lt;ReadMode, T&gt;::value&gt;&gt; inline static RegType Get() { return ((*reinterpret_cast&lt;RegType *&gt;(Reg::Address)) &amp; (((1U &lt;&lt; size) - 1U) &lt;&lt; offset)) &gt;&gt; offset ; } };</span></span></code> </pre> <br> 之后，已经可以执行以下操作： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TIM1</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CR1</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RegisterBase&lt;<span class="hljs-number"><span class="hljs-number">0x40010000</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>, ReadWriteMode&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> CKD = RegisterField&lt;TIM1::CR1, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, ReadWriteMode&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ARPE = RegisterField&lt;TIM1::CR1, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, ReadWriteMode&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> CMS = RegisterField&lt;TIM1::CR1, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, ReadWriteMode&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> DIR = RegisterField&lt;TIM1::CR1, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, ReadWriteMode&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> OPM = RegisterField&lt;TIM1::CR1, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, ReadWriteMode&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> URS = RegisterField&lt;TIM1::CR1, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, ReadWriteMode&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UDIS = RegisterField&lt;TIM1::CR1, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, ReadWriteMode&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> CEN = RegisterField&lt;TIM1::CR1, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, ReadWriteMode&gt; ; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   CR1  9   1,  8  0 TIM1::CR1::CKD::Set(2U) ; auto reg = TIM1::CR1::CEN::Get() ; }</span></span></code> </pre><br> 尽管总体上看起来一切都不错，但仍不清楚<code>TIM1::CR1::CKD::Set(2)</code>含义是什么，传递给<code>Set()</code>函数的魔术二是什么意思？  <code>TIM1::CR1::CEN::Get()</code>方法返回的数字<code>TIM1::CR1::CEN::Get()</code>什么<code>TIM1::CR1::CEN::Get()</code> ？ <br><br> 无缝移动到字段值。 <br><br><h4> 栏位值 </h4><br> 字段值的抽象本质上也是一个字段，但是只能接受一个状态。 将属性添加到字段抽象中-实际值和到该字段的链接。 设置字段值的<code>Set()</code>方法与设置字段的<code>Set()</code>方法相同，不同之处在于，不需要将值本身传递给该方法，这是预先已知的，只需要对其进行设置即可。 但是<code>Get()</code>方法没有任何意义；相反，最好检查是否设置了此值，用<code>IsSet()</code>方法替换此方法。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//        template&lt;typename Field, typename Field::Register::Type value&gt; struct FieldValueBase { using RegType = typename Field::Register::Type ; template&lt;typename T = typename Field::Access, class = typename std::enable_if_t&lt;std::is_base_of&lt;WriteMode, T&gt;::value&gt;&gt; static void Set() { RegType newRegValue = *reinterpret_cast&lt;RegType *&gt;(Field::Register::Address) ; newRegValue &amp;= ~ (((1U &lt;&lt; Field::Size) - 1U) &lt;&lt; Field::Offset); newRegValue |= (value &lt;&lt; Field::Offset) ; *reinterpret_cast&lt;RegType *&gt;(Field::Register::Address) = newRegValue ; } __forceinline template&lt;typename T = typename Field::Access, class = typename std::enable_if_t&lt;std::is_base_of&lt;ReadMode, T&gt;::value&gt;&gt; inline static bool IsSet() { return ((*reinterpret_cast&lt;RegType *&gt;(Field::Register::Address)) &amp; static_cast&lt;RegType&gt;(((1U &lt;&lt; Field::Size) - 1U) &lt;&lt; Field::Offset)) == (value &lt;&lt; Field::Offset) ; } };</span></span></code> </pre> <br> 现在可以通过一组值来描述register字段： <br><br><div class="spoiler">  <b class="spoiler_title">定时器TIM1的CR1寄存器字段的值</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Reg, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> offset, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> AccessMode&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TIM_CR_CKD_Values</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RegisterField&lt;Reg, offset, size, AccessMode&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> DividedBy1 = FieldValue&lt;TIM_CR_CKD_Values, <span class="hljs-number"><span class="hljs-number">0U</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> DividedBy2 = FieldValue&lt;TIM_CR_CKD_Values, <span class="hljs-number"><span class="hljs-number">1U</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> DividedBy4 = FieldValue&lt;TIM_CR_CKD_Values, <span class="hljs-number"><span class="hljs-number">2U</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Reserved = FieldValue&lt;TIM_CR_CKD_Values, <span class="hljs-number"><span class="hljs-number">3U</span></span>&gt; ; } ; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Reg, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> offset, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> AccessMode&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TIM_CR_ARPE_Values</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RegisterField&lt;Reg, offset, size, AccessMode&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ARRNotBuffered = FieldValue&lt;TIM_CR_ARPE_Values, <span class="hljs-number"><span class="hljs-number">0U</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ARRBuffered = FieldValue&lt;TIM_CR_ARPE_Values, <span class="hljs-number"><span class="hljs-number">1U</span></span>&gt; ; } ; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Reg, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> offset, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> AccessMode&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TIM_CR_CMS_Values</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RegisterField&lt;Reg, offset, size, AccessMode&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> CenterAlignedMode0 = FieldValue&lt;TIM_CR_CMS_Values, <span class="hljs-number"><span class="hljs-number">0U</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> CenterAlignedMode1 = FieldValue&lt;TIM_CR_CMS_Values, <span class="hljs-number"><span class="hljs-number">1U</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> CenterAlignedMode2 = FieldValue&lt;TIM_CR_CMS_Values, <span class="hljs-number"><span class="hljs-number">2U</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> CenterAlignedMode3 = FieldValue&lt;TIM_CR_CMS_Values, <span class="hljs-number"><span class="hljs-number">3U</span></span>&gt; ; } ; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Reg, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> offset, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> AccessMode&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TIM_CR_DIR_Values</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RegisterField&lt;Reg, offset, size, AccessMode&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Upcounter = FieldValue&lt;TIM_CR_DIR_Values, <span class="hljs-number"><span class="hljs-number">0U</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Downcounter = FieldValue&lt;TIM_CR_DIR_Values, <span class="hljs-number"><span class="hljs-number">1U</span></span>&gt; ; } ; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Reg, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> offset, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> AccessMode&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TIM_CR_OPM_Values</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RegisterField&lt;Reg, offset, size, AccessMode&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ContinueAfterUEV = FieldValue&lt;TIM_CR_OPM_Values, <span class="hljs-number"><span class="hljs-number">0U</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> StopAfterUEV = FieldValue&lt;TIM_CR_OPM_Values, <span class="hljs-number"><span class="hljs-number">1U</span></span>&gt; ; } ; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Reg, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> offset, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> AccessMode&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TIM_CR_URS_Values</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RegisterField&lt;Reg, offset, size, AccessMode&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Any = FieldValue&lt;TIM_CR_URS_Values, <span class="hljs-number"><span class="hljs-number">0U</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Overflow = FieldValue&lt;TIM_CR_URS_Values, <span class="hljs-number"><span class="hljs-number">1U</span></span>&gt; ; } ; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Reg, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> offset, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> AccessMode&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TIM_CR_UDIS_Values</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RegisterField&lt;Reg, offset, size, AccessMode&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Enable = FieldValue&lt;TIM_CR_UDIS_Values, <span class="hljs-number"><span class="hljs-number">0U</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Disable = FieldValue&lt;TIM_CR_UDIS_Values, <span class="hljs-number"><span class="hljs-number">1U</span></span>&gt; ; } ; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Reg, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> offset, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> AccessMode&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TIM_CR_CEN_Values</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RegisterField&lt;Reg, offset, size, AccessMode&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Disable = FieldValue&lt;TIM_CR_CEN_Values, <span class="hljs-number"><span class="hljs-number">0U</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Enable = FieldValue&lt;TIM_CR_CEN_Values, <span class="hljs-number"><span class="hljs-number">1U</span></span>&gt; ; } ;</code> </pre><br></div></div><br> 然后，CR1寄存器本身将被描述如下： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TIM1</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CR1</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RegisterBase&lt;<span class="hljs-number"><span class="hljs-number">0x40010000</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>, ReadWriteMode&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> CKD = TIM_CR1_CKD_Values&lt;TIM1::CR1, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, ReadWriteMode&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ARPE = TIM_CR1_ARPE_Values&lt;TIM1::CR1, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, ReadWriteMode&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> CMS = TIM_CR1_CMS_Values&lt;TIM1::CR1, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, ReadWriteMode&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> DIR = TIM_CR1_DIR_Values&lt;TIM1::CR1, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, ReadWriteMode&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> OPM = TIM_CR1_OPM_Values&lt;TIM1::CR1, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, ReadWriteMode&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> URS = TIM_CR1_URS_Values&lt;TIM1::CR1, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, ReadWriteMode&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UDIS = TIM_CR1_UDIS_Values&lt;TIM1::CR1, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, ReadWriteMode&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> CEN = TIM_CR1_CEN_Values&lt;TIM1::CR1, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, ReadWriteMode&gt; ; } ; }</code> </pre><br> 现在，您可以设置并直接读取寄存器字段的值：例如，如果要在帐户上启用计时器，只需对计时器TIM1的寄存器CR1的CEN字段的<code>Enable</code>值调用<code>Set()</code>方法： <code>TIM1::CR1::CEN::Enable::Set() ;</code>  。 在代码中，它将如下所示： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TIM1::CR1::CKD::DividedBy2::IsSet()) { TIM1::ARR::Set(<span class="hljs-number"><span class="hljs-number">100U</span></span>) ; TIM1::CR1::CEN::Enable::Set() ; } }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">为了进行比较，使用C头文件是相同的：</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((TIM1-&gt;CR1 &amp; TIM_CR1_CKD_Msk) == TIM_CR1_CKD_0) { TIM1-&gt;ARR = <span class="hljs-number"><span class="hljs-number">100U</span></span> ; regValue = TIM1-&gt;CR1 ; regValue &amp;=~(TIM_CR1_CEN_Msk) ; regValue |= TIM_CR1_CEN ; TIM1-&gt;CR1 = regValue ; } }</code> </pre><br></div></div><br> 因此，进行了主要改进，我们可以对寄存器及其字段和值进行简单且可理解的访问。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">访问在编译级别进行控制，并且如果寄存器，字段或值不允许进行写入或读取，则即使在将代码闪存到微控制器之前，也将清除该访问权限。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，仍然有一个缺点，不可能同时将多个字段值放入寄存器中。</font><font style="vertical-align: inherit;">想象一下您需要执行以下操作：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> regValue = TIM1-&gt;CR1 ; regValue &amp;=~(TIM_CR1_CKD_Msk | TIM_CR1_DIR) ; regValue |= (TIM_CR1_CEN | TIM_CR1_CKD_0 | TIM_CR1_CKD_0) ; TIM1-&gt;CR1 = regValue ; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为此，我们需要在寄存器</font></font><code>Set(...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中创建一个具有可变数量参数的方法，或者尝试指定需要在模板中设置的字段的值。</font></font>即<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 实现以下选项之一： </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// 1,      Set() TIM1::CR1::Set(TIM1::CR1::DIR::Upcounter, TIM1::CR1::CKD::DividedBy4, TIM1::CR1::CEN::Enable) ; // 2,     TIM1::CR1&lt;TIM1::CR1::DIR::Upcounter, TIM1::CR1::CKD::DividedBy4, TIM1::CR1::CEN::Enable&gt;::Set() ; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于具有可变参数个数的选项不会总是由编译器优化，并且实际上所有参数都将通过寄存器和堆栈传输，这可能会影响RAM的速度和开销，因此我选择了第二种方法，即在该阶段进行要设置的位掩码的计算编译。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将使用带有可变数量参数的模板。</font><font style="vertical-align: inherit;">值列表作为类型列表传递：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,          template&lt;uint32_t address, size_t size, typename AccessMode, typename ...Args&gt; class Register { private: ...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 为了在寄存器中设置所需的值，我们需要： </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 从整个值集中形成一个掩码，以重置寄存器中的所需位。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 从整个值集中，生成一个值以设置所需的位。 </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 这些应该是constexpr方法，这些方法将在编译阶段执行所有必要的操作： </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,          template&lt;uint32_t address, size_t size, typename AccessMode, typename ...Args&gt; class Register { private: // ,    //     . __forceinline template&lt;typename T&gt; static constexpr auto GetIndividualMask() { Type result = T::Mask &lt;&lt; T::Offset ; return result ; } // ,    //       . static constexpr auto GetMask() { //       const auto values = {GetIndividualMask&lt;Args&gt;()...} ; Type result = 0UL; for (auto const v: values) { //       result |= v ; } return result ; } //    __forceinline template&lt;typename T&gt; static constexpr auto GetIndividualValue() { Type result = T::Value &lt;&lt; T::Offset ; return result ; } static constexpr auto GetValue() { const auto values = {GetIndividualValue&lt;Args&gt;()...}; Type result = 0UL; for (const auto v: values) { result |= v ; } return result ; } };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅定义公共方法</font></font><code>Set()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>IsSet()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,          template&lt;uint32_t address, size_t size, typename AccessMode, typename ...Args&gt; class Register { public: using Type = typename RegisterType&lt;size&gt;::Type; template&lt;typename T = AccessMode, class = typename std::enable_if_t&lt;std::is_base_of&lt;WriteMode, T&gt;::value&gt;&gt; static void Set() { Type newRegValue = *reinterpret_cast&lt;Type *&gt;(address) ; //GetMask()    ,     newRegValue &amp;= ~GetMask() ; //GetValue()    ,     newRegValue |= GetValue() ; //     *reinterpret_cast&lt;Type *&gt;(address) = newRegValue ; } template&lt;typename T = AccessMode, class = typename std::enable_if_t&lt;std::is_base_of&lt;ReadMode, T&gt;::value&gt;&gt; static bool IsSet() { Type newRegValue = *reinterpret_cast&lt;Type *&gt;(address) ; return ((newRegValue &amp; GetMask()) == GetValue()) ; } private: ...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 几乎所有事情，还有一个小问题，我们可以做到这样的愚蠢： </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ,     TIM1::CR1 TIM1::CR1&lt;TIM2::CR1::Enabled, TIM1::CR2::OIS1::OC1OutputIs0&gt;::Set() ; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显然，您需要以某种方式检查我们的值集是否区分大小写，做到这一点非常简单，只需在template参数中添加一个附加类型，我们称之为</font></font><code>FieldValueBaseType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">现在，该寄存器和可以在该寄存器中设置的字段的值应为同一</font></font><code>FieldValueBaseType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型：</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">向该寄存器添加对字段值所有权的检查</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> address, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> AccessMode, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> FieldValueBaseType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Args&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Register</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">//     BaseType     FieldValueBaseType,    . __forceinline template&lt;typename T, class = typename std::enable_if_t&lt;std::is_same&lt;FieldValueBaseType, typename T::BaseType&gt;::value&gt;&gt; static constexpr auto GetIndividualMask() { Type result = T::Mask &lt;&lt; T::Offset ; return result ; } static constexpr auto GetMask() { const auto values = {GetIndividualMask&lt;Args&gt;()...} ; Type result = 0UL; for (auto const v: values) { result |= v ; } return result ; } //     BaseType     FieldValueBaseType,    . __forceinline template&lt;typename T, class = typename std::enable_if_t&lt;std::is_same&lt;FieldValueBaseType, typename T::BaseType&gt;::value&gt;&gt; static constexpr auto GetIndividualValue() { Type result = T::Value &lt;&lt; T::Offset ; return result ; } static constexpr auto GetValue() { const auto values = {GetIndividualValue&lt;Args&gt;()...}; Type result = 0UL; for (const auto v: values) { result |= v ; } return result ; } };</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设置多个字段值时，SFINAE机制将再次检查此值是否与寄存器字段允许的类型相同，如果是，则由编译器显示该方法，否则，编译时会出现错误。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TIM1的CR1寄存器的完整描述如下所示：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TIM1</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TIM1CR1Base</span></span></span><span class="hljs-class"> {</span></span>} ; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CR1</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RegisterBase&lt;<span class="hljs-number"><span class="hljs-number">0x40010000</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>, ReadWriteMode&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> CKD = TIM_CR_CKD_Values&lt;TIM1::CR1, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, ReadWriteMode, TIM1CR1Base&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ARPE = TIM_CR_ARPE_Values&lt;TIM1::CR1, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, ReadWriteMode, TIM1CR1Base&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> CMS = TIM_CR_CMS_Values&lt;TIM1::CR1, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, ReadWriteMode, TIM1CR1Base&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> DIR = TIM_CR_DIR_Values&lt;TIM1::CR1, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, ReadWriteMode, TIM1CR1Base&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> OPM = TIM_CR_OPM_Values&lt;TIM1::CR1, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, ReadWriteMode, TIM1CR1Base&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> URS = TIM_CR_URS_Values&lt;TIM1::CR1, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, ReadWriteMode, TIM1CR1Base&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UDIS = TIM_CR_UDIS_Values&lt;TIM1::CR1, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, ReadWriteMode, TIM1CR1Base&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> CEN = TIM_CR_CEN_Values&lt;TIM1::CR1, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, ReadWriteMode, TIM1CR1Base&gt; ; } ; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，现在可以单独更改和检查寄存器字段的任何值，您可以一次设置和检查多个字段值。</font><font style="vertical-align: inherit;">您可以更改并获取该字段或寄存器的值，同时绝对确保您不会混淆任何东西，并且将无法进行无效的操作，或者在寄存器字段中写入错误的位。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在让我们回到C的原始版本，在那里我们做了很多废话：</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初始选项</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     GPIOA //,    AHB1ENR RCC-&gt;APB1ENR |= RCC_AHB1ENR_GPIOAEN ; //    ,      RCC-&gt;AHB1ENR = RCC_AHB1ENR_GPIOAEN; //,  TIM1    APB2 RCC-&gt;APB1ENR |= RCC_APB1ENR_TIM2EN | RCC_APB2ENR_TIM1EN; // - ,        . auto result = GPIOA-&gt;BSRR ; if (result &amp; GPIO_BSRR_BS1) { //do something } //-     .   ... GPIOA-&gt;IDR = GPIO_IDR_ID5 ;</span></span></code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 并尝试使用新方法执行相同操作： </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     GPIOA // ,   APB1ENR   GPIOAEN RCC::APB1ENR::GPIOAEN::Enable::Set() ; // ,     GPIOA RCC::AHB1ENR::GPIOAEN::Enable::Set() ; // , RCC::APB2ENR::TIM1EN::Enable  //   APB1ENR RCC::APB1ENRPack&lt;RCC::APB1ENR::TIM2EN::Enable, RCC::APB2ENR::TIM1EN::Enable&gt;::Set(); // ,  BSRR    auto result = GPIOA::BSRR::Get() ; // ,  Reset    if (GPIOA::BSRR::BS1::Reset::IsSet()) { //do something } // ,       GPIOA::IDR::IDR5::On::Set() }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在每种情况下，我们在编译阶段都会遇到错误，这正是我们所实现的。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">好吧，我们提供了一个美丽，安全的访问寄存器及其字段的通道，但是速度如何？</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 性能表现 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 为了进行比较，我们的方法有多理想，我们将使用C和C ++代码将时钟馈送到端口A，将三个端口设置为输出模式，并在这三个端口中设置输出端口： </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C代码：</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> res = RCC-&gt;AHB2ENR; res &amp;=~ RCC_AHB1ENR_GPIOAEN_Msk ; res |= RCC_AHB1ENR_GPIOAEN ; RCC-&gt;AHB2ENR = res ; res = GPIOA-&gt;MODER ; res &amp;=~ (GPIO_MODER_MODER5 | GPIO_MODER_MODER4 | GPIO_MODER_MODER1) ; res |= (GPIO_MODER_MODER5_0 | GPIO_MODER_MODER4_0 | GPIO_MODER_MODER1_0) ; GPIOA-&gt;MODER = res ; GPIOA-&gt;BSRR = (GPIO_BSRR_BS5 | GPIO_BSRR_BS4 | GPIO_BSRR_BS1) ; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> ; }</code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++代码：</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ RCC::AHB1ENR::GPIOAEN::Enable::Set() ; GPIOA::MODERPack&lt; GPIOA::MODER::MODER5::Output, GPIOA::MODER::MODER4::Output, GPIOA::MODER::MODER1::Output&gt;::Set() ; GPIOA::BSRRPack&lt; GPIOA::BSRR::BS5::Set, GPIOA::BSRR::BS4::Set, GPIOA::BSRR::BS1::Set&gt;::Write() ; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> ; }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我正在使用IAR编译器。</font><font style="vertical-align: inherit;">让我们看看两种优化模式：没有优化和中等优化：没有优化的</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C代码和汇编程序表示形式：没有优化的</font></font><br><br><img src="https://habrastorage.org/webt/w-/wu/ln/w-wulnrmu5wg5pdby7qzzkxfdl8.png" alt="图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++代码和汇编程序表示形式：</font></font><br><br><img src="https://habrastorage.org/webt/wz/da/sf/wzdasflo3-fmkqsiq4lbtsbgf6g.png" alt="图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">两种情况下的18行汇编器和代码几乎相同，实际上这并不奇怪，因为它是这就是我们所取得的成就。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们检查平均优化，C中的代码：</font></font><br><br><img src="https://habrastorage.org/webt/xm/m2/ac/xmm2actwv_1w6m_hqnbhsccg6xe.png" alt="图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">预期已经只有13条汇编器行。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而且C ++代码平均而言是优化的：</font></font><br><br><img src="https://habrastorage.org/webt/qa/ic/a-/qaica-alj0danc4ffbmhyc2livs.png" alt="图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再次，情况是相同的：没有开销，并且在代码可读性方面有明显的优势。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">好了，所有任务都解决了，最后一个问题出现了。</font><font style="vertical-align: inherit;">以这种形式描述所有寄存器需要多少时间和精力？</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 如何描述所有寄存器 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们获得了可靠，方便，快捷的寄存器访问权限。</font><font style="vertical-align: inherit;">仍然有一个问题。</font><font style="vertical-align: inherit;">如何描述所有寄存器，对于单片机也有不到一百个。</font><font style="vertical-align: inherit;">这是描述所有寄存器所需的时间，因为在这样的例行工作中您可能会犯很多错误。</font><font style="vertical-align: inherit;">是的，您不需要手动执行此操作。</font><font style="vertical-align: inherit;">相反，我们将使用SVD文件中的代码生成器，正如我在本文开头所指出的那样，它完全涵盖了我接受的寄存器抽象。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我完成了一个同事的脚本，基于这个想法，脚本也做了相同的工作，但是使用枚举代替字段值的类要容易一些。</font><font style="vertical-align: inherit;">该脚本仅用于测试和检查想法，因此并不是最佳选择，但它允许您生成</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类似的内容。</font></font></a> <br><img src="https://habrastorage.org/webt/jq/0h/kj/jq0hkj-s5u4jyou1-luv7bhlasy.png" alt="图片"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">谁在乎脚本在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 总结 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结果，程序员的工作只是正确地连接生成的文件。</font><font style="vertical-align: inherit;">如果您需要使用寄存器，例如gpioa或rcc模块，则只需包含所需的头文件：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"gpioaregisters.hpp"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//for GPIOA #include "rccregisters.hpp" //for RCC int main() { RCC::AHB1ENR::GPIOAEN::Enable::Set() ; GPIOA::MODER::MODER15::Output::Set() ; GPIOA::MODERPack&lt; GPIOA::MODER::MODER12::Output, GPIOA::MODER::MODER14::Analog &gt;::Set() ; }</span></span></span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重复一遍，可以从制造商的网站下载SVD文件，您可以将其拉出开发环境，然后将其提交到脚本输入中，仅此而已。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，正如我上面所说，并不是所有的制造商都关心他们的消费者，因此并不是每个人都在SVD文件中进行枚举，因此，ST微控制器的所有枚举在生成后都是这样的：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Reg, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> offset, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> AccessMode, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> BaseType&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GPIOA_MODER_MODER_Values</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RegisterField&lt;Reg, offset, size, AccessMode&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Value0 = FieldValue&lt;GPIOA_MODER_MODER_Values, BaseType, <span class="hljs-number"><span class="hljs-number">0U</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Value1 = FieldValue&lt;GPIOA_MODER_MODER_Values, BaseType, <span class="hljs-number"><span class="hljs-number">1U</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Value2 = FieldValue&lt;GPIOA_MODER_MODER_Values, BaseType, <span class="hljs-number"><span class="hljs-number">2U</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Value3 = FieldValue&lt;GPIOA_MODER_MODER_Values, BaseType, <span class="hljs-number"><span class="hljs-number">3U</span></span>&gt; ; } ;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在需要使用它们的那一刻，您可以查看文档并更改“值”一词，以获得更易理解的信息： </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Reg, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> offset, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> AccessMode, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> BaseType&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GPIOA_MODER_MODER_Values</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RegisterField&lt;Reg, offset, size, AccessMode&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Input = FieldValue&lt;GPIOA_MODER_MODER_Values, BaseType, <span class="hljs-number"><span class="hljs-number">0U</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Output = FieldValue&lt;GPIOA_MODER_MODER_Values, BaseType, <span class="hljs-number"><span class="hljs-number">1U</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Alternate = FieldValue&lt;GPIOA_MODER_MODER_Values, BaseType, <span class="hljs-number"><span class="hljs-number">2U</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Analog = FieldValue&lt;GPIOA_MODER_MODER_Values, BaseType, <span class="hljs-number"><span class="hljs-number">3U</span></span>&gt; ; } ;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之后，您所有的字段值都将具有一个清晰的名称。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我希望将来ST仍能描述所有字段值，那么手工工作通常将为0。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">公平地说，在大多数情况下，程序员应该手动创建枚举枚举，以加深理解。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实际上，一切都欢迎任何建议和评论。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IAR 8.40.1下的项目位于</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，源代码本身位于</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处</font></font></a> <font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">“在线GDB”</font></a></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代码</font><font style="vertical-align: inherit;">PS：感谢</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link"><font style="vertical-align: inherit;">putyavka</font></a><font style="vertical-align: inherit;">提供的方法中发现的错误，</font><font style="vertical-align: inherit;">以及</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link"><font style="vertical-align: inherit;">Ryppka</font></a><font style="vertical-align: inherit;">提供的具有assert的错误。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a> <br><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><code>RegisterField::Get()</code> <br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 文章中使用的链接和文章 </font></font></h3><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Typesafe Register Access in C++</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">One Approach to Using Hardware Registers in C++</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SVD Description (*.svd) Format</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN459642/">https://habr.com/ru/post/zh-CN459642/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN459626/index.html">Windows通知工具：记录最薄的攻击面</a></li>
<li><a href="../zh-CN459628/index.html">开放发明网拥有三千多名被许可人-这对开源软件意味着什么</a></li>
<li><a href="../zh-CN459630/index.html">井字游戏第2部分：无状态复原/重做</a></li>
<li><a href="../zh-CN459638/index.html">建立有关电池的全球知识库</a></li>
<li><a href="../zh-CN459640/index.html">将文档作为代码。 第1部分：自动化更新</a></li>
<li><a href="../zh-CN459644/index.html">LED调光器</a></li>
<li><a href="../zh-CN459648/index.html">分析仪中的所有功能都应该很好：功能和界面...我们正在探索新的Solar appScreener 3.1界面</a></li>
<li><a href="../zh-CN459650/index.html">如何在黑匣子中不赔钱：计费测试方法</a></li>
<li><a href="../zh-CN459652/index.html">自动化回归测试方法</a></li>
<li><a href="../zh-CN459656/index.html">无需编写代码的OData服务</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>