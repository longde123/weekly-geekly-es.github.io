<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤟 🤚🏽 👨🏼‍🎓 颤振如何工作 😀 😖 🕞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Flutter实际如何运作？ 


 什么是窗口小部件，元素，BuildContext，RenderOject，绑定？ 


 难度： 初学者 
 参赛作品 


 去年（ 注：在2018年 ），当我开始进入神话般的Flutter世界时，与今天相比，互联网上的信息很少。 现在，尽管已经编写了许多材料...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>颤振如何工作</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476018/"><p><img src="https://habrastorage.org/webt/xo/f8/wq/xof8wqtuioee7o5ztrhyyb7hriq.png"></p><br><p>  Flutter实际如何运作？ </p><br><p> 什么是窗口小部件，元素，BuildContext，RenderOject，绑定？ </p><br><p> 难度： <em>初学者</em> </p><br><h1 id="vstuplenie"> 参赛作品 </h1><br><p> 去年（ <em>注：在2018年</em> ），当我开始进入神话般的Flutter世界时，与今天相比，互联网上的信息很少。 现在，尽管已经编写了许多材料，但其中只有一小部分谈论Flutter的实际工作原理。 </p><br><p> 什么是小部件（ <em>widgets</em> ），元素（ <em>elements</em> ），BuildContext？ 为什么Flutter快速？ 为什么有时它不能按预期工作？ 什么是树木，为什么需要它们？ </p><br><p> 在95％的情况下，编写应用程序时，您将只处理小部件以显示某些内容或与之交互。 但是，您是否从未真正想过所有这些魔术如何发挥作用？ 系统如何知道何时刷新屏幕以及应更新哪些部分？ </p><br><p>  <strong>内容：</strong> </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">参赛作品</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第1部分：背景</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">关于设备的一点点</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">代码与设备之间的接口</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">管理Flutter Framework Flutter Engine渲染</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RenderView和RenderObject</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">初始化绑定</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">调度程序绑定</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">手势绑定</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">渲染器绑定</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">小部件绑定</a> <a name="habracut"></a></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第2部分。从小部件到像素</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不变的配置</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">小部件的层次结构</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">树木背后的森林</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了解树中的元素</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3种小部件</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">项目类型</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">小部件和元素如何协同工作</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">onDrawFrame（）</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第3部分：处理手势</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第4部分：动画</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">全图</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">构建上下文</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">BuildContext有多有用？</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">为了好玩</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">结论</a> </li></ul><br><h1 id="chast-1-predystoriya"> 第1部分：背景 </h1><br><p> 本文的第一部分介绍了一些关键概念，这些概念将在本材料的第二部分中使用，并有助于更好地理解Flutter。 </p><br><h2 id="nemnogo-ob-ustroystve"> 关于设备的一点点 </h2><br><p> 让我们从头开始，再回到基础。 </p><br><p> 当您查看设备时，或更确切地说，查看设备上运行的应用程序时，只会看到屏幕。 </p><br><p> 实际上，您所看到的只是像素，它们共同构成一个二维图像，并且当您用手指触摸屏幕时，设备仅会识别手指在玻璃板上的位置。 </p><br><p> 在大多数情况下（从视觉角度而言），应用程序的所有奇妙之处在于，它基于以下交互作用来更新该图像： </p><br><ul><li> 使用设备屏幕（ <em>例如，玻璃上的手指</em> ） </li><li> 与网络（ <em>例如，与服务器通信</em> ） </li><li> 随着时间的流逝（ <em>例如动画</em> ） </li><li> 与其他外部传感器 </li></ul><br><p> 屏幕上图像的可视化由硬件（显示器）提供，该硬件定期（通常每秒60次）更新显示。 这称为“刷新率”，以Hz（赫兹）表示。 </p><br><p> 显示器从GPU（图形处理单元）接收要显示的信息，GPU是一种经过优化和设计以从某些数据（多边形和纹理）快速形成图像的专用电子电路。 图形处理器每秒生成一次“图像”（=帧缓冲区）以显示并将其发送到硬件的次数称为帧率（ <em>注：frame rate</em> ）。 这是使用每秒一帧的帧（ <em>例如</em> ，每秒<em>60帧或60fps</em> ）来测量的。 </p><br><p> 您可能会问我，为什么我以GPU /硬件和物理玻璃传感器显示的二维图像的概念开始本文，以及与常规Flutter小部件之间的关系是什么？ </p><br><p> 我认为，如果从这种角度来看，将更容易理解Flutter的实际工作原理，因为Flutter应用程序的主要目标之一是创建此二维图像并使其与之交互。 也因为不相信，在Flutter中，几乎所有事情都是由于需要在正确的时间快速更新屏幕！ </p><br><h2 id="interfeys-mezhdu-kodom-i-ustroystvom"> 代码与设备之间的接口 </h2><br><p> 无论如何，对Flutter感兴趣的每个人都已经看到了以下描述Flutter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">高级架构的图片</a> 。 </p><br><p><img src="https://habrastorage.org/webt/i0/tp/fo/i0tpfoumlz1ultkyzqywfm9-osa.png"></p><br><p> 当我们使用Dart编写Flutter应用程序时，我们仍处于<em>Flutter Framework</em>级别（以绿色突出显示）。 </p><br><p>  <em>Flutter框架</em>通过称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Window</a>的抽象层与<em>Flutter Engine</em> （蓝色）进行交互。 这种抽象级别提供了许多用于与设备进行间接交互的API。 </p><br><p> 同样通过这种抽象级别， <em>Flutter引擎在以下情况下</em>通知<em>Flutter框架</em> ： </p><br><ul><li> 在设备级别发生感兴趣的事件（方向更改，设置更改，内存问题，应用程序的运行状态...） </li><li> 在玻璃水平上发生一些事件（=手势） </li><li> 平台通道发送一些数据 </li><li> 而且主要是在<strong>Flutter Engine准备渲染新帧时</strong> </li></ul><br><h2 id="upravlenie-flutter-framework-renderingom-flutter-engine"> 管理Flutter Framework Flutter Engine渲染 </h2><br><p> 很难相信，但这是事实。 除了某些情况（ <em>请参阅下文</em> ），在不启动<em>Flutter Engine</em>渲染的情况下不会执行<em>Flutter Framework</em>代码。 </p><br><p> 例外情况： </p><br><ul><li> 手势/手势（=玻璃上的事件） </li><li> 平台消息（=由设备生成的消息，例如GPS） </li><li> 设备消息（=与设备状态更改有关的消息，例如方向，在后台发送的应用程序，内存警报，设备设置...） </li><li> 未来或http回应 </li></ul><br><p>  <em>（在我们之间，您实际上可以应用视觉更改，而无需通过Flutter Engine调用，但这是<strong>不推荐的</strong> ）</em> </p><br><p> 您问我：“如果执行了与<em>手势</em>相关的某种代码并引起视觉变化，或者如果我使用<em>计时器</em>来设置导致视觉变化的任务的频率（例如动画），那么它如何工作？” </p><br><p> 如果希望发生视觉变化或基于计时器执行某些代码，则需要告诉<em>Flutter Engine</em>需要绘制一些内容。 </p><br><p> 通常，下次<em>Flutter Engine</em>更新时，它会调用<em>Flutter Framework</em>执行一些代码，并最终提供一个新的呈现场景。 </p><br><p> 因此，一个重要的问题是Flutter引擎如何基于渲染组织所有应用程序行为。 </p><br><p> 要了解内部机制，请看以下动画： </p><br><p><img src="https://habrastorage.org/webt/zu/7s/ig/zu7sigrkekrmz8ha_83cvr88ynk.gif"></p><br><p> 简要说明（稍后将提供更多详细信息）： </p><br><ul><li> 某些外部事件（手势，http响应等）或什至是将来，都可能触发需要更新显示的任务。 相应的消息被发送到<em>Flutter Engine</em> （= <em>Schedule Frame</em> ） </li><li> 当<em>Flutter Engine</em>准备开始更新渲染时，它将创建一个<em>Begin Frame</em>请求。 </li><li>  <em>Flutter Framework</em>截获了此<em>Begin Frame</em>请求，该<em>框架</em>执行主要与代码相关的任务（例如，动画） </li><li> 这些任务可以重新创建请求以供以后渲染（例如：动画尚未完成其执行，并且要完成该动画，它需要在以后的阶段中获得另一个<em>Begin Frame</em> ）。 </li><li> 接下来， <em>Flutter引擎</em>发送并条机，并条机将其<em>捕获</em> ，并在结构和大小方面查找与更新布局有关的所有任务 </li><li> 完成所有这些任务后，他继续进行与在渲染方面更新布局相关的任务 </li><li> 如果屏幕上需要绘制某些内容，则将用于可视化的新场景（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Scene</a> ）发送到<em>Flutter Engine</em> ，后者将更新屏幕 </li><li> 然后<em>Flutter框架</em>执行渲染<em>后将</em>执行的所有任务（= PostFrame回调），以及与渲染无关的任何其他后续任务 </li><li>  ...然后这个过程重新开始 </li></ul><br><h2 id="renderview-i-renderobject">  RenderView和RenderObject </h2><br><p> 在深入研究工作流的细节之前，是时候介绍“ <em>渲染树”</em>的概念了。 </p><br><p> 如前所述，最终所有内容都将转换为将在屏幕上显示的像素， <em>Flutter框架会将</em>我们用于开发应用程序的<em>小部件</em>转换为将在屏幕上显示的可视块。 </p><br><p> 这些可视部分对应于称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">RenderObject的</a>对象，这些对象用于： </p><br><ul><li> 根据大小，位置，几何形状以及<em>“渲染内容”</em>定义屏幕的特定区域 </li><li> 识别可能受手势影响的屏幕区域（=手指触摸） </li></ul><br><p> 一组所有<em>RenderObject</em>组成一棵树，称为<em>Render Tree</em> 。 在这棵树的顶部（= <em>根</em> ），我们找到一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">RenderView</a> 。 </p><br><p>  <em>RenderView</em>为<em>Render Tree</em>对象提供了公共表面，并且是<em>RenderObject</em>的特殊版本。 </p><br><p> 在视觉上，我们可以将所有这些表示如下： <br><img src="https://habrastorage.org/webt/yi/aq/6v/yiaq6vvo9ssed0qtewkftfwrmpy.png"></p><br><p>  <em>Widget</em>和<em>RenderObject</em>之间的关系将在后面讨论。 同时，该深入一点了。 </p><br><h2 id="inicializaciya-bindings"> 初始化绑定 </h2><br><p>当Flutter应用程序启动时，首先调用<code>main()</code>函数，最终调用<code>runApp(Widget app)</code>方法。 </p><br><p>  <code>runApp()</code>方法时<code>runApp()</code> <em>Flutter框架</em>将初始化其自身与<em>Flutter Engine</em>之间的接口。 这些接口称为<strong>绑定</strong> （ <em>请注意：bindings</em> ）。 </p><br><p>  <strong>绑定介绍</strong> </p><br><p> 绑定被设计为框架和Flutter引擎之间的链接。 只有通过绑定，才能在<em>Flutter框架</em>和<em>Flutter引擎</em>之间交换数据。 <br>  <em>（该规则只有一个例外</em> -RenderView <em>，但我们将在后面讨论）。</em> </p><br><p> 每个绑定负责处理按活动区域分组的一组特定任务，动作，事件。 </p><br><p> 在撰写本文时， <em>Flutter框架</em>具有8个绑定。 </p><br><p> 下面是他们的4，这将在本文中进行讨论： </p><br><ul><li>  <em>调度程序绑定</em> </li><li>  <em>手势绑定</em> </li><li>  <em>渲染器绑定</em> </li><li>  <em>小部件绑定</em> </li></ul><br><p> 为了完整起见，我将提及其余的4个： </p><br><ul><li>  <em>ServicesBinding：</em>负责处理消息发送给信道的平台<em>（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">平台通道构件</a> ）</em> </li><li>  <em>PaintingBinding</em> ：负责处理图像缓存 </li><li>  <em>SemanticsBinding</em> ：保留用于与语义相关的所有内容的后续实现 </li><li>  <em>TestWidgetsFlutterBinding</em> ：由窗口小部件测试库使用 </li></ul><br><p> 您也可以提到<em>WidgetsFlutterBinding</em> ，但这并不是一个绑定，而是一种<em>“绑定初始化器”</em> 。 </p><br><p> 下图显示了绑定之间的互动，我会进一步考虑和<em>颤振引擎。</em> </p><br><p><img src="https://habrastorage.org/webt/ws/ph/x_/wsphx_tme3caqf0qimfk0wxur9g.png"></p><br><p> 让我们看一下这些“核心”绑定。 </p><br><h3 id="schedulerbinding"> 调度程序绑定 </h3><br><p> 此绑定有两个主要职责： </p><br><ul><li> 说说<em>Flutter Engine</em> ： <em>“嘿！下次当您不忙时，叫醒我，这样我就可以工作一点，告诉您要渲染什么，或者是否需要您以后再打电话给我……”</em> </li><li> 倾听并回应这种<em>“令人不安的觉醒”</em> （见下文） </li></ul><br><p>  <em>SchedulerBinding</em>何时请求<em>唤醒电话</em> ？ </p><br><ul><li><p> 当<em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">股票代号</a></em>必须<em>算出</em>新的<em>代号时</em> </p><br><p> 例如，您有一个动画，然后启动它。 使用“ <em>股票行情指示器”</em>对动画进行裁剪，该<em>行情发生器会</em>定期调用（= <em>tick</em> ）以执行<em>回调</em> 。 为了启动这样的<em>回调</em> ，我们需要告诉<em>Flutter Engine，</em>以便在下一次更新（= <em>Begin Frame</em> ）时唤醒我们。 这将启动<em>自动收录器</em>回调以完成其任务。 如果<em>代码</em>仍然需要继续执行，则在其任务结束时，它将调用<em>SchedulerBinding</em>来调度另一个框架。 </p><br></li><li><p> 何时更新显示 </p><br><p> 例如，我们需要制定一个导致视觉变化的事件（例如：更新屏幕一部分的颜色，滚动，在屏幕上添加/删除某些东西），为此，我们需要采取必要的步骤以最终在屏幕上显示更新的图像。 在这种情况下，当发生此类更改时， <em>Flutter框架</em>将调用<em>SchedulerBinding</em>以使用<em>Flutter Engine</em>调度另一个帧。  <em>（稍后我们将了解其实际工作原理）</em> </p><br></li></ul><br><h3 id="gesturebinding"> 手势绑定 </h3><br><p> 此绑定根据<em>“手指”</em> （= <em>手势</em> ）侦听与引擎的交互。 </p><br><p> 特别是，他负责接收与<em>手指</em>有关的数据，并确定手势在屏幕的哪一部分使用。 然后，他相应地通知这些部分。 </p><br><h3 id="rendererbinding"> 渲染器绑定 </h3><br><p> 此绑定是<em>Flutter Engine</em>和<em>Render Tree</em>之间的链接。 她负责： </p><br><ul><li> 侦听引擎生成的事件，以通知用户通过影响视觉效果和/或语义的设备设置应用的更改 </li><li> 向引擎发送有关将应用于显示的更改的消息 </li></ul><br><p> 为了提供将在屏幕上显示的更改， <em>RendererBinding</em>负责管理<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">PipelineOwner</a>并初始化<strong>RenderView</strong> 。 </p><br><p>  <em>PipelineOwner</em>是一种<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">乐团</a> ，它知道根据<em>组件</em>使用<em>RenderObject</em>需要执行的操作，并协调这些动作。 </p><br><h3 id="widgetsbinding"> 小部件绑定 </h3><br><p> 该绑定侦听用户通过影响语言（= <em>语言环境</em> ）和<em>语义的</em>设备设置应用的更改。 </p><br><blockquote>  <em>小笔记</em> <br><br>  <em>我假设在</em> Flutter <em>开发的后期</em> ， <em>所有与语义相关的事件都将转移到</em> SemanticsBinding <em>，但是在撰写本文时，情况并非如此。</em> </blockquote><p> 另外， <em>WidgetsBinding</em>是小部件和<em>Flutter Engine</em>之间的链接。 她负责： </p><br><ul><li> 管理小部件结构更改的处理过程 </li><li> 渲染通话 </li></ul><br><p> 处理部件结构通过使用改变<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">BuildOwner</a> 。 </p><br><p>  <em>BuildOwner</em>跟踪需要重建哪些窗口小部件，并处理应用于整个窗口小部件结构的其他任务。 </p><br><h1 id="chast-2-ot-vidzhetov-k-pikselyam"> 第2部分。从小部件到像素 </h1><br><p> 既然我们已经了解了<em>Flutter</em>内部工作的基础知识，那么该讨论小部件了。 </p><br><p> 在所有Flutter文档中，您将阅读所有<em>小部件</em> （小部件）。 </p><br><p> 这几乎是正确的。 但是为了更精确一点，我宁愿说： </p><br><blockquote> 从开发人员的角度来看，在布局和交互方面，与用户界面相关的所有内容均使用小部件完成。 </blockquote><p> 为什么这么准确？ 除了<em>Widget</em>允许开发人员根据大小，内容，布局和交互性来确定屏幕的一部分外，还有很多其他功能。 那么<em>Widget</em>到底是什么？ </p><br><h2 id="neizmenyaemaya-konfiguraciya"> 不变的配置 </h2><br><p> 如果您查看<em>Flutter</em>的源代码，您会注意到<em>Widget</em>类的以下定义。 </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DiagnosticableTree</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">({ </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.key })</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Key key; ... }</code> </pre> <br><p> 这是什么意思？ </p><br><p> 注释<strong>“ @immutable”</strong>非常重要，它告诉我们<strong>Widget类</strong>中的<strong>任何变量都必须为FINAL</strong> ，换句话说：“ <strong>为每个人</strong>定义并分配<strong>一次”</strong> 。 因此，在创建实例后，小部件将不再能够更改其内部变量。 </p><br><blockquote>  <em>由于Widget是不可变的，因此可以将其视为静态配置。</em> </blockquote><br><h2 id="ierarhicheskaya-struktura-vidzhetov"> 小部件的层次结构 </h2><br><p> 使用Flutter设计时，您可以使用如下小部件定义屏幕的结构： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SafeArea( child: Scaffold( appBar: AppBar( title: Text(<span class="hljs-string"><span class="hljs-string">'My title'</span></span>), ), body: Container( child: Center( child: Text(<span class="hljs-string"><span class="hljs-string">'Centered Text'</span></span>), ), ), ), ); }</code> </pre> <br><p> 本示例使用7个小部件，这些小部件共同形成一个层次结构。 基于此代码的非常简化的方案如下： </p><br><p><img src="https://habrastorage.org/webt/f2/ke/dt/f2kedtux7_ot2issfzbv64n3uak.png"></p><br><p> 如您所见，所显示的图看起来像一棵树，其中<em>SafeArea</em>是其根。 </p><br><h2 id="les-za-derevyami"> 树木背后的森林 </h2><br><p> 如您所知，小部件本身可以是其他小部件的集合。 例如，您可以按以下方式修改前面的代码： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MyOwnWidget(); }</code> </pre> <br><p> 此选项假定小部件<em>“ MyOwnWidget”</em>本身将显示<em>SafeArea</em>和<em>Scaffold</em> 。 但是在这个例子中最重要的是 </p><br><blockquote>  <em>小部件</em>可以表示叶子，树中的结，甚至是树本身，或者为什么代表森林？ </blockquote><br><h2 id="ponimanie-element-v-dereve"> 了解树中的<em>元素</em> </h2><br><p> 这和它有什么关系？ </p><br><p> 如稍后所示，为了能够生成组成设备上显示图像的像素， <em>Flutter</em>必须详细了解组成屏幕的所有小部分，并且要确定所有部分，需要了解所有小部件的<strong>扩展</strong> 。 </p><br><p> 为了说明这一点，考虑娃娃的原理：在一个封闭的状态下，你看到的只是一个娃娃，但她还有另一个，又包含另一种，等等... </p><br><p><img src="https://habrastorage.org/webt/9x/kq/lb/9xkqlbngsofs0w7m71rx2yucnzy.png"></p><br><p> 当<em>Flutter</em>展开所有小部件<em>（屏幕的一部分）时</em> ，就像获取所有娃娃<em>（整个</em> <em>屏幕的</em> <em>一部分）一样</em> 。 </p><br><p> 下面的图片示出了对应于先前代码窗口小部件的分层结构的最后部分。 用黄色突出显示了前面代码中提到的小部件，以便您可以在最后的树中定义它们。 </p><br><p><img src="https://habrastorage.org/webt/mp/lw/-o/mplw-oisztyx_zvwf8kvpl2tpog.png"></p><br><blockquote>  <strong><em>重要说明</em></strong> <br><br>  <em>语言“小部件树”的存在只是为了便于理解，因为程序员使用小部件，但是Flutter中没有小部件树！</em> <br><br>  <em>实际上，说“元素之树”会更正确</em> </blockquote><p> 现在该介绍<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Element</a>的概念了。 </p><br><blockquote>  <em><strong>每个</strong>小部件都有<strong>一个</strong>元素。</em>  <em>元素相互连接并形成一棵树。</em>  <em>因此， <strong>元素</strong>是对树中某物的引用。</em> </blockquote><p> 首先，将元素视为具有父级（可能还有子级）的节点。 通过<em>父子</em>关系将它们链接在一起，我们得到了树形结构。 </p><br><p><img src="https://habrastorage.org/webt/bd/cx/t4/bdcxt4slijkhhc5j0fnipnauyey.png"></p><br><p> 如您所见，该元素指向一个小部件，也<strong>可以</strong>指向<em>RenderObject</em> 。 </p><br><blockquote>  <em>更好的是... Element指向<strong>创建</strong>此Element的Widget！</em> </blockquote><p> 让我们总结一下： </p><br><ul><li> 没有树小部件，但有一个木质元素 </li><li> 元素是小工具 </li><li> 该项目是指创建它的小部件。 </li><li> 链接到父级关系的元素 </li><li> 一个项目可能有一个“婴儿”。 </li><li> 元素也可以指向<em>RenderObject。</em> </li></ul><br><blockquote>  <em><strong>元素</strong>确定显示的块的各个部分如何相互关联。</em> </blockquote><p> 为了更好地了解<em>一个</em>办法<em>的</em>概念，让我们考虑下面的可视化表示： </p><br><p><img src="https://habrastorage.org/webt/x5/vb/jt/x5vbjtq_5fhuyhvc2s7jnt7pbai.png"></p><br><p> 如您所见，元素树是小部件和<em>RenderObjects</em>之间的实际关系。 </p><br><p> 但是，为什么<em>Widget</em>创建一个<em>Element</em> ？ </p><br><h2 id="3-kategorii-vidzhetov">  3种小部件 </h2><br><p> 在Flutter中，小部件分为3类，我个人将其称为<em>（但这只是我对它们进行分类的方式）</em> ： </p><br><ul><li><p> 代理人 </p><br><p> 这些窗口小部件的主要目的是存储一些信息（窗口小部件应可访问这​​些信息），这些信息是基于Proxy的树结构的一部分。 此类小部件的一个示例是<strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">InheritedWidget</a></strong>或<strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">LayoutId</a></strong> 。 </p><br><p> 这些小部件不直接参与用户界面的形成，而是用于获取它们可以提供的信息。 </p><br></li><li><p> 渲染 </p><br><p> 这些小部件与屏幕的布局直接相关，因为它们确定（或用于确定） <em>大小</em> ， <em>位置</em> ， <em>渲染</em> 。 典型示例包括： <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Row</a></strong> ， <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Column</a></strong> ， <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Stack</a></strong>以及<strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Padding</a></strong> ， <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Align</a></strong> ， <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Opacity</a></strong> ， <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">RawImage</a></strong> ... </p><br></li><li><p> 组成部分 </p><br><p> 这些是其他小部件，它们不直接提供与大小，位置，外观有关的最终信息，而是提供将用于获取相同最终信息的数据（或技巧）。 这些窗口小部件通常称为组件。 </p><br><p> 示例： <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">RaisedButton</a></strong> ， <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Scaffold</a></strong> ， <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Text</a></strong> ， <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">GestureDetector</a></strong> ， <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Container</a></strong> ... </p><br></li></ul><br><p><img src="https://habrastorage.org/webt/oe/j0/j7/oej0j75h_3ycogohqdckq5e03im.png"></p><br><p> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">此PDF文件</a>发送最高按类别分组的小部件。 </p><br><p> 为什么这种分离很重要？ 因为根据窗口小部件的类别，相应的元素类型与...关联。 </p><br><h2 id="tipy-elementov"> 项目类型 </h2><br><p> 有几种类型的元素： </p><br><p><img src="https://habrastorage.org/webt/or/au/yc/orauycfegkvfnjlmjws4x4ftpuw.png"></p><br><p> 正如可以在上面的图中看到，该元件被分成两种主要类型： </p><br><ul><li><p> 组成要素 </p><br><p> 这些元素不<strong>直接</strong>负责渲染显示的任何部分。 </p><br></li><li><p>  RenderObjectElement </p><br><p> 这些元素负责屏幕上显示的图像部分。 </p><br></li></ul><br><p> 太好了！ 这么多的信息，但是所有这些之间是如何关联的，为什么谈论它有趣呢？ </p><br><h2 id="kak-vidzhety-i-elementy-rabotayut-vmeste"> 小部件和元素如何协同工作 </h2><br><blockquote>  <em>在Flutter中，所有机制都基于使元素或renderObject无效。</em> </blockquote><p> 元素失效可以通过以下方式完成： </p><br><ul><li> 使用<code>setState</code> ，这会使整个<strong>StatefulElement</strong>无效（请注意，我故意不说<em>StatefulWidget</em> ） </li><li> 通过<strong>proxyElement</strong>处理的通知（例如，InheritedWidget），使依赖于此<em>proxyElement的</em>任何<em>元素</em>失效 </li></ul><br><p>  <em>无效</em>的结果是，到相应<em>元素</em>的链接出现在<strong>脏</strong>元素列表中。 </p><br><p>  <em>renderObject</em>的<em>无效</em>意味着元素的结构完全不变，但是<em>renderObject</em>级别发生了变化，例如： </p><br><ul><li> 改变其大小，位置，几何形状... </li><li> 某些东西需要重新粉刷，例如，当您仅更改背景颜色，字体样式时... </li></ul><br><p> 这种<em>无效</em>的结果是链接到需要重建或重新绘制的渲染对象<em>（renderObject）</em>列表中的相应<em>renderObject</em> 。 </p><br><p> 不管失效类型引起<strong>SchedulerBinding（</strong>还记得吗？）要查询<strong>扑引擎，</strong>所以他计划组建一个新框架。 </p><br><p> 这是时刻<em>扑引擎</em> “唤醒” <em>SchedulerBinding</em>发生的所有魔法... </p><br><h2 id="ondrawframe">  onDrawFrame（） </h2><br><p> 在本文的前面，我们注意到<em>SchedulerBinding有</em>两个主要职责，其中之一是愿意处理<em>Flutter Engine提出的</em>与帧重建有关的请求。 这是专注于此的最佳时机。 </p><br><p> 下面的部分时序图显示了<em>SchedulerBinding</em>从<em>Flutter Engine</em>接收到<em>onDrawFrame（）</em>请求时发生的情况。 </p><br><p><img src="https://habrastorage.org/webt/b8/mz/ba/b8mzbav2krwuwat0ibyvd5gngs4.png"></p><br><p>  <strong>步骤1.元素</strong> </p><br><p> 叫<em>WidgetsBinding，</em>并且这种结合首先考虑与元件相关联的变化。  <em>WidgetsBinding</em>调用<em>buildOwner</em>对象的<em>buildScope</em>方法，因为<strong>BuildOwner</strong>负责处理项目树。 此方法遍历所有<em>脏</em>元素并请求对其进行<strong>重建</strong> 。 </p><br><p> 此<code>rebuild()</code>方法（ <code>rebuild()</code> ）的主要原理是： </p><br><ol><li> 通过调用此元素所引用的窗口小部件的<code>build()</code>方法（=窗口<code>Widget build (BuildContext context) {...}</code>方法），有一个重建该元素的请求（这将花费大部分时间）。 这个<code>build()</code>方法将返回一个新的小部件 </li><li> 如果该元素没有“子级”，则为新的小部件创建一个元素（请参见下文）（ <em>注意： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">inflateWidget</a></em> ），否则 </li><li> 将新的小部件与元素的子代所引用的小部件进行比较 <br><ul><li> 如果它们是可互换的（= <em>相同的小部件类型和键</em> ），则将进行更新并保存子级。 </li><li> 如果他们不能互换，子元素将被丢弃<em>（丢弃〜）</em>和新的窗口小部件创建的元素 </li></ul></li><li> 这种新元件被安装为元素的子元素。  （已<em>安装）</em> =插入到元素树中） </li></ol><br><p> 下面的动画将尝试使这一解释更加清楚。 </p><br><p><img src="https://habrastorage.org/webt/71/91/xc/7191xcnbg00lbho_ol_9vaczdca.gif"></p><br><p>  <strong>注意小部件和元素</strong> </p><br><p> 对于新的小部件，将创建与小部件<em>类别</em>相对应的<em>特定类型</em>的元素，即： </p><br><ul><li>  <em>InheritedWidget-</em> &gt; <em>InheritedElement</em> </li><li>  <em>StatefulWidget</em> - &gt; <em>StatefulElement</em> </li><li>  <em>StatelessWidget-</em> &gt; <em>StatelessElement</em> </li><li>  <em>InheritedModel-</em> &gt; <em>InheritedModelElement</em> </li><li>  <em>InheritedNotifier-</em> &gt; <em>InheritedNotifierElement</em> </li><li>  <em>LeafRenderObjectWidget-</em> &gt; <em>LeafRenderObjectElement</em> </li><li>  <em>SingleChildRenderObjectWidget</em> - &gt; <em>SingleChildRenderObjectElement</em> </li><li>  <em>MultiChildRenderObjectWidget-</em> &gt; <em>MultiChildRenderObjectElement</em> </li><li>  <em>ParentDataWidget-</em> &gt; <em>ParentDataElement</em> </li></ul><br><p> 这些元素中的每一种都有自己的行为。 例如： </p><br><ul><li>  <em>StatefulElement</em>将在初始化时调用<code>widget.createState()</code>方法，这将创建一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">State</a>并将其与元素关联 </li><li> 装入类型为<em>RenderObjectElement</em>的元素时，它将创建一个<em>RenderObject</em> 。 该<em>renderObject</em>将被添加到<em>Render Tree</em>并与该元素相关联。 </li></ul><br><p>  <strong>步骤2. renderObjects</strong> </p><br><p> 现在，在完成所有与<em>脏</em>元素关联的操作之后， <em>元素树</em>将稳定下来。 因此，现在该考虑可视化过程了。 </p><br><p> 由于<em>RendererBinding</em>负责渲染<em>Render Tree</em> ，因此<em>WidgetsBinding</em>调用<code>drawFrame</code> <em>RendererBinding</em>方法。 </p><br><p> 下面的局部图显示了在<em>drawFrame（）</em>请求期间执行的操作序列。 </p><br><p><img src="https://habrastorage.org/webt/dp/sw/v3/dpswv3gszlwj3f_zwsak0xq91k0.png"></p><br><p> 在此步骤中，执行以下操作： </p><br><ul><li> 请求每个标记为<em>脏的</em> <em>renderObject进行合成</em> （即，计算其大小和几何形状） </li><li> 每个标记为“需要重绘”的<em>renderObject</em>均使用其自己的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">layer</a>方法重绘 </li><li> 所形成的场景已形成并发送到<em>Flutter Engine</em> ，以便后者将其传输到设备屏幕。 </li><li> 最后，语义也将更新并发送到<em>Flutter Engine</em> </li></ul><br><p> 在此工作流程结束时，设备屏幕将刷新。 </p><br><h1 id="chast-3-obrabotka-zhestov"> 第3部分：加工手势 </h1><br><p> 使用<em>GestureBinding</em>处理手势（ <em>与玻璃上的手指动作有关的事件</em> ）。 </p><br><p> 当<em>Flutter Engine</em>通过<em>window.onPointerDataPacket</em> API发送有关手势相关事件的信息时， <strong>GestureBinding会</strong>拦截它，执行一些缓冲，并： </p><br><ol><li> 转换<em>Flutter Engine</em>给定的坐标以匹配<strong>设备像素比率</strong> ，然后 </li><li> 从<em>renderView</em>检索屏幕部分中与事件坐标相关的所有<em>RenderObject</em> <em>的</em>列表 </li><li> 然后<em>遍历</em>生成的<em>renderObjects</em>列表，并将相关事件发送给每个对象 </li><li> 如果<em>renderObject</em> “侦听”此类事件，则对其进行处理 </li></ol><br><p> 希望现在我了解<em>renderObjects的</em>重要性。 </p><br><h1 id="chast-4-animacii"> 第4部分：动画 </h1><br><p> 本文的这一部分是关于<strong>动画</strong>的概念和对<strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Ticker</a></strong>的深入了解。 </p><br><p> 在处理动画时，通常使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">AnimationController</a>或任何用于动画的小部件（ <em>请注意： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">AnimatedCrossFade</a></em> ）。 </p><br><p> 在<em>Flutter中，</em>所有与动画相关的内容都指<em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Ticker</a></em> 。 激活时， <em>股票代码</em>只有一个任务：“它要求<em>SchedulerBinding</em>注册回调，并在出现新的回调时告诉<em>Flutter Engine</em>唤醒它。” 当<em>发动机颤</em>准备好，它调用通过<em>SchedulerBinding</em>请求<em>：“onBeginFrame”。</em>  <em>SchedulerBinding</em>访问<em>代码</em>回调列表并执行每个列表。 </p><br><p> 每个<em>刻度都</em>被“感兴趣的”控制器拦截以对其进行处理。 如果动画已完成，则<em>代码将</em> “禁用”，否则<em>代码将</em>请求<em>SchedulerBinding</em>来计划新的回调。 等等... </p><br><h1 id="polnaya-kartina"> 全图 </h1><br><p> 现在我们已经了解了<em>Flutter的</em>工作原理： </p><br><p><img src="https://habrastorage.org/webt/5s/tw/w7/5stww7o_izlc6ywpnkmcfkkllbk.png"></p><br><h1 id="buildcontext"> 构建上下文 </h1><br><p> 最后，回到显示不同类型元素的图，并考虑根<em>元素</em>的签名： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Element</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DiagnosticableTree</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BuildContext</span></span></span><span class="hljs-class"> </span></span>{ ... }</code> </pre> <br><p> 我们看到了非常著名的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">BuildContext</a> ！ 那是什么 </p><br><p>  <strong>BuildContext</strong>是一个接口，它定义了可以由元素实现的许多吸气剂和方法。 通常， <em>BuildContext</em>用于<em>StatelessWidget</em>的<code>build()</code>方法或<em>StatefulWidget的</em> <em>State</em> 。 </p><br><blockquote>  <em><strong>BuildContext</strong> -这是不一样<strong>的元素</strong>本身，它对应于</em> <br><ul><li>  <em>正在更新的小部件（在<code>build</code>或<code>builder</code>方法内部）</em> </li><li>  <em>与在其中引用上下文变量的<strong>州</strong>相关联的StatefulWidget。</em> </li></ul><br></blockquote><p> 这意味着大多数开发人员在不了解元素的情况下就不断使用它们。 </p><br><h2 id="naskolko-poleznym-mozhet-byt-buildcontext">  BuildContext有多有用？ </h2><br><p>  <em>BuildContext</em>  ,   ,      ,  <em>BuildContext</em>   ,  : </p><br><ul><li>     <em>RenderObject</em> ,   (,     <em>Renderer</em> ,  -) </li><li>   <em>RenderObject</em> </li><li>   .     ,     <code>of</code> (, <code>MediaQuery.of(context)</code> , <code>Theme.of(context)</code> …) </li></ul><br><h2 id="zabavy-radi">   </h2><br><p> ,   ,  <em>BuildContext</em> –  <em></em> ,         .  <strong> </strong>   <em>StatelessWidget</em>   ,      <em>StatefulWidget</em> ,    <code>setState()</code> ,    <em>BuildContext</em> . </p><br><blockquote> <strong></strong> <br> <strong>,    !</strong> <br><br>    – ,  <em>StatelessWidget</em>   . <br>       , ,  <em>StatefulWidget</em> . </blockquote><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ runApp(MaterialApp(home: TestPage(),)); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestPage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatelessWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// final because a Widget is immutable (remember?) final bag = {"first": true}; @override Widget build(BuildContext context){ return Scaffold( appBar: AppBar(title: Text('Stateless ??')), body: Container( child: Center( child: GestureDetector( child: Container( width: 50.0, height: 50.0, color: bag["first"] ? Colors.red : Colors.blue, ), onTap: (){ bag["first"] = !bag["first"]; // // This is the trick // (context as Element).markNeedsBuild(); } ), ), ), ); } }</span></span></code> </pre> <br><p> <em> ,    <code>setState()</code> ,         : <code>_element.markNeedsBuild()</code> .</em> </p><br><h1 id="zaklyuchenie"> 结论 </h1><br><p>  : "   ".   ,      ,    <em>Flutter</em> ,   ,    ,   ,      .  ,  ,   <em>Widget</em> , <em>Element</em> , <em>BuildContext</em> , <em>RenderObject</em> ,     .   ,       . </p><br><p>     .       . </p><br><p> PS  ,          () . <br> PSS       <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Flutter internals</a></strong>  Didier Boelens,           ) </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN476018/">https://habr.com/ru/post/zh-CN476018/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN476000/index.html">ML.NET模型构建器更新</a></li>
<li><a href="../zh-CN476002/index.html">在德国找到博士生职位的经验</a></li>
<li><a href="../zh-CN476004/index.html">项目经理-神话还是现实？ 或为什么在视觉效果领域需要它？</a></li>
<li><a href="../zh-CN476006/index.html">SOC建设者的神话和传说，或对监视和响应网络攻击中心的3种误解</a></li>
<li><a href="../zh-CN476008/index.html">MOSDROID聚会：连接到广播</a></li>
<li><a href="../zh-CN476022/index.html">Vue店面：提升后端</a></li>
<li><a href="../zh-CN476024/index.html">MVP的最佳体系结构：整体，SOA，微服务还是无服务器？..第1部分</a></li>
<li><a href="../zh-CN476026/index.html">适用于WSL的酷生活技巧（适用于Linux的Windows子系统）</a></li>
<li><a href="../zh-CN476032/index.html">Brunner Elektronik-从CAD系统到驾驶舱</a></li>
<li><a href="../zh-CN476034/index.html">最没有防御能力的是百富勤猎鹰</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>