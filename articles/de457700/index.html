<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍👩‍👦‍👦 😺 👆 Node.js Authentifizierungshandbuch ohne passport.js und Dienste von Drittanbietern ⏮️ 🐍 👨‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Autor des Artikels, dessen Übersetzung wir heute veröffentlichen, sagt, dass Sie jetzt die wachsende Beliebtheit von Authentifizierungsdiensten wi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Node.js Authentifizierungshandbuch ohne passport.js und Dienste von Drittanbietern</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/457700/">  Der Autor des Artikels, dessen Übersetzung wir heute veröffentlichen, sagt, dass Sie jetzt die wachsende Beliebtheit von Authentifizierungsdiensten wie Google Firebase Authentication, AWS Cognito und Auth0 beobachten können.  Generische Lösungen wie passport.js sind zum Industriestandard geworden.  Angesichts der aktuellen Situation ist es jedoch üblich geworden, dass Entwickler nie vollständig verstehen, welche Mechanismen beim Betrieb von Authentifizierungssystemen eine Rolle spielen. <br><br>  Dieses Material befasst sich mit dem Problem der Organisation der Benutzerauthentifizierung in Node.js.  In einem praktischen Beispiel werden die Organisation der Benutzerregistrierung im System und die Organisation ihres Eintritts in das System betrachtet.  Es werden Probleme wie die Arbeit mit JWT-Technologie und der Identitätswechsel von Benutzern aufgeworfen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/8q/s0/uv/8qs0uvft-oqo_nmhu1vwlpf4rjw.jpeg"></a> <br><br>  Beachten Sie auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses</a> GitHub-Repository, das den Code für das Node.js-Projekt enthält. Einige Beispiele hierfür finden Sie in diesem Artikel.  Sie können dieses Repository als Grundlage für Ihre eigenen Experimente verwenden. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Projektanforderungen</font> </h2><br>  Hier sind die Anforderungen für das Projekt, mit dem wir uns hier befassen werden: <br><br><ul><li>  Das Vorhandensein einer Datenbank, in der die E-Mail-Adresse und das Kennwort des Benutzers gespeichert werden, entweder clientId und clientSecret oder eine Kombination aus privaten und öffentlichen Schlüsseln. </li><li>  Verwenden eines starken und effizienten kryptografischen Algorithmus zum Verschlüsseln eines Kennworts. </li></ul><br>  Im Moment, in dem ich dieses Material schreibe, glaube ich, dass der beste der vorhandenen kryptografischen Algorithmen Argon2 ist.  Ich bitte Sie, keine einfachen kryptografischen Algorithmen wie SHA256, SHA512 oder MD5 zu verwenden. <br><br>  Außerdem schlage ich vor, dass Sie sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses</a> wunderbare Material ansehen, in dem Sie Details zur Auswahl eines Algorithmus für das Hashing von Passwörtern finden. <br><br><h2>  <font color="#3AC1EF">Registrierung von Benutzern im System</font> </h2><br>  Wenn ein neuer Benutzer im System erstellt wird, muss sein Kennwort gehasht und in der Datenbank gespeichert werden.  Das Kennwort wird zusammen mit der E-Mail-Adresse und anderen Informationen über den Benutzer in der Datenbank gespeichert (z. B. das Benutzerprofil, die Registrierungszeit usw.). <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> argon2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'argon2'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthService</span></span></span><span class="hljs-class"> </span></span>{   public <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> SignUp(email, password, name): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;any&gt; {     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> passwordHashed = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> argon2.hash(password);     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userRecord = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> UserModel.create({       <span class="hljs-attr"><span class="hljs-attr">password</span></span>: passwordHashed,       email,       name,     });     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {       <span class="hljs-comment"><span class="hljs-comment">//    - !!!       user: {         email: userRecord.email,         name: userRecord.name,       },       }</span></span></code> </pre> <br>  Die Benutzerkontoinformationen sollten ungefähr so ​​aussehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2b3/df3/027/2b3df30272e36e256f719b93ddf1197c.jpg"></div><br>  <i><font color="#999999">Benutzerdaten, die mit Robo3T aus MongoDB abgerufen wurden</font></i> <br><br><h2>  <font color="#3AC1EF">Benutzeranmeldung</font> </h2><br>  Hier ist ein Diagramm der Aktionen, die ausgeführt werden, wenn ein Benutzer versucht, sich anzumelden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/449/370/7e2/4493707e27d80de68619e12f8e7a8639.png"></div><br>  <i><font color="#999999">Benutzeranmeldung</font></i> <br><br>  Folgendes passiert, wenn sich ein Benutzer anmeldet: <br><br><ul><li>  Der Client sendet dem Server eine Kombination aus der öffentlichen Kennung und dem privaten Schlüssel des Benutzers.  Dies ist normalerweise eine E-Mail-Adresse und ein Passwort. </li><li>  Der Server sucht nach dem Benutzer in der Datenbank anhand der E-Mail-Adresse. </li><li>  Wenn der Benutzer in der Datenbank vorhanden ist, hascht der Server das an ihn gesendete Kennwort und vergleicht das, was passiert ist, mit dem in der Datenbank gespeicherten Kennwort-Hash. </li><li>  Wenn die Überprüfung erfolgreich ist, generiert der Server ein sogenanntes Token oder Authentifizierungstoken - JSON Web Token (JWT). </li></ul><br>  JWT ist ein temporärer Schlüssel.  Der Client muss diesen Schlüssel bei jeder Anforderung an den authentifizierten Endpunkt an den Server senden. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> argon2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'argon2'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthService</span></span></span><span class="hljs-class"> </span></span>{  public <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> Login(email, password): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;any&gt; {    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userRecord = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> UserModel.findOne({ email });    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!userRecord) {      <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'User not found'</span></span>)    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {      <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> correctPassword = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> argon2.verify(userRecord.password, password);      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!correctPassword) {        <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Incorrect password'</span></span>)            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {      <span class="hljs-attr"><span class="hljs-attr">user</span></span>: {        <span class="hljs-attr"><span class="hljs-attr">email</span></span>: userRecord.email,        <span class="hljs-attr"><span class="hljs-attr">name</span></span>: userRecord.name,      },      <span class="hljs-attr"><span class="hljs-attr">token</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.generateJWT(userRecord),    }</code> </pre> <br>  Die Kennwortüberprüfung wird mithilfe der argon2-Bibliothek durchgeführt.  Dies soll die sogenannten " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zeitangriffe</a> " verhindern.  Bei einem solchen Angriff versucht ein Angreifer, das Kennwort mit brutaler Gewalt zu knacken, basierend auf einer Analyse, wie viel Zeit der Server benötigt, um eine Antwort zu erstellen. <br><br>  Lassen Sie uns nun darüber sprechen, wie JWT generiert wird. <br><br><h2>  <font color="#3AC1EF">Was ist ein JWT?</font> </h2><br>  JSON Web Token (JWT) ist ein JSON-Objekt, das in Zeichenfolgenform codiert ist.  Tokens können als Ersatz für Cookies verwendet werden, was gegenüber ihnen mehrere Vorteile hat. <br><br>  Der Token besteht aus drei Teilen.  Dies ist der Header, die Nutzlast und die Signatur.  Die folgende Abbildung zeigt das Erscheinungsbild. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f16/a11/08d/f16a1108de7e0a5d8e4754725aacc830.jpg"></div><br>  <i><font color="#999999">Jwt</font></i> <br><br>  Token-Daten können auf der Client-Seite ohne Verwendung eines geheimen Schlüssels oder einer geheimen Signatur dekodiert werden. <br><br>  Dies kann nützlich sein, um beispielsweise Metadaten zu übertragen, die im Token codiert sind.  Solche Metadaten können die Rolle des Benutzers, sein Profil, die Dauer des Tokens usw. beschreiben.  Sie können für den Einsatz in Front-End-Anwendungen vorgesehen sein. <br><br>  So könnte ein dekodierter Token aussehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e5/734/5fa/3e57345fafedf8eaa0d326190aa03b47.jpg"></div><br>  <i><font color="#999999">Decodiertes Token</font></i> <br><br><h2>  <font color="#3AC1EF">JWT in Node.js generieren</font> </h2><br>  Lassen Sie uns die Funktion <code>generateToken</code> erstellen, die wir benötigen, um die Arbeit am Benutzerauthentifizierungsdienst abzuschließen. <br><br>  Sie können JWT mithilfe der jsonwebtoken-Bibliothek erstellen.  Sie finden diese Bibliothek in npm. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> jwt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'jsonwebtoken'</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthService</span></span></span><span class="hljs-class"> </span></span>{  private generateToken(user) {    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = {      <span class="hljs-attr"><span class="hljs-attr">_id</span></span>: user._id,      <span class="hljs-attr"><span class="hljs-attr">name</span></span>: user.name,      <span class="hljs-attr"><span class="hljs-attr">email</span></span>: user.email    };    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> signature = <span class="hljs-string"><span class="hljs-string">'MySuP3R_z3kr3t'</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> expiration = <span class="hljs-string"><span class="hljs-string">'6h'</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jwt.sign({ data, }, signature, { <span class="hljs-attr"><span class="hljs-attr">expiresIn</span></span>: expiration }); }</code> </pre> <br>  Das Wichtigste dabei sind die verschlüsselten Daten.  Senden Sie keine geheimen Benutzerinformationen in Token. <br><br>  Eine Signatur (hier ist die <code>signature</code> ) sind die geheimen Daten, die zum Generieren der JWT verwendet werden.  Es ist sehr wichtig sicherzustellen, dass die Unterschrift nicht in die falschen Hände gerät.  Wenn die Signatur kompromittiert wird, kann der Angreifer im Namen der Benutzer Token generieren und deren Sitzungen stehlen. <br><br><h2>  <font color="#3AC1EF">Endpoint Protection und JWT-Validierung</font> </h2><br>  Jetzt muss der Client-Code bei jeder Anforderung eine JWT an einen sicheren Endpunkt senden. <br><br>  Es wird empfohlen, JWT in die Anforderungsheader aufzunehmen.  Sie sind normalerweise im Authorization-Header enthalten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5c/4dd/19d/b5c4dd19dfd705c210c9b4f5ce5212cf.jpg"></div><br>  <i><font color="#999999">Autorisierungsheader</font></i> <br><br>  Jetzt müssen Sie auf dem Server Code erstellen, der Middleware für Expressrouten ist.  <code>isAuth.ts</code> Sie diesen Code in die Datei <code>isAuth.ts</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> jwt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'express-jwt'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      ,  JWT      Authorization,        req.body,    ,      ,     . const getTokenFromHeader = (req) =&gt; {  if (req.headers.authorization &amp;&amp; req.headers.authorization.split(' ')[0] === 'Bearer') {    return req.headers.authorization.split(' ')[1]; } export default jwt({  secret: 'MySuP3R_z3kr3t', //      ,     JWT  userProperty: 'token', //       ,     services/auth:generateToken -&gt; 'req.token'  getToken: getTokenFromHeader, //        })</span></span></code> </pre> <br>  Es ist hilfreich, vollständige Informationen über das Benutzerkonto aus der Datenbank abrufen und an die Anforderung anhängen zu können.  In unserem Fall wird diese Funktion mithilfe von Middleware aus der Datei <code>attachCurrentUser.ts</code> implementiert.  Hier ist der vereinfachte Code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> (req, res, next) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> decodedTokenData = req.tokenData; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userRecord = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> UserModel.findOne({ <span class="hljs-attr"><span class="hljs-attr">_id</span></span>: decodedTokenData._id })  req.currentUser = userRecord; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!userRecord) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res.status(<span class="hljs-number"><span class="hljs-number">401</span></span>).end(<span class="hljs-string"><span class="hljs-string">'User not found'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> next(); }</code> </pre> <br>  Nach der Implementierung dieses Mechanismus können Routen Informationen über den Benutzer empfangen, der die Anforderung ausführt: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> isAuth <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../middlewares/isAuth'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> attachCurrentUser <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../middlewares/attachCurrentUser'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ItemsModel <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../models/items'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> (app) =&gt; {    app.get(<span class="hljs-string"><span class="hljs-string">'/inventory/personal-items'</span></span>, isAuth, attachCurrentUser, (req, res) =&gt; {      <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = req.currentUser;      <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userItems = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> ItemsModel.find({ <span class="hljs-attr"><span class="hljs-attr">owner</span></span>: user._id });      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res.json(userItems).status(<span class="hljs-number"><span class="hljs-number">200</span></span>);    })</code> </pre> <br>  Die Route für <code>inventory/personal-items</code> ist jetzt geschützt.  Um darauf zugreifen zu können, muss der Benutzer über eine gültige JWT verfügen.  Eine Route kann außerdem Benutzerinformationen verwenden, um die Datenbank nach den benötigten Informationen zu durchsuchen. <br><br><h2>  <font color="#3AC1EF">Warum sind Token vor Eindringlingen geschützt?</font> </h2><br>  Nachdem Sie die Verwendung von JWT gelesen haben, stellen Sie sich möglicherweise die folgende Frage: „Wenn JWT-Daten auf der Clientseite dekodiert werden können, ist es dann möglich, das Token so zu verarbeiten, dass die Benutzer-ID oder andere Daten geändert werden?“. <br><br>  Token-Dekodierung - der Vorgang ist sehr einfach.  Sie können dieses Token jedoch nicht "wiederholen", ohne diese Signatur zu haben, die geheimen Daten, die beim Signieren des JWT auf dem Server verwendet wurden. <br><br>  Deshalb ist der Schutz dieser sensiblen Daten so wichtig. <br><br>  Unser Server überprüft die Signatur in der isAuth-Middleware.  Die Express-JWT-Bibliothek ist für die Überprüfung verantwortlich. <br><br>  Nachdem wir herausgefunden haben, wie die JWT-Technologie funktioniert, lassen Sie uns nun einige interessante zusätzliche Funktionen besprechen, die sie uns bietet. <br><br><h2>  <font color="#3AC1EF">Wie kann man sich als Benutzer ausgeben?</font> </h2><br>  Der Benutzeridentitätswechsel ist eine Technik, mit der Sie sich als bestimmter Benutzer bei einem System anmelden, ohne sein Kennwort zu kennen. <br><br>  Diese Funktion ist sehr nützlich für Superadministratoren, Entwickler oder Supportmitarbeiter.  Mit dem Identitätswechsel können sie Probleme lösen, die nur bei Benutzern auftreten, die mit dem System arbeiten. <br><br>  Sie können im Namen des Benutzers mit der Anwendung arbeiten, ohne sein Passwort zu kennen.  Dazu reicht es aus, eine JWT mit der richtigen Signatur und den erforderlichen Metadaten zu generieren, die den Benutzer beschreiben. <br><br>  Erstellen Sie einen Endpunkt, der unter dem Deckmantel bestimmter Benutzer Token für die Eingabe in das System generieren kann.  Nur der Superadministrator des Systems kann diesen Endpunkt verwenden. <br><br>  Für den Anfang müssen wir diesem Benutzer eine Rolle mit einer höheren Berechtigungsstufe als anderen Benutzern zuweisen.  Dies kann auf viele verschiedene Arten erfolgen.  Fügen Sie beispielsweise einfach das Rollenfeld zu den in der Datenbank gespeicherten Benutzerinformationen hinzu. <br><br>  Es kann wie das unten gezeigte aussehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f69/c19/30e/f69c1930ec89fdf649d73772cc7754bc.jpg"></div><br>  <i><font color="#999999">Neues Feld in den Benutzerinformationen</font></i> <br><br>  Der Wert des <code>super-admin</code> ist <code>super-admin</code> . <br><br>  Als Nächstes müssen Sie eine neue Middleware erstellen, die die Benutzerrolle überprüft: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> (requiredRole) =&gt; {  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res, next</span></span></span><span class="hljs-function">) =&gt;</span></span> {    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(req.currentUser.role === requiredRole) {      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> next();    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res.status(<span class="hljs-number"><span class="hljs-number">401</span></span>).send(<span class="hljs-string"><span class="hljs-string">'Action not allowed'</span></span>);    }</code> </pre> <br>  Es sollte nach isAuth und attachCurrentUser platziert werden.  Erstellen Sie nun den Endpunkt, der die JWT für den Benutzer generiert, für den sich der Superadministrator anmelden möchte: <br><br><pre> <code class="javascript hljs">  <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> isAuth <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../middlewares/isAuth'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> attachCurrentUser <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../middlewares/attachCurrentUser'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> roleRequired <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../middlwares/roleRequired'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UserModel <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../models/user'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> (app) =&gt; {    app.post(<span class="hljs-string"><span class="hljs-string">'/auth/signin-as-user'</span></span>, isAuth, attachCurrentUser, roleRequired(<span class="hljs-string"><span class="hljs-string">'super-admin'</span></span>), (req, res) =&gt; {      <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userEmail = req.body.email;      <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userRecord = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> UserModel.findOne({ <span class="hljs-attr"><span class="hljs-attr">email</span></span>: userEmail });      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!userRecord) {        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res.status(<span class="hljs-number"><span class="hljs-number">404</span></span>).send(<span class="hljs-string"><span class="hljs-string">'User not found'</span></span>);           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res.json({        <span class="hljs-attr"><span class="hljs-attr">user</span></span>: {          <span class="hljs-attr"><span class="hljs-attr">email</span></span>: userRecord.email,          <span class="hljs-attr"><span class="hljs-attr">name</span></span>: userRecord.name        },        <span class="hljs-attr"><span class="hljs-attr">jwt</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.generateToken(userRecord)      })      .status(<span class="hljs-number"><span class="hljs-number">200</span></span>);    })</code> </pre> <br>  Wie Sie sehen können, gibt es nichts Geheimnisvolles.  Der Superadministrator kennt die E-Mail-Adresse des Benutzers, für den Sie sich anmelden möchten.  Die Logik des obigen Codes erinnert sehr an die Funktionsweise des Codes und liefert eine Eingabe für das System normaler Benutzer.  Der Hauptunterschied besteht darin, dass das Passwort hier nicht überprüft wird. <br>  Das Passwort wird hier nicht verifiziert, da es hier einfach nicht benötigt wird.  Die Endpunktsicherheit wird durch Middleware bereitgestellt. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Es ist nichts Falsches daran, sich auf Authentifizierungsdienste und Bibliotheken von Drittanbietern zu verlassen.  Dies hilft Entwicklern, Zeit zu sparen.  Sie müssen jedoch auch wissen, auf welchen Prinzipien der Betrieb von Authentifizierungssystemen basiert und was die Funktionsweise solcher Systeme sicherstellt. <br><br>  In diesem Artikel haben wir die Möglichkeiten der JWT-Authentifizierung untersucht und über die Bedeutung der Auswahl eines guten kryptografischen Algorithmus für das Hashing von Passwörtern gesprochen.  Wir haben die Erstellung eines Benutzeridentitätswechselmechanismus untersucht. <br><br>  Dasselbe mit so etwas wie passport.js zu tun, ist alles andere als einfach.  Authentifizierung ist ein großes Thema.  Vielleicht kehren wir zu ihr zurück. <br><br>  <b>Liebe Leser!</b>  Wie erstellen Sie Authentifizierungssysteme für Ihre Node.js-Projekte? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/a09/9e4/5a8/a099e45a81c9dafd3a3673edd5ea415b.jpg"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457700/">https://habr.com/ru/post/de457700/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de457690/index.html">Paranoides Video von Yandex.Money metap</a></li>
<li><a href="../de457692/index.html">Überlegungen zu nationalen NB-Fi-Standard- und Abrechnungssystemen</a></li>
<li><a href="../de457694/index.html">Die Gefahren der Verwendung von Konstanten mit mehreren Zeichen</a></li>
<li><a href="../de457696/index.html">Die Gefahren der Verwendung von Konstanten mit mehreren Zeichen</a></li>
<li><a href="../de457698/index.html">Experiment: Wir verwenden Proxys als Werkzeug zur Bekämpfung von DoS-Angriffen</a></li>
<li><a href="../de457702/index.html">Arbeiten Sie mit der KOMPAS-3D-API → Lektion 16 → Steuerzeichen</a></li>
<li><a href="../de457704/index.html">Wie GPUs mit Verzweigungen umgehen</a></li>
<li><a href="../de457706/index.html">Roboter testet SAP ERP</a></li>
<li><a href="../de457710/index.html">Die erstaunlichen Eigenschaften neuronaler Netze 2019</a></li>
<li><a href="../de457712/index.html">Wie Verizon und BGP Optimizer sich offline hervorragend einrichten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>