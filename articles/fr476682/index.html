<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí£ üë©üèΩ‚Äçü§ù‚Äçüë©üèª ü§ûüèª Comment √©crire un sapeur dans Phaser et ex√©cuter une t√¢che de test de d√©veloppeur HTML5 üë©üèæ‚Äçüéì ü•£ üßìüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, chers coll√®gues! 

 Je m'appelle Alexander, je suis d√©veloppeur de jeux HTML5. 

 Dans l'une des entreprises o√π j'ai envoy√© mon CV, on m'a de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment √©crire un sapeur dans Phaser et ex√©cuter une t√¢che de test de d√©veloppeur HTML5</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476682/"> Bonjour, chers coll√®gues! <br><br>  Je m'appelle Alexander, je suis d√©veloppeur de jeux HTML5. <br><br>  Dans l'une des entreprises o√π j'ai envoy√© mon CV, on m'a demand√© de terminer une t√¢che de test.  J'ai accept√© et, apr√®s 1 jour, j'ai envoy√© le jeu d√©velopp√© conform√©ment aux TOR HTML5. <br><br><img src="https://habrastorage.org/webt/4t/ng/dn/4tngdnvlxq3izqrpk2nykww2dvs.png"><br><br>  √âtant donn√© que je m'entra√Æne √† la programmation de jeux, ainsi qu'√† une utilisation plus efficace de mon code, j'ai d√©cid√© qu'il serait utile d'√©crire un article de formation sur le projet termin√©.  Et puisque le test termin√© a re√ßu une √©valuation positive et a conduit √† une invitation √† un entretien, ma d√©cision a probablement le droit d'exister et, peut-√™tre, aidera quelqu'un √† l'avenir. <br><br>  Cet article donnera une id√©e de la quantit√© de travail suffisante pour r√©ussir la t√¢che de test moyenne pour le poste de d√©veloppeur HTML5.  Le mat√©riel peut √©galement int√©resser quiconque souhaite se familiariser avec le cadre Phaser.  Et si vous travaillez d√©j√† avec Phaser et que vous √©crivez en JS - voyez comment d√©velopper un projet en TypeScript. <br><br>  Donc, sous cat, il y a beaucoup de code TypeScript! <br><a name="habracut"></a><br><h2>  Pr√©sentation </h2><br>  Nous donnons un bref expos√© du probl√®me. <br><br><ol><li>  Nous allons d√©velopper un jeu HTML5 simple - un sapeur classique. </li><li>  Comme outils principaux, nous utiliserons phaser 3, dactylographi√© et webpack. </li><li>  Le jeu sera con√ßu pour le bureau et ex√©cut√© dans le navigateur. </li></ol><br>  Nous fournissons des liens vers le projet final. <br><br><div class="spoiler">  <b class="spoiler_title">Liens vers la d√©mo et la source</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">D√©mo jouable</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Code source GitHub</a> <br></div></div><br>  Et rappelez-vous la m√©canique du sapeur, si tout √† coup quelqu'un oublie les r√®gles du jeu.  Mais comme il s'agit d'un cas peu probable, les r√®gles sont plac√©es sous le spoiler :) <br><br><div class="spoiler">  <b class="spoiler_title">R√®gles du sapeur</b> <div class="spoiler_text">  Le terrain de jeu se compose de cellules dispos√©es dans une table.  Par d√©faut, lorsque le jeu d√©marre, toutes les cellules sont ferm√©es.  Des bombes sont plac√©es dans certaines cellules. <br><br>  Lorsque vous cliquez avec le bouton gauche sur une cellule ferm√©e, elle s'ouvre.  S'il y avait une bombe dans une cellule ouverte, le jeu se termine par la d√©faite. <br><br>  S'il n'y avait pas de bombe dans la cellule, un nombre s'affiche √† l'int√©rieur, indiquant le nombre de bombes qui se trouvent dans les cellules voisines par rapport √† l'ouverture actuelle.  S'il n'y a pas de bombes √† proximit√©, la cellule semble vide. <br><br>  Un clic droit sur une cellule ferm√©e d√©finit un indicateur dessus.  La t√¢che du joueur est d'organiser tous les drapeaux √† sa disposition afin qu'ils marquent toutes les cellules min√©es.  Apr√®s avoir plac√© tous les drapeaux, le joueur appuie sur le bouton gauche de la souris sur l'une des cellules ouvertes pour v√©rifier s'il a gagn√©. <br></div></div><br>  Ensuite, nous allons directement au manuel lui-m√™me.  Tout le mat√©riel est divis√© en petites √©tapes, chacune d√©crivant la mise en ≈ìuvre d'une t√¢che sp√©cifique en peu de temps.  Ainsi, en effectuant de petits objectifs √©tape par √©tape, nous allons finalement cr√©er un jeu √† part enti√®re.  Utilisez la table des mati√®res si vous d√©cidez de passer rapidement √† une √©tape sp√©cifique. <br><br><div class="spoiler">  <b class="spoiler_title">Table des mati√®res</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1. Pr√©paration</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.1 Mod√®le de projet</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.2 Configuration de la construction</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.3 Installation de modules</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.4 Pr√©paration des actifs</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2. Cr√©ation de sc√®nes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.1 Point d'entr√©e</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.2 Sc√®ne de d√©part</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.3 Textes de la sc√®ne de d√©part</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.4 Transition au niveau du jeu</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sc√®ne de niveau 2.5</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.6 R√©glage des sc√®nes au point d'entr√©e</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3. Objets de jeu</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.1 Plateau de jeu</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.2 Mod√®le de cellule</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.3 Vue des cellules</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.4 Cr√©ation d'un sprite dans une classe de vue</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.5 Positionnement des sprites</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.6 Cr√©ation d'une instance de FieldView</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.7 Afficher les champs de la carte.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.8 Fabrication de bombes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.9 R√©glage des valeurs</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4. Gestion des √©v√©nements d'entr√©e</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.1 Suivi des √©v√©nements de clic de souris</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Traitement du clic gauche</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.4 Traitement du clic droit</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.5 Objet GameSceneView</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">5. Animations</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">5.1 Animation de remplissage du tableau</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">5.2 Animations de retournement de cellule</a> <br></div></div><br><a name="section-1"></a><h2>  <font color="#008080">1. Pr√©paration</font> </h2><br><a name="section-1-1"></a><h3>  <font color="#008080">1.1 Mod√®le de projet</font> </h3><br>  T√©l√©chargez le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mod√®le de projet phaser par d√©faut</a> .  Il s'agit du mod√®le recommand√© par l'auteur du framework et il nous offre la structure de r√©pertoires suivante: <br><div class="scrollable-table"><table><tbody><tr><td>  index.html </td><td colspan="2">  Page HTML de lancement du jeu </td></tr><tr><td rowspan="2">  webpack / </td><td>  base.js </td><td>  construire la configuration pour l'environnement de test </td></tr><tr><td>  prod.js </td><td>  construire la configuration pour la production </td></tr><tr><td rowspan="2">  src / </td><td>  atouts / </td><td>  ressources du jeu (sprites, sons, polices) </td></tr><tr><td>  index.js </td><td>  point d'entr√©e </td></tr></tbody></table></div> Pour notre projet, nous n'avons pas besoin du fichier <code>index.js</code> actuel, donc supprimez-le.  Cr√©ez ensuite le r√©pertoire <code>/src/scripts/</code> et placez-y le fichier <code>index.ts</code> vide.  Nous ajouterons tous nos scripts √† ce dossier. <br>  Il convient √©galement de garder √† l'esprit que lors de la construction d'un projet pour la production, un r√©pertoire <code>dist</code> sera cr√©√© √† la racine, dans lequel la version sera plac√©e. <br><br><a name="section-1-2"></a><h3>  <font color="#008080">1.2 Configuration de la construction</font> </h3><br>  Nous utiliserons le webpack pour l'assemblage.  √âtant donn√© que notre mod√®le a √©t√© initialement pr√©par√© pour fonctionner avec JavaScript et que nous √©crivons en TypeScript, nous devons apporter de petites modifications √† la configuration du collecteur. <br><br>  Dans le <code>webpack/base.js</code> ajoutez la cl√© d' <code>entry</code> , qui indique le point d'entr√©e lors de la construction de notre projet, ainsi que la configuration <code>ts-loader</code> qui d√©crit les r√®gles de construction des scripts TS: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// webpack/base.js //... module.exports = { entry: './src/scripts/index.ts', // ... resolve: { extensions: [ '.ts', '.tsx', '.js' ] }, module: { rules: [{ test: /\.tsx?$/, use: 'ts-loader', exclude: /node_modules/ }, //...</span></span></code> </pre><br>  Nous devrons √©galement cr√©er le fichier tsconfig.json √† la racine du projet.  Pour moi, il a le contenu suivant: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"compilerOptions"</span></span>: { <span class="hljs-string"><span class="hljs-string">"module"</span></span>: <span class="hljs-string"><span class="hljs-string">"commonjs"</span></span>, <span class="hljs-string"><span class="hljs-string">"lib"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"dom"</span></span>, <span class="hljs-string"><span class="hljs-string">"es5"</span></span>, <span class="hljs-string"><span class="hljs-string">"es6"</span></span>, <span class="hljs-string"><span class="hljs-string">"es2015"</span></span>, <span class="hljs-string"><span class="hljs-string">"es2017"</span></span>, <span class="hljs-string"><span class="hljs-string">"es2015.promise"</span></span> ], <span class="hljs-string"><span class="hljs-string">"target"</span></span>: <span class="hljs-string"><span class="hljs-string">"es5"</span></span>, <span class="hljs-string"><span class="hljs-string">"skipLibCheck"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-string"><span class="hljs-string">"exclude"</span></span>: [<span class="hljs-string"><span class="hljs-string">"node_modules"</span></span>, <span class="hljs-string"><span class="hljs-string">"dist"</span></span>] }</code> </pre> <br><a name="section-1-3"></a><h3>  <font color="#008080">1.3 Installation de modules</font> </h3><br>  Installez toutes les d√©pendances de package.json et ajoutez-y les modules typescript et ts-loader: <br><br><pre> <code class="plaintext hljs">npm i npm i typescript --save-dev npm i ts-loader --save-dev</code> </pre><br>  Le projet est maintenant pr√™t √† d√©marrer le d√©veloppement.  Nous avons 2 commandes √† notre disposition qui sont d√©j√† d√©finies dans la propri√©t√© <code>scripts</code> du fichier <code>package.json</code> . <br><br><ol><li>  Construire un projet de d√©bogage et ouvrir dans un navigateur via un serveur local <br><br><pre> <code class="plaintext hljs">npm start</code> </pre> </li><li>  Ex√©cutez la version √† vendre et placez la version finale dans le dossier dist / <br><br><pre> <code class="plaintext hljs">npm run build</code> </pre> </li></ol><br><a name="section-1-4"></a><h3>  <font color="#008080">1.4 Pr√©paration des actifs</font> </h3><br>  Tous les actifs de ce jeu sont honn√™tement t√©l√©charg√©s depuis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OpenGameArt</a> (version 61x61) et ont la plus conviviale des licences appel√©e <i>N'h√©sitez pas √† utiliser</i> , ce que la page avec le pack nous dit soigneusement).  Soit dit en passant, le code pr√©sent√© dans l'article a la m√™me licence!  ;) <br><br>  J'ai supprim√© l'image d'horloge de l'ensemble t√©l√©charg√© et renomm√© le reste des fichiers afin d'obtenir des noms de trame faciles √† utiliser.  La liste des noms et des fichiers correspondants s'affiche sur l'√©cran ci-dessous. <br><br>  √Ä partir des sprites r√©sultants, nous allons cr√©er un atlas au format <code>Phaser JSONArray</code> dans le programme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TexturePacker</a> (il y a plus qu'assez d'une version gratuite, je n'ai encore re√ßu aucun travail) et placer les fichiers <code>spritesheet.png</code> et <code>spritesheet.json</code> dans le r√©pertoire du projet <code>src/assets/</code> . <br><br><img src="https://habrastorage.org/webt/ms/ki/z9/mskiz9zmuidbxk8hhcbksfmny4k.png"><br><br><a name="section-2"></a><h2>  <font color="#008080">2. Cr√©ation de sc√®nes</font> </h2><br><a name="section-2-1"></a><h3>  <font color="#008080">2.1 Point d'entr√©e</font> </h3><br>  Nous commen√ßons le d√©veloppement en cr√©ant le point d'entr√©e d√©crit dans la configuration du webpack. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// src/scripts/index.ts import * as Phaser from "phaser"; new Phaser.Game({ type: Phaser.AUTO, parent: "minesweeper", width: window.innerWidth, height: window.innerHeight, backgroundColor: "#F0FFFF", scene: [] });</span></span></code> </pre><br>  √âtant donn√© que le jeu que nous avons est con√ßu pour le bureau et remplira tout l'√©cran, nous utilisons hardiment toute la largeur et la hauteur du navigateur pour les champs de <code>width</code> et de <code>height</code> . <br>  Le champ de <code>scene</code> est actuellement un tableau vide et nous allons le corriger! <br><br><a name="section-2-2"></a><h3>  <font color="#008080">2.2 Sc√®ne de d√©part</font> </h3><br>  Cr√©ez la classe de la premi√®re sc√®ne dans le <code>src/scripts/scenes/StartScene.ts</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StartScene</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Scene</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(<span class="hljs-string"><span class="hljs-string">'Start'</span></span>); } public preload(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } public create(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } }</code> </pre><br>  Pour un h√©ritage valide de <code>Phaser.Scene</code> nous transmettons le nom de la sc√®ne en tant que param√®tre au constructeur de la classe parente. <br><br>  Cette sc√®ne combinera la fonctionnalit√© de pr√©chargement des ressources et l'√©cran de d√©marrage, invitant l'utilisateur au jeu. <br><br>  Habituellement, dans mes projets, un joueur passe par deux sc√®nes avant d'arriver √† la premi√®re, dans cet ordre: <br><br><pre> <code class="plaintext hljs">Boot =&gt; Preload =&gt; Start</code> </pre><br>  Mais dans ce cas, le jeu est si simple, et il y a si peu de ressources qu'il n'y a aucune raison de mettre la pr√©charge dans une sc√®ne distincte et encore plus de faire le chargeur de <code>Boot</code> s√©par√© initial. <br><br>  Nous chargerons tous les actifs dans la m√©thode de <code>preload</code> .  Afin de pouvoir travailler avec l'atlas cr√©√© √† l'avenir, nous devons effectuer 2 √©tapes: <br><br><ol><li>  obtenir les fichiers atlas <code>png</code> et <code>json</code> en utilisant <code>require</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.ts const spritesheetPng = require("./../../assets/spritesheet.png"); const spritesheetJson = require("./../../assets/spritesheet.json"); // ...</span></span></code> </pre><br></li><li>  chargez-les dans la m√©thode de <code>preload</code> de la sc√®ne de d√©part: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.ts // ... public preload(): void { this.load.atlas("spritesheet", spritesheetPng, spritesheetJson); } // ...</span></span></code> </pre><br></li></ol><br><a name="section-2-3"></a><h3>  <font color="#008080">2.3 Textes de la sc√®ne de d√©part</font> </h3><br>  Il reste 2 choses √† faire dans la sc√®ne de d√©part: <br><br><ol><li>  dire au joueur comment d√©marrer le jeu </li><li>  lancer le jeu √† l'initiative du joueur </li></ol><br>  Pour r√©pondre au premier point, nous cr√©ons d'abord deux √©num√©rations au d√©but du fichier de sc√®ne pour d√©crire les textes et leurs styles: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.js enum Texts { Title = 'Minesweeper HTML5', Message = 'Click anywhere to start' } enum Styles { Color = '#008080', Font = 'Arial' } //...</span></span></code> </pre><br>  Et puis cr√©ez les deux textes en tant qu'objets dans la m√©thode <code>create</code> .  Permettez-moi de vous rappeler que la m√©thode de <code>create</code> de sc√®nes dans <code>Phaser</code> ne sera appel√©e qu'apr√®s le chargement de toutes les ressources dans la m√©thode de <code>preload</code> et cela nous convient parfaitement. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.js //... public create(): void { this.add.text( this.cameras.main.centerX, this.cameras.main.centerY - 100, Texts.Title, {font: `52px ${Styles.Font}`, fill: Styles.Color}) .setOrigin(0.5); this.add.text( this.cameras.main.centerX, this.cameras.main.centerY + 100, Texts.Message, {font: `28px ${Styles.Font}`, fill: Styles.Color}) .setOrigin(0.5); } //...</span></span></code> </pre><br>  Dans un autre projet plus vaste, nous pourrions prendre les textes et les styles soit dans des fichiers locaux json soit dans des configurations distinctes, mais √©tant donn√© que nous n'avons maintenant que 2 lignes, je consid√®re cette √©tape redondante et dans ce cas, je sugg√®re de ne pas compliquer nos vies, nous limiter aux listes au d√©but du fichier de sc√®ne. <br><br><a name="section-2-4"></a><h3>  <font color="#008080">2.4 Transition au niveau du jeu</font> </h3><br>  La derni√®re chose que nous ferons dans cette sc√®ne avant de continuer est de suivre l'√©v√©nement de clic de souris pour lancer le joueur dans le jeu: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.js //... public create(): void { //... this.input.once('pointerdown', () =&gt; { this.scene.start('Game'); }); } //...</span></span></code> </pre> <br><a name="section-2-5"></a><h3>  <font color="#008080">Sc√®ne de niveau 2.5</font> </h3><br>  A en juger par le param√®tre <code>"Game"</code> pass√© √† la m√©thode <code>this.scene.start</code> vous avez d√©j√† devin√© qu'il √©tait temps de cr√©er une deuxi√®me sc√®ne, qui traiterait la logique principale du jeu.  Cr√©ez le <code>src/scripts/scenes/GameScene.ts</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameScene</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Scene</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(<span class="hljs-string"><span class="hljs-string">'Game'</span></span>); } public create(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } }</code> </pre><br>  Dans cette sc√®ne, nous n'avons pas besoin de la m√©thode de <code>preload</code> car  nous avons d√©j√† charg√© toutes les ressources n√©cessaires dans la sc√®ne pr√©c√©dente. <br><br><a name="section-2-6"></a><h3>  <font color="#008080">2.6 R√©glage des sc√®nes au point d'entr√©e</font> </h3><br>  Maintenant que les deux sc√®nes sont cr√©√©es, ajoutez-les √† notre point d'entr√©e <br>  <code>src/scripts/index.ts</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//... import { StartScene } from "./scenes/StartScene"; import { GameScene } from "./scenes/GameScene"; //... new Phaser.Game({ // ... scene: [StartScene, GameScene] });</span></span></code> </pre><br><a name="section-3"></a><h2>  <font color="#008080">3. Objets de jeu</font> </h2><br>  Ainsi, la classe <code>GameScene</code> impl√©mentera la logique au niveau du jeu.  Et qu'attendons-nous du niveau de jeu des sapeurs?  Visuellement, nous nous attendons √† voir un terrain de jeu avec des cellules ferm√©es.  Nous savons que le champ est une table, ce qui signifie qu'il a un nombre donn√© de lignes et de colonnes, dans plusieurs desquelles les bombes sont confortablement plac√©es.  Ainsi, nous avons suffisamment d'informations pour cr√©er une entit√© distincte qui d√©crit le terrain de jeu. <br><br><a name="section-3-1"></a><h3>  <font color="#008080">3.1 Plateau de jeu</font> </h3><br>  Cr√©ez le <code>src/scripts/models/Board.ts</code> dans lequel nous <code>src/scripts/models/Board.ts</code> la classe <code>Board</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Field } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./Field"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Board</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Events</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventEmitter</span></span></span><span class="hljs-class"> </span></span>{ private _scene: Phaser.Scene = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; private _rows: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; private _cols: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; private _bombs: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; private _fields: Field[] = []; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(scene: Phaser.Scene, rows: number, cols: number, bombs: number) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._scene = scene; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._rows = rows; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._cols = cols; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._bombs = bombs; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._fields = []; } public get cols(): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._cols; } public get rows(): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._rows; } }</code> </pre> <br>  Faisons de la classe le successeur de Phaser.Events.EventEmitter afin d'acc√©der √† l'interface d'enregistrement et d'appel des √©v√©nements, dont nous aurons besoin √† l'avenir. <br><br>  Un tableau d'objets de la classe <code>Field</code> sera stock√© dans la propri√©t√© priv√©e <code>_fields</code> .  Nous impl√©menterons ce mod√®le plus tard. <br><br>  Nous avons configur√© des propri√©t√©s num√©riques priv√©es <code>_rows</code> et <code>_cols</code> pour indiquer le nombre de lignes et de colonnes du terrain de jeu.  Cr√©ez des getters publics pour lire les <code>_rows</code> et les <code>_cols</code> . <br><br>  Le champ <code>_bombs</code> nous indique le nombre de bombes qui devront √™tre g√©n√©r√©es pour le niveau.  Et dans le param√®tre <code>_scene</code> nous passons une r√©f√©rence √† l'objet de la sc√®ne de jeu <code>GameScene</code> , dans lequel nous allons cr√©er une instance de la classe <code>Board</code> . <br><br>  Il convient de noter que nous transf√©rons l'objet de sc√®ne au mod√®le uniquement pour une transmission ult√©rieure aux vues, o√π nous ne l'utiliserons que pour afficher la vue.  Le fait est que le phaseur utilise directement l'objet sc√®ne pour rendre les sprites et nous oblige donc √† fournir un lien vers la sc√®ne actuelle lors de la cr√©ation de pr√©fabriqu√©s sprite, que nous d√©velopperons √† l'avenir.  Et pour nous-m√™mes, nous accepterons que nous transf√©rions le lien vers la sc√®ne uniquement pour son utilisation ult√©rieure en tant que moteur d'affichage et convenons que nous n'appellerons pas directement les m√©thodes personnalis√©es de la sc√®ne dans les mod√®les et les vues. <br><br>  Une fois que nous avons d√©cid√© de l'interface de cr√©ation de la carte, je propose de l'initialiser dans la sc√®ne de niveau, en finalisant la classe <code>GameScene</code> : <br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">// GameScene.ts import { Board } from "../models/Board"; const Rows = 8; const Cols = 8; const Bombs = 8; export class GameScene extends Phaser.Scene { private _board: Board = null; //... public create(): void { this._board = new Board(this, Rows, Cols, Bombs); } }</span></span></code> </pre> <br>  Nous prenons les param√®tres de la carte en constantes au d√©but du fichier de sc√®ne et les transmettons au constructeur de la carte lors de la cr√©ation d'une instance de cette classe. <br><br><a name="section-3-2"></a><h3>  <font color="#008080">3.2 Mod√®le de cellule</font> </h3><br>  Le tableau se compose de cellules que vous souhaitez afficher √† l'√©cran.  Chaque cellule doit √™tre plac√©e √† la position correspondante, d√©termin√©e par la ligne et la colonne. <br><br>  Les cellules sont √©galement s√©lectionn√©es en tant qu'entit√© distincte.  Cr√©ez le <code>src/scripts/models/Field.ts</code> dans lequel nous <code>src/scripts/models/Field.ts</code> la classe qui d√©crit la cellule: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Board } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./Board"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Field</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Events</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventEmitter</span></span></span><span class="hljs-class"> </span></span>{ private _scene: Phaser.Scene = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; private _board: Board = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; private _row: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; private _col: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(scene: Phaser.Scene, board: Board, row: number, col: number) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._init(scene, board, row, col); } public get col(): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._col; } public get row(): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._row; } public get board(): Board { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._board; } private _init(scene: Phaser.Scene, <span class="hljs-attr"><span class="hljs-attr">board</span></span>: Board, <span class="hljs-attr"><span class="hljs-attr">row</span></span>: number, <span class="hljs-attr"><span class="hljs-attr">col</span></span>: number): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._scene = scene; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._board = board; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._row = row; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._col = col; } }</code> </pre><br>  Chaque cellule doit avoir des m√©triques de ligne et de colonne dans lesquelles elle se trouve.  Nous avons configur√© les param√®tres <code>_board</code> et <code>_scene</code> pour d√©finir des liens vers les objets du tableau et de la sc√®ne.  Nous impl√©mentons des getters pour lire les <code>_row</code> , <code>_col</code> et <code>_board</code> . <br><br><a name="section-3-3"></a><h3>  <font color="#008080">3.3 Vue des cellules</font> </h3><br>  La cellule abstraite est cr√©√©e et maintenant nous voulons la visualiser.  Pour afficher une cellule √† l'√©cran, vous devez cr√©er sa vue.  Cr√©ez le <code>src/scripts/views/FieldView.ts</code> et placez-y la classe de vue: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Field } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"../models/Field"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FieldView</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameObjects</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sprite</span></span></span><span class="hljs-class"> </span></span>{ private _model: Field = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(scene: Phaser.Scene, model: Field) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(scene, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'spritesheet'</span></span>, <span class="hljs-string"><span class="hljs-string">'closed'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._model = model; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._init(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._create(); } private _init(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } private _create(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } }</code> </pre><br>  Veuillez noter que nous avons fait de cette classe le descendant de <code>Phaser.GameObjects.Sprite</code> .  En termes de phaser, cette classe est devenue un pr√©fabriqu√© sprite.  Autrement dit, j'ai obtenu la fonctionnalit√© de l'objet de jeu du sprite, que nous d√©velopperons davantage avec nos propres m√©thodes. <br><br>  Regardons le constructeur de cette classe.  Ici, tout d'abord, nous devons appeler le constructeur de la classe parente avec les ensembles de param√®tres suivants: <br><br><ul><li>  lien vers l'objet sc√®ne (comme je l'avais pr√©venu dans la section 3.1: phaser nous oblige √† cr√©er un lien vers la sc√®ne actuelle afin de rendre les sprites) </li><li>  Coordonn√©es <code>x</code> et <code>y</code> sur toile </li><li>  la cl√© de cha√Æne pour laquelle l'atlas est disponible, que nous avons charg√©e dans la m√©thode de <code>preload</code> de la sc√®ne de d√©part </li><li>  la cl√© de cha√Æne de trame dans cet atlas que vous souhaitez s√©lectionner pour afficher le sprite </li></ul><br>  D√©finissez une r√©f√©rence au mod√®le (c'est-√†-dire une instance de la classe <code>Field</code> ) dans la propri√©t√© <code>_model</code> priv√©e. <br><br>  Nous avons √©galement prudemment d√©marr√© 2 <code>_create</code> <code>_init</code> et <code>_create</code> actuellement vides, que nous impl√©menterons un peu plus tard. <br><br><a name="section-3-4"></a><h3>  <font color="#008080">3.4 Cr√©ation d'un sprite dans une classe de vue</font> </h3><br>  Ainsi, la vue a √©t√© cr√©√©e, mais elle ne sait toujours pas comment dessiner un sprite.  Pour placer l'image-objet avec le cadre dont nous avons besoin sur la toile, vous devrez modifier notre propre m√©thode <code>_create</code> priv√©e: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.js //... private _create(): void { this.scene.add.existing(this); //      this.setOrigin(0.5); //  pivot point    } //...</span></span></code> </pre><br><a name="section-3-5"></a><h3>  <font color="#008080">3.5 Positionnement des sprites</font> </h3><br>  Pour le moment, tous les sprites cr√©√©s seront plac√©s dans les coordonn√©es (0, 0) du canevas.  Nous devons √©galement placer chaque cellule dans sa position correspondante sur la carte.  C'est-√†-dire √† l'endroit qui correspond √† la ligne et √† la colonne de cette cellule.  Pour ce faire, nous devons √©crire un code pour calculer les coordonn√©es de chaque instance de la classe <code>FieldView</code> . <br><br>  Ajoutez la propri√©t√© <code>_position</code> √† la classe, qui est responsable des coordonn√©es finales de la cellule sur le terrain de jeu: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... interface Vec2 {x: number, y: number}; export class FieldView extends Phaser.GameObjects.Sprite { private _position: Vec2 = {x: 0, y: 0}; //...</span></span></code> </pre><br>  Puisque nous voulons aligner la carte et, par cons√©quent, les cellules qu'elle <code>_offset</code> , par rapport au centre de l'√©cran, nous avons √©galement besoin de la propri√©t√© <code>_offset</code> , indiquant le d√©calage de cette cellule particuli√®re par rapport aux bords gauche et sup√©rieur de l'√©cran.  Ajoutez-le avec un getter priv√©: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private get _offset(): Vec2 { return { x: (this.scene.cameras.main.width - this._model.board.cols * this.width) / 2, y: (this.scene.cameras.main.height - this._model.board.rows * this.height) / 2 }; } //...</span></span></code> </pre><br>  Ainsi, nous: <br><br><ol><li>  Vous avez la largeur totale de l'√©cran dans <code>this._scene.cameras.main.width</code> . </li><li>  Nous avons obtenu la largeur totale de la planche en multipliant le nombre de cellules par la largeur d'une cellule: <code>this._board.cols * this.width</code> . </li><li>  En enlevant la largeur de la planche √† la largeur de l'√©cran, nous avons obtenu une place sur l'√©cran, non occup√©e par la planche. </li><li>  En divisant le nombre r√©sultant par 2, nous avons obtenu la valeur de retrait √† gauche et √† droite de la carte. </li><li>  En d√©calant chaque cellule de la valeur de cette indentation, nous garantissons l'alignement de la carte enti√®re le long de l'axe <code>x</code> . </li></ol><br>  Nous effectuons des actions absolument similaires pour obtenir un d√©placement vertical. <br><br>  Il reste √† ajouter le code n√©cessaire dans la m√©thode <code>_init</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts // ... private _init(): void { const offset = this._offset; this.x = this._position.x = offset.x + this.width * this._model.col + this.width / 2; this.y = this._position.y = offset.y + this.height * this._model.row + this.height / 2; } // ...</span></span></code> </pre><br>  Les propri√©t√©s <code>this.x</code> , <code>this.y</code> , <code>this.width</code> et <code>this.height</code> sont les propri√©t√©s h√©rit√©es de la classe parente <code>Phaser.GameObjects.Sprite</code> .  La modification des propri√©t√©s de <code>this.x</code> et <code>this.y</code> conduit au positionnement correct du sprite sur la toile. <br><br><a name="section-3-6"></a><h3>  <font color="#008080">3.6 Cr√©ation d'une instance de FieldView</font> </h3><br>  Cr√©ez une vue dans la classe <code>Field</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts // ... private _view: FieldView = null; public get view(): FieldView { return this._view; } private _init(scene: Phaser.Scene, board: Board, row: number, col: number): void { //... this._view = new FieldView(this._scene, this); } // ...</span></span></code> </pre><br><a name="section-3-7"></a><h3>  <font color="#008080">3.7 Afficher les champs de la carte.</font> </h3><br>  Revenons √† la classe <code>Board</code> , qui est essentiellement une collection d'objets <code>Field</code> et va cr√©er des cellules. <br><br>  Nous allons retirer le code de cr√©ation de la carte dans une m√©thode <code>_create</code> distincte et appeler cette m√©thode depuis le constructeur.  Sachant que dans la m√©thode <code>_create</code> , nous ne cr√©erons pas seulement des cellules, nous <code>_createFields</code> le code de cr√©ation de cellules dans une m√©thode <code>_createFields</code> distincte. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts constructor(scene: Phaser.Scene, rows: number, cols: number, bombs: number) { // ... this._create(); } private _create(): void { this._createFields(); } private _createFields(): void { }</span></span></code> </pre><br>  C'est dans cette m√©thode que nous allons cr√©er le nombre de cellules souhait√© dans une boucle imbriqu√©e: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts // ... private _createFields(): void { for (let row = 0; row &lt; this._rows; row++) { for (let col = 0; col &lt; this._cols; col++) { this._fields.push(new Field(this._scene, this, row, col)); } } } //...</span></span></code> </pre><br>  Il est temps pour la premi√®re fois d'ex√©cuter l'assembly pour le d√©bogage avec la commande <br><br><pre> <code class="plaintext hljs">npm start</code> </pre> <br>  Assurez-vous qu'au centre de l'√©cran, nous nous attendons √† voir 64 cellules sur 8 rang√©es. <br><br><a name="section-3-8"></a><h3>  <font color="#008080">3.8 Fabrication de bombes</font> </h3><br>  Plus t√¥t, j'ai signal√© que dans la m√©thode <code>_create</code> de la classe <code>Board</code> , nous ne cr√©erons pas seulement des champs.  Quoi d'autre?  Il y aura √©galement la cr√©ation de bombes et le r√©glage des cellules cr√©√©es au nombre de bombes voisines.  Commen√ßons par les bombes elles-m√™mes. <br><br>  Nous devons placer N bombes sur le plateau dans des cellules al√©atoires.  Nous d√©crivons le processus de cr√©ation de bombes avec un algorithme approximatif: <br><br><pre> <code class="plaintext hljs">                        </code> </pre><br>  √Ä chaque it√©ration de la boucle, nous obtiendrons une cellule al√©atoire de la propri√©t√© <code>this._fields</code> jusqu'√† ce que nous cr√©ons autant de bombes que celles indiqu√©es dans le champ <code>this._bombs</code> ,.  Si la cellule re√ßue est vide, nous y installerons une bombe et mettrons √† jour le compteur des bombes n√©cessaires √† la g√©n√©ration. <br><br>  Pour g√©n√©rer un nombre al√©atoire, nous utilisons la m√©thode statique <code>Phaser.Math.Between</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... private _createBombs(): void { let count = this._bombs; //      while (count &gt; 0) { //       let field = this._fields[Phaser.Math.Between(0, this._fields.length - 1)]; //    if (field.empty) { //     field.setBomb(); //     --count; //    } } }</span></span></code> </pre><br>  N'oubliez pas d'√©crire l'appel √† <code>this._createBombs();</code> dans le fichier <code>Board.ts</code> <code>this._createBombs();</code>  √† la fin de la m√©thode <code>_create</code> <br><br>  Comme vous l'avez d√©j√† remarqu√©, pour que ce code fonctionne correctement, vous devez affiner la classe <code>Field</code> en y ajoutant le getter <code>empty</code> et la m√©thode <code>setBomb</code> . <br><br>  Ajoutez un champ <code>_value</code> priv√© √† la <code>_value</code> Field, qui r√©glementera le contenu de la cellule.  Nous acceptons les accords suivants. <br><div class="scrollable-table"><table><tbody><tr><td>  <code>_value</code> === 0 </td><td>  la cellule est vide et ne contient ni mines ni valeurs </td></tr><tr><td>  <code>_value</code> === -1 </td><td>  il y a une mine dans la cellule </td></tr><tr><td>  <code>_value</code> &gt; 0 </td><td>  dans la cellule est le nombre de mines situ√©es √† c√¥t√© de la cellule actuelle </td></tr></tbody></table></div><br>  En suivant ces r√®gles, nous d√©velopperons des m√©thodes dans la classe <code>Field</code> qui fonctionnent avec la propri√©t√© <code>_value</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts // ... private _value: number = 0; // ... public get value(): number { return this._value; } public set value(value) { this._value = value; } public get empty(): boolean { return this._value === 0; } public get mined(): boolean { return this._value === -1; } public get filled(): boolean { return this._value &gt; 0; } public setBomb(): void { this._value = -1; } // ...</span></span></code> </pre><br><a name="section-3-9"></a><h3>  <font color="#008080">3.9 R√©glage des valeurs</font> </h3><br>  Les bombes sont dispos√©es et nous avons maintenant toutes les donn√©es afin de d√©finir les valeurs num√©riques dans toutes les cellules qui en ont besoin. <br><br>  Permettez-moi de vous rappeler que selon les r√®gles du sapeur, la cellule doit avoir le nombre qui correspond au nombre de bombes situ√©es √† c√¥t√© de cette cellule.  Sur la base de cette r√®gle, nous √©crivons le pseudocode correspondant. <br><br><pre> <code class="plaintext hljs">                  </code> </pre><br>  Dans la classe <code>Board</code> , cr√©ez une nouvelle m√©thode et traduisez le pseudocode sp√©cifi√© en code r√©el: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... private _createValues() { //      this._fields.forEach(field =&gt; { //      if (field.mined) { //     field.getClosestFields().forEach(item =&gt; { //      if (item.value &gt;= 0) { ++item.value; } }); } }); } //...</span></span></code> </pre><br>  Voyons laquelle des interfaces que nous utilisons n'est pas impl√©ment√©e.  Vous devez ajouter la m√©thode <code>getClosestFields</code> pour obtenir les cellules voisines. <br><br>  Comment identifier les cellules voisines? <br><br>  Par exemple, consid√©rez toute cellule de la carte qui n'est pas sur le bord, c'est-√†-dire pas dans la ligne extr√™me et pas dans la colonne extr√™me.  Ces cellules ont un nombre maximum de voisins: 1 en haut, 1 en bas, 3 √† gauche et 3 √† droite (y compris les cellules en diagonale). <br><br>  Ainsi, dans chacune des cellules voisines, les indicateurs <code>_row</code> et <code>_col</code> ne diff√®rent pas de plus de 1. Cela signifie que nous pouvons sp√©cifier √† l'avance la diff√©rence entre les param√®tres <code>_row</code> et <code>_col</code> avec le champ courant.  Ajoutez une constante au d√©but du fichier √† la description de la classe: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts const Positions = [ {row : 0, col : 1}, //  {row : 0, col : -1}, //  {row : 1, col : 0}, //  {row : 1, col : 1}, //   {row : 1, col : -1}, //   {row : -1, col : 0}, //  {row : -1, col : 1}, //   {row : -1, col : -1} //   ]; //...</span></span></code> </pre><br>  Et maintenant, nous pouvons ajouter la m√©thode manquante, dans laquelle nous allons parcourir ce tableau: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts //... public getClosestFields(): Field[] { let results = []; //      Positions.forEach(position =&gt; { //      let field = this._board.getField(this._row + position.row, this._col + position.col); //       if (field) { //     results.push(field); } }); return results; }; //...</span></span></code> </pre><br>  N'oubliez pas de v√©rifier la variable de <code>field</code> √† chaque it√©ration, car toutes les cellules de la carte n'ont pas 8 voisins.  Par exemple, la cellule sup√©rieure gauche n'aura pas de voisins √† sa gauche, etc. <br><br>  Il reste √† impl√©menter la m√©thode <code>getField</code> et √† ajouter tous les appels n√©cessaires √† la m√©thode <code>_create</code> dans la classe <code>Board</code> <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public getField(row: number, col: number): Field { return this._fields.find(field =&gt; field.row === row &amp;&amp; field.col === col); } //... private _create(): void { this._createFields(); this._createBombs(); this._createValues(); } //...</span></span></code> </pre><br><a name="section-4"></a><h2> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Gestion des √©v√©nements d'entr√©e</font></font></font> </h2><br><a name="section-4-1"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.1 Suivi des √©v√©nements de clic de souris</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour le moment, le tableau est compl√®tement initialis√©, il a des bombes et il y a des cellules avec des num√©ros, mais toutes sont actuellement ferm√©es et il n'y a aucun moyen de les ouvrir. </font><font style="vertical-align: inherit;">Nous allons corriger cela et impl√©menter l'ouverture des cellules en cliquant sur le bouton gauche de la souris. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout d'abord, nous devons suivre ce clic. </font><font style="vertical-align: inherit;">Dans la classe, </font></font><code>FieldView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ajoutez le </font></font><code>_create</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">code suivant </font><font style="vertical-align: inherit;">√† la toute fin de la m√©thode </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FielView.ts //... private _create(): void { // ... this.setInteractive(); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans phaser, vous pouvez vous abonner √† des objets de l'espace de noms pour diff√©rents √©v√©nements </font></font><code>Phaser.GameObjects</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. En particulier, nous souscrirons √† l'√©v√©nement click ( </font></font><code>pointerdown</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) le pr√©fabriqu√© du sprite lui-m√™me, c'est-√†-dire un objet d'une classe </font></font><code>FieldView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">h√©rit√©e de </font></font><code>Phaser.GameObjects.Sprite</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais avant de le faire, nous devons explicitement indiquer que le sprite est potentiellement interactif, c'est-√†-dire que vous devez g√©n√©ralement √©couter les entr√©es de l'utilisateur √† ce sujet. Vous devez le faire en appelant la m√©thode </font></font><code>setInteractive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sans param√®tres sur le sprite lui-m√™me, ce que nous avons fait dans l'exemple ci-dessus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que notre image-objet est devenue interactive, revenons √† la classe </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† l'endroit o√π de nouveaux objets de mod√®le sont cr√©√©s </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, √† savoir la m√©thode </font></font><code>_createFields</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et enregistrons le rappel des √©v√©nements d'entr√©e pour la vue:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... private _createFields(): void { for (let row = 0; row &lt; this._rows; row++) { for (let col = 0; col &lt; this._cols; col++) { const field = new Field(this._scene, this, row, col) field.view.on('pointerdown', this._onFieldClick.bind(this, field)); this._fields.push(field); } } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une fois que nous avons √©tabli qu'en cliquant sur le sprite que nous voulons ex√©cuter la m√©thode </font></font><code>_onFieldClick</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous devons l'impl√©menter. Mais nous supprimerons la logique de traitement du clic de la classe </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. On pense qu'il est pr√©f√©rable de traiter le mod√®le en fonction de l'entr√©e et de modifier en cons√©quence ses donn√©es dans un contr√¥leur s√©par√©, dont la similitude est la classe de la sc√®ne du jeu </font></font><code>GameScene</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Nous devons donc transmettre l'√©v√©nement de clic plus loin, de la classe </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† la sc√®ne elle-m√™me. Nous allons donc faire:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... private _onFieldClick(field: Field, pointer: Phaser.Input.Pointer): void { if (pointer.leftButtonDown()) { this.emit(`left-click`, field); } else if (pointer.rightButtonDown()) { this.emit(`right-click`, field); } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ici, nous ne jetons pas simplement l'√©v√©nement click tel qu'il √©tait, mais nous sp√©cifions √©galement de quel clic il s'agissait. </font><font style="vertical-align: inherit;">Cela sera utile √† l'avenir, lorsque dans la classe de sc√®ne, nous traiterons chaque option diff√©remment. </font><font style="vertical-align: inherit;">Bien s√ªr, il serait possible d'envoyer l'√©v√©nement click tel quel, mais nous simplifierons le code de la sc√®ne, en laissant une partie de la logique concernant l'√©v√©nement lui-m√™me dans la classe </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eh bien, revenons maintenant √† la classe de la sc√®ne de jeu </font></font><code>GameScene</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et ajoutons un </font></font><code>_create</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">code </font><font style="vertical-align: inherit;">√† la fin de la m√©thode </font><font style="vertical-align: inherit;">qui suit les √©v√©nements d'un clic sur les cellules:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... import { Field } from "../models/Field"; //... public create(): void { this._board = new Board(this, Rows, Cols, Bombs); this._board.on('left-click', this._onFieldClickLeft, this); this._board.on('right-click', this._onFieldClickRight, this); } private _onFieldClickLeft(field: Field): void { } private _onFieldClickRight(field: Field): void { } //...</span></span></code> </pre><br><a name="section-4-2"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.2. </font><font style="vertical-align: inherit;">Traitement du clic gauche</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous proc√©dons √† la mise en ≈ìuvre du traitement des √©v√©nements de clic de souris. </font><font style="vertical-align: inherit;">Et commencez par ouvrir les cellules. </font><font style="vertical-align: inherit;">Les cellules doivent √™tre ouvertes en appuyant sur le bouton gauche. </font><font style="vertical-align: inherit;">Et avant de commencer la programmation, parlons des conditions qui doivent √™tre remplies:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lorsque vous cliquez sur une cellule ferm√©e, elle doit √™tre ouverte </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s'il y a une mine dans une cellule ouverte - le jeu est perdu </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s'il n'y a pas de mines ou de valeurs dans la cellule ouverte, alors min n'est pas dans les cellules voisines, dans ce cas, vous devez ouvrir toutes les cellules voisines et continuer jusqu'√† ce que la valeur apparaisse dans la cellule ouverte </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lorsque vous cliquez sur une cellule ouverte, vous devez v√©rifier si tous les drapeaux sont d√©finis correctement et si oui, puis terminer le jeu avec une victoire </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et maintenant, pour simplifier la compr√©hension des fonctionnalit√©s requises, nous traduisons la logique ci-dessus en pseudo-code: </font></font><br><br><pre> <code class="plaintext hljs">                         </code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous comprenons maintenant ce qui doit √™tre programm√©. </font><font style="vertical-align: inherit;">Nous mettons en ≈ìuvre la m√©thode </font></font><code>_onFieldClickLeft</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts //... private _onFieldClickLeft(field: Field): void { if (field.closed) { //    field.open(); //   if (field.mined) { //    field.exploded = true; this._onGameOver(false); //   } else if (field.empty) { //    this._board.openClosestFields(field); //   } } else if (field.opened) { //    if (this._board.completed) { //       this._onGameOver(true); //   } } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et puis, comme toujours, nous finaliserons les classes </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et y </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">impl√©menterons ces m√©thodes que nous appelons dans le gestionnaire. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous indiquons 3 √©tats possibles de la cellule dans l'√©num√©ration </font></font><code>States</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ajoutons un champ </font></font><code>_state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et impl√©mentons un getter pour chaque √©tat possible:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts enum States { Closed = 'closed', Opened = 'opened', Marked = 'flag' }; export class Field extends Phaser.Events.EventEmitter { private _state: string = States.Closed; //... public get marked(): boolean { return this._state === States.Marked; } public get closed(): boolean { return this._state === States.Closed; } public get opened(): boolean { return this._state === States.Opened; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que nous avons des √©tats indiquant si la cellule est ferm√©e ou non, nous pouvons ajouter une m√©thode </font></font><code>open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui changera l'√©tat:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts //... public open(): void { this._setState(States.Opened); } private _setState(state: string): void { if (this._state !== state) { this._state = state; this.emit('change'); } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chaque modification de l'√©tat du mod√®le doit d√©clencher un √©v√©nement qui le signale. </font><font style="vertical-align: inherit;">Par cons√©quent, nous introduisons une m√©thode priv√©e suppl√©mentaire </font></font><code>_setState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans laquelle toute la logique du changement d'√©tat sera impl√©ment√©e. </font><font style="vertical-align: inherit;">Cette m√©thode sera appel√©e dans toutes les m√©thodes publiques du mod√®le, ce qui devrait changer son √©tat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez un indicateur bool√©en </font></font><code>_exploded</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour indiquer explicitement exactement l'objet Field qui a explos√©:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts private _exploded: boolean = false; //... public set exploded(exploded: boolean) { this._exploded = exploded; this.emit('change'); } public get exploded(): boolean { return this._exploded; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ouvrez maintenant la classe </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et impl√©mentez-y la m√©thode </font></font><code>openClosestFields</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cette m√©thode est r√©cursive et sa t√¢che sera d'ouvrir tous les champs voisins vides par rapport √† la cellule accept√©e dans le param√®tre. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'algorithme sera le suivant:</font></font><br><br><pre> <code class="plaintext hljs"> :                </code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et cette fois, nous avons d√©j√† toutes les interfaces n√©cessaires pour la mise en ≈ìuvre compl√®te de cette m√©thode: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public openClosestFields(field: Field): void { field.getClosestFields().forEach(item =&gt; {//     if (item.closed) {//    item.open();//   if (item.empty) {//    this.openClosestFields(item);//     } } }); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez un getter </font></font><code>completed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† la classe </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour indiquer l'emplacement correct des drapeaux sur le tableau. </font><font style="vertical-align: inherit;">Comment pouvons-nous d√©terminer si une planche a √©t√© effac√©e avec succ√®s? </font><font style="vertical-align: inherit;">Le nombre de champs correctement marqu√©s doit √™tre √©gal au nombre total de bombes sur le plateau.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public get completed(): boolean { return this._fields.filter(field =&gt; field.completed).length === this._bombs; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette m√©thode filtre le tableau </font></font><code>_fields</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par getter </font></font><code>completed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ce qui devrait indiquer la validit√© de la marque de champ. </font><font style="vertical-align: inherit;">Si la longueur du tableau filtr√© (dans lequel seuls les champs correctement marqu√©s tombent, pour lesquels le getter est </font></font><code>completed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©j√† </font><font style="vertical-align: inherit;">responsable </font><font style="vertical-align: inherit;">de la classe </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) est √©gale √† la valeur du champ </font></font><code>_bombs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(c'est-√†-dire le nombre de bombes sur le plateau), alors nous revenons </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, en d'autres termes, nous consid√©rons que le jeu est gagn√©. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela ne nous d√©range pas non plus d'avoir la possibilit√© d'ouvrir tout le tableau en un seul appel, ce que nous devons faire √† la fin du niveau. </font><font style="vertical-align: inherit;">Nous ajouterons √©galement cette fonctionnalit√© √† la classe </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public open(): void { this._fields.forEach(field =&gt; field.open()); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il reste √† ajouter un getter </font></font><code>completed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† la classe elle-m√™me </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dans quel cas le champ sera-t-il consid√©r√© comme effac√© avec succ√®s? </font><font style="vertical-align: inherit;">S'il est extrait et signal√©. </font><font style="vertical-align: inherit;">Les deux getters n√©cessaires sont d√©j√† l√† et nous pouvons ajouter cette m√©thode:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts //... public get completed(): boolean { return this.marked &amp;&amp; this.mined; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour terminer le traitement du clic gauche de la souris, nous allons cr√©er une m√©thode </font></font><code>_onGameOver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans laquelle nous d√©sactiverons le suivi des √©v√©nements du plateau et montrerons au joueur l'ensemble du plateau. </font><font style="vertical-align: inherit;">Plus tard, nous y ajouterons √©galement un code de rendu du rapport d'ach√®vement d'√©tat bas√© sur le param√®tre </font></font><code>status</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts //... private _onGameOver(status: boolean) { this._board.off('left-click', this._onFieldClickLeft, this); this._board.off('right-click', this._onFieldClickRight, this); this._board.open(); } //...</span></span></code> </pre><br><a name="section-4-3"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.3 Affichage sur le terrain</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avant de commencer le traitement du clic droit, nous apprendrons √† redessiner les cellules nouvellement ouvertes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plus t√¥t dans la classe, </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous avons d√©velopp√© une m√©thode </font></font><code>_setState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui d√©clenche un √©v√©nement </font></font><code>change</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lorsque l'√©tat du mod√®le change. Nous l'utiliserons et dans la classe, nous </font></font><code>FieldView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tracerons cet √©v√©nement:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _init(): void { //... this._model.on('change', this._onStateChange, this); } private _onStateChange(): void { this._render(); } private _render(): void { this.setFrame(this._frameName); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons sp√©cifiquement fait de la m√©thode interm√©diaire un </font></font><code>_onStateChange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rappel de l'√©v√©nement de changement de mod√®le. </font><font style="vertical-align: inherit;">√Ä l'avenir, nous devrons v√©rifier comment le mod√®le a √©t√© modifi√© afin de comprendre s'il est n√©cessaire d'effectuer </font></font><code>_render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour afficher l'image-objet actuelle d'une cellule dans un nouvel √©tat, vous devez modifier son cadre. </font><font style="vertical-align: inherit;">Puisque nous avons charg√© l'atlas en tant qu'actifs, nous pouvons appeler la m√©thode </font></font><code>setFrame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">afin de changer le cadre courant en un nouveau. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour obtenir le cadre sur une seule ligne, nous avons astucieusement utilis√© le getter </font></font><code>_frameName</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui doit maintenant √™tre impl√©ment√©. </font><font style="vertical-align: inherit;">Tout d'abord, nous d√©crivons toutes les valeurs possibles qu'une trame de cellule peut prendre.</font></font><br><div class="scrollable-table"><table><tbody><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cadre </font></font></td><td>  Condition </td></tr><tr><td> <code>closed</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le champ est ferm√© </font></font><br></td></tr><tr><td> <code>flag</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Champ marqu√© </font></font><br></td></tr><tr><td> <code>empty</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le champ est ouvert, non extrait ou rempli de valeur </font></font><br></td></tr><tr><td> <code>exploded</code> <br> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> le champ est ouvert, min√© et explos√© </font></font><br></td></tr><tr><td> <code>mined</code> <br> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> le champ est ouvert, min√©, mais pas explos√© </font></font><br></td></tr><tr><td> <code>1...9</code> <br> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> le champ est ouvert et affiche une valeur de 1 √† 9, indiquant le nombre de bombes √† c√¥t√© de ce champ </font></font><br></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons obtenu une description de tous les √©tats et avons d√©j√† toutes les m√©thodes du mod√®le, gr√¢ce auxquelles ces √©tats peuvent √™tre obtenus. </font><font style="vertical-align: inherit;">Obtenons une petite configuration au d√©but du fichier:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts const States = { 'closed': field =&gt; field.closed, 'flag': field =&gt; field.marked, 'empty': field =&gt; field.opened &amp;&amp; !field.mined &amp;&amp; !field.filled, 'exploded': field =&gt; field.opened &amp;&amp; field.mined &amp;&amp; field.exploded, 'mined': field =&gt; field.opened &amp;&amp; field.mined &amp;&amp; !field.exploded } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les cl√©s de cet objet seront les valeurs des trames et les valeurs de ces cl√©s sont les rappels qui renvoient un r√©sultat bool√©en. </font><font style="vertical-align: inherit;">Sur la base de cette configuration, nous pouvons d√©velopper une m√©thode pour obtenir la trame souhait√©e (c'est-√†-dire la cl√© de la configuration):</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private get _frameName(): string { for (let key in States) { if (States[key](this._model)) { return key; } } return this._model.value.toString(); }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainsi, par simple √©num√©ration dans une boucle, nous parcourons toutes les cl√©s de l'objet config et appelons chaque rappel tour √† tour. </font><font style="vertical-align: inherit;">La fonction qui nous renvoie en premier </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indiquera que la cl√© </font></font><code>key</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† l'it√©ration actuelle est le cadre correct pour l'√©tat actuel du mod√®le. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si aucune cl√© ne convient, alors pour l'√©tat par d√©faut, nous consid√©rerons un champ ouvert avec une valeur </font></font><code>_value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, car </font></font><code>States</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous n'avons pas d√©fini </font><font style="vertical-align: inherit;">cet √©tat dans la configuration </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons tester compl√®tement le clic gauche sur les champs du tableau et v√©rifier comment les cellules s'ouvrent et ce qui s'affiche apr√®s leur ouverture.</font></font><br><br><a name="section-4-4"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.4 Traitement du clic droit</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme dans le cas de la cr√©ation du gestionnaire de clic gauche, nous d√©finissons d'abord clairement la fonctionnalit√© attendue. </font><font style="vertical-align: inherit;">En cliquant avec le bouton droit, nous devons marquer la cellule s√©lectionn√©e avec un drapeau. </font><font style="vertical-align: inherit;">Mais il y a certaines conditions.</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seul un champ ferm√© qui n'est pas actuellement marqu√© peut √™tre marqu√© </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si le champ est coch√©, un clic droit √† nouveau devrait supprimer le drapeau du champ </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lors de la d√©finition / suppression d'un indicateur, il est n√©cessaire de mettre √† jour le nombre d'indicateurs disponibles au niveau et d'afficher le texte avec le num√©ro actuel </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En traduisant ces conditions en pseudo-code, nous obtenons les lignes de commentaires suivantes: </font></font><br><br><pre> <code class="plaintext hljs">                              </code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous pouvons maintenant traduire cet algorithme en appels aux m√©thodes dont nous avons besoin, m√™me si elles n'ont pas encore √©t√© d√©velopp√©es: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts private _flags: number = 0; //... private _onFieldClickRight(field: Field): void { if (field.closed &amp;&amp; this._flags &gt; 0) { //        field.addFlag(); //     } else if (field.marked) { //     field.removeFlag(); //   } this._flags = Bombs - this._board.countMarked; } //... public create(): void { this._flags = Bombs; //... } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ici, nous avons √©galement commenc√© un nouveau champ </font></font><code>_flags</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui au d√©but du niveau de jeu est √©gal au nombre de bombes sur le plateau, car au d√©but du jeu, aucun drapeau n'a √©t√© d√©fini. </font><font style="vertical-align: inherit;">Ce champ est oblig√© d'√™tre mis √† jour √† chaque clic droit, car dans ce cas, le drapeau est ajout√© ou supprim√© du tableau. </font><font style="vertical-align: inherit;">Ajoutez un </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getter </font><font style="vertical-align: inherit;">√† la classe </font></font><code>countMarked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public get countMarked(): number { return this._fields.filter(field =&gt; field.marked).length; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La d√©finition et la suppression de l'indicateur est un changement dans l'√©tat du mod√®le </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous impl√©mentons donc ces m√©thodes dans la classe correspondante de mani√®re similaire √† la m√©thode </font></font><code>open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts //... public addFlag(): void { this._setState(States.Marked); } public removeFlag(): void { this._setState(States.Closed); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Permettez-moi de vous rappeler que cela </font></font><code>_setState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©clenchera un √©v√©nement </font></font><code>change</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui est suivi dans la vue et, par cons√©quent, le sprite sera redessin√© automatiquement cette fois lorsque le mod√®le change. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors du test des fonctionnalit√©s d√©velopp√©es, vous constaterez certainement qu'√† chaque fois que vous cliquez sur le bouton droit de la souris, un menu contextuel s'ouvre. </font><font style="vertical-align: inherit;">Ajoutez le code qui d√©sactive ce comportement au constructeur de la sc√®ne de jeu:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts //... constructor() { super('Game'); //        document.querySelector("canvas").oncontextmenu = e =&gt; e.preventDefault(); } //...</span></span></code> </pre><br><a name="section-4-5"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.5 Objet GameSceneView</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour afficher l'interface utilisateur sur la sc√®ne du jeu, nous allons cr√©er une classe </font></font><code>GameSceneView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et la placer </font></font><code>src/scripts/views/GameSceneView.ts</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans ce cas, nous agirons d'une mani√®re diff√©rente de la cr√©ation </font></font><code>FieldView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et ne ferons pas de cette classe un pr√©fabriqu√© et un h√©ritier </font></font><code>GameObjects</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans ce cas, nous devons sortir les √©l√©ments suivants de la vue de la sc√®ne:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> texte dans le nombre de drapeaux </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bouton de sortie </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Message d'√©tat de fin de partie (gagnant / perdant) </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faisons de chaque √©l√©ment de l'interface utilisateur un champ distinct dans la classe </font></font><code>GameSceneView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous allons pr√©parer un talon.</font></font><br><br><pre> <code class="javascript hljs">enum Styles { Color = <span class="hljs-string"><span class="hljs-string">'#008080'</span></span>, Font = <span class="hljs-string"><span class="hljs-string">'Arial'</span></span> } enum Texts { Flags = <span class="hljs-string"><span class="hljs-string">'FLAGS: '</span></span>, Exit = <span class="hljs-string"><span class="hljs-string">'EXIT'</span></span>, Success = <span class="hljs-string"><span class="hljs-string">'YOU WIN!'</span></span>, Failure = <span class="hljs-string"><span class="hljs-string">'YOU LOOSE'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameSceneView</span></span></span><span class="hljs-class"> </span></span>{ private _scene: Phaser.Scene = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; private _style: {<span class="hljs-attr"><span class="hljs-attr">font</span></span>: string, <span class="hljs-attr"><span class="hljs-attr">fill</span></span>: string}; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(scene: Phaser.Scene) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._scene = scene; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._style = {<span class="hljs-attr"><span class="hljs-attr">font</span></span>: <span class="hljs-string"><span class="hljs-string">`28px </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${Styles.Font}</span></span></span><span class="hljs-string">`</span></span>, <span class="hljs-attr"><span class="hljs-attr">fill</span></span>: Styles.Color}; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._create(); } private _create(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } public render() { } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ajoutez du texte avec le nombre de drapeaux. </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameSceneView.ts //... private _txtFlags: Phaser.GameObjects.Text = null; //... private _createTxtFlags(): void { this._txtFlags = this._scene.add.text( 50, 50, Texts.Flags, this._style ).setOrigin(0, 1); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce code mettra le texte dont nous avons besoin dans une position en retrait de 50 pixels √† partir des c√¥t√©s sup√©rieur et gauche et le d√©finira dans le style sp√©cifi√©. </font><font style="vertical-align: inherit;">De plus, la m√©thode </font></font><code>setOrigin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©finit le point de pivot du texte sur les coordonn√©es (0, 1). </font><font style="vertical-align: inherit;">Cela signifie que le texte s'alignera sur sa bordure gauche. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez un message d'√©tat.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameSceneView.ts //... private _txtStatus: Phaser.GameObjects.Text = null; //... private _createTxtStatus(): void { this._txtStatus = this._scene.add.text( this._scene.cameras.main.centerX, 50, Texts.Success, this._style ).setOrigin(0.5, 1); this._txtStatus.visible = false; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pla√ßons le texte d'√©tat au centre de l'√©cran et l'alignons avec le milieu de la ligne en appelant </font></font><code>setOrigin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec le param√®tre 0.5 pour la coordonn√©e x. </font><font style="vertical-align: inherit;">De plus, par d√©faut, ce texte doit √™tre masqu√©, car nous ne l'afficherons qu'√† la fin du jeu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cr√©ez un bouton de sortie, qui dans son essence est √©galement un objet texte.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameSceneView.ts //... private _btnExit: Phaser.GameObjects.Text = null; //... private _createBtnExit(): void { this._btnExit = this._scene.add.text( this._scene.cameras.main.width - 50, 50, Texts.Exit, this._style ).setOrigin(1); this._btnExit.setInteractive(); this._btnExit.once('pointerdown', () =&gt; { this._scene.scene.start('Start'); }); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pla√ßons le bouton dans le coin sup√©rieur droit de l'√©cran et l'utilisons √† nouveau </font></font><code>setOrigin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour aligner le texte cette fois avec son bord droit. </font><font style="vertical-align: inherit;">Nous rendons le bouton interactif et ajoutons un rappel √† l'√©v√©nement click, qui envoie le joueur √† la sc√®ne de d√©part. </font><font style="vertical-align: inherit;">Ainsi, nous donnons au joueur la possibilit√© de quitter le niveau √† tout moment. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il reste √† d√©velopper une m√©thode </font></font><code>render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour mettre √† jour correctement tous les √©l√©ments de l'interface utilisateur et ajouter des appels √† toutes les m√©thodes cr√©√©es dans </font></font><code>_create</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameSceneView.ts //... private _create(): void { this._createTxtFlags(); this._createTxtStatus(); this._createBtnExit(); } public render(data: {flags?: number, status?: boolean}) { if (typeof data.flags !== 'undefined') { this._txtFlags.text = Texts.Flags + data.flags.toString(); } if (typeof data.status !== 'undefined') { this._txtStatus.text = data.status ? Texts.Success : Texts.Failure; this._txtStatus.visible = true; } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En fonction de la propri√©t√© pass√©e dans le param√®tre, nous mettons √† jour l'interface utilisateur, en affichant les modifications n√©cessaires. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cr√©ez une repr√©sentation dans la sc√®ne du jeu dans la classe GameScene et √©crivez l'appel √† la m√©thode _render partout o√π cela est requis en signifiant:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts //... import { GameSceneView } from "../views/GameSceneView"; //... export class GameScene extends Phaser.Scene { private _view: GameSceneView = null; //... private _onGameOver(status: boolean) { //... this._view.render({status}); } //... private _onFieldClickRight(field: Field): void { //... this._flags = Bombs - this._board.countMarked; this._view.render({flags: this._flags}); } //... public create(): void { //... this._view = new GameSceneView(this); this._view.render({flags: this._flags}); } //... }</span></span></code> </pre><br><a name="section-5"></a><h2> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Animations</font></font></font> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quel genre de fan de cr√©er un jeu, m√™me aussi simple que le n√¥tre, s'il n'y a pas d'animations?!! </font><font style="vertical-align: inherit;">De plus, depuis que nous avons commenc√© √† √©tudier le phaser, familiarisons-nous avec les fonctionnalit√©s les plus √©l√©mentaires des animations et consid√©rons la fonctionnalit√© des jumeaux. </font><font style="vertical-align: inherit;">Les jumeaux sont impl√©ment√©s dans le cadre lui-m√™me et aucune biblioth√®que tierce n'est requise. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez 2 animations au jeu: remplir le tableau de cellules au d√©but et retourner la cellule √† l'ouverture. </font><font style="vertical-align: inherit;">Commen√ßons par le premier.</font></font><br><br><a name="section-5-1"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.1 Animation de remplissage du tableau</font></font></font> </h3><br><img src="https://habrastorage.org/webt/7r/uu/1v/7ruu1vtppaw26sp-fapxbahgm9q.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous nous assurons que toutes les cellules de la carte volent en place √† partir du bord sup√©rieur gauche de l'√©cran. </font><font style="vertical-align: inherit;">Lors du d√©marrage du niveau de jeu, nous devons d√©placer toutes les cellules dans le coin sup√©rieur gauche de l'√©cran et pour chaque cellule d√©marrer l'animation du mouvement √† ses coordonn√©es correspondantes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la classe, </font></font><code>FiledView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ajoutez l' </font></font><code>_create</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">appel </font><font style="vertical-align: inherit;">√† la fin des m√©thodes </font></font><code>_animateShow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _create(): void { //... this._animateShow(); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B nous mettons en ≈ìuvre la nouvelle m√©thode dont nous avons besoin. </font><font style="vertical-align: inherit;">Dans ce document, comme nous l'avons convenu ci-dessus, il est n√©cessaire d'effectuer 2 choses:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d√©placer la cellule derri√®re le coin sup√©rieur gauche afin qu'elle ne soit pas visible √† l'√©cran </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d√©marrer le mouvement jumeau aux coordonn√©es souhait√©es avec le retard correct </font></font></li></ol><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _animateShow(): Promise&lt;void&gt; { this.x = -this.width; this.y = -this.height; const delay = this._model.row * 50 + this._model.col * 10; return this._moveTo(this._position, delay); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âtant donn√© que le coin sup√©rieur gauche du canevas a des coordonn√©es (0, 0), si nous d√©finissons la cellule sur les coordonn√©es √©gales √† ses valeurs n√©gatives de largeur et de hauteur, cela placera la cellule derri√®re le coin sup√©rieur gauche et la masquera √† l'√©cran. </font><font style="vertical-align: inherit;">Ainsi, nous avons termin√© notre premi√®re t√¢che. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous atteindrez le deuxi√®me objectif en appelant la m√©thode </font></font><code>_moveTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _moveTo(position: Vec2, delay: number): Promise&lt;void&gt; { return new Promise(resolve =&gt; { this.scene.tweens.add({ targets: this, x: position.x, y: position.y, duration: 600, ease: 'Elastic', easeParams: [1, 1], delay, onComplete: () =&gt; { resolve(); } }); }); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour cr√©er une animation, nous utilisons la propri√©t√© scene </font></font><code>tweens</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dans sa m√©thode, </font></font><code>add</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous passons l'objet de configuration avec les param√®tres:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La propri√©t√© </font></font><code>targets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici doit contenir comme valeur les objets de jeu auxquels vous souhaitez appliquer des effets d'animation. </font><font style="vertical-align: inherit;">Dans notre cas, il s'agit d'un lien </font></font><code>this</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vers l'objet courant, car il s'agit d'un pr√©fabriqu√© de l'image-objet.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les deuxi√®me et troisi√®me param√®tres nous passent les coordonn√©es de la destination. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La propri√©t√© </font></font><code>duration</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est responsable de la dur√©e de l'animation, dans notre cas - 600ms.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Param√®tres </font></font><code>ease</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>easeParams</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©finir la fonction d'acc√©l√©ration.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le champ de d√©lai, nous substituons la valeur du deuxi√®me argument, qui est g√©n√©r√© pour chaque cellule individuelle, en tenant compte de sa position sur la carte. </font><font style="vertical-align: inherit;">Ceci est fait pour que les cellules ne volent pas en m√™me temps. </font><font style="vertical-align: inherit;">Au lieu de cela, chaque cellule appara√Ætra avec un l√©ger retard par rapport √† la pr√©c√©dente.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enfin, </font></font><code>onComplete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous mettons un rappel </font><font style="vertical-align: inherit;">dans la propri√©t√© </font><font style="vertical-align: inherit;">, qui sera appel√© √† la fin de l'action d'interpolation.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est raisonnable d'envelopper le jumeau dans une promesse afin qu'√† l'avenir il puisse magnifiquement ancrer diff√©rentes animations, nous allons donc placer un appel de fonction dans le rappel </font></font><code>resolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indiquant la bonne ex√©cution de l'animation.</font></font><br><br><a name="section-5-2"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.2 Animations de retournement de cellule</font></font></font> </h3><br><img src="https://habrastorage.org/webt/uc/d-/yw/ucd-yw-nq6a4veixb-npp0mdyqy.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce sera formidable si, lors de l'ouverture de la cellule, l'effet de son inversion se reproduisait. Comment pouvons-nous y parvenir? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'ouverture d'une cellule s'effectue actuellement en changeant le cadre lors de l'appel de la m√©thode </font></font><code>_render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans la vue. Si nous v√©rifions l'√©tat du mod√®le dans cette m√©thode, nous verrons si la cellule √©tait ouverte. Si la cellule √©tait ouverte, d√©marrez l'animation au lieu d'afficher instantan√©ment un nouveau cadre d'inversion.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _onStateChange(): void { if (this._model.opened) { this._animateFlip(); } else { this._render(); } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour obtenir l'effet souhait√©, nous utiliserons la transformation du sprite √† travers la propri√©t√© </font></font><code>scale</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Si nous redimensionnons le sprite le long de l'axe </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† z√©ro au </font><font style="vertical-align: inherit;">fil du temps </font><font style="vertical-align: inherit;">, il finira par r√©tr√©cir, reliant les c√¥t√©s gauche et droit. </font><font style="vertical-align: inherit;">Et vice versa, si vous redimensionnez le sprite le long de l'axe </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de z√©ro √† sa pleine largeur, nous l'√©tirons √† sa taille maximale. </font><font style="vertical-align: inherit;">Nous impl√©mentons cette logique dans la m√©thode </font></font><code>_animateFlip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _animateFlip(): void { this._scaleXTo(0).then(() =&gt; { this._render(); this._scaleXTo(1); }) } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par analogie avec la m√©thode, nous mettons en </font></font><code>_moveTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">≈ìuvre </font></font><code>_scaleTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _scaleXTo(scaleX: number): Promise&lt;void&gt; { return new Promise(resolve =&gt; { this.scene.tweens.add({ targets: this, scaleX, ease: 'Elastic.easeInOut', easeParams: [1, 1], duration: 150, onComplete: () =&gt; { resolve() } }); }); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans cette m√©thode, en tant que param√®tre, nous prenons la valeur de l'√©chelle, que nous utiliserons pour changer la taille du sprite dans les deux sens et la passer comme second param√®tre √† l'objet de configuration d'animation. </font><font style="vertical-align: inherit;">Tous les autres param√®tres de configuration nous sont d√©j√† familiers depuis l'animation pr√©c√©dente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous allons maintenant commencer le projet pour les tests et apr√®s le d√©bogage, nous consid√©rerons notre jeu termin√© et la t√¢che de test termin√©e!</font></font> :) <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Je remercie sinc√®rement tout le monde d'avoir atteint ce moment avec moi! </font></font><br><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chers coll√®gues, je serai tr√®s heureux si le mat√©riel pr√©sent√© dans l'article vous est utile et vous pouvez utiliser ces approches ou celles d√©crites dans vos propres projets. Vous pouvez toujours vous adresser √† moi pour toute question, √† la fois sur cet article, et sur la programmation phaser ou travailler dans gamedev en g√©n√©ral. J'accueille la communication et serai heureux de faire de nouvelles connaissances et d'√©changer des exp√©riences! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et j'ai une question pour vous en ce moment. Depuis que je cr√©e des tutoriels vid√©o sur le d√©veloppement de jeux, j'ai naturellement accumul√© une douzaine de ces petits jeux. Chaque jeu ouvre le framework √† sa mani√®re. Par exemple, dans ce jeu, nous avons abord√© le sujet des jumeaux, mais il existe de nombreuses autres fonctionnalit√©s, telles que la physique, le tilemap, la colonne vert√©brale, etc.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä cet √©gard, la question est: avez-vous aim√© cet article et, si oui, seriez-vous int√©ress√© √† continuer √† lire des articles comme celui-ci, mais √† propos d'autres petits jeux classiques? </font><font style="vertical-align: inherit;">Si la r√©ponse est oui, je me ferai un plaisir de traduire le mat√©riel de mes didacticiels vid√©o au format texte et de continuer √† publier de nouveaux manuels au fil du temps, mais pour d'autres jeux. </font><font style="vertical-align: inherit;">J'apporte l'enqu√™te correspondante. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Merci √† tous pour votre attention! </font><font style="vertical-align: inherit;">Je serai heureux de vos commentaires et √† bient√¥t!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr476682/">https://habr.com/ru/post/fr476682/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr476670/index.html">Vue d'ensemble de la CAO sur le noyau g√©om√©trique C3D - 2</a></li>
<li><a href="../fr476674/index.html">D√©ploiement rapide de ReportPortal pour la familiarisation</a></li>
<li><a href="../fr476676/index.html">48 ressources open source pour JavaScript (2019)</a></li>
<li><a href="../fr476678/index.html">API pour l'extraction asynchrone √† distance √† l'aide d'Apple Combine</a></li>
<li><a href="../fr476680/index.html">Le syst√®me de planification de la production continue de Rodov est le Lean / MRP sovi√©tique de 1961. D√©collage, coucher de soleil et nouvelle naissance</a></li>
<li><a href="../fr476686/index.html">D√©veloppement d'une passerelle IoT bas√©e sur Raspberry CM3 +</a></li>
<li><a href="../fr476688/index.html">Nouveau cours d'OTUS. ¬´D√©veloppeur IOS. Cours avanc√© V 2.0 ¬ª</a></li>
<li><a href="../fr476692/index.html">Principes du marketing de contenu</a></li>
<li><a href="../fr476694/index.html">A propos de la robotique d'entreprise avec Farida Roslovets et directrice de la soci√©t√© RPA electroNeek</a></li>
<li><a href="../fr476696/index.html">Comment cr√©er et d√©ployer Full Stack React application</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>