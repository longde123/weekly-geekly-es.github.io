<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💣 👩🏽‍🤝‍👩🏻 🤞🏻 Comment écrire un sapeur dans Phaser et exécuter une tâche de test de développeur HTML5 👩🏾‍🎓 🥣 🧓🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, chers collègues! 

 Je m'appelle Alexander, je suis développeur de jeux HTML5. 

 Dans l'une des entreprises où j'ai envoyé mon CV, on m'a de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment écrire un sapeur dans Phaser et exécuter une tâche de test de développeur HTML5</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476682/"> Bonjour, chers collègues! <br><br>  Je m'appelle Alexander, je suis développeur de jeux HTML5. <br><br>  Dans l'une des entreprises où j'ai envoyé mon CV, on m'a demandé de terminer une tâche de test.  J'ai accepté et, après 1 jour, j'ai envoyé le jeu développé conformément aux TOR HTML5. <br><br><img src="https://habrastorage.org/webt/4t/ng/dn/4tngdnvlxq3izqrpk2nykww2dvs.png"><br><br>  Étant donné que je m'entraîne à la programmation de jeux, ainsi qu'à une utilisation plus efficace de mon code, j'ai décidé qu'il serait utile d'écrire un article de formation sur le projet terminé.  Et puisque le test terminé a reçu une évaluation positive et a conduit à une invitation à un entretien, ma décision a probablement le droit d'exister et, peut-être, aidera quelqu'un à l'avenir. <br><br>  Cet article donnera une idée de la quantité de travail suffisante pour réussir la tâche de test moyenne pour le poste de développeur HTML5.  Le matériel peut également intéresser quiconque souhaite se familiariser avec le cadre Phaser.  Et si vous travaillez déjà avec Phaser et que vous écrivez en JS - voyez comment développer un projet en TypeScript. <br><br>  Donc, sous cat, il y a beaucoup de code TypeScript! <br><a name="habracut"></a><br><h2>  Présentation </h2><br>  Nous donnons un bref exposé du problème. <br><br><ol><li>  Nous allons développer un jeu HTML5 simple - un sapeur classique. </li><li>  Comme outils principaux, nous utiliserons phaser 3, dactylographié et webpack. </li><li>  Le jeu sera conçu pour le bureau et exécuté dans le navigateur. </li></ol><br>  Nous fournissons des liens vers le projet final. <br><br><div class="spoiler">  <b class="spoiler_title">Liens vers la démo et la source</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Démo jouable</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Code source GitHub</a> <br></div></div><br>  Et rappelez-vous la mécanique du sapeur, si tout à coup quelqu'un oublie les règles du jeu.  Mais comme il s'agit d'un cas peu probable, les règles sont placées sous le spoiler :) <br><br><div class="spoiler">  <b class="spoiler_title">Règles du sapeur</b> <div class="spoiler_text">  Le terrain de jeu se compose de cellules disposées dans une table.  Par défaut, lorsque le jeu démarre, toutes les cellules sont fermées.  Des bombes sont placées dans certaines cellules. <br><br>  Lorsque vous cliquez avec le bouton gauche sur une cellule fermée, elle s'ouvre.  S'il y avait une bombe dans une cellule ouverte, le jeu se termine par la défaite. <br><br>  S'il n'y avait pas de bombe dans la cellule, un nombre s'affiche à l'intérieur, indiquant le nombre de bombes qui se trouvent dans les cellules voisines par rapport à l'ouverture actuelle.  S'il n'y a pas de bombes à proximité, la cellule semble vide. <br><br>  Un clic droit sur une cellule fermée définit un indicateur dessus.  La tâche du joueur est d'organiser tous les drapeaux à sa disposition afin qu'ils marquent toutes les cellules minées.  Après avoir placé tous les drapeaux, le joueur appuie sur le bouton gauche de la souris sur l'une des cellules ouvertes pour vérifier s'il a gagné. <br></div></div><br>  Ensuite, nous allons directement au manuel lui-même.  Tout le matériel est divisé en petites étapes, chacune décrivant la mise en œuvre d'une tâche spécifique en peu de temps.  Ainsi, en effectuant de petits objectifs étape par étape, nous allons finalement créer un jeu à part entière.  Utilisez la table des matières si vous décidez de passer rapidement à une étape spécifique. <br><br><div class="spoiler">  <b class="spoiler_title">Table des matières</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1. Préparation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.1 Modèle de projet</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.2 Configuration de la construction</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.3 Installation de modules</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.4 Préparation des actifs</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2. Création de scènes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.1 Point d'entrée</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.2 Scène de départ</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.3 Textes de la scène de départ</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.4 Transition au niveau du jeu</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Scène de niveau 2.5</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.6 Réglage des scènes au point d'entrée</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3. Objets de jeu</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.1 Plateau de jeu</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.2 Modèle de cellule</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.3 Vue des cellules</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.4 Création d'un sprite dans une classe de vue</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.5 Positionnement des sprites</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.6 Création d'une instance de FieldView</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.7 Afficher les champs de la carte.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.8 Fabrication de bombes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.9 Réglage des valeurs</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4. Gestion des événements d'entrée</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.1 Suivi des événements de clic de souris</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Traitement du clic gauche</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.4 Traitement du clic droit</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.5 Objet GameSceneView</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">5. Animations</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">5.1 Animation de remplissage du tableau</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">5.2 Animations de retournement de cellule</a> <br></div></div><br><a name="section-1"></a><h2>  <font color="#008080">1. Préparation</font> </h2><br><a name="section-1-1"></a><h3>  <font color="#008080">1.1 Modèle de projet</font> </h3><br>  Téléchargez le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">modèle de projet phaser par défaut</a> .  Il s'agit du modèle recommandé par l'auteur du framework et il nous offre la structure de répertoires suivante: <br><div class="scrollable-table"><table><tbody><tr><td>  index.html </td><td colspan="2">  Page HTML de lancement du jeu </td></tr><tr><td rowspan="2">  webpack / </td><td>  base.js </td><td>  construire la configuration pour l'environnement de test </td></tr><tr><td>  prod.js </td><td>  construire la configuration pour la production </td></tr><tr><td rowspan="2">  src / </td><td>  atouts / </td><td>  ressources du jeu (sprites, sons, polices) </td></tr><tr><td>  index.js </td><td>  point d'entrée </td></tr></tbody></table></div> Pour notre projet, nous n'avons pas besoin du fichier <code>index.js</code> actuel, donc supprimez-le.  Créez ensuite le répertoire <code>/src/scripts/</code> et placez-y le fichier <code>index.ts</code> vide.  Nous ajouterons tous nos scripts à ce dossier. <br>  Il convient également de garder à l'esprit que lors de la construction d'un projet pour la production, un répertoire <code>dist</code> sera créé à la racine, dans lequel la version sera placée. <br><br><a name="section-1-2"></a><h3>  <font color="#008080">1.2 Configuration de la construction</font> </h3><br>  Nous utiliserons le webpack pour l'assemblage.  Étant donné que notre modèle a été initialement préparé pour fonctionner avec JavaScript et que nous écrivons en TypeScript, nous devons apporter de petites modifications à la configuration du collecteur. <br><br>  Dans le <code>webpack/base.js</code> ajoutez la clé d' <code>entry</code> , qui indique le point d'entrée lors de la construction de notre projet, ainsi que la configuration <code>ts-loader</code> qui décrit les règles de construction des scripts TS: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// webpack/base.js //... module.exports = { entry: './src/scripts/index.ts', // ... resolve: { extensions: [ '.ts', '.tsx', '.js' ] }, module: { rules: [{ test: /\.tsx?$/, use: 'ts-loader', exclude: /node_modules/ }, //...</span></span></code> </pre><br>  Nous devrons également créer le fichier tsconfig.json à la racine du projet.  Pour moi, il a le contenu suivant: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"compilerOptions"</span></span>: { <span class="hljs-string"><span class="hljs-string">"module"</span></span>: <span class="hljs-string"><span class="hljs-string">"commonjs"</span></span>, <span class="hljs-string"><span class="hljs-string">"lib"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"dom"</span></span>, <span class="hljs-string"><span class="hljs-string">"es5"</span></span>, <span class="hljs-string"><span class="hljs-string">"es6"</span></span>, <span class="hljs-string"><span class="hljs-string">"es2015"</span></span>, <span class="hljs-string"><span class="hljs-string">"es2017"</span></span>, <span class="hljs-string"><span class="hljs-string">"es2015.promise"</span></span> ], <span class="hljs-string"><span class="hljs-string">"target"</span></span>: <span class="hljs-string"><span class="hljs-string">"es5"</span></span>, <span class="hljs-string"><span class="hljs-string">"skipLibCheck"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-string"><span class="hljs-string">"exclude"</span></span>: [<span class="hljs-string"><span class="hljs-string">"node_modules"</span></span>, <span class="hljs-string"><span class="hljs-string">"dist"</span></span>] }</code> </pre> <br><a name="section-1-3"></a><h3>  <font color="#008080">1.3 Installation de modules</font> </h3><br>  Installez toutes les dépendances de package.json et ajoutez-y les modules typescript et ts-loader: <br><br><pre> <code class="plaintext hljs">npm i npm i typescript --save-dev npm i ts-loader --save-dev</code> </pre><br>  Le projet est maintenant prêt à démarrer le développement.  Nous avons 2 commandes à notre disposition qui sont déjà définies dans la propriété <code>scripts</code> du fichier <code>package.json</code> . <br><br><ol><li>  Construire un projet de débogage et ouvrir dans un navigateur via un serveur local <br><br><pre> <code class="plaintext hljs">npm start</code> </pre> </li><li>  Exécutez la version à vendre et placez la version finale dans le dossier dist / <br><br><pre> <code class="plaintext hljs">npm run build</code> </pre> </li></ol><br><a name="section-1-4"></a><h3>  <font color="#008080">1.4 Préparation des actifs</font> </h3><br>  Tous les actifs de ce jeu sont honnêtement téléchargés depuis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OpenGameArt</a> (version 61x61) et ont la plus conviviale des licences appelée <i>N'hésitez pas à utiliser</i> , ce que la page avec le pack nous dit soigneusement).  Soit dit en passant, le code présenté dans l'article a la même licence!  ;) <br><br>  J'ai supprimé l'image d'horloge de l'ensemble téléchargé et renommé le reste des fichiers afin d'obtenir des noms de trame faciles à utiliser.  La liste des noms et des fichiers correspondants s'affiche sur l'écran ci-dessous. <br><br>  À partir des sprites résultants, nous allons créer un atlas au format <code>Phaser JSONArray</code> dans le programme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TexturePacker</a> (il y a plus qu'assez d'une version gratuite, je n'ai encore reçu aucun travail) et placer les fichiers <code>spritesheet.png</code> et <code>spritesheet.json</code> dans le répertoire du projet <code>src/assets/</code> . <br><br><img src="https://habrastorage.org/webt/ms/ki/z9/mskiz9zmuidbxk8hhcbksfmny4k.png"><br><br><a name="section-2"></a><h2>  <font color="#008080">2. Création de scènes</font> </h2><br><a name="section-2-1"></a><h3>  <font color="#008080">2.1 Point d'entrée</font> </h3><br>  Nous commençons le développement en créant le point d'entrée décrit dans la configuration du webpack. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// src/scripts/index.ts import * as Phaser from "phaser"; new Phaser.Game({ type: Phaser.AUTO, parent: "minesweeper", width: window.innerWidth, height: window.innerHeight, backgroundColor: "#F0FFFF", scene: [] });</span></span></code> </pre><br>  Étant donné que le jeu que nous avons est conçu pour le bureau et remplira tout l'écran, nous utilisons hardiment toute la largeur et la hauteur du navigateur pour les champs de <code>width</code> et de <code>height</code> . <br>  Le champ de <code>scene</code> est actuellement un tableau vide et nous allons le corriger! <br><br><a name="section-2-2"></a><h3>  <font color="#008080">2.2 Scène de départ</font> </h3><br>  Créez la classe de la première scène dans le <code>src/scripts/scenes/StartScene.ts</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StartScene</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Scene</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(<span class="hljs-string"><span class="hljs-string">'Start'</span></span>); } public preload(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } public create(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } }</code> </pre><br>  Pour un héritage valide de <code>Phaser.Scene</code> nous transmettons le nom de la scène en tant que paramètre au constructeur de la classe parente. <br><br>  Cette scène combinera la fonctionnalité de préchargement des ressources et l'écran de démarrage, invitant l'utilisateur au jeu. <br><br>  Habituellement, dans mes projets, un joueur passe par deux scènes avant d'arriver à la première, dans cet ordre: <br><br><pre> <code class="plaintext hljs">Boot =&gt; Preload =&gt; Start</code> </pre><br>  Mais dans ce cas, le jeu est si simple, et il y a si peu de ressources qu'il n'y a aucune raison de mettre la précharge dans une scène distincte et encore plus de faire le chargeur de <code>Boot</code> séparé initial. <br><br>  Nous chargerons tous les actifs dans la méthode de <code>preload</code> .  Afin de pouvoir travailler avec l'atlas créé à l'avenir, nous devons effectuer 2 étapes: <br><br><ol><li>  obtenir les fichiers atlas <code>png</code> et <code>json</code> en utilisant <code>require</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.ts const spritesheetPng = require("./../../assets/spritesheet.png"); const spritesheetJson = require("./../../assets/spritesheet.json"); // ...</span></span></code> </pre><br></li><li>  chargez-les dans la méthode de <code>preload</code> de la scène de départ: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.ts // ... public preload(): void { this.load.atlas("spritesheet", spritesheetPng, spritesheetJson); } // ...</span></span></code> </pre><br></li></ol><br><a name="section-2-3"></a><h3>  <font color="#008080">2.3 Textes de la scène de départ</font> </h3><br>  Il reste 2 choses à faire dans la scène de départ: <br><br><ol><li>  dire au joueur comment démarrer le jeu </li><li>  lancer le jeu à l'initiative du joueur </li></ol><br>  Pour répondre au premier point, nous créons d'abord deux énumérations au début du fichier de scène pour décrire les textes et leurs styles: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.js enum Texts { Title = 'Minesweeper HTML5', Message = 'Click anywhere to start' } enum Styles { Color = '#008080', Font = 'Arial' } //...</span></span></code> </pre><br>  Et puis créez les deux textes en tant qu'objets dans la méthode <code>create</code> .  Permettez-moi de vous rappeler que la méthode de <code>create</code> de scènes dans <code>Phaser</code> ne sera appelée qu'après le chargement de toutes les ressources dans la méthode de <code>preload</code> et cela nous convient parfaitement. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.js //... public create(): void { this.add.text( this.cameras.main.centerX, this.cameras.main.centerY - 100, Texts.Title, {font: `52px ${Styles.Font}`, fill: Styles.Color}) .setOrigin(0.5); this.add.text( this.cameras.main.centerX, this.cameras.main.centerY + 100, Texts.Message, {font: `28px ${Styles.Font}`, fill: Styles.Color}) .setOrigin(0.5); } //...</span></span></code> </pre><br>  Dans un autre projet plus vaste, nous pourrions prendre les textes et les styles soit dans des fichiers locaux json soit dans des configurations distinctes, mais étant donné que nous n'avons maintenant que 2 lignes, je considère cette étape redondante et dans ce cas, je suggère de ne pas compliquer nos vies, nous limiter aux listes au début du fichier de scène. <br><br><a name="section-2-4"></a><h3>  <font color="#008080">2.4 Transition au niveau du jeu</font> </h3><br>  La dernière chose que nous ferons dans cette scène avant de continuer est de suivre l'événement de clic de souris pour lancer le joueur dans le jeu: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.js //... public create(): void { //... this.input.once('pointerdown', () =&gt; { this.scene.start('Game'); }); } //...</span></span></code> </pre> <br><a name="section-2-5"></a><h3>  <font color="#008080">Scène de niveau 2.5</font> </h3><br>  A en juger par le paramètre <code>"Game"</code> passé à la méthode <code>this.scene.start</code> vous avez déjà deviné qu'il était temps de créer une deuxième scène, qui traiterait la logique principale du jeu.  Créez le <code>src/scripts/scenes/GameScene.ts</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameScene</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Scene</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(<span class="hljs-string"><span class="hljs-string">'Game'</span></span>); } public create(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } }</code> </pre><br>  Dans cette scène, nous n'avons pas besoin de la méthode de <code>preload</code> car  nous avons déjà chargé toutes les ressources nécessaires dans la scène précédente. <br><br><a name="section-2-6"></a><h3>  <font color="#008080">2.6 Réglage des scènes au point d'entrée</font> </h3><br>  Maintenant que les deux scènes sont créées, ajoutez-les à notre point d'entrée <br>  <code>src/scripts/index.ts</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//... import { StartScene } from "./scenes/StartScene"; import { GameScene } from "./scenes/GameScene"; //... new Phaser.Game({ // ... scene: [StartScene, GameScene] });</span></span></code> </pre><br><a name="section-3"></a><h2>  <font color="#008080">3. Objets de jeu</font> </h2><br>  Ainsi, la classe <code>GameScene</code> implémentera la logique au niveau du jeu.  Et qu'attendons-nous du niveau de jeu des sapeurs?  Visuellement, nous nous attendons à voir un terrain de jeu avec des cellules fermées.  Nous savons que le champ est une table, ce qui signifie qu'il a un nombre donné de lignes et de colonnes, dans plusieurs desquelles les bombes sont confortablement placées.  Ainsi, nous avons suffisamment d'informations pour créer une entité distincte qui décrit le terrain de jeu. <br><br><a name="section-3-1"></a><h3>  <font color="#008080">3.1 Plateau de jeu</font> </h3><br>  Créez le <code>src/scripts/models/Board.ts</code> dans lequel nous <code>src/scripts/models/Board.ts</code> la classe <code>Board</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Field } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./Field"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Board</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Events</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventEmitter</span></span></span><span class="hljs-class"> </span></span>{ private _scene: Phaser.Scene = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; private _rows: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; private _cols: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; private _bombs: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; private _fields: Field[] = []; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(scene: Phaser.Scene, rows: number, cols: number, bombs: number) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._scene = scene; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._rows = rows; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._cols = cols; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._bombs = bombs; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._fields = []; } public get cols(): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._cols; } public get rows(): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._rows; } }</code> </pre> <br>  Faisons de la classe le successeur de Phaser.Events.EventEmitter afin d'accéder à l'interface d'enregistrement et d'appel des événements, dont nous aurons besoin à l'avenir. <br><br>  Un tableau d'objets de la classe <code>Field</code> sera stocké dans la propriété privée <code>_fields</code> .  Nous implémenterons ce modèle plus tard. <br><br>  Nous avons configuré des propriétés numériques privées <code>_rows</code> et <code>_cols</code> pour indiquer le nombre de lignes et de colonnes du terrain de jeu.  Créez des getters publics pour lire les <code>_rows</code> et les <code>_cols</code> . <br><br>  Le champ <code>_bombs</code> nous indique le nombre de bombes qui devront être générées pour le niveau.  Et dans le paramètre <code>_scene</code> nous passons une référence à l'objet de la scène de jeu <code>GameScene</code> , dans lequel nous allons créer une instance de la classe <code>Board</code> . <br><br>  Il convient de noter que nous transférons l'objet de scène au modèle uniquement pour une transmission ultérieure aux vues, où nous ne l'utiliserons que pour afficher la vue.  Le fait est que le phaseur utilise directement l'objet scène pour rendre les sprites et nous oblige donc à fournir un lien vers la scène actuelle lors de la création de préfabriqués sprite, que nous développerons à l'avenir.  Et pour nous-mêmes, nous accepterons que nous transférions le lien vers la scène uniquement pour son utilisation ultérieure en tant que moteur d'affichage et convenons que nous n'appellerons pas directement les méthodes personnalisées de la scène dans les modèles et les vues. <br><br>  Une fois que nous avons décidé de l'interface de création de la carte, je propose de l'initialiser dans la scène de niveau, en finalisant la classe <code>GameScene</code> : <br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">// GameScene.ts import { Board } from "../models/Board"; const Rows = 8; const Cols = 8; const Bombs = 8; export class GameScene extends Phaser.Scene { private _board: Board = null; //... public create(): void { this._board = new Board(this, Rows, Cols, Bombs); } }</span></span></code> </pre> <br>  Nous prenons les paramètres de la carte en constantes au début du fichier de scène et les transmettons au constructeur de la carte lors de la création d'une instance de cette classe. <br><br><a name="section-3-2"></a><h3>  <font color="#008080">3.2 Modèle de cellule</font> </h3><br>  Le tableau se compose de cellules que vous souhaitez afficher à l'écran.  Chaque cellule doit être placée à la position correspondante, déterminée par la ligne et la colonne. <br><br>  Les cellules sont également sélectionnées en tant qu'entité distincte.  Créez le <code>src/scripts/models/Field.ts</code> dans lequel nous <code>src/scripts/models/Field.ts</code> la classe qui décrit la cellule: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Board } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./Board"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Field</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Events</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventEmitter</span></span></span><span class="hljs-class"> </span></span>{ private _scene: Phaser.Scene = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; private _board: Board = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; private _row: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; private _col: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(scene: Phaser.Scene, board: Board, row: number, col: number) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._init(scene, board, row, col); } public get col(): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._col; } public get row(): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._row; } public get board(): Board { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._board; } private _init(scene: Phaser.Scene, <span class="hljs-attr"><span class="hljs-attr">board</span></span>: Board, <span class="hljs-attr"><span class="hljs-attr">row</span></span>: number, <span class="hljs-attr"><span class="hljs-attr">col</span></span>: number): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._scene = scene; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._board = board; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._row = row; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._col = col; } }</code> </pre><br>  Chaque cellule doit avoir des métriques de ligne et de colonne dans lesquelles elle se trouve.  Nous avons configuré les paramètres <code>_board</code> et <code>_scene</code> pour définir des liens vers les objets du tableau et de la scène.  Nous implémentons des getters pour lire les <code>_row</code> , <code>_col</code> et <code>_board</code> . <br><br><a name="section-3-3"></a><h3>  <font color="#008080">3.3 Vue des cellules</font> </h3><br>  La cellule abstraite est créée et maintenant nous voulons la visualiser.  Pour afficher une cellule à l'écran, vous devez créer sa vue.  Créez le <code>src/scripts/views/FieldView.ts</code> et placez-y la classe de vue: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Field } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"../models/Field"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FieldView</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameObjects</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sprite</span></span></span><span class="hljs-class"> </span></span>{ private _model: Field = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(scene: Phaser.Scene, model: Field) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(scene, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'spritesheet'</span></span>, <span class="hljs-string"><span class="hljs-string">'closed'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._model = model; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._init(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._create(); } private _init(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } private _create(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } }</code> </pre><br>  Veuillez noter que nous avons fait de cette classe le descendant de <code>Phaser.GameObjects.Sprite</code> .  En termes de phaser, cette classe est devenue un préfabriqué sprite.  Autrement dit, j'ai obtenu la fonctionnalité de l'objet de jeu du sprite, que nous développerons davantage avec nos propres méthodes. <br><br>  Regardons le constructeur de cette classe.  Ici, tout d'abord, nous devons appeler le constructeur de la classe parente avec les ensembles de paramètres suivants: <br><br><ul><li>  lien vers l'objet scène (comme je l'avais prévenu dans la section 3.1: phaser nous oblige à créer un lien vers la scène actuelle afin de rendre les sprites) </li><li>  Coordonnées <code>x</code> et <code>y</code> sur toile </li><li>  la clé de chaîne pour laquelle l'atlas est disponible, que nous avons chargée dans la méthode de <code>preload</code> de la scène de départ </li><li>  la clé de chaîne de trame dans cet atlas que vous souhaitez sélectionner pour afficher le sprite </li></ul><br>  Définissez une référence au modèle (c'est-à-dire une instance de la classe <code>Field</code> ) dans la propriété <code>_model</code> privée. <br><br>  Nous avons également prudemment démarré 2 <code>_create</code> <code>_init</code> et <code>_create</code> actuellement vides, que nous implémenterons un peu plus tard. <br><br><a name="section-3-4"></a><h3>  <font color="#008080">3.4 Création d'un sprite dans une classe de vue</font> </h3><br>  Ainsi, la vue a été créée, mais elle ne sait toujours pas comment dessiner un sprite.  Pour placer l'image-objet avec le cadre dont nous avons besoin sur la toile, vous devrez modifier notre propre méthode <code>_create</code> privée: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.js //... private _create(): void { this.scene.add.existing(this); //      this.setOrigin(0.5); //  pivot point    } //...</span></span></code> </pre><br><a name="section-3-5"></a><h3>  <font color="#008080">3.5 Positionnement des sprites</font> </h3><br>  Pour le moment, tous les sprites créés seront placés dans les coordonnées (0, 0) du canevas.  Nous devons également placer chaque cellule dans sa position correspondante sur la carte.  C'est-à-dire à l'endroit qui correspond à la ligne et à la colonne de cette cellule.  Pour ce faire, nous devons écrire un code pour calculer les coordonnées de chaque instance de la classe <code>FieldView</code> . <br><br>  Ajoutez la propriété <code>_position</code> à la classe, qui est responsable des coordonnées finales de la cellule sur le terrain de jeu: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... interface Vec2 {x: number, y: number}; export class FieldView extends Phaser.GameObjects.Sprite { private _position: Vec2 = {x: 0, y: 0}; //...</span></span></code> </pre><br>  Puisque nous voulons aligner la carte et, par conséquent, les cellules qu'elle <code>_offset</code> , par rapport au centre de l'écran, nous avons également besoin de la propriété <code>_offset</code> , indiquant le décalage de cette cellule particulière par rapport aux bords gauche et supérieur de l'écran.  Ajoutez-le avec un getter privé: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private get _offset(): Vec2 { return { x: (this.scene.cameras.main.width - this._model.board.cols * this.width) / 2, y: (this.scene.cameras.main.height - this._model.board.rows * this.height) / 2 }; } //...</span></span></code> </pre><br>  Ainsi, nous: <br><br><ol><li>  Vous avez la largeur totale de l'écran dans <code>this._scene.cameras.main.width</code> . </li><li>  Nous avons obtenu la largeur totale de la planche en multipliant le nombre de cellules par la largeur d'une cellule: <code>this._board.cols * this.width</code> . </li><li>  En enlevant la largeur de la planche à la largeur de l'écran, nous avons obtenu une place sur l'écran, non occupée par la planche. </li><li>  En divisant le nombre résultant par 2, nous avons obtenu la valeur de retrait à gauche et à droite de la carte. </li><li>  En décalant chaque cellule de la valeur de cette indentation, nous garantissons l'alignement de la carte entière le long de l'axe <code>x</code> . </li></ol><br>  Nous effectuons des actions absolument similaires pour obtenir un déplacement vertical. <br><br>  Il reste à ajouter le code nécessaire dans la méthode <code>_init</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts // ... private _init(): void { const offset = this._offset; this.x = this._position.x = offset.x + this.width * this._model.col + this.width / 2; this.y = this._position.y = offset.y + this.height * this._model.row + this.height / 2; } // ...</span></span></code> </pre><br>  Les propriétés <code>this.x</code> , <code>this.y</code> , <code>this.width</code> et <code>this.height</code> sont les propriétés héritées de la classe parente <code>Phaser.GameObjects.Sprite</code> .  La modification des propriétés de <code>this.x</code> et <code>this.y</code> conduit au positionnement correct du sprite sur la toile. <br><br><a name="section-3-6"></a><h3>  <font color="#008080">3.6 Création d'une instance de FieldView</font> </h3><br>  Créez une vue dans la classe <code>Field</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts // ... private _view: FieldView = null; public get view(): FieldView { return this._view; } private _init(scene: Phaser.Scene, board: Board, row: number, col: number): void { //... this._view = new FieldView(this._scene, this); } // ...</span></span></code> </pre><br><a name="section-3-7"></a><h3>  <font color="#008080">3.7 Afficher les champs de la carte.</font> </h3><br>  Revenons à la classe <code>Board</code> , qui est essentiellement une collection d'objets <code>Field</code> et va créer des cellules. <br><br>  Nous allons retirer le code de création de la carte dans une méthode <code>_create</code> distincte et appeler cette méthode depuis le constructeur.  Sachant que dans la méthode <code>_create</code> , nous ne créerons pas seulement des cellules, nous <code>_createFields</code> le code de création de cellules dans une méthode <code>_createFields</code> distincte. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts constructor(scene: Phaser.Scene, rows: number, cols: number, bombs: number) { // ... this._create(); } private _create(): void { this._createFields(); } private _createFields(): void { }</span></span></code> </pre><br>  C'est dans cette méthode que nous allons créer le nombre de cellules souhaité dans une boucle imbriquée: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts // ... private _createFields(): void { for (let row = 0; row &lt; this._rows; row++) { for (let col = 0; col &lt; this._cols; col++) { this._fields.push(new Field(this._scene, this, row, col)); } } } //...</span></span></code> </pre><br>  Il est temps pour la première fois d'exécuter l'assembly pour le débogage avec la commande <br><br><pre> <code class="plaintext hljs">npm start</code> </pre> <br>  Assurez-vous qu'au centre de l'écran, nous nous attendons à voir 64 cellules sur 8 rangées. <br><br><a name="section-3-8"></a><h3>  <font color="#008080">3.8 Fabrication de bombes</font> </h3><br>  Plus tôt, j'ai signalé que dans la méthode <code>_create</code> de la classe <code>Board</code> , nous ne créerons pas seulement des champs.  Quoi d'autre?  Il y aura également la création de bombes et le réglage des cellules créées au nombre de bombes voisines.  Commençons par les bombes elles-mêmes. <br><br>  Nous devons placer N bombes sur le plateau dans des cellules aléatoires.  Nous décrivons le processus de création de bombes avec un algorithme approximatif: <br><br><pre> <code class="plaintext hljs">                        </code> </pre><br>  À chaque itération de la boucle, nous obtiendrons une cellule aléatoire de la propriété <code>this._fields</code> jusqu'à ce que nous créons autant de bombes que celles indiquées dans le champ <code>this._bombs</code> ,.  Si la cellule reçue est vide, nous y installerons une bombe et mettrons à jour le compteur des bombes nécessaires à la génération. <br><br>  Pour générer un nombre aléatoire, nous utilisons la méthode statique <code>Phaser.Math.Between</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... private _createBombs(): void { let count = this._bombs; //      while (count &gt; 0) { //       let field = this._fields[Phaser.Math.Between(0, this._fields.length - 1)]; //    if (field.empty) { //     field.setBomb(); //     --count; //    } } }</span></span></code> </pre><br>  N'oubliez pas d'écrire l'appel à <code>this._createBombs();</code> dans le fichier <code>Board.ts</code> <code>this._createBombs();</code>  à la fin de la méthode <code>_create</code> <br><br>  Comme vous l'avez déjà remarqué, pour que ce code fonctionne correctement, vous devez affiner la classe <code>Field</code> en y ajoutant le getter <code>empty</code> et la méthode <code>setBomb</code> . <br><br>  Ajoutez un champ <code>_value</code> privé à la <code>_value</code> Field, qui réglementera le contenu de la cellule.  Nous acceptons les accords suivants. <br><div class="scrollable-table"><table><tbody><tr><td>  <code>_value</code> === 0 </td><td>  la cellule est vide et ne contient ni mines ni valeurs </td></tr><tr><td>  <code>_value</code> === -1 </td><td>  il y a une mine dans la cellule </td></tr><tr><td>  <code>_value</code> &gt; 0 </td><td>  dans la cellule est le nombre de mines situées à côté de la cellule actuelle </td></tr></tbody></table></div><br>  En suivant ces règles, nous développerons des méthodes dans la classe <code>Field</code> qui fonctionnent avec la propriété <code>_value</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts // ... private _value: number = 0; // ... public get value(): number { return this._value; } public set value(value) { this._value = value; } public get empty(): boolean { return this._value === 0; } public get mined(): boolean { return this._value === -1; } public get filled(): boolean { return this._value &gt; 0; } public setBomb(): void { this._value = -1; } // ...</span></span></code> </pre><br><a name="section-3-9"></a><h3>  <font color="#008080">3.9 Réglage des valeurs</font> </h3><br>  Les bombes sont disposées et nous avons maintenant toutes les données afin de définir les valeurs numériques dans toutes les cellules qui en ont besoin. <br><br>  Permettez-moi de vous rappeler que selon les règles du sapeur, la cellule doit avoir le nombre qui correspond au nombre de bombes situées à côté de cette cellule.  Sur la base de cette règle, nous écrivons le pseudocode correspondant. <br><br><pre> <code class="plaintext hljs">                  </code> </pre><br>  Dans la classe <code>Board</code> , créez une nouvelle méthode et traduisez le pseudocode spécifié en code réel: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... private _createValues() { //      this._fields.forEach(field =&gt; { //      if (field.mined) { //     field.getClosestFields().forEach(item =&gt; { //      if (item.value &gt;= 0) { ++item.value; } }); } }); } //...</span></span></code> </pre><br>  Voyons laquelle des interfaces que nous utilisons n'est pas implémentée.  Vous devez ajouter la méthode <code>getClosestFields</code> pour obtenir les cellules voisines. <br><br>  Comment identifier les cellules voisines? <br><br>  Par exemple, considérez toute cellule de la carte qui n'est pas sur le bord, c'est-à-dire pas dans la ligne extrême et pas dans la colonne extrême.  Ces cellules ont un nombre maximum de voisins: 1 en haut, 1 en bas, 3 à gauche et 3 à droite (y compris les cellules en diagonale). <br><br>  Ainsi, dans chacune des cellules voisines, les indicateurs <code>_row</code> et <code>_col</code> ne diffèrent pas de plus de 1. Cela signifie que nous pouvons spécifier à l'avance la différence entre les paramètres <code>_row</code> et <code>_col</code> avec le champ courant.  Ajoutez une constante au début du fichier à la description de la classe: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts const Positions = [ {row : 0, col : 1}, //  {row : 0, col : -1}, //  {row : 1, col : 0}, //  {row : 1, col : 1}, //   {row : 1, col : -1}, //   {row : -1, col : 0}, //  {row : -1, col : 1}, //   {row : -1, col : -1} //   ]; //...</span></span></code> </pre><br>  Et maintenant, nous pouvons ajouter la méthode manquante, dans laquelle nous allons parcourir ce tableau: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts //... public getClosestFields(): Field[] { let results = []; //      Positions.forEach(position =&gt; { //      let field = this._board.getField(this._row + position.row, this._col + position.col); //       if (field) { //     results.push(field); } }); return results; }; //...</span></span></code> </pre><br>  N'oubliez pas de vérifier la variable de <code>field</code> à chaque itération, car toutes les cellules de la carte n'ont pas 8 voisins.  Par exemple, la cellule supérieure gauche n'aura pas de voisins à sa gauche, etc. <br><br>  Il reste à implémenter la méthode <code>getField</code> et à ajouter tous les appels nécessaires à la méthode <code>_create</code> dans la classe <code>Board</code> <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public getField(row: number, col: number): Field { return this._fields.find(field =&gt; field.row === row &amp;&amp; field.col === col); } //... private _create(): void { this._createFields(); this._createBombs(); this._createValues(); } //...</span></span></code> </pre><br><a name="section-4"></a><h2> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Gestion des événements d'entrée</font></font></font> </h2><br><a name="section-4-1"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.1 Suivi des événements de clic de souris</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour le moment, le tableau est complètement initialisé, il a des bombes et il y a des cellules avec des numéros, mais toutes sont actuellement fermées et il n'y a aucun moyen de les ouvrir. </font><font style="vertical-align: inherit;">Nous allons corriger cela et implémenter l'ouverture des cellules en cliquant sur le bouton gauche de la souris. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout d'abord, nous devons suivre ce clic. </font><font style="vertical-align: inherit;">Dans la classe, </font></font><code>FieldView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ajoutez le </font></font><code>_create</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">code suivant </font><font style="vertical-align: inherit;">à la toute fin de la méthode </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FielView.ts //... private _create(): void { // ... this.setInteractive(); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans phaser, vous pouvez vous abonner à des objets de l'espace de noms pour différents événements </font></font><code>Phaser.GameObjects</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. En particulier, nous souscrirons à l'événement click ( </font></font><code>pointerdown</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) le préfabriqué du sprite lui-même, c'est-à-dire un objet d'une classe </font></font><code>FieldView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">héritée de </font></font><code>Phaser.GameObjects.Sprite</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais avant de le faire, nous devons explicitement indiquer que le sprite est potentiellement interactif, c'est-à-dire que vous devez généralement écouter les entrées de l'utilisateur à ce sujet. Vous devez le faire en appelant la méthode </font></font><code>setInteractive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sans paramètres sur le sprite lui-même, ce que nous avons fait dans l'exemple ci-dessus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que notre image-objet est devenue interactive, revenons à la classe </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à l'endroit où de nouveaux objets de modèle sont créés </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, à savoir la méthode </font></font><code>_createFields</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et enregistrons le rappel des événements d'entrée pour la vue:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... private _createFields(): void { for (let row = 0; row &lt; this._rows; row++) { for (let col = 0; col &lt; this._cols; col++) { const field = new Field(this._scene, this, row, col) field.view.on('pointerdown', this._onFieldClick.bind(this, field)); this._fields.push(field); } } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une fois que nous avons établi qu'en cliquant sur le sprite que nous voulons exécuter la méthode </font></font><code>_onFieldClick</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous devons l'implémenter. Mais nous supprimerons la logique de traitement du clic de la classe </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. On pense qu'il est préférable de traiter le modèle en fonction de l'entrée et de modifier en conséquence ses données dans un contrôleur séparé, dont la similitude est la classe de la scène du jeu </font></font><code>GameScene</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Nous devons donc transmettre l'événement de clic plus loin, de la classe </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à la scène elle-même. Nous allons donc faire:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... private _onFieldClick(field: Field, pointer: Phaser.Input.Pointer): void { if (pointer.leftButtonDown()) { this.emit(`left-click`, field); } else if (pointer.rightButtonDown()) { this.emit(`right-click`, field); } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ici, nous ne jetons pas simplement l'événement click tel qu'il était, mais nous spécifions également de quel clic il s'agissait. </font><font style="vertical-align: inherit;">Cela sera utile à l'avenir, lorsque dans la classe de scène, nous traiterons chaque option différemment. </font><font style="vertical-align: inherit;">Bien sûr, il serait possible d'envoyer l'événement click tel quel, mais nous simplifierons le code de la scène, en laissant une partie de la logique concernant l'événement lui-même dans la classe </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eh bien, revenons maintenant à la classe de la scène de jeu </font></font><code>GameScene</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et ajoutons un </font></font><code>_create</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">code </font><font style="vertical-align: inherit;">à la fin de la méthode </font><font style="vertical-align: inherit;">qui suit les événements d'un clic sur les cellules:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... import { Field } from "../models/Field"; //... public create(): void { this._board = new Board(this, Rows, Cols, Bombs); this._board.on('left-click', this._onFieldClickLeft, this); this._board.on('right-click', this._onFieldClickRight, this); } private _onFieldClickLeft(field: Field): void { } private _onFieldClickRight(field: Field): void { } //...</span></span></code> </pre><br><a name="section-4-2"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.2. </font><font style="vertical-align: inherit;">Traitement du clic gauche</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous procédons à la mise en œuvre du traitement des événements de clic de souris. </font><font style="vertical-align: inherit;">Et commencez par ouvrir les cellules. </font><font style="vertical-align: inherit;">Les cellules doivent être ouvertes en appuyant sur le bouton gauche. </font><font style="vertical-align: inherit;">Et avant de commencer la programmation, parlons des conditions qui doivent être remplies:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lorsque vous cliquez sur une cellule fermée, elle doit être ouverte </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s'il y a une mine dans une cellule ouverte - le jeu est perdu </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s'il n'y a pas de mines ou de valeurs dans la cellule ouverte, alors min n'est pas dans les cellules voisines, dans ce cas, vous devez ouvrir toutes les cellules voisines et continuer jusqu'à ce que la valeur apparaisse dans la cellule ouverte </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lorsque vous cliquez sur une cellule ouverte, vous devez vérifier si tous les drapeaux sont définis correctement et si oui, puis terminer le jeu avec une victoire </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et maintenant, pour simplifier la compréhension des fonctionnalités requises, nous traduisons la logique ci-dessus en pseudo-code: </font></font><br><br><pre> <code class="plaintext hljs">                         </code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous comprenons maintenant ce qui doit être programmé. </font><font style="vertical-align: inherit;">Nous mettons en œuvre la méthode </font></font><code>_onFieldClickLeft</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts //... private _onFieldClickLeft(field: Field): void { if (field.closed) { //    field.open(); //   if (field.mined) { //    field.exploded = true; this._onGameOver(false); //   } else if (field.empty) { //    this._board.openClosestFields(field); //   } } else if (field.opened) { //    if (this._board.completed) { //       this._onGameOver(true); //   } } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et puis, comme toujours, nous finaliserons les classes </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et y </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implémenterons ces méthodes que nous appelons dans le gestionnaire. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous indiquons 3 états possibles de la cellule dans l'énumération </font></font><code>States</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ajoutons un champ </font></font><code>_state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et implémentons un getter pour chaque état possible:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts enum States { Closed = 'closed', Opened = 'opened', Marked = 'flag' }; export class Field extends Phaser.Events.EventEmitter { private _state: string = States.Closed; //... public get marked(): boolean { return this._state === States.Marked; } public get closed(): boolean { return this._state === States.Closed; } public get opened(): boolean { return this._state === States.Opened; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que nous avons des états indiquant si la cellule est fermée ou non, nous pouvons ajouter une méthode </font></font><code>open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui changera l'état:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts //... public open(): void { this._setState(States.Opened); } private _setState(state: string): void { if (this._state !== state) { this._state = state; this.emit('change'); } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chaque modification de l'état du modèle doit déclencher un événement qui le signale. </font><font style="vertical-align: inherit;">Par conséquent, nous introduisons une méthode privée supplémentaire </font></font><code>_setState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans laquelle toute la logique du changement d'état sera implémentée. </font><font style="vertical-align: inherit;">Cette méthode sera appelée dans toutes les méthodes publiques du modèle, ce qui devrait changer son état. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez un indicateur booléen </font></font><code>_exploded</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour indiquer explicitement exactement l'objet Field qui a explosé:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts private _exploded: boolean = false; //... public set exploded(exploded: boolean) { this._exploded = exploded; this.emit('change'); } public get exploded(): boolean { return this._exploded; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ouvrez maintenant la classe </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et implémentez-y la méthode </font></font><code>openClosestFields</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cette méthode est récursive et sa tâche sera d'ouvrir tous les champs voisins vides par rapport à la cellule acceptée dans le paramètre. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'algorithme sera le suivant:</font></font><br><br><pre> <code class="plaintext hljs"> :                </code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et cette fois, nous avons déjà toutes les interfaces nécessaires pour la mise en œuvre complète de cette méthode: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public openClosestFields(field: Field): void { field.getClosestFields().forEach(item =&gt; {//     if (item.closed) {//    item.open();//   if (item.empty) {//    this.openClosestFields(item);//     } } }); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez un getter </font></font><code>completed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à la classe </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour indiquer l'emplacement correct des drapeaux sur le tableau. </font><font style="vertical-align: inherit;">Comment pouvons-nous déterminer si une planche a été effacée avec succès? </font><font style="vertical-align: inherit;">Le nombre de champs correctement marqués doit être égal au nombre total de bombes sur le plateau.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public get completed(): boolean { return this._fields.filter(field =&gt; field.completed).length === this._bombs; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette méthode filtre le tableau </font></font><code>_fields</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par getter </font></font><code>completed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ce qui devrait indiquer la validité de la marque de champ. </font><font style="vertical-align: inherit;">Si la longueur du tableau filtré (dans lequel seuls les champs correctement marqués tombent, pour lesquels le getter est </font></font><code>completed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">déjà </font><font style="vertical-align: inherit;">responsable </font><font style="vertical-align: inherit;">de la classe </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) est égale à la valeur du champ </font></font><code>_bombs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(c'est-à-dire le nombre de bombes sur le plateau), alors nous revenons </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, en d'autres termes, nous considérons que le jeu est gagné. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela ne nous dérange pas non plus d'avoir la possibilité d'ouvrir tout le tableau en un seul appel, ce que nous devons faire à la fin du niveau. </font><font style="vertical-align: inherit;">Nous ajouterons également cette fonctionnalité à la classe </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public open(): void { this._fields.forEach(field =&gt; field.open()); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il reste à ajouter un getter </font></font><code>completed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à la classe elle-même </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dans quel cas le champ sera-t-il considéré comme effacé avec succès? </font><font style="vertical-align: inherit;">S'il est extrait et signalé. </font><font style="vertical-align: inherit;">Les deux getters nécessaires sont déjà là et nous pouvons ajouter cette méthode:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts //... public get completed(): boolean { return this.marked &amp;&amp; this.mined; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour terminer le traitement du clic gauche de la souris, nous allons créer une méthode </font></font><code>_onGameOver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans laquelle nous désactiverons le suivi des événements du plateau et montrerons au joueur l'ensemble du plateau. </font><font style="vertical-align: inherit;">Plus tard, nous y ajouterons également un code de rendu du rapport d'achèvement d'état basé sur le paramètre </font></font><code>status</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts //... private _onGameOver(status: boolean) { this._board.off('left-click', this._onFieldClickLeft, this); this._board.off('right-click', this._onFieldClickRight, this); this._board.open(); } //...</span></span></code> </pre><br><a name="section-4-3"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.3 Affichage sur le terrain</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avant de commencer le traitement du clic droit, nous apprendrons à redessiner les cellules nouvellement ouvertes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plus tôt dans la classe, </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous avons développé une méthode </font></font><code>_setState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui déclenche un événement </font></font><code>change</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lorsque l'état du modèle change. Nous l'utiliserons et dans la classe, nous </font></font><code>FieldView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tracerons cet événement:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _init(): void { //... this._model.on('change', this._onStateChange, this); } private _onStateChange(): void { this._render(); } private _render(): void { this.setFrame(this._frameName); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons spécifiquement fait de la méthode intermédiaire un </font></font><code>_onStateChange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rappel de l'événement de changement de modèle. </font><font style="vertical-align: inherit;">À l'avenir, nous devrons vérifier comment le modèle a été modifié afin de comprendre s'il est nécessaire d'effectuer </font></font><code>_render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour afficher l'image-objet actuelle d'une cellule dans un nouvel état, vous devez modifier son cadre. </font><font style="vertical-align: inherit;">Puisque nous avons chargé l'atlas en tant qu'actifs, nous pouvons appeler la méthode </font></font><code>setFrame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">afin de changer le cadre courant en un nouveau. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour obtenir le cadre sur une seule ligne, nous avons astucieusement utilisé le getter </font></font><code>_frameName</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui doit maintenant être implémenté. </font><font style="vertical-align: inherit;">Tout d'abord, nous décrivons toutes les valeurs possibles qu'une trame de cellule peut prendre.</font></font><br><div class="scrollable-table"><table><tbody><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cadre </font></font></td><td>  Condition </td></tr><tr><td> <code>closed</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le champ est fermé </font></font><br></td></tr><tr><td> <code>flag</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Champ marqué </font></font><br></td></tr><tr><td> <code>empty</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le champ est ouvert, non extrait ou rempli de valeur </font></font><br></td></tr><tr><td> <code>exploded</code> <br> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> le champ est ouvert, miné et explosé </font></font><br></td></tr><tr><td> <code>mined</code> <br> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> le champ est ouvert, miné, mais pas explosé </font></font><br></td></tr><tr><td> <code>1...9</code> <br> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> le champ est ouvert et affiche une valeur de 1 à 9, indiquant le nombre de bombes à côté de ce champ </font></font><br></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons obtenu une description de tous les états et avons déjà toutes les méthodes du modèle, grâce auxquelles ces états peuvent être obtenus. </font><font style="vertical-align: inherit;">Obtenons une petite configuration au début du fichier:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts const States = { 'closed': field =&gt; field.closed, 'flag': field =&gt; field.marked, 'empty': field =&gt; field.opened &amp;&amp; !field.mined &amp;&amp; !field.filled, 'exploded': field =&gt; field.opened &amp;&amp; field.mined &amp;&amp; field.exploded, 'mined': field =&gt; field.opened &amp;&amp; field.mined &amp;&amp; !field.exploded } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les clés de cet objet seront les valeurs des trames et les valeurs de ces clés sont les rappels qui renvoient un résultat booléen. </font><font style="vertical-align: inherit;">Sur la base de cette configuration, nous pouvons développer une méthode pour obtenir la trame souhaitée (c'est-à-dire la clé de la configuration):</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private get _frameName(): string { for (let key in States) { if (States[key](this._model)) { return key; } } return this._model.value.toString(); }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainsi, par simple énumération dans une boucle, nous parcourons toutes les clés de l'objet config et appelons chaque rappel tour à tour. </font><font style="vertical-align: inherit;">La fonction qui nous renvoie en premier </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indiquera que la clé </font></font><code>key</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à l'itération actuelle est le cadre correct pour l'état actuel du modèle. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si aucune clé ne convient, alors pour l'état par défaut, nous considérerons un champ ouvert avec une valeur </font></font><code>_value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, car </font></font><code>States</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous n'avons pas défini </font><font style="vertical-align: inherit;">cet état dans la configuration </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons tester complètement le clic gauche sur les champs du tableau et vérifier comment les cellules s'ouvrent et ce qui s'affiche après leur ouverture.</font></font><br><br><a name="section-4-4"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.4 Traitement du clic droit</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme dans le cas de la création du gestionnaire de clic gauche, nous définissons d'abord clairement la fonctionnalité attendue. </font><font style="vertical-align: inherit;">En cliquant avec le bouton droit, nous devons marquer la cellule sélectionnée avec un drapeau. </font><font style="vertical-align: inherit;">Mais il y a certaines conditions.</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seul un champ fermé qui n'est pas actuellement marqué peut être marqué </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si le champ est coché, un clic droit à nouveau devrait supprimer le drapeau du champ </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lors de la définition / suppression d'un indicateur, il est nécessaire de mettre à jour le nombre d'indicateurs disponibles au niveau et d'afficher le texte avec le numéro actuel </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En traduisant ces conditions en pseudo-code, nous obtenons les lignes de commentaires suivantes: </font></font><br><br><pre> <code class="plaintext hljs">                              </code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous pouvons maintenant traduire cet algorithme en appels aux méthodes dont nous avons besoin, même si elles n'ont pas encore été développées: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts private _flags: number = 0; //... private _onFieldClickRight(field: Field): void { if (field.closed &amp;&amp; this._flags &gt; 0) { //        field.addFlag(); //     } else if (field.marked) { //     field.removeFlag(); //   } this._flags = Bombs - this._board.countMarked; } //... public create(): void { this._flags = Bombs; //... } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ici, nous avons également commencé un nouveau champ </font></font><code>_flags</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui au début du niveau de jeu est égal au nombre de bombes sur le plateau, car au début du jeu, aucun drapeau n'a été défini. </font><font style="vertical-align: inherit;">Ce champ est obligé d'être mis à jour à chaque clic droit, car dans ce cas, le drapeau est ajouté ou supprimé du tableau. </font><font style="vertical-align: inherit;">Ajoutez un </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getter </font><font style="vertical-align: inherit;">à la classe </font></font><code>countMarked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public get countMarked(): number { return this._fields.filter(field =&gt; field.marked).length; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La définition et la suppression de l'indicateur est un changement dans l'état du modèle </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous implémentons donc ces méthodes dans la classe correspondante de manière similaire à la méthode </font></font><code>open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts //... public addFlag(): void { this._setState(States.Marked); } public removeFlag(): void { this._setState(States.Closed); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Permettez-moi de vous rappeler que cela </font></font><code>_setState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">déclenchera un événement </font></font><code>change</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui est suivi dans la vue et, par conséquent, le sprite sera redessiné automatiquement cette fois lorsque le modèle change. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors du test des fonctionnalités développées, vous constaterez certainement qu'à chaque fois que vous cliquez sur le bouton droit de la souris, un menu contextuel s'ouvre. </font><font style="vertical-align: inherit;">Ajoutez le code qui désactive ce comportement au constructeur de la scène de jeu:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts //... constructor() { super('Game'); //        document.querySelector("canvas").oncontextmenu = e =&gt; e.preventDefault(); } //...</span></span></code> </pre><br><a name="section-4-5"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.5 Objet GameSceneView</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour afficher l'interface utilisateur sur la scène du jeu, nous allons créer une classe </font></font><code>GameSceneView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et la placer </font></font><code>src/scripts/views/GameSceneView.ts</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans ce cas, nous agirons d'une manière différente de la création </font></font><code>FieldView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et ne ferons pas de cette classe un préfabriqué et un héritier </font></font><code>GameObjects</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans ce cas, nous devons sortir les éléments suivants de la vue de la scène:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> texte dans le nombre de drapeaux </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bouton de sortie </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Message d'état de fin de partie (gagnant / perdant) </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faisons de chaque élément de l'interface utilisateur un champ distinct dans la classe </font></font><code>GameSceneView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous allons préparer un talon.</font></font><br><br><pre> <code class="javascript hljs">enum Styles { Color = <span class="hljs-string"><span class="hljs-string">'#008080'</span></span>, Font = <span class="hljs-string"><span class="hljs-string">'Arial'</span></span> } enum Texts { Flags = <span class="hljs-string"><span class="hljs-string">'FLAGS: '</span></span>, Exit = <span class="hljs-string"><span class="hljs-string">'EXIT'</span></span>, Success = <span class="hljs-string"><span class="hljs-string">'YOU WIN!'</span></span>, Failure = <span class="hljs-string"><span class="hljs-string">'YOU LOOSE'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameSceneView</span></span></span><span class="hljs-class"> </span></span>{ private _scene: Phaser.Scene = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; private _style: {<span class="hljs-attr"><span class="hljs-attr">font</span></span>: string, <span class="hljs-attr"><span class="hljs-attr">fill</span></span>: string}; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(scene: Phaser.Scene) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._scene = scene; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._style = {<span class="hljs-attr"><span class="hljs-attr">font</span></span>: <span class="hljs-string"><span class="hljs-string">`28px </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${Styles.Font}</span></span></span><span class="hljs-string">`</span></span>, <span class="hljs-attr"><span class="hljs-attr">fill</span></span>: Styles.Color}; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._create(); } private _create(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } public render() { } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ajoutez du texte avec le nombre de drapeaux. </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameSceneView.ts //... private _txtFlags: Phaser.GameObjects.Text = null; //... private _createTxtFlags(): void { this._txtFlags = this._scene.add.text( 50, 50, Texts.Flags, this._style ).setOrigin(0, 1); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce code mettra le texte dont nous avons besoin dans une position en retrait de 50 pixels à partir des côtés supérieur et gauche et le définira dans le style spécifié. </font><font style="vertical-align: inherit;">De plus, la méthode </font></font><code>setOrigin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">définit le point de pivot du texte sur les coordonnées (0, 1). </font><font style="vertical-align: inherit;">Cela signifie que le texte s'alignera sur sa bordure gauche. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez un message d'état.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameSceneView.ts //... private _txtStatus: Phaser.GameObjects.Text = null; //... private _createTxtStatus(): void { this._txtStatus = this._scene.add.text( this._scene.cameras.main.centerX, 50, Texts.Success, this._style ).setOrigin(0.5, 1); this._txtStatus.visible = false; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous plaçons le texte d'état au centre de l'écran et l'alignons avec le milieu de la ligne en appelant </font></font><code>setOrigin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec le paramètre 0.5 pour la coordonnée x. </font><font style="vertical-align: inherit;">De plus, par défaut, ce texte doit être masqué, car nous ne l'afficherons qu'à la fin du jeu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Créez un bouton de sortie, qui dans son essence est également un objet texte.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameSceneView.ts //... private _btnExit: Phaser.GameObjects.Text = null; //... private _createBtnExit(): void { this._btnExit = this._scene.add.text( this._scene.cameras.main.width - 50, 50, Texts.Exit, this._style ).setOrigin(1); this._btnExit.setInteractive(); this._btnExit.once('pointerdown', () =&gt; { this._scene.scene.start('Start'); }); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous plaçons le bouton dans le coin supérieur droit de l'écran et l'utilisons à nouveau </font></font><code>setOrigin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour aligner le texte cette fois avec son bord droit. </font><font style="vertical-align: inherit;">Nous rendons le bouton interactif et ajoutons un rappel à l'événement click, qui envoie le joueur à la scène de départ. </font><font style="vertical-align: inherit;">Ainsi, nous donnons au joueur la possibilité de quitter le niveau à tout moment. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il reste à développer une méthode </font></font><code>render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour mettre à jour correctement tous les éléments de l'interface utilisateur et ajouter des appels à toutes les méthodes créées dans </font></font><code>_create</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameSceneView.ts //... private _create(): void { this._createTxtFlags(); this._createTxtStatus(); this._createBtnExit(); } public render(data: {flags?: number, status?: boolean}) { if (typeof data.flags !== 'undefined') { this._txtFlags.text = Texts.Flags + data.flags.toString(); } if (typeof data.status !== 'undefined') { this._txtStatus.text = data.status ? Texts.Success : Texts.Failure; this._txtStatus.visible = true; } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En fonction de la propriété passée dans le paramètre, nous mettons à jour l'interface utilisateur, en affichant les modifications nécessaires. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Créez une représentation dans la scène du jeu dans la classe GameScene et écrivez l'appel à la méthode _render partout où cela est requis en signifiant:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts //... import { GameSceneView } from "../views/GameSceneView"; //... export class GameScene extends Phaser.Scene { private _view: GameSceneView = null; //... private _onGameOver(status: boolean) { //... this._view.render({status}); } //... private _onFieldClickRight(field: Field): void { //... this._flags = Bombs - this._board.countMarked; this._view.render({flags: this._flags}); } //... public create(): void { //... this._view = new GameSceneView(this); this._view.render({flags: this._flags}); } //... }</span></span></code> </pre><br><a name="section-5"></a><h2> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Animations</font></font></font> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quel genre de fan de créer un jeu, même aussi simple que le nôtre, s'il n'y a pas d'animations?!! </font><font style="vertical-align: inherit;">De plus, depuis que nous avons commencé à étudier le phaser, familiarisons-nous avec les fonctionnalités les plus élémentaires des animations et considérons la fonctionnalité des jumeaux. </font><font style="vertical-align: inherit;">Les jumeaux sont implémentés dans le cadre lui-même et aucune bibliothèque tierce n'est requise. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez 2 animations au jeu: remplir le tableau de cellules au début et retourner la cellule à l'ouverture. </font><font style="vertical-align: inherit;">Commençons par le premier.</font></font><br><br><a name="section-5-1"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.1 Animation de remplissage du tableau</font></font></font> </h3><br><img src="https://habrastorage.org/webt/7r/uu/1v/7ruu1vtppaw26sp-fapxbahgm9q.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous nous assurons que toutes les cellules de la carte volent en place à partir du bord supérieur gauche de l'écran. </font><font style="vertical-align: inherit;">Lors du démarrage du niveau de jeu, nous devons déplacer toutes les cellules dans le coin supérieur gauche de l'écran et pour chaque cellule démarrer l'animation du mouvement à ses coordonnées correspondantes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la classe, </font></font><code>FiledView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ajoutez l' </font></font><code>_create</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">appel </font><font style="vertical-align: inherit;">à la fin des méthodes </font></font><code>_animateShow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _create(): void { //... this._animateShow(); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B nous mettons en œuvre la nouvelle méthode dont nous avons besoin. </font><font style="vertical-align: inherit;">Dans ce document, comme nous l'avons convenu ci-dessus, il est nécessaire d'effectuer 2 choses:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> déplacer la cellule derrière le coin supérieur gauche afin qu'elle ne soit pas visible à l'écran </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> démarrer le mouvement jumeau aux coordonnées souhaitées avec le retard correct </font></font></li></ol><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _animateShow(): Promise&lt;void&gt; { this.x = -this.width; this.y = -this.height; const delay = this._model.row * 50 + this._model.col * 10; return this._moveTo(this._position, delay); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étant donné que le coin supérieur gauche du canevas a des coordonnées (0, 0), si nous définissons la cellule sur les coordonnées égales à ses valeurs négatives de largeur et de hauteur, cela placera la cellule derrière le coin supérieur gauche et la masquera à l'écran. </font><font style="vertical-align: inherit;">Ainsi, nous avons terminé notre première tâche. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous atteindrez le deuxième objectif en appelant la méthode </font></font><code>_moveTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _moveTo(position: Vec2, delay: number): Promise&lt;void&gt; { return new Promise(resolve =&gt; { this.scene.tweens.add({ targets: this, x: position.x, y: position.y, duration: 600, ease: 'Elastic', easeParams: [1, 1], delay, onComplete: () =&gt; { resolve(); } }); }); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour créer une animation, nous utilisons la propriété scene </font></font><code>tweens</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dans sa méthode, </font></font><code>add</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous passons l'objet de configuration avec les paramètres:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La propriété </font></font><code>targets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici doit contenir comme valeur les objets de jeu auxquels vous souhaitez appliquer des effets d'animation. </font><font style="vertical-align: inherit;">Dans notre cas, il s'agit d'un lien </font></font><code>this</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vers l'objet courant, car il s'agit d'un préfabriqué de l'image-objet.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les deuxième et troisième paramètres nous passent les coordonnées de la destination. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La propriété </font></font><code>duration</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est responsable de la durée de l'animation, dans notre cas - 600ms.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paramètres </font></font><code>ease</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>easeParams</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">définir la fonction d'accélération.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le champ de délai, nous substituons la valeur du deuxième argument, qui est généré pour chaque cellule individuelle, en tenant compte de sa position sur la carte. </font><font style="vertical-align: inherit;">Ceci est fait pour que les cellules ne volent pas en même temps. </font><font style="vertical-align: inherit;">Au lieu de cela, chaque cellule apparaîtra avec un léger retard par rapport à la précédente.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enfin, </font></font><code>onComplete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous mettons un rappel </font><font style="vertical-align: inherit;">dans la propriété </font><font style="vertical-align: inherit;">, qui sera appelé à la fin de l'action d'interpolation.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est raisonnable d'envelopper le jumeau dans une promesse afin qu'à l'avenir il puisse magnifiquement ancrer différentes animations, nous allons donc placer un appel de fonction dans le rappel </font></font><code>resolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indiquant la bonne exécution de l'animation.</font></font><br><br><a name="section-5-2"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.2 Animations de retournement de cellule</font></font></font> </h3><br><img src="https://habrastorage.org/webt/uc/d-/yw/ucd-yw-nq6a4veixb-npp0mdyqy.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce sera formidable si, lors de l'ouverture de la cellule, l'effet de son inversion se reproduisait. Comment pouvons-nous y parvenir? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'ouverture d'une cellule s'effectue actuellement en changeant le cadre lors de l'appel de la méthode </font></font><code>_render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans la vue. Si nous vérifions l'état du modèle dans cette méthode, nous verrons si la cellule était ouverte. Si la cellule était ouverte, démarrez l'animation au lieu d'afficher instantanément un nouveau cadre d'inversion.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _onStateChange(): void { if (this._model.opened) { this._animateFlip(); } else { this._render(); } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour obtenir l'effet souhaité, nous utiliserons la transformation du sprite à travers la propriété </font></font><code>scale</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Si nous redimensionnons le sprite le long de l'axe </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à zéro au </font><font style="vertical-align: inherit;">fil du temps </font><font style="vertical-align: inherit;">, il finira par rétrécir, reliant les côtés gauche et droit. </font><font style="vertical-align: inherit;">Et vice versa, si vous redimensionnez le sprite le long de l'axe </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de zéro à sa pleine largeur, nous l'étirons à sa taille maximale. </font><font style="vertical-align: inherit;">Nous implémentons cette logique dans la méthode </font></font><code>_animateFlip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _animateFlip(): void { this._scaleXTo(0).then(() =&gt; { this._render(); this._scaleXTo(1); }) } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par analogie avec la méthode, nous mettons en </font></font><code>_moveTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">œuvre </font></font><code>_scaleTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _scaleXTo(scaleX: number): Promise&lt;void&gt; { return new Promise(resolve =&gt; { this.scene.tweens.add({ targets: this, scaleX, ease: 'Elastic.easeInOut', easeParams: [1, 1], duration: 150, onComplete: () =&gt; { resolve() } }); }); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans cette méthode, en tant que paramètre, nous prenons la valeur de l'échelle, que nous utiliserons pour changer la taille du sprite dans les deux sens et la passer comme second paramètre à l'objet de configuration d'animation. </font><font style="vertical-align: inherit;">Tous les autres paramètres de configuration nous sont déjà familiers depuis l'animation précédente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous allons maintenant commencer le projet pour les tests et après le débogage, nous considérerons notre jeu terminé et la tâche de test terminée!</font></font> :) <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Je remercie sincèrement tout le monde d'avoir atteint ce moment avec moi! </font></font><br><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chers collègues, je serai très heureux si le matériel présenté dans l'article vous est utile et vous pouvez utiliser ces approches ou celles décrites dans vos propres projets. Vous pouvez toujours vous adresser à moi pour toute question, à la fois sur cet article, et sur la programmation phaser ou travailler dans gamedev en général. J'accueille la communication et serai heureux de faire de nouvelles connaissances et d'échanger des expériences! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et j'ai une question pour vous en ce moment. Depuis que je crée des tutoriels vidéo sur le développement de jeux, j'ai naturellement accumulé une douzaine de ces petits jeux. Chaque jeu ouvre le framework à sa manière. Par exemple, dans ce jeu, nous avons abordé le sujet des jumeaux, mais il existe de nombreuses autres fonctionnalités, telles que la physique, le tilemap, la colonne vertébrale, etc.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À cet égard, la question est: avez-vous aimé cet article et, si oui, seriez-vous intéressé à continuer à lire des articles comme celui-ci, mais à propos d'autres petits jeux classiques? </font><font style="vertical-align: inherit;">Si la réponse est oui, je me ferai un plaisir de traduire le matériel de mes didacticiels vidéo au format texte et de continuer à publier de nouveaux manuels au fil du temps, mais pour d'autres jeux. </font><font style="vertical-align: inherit;">J'apporte l'enquête correspondante. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Merci à tous pour votre attention! </font><font style="vertical-align: inherit;">Je serai heureux de vos commentaires et à bientôt!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr476682/">https://habr.com/ru/post/fr476682/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr476670/index.html">Vue d'ensemble de la CAO sur le noyau géométrique C3D - 2</a></li>
<li><a href="../fr476674/index.html">Déploiement rapide de ReportPortal pour la familiarisation</a></li>
<li><a href="../fr476676/index.html">48 ressources open source pour JavaScript (2019)</a></li>
<li><a href="../fr476678/index.html">API pour l'extraction asynchrone à distance à l'aide d'Apple Combine</a></li>
<li><a href="../fr476680/index.html">Le système de planification de la production continue de Rodov est le Lean / MRP soviétique de 1961. Décollage, coucher de soleil et nouvelle naissance</a></li>
<li><a href="../fr476686/index.html">Développement d'une passerelle IoT basée sur Raspberry CM3 +</a></li>
<li><a href="../fr476688/index.html">Nouveau cours d'OTUS. «Développeur IOS. Cours avancé V 2.0 »</a></li>
<li><a href="../fr476692/index.html">Principes du marketing de contenu</a></li>
<li><a href="../fr476694/index.html">A propos de la robotique d'entreprise avec Farida Roslovets et directrice de la société RPA electroNeek</a></li>
<li><a href="../fr476696/index.html">Comment créer et déployer Full Stack React application</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>