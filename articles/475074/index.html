<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòè üëäüèª üßëüèæ‚Äçü§ù‚Äçüßëüèª Introducci√≥n a ECMAScript 2017 (ES8) üìõ ü§öüèª üï•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tabla de contenidos 
 Pr√≥logo 
 Descripci√≥n general de ES7 
 1. Entradas de objeto 
 2. Valores del objeto 
 3. String.prototype.padEnd 
 4. String.pr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introducci√≥n a ECMAScript 2017 (ES8)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/475074/"><h4>  Tabla de contenidos </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Pr√≥logo</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Descripci√≥n general de ES7</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1. Entradas de objeto</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2. Valores del objeto</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3. String.prototype.padEnd</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4. String.prototype.padStart</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">5. Object.getOwnPropertyDescriptor</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">6. Comas finales</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">7. SharedArrayBuffer</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">8. Atomics</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">9. Funciones as√≠ncronas</a> <br><br><a name="section000"></a><h2>  Pr√≥logo </h2><br>  Hola, en el pasado ya consideraba las innovaciones en ES6 y ahora es el momento de desarmar ES8 ya que trajo muchas cosas nuevas.  No consider√© ES7 (2016) por separado, ya que esta versi√≥n trajo solo 2 innovaciones.  Este es Array.prototype.includes () y el operador de exponenciaci√≥n.  Pero a√∫n as√≠, antes de comenzar ES8, veamos las innovaciones de ES7. <br><br><a name="section0000"></a><h2>  Descripci√≥n general de ES7 </h2><br>  <b>El m√©todo incluye ()</b> determina si la matriz contiene un elemento espec√≠fico, devolviendo verdadero o falso dependiendo de esto. <br><br><pre><code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.includes(searchElement[, fromIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>]) : <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span></code> </pre> <br>  searchElement: el elemento a buscar. <br><br>  fromIndex: la posici√≥n en la matriz desde la que comenzar a buscar el elemento searchElement.  Para valores negativos, la b√∫squeda se realiza comenzando con el √≠ndice array.length + fromIndex ascendente.  El valor predeterminado es 0. <a name="habracut"></a><br><br>  <b>Ejemplos</b> <br><br><pre> <code class="javascript hljs">[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>].includes(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">// true [1, 2, 3].includes(4); // false [1, 2, 3].includes(3, 3); // false [1, 2, 3].includes(3, -1); // true [1, 2, NaN].includes(NaN); // true</span></span></code> </pre> <br>  Incluye () se puede aplicar a otros tipos de objetos (por ejemplo, objetos en forma de matriz).  Ejemplo: usar el m√©todo incluye () en un objeto de argumentos. <br><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log([].includes.call(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// true console.log([].includes.call(arguments, 'd')); // false })('a','b','c');</span></span></code> </pre> <br>  <b>El operador de exponenciaci√≥n</b> (**) devuelve una potencia con base ay un exponente natural b.  Elevar a al poder de b. <br><br><pre> <code class="javascript hljs">a ** b</code> </pre> <br>  <b>Ejemplos</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">2</span></span> ** <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-comment"><span class="hljs-comment">// 8 3 ** 2 // 9 3 ** 2.5 // 15.588457268119896 10 ** -1 // 0.1 NaN ** 2 // NaN 2 ** 3 ** 2 // 512 2 ** (3 ** 2) // 512 (2 ** 3) ** 2 // 64 -(2 ** 2) // -4 (-2) ** 2 // 4</span></span></code> </pre> <br><a name="section001"></a><h2>  1. Entradas de objeto </h2><br>  Object.entries () devuelve una matriz cuyos elementos son matrices correspondientes a la propiedad enumerada del par [clave, valor] que se encuentra directamente en el objeto.  El orden de las propiedades es el mismo que cuando recorre las propiedades de un objeto manualmente. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.entries(obj) : <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span></code> </pre> <br>  obj: un objeto cuyas propiedades enumeradas se devolver√°n como una matriz [clave, valor]. <br><br>  Object.entries () devuelve las propiedades en el mismo orden que en el bucle for ... in (la diferencia es que for-in tambi√©n enumera las propiedades de la cadena del prototipo).  El orden de los elementos en la matriz que Object.entries () devuelve es independiente de c√≥mo se declara el objeto.  Si se necesita un orden espec√≠fico, la matriz debe ordenarse antes de llamar al m√©todo. <br><br>  <b>Ejemplos</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-string"><span class="hljs-string">"bar"</span></span>, <span class="hljs-attr"><span class="hljs-attr">baz</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.entries(obj)); <span class="hljs-comment"><span class="hljs-comment">// [ ['foo', 'bar'], ['baz', 42] ] //    var obj = { 0: 'a', 1: 'b', 2: 'c' }; console.log(Object.entries(obj)); // [ ['0', 'a'], ['1', 'b'], ['2', 'c'] ] //    c random   var an_obj = { 100: 'a', 2: 'b', 7: 'c' }; console.log(Object.entries(an_obj)); // [ ['2', 'b'], ['7', 'c'], ['100', 'a'] ] // getFoo  ,    var my_obj = Object.create({}, { getFoo: { value: function() { return this.foo; } } }); my_obj.foo = "bar"; console.log(Object.entries(my_obj)); // [ ['foo', 'bar'] ] // non-object     object console.log(Object.entries("foo")); // [ ['0', 'f'], ['1', 'o'], ['2', 'o'] ] let obj = { one: 1, two: 2 }; for (let [k,v] of Object.entries(obj)) console.log(`${JSON.stringify(k)}: ${JSON.stringify(v)}`) // "one": 1 // "two": 2</span></span></code> </pre> <br>  <b>Convertir objeto a mapa</b> <br><br>  El nuevo constructor Map () acepta la repetici√≥n de valores.  Con Object.entries, puede convertir f√°cilmente Object a Map.  Esto es m√°s conciso que usar una matriz de matrices de 2 elementos, pero las claves solo pueden ser cadenas. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-string"><span class="hljs-string">"bar"</span></span>, <span class="hljs-attr"><span class="hljs-attr">baz</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> map = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.entries(obj)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(map); <span class="hljs-comment"><span class="hljs-comment">// Map {"foo" =&gt; "bar", "baz" =&gt; 42}</span></span></code> </pre> <br>  ¬øPor qu√© el valor de retorno de Object.entries () es una matriz y no un iterador? <br>  El caso de uso correspondiente en este caso es Object.keys (), y no, por ejemplo, Map.prototype.entries (). <br><br>  ¬øPor qu√© Object.entries () devuelve solo propiedades nativas enumeradas con claves de cadena? <br><br>  Nuevamente, esto se hace para que coincida con Object.keys ().  Este m√©todo tambi√©n ignora las propiedades cuyas claves son caracteres.  Al final, puede haber un m√©todo Reflect.ownEntries () que devuelve todas sus propias propiedades. <br><br>  Ver object.entries en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">especificaci√≥n</a> oficial, as√≠ como en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">MDN Web Docs</a> . <br><br><a name="section002"></a><h2>  2. Valores del objeto </h2><br>  Object.values ‚Äã‚Äã() devuelve una matriz cuyos elementos son los valores de las propiedades enumeradas que se encuentran en el objeto.  El orden es el mismo que si recorre el objeto manualmente. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.values(obj) : <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span></code> </pre> <br>  obj: un objeto cuyos valores de las propiedades enumeradas se devolver√°n. <br><br>  El m√©todo Object.values ‚Äã‚Äã() devuelve una matriz de valores de las propiedades enumeradas del objeto en el mismo orden que el bucle for ... in.  La diferencia entre un bucle y un m√©todo es que el bucle enumera propiedades desde y desde la cadena de prototipos. <br><br>  <b>Ejemplos</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-string"><span class="hljs-string">"bar"</span></span>, <span class="hljs-attr"><span class="hljs-attr">baz</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.values(obj)); <span class="hljs-comment"><span class="hljs-comment">// ['bar', 42] //    var obj = { 0: 'a', 1: 'b', 2: 'c' }; console.log(Object.values(obj)); // ['a', 'b', 'c']</span></span></code> </pre><br>  La diferencia entre Object.entries y Object.values ‚Äã‚Äã() es que el primero devuelve una matriz de matrices que contienen el nombre y el valor de la propiedad, mientras que la segunda solo devuelve una matriz con el valor de las propiedades. <br><br>  <b>Ejemplo de diferencia entre Object.values ‚Äã‚Äã() y Object.entries ()</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-string"><span class="hljs-string">'somestring'</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.values(object)); <span class="hljs-comment"><span class="hljs-comment">// ["somestring", 42, false] console.log(Object.entries(object)); // [ ["a", "somestring"], ["b", 42], ["c", false] ]</span></span></code> </pre> <br>  Consulte Object.values ‚Äã‚Äã() en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">especificaci√≥n</a> oficial, as√≠ como en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">MDN Web Docs</a> . <br><br><a name="section003"></a><h2>  3. String.prototype.padEnd </h2><br>  El m√©todo padEnd () completa la l√≠nea actual con la cadena dada (eventualmente repiti√©ndose) para que la cadena resultante alcance la longitud especificada.  La adici√≥n se aplica al final (derecha) de la l√≠nea actual. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">String</span></span>.prototype.padEnd(maxLength [ , fillString ]) : <span class="hljs-built_in"><span class="hljs-built_in">String</span></span></code> </pre> <br>  maxLength: la longitud de la fila resultante despu√©s de que se haya rellenado la fila actual.  Si este par√°metro es menor que la longitud de la l√≠nea actual, la l√≠nea actual se devolver√° tal cual. <br>  fillString: una cadena para complementar la l√≠nea actual.  Si esta l√≠nea es demasiado larga, se truncar√° y se aplicar√° la izquierda.  "" (0x0020 SPACE) es el valor predeterminado para este par√°metro. <br><br>  <b>Ejemplos</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">'abc'</span></span>.padEnd(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-comment"><span class="hljs-comment">// "abc " 'abc'.padEnd(10, "foo"); // "abcfoofoof" 'abc'.padEnd(6,"123456"); // "abc123"</span></span></code> </pre> <br>  Los casos de uso para llenar cadenas incluyen: <br><br><ul><li>  Agregar un contador o identificador a un nombre de archivo o URL: 'archivo 001.txt' </li><li>  Alineaci√≥n de salida de la consola: "Prueba 001: ‚úì" </li><li>  Imprima n√∫meros hexadecimales o binarios con un n√∫mero fijo de d√≠gitos: '0x00FF' </li></ul><br>  Consulte String.prototype.padEnd en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">especificaci√≥n</a> oficial, as√≠ como en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">MDN Web Docs</a> . <br><br><a name="section004"></a><h2>  4. String.prototype.padStart </h2><br>  El m√©todo padStart () llena la l√≠nea actual con otra l√≠nea (varias veces, si es necesario) para que la l√≠nea resultante alcance la longitud especificada.  El llenado se lleva a cabo al comienzo (izquierda) de la l√≠nea actual. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">String</span></span>.prototype.padStart(maxLength [, fillString]) : <span class="hljs-built_in"><span class="hljs-built_in">String</span></span></code> </pre> <br>  maxLength: la longitud de la l√≠nea de resumen despu√©s de completar la l√≠nea actual.  Si el valor es menor que la longitud de la l√≠nea actual, la l√≠nea actual se devolver√° sin cambios. <br><br>  fillString: una cadena para llenar la l√≠nea actual.  Si esta cadena es demasiado larga para la longitud dada, se truncar√°.  El valor predeterminado es "" (0x0020 SPACE). <br><br>  <b>Ejemplos</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">'abc'</span></span>.padStart(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-comment"><span class="hljs-comment">// " abc" 'abc'.padStart(10, "foo"); // "foofoofabc" 'abc'.padStart(6,"123465"); // "123abc" 'abc'.padStart(8, "0"); // "00000abc" 'abc'.padStart(1); // "abc"</span></span></code> </pre> <br>  ¬øPor qu√© los m√©todos de relleno no se llaman padLeft y padRight? <br><br>  Para los idiomas bidireccionales o de derecha a izquierda, los t√©rminos "izquierda" y "derecha" no funcionan.  Por lo tanto, la denominaci√≥n de padStart y padEnd sigue los nombres existentes que comienzan con beginWith y endsWith. <br><br>  Consulte String.prototype.padStart en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">especificaci√≥n</a> oficial, as√≠ como en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">MDN Web Docs</a> . <br><br><a name="section005"></a><h2>  5. Object.getOwnPropertyDescriptor </h2><br>  El m√©todo Object.getOwnPropertyDescriptor () devuelve un descriptor de propiedad para su propia propiedad (es decir, una ubicada directamente en el objeto y no recibida a trav√©s de la cadena del prototipo) del objeto pasado.  Si la propiedad no existe, devuelve indefinido. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptor(obj, prop) : <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span></code> </pre> <br>  obj: el objeto en el que se busca la propiedad. <br><br>  prop: el nombre de la propiedad cuya descripci√≥n se devolver√°. <br><br>  Este m√©todo le permite ver la descripci√≥n exacta de la propiedad.  Una propiedad en JavaScript consta de un nombre de cadena y un descriptor de propiedad. <br><br>  Un descriptor de propiedad es un registro con algunos de los siguientes atributos: <br><br><ul><li>  valor: el valor asociado con la propiedad (solo en el descriptor de datos). </li><li>  escribible: verdadero si el valor asociado con la propiedad se puede cambiar; de lo contrario, falso (solo en el descriptor de datos). </li><li>  get: una funci√≥n que devuelve el valor de la propiedad, o no est√° definida si no existe dicha funci√≥n (solo en el descriptor de acceso). </li><li>  set: una funci√≥n que cambia el valor de una propiedad, o no est√° definida si no existe tal funci√≥n (solo en el descriptor de acceso). </li><li>  configurable: verdadero si el tipo de identificador de esta propiedad se puede cambiar y si la propiedad se puede eliminar del objeto que la contiene; de ‚Äã‚Äãlo contrario, es falso. </li><li>  enumerable: verdadero si esta propiedad est√° disponible al enumerar las propiedades del objeto que lo contiene; de ‚Äã‚Äãlo contrario, es falso. </li></ul><br>  <b>Ejemplos</b> <br><br><pre> <code class="javascript hljs">obj = { get foo() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>; } }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptor(obj, <span class="hljs-string"><span class="hljs-string">'foo'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// {set: undefined, enumerable: true, configurable: true, get: ∆í} obj2 = { bar: 42 }; console.log(Object.getOwnPropertyDescriptor(obj2, 'bar')); // {value: 42, writable: true, enumerable: true, configurable: true}</span></span></code> </pre> <br><h4>  Casos de uso para Object.getOwnPropertyDescriptor () </h4><br>  <b>Primer</b> caso de uso: copiar propiedades a un objeto <br>  Comenzando con ES6, JavaScript ya tiene un m√©todo de herramienta para copiar propiedades: Object.assign ().  Sin embargo, este m√©todo utiliza operaciones simples de obtenci√≥n y configuraci√≥n para copiar una propiedad cuya clave es la clave: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> value = source[key]; <span class="hljs-comment"><span class="hljs-comment">// get target[key] = value; // set</span></span></code> </pre>  Esto significa que no copia correctamente las propiedades con atributos distintos a los especificados por defecto (m√©todos para obtener, configurar, escribir, etc.).  El siguiente ejemplo ilustra esta limitaci√≥n.  La fuente del objeto tiene un instalador cuya clave es foo: <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> source = { set foo(value) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(value); } }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptor(source, <span class="hljs-string"><span class="hljs-string">'foo'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// { get: undefined, set: [Function: foo], enumerable: true, configurable: true }</span></span></code> </pre> <br>  El uso de Object.assign () para copiar la propiedad foo en el objeto de destino falla: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> target1 = {}; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign(target1, source); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptor(target1, <span class="hljs-string"><span class="hljs-string">'foo'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// { value: undefined, writable: true, enumerable: true, configurable: true }</span></span></code> </pre>  Afortunadamente, el uso de Object.getOwnPropertyDescriptors () junto con Object.defineProperties () funciona: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> target2 = {}; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperties(target2, <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptors(source)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptor(target2, <span class="hljs-string"><span class="hljs-string">'foo'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// { get: undefined, set: [Function: foo], enumerable: true, configurable: true }</span></span></code> </pre> <br>  <b>Segundo</b> caso de uso: clonaci√≥n de objetos <br>  La clonaci√≥n superficial es similar a las propiedades de copia, por lo que Object.getOwnPropertyDescriptors () tambi√©n es una buena opci√≥n aqu√≠. <br><br>  Esta vez usamos Object.create (), que tiene dos par√°metros: <br>  El primer par√°metro especifica el prototipo del objeto devuelto. <br><br>  Un segundo par√°metro opcional es una colecci√≥n de descriptores de propiedades, similares a los devueltos por Object.getOwnPropertyDescriptors (). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> clone = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getPrototypeOf(obj), <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptors(obj));</code> </pre> <br>  <b>Tercer</b> caso de uso: literales de objetos multiplataforma con prototipos arbitrarios. <br><br>  La mejor manera sint√°ctica de usar un objeto literal para crear un objeto con un prototipo arbitrario es usar la propiedad especial __proto__: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">__proto__</span></span>: prot, <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-number"><span class="hljs-number">123</span></span>, };</code> </pre> <br>  Por desgracia, esta caracter√≠stica est√° garantizada para estar presente solo en los navegadores.  La soluci√≥n general es Object.create () y asignaci√≥n: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(prot); obj.foo = <span class="hljs-number"><span class="hljs-number">123</span></span>;</code> </pre> <br>  Pero tambi√©n puede usar Object.getOwnPropertyDescriptors (): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create( prot, <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptors({ <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-number"><span class="hljs-number">123</span></span>, }) );</code> </pre> <br>  Otra alternativa es Object.assign (): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign( <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(prot), { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-number"><span class="hljs-number">123</span></span>, } );</code> </pre> <br>  Dificultad: copiar m√©todos usando super. <br><br>  El m√©todo que super utiliza est√° estrechamente vinculado a su objeto de inicio (el objeto en el que se almacena).  Actualmente no hay forma de copiar o mover dicho m√©todo a otro objeto. <br><br>  Consulte Object.getOwnPropertyDescriptor en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">especificaci√≥n</a> oficial, as√≠ como en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">MDN Web Docs</a> . <br><br><a name="section006"></a><h2>  6. Comas finales </h2><br>  Comas colgantes (comas finales): pueden ser √∫tiles al agregar nuevos elementos, par√°metros o propiedades al c√≥digo JavaScript.  Si desea agregar una nueva propiedad, simplemente agregue una nueva l√≠nea sin cambiar la anterior, si la coma colgante ya est√° en ella.  Esto hace que las diferencias en el control de versiones sean m√°s limpias y los cambios de c√≥digo pueden ser menos problem√°ticos. <br><br><h4>  Comas colgantes en literales </h4><br>  <b>Matrices</b> <br><br>  JavaScript ignora las comas colgantes en las matrices: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr = [ <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, ]; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr); <span class="hljs-comment"><span class="hljs-comment">// [0, 1, 2] console.log(arr.length); // 3 var arr2 = [0, 1, 2,,,]; console.log(arr2.length); // 5 arr2.forEach((e) =&gt; console.log(e)); // 0 1 2 console.log(arr.map((e) =&gt; e)); // 0 1 2</span></span></code> </pre> <br>  Si se usa m√°s de un punto colgante, se crear√°n agujeros.  Una matriz con "agujeros" se llama dispersa (una matriz densa no tiene "agujeros").  Al iterar una matriz utilizando, por ejemplo, Array.prototype.forEach () o Array.prototype.map (), se omitir√°n los agujeros. <br><br>  <b>Los objetos</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-string"><span class="hljs-string">"bar"</span></span>, <span class="hljs-attr"><span class="hljs-attr">baz</span></span>: <span class="hljs-string"><span class="hljs-string">"qwerty"</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span>, }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(object); <span class="hljs-comment"><span class="hljs-comment">// {foo: "bar", baz: "qwerty", age: 42}</span></span></code> </pre> <br><h4>  Comas colgantes en funciones </h4><br>  <b>Par√°metro Definici√≥n</b> <br><br>  Las siguientes definiciones de par√°metros de funci√≥n son v√°lidas y equivalentes entre s√≠.  Las comas colgantes no afectan la propiedad de longitud de una funci√≥n o sus argumentos objeto. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p</span></span></span><span class="hljs-function">) </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p,</span></span></span><span class="hljs-function">) </span></span>{} (p) =&gt; {}; <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p,</span></span></span><span class="hljs-function">) =&gt;</span></span> {};</code> </pre> <br>  <b>Definici√≥n del m√©todo</b> <br><br>  La coma colgante tambi√©n funciona con m√©todos de definici√≥n para clases u objetos. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{ one(a,) {}, two(a, b,) {}, } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { one(a,) {}, two(a, b,) {}, };</code> </pre> <br>  <b>Llamada a la funci√≥n</b> <br><br>  Las siguientes llamadas a funciones son v√°lidas y equivalentes entre s√≠. <br><br><pre> <code class="javascript hljs">f(p); f(p,); <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.max(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.max(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>,);</code> </pre> <br>  <b>Comas colgantes inv√°lidas</b> <br><br>  Definir par√°metros de funci√≥n o llamar a una funci√≥n que contenga solo una coma generar√° un SyntaxError.  Adem√°s, cuando se usan los par√°metros restantes, no se permiten comas colgantes. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">,</span></span></span><span class="hljs-function">) </span></span>{} <span class="hljs-comment"><span class="hljs-comment">// SyntaxError: missing formal parameter (,) =&gt; {}; // SyntaxError: expected expression, got ',' f(,) // SyntaxError: expected expression, got ',' function f(...p,) {} // SyntaxError: parameter after rest parameter (...p,) =&gt; {} // SyntaxError: expected closing parenthesis, got ','</span></span></code> </pre> <br><h4>  Comas colgantes en la desestructuraci√≥n </h4><br>  Las comas colgantes tambi√©n se pueden usar a la izquierda cuando se usa una asignaci√≥n destructiva. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      [a, b,] = [1, 2]; //      var o = { p: 42, q: true, }; var {p, q,} = o;</span></span></code> </pre> <br>  Una vez m√°s, utilizando los par√°metros restantes, se lanzar√° un SyntaxError. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> [a, ...b,] = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// Uncaught SyntaxError: Rest element must be last element</span></span></code> </pre> <br><h4>  JSON Dangling Comas </h4><br>  Las comas colgantes en un objeto solo est√°n permitidas en ECMAScript 5. Dado que JSON se basa en la sintaxis de JavaScript anterior a ES5, <b>las comas colgantes</b> no est√°n permitidas <b>en JSON.</b> <br><br>  Ambas l√≠neas arrojan un SyntaxError <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(<span class="hljs-string"><span class="hljs-string">'[1, 2, 3, 4, ]'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(<span class="hljs-string"><span class="hljs-string">'{"foo" : 1, }'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Uncaught SyntaxError: Unexpected token ] in JSON // Uncaught SyntaxError: Unexpected token } in JSON</span></span></code> </pre> <br><h4>  ¬øPor qu√© son √∫tiles las comas colgantes? </h4><br>  Hay dos beneficios. <br><br>  En primer lugar, reorganizar los elementos es m√°s f√°cil porque no es necesario agregar o quitar comas si el √∫ltimo elemento cambia su posici√≥n. <br><br>  En segundo lugar, ayuda a los sistemas de control de versiones a realizar un seguimiento de lo que realmente ha cambiado.  Por ejemplo, de: <br><br><pre> <code class="plaintext hljs">[ 'Foo' ] : [ 'Foo', '' ]</code> </pre> <br>  hace que tanto la l√≠nea con 'foo' como la l√≠nea con 'barra' se marquen como modificadas, aunque el √∫nico cambio real es agregar la √∫ltima l√≠nea. <br><br>  Ver Comillas finales en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">MDN Web Docs</a> . <br><br><a name="section007"></a><h2>  7. SharedArrayBuffer </h2><br>  El objeto SharedArrayBuffer se usa para crear un b√∫fer dividido de longitud fija para almacenar datos binarios primitivos, similar al objeto ArrayBuffer, pero en contraste, las instancias SharedArrayBuffer se pueden usar para crear una vista en la memoria compartida.  SharedArrayBuffer no se puede desconectar. <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SharedArrayBuffer(length) : <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span></code> </pre>  longitud: el tama√±o, en bytes, para crear la matriz de b√∫fer. <br><br>  return - Un nuevo objeto SharedArrayBuffer de la longitud especificada.  Su contenido despu√©s de la inicializaci√≥n es 0. <br><br>  PostMessage y la clonaci√≥n estructurada se utilizan para dividir la memoria utilizando un objeto SharedArrayBuffer entre un agente en el cl√∫ster y otro (el agente puede ser el programa principal de la p√°gina web o uno de los trabajadores web). <br><br>  El algoritmo de clonaci√≥n estructurada acepta SharedArrayBuffers y TypedArrays asignados a SharedArrayBuffers.  En ambos casos, el objeto SharedArrayBuffer se pasa al receptor, lo que crea un nuevo objeto privado SharedArrayBuffer dentro del agente receptor (igual que para ArrayBuffer).  Sin embargo, el bloque de datos compartidos al que hacen referencia ambos objetos SharedArrayBuffer es el mismo bloque de datos, y los efectos de terceros en el bloque en uno de los agentes eventualmente ser√°n visibles en el otro agente. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sab = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SharedArrayBuffer(<span class="hljs-number"><span class="hljs-number">1024</span></span>); worker.postMessage(sab);</code> </pre> <br>  La memoria compartida se puede crear y cambiar simult√°neamente en los trabajadores o en el hilo principal.  Dependiendo del sistema (CPU, SO, navegador), puede llevar tiempo hasta que los cambios se propaguen a todos los contextos.  Para la sincronizaci√≥n, se necesitan operaciones at√≥micas. <br><br>  Shared Array Buffers es un bloque de construcci√≥n primitivo para abstracciones de paralelismo de nivel superior.  Le permiten compartir los bytes de un objeto SharedArrayBuffer entre varios trabajadores y el subproceso principal (el b√∫fer se comparte para acceder a los bytes, envolverlo en una matriz con tipo).  Este tipo de intercambio tiene dos ventajas: <br>  Puede intercambiar datos entre trabajadores m√°s r√°pido. <br><br>  La coordinaci√≥n entre los trabajadores se vuelve m√°s f√°cil y r√°pida (en comparaci√≥n con postMessage ()). <br><br>  La implementaci√≥n del trabajador es la siguiente. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// worker.js self.addEventListener ('message', function (event) { const {sharedBuffer} = event.data; const sharedArray = new Int32Array (sharedBuffer); // ¬∑¬∑¬∑ });</span></span></code> </pre><br>  Primero, extraemos el b√∫fer de la matriz compartida que nos enviaron y luego lo envolvemos en una matriz tipada para que podamos usarlo localmente. <br><br>  <b>Propiedades y m√©todos de SharedArrayBuffer.</b> <br><br>  SharedArrayBuffer.length: la longitud del constructor SharedArrayBuffer cuyo valor es 1. <br>  SharedArrayBuffer.prototype: permite propiedades adicionales para todos los objetos SharedArrayBuffer. <br><br>  <b>Instancias SharedArrayBuffer</b> <br>  <b>Las propiedades</b> <br><br>  SharedArrayBuffer.prototype.constructor: define una funci√≥n que crea un prototipo de un objeto.  El valor inicial es el constructor est√°ndar SharedArrayBuffer incorporado. <br><br>  SharedArrayBuffer.prototype.byteLength (solo lectura): el tama√±o de la matriz en bytes.  Esto se establece cuando se crea la matriz y no se puede cambiar. <br><br>  <b>M√©todos</b> <br><br>  SharedArrayBuffer.prototype.slice () - Devuelve un nuevo SharedArrayBuffer cuyo contenido es una copia de los bytes de este SharedArrayBuffer desde el principio, incluido hasta el final, de la exclusiva.  Si el principio o el final es negativo, esto se refiere al √≠ndice desde el final de la matriz, no desde el principio.  Este m√©todo tiene el mismo algoritmo que Array.prototype.slice (). <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  SharedArrayBuffer     const buffer = new SharedArrayBuffer(16); const int32View = new Int32Array(buffer); //  view // produces Int32Array [0, 0, 0, 0] int32View[1] = 42; const sliced = new Int32Array(buffer.slice(4,12)); console.log(sliced); // Int32Array [42, 0]</span></span></code> </pre> <br><pre> <code class="javascript hljs">sab.slice([begin, end]) : <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span></code> </pre> <br>  begin: el √≠ndice cero en el que comienza la extracci√≥n.  Puede usar un √≠ndice negativo que indique el desplazamiento desde el final de la secuencia.  slice (-2) extrae los dos √∫ltimos elementos en una secuencia.  Si el comienzo no est√° definido, el segmento comienza en el √≠ndice 0. <br>  Fin: el √≠ndice de base cero en el que se debe completar la extracci√≥n. <br><br>  Por ejemplo, el segmento (1,4) recupera el segundo elemento a trav√©s del cuarto elemento (elementos con los √≠ndices 1, 2 y 3).  Puede usar un √≠ndice negativo que indique el desplazamiento desde el final de la secuencia.  slice (2, -1) recupera el tercer elemento a trav√©s del pen√∫ltimo elemento de la secuencia.  Si se omite el final, corte las recuperaciones hasta el final de la secuencia (sab.byteLength). <br><br>  <b>Ejemplos</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sab = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SharedArrayBuffer(<span class="hljs-number"><span class="hljs-number">1024</span></span>); sab.slice(); <span class="hljs-comment"><span class="hljs-comment">// SharedArrayBuffer { byteLength: 1024 } sab.slice(2); // SharedArrayBuffer { byteLength: 1022 } sab.slice(-2); // SharedArrayBuffer { byteLength: 2 } sab.slice(0, 1); // SharedArrayBuffer { byteLength: 1 }</span></span></code> </pre> <br>  Consulte SharedArrayBuffer en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">especificaci√≥n</a> oficial, as√≠ como en los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">documentos web de MDN</a> . <br><br><a name="section008"></a><h2>  8. Atomics </h2><br>  El objeto Atomics proporciona operaciones at√≥micas como m√©todos est√°ticos.  Usado con un objeto SharedArrayBuffer. <br><br>  Las operaciones at√≥micas se instalan en el m√≥dulo Atomics.  A diferencia de otros objetos globales, Atomics no es un constructor.  No se puede usar con el nuevo operador o para llamar a un objeto Atomics como una funci√≥n.  Todas las propiedades y m√©todos de Atomics son est√°ticos (como un objeto matem√°tico, por ejemplo). <br><br>  Cuando se comparte la memoria, varios hilos pueden leer y escribir los mismos datos en la memoria.  Las operaciones at√≥micas garantizan que los valores esperados se escribir√°n y leer√°n, y las operaciones se completar√°n antes de que la pr√≥xima operaci√≥n comience su trabajo, y no se interrumpir√°n. <br><br><h4>  Las propiedades </h4><br>  Atomics [Symbol.toStringTag]: el valor de esta propiedad es Atomics. <br><br><h4>  M√©todos </h4><br>  <b>Operaciones at√≥micas</b> <br><br><ul><li>  Atomics.add (): agrega el valor presentado al valor actual en la posici√≥n especificada en la matriz.  Devuelve el valor anterior en esta posici√≥n. </li><li>  Atomics.and (): calcula AND bit a bit en la posici√≥n de matriz especificada.  Devuelve el valor anterior en esta posici√≥n. </li><li>  Atomics.compareExchange (): guarda el valor presentado en la posici√≥n especificada de la matriz, si es equivalente al valor presentado.  Devuelve el valor anterior. </li><li> Atomics.exchange() ‚Äî       .   . </li><li> Atomics.load() ‚Äî      . </li><li> Atomics.or() ‚Äî   OR    .      . </li><li> Atomics.store() ‚Äî       .  . </li><li> Atomics.sub() ‚Äî          .      . </li><li> Atomics.xor() ‚Äî   XOR    .      . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El m√©todo est√°tico Atomics.add () agrega el valor al actual en la posici√≥n especificada en la matriz y devuelve el valor anterior en esta posici√≥n. </font><font style="vertical-align: inherit;">Esta operaci√≥n at√≥mica asegura que no se produzca otra escritura hasta que el valor modificado se vuelva a escribir.</font></font><br><br><pre> <code class="javascript hljs">Atomics.add(typedArray, index, value) : mixed</code> </pre> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">typedArray: una matriz dividida de enteros. </font><font style="vertical-align: inherit;">Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array o Uint32Array.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> index: la posici√≥n en typedArray para agregar valor. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> valor: el n√∫mero a agregar. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> return: el valor anterior en la posici√≥n especificada (typedArray [index]). </font></font></li></ul><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lanza un TypeError si el tipo typedArray no es uno de los tipos enteros v√°lidos. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lanza un TypeError si el tipo typedArray no es de tipo gen√©rico. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lanza RangeError si el √≠ndice est√° fuera de typedArray. </font></font></li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplos</font></font></b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sab = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SharedArrayBuffer(<span class="hljs-number"><span class="hljs-number">1024</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ta = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>(sab); Atomics.add(ta, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  0,   Atomics.load(ta, 0); // 12</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atomics.add () en la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">especificaci√≥n</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MDN Web Docs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Espera y notifica </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los m√©todos wait () y wake () se modelan sobre la base de futexes ("mutex de espacio de usuario r√°pido") Linux y proporcionan formas de esperar un momento cuando un cierto estado no se vuelve verdadero, y generalmente se usa como construcciones de bloqueo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atomics.wait () </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comprueba </font><font style="vertical-align: inherit;">si el </font><font style="vertical-align: inherit;">valor que a√∫n est√° representado est√° contenido en la posici√≥n especificada de la matriz y est√° inactivo o en espera. </font><font style="vertical-align: inherit;">Devuelve ok, no igual o expirado. </font><font style="vertical-align: inherit;">Si la espera no est√° permitida en el agente que realiza la llamada, arrojar√° un error de excepci√≥n (la mayor√≠a de los navegadores no permiten la espera () en la secuencia principal del navegador).</font></font><br><br><ul><li> Atomics.wait() ‚Äî ,               -.  ¬´ok¬ª, ¬´not-equal¬ª  ¬´timed-out¬ª.       ,     (    wait()    ). </li><li> Atomics.wake() ‚Äî   ,         .   ,   . </li><li> Atomics.isLockFree(size) ‚Äî  ,            .  true,                 (  ).   . </li></ul><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Problemas de optimizaci√≥n </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La optimizaci√≥n hace que el c√≥digo sea impredecible entre los trabajadores. </font><font style="vertical-align: inherit;">En subprocesos individuales, los compiladores pueden realizar optimizaciones que rompen el c√≥digo multiproceso. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tomemos, por ejemplo, el siguiente c√≥digo:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (sharedArray [<span class="hljs-number"><span class="hljs-number">0</span></span>] === <span class="hljs-number"><span class="hljs-number">123</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En un solo subproceso, el valor de sharedArray [0] nunca cambia durante la ejecuci√≥n del bucle (si sharedArray es una matriz o una matriz con tipo que no se ha corregido de ninguna manera). </font><font style="vertical-align: inherit;">Por lo tanto, el c√≥digo se puede optimizar de la siguiente manera:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tmp = sharedArray [<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (tmp === <span class="hljs-number"><span class="hljs-number">123</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, en modo multiproceso, esta optimizaci√≥n no nos permite usar esta plantilla para esperar los cambios realizados en otro hilo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otro ejemplo es el siguiente c√≥digo:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// main.js sharedArray [1] = 11; sharedArray [2] = 22;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En un hilo, puede reorganizar estas operaciones de escritura porque no se lee nada entre ellas. </font><font style="vertical-align: inherit;">Varios subprocesos experimentan problemas cuando espera que las grabaciones se realicen en un orden espec√≠fico:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// worker.js while (sharedArray [2]! == 22); console.log (sharedArray [1]); // 0  11</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Estos tipos de optimizaci√≥n hacen que sea casi imposible sincronizar las acciones de varios trabajadores que trabajan en el mismo b√∫fer con una matriz com√∫n. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Resolviendo problemas de optimizaci√≥n </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando la variable global Atomics, cuyos m√©todos tienen tres usos principales. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primer caso de uso: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sincronizaci√≥n. </font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los m√©todos at√≥micos se pueden usar para sincronizar con otros trabajadores. </font><font style="vertical-align: inherit;">Por ejemplo, las siguientes dos operaciones le permiten leer y escribir datos y los compiladores nunca las reordenan:</font></font><br><br><pre> <code class="javascript hljs">Atomics.load (TypedArray &lt;T&gt;, index) : T Atomics.store (TypedArray &lt;T&gt;, index, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: T) : T</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La idea es utilizar operaciones ordinarias para leer y escribir la mayor√≠a de los datos, mientras que las operaciones de Atomics (carga, almacenamiento y otros) aseguran que la lectura y la escritura sean seguras. A menudo utilizar√° sus propios mecanismos de sincronizaci√≥n, como bloqueos, que se basan en Atomics. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este es un ejemplo muy simple que siempre funciona gracias a Atomics (omit√≠ la configuraci√≥n sharedArray):</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// main.js console.log ('notified...'); Atomics.store (sharedArray, 0, 123); // worker.js while (Atomics.load (sharedArray, 0)! == 123); console.log ('notified');</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segundo caso de uso: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esperando notificaci√≥n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usar un ciclo while para esperar una notificaci√≥n no es muy eficiente, por lo que Atomics tiene operaciones que ayudan: Atomics.wait (Int32Array, index, value, timeout) y Atomics.wake (Int32Array, index, count). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tercer caso de uso: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">operaciones at√≥micas</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algunas </font><b><font style="vertical-align: inherit;">operaciones at√≥micas</font></b><font style="vertical-align: inherit;"> realizan operaciones aritm√©ticas y no pueden interrumpirse al mismo tiempo, lo que ayuda con la sincronizaci√≥n.</font></font> Por ejemplo: <br><br><pre> <code class="javascript hljs">Atomics.add (TypedArray &lt;T&gt;, index, value) : T</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En t√©rminos generales, esta operaci√≥n realiza: √≠ndice + = valor; </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problema con valores rotos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otro efecto problem√°tico con la memoria compartida son los valores rotos (basura): al leer, puede ver un valor intermedio, ni el valor anterior al nuevo valor se escribi√≥ en la memoria, ni el nuevo valor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La secci√≥n de Lecturas sin rasgaduras de la especificaci√≥n establece que no hay vac√≠os si y solo si:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tanto la lectura como la escritura se realizan a trav√©s de matrices escritas (no DataViews). </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ambas matrices escritas est√°n alineadas con sus memorias intermedias de matrices compartidas: sharedArray.byteOffset% sharedArray.BYTES_PER_ELEMENT === 0 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ambas matrices escritas tienen el mismo n√∫mero de bytes por elemento. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En otras palabras, los valores desgarrados son un problema cuando se accede al mismo b√∫fer de una matriz compartida a trav√©s de: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Uno o m√°s DateViews; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hay una o m√°s matrices tipadas no alineadas; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arreglos mecanografiados con diferentes tama√±os de elementos; </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para evitar una brecha en los valores en estos casos, use Atomics o sync. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Buffers de matriz compartidos en usos </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buffers de matriz compartidos y sem√°ntica de JavaScript para ejecutar una funci√≥n pendiente. JavaScript tiene la llamada sem√°ntica de ejecuci√≥n "antes de la finalizaci√≥n": cada funci√≥n puede esperar que no sea interrumpida por otro hilo hasta que se complete. Las funciones se convierten en transacciones y pueden ejecutar algoritmos completos, mientras que nadie ve los datos con los que trabajan en un estado intermedio. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los Buffers de matriz compartida interrumpen el ciclo hasta su finalizaci√≥n (RTC): los datos en los que la funci√≥n est√° trabajando pueden ser cambiados por otro hilo durante la ejecuci√≥n de la funci√≥n. Sin embargo, el c√≥digo controla por completo si se produce esta violaci√≥n de RTC: si no utiliza Buffers de matriz compartida, es seguro.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto es m√°s o menos similar a c√≥mo las funciones asincr√≥nicas violan RTC. All√≠ habilita la operaci√≥n de bloqueo con la palabra clave wait. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los Buffers de matriz compartida permiten que emscripten compile pthreads en asm.js. Citando la p√°gina de documentaci√≥n de emscripten: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Es] [Los Buffers de matriz compartidos permiten] Las aplicaciones de Emscripten comparten el mont√≥n de memoria principal entre los trabajadores web. Esto, junto con primitivas para at√≥micos de bajo nivel y compatibilidad con futex, permite que Emscripten implemente la compatibilidad con la API Pthreads (hilos POSIX). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Ru] [Los Buffers de matriz compartidos permiten] Las aplicaciones Emscripten comparten un mont√≥n de memoria principal entre los trabajadores web. Junto con las primitivas at√≥micas de bajo nivel y el soporte futex, Emscripten permite el soporte para la API Pthreads (hilos POSIX).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es decir, puede compilar c√≥digo C y C ++ multiproceso en asm.js. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay una discusi√≥n en curso sobre la mejor manera de usar el subprocesamiento m√∫ltiple en WebAssembly. </font><font style="vertical-align: inherit;">Dado que los trabajadores web son relativamente pesados, es posible que WebAssembly introduzca hilos livianos. </font><font style="vertical-align: inherit;">Tambi√©n puede ver que los temas est√°n en camino hacia el futuro de WebAssembly.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Intercambiar datos que no sean enteros </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por el momento, solo se pueden usar matrices de enteros (de hasta 32 bits de longitud). </font><font style="vertical-align: inherit;">Esto significa que la √∫nica forma de compartir otros tipos de datos es codificarlos como enteros. </font><font style="vertical-align: inherit;">Las herramientas que pueden ayudar incluyen:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TextEncoder y TextDecoder: el primero convierte cadenas a instancias Uint8Array, el segundo hace lo contrario. </font></font></li><li> stringview.js: ,      .   . </li><li> FlatJS:  JavaScript        (,   )    (ArrayBuffer  SharedArrayBuffer). JavaScript + FlatJS    JavaScript. JavaScript  (TypeScript  . .) . </li><li> TurboScript:  JavaScript-    .    asm.js  WebAssembly. </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al final, es probable que aparezcan mecanismos adicionales de alto nivel para el intercambio de datos. Y los experimentos continuar√°n descubriendo c√≥mo deber√≠an ser estos mecanismos. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øCu√°nto m√°s r√°pido funciona el c√≥digo que usa b√∫feres de matriz compartida?</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lars T. Hansen escribi√≥ dos implementaciones del algoritmo Mandelbrot (como se describe en su art√≠culo " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A Taste of JavaScript's New Parallel Primitives</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ", una versi√≥n secuencial y una versi√≥n paralela que utiliza varios trabajadores web. Hasta 4 trabajadores web y, por lo tanto, n√∫cleos de procesador, aceleraci√≥n aumenta casi linealmente, de 6.9 cuadros por segundo (1 trabajador web) a 25.4 cuadros por segundo (4 trabajadores web). M√°s trabajadores web traen mejoras de productividad adicionales, pero m√°s modestas.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hansen se√±ala que las aceleraciones son impresionantes, pero el trabajo paralelo se debe a un c√≥digo m√°s complejo. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Informaci√≥n adicional</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sobre Buffers de matriz compartida y tecnolog√≠as de soporte:</font></font><br><br><ul><li> <a href="" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memoria compartida: un breve tutorial</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de Lars T. Hansen</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una muestra de las nuevas primitivas paralelas de JavaScript</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> por Lars T. Hansen</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SharedArrayBuffer y Atomics Etapa 2.95 a Etapa 3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (PDF), diapositivas de Shu-yu Guo y Lars T. Hansen (30-11-2016) [diapositivas que acompa√±an a la oraci√≥n ES]</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los fundamentos de los trabajadores web</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> por Eric Bidelman [introducci√≥n a los trabajadores web].</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Otras tecnolog√≠as de concurrencia de JavaScript: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Path to Parallel JavaScript</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " de Dave Herman [descripci√≥n general de d√≥nde se mueve JavaScript despu√©s de abandonar PJS]</font></font></li><li> ‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Write massively-parallel GPU code for the browser with WebGL</a> ‚Äù by Steve Sanderson [ , ,   WebGL      GPU]. </li><li> ‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Concurrency is not parallelism</a> ‚Äù by Rob Pike [Rob Pike   ¬´concurrency¬ª  ¬´parallelism¬ª    ]. </li><li> " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Using Web Workers</a> " from MDN [  MDN,      web workers]. </li><li> " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Shared memory and atomics</a> " by Axel Rauschmayer [     js   Shared Array Buffers  Atomics] </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consulte Objeto Atomics en la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">especificaci√≥n</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oficial </font><font style="vertical-align: inherit;">, as√≠ como en los </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentos web de MDN</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><a name="section009"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 9. Funciones as√≠ncronas </font></font></h2><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Crear una funci√≥n Async usando el constructor AsyncFunction </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El constructor AsyncFunction crea un nuevo objeto de funci√≥n as√≠ncrona. </font><font style="vertical-align: inherit;">En JavaScript, cualquier funci√≥n asincr√≥nica es en realidad un objeto AsyncFunction. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenga en cuenta que AsyncFunction no es un objeto global. </font><font style="vertical-align: inherit;">Se puede obtener ejecutando el siguiente c√≥digo.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getPrototypeOf(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{}).constructor</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sintaxis</font></font></b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AsyncFunction([arg1[, arg2[, ...argN]],] functionBody)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arg1, arg2, ... argN: nombres utilizados por la funci√≥n como nombres de argumentos formales. Cada nombre debe ser una cadena que coincida con un identificador de JavaScript v√°lido o una lista de tales cadenas separadas por comas; por ejemplo, "x", "theValue" o "a, b". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">functionBody: una cadena que contiene la definici√≥n de una funci√≥n en el c√≥digo fuente de JavaScript. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los objetos de funci√≥n as√≠ncrona creados con el constructor AsyncFunction se analizar√°n en el momento en que se cree la funci√≥n. Esto es menos eficiente que declarar una funci√≥n asincr√≥nica usando la expresi√≥n de funci√≥n as√≠ncrona y llamarla dentro de su c√≥digo, ya que dichas funciones se analizan con el resto del c√≥digo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todos los argumentos pasados ‚Äã‚Äãa la funci√≥n se tratan como los nombres de los identificadores de par√°metros en la funci√≥n creada en el orden en que se pasan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Llamar al constructor AsyncFunction como una funci√≥n (sin usar el nuevo operador) tiene el mismo efecto que llamarlo como un constructor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las funciones as√≠ncronas creadas con el constructor AsyncFunction no provocan un cortocircuito en los contextos que las crean; Siempre se crean en el √°mbito global. Cuando comiencen, solo podr√°n acceder a sus variables locales y variables globales, pero no tendr√°n acceso a los √°mbitos en los que se llam√≥ al constructor AsyncFunction. Esto es diferente de usar eval con el c√≥digo para la funci√≥n as√≠ncrona. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplo de creaci√≥n de una funci√≥n as√≠ncrona utilizando el constructor AsyncFunction</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolveAfter2Seconds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(x); }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); }); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> AsyncFunction = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getPrototypeOf(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{}).constructor <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AsyncFunction(<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-string"><span class="hljs-string">'return await resolveAfter2Seconds(a) + await resolveAfter2Seconds(b);'</span></span>); a(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(v); <span class="hljs-comment"><span class="hljs-comment">//  30  4  });</span></span></code> </pre> <br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Declaraci√≥n de funci√≥n as√≠ncrona </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La declaraci√≥n de funci√≥n asincr√≥nica define una funci√≥n asincr√≥nica que devuelve un objeto AsyncFunction. </font><font style="vertical-align: inherit;">Tambi√©n puede definir funciones as√≠ncronas utilizando la expresi√≥n de funci√≥n as√≠ncrona. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sintaxis</font></font></b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">name</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[param[, param[, ... param]]]</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// body }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nombre: el nombre de la funci√≥n. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">param: el nombre del argumento que se pasar√° a la funci√≥n. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">declaraciones - Una expresi√≥n que contiene el cuerpo de la funci√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de la llamada, la funci√≥n as√≠ncrona devuelve Promise. Cuando se ha recibido el resultado, Promise se completa y devuelve el valor recibido. Cuando la funci√≥n as√≠ncrona arroja una excepci√≥n, Promise fallar√° con un valor de lanzamiento. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La funci√≥n as√≠ncrona puede contener una expresi√≥n de espera que detiene la ejecuci√≥n de la funci√≥n as√≠ncrona y espera una respuesta de la Promesa aprobada, luego reanuda la funci√≥n as√≠ncrona y devuelve el valor recibido. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La palabra clave await es v√°lida solo en funciones asincr√≥nicas. En otro contexto, obtendr√° un error SyntaxError.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El prop√≥sito de las funciones as√≠ncrono / espera es simplificar el uso de promesas sincr√≥nicamente y jugar alguna acci√≥n en el grupo Promesas. </font><font style="vertical-align: inherit;">Al igual que las promesas son como devoluciones de llamada estructuradas, async / waitit es como una combinaci√≥n de generadores y promesas.</font></font><br><br>  <b>Ejemplo</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolveAfter2Seconds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(x); }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); }); } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> resolveAfter2Seconds(<span class="hljs-number"><span class="hljs-number">20</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> resolveAfter2Seconds(<span class="hljs-number"><span class="hljs-number">30</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + a + b; } add1(<span class="hljs-number"><span class="hljs-number">10</span></span>).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(v); <span class="hljs-comment"><span class="hljs-comment">//  60  4  }); async function add2(x) { const a = resolveAfter2Seconds(20); const b = resolveAfter2Seconds(30); return x + await a + await b; } add2(10).then(v =&gt; { console.log(v); //  60  2  });</span></span></code> </pre> <br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬øPara qu√© sirve la asincron√≠a? </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede escribir su programa JS en un archivo .js, pero su c√≥digo probablemente se dividir√° en varias partes. Y solo una de las partes se ejecutar√° ahora, y el resto se ejecutar√° m√°s adelante. La funci√≥n es la t√©cnica m√°s utilizada para dividir un programa en partes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El principal problema de la mayor√≠a de los desarrolladores que ven a JS por primera vez es la falta de comprensi√≥n de lo que no suceder√° inmediatamente despu√©s de ahora. En otras palabras, las tareas que no se pueden completar ahora, por definici√≥n, finalizar√°n de forma asincr√≥nica. Y no tendremos el comportamiento de bloqueo del programa que asumimos. (You-Dont-Know-JS / async &amp; performance, Jake Archibald).</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ajax(..)  Ajax-,   var data = ajax( "http://some.url.1" ); console.log( data );// !  `data`     Ajax-</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øCu√°l es el error aqu√≠? </font><font style="vertical-align: inherit;">console.log () ejecutado antes de recibir los datos de la solicitud. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La decisi√≥n obvia de "esperar" de ahora en adelante es usar devoluciones de llamada:</font></font><br><br><pre> <code class="javascript hljs">ajax( <span class="hljs-string"><span class="hljs-string">"http://some.url.1"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myCallbackFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( data ); <span class="hljs-comment"><span class="hljs-comment">// ,   ! } );</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Considere varios m√©todos para resolver la ejecuci√≥n de c√≥digo s√≠ncrono prematuramente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenemos 3 funciones getUser, getPosts, getComments.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { getUser, getPosts, getComments } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./db'</span></span>); getUser(<span class="hljs-number"><span class="hljs-number">1</span></span>, (error, user) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(error) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error); getPosts(user.id, (error, posts) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(error) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error); getComments(posts[<span class="hljs-number"><span class="hljs-number">0</span></span>].id, (error, comment) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(error) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(comments); }); }); });</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este ejemplo, es dif√≠cil no notar la pir√°mide, que aumenta con la incorporaci√≥n de nuevas funciones. Este estilo de codificaci√≥n com√∫nmente se llama </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Callback Hell</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Este es un cierto patr√≥n que le proporciona control sobre las solicitudes competidoras (as√≠ncronas), lo que garantiza la secuencia de su ejecuci√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte de la soluci√≥n al problema de las funciones de anidamiento es usar Promise (que discut√≠ en mi √∫ltimo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">art√≠culo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que lo elimina y hace que el c√≥digo sea m√°s limpio. Tambi√©n proporcionan una forma m√°s conveniente de manejar errores. Pero a muchos no les gust√≥ esta sintaxis.</font></font><br><br><pre> <code class="javascript hljs">getUser(<span class="hljs-number"><span class="hljs-number">1</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function"> =&gt;</span></span> getPosts(user,id)) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">posts</span></span></span><span class="hljs-function"> =&gt;</span></span> getComments(posts[<span class="hljs-number"><span class="hljs-number">0</span></span>].id)) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">comments</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(comments)) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los generadores se convirtieron en una alternativa a Promise (que tambi√©n examin√© en un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">art√≠culo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> anterior </font><font style="vertical-align: inherit;">. El generador en s√≠ no es adecuado para escribir c√≥digo asincr√≥nico, pero si los usa junto con Promise, obtenemos algo √∫nico: c√≥digo asincr√≥nico que parece sincr√≥nico. Al mismo tiempo, los generadores proporcionan el conocido mecanismo de manejo de errores que usa la construcci√≥n try ... catch. Solo los generadores tienen una gran desventaja: para usarlos con Promise necesitar√° una funci√≥n separada que controlar√° el proceso del generador R. Puede escribir esta funci√≥n usted mismo o usar una biblioteca de terceros, por ejemplo, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">co</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . En este ejemplo, escrib√≠ mi implementaci√≥n de dicha funci√≥n.</font></font><br><br><pre> <code class="javascript hljs">co(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> getUser(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> posts = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> getPosts(user.id); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> comments = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> getComments(posts[<span class="hljs-number"><span class="hljs-number">0</span></span>].id); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(comments); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error); } }); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">co</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">generator</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> iterator = generator(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prev</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { value, done } = iterator.next(prev); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (done) resolve(value); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>) value.then(run, reject); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> run(value); } run(); }); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada uno de los m√©todos para trabajar con c√≥digo asincr√≥nico tiene sus ventajas y desventajas. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funciones de devoluci√≥n de llamada (funciones de devoluci√≥n de llamada): f√°cil de usar, pero con un aumento en las funciones anidadas, la legibilidad comienza a sufrir. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promesas (promesas): elegantes y c√≥modas, pero dif√≠ciles de entender para los principiantes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generadores (Generadores): le permiten escribir c√≥digo as√≠ncrono sincr√≥nicamente, pero requieren una funci√≥n separada, y el mecanismo de operaci√≥n de los generadores es muy complicado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las funciones asincr√≥nicas se crearon sobre la base de Promesas y Generadores, para que el trabajo con c√≥digo asincr√≥nico sea simple y comprensible. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para comprender qu√© son las funciones asincr√≥nicas, considere el siguiente ejemplo:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUser</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user = getUser(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(user); <span class="hljs-comment"><span class="hljs-comment">// { id: 1 }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ahora, si hace que la funci√≥n sea as√≠ncrona (agregando la palabra clave as√≠ncrona), la funci√≥n devolver√° una Promesa que contiene un objeto con la propiedad id. </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUser</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user = getUser(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(user); <span class="hljs-comment"><span class="hljs-comment">// Promise { {id: 1} }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, podemos decir que cualquier funci√≥n asincr√≥nica devuelve Promis (o m√°s bien envuelve en Promis el valor que deber√≠a devolver). </font><font style="vertical-align: inherit;">Si el valor devuelto a la funci√≥n asincr√≥nica ya es una promesa, entonces no se volver√° a cambiar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para obtener el valor de la promesa, podemos usar el m√©todo then ().</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUser</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; } getUser(<span class="hljs-number"><span class="hljs-number">1</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(user)); <span class="hljs-comment"><span class="hljs-comment">// { id: 1 }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O podemos usar la palabra clave wait, que se discutir√° m√°s adelante. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Volvamos a nuestro primer ejemplo (solo que esta vez usaremos la funci√≥n real para enviar una solicitud HTTP.</font></font><br><br><pre> <code class="javascript hljs">fetch(<span class="hljs-string"><span class="hljs-string">`https://jsonplaceholder.typicode.com/users/1`</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> data.json()) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As√≠ es como se ve el c√≥digo asincr√≥nico usando Promise. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero podemos escribir c√≥digo as√≠ncrono como s√≠ncrono si usamos funciones as√≠ncronas.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendRequest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> response= <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetch(<span class="hljs-string"><span class="hljs-string">`https://jsonplaceholder.typicode.com/users/1`</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response.json(); } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> sendRequest(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a); } main();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo √∫nico que no me gusta es que el operador as√≠ncrono solo se puede usar en funciones asincr√≥nicas. </font><font style="vertical-align: inherit;">De lo contrario, no necesitar√≠a usar la funci√≥n main (). </font><font style="vertical-align: inherit;">Por supuesto, tambi√©n puede usar el m√©todo then (), pero el c√≥digo ya no se ver√° asincr√≥nico.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendRequest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> response= <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetch(<span class="hljs-string"><span class="hljs-string">`https://jsonplaceholder.typicode.com/users/1`</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response.json(); } sendRequest() .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La conclusi√≥n es que no utilizamos funciones de devoluci√≥n de llamada para obtener datos de fetch (). </font><font style="vertical-align: inherit;">En su lugar, usamos la palabra clave await, que, por as√≠ decirlo, le dice al tiempo de ejecuci√≥n: espere a que la funci√≥n fetch () se ejecute y escriba el resultado en la variable de respuesta. </font><font style="vertical-align: inherit;">Y usando la funci√≥n de devoluci√≥n de llamada, decimos: espere a que se ejecute la funci√≥n fetch () y llame a la funci√≥n de devoluci√≥n de llamada para procesar los datos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠ est√° la diferencia obvia entre usar Promise y la funci√≥n as√≠ncrona</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Promise function sendRequest() { return fetch(`https://jsonplaceholder.typicode.com/users/1`) .then(data =&gt; data.json()); } //  async function async function sendRequest() { let response = await fetch(`https://jsonplaceholder.typicode.com/users/1`); return response.json(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El operador de espera solo se puede usar en el cuerpo de funciones asincr√≥nicas, y su acci√≥n se puede usar en cualquier funci√≥n que devuelva una promesa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para manejar excepciones en funciones asincr√≥nicas, es costumbre usar la construcci√≥n try ... catch.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendRequest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetch(<span class="hljs-string"><span class="hljs-string">`https://jsonplaceholder.typicode.com/users/1`</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Unexpected error"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response.json(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error); <span class="hljs-comment"><span class="hljs-comment">// Error: Unexpected error at sendRequest } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Y finalmente ... </font></font><br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">//    async; await; async; await; async; await; async; await; In the System(); The function.sleep()s tonight~</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consulte las definiciones de funciones as√≠ncronas en la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">especificaci√≥n</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oficial </font><font style="vertical-align: inherit;">, as√≠ como en los </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentos web de MDN</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/475074/">https://habr.com/ru/post/475074/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../475060/index.html">Crear un servicio de seguimiento de llamadas simple, parte 2</a></li>
<li><a href="../475064/index.html">.NET Core 3 para escritorio de Windows</a></li>
<li><a href="../475066/index.html">Las cr√≥nicas del hambre de libros</a></li>
<li><a href="../475068/index.html">Envolvemos todo el tr√°fico LAN en vpn sin l√≠mite de velocidad</a></li>
<li><a href="../475072/index.html">Pasantes a trav√©s de los ojos de la empresa</a></li>
<li><a href="../475076/index.html">Superh√©roes sovi√©ticos, mocos checos y clon australiano</a></li>
<li><a href="../475078/index.html">Comprender los envoltorios de propiedades en SwiftUI</a></li>
<li><a href="../475086/index.html">Tipo de API REST para desarrolladores frontend</a></li>
<li><a href="../475090/index.html">.NET Core con Jupyter Notebooks Preview 1</a></li>
<li><a href="../475092/index.html">"Lo leer√© m√°s tarde": el destino dif√≠cil de una colecci√≥n de p√°ginas web fuera de l√≠nea</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>