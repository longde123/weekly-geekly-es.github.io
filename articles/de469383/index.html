<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♻️ 🐛 😖 Hyperkonvergente Lösung AERODISK vAIR. Basis - ARDFS-Dateisystem 👨🏼‍🚒 🚘 💆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Leser von Habr. Mit diesem Artikel eröffnen wir einen Zyklus, der sich mit dem von uns entwickelten hyperkonvergenten System AERODISK vAIR befas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hyperkonvergente Lösung AERODISK vAIR. Basis - ARDFS-Dateisystem</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/aerodisk/blog/469383/"><p><img src="https://habrastorage.org/webt/sk/n3/zh/skn3zhr0fgbcuqfar5ozlg0v2tk.jpeg"></p><br><p>  Hallo Leser von Habr.  Mit diesem Artikel eröffnen wir einen Zyklus, der sich mit dem von uns entwickelten hyperkonvergenten System AERODISK vAIR befasst.  Anfangs wollten wir, dass der erste Artikel alles über alles erzählt, aber das System ist ziemlich komplex, so dass wir einen Elefanten in Teilen essen werden. </p><br><p>  Beginnen wir die Geschichte mit der Geschichte des Systems, gehen wir tiefer in das ARDFS-Dateisystem ein, das die Grundlage von vAIR bildet, und sprechen wir auch ein wenig über die Positionierung dieser Lösung auf dem russischen Markt. </p><br><p>  In zukünftigen Artikeln werden wir mehr über verschiedene Architekturkomponenten (Cluster, Hypervisor, Load Balancer, Überwachungssystem usw.), den Konfigurationsprozess sprechen, Lizenzierungsprobleme ansprechen, Crashtests separat anzeigen und natürlich über Lasttests und schreiben Dimensionierung.  Wir werden auch einen separaten Artikel der Community-Version von vAIR widmen. </p><a name="habracut"></a><br><h2 id="aerodisk---eto-vrode-istoriya-pro-shd-ili-zachem-my-voobsche-nachali-zanimatsya-giperkonvergentom">  Ist eine Airdisc eine Geschichte über Lagerung?  Oder warum haben wir überhaupt angefangen, uns zu konvergieren? </h2><br><p>  Die Idee, ein eigenes Hyperkonvergenz zu schaffen, kam uns etwa im Jahr 2010.  Dann gab es keine Aerodisk und ähnliche Lösungen (kommerzielle hyperkonvergente Boxed-Systeme) auf dem Markt.  Unsere Aufgabe war wie folgt: Von einer Reihe von Servern mit lokalen Festplatten, die über eine Ethernet-Verbindung verbunden sind, mussten wir erweiterten Speicher erstellen und virtuelle Maschinen und ein Software-Netzwerk an derselben Stelle ausführen.  All dies musste ohne Speichersysteme implementiert werden (da es einfach kein Geld für die Speicherung und deren Bindung gab, wir aber noch kein eigenes Speichersystem erfunden hatten). </p><br><p>  Wir haben viele Open-Source-Lösungen ausprobiert und dieses Problem trotzdem gelöst, aber die Lösung war sehr kompliziert und schwer zu wiederholen.  Darüber hinaus fiel diese Entscheidung aus der Kategorie „Werke?  Nicht anfassen! "  Nachdem wir dieses Problem gelöst hatten, entwickelten wir die Idee, das Ergebnis unserer Arbeit in ein vollwertiges Produkt umzuwandeln, nicht weiter. </p><br><p> Nach diesem Vorfall haben wir uns von dieser Idee entfernt, aber wir hatten immer noch das Gefühl, dass diese Aufgabe vollständig lösbar war und die Vorteile einer solchen Lösung mehr als offensichtlich waren.  In der Folge bestätigten die freigegebenen HCI-Produkte ausländischer Unternehmen dieses Gefühl nur. </p><br><p>  Daher sind wir Mitte 2016 im Rahmen der Entwicklung eines vollwertigen Produkts zu dieser Aufgabe zurückgekehrt.  Da wir noch keine Beziehungen zu Investoren hatten, mussten wir für unser nicht sehr großes Geld einen Entwicklungsstand kaufen.  Nachdem wir auf Avito BU-shyh Servern und Switches getippt hatten, machten wir uns an die Arbeit. </p><br><p><img src="https://habrastorage.org/webt/wy/ir/jr/wyirjr50guvzpnolcvdvniyn2mo.jpeg"></p><br><p>  Die Hauptaufgabe bestand darin, ein eigenes, wenn auch einfaches, aber eigenes Dateisystem zu erstellen, mit dem Daten in Form von virtuellen Blöcken auf der n-ten Anzahl von Clusterknoten, die über Ethernet miteinander verbunden sind, automatisch und gleichmäßig verteilt werden können.  In diesem Fall sollte der FS gut und leicht skalierbar und unabhängig von benachbarten Systemen sein, d.h.  von vAIR in Form von "gerechter Lagerung" entfremdet sein. </p><br><p><img src="https://habrastorage.org/webt/il/vk/zs/ilvkzsyjkyr6pkcgoqs_ibumyus.jpeg"></p><br><p>  VAIR Erstes Konzept </p><br><p><img src="https://habrastorage.org/webt/h1/e0/pd/h1e0pda3j1ebbxls_cn_gmzm5ug.jpeg"></p><br><p>  Wir haben uns absichtlich geweigert, vorgefertigte Open-Source-Lösungen für die Organisation von erweitertem Speicher (Ceph, Gluster, Lustre und dergleichen) zugunsten unserer Entwicklung zu verwenden, da wir bereits viel Projekterfahrung mit ihnen hatten.  Natürlich sind diese Lösungen selbst wunderbar, und bevor wir an Aerodisk gearbeitet haben, haben wir mehr als ein Integrationsprojekt mit ihnen implementiert.  Es ist jedoch eine Sache, die spezifische Aufgabe eines Kunden zu realisieren, Mitarbeiter zu schulen und möglicherweise Support für einen großen Anbieter zu kaufen, und es ist eine ganz andere Sache, ein einfach zu replizierendes Produkt zu erstellen, das für verschiedene Aufgaben verwendet wird, die wir als Anbieter möglicherweise selbst kennen wir werden nicht.  Für den zweiten Zweck passten die vorhandenen Open Source-Produkte nicht zu uns, daher entschieden wir uns, das verteilte Dateisystem selbst zu sehen. <br>  Zwei Jahre später erzielten mehrere Entwickler (die die Arbeit an vAIR mit der Arbeit an der klassischen Storage Engine kombinierten) ein bestimmtes Ergebnis. </p><br><p>  Bis zum Jahr 2018 hatten wir das einfachste Dateisystem geschrieben und es mit der notwendigen Bindung ergänzt.  Das System integrierte physische (lokale) Festplatten von verschiedenen Servern über eine interne Verbindung in einen flachen Pool und „schnitt“ sie in virtuelle Blöcke. Anschließend wurden Blockgeräte mit unterschiedlichem Grad an Fehlertoleranz aus virtuellen Blöcken erstellt, auf denen virtuelle KVM-Hypervisoren erstellt und ausgeführt wurden Autos. </p><br><p>  Wir haben uns nicht mit dem Namen des Dateisystems beschäftigt und es kurz ARDFS genannt (raten Sie mal, wie es entschlüsselt). </p><br><p>  Dieser Prototyp sah gut aus (nicht visuell, natürlich gab es damals kein visuelles Design) und zeigte gute Ergebnisse in Bezug auf Leistung und Skalierung.  Nach dem ersten echten Ergebnis haben wir die Weichen für dieses Projekt gestellt, nachdem wir eine vollwertige Entwicklungsumgebung und ein separates Team organisiert hatten, das nur mit vAIR beschäftigt war. </p><br><p>  Zu diesem Zeitpunkt war die allgemeine Architektur der Lösung gereift, die bis jetzt keine wesentlichen Änderungen erfahren hatte. </p><br><h2 id="pogruzhaemsya-v-faylovuyu-sistemu-ardfs">  Eintauchen in das ARDFS-Dateisystem </h2><br><p>  ARDFS ist die Grundlage von vAIR, das verteilten Failover-Speicher für den gesamten Cluster bereitstellt.  Ein (aber nicht das einzige) Unterscheidungsmerkmal von ARDFS ist, dass keine zusätzlichen dedizierten Server für Meta und Verwaltung verwendet werden.  Dies sollte ursprünglich die Konfiguration der Lösung und ihre Zuverlässigkeit vereinfachen. </p><br><h3 id="struktura-hraneniya">  Speicherstruktur </h3><br><p>  Innerhalb aller Clusterknoten organisiert ARDFS einen logischen Pool aus dem gesamten verfügbaren Speicherplatz.  Es ist wichtig zu verstehen, dass ein Pool noch keine Daten und kein formatierter Speicherplatz ist, sondern einfach ein Markup, d. H.  Alle Knoten, auf denen vAIR installiert ist, wenn sie zum Cluster hinzugefügt werden, werden automatisch zum freigegebenen ARDFS-Pool hinzugefügt, und die Festplattenressourcen werden automatisch für den gesamten Cluster freigegeben (und stehen für die zukünftige Datenspeicherung zur Verfügung).  Mit diesem Ansatz können Sie Knoten im laufenden Betrieb hinzufügen und entfernen, ohne dass dies ernsthafte Auswirkungen auf ein bereits ausgeführtes System hat.  Das heißt,  Das System lässt sich sehr einfach mit „Bausteinen“ skalieren und bei Bedarf Knoten im Cluster hinzufügen oder entfernen. </p><br><p>  Über dem ARDFS-Pool werden virtuelle Festplatten (Speicherobjekte für virtuelle Maschinen) hinzugefügt, die aus virtuellen Blöcken mit einer Größe von 4 Megabyte bestehen.  Virtuelle Festplatten speichern Daten direkt.  Auf der Ebene der virtuellen Festplatte wird auch ein Fehlertoleranzschema definiert. </p><br><p>  Wie Sie vielleicht vermutet haben, verwenden wir für die Fehlertoleranz des Festplattensubsystems nicht das Konzept von RAID (Redundantes Array unabhängiger Festplatten), sondern RAIN (Redundantes Array unabhängiger Knoten).  Das heißt,  Die Fehlertoleranz wird basierend auf Knoten und nicht auf Festplatten gemessen, automatisiert und verwaltet.  Festplatten sind natürlich auch ein Speicherobjekt. Sie werden wie alles andere überwacht. Sie können alle Standardvorgänge mit ihnen ausführen, einschließlich der Erstellung lokaler Hardware-RAIDs, aber der Cluster arbeitet mit Knoten. </p><br><p>  In einer Situation, in der Sie wirklich RAID benötigen (z. B. ein Szenario, das mehrere Fehler in kleinen Clustern unterstützt), hindert Sie nichts daran, lokale RAID-Controller zu verwenden und darüber hinaus Stretched Storage und eine RAIN-Architektur auszuführen.  Dieses Szenario ist recht lebhaft und wird von uns unterstützt. Daher werden wir in einem Artikel über typische Szenarien für die Verwendung von vAIR darüber sprechen. </p><br><h3 id="shemy-otkazoustoychivosti-hranilischa">  Speicher-Failover-Schemata </h3><br><p>  Möglicherweise gibt es zwei Ausfallsicherheitsschemata für virtuelle vAIR-Festplatten: </p><br><p>  1) Replikationsfaktor oder nur Replikation - diese Methode der Fehlertoleranz ist einfach „wie ein Stock und ein Seil“.  Eine synchrone Replikation zwischen Knoten mit einem Faktor von 2 (2 Kopien pro Cluster) oder 3 (3 Kopien) wird durchgeführt.  Mit RF-2 kann die virtuelle Festplatte dem Ausfall eines Knotens im Cluster standhalten, „frisst“ jedoch die Hälfte des verwendbaren Volumes, und RF-3 hält dem Ausfall von 2 Knoten im Cluster stand, reserviert jedoch 2/3 des nützlichen Volumes für seine Anforderungen.  Dieses Schema ist RAID-1 sehr ähnlich, dh eine in RF-2 konfigurierte virtuelle Festplatte ist resistent gegen den Ausfall eines Knotens des Clusters.  In diesem Fall sind die Daten in Ordnung und selbst die E / A werden nicht gestoppt.  Wenn ein heruntergefallener Knoten wieder in Betrieb genommen wird, beginnt die automatische Datenwiederherstellung / -synchronisation. </p><br><p>  Das Folgende sind Beispiele für die Verteilung von RF-2- und RF-3-Daten im normalen Modus und in einer Fehlersituation. </p><br><p>  Wir haben eine virtuelle Maschine mit einer Kapazität von 8 MB eindeutiger (nützlicher) Daten, die auf 4 vAIR-Knoten ausgeführt wird.  Es ist klar, dass es in der Realität unwahrscheinlich ist, dass es eine so geringe Menge geben wird, aber für ein Schema, das die Logik von ARDFS widerspiegelt, ist dieses Beispiel am verständlichsten.  AB sind virtuelle 4-MB-Blöcke, die eindeutige Daten der virtuellen Maschine enthalten.  Mit RF-2 werden zwei Kopien dieser Blöcke A1 + A2 bzw. B1 + B2 erstellt.  Diese Blöcke werden von Knoten „angelegt“, wobei der Schnittpunkt derselben Daten auf demselben Knoten vermieden wird, dh Kopie A1 befindet sich nicht auf derselben Note wie Kopie A2.  Bei B1 und B2 ist es ähnlich. </p><br><p><img src="https://habrastorage.org/webt/ho/xm/oh/hoxmohhemj_whmr38pvgfyfousm.png"></p><br><p>  Bei einem Ausfall eines der Knoten (z. B. Knoten 3, der eine Kopie von B1 enthält) wird diese Kopie automatisch auf dem Knoten aktiviert, auf dem keine Kopie seiner Kopie vorhanden ist (dh Kopie B2). </p><br><p><img src="https://habrastorage.org/webt/ex/xl/o4/exxlo4frqr3crhwbh_orvlcwl9g.png"></p><br><p>  Somit überlebt die virtuelle Festplatte (bzw. die VMs) leicht den Ausfall eines Knotens im RF-2-Schema. </p><br><p>  Eine Schaltung mit Replikation leidet aufgrund ihrer Einfachheit und Zuverlässigkeit unter denselben Schmerzen wie RAID1 - es gibt wenig nutzbaren Speicherplatz. </p><br><p>  2) Löschcodierung oder Löschcodierung (auch als "redundante Codierung", "Löschcodierung" oder "Redundanzcode" bekannt) existiert nur, um das obige Problem zu lösen.  EC ist ein Redundanzschema, das im Vergleich zur Replikation eine hohe Datenverfügbarkeit bei geringerem Festplatten-Overhead bietet.  Das Funktionsprinzip dieses Mechanismus ähnelt RAID 5, 6, 6P. </p><br><p>  Bei der Codierung unterteilt der EC-Prozess den virtuellen Block (standardmäßig 4 MB) in Abhängigkeit vom EC-Schema in mehrere kleinere „Datenelemente“ (z. B. teilt ein 2 + 1-Schema jeden 4-MB-Block in 2 Teile von 2 MB).  Ferner erzeugt dieser Prozess "Paritätsblöcke" für "Datenstücke" von nicht mehr als einem der zuvor getrennten Teile.  Beim Decodieren generiert die EC die fehlenden Teile und liest die "überlebenden" Daten im gesamten Cluster. </p><br><p>  Beispielsweise kann eine virtuelle Festplatte mit einem EC-Schema 2 + 1, die auf 4 Knoten eines Clusters implementiert ist, einem Ausfall eines einzelnen Knotens in einem Cluster auf dieselbe Weise wie RF-2 problemlos standhalten.  Gleichzeitig werden die Gemeinkosten niedriger sein, insbesondere beträgt der Kapazitätsfaktor bei RF-2 2 und bei EC 2 + 1 1,5. </p><br><p>  Wenn es einfacher zu beschreiben ist, ist die Quintessenz, dass der virtuelle Block in 2-8 (warum von 2 bis 8 siehe unten) "Teile" unterteilt ist, und für diese Teile werden die "Teile" der Parität desselben Volumens berechnet. </p><br><p>  Infolgedessen werden Daten und Parität gleichmäßig auf alle Knoten des Clusters verteilt.  Gleichzeitig verteilt ARDFS wie bei der Replikation Daten automatisch auf Knoten, so dass die Speicherung derselben Daten (Kopien von Daten und deren Parität) auf einem Knoten verhindert wird, um die Möglichkeit eines Datenverlusts aufgrund der Tatsache, dass die Daten und ihre Daten ausgeschlossen sind, auszuschließen Die Parität endet plötzlich auf demselben Speicherknoten, was fehlschlägt. </p><br><p>  Unten sehen Sie ein Beispiel mit derselben virtuellen Maschine mit 8 MB und 4 Knoten, jedoch bereits mit dem EC 2 + 1-Schema. </p><br><p>  Die Blöcke A und B sind in zwei Teile von jeweils 2 MB unterteilt (zwei, weil 2 + 1), dh A1 + A2 und B1 + B2.  Im Gegensatz zum Replikat ist A1 keine Kopie von A2, sondern ein virtueller Block A, der in zwei Teile unterteilt ist, ebenfalls mit Block B. Insgesamt erhalten wir zwei Sätze von 4 MB, von denen jeder zwei Zwei-Megabyte-Teile enthält.  Ferner erhalten wir für jeden dieser Sätze Parität mit einem Volumen von nicht mehr als einem Stück (d. H. 2 MB) zusätzliche + 2 Paritätsstücke (AP und BP).  Insgesamt haben wir 4x2 Daten + 2x2 Parität. </p><br><p>  Als nächstes werden die Teile von Knoten „angeordnet“, damit sich die Daten nicht mit ihrer Parität überschneiden.  Das heißt,  A1 und A2 liegen nicht mit AP auf demselben Knoten. </p><br><p><img src="https://habrastorage.org/webt/s9/xi/om/s9xiombqm4ep-bos8lntf8kjq4s.png"></p><br><p>  Im Falle eines Ausfalls eines Knotens (zum Beispiel auch des dritten) wird der heruntergefallene Block B1 automatisch aus der Parität BP wiederhergestellt, die auf Knoten Nr. 2 gespeichert ist, und wird auf dem Knoten aktiviert, auf dem keine B-Parität vorliegt, d. H.  Stücke von BP.  In diesem Beispiel ist dies Knoten 1 </p><br><p><img src="https://habrastorage.org/webt/wu/gk/dr/wugkdrhgfund89fswagb7wc4iba.png"></p><br><p>  Ich bin sicher, der Leser hat eine Frage: </p><br><blockquote>  "Alles, was Sie beschrieben haben, wurde seit langem sowohl von Wettbewerbern als auch von Open Source-Lösungen implementiert. Was ist der Unterschied zwischen Ihrer Implementierung von EC in ARDFS?" </blockquote><p>  Und dann wird es interessante Funktionen des ARDFS geben. </p><br><h3 id="erasure-coding-s-uporom-na-gibkost">  Löschcodierung mit Schwerpunkt auf Flexibilität </h3><br><p>  Anfangs haben wir ein ziemlich flexibles EC X + Y-Schema bereitgestellt, wobei X gleich einer Zahl von 2 bis 8 und Y gleich einer Zahl von 1 bis 8 ist, aber immer kleiner oder gleich X. Ein solches Schema ist aus Gründen der Flexibilität vorgesehen.  Durch Erhöhen der Anzahl der Daten (X), in die die virtuelle Einheit unterteilt ist, kann der Overhead reduziert, dh der nutzbare Speicherplatz erhöht werden. <br>  Eine Erhöhung der Anzahl der Paritätsblöcke (Y) erhöht die Zuverlässigkeit der virtuellen Festplatte.  Je größer der Y-Wert ist, desto mehr Knoten im Cluster können ausfallen.  Das Erhöhen der Paritätsmenge verringert natürlich die Menge der nutzbaren Kapazität, aber dies ist eine Gebühr für die Zuverlässigkeit. </p><br><p>  Die Abhängigkeit der Leistung von EC-Schaltkreisen ist nahezu direkt: Je mehr „Teile“ vorhanden sind, desto geringer ist die Leistung. Hier benötigen Sie natürlich ein ausgewogenes Erscheinungsbild. </p><br><p>  Mit diesem Ansatz können Administratoren den erweiterten Speicher am flexibelsten konfigurieren.  Innerhalb des ARDFS-Pools können Sie beliebige Fehlertoleranzschemata und deren Kombinationen verwenden, was unserer Meinung nach ebenfalls sehr nützlich ist. </p><br><p>  In der folgenden Tabelle werden mehrere (nicht alle möglichen) HF- und EC-Schaltkreise verglichen. </p><br><p><img src="https://habrastorage.org/webt/g0/vj/oj/g0vjojekzkzjv2xbxbdhyw1fjy0.png"></p><br><p>  Die Tabelle zeigt, dass selbst die meiste „Frottee“ -Kombination von EC 8 + 7, die den Verlust von bis zu 7 Knoten gleichzeitig in einem Cluster ermöglicht, weniger nutzbaren Speicherplatz (1.875 gegenüber 2) als die Standardreplikation „verbraucht“ und siebenmal besser schützt. Dies macht diesen Schutzmechanismus zwar komplexer, aber in Situationen, in denen Sie unter Bedingungen mangelnden Speicherplatzes maximale Zuverlässigkeit gewährleisten müssen, viel attraktiver.  Gleichzeitig müssen Sie verstehen, dass jedes „Plus“ für X oder Y einen zusätzlichen Overhead für die Produktivität darstellt. Daher müssen Sie im Dreieck zwischen Zuverlässigkeit, Wirtschaftlichkeit und Leistung sehr sorgfältig auswählen.  Aus diesem Grund widmen wir der Codierung der Größenlöschung einen separaten Artikel. </p><br><p><img src="https://habrastorage.org/webt/5v/2o/-j/5v2o-jpchgy8rqib7bugk35vmj4.png"></p><br><h3 id="nadezhnost-i-avtonomnost-faylovoy-sistemy">  Zuverlässigkeit und Autonomie des Dateisystems </h3><br><p>  ARDFS wird lokal auf allen Knoten des Clusters ausgeführt und synchronisiert sie auf eigene Weise über dedizierte Ethernet-Schnittstellen.  Ein wichtiger Punkt ist, dass ARDFS nicht nur Daten, sondern auch speicherbezogene Metadaten unabhängig voneinander synchronisiert.  Während der Arbeit an ARDFS haben wir gleichzeitig eine Reihe vorhandener Lösungen untersucht und festgestellt, dass viele Dateisystem-Metasynchronisierungen mithilfe eines externen verteilten DBMS durchführen, das wir auch zum Synchronisieren verwenden, jedoch nur Konfigurationen, keine FS-Metadaten (zu diesem und anderen verwandten Subsystemen) im nächsten Artikel). </p><br><p>  Die Synchronisation von FS-Metadaten mit einem externen DBMS ist natürlich eine funktionierende Lösung, aber dann würde die Konsistenz der in ARDFS gespeicherten Daten vom externen DBMS und seinem Verhalten abhängen (und sie ist ehrlich gesagt eine launische Frau), was unserer Meinung nach schlecht ist.  Warum?  Wenn die FS-Metadaten beschädigt sind, können die FS-Daten selbst auch als „Auf Wiedersehen“ bezeichnet werden. Daher haben wir uns für einen komplizierteren, aber zuverlässigeren Weg entschieden. </p><br><p>  Wir haben das Metadatensynchronisations-Subsystem für ARDFS unabhängig gemacht und es lebt völlig unabhängig von den benachbarten Subsystemen.  Das heißt,  Kein anderes Subsystem kann ARDFS-Daten beschädigen.  Unserer Meinung nach ist dies der zuverlässigste und korrekteste Weg, und ist es wirklich so - die Zeit wird es zeigen.  Darüber hinaus ergibt sich bei diesem Ansatz ein zusätzlicher Vorteil.  ARDFS kann unabhängig von vAIR verwendet werden, genau wie erweiterter Speicher, den wir sicherlich in zukünftigen Produkten verwenden werden. </p><br><p>  Als Ergebnis der Entwicklung von ARDFS haben wir ein flexibles und zuverlässiges Dateisystem erhalten, mit dem Sie die Wahl haben, Kapazität zu sparen oder alles an Leistung zu verlieren oder Speicher für eine moderate Gebühr hochzuverlässig zu machen, aber die Leistungsanforderungen zu reduzieren. </p><br><p>  Zusammen mit einer einfachen Lizenzierungsrichtlinie und einem flexiblen Bereitstellungsmodell (in Zukunft wird es von vAIR von Knoten lizenziert und entweder von Software oder als PAC bereitgestellt) können Sie die Lösung sehr genau auf die unterschiedlichsten Anforderungen der Kunden zuschneiden, und in Zukunft ist es einfach, dieses Gleichgewicht aufrechtzuerhalten. </p><br><h2 id="komu-eto-chudo-nuzhno">  Wer braucht dieses Wunder? </h2><br><p>  Einerseits können wir sagen, dass es bereits Akteure auf dem Markt gibt, die ernsthafte Entscheidungen im Bereich der Hyperkonvergenz treffen und wohin wir tatsächlich gehen.  Diese Aussage scheint wahr zu sein, ABER ... </p><br><p>  Auf der anderen Seite sehen wir und unsere Partner, wenn wir auf die Felder gehen und mit Kunden kommunizieren, dass dies überhaupt nicht der Fall ist.  Es gibt viele Probleme für die Hyperkonvergenz, irgendwo wussten die Leute einfach nicht, dass es solche Lösungen gibt, irgendwo schien es teuer, irgendwo gab es erfolglose Tests alternativer Lösungen, aber irgendwo verbieten sie den Kauf aufgrund von Sanktionen im Allgemeinen.  Im Allgemeinen wurde das Feld nicht gepflügt, also gingen wir, um das jungfräuliche Land zu erheben))). </p><br><h3 id="kogda-shd-luchshe-chem-gks">  Wann ist Speicher besser als GCS? </h3><br><p>  Während der Arbeit mit dem Markt werden wir oft gefragt, wann es besser ist, das klassische Schema mit Speichersystemen zu verwenden, und wann es hyperkonvergent ist.  Viele Unternehmen - Hersteller von GCS (insbesondere solche, die keinen Speicher in ihrem Portfolio haben) sagen: "Speicher ist überlebt, nur hyperkonvergent!"  Dies ist eine kühne Aussage, die jedoch die Realität nicht ganz widerspiegelt. </p><br><p>  In Wahrheit schwimmt der Speichermarkt zwar in Richtung hyperkonvergenter und ähnlicher Lösungen, aber es gibt immer ein „Aber“. </p><br><p>  Erstens können Rechenzentren und IT-Infrastrukturen, die nach dem klassischen Schema mit Speichersystemen gebaut wurden, nicht einfach so wieder aufgebaut werden, weshalb die Modernisierung und Fertigstellung solcher Infrastrukturen immer noch ein 5-7-jähriges Erbe ist. </p><br><p>  Zweitens werden die Infrastrukturen, die derzeit größtenteils gebaut werden (dh die Russische Föderation), nach dem klassischen Schema unter Verwendung von Speichersystemen gebaut, und zwar nicht, weil die Menschen nichts über Hyperkonvergenz wissen, sondern weil der Markt für Hyperkonvergenz neu ist, Lösungen und Standards noch nicht festgelegt wurden , IT-Mitarbeiter wurden noch nicht geschult, es gibt wenig Erfahrung und wir müssen hier und jetzt Rechenzentren bauen.  Und dieser Trend hält noch 3-5 Jahre an (und dann ein weiteres Erbe, siehe Absatz 1). </p><br><p>  Drittens eine rein technische Einschränkung bei zusätzlichen kleinen Verzögerungen von 2 Millisekunden pro Schreibvorgang (natürlich ohne den lokalen Cache), die Gebühren für verteilten Speicher sind. </p><br><p>  Vergessen wir nicht, große physische Server zu verwenden, die die vertikale Skalierung des Festplattensubsystems lieben. </p><br><p>  Es gibt viele notwendige und beliebte Aufgaben, bei denen sich das Speichersystem besser verhält als das GCS.  Hier sind natürlich diejenigen Hersteller nicht einverstanden, die keine Speichersysteme in ihrem Produktportfolio haben, aber wir sind bereit, vernünftig zu argumentieren.  Natürlich werden wir als Entwickler beider Produkte in einer der zukünftigen Veröffentlichungen definitiv einen Vergleich von Speichersystemen und GCS anstellen, wo wir klar zeigen werden, was unter welchen Bedingungen besser ist. </p><br><h3 id="a-gde-giperkonvergentnye-resheniya-budut-rabotat-luchshe-shd">  Und wo funktionieren hyperkonvergente Lösungen besser als Speichersysteme? </h3><br><p>  Basierend auf den obigen Thesen gibt es drei offensichtliche Schlussfolgerungen: </p><br><ol><li>  Wenn zusätzliche 2 Millisekunden Aufzeichnungsverzögerungen, die in einem Produkt stabil auftreten (jetzt sprechen wir nicht mehr über Kunststoffe, Sie können Nanosekunden auf Kunststoffen anzeigen), nicht kritisch sind, reicht eine hyperkonvergente Funktion aus. </li><li>  Wenn die Last von großen physischen Servern in viele kleine virtuelle Server umgewandelt und von Knoten verteilt werden kann, funktioniert der Hyperkonvergent auch dort gut. </li><li>  Wo horizontale Skalierung wichtiger ist als vertikale Skalierung, funktioniert GCS auch dort einwandfrei. </li></ol><br><h3 id="kakie-eto-resheniya">  Was sind diese Lösungen? </h3><br><ol><li>  Alle Standardinfrastrukturdienste (Verzeichnisdienst, Mail, EDS, Dateiserver, kleine oder mittlere ERP- und BI-Systeme usw.).  Wir nennen dies "General Computing". </li><li>  Die Infrastruktur von Cloud-Anbietern, bei der es erforderlich ist, eine große Anzahl virtueller Maschinen für Clients schnell und standardisiert horizontal zu erweitern und einfach zu „schneiden“. </li><li>  Infrastruktur für virtuelle Desktops (VDI), bei der viele Virtuala für kleine Benutzer gestartet werden und leise in einem einheitlichen Cluster "schweben". </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Filialnetzwerke, in denen Sie in jeder Filiale eine standardmäßige, fehlertolerante und gleichzeitig kostengünstige Infrastruktur mit 15 bis 20 virtuellen Maschinen benötigen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jedes verteilte Computing (z. B. Big Data-Dienste). </font><font style="vertical-align: inherit;">Wo die Ladung nicht "tief" geht, sondern "breit".</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Testumgebungen, in denen zusätzliche kleine Verzögerungen akzeptabel sind, aber Budgetbeschränkungen bestehen, da es sich um Tests handelt. </font></font></li></ol><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Derzeit haben wir für diese Aufgaben AERODISK vAIR erstellt und konzentrieren uns darauf (bisher erfolgreich). </font><font style="vertical-align: inherit;">Vielleicht wird sich das bald ändern. </font><font style="vertical-align: inherit;">Die Welt steht nicht still.</font></font></p><br><h3 id="itak">  Also ... </h3><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Damit ist der erste Teil einer großen Reihe von Artikeln abgeschlossen. Im nächsten Artikel werden wir über die Architektur der Lösung und die verwendeten Komponenten sprechen. </font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir freuen uns über Fragen, Vorschläge und konstruktive Streitigkeiten. </font></font></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de469383/">https://habr.com/ru/post/de469383/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de469371/index.html">Beschreibung des Ansatzes zum Organisieren und Testen von Code mit Redux Thunk</a></li>
<li><a href="../de469373/index.html">Die Ergebnisse des Projekts zur Schaffung einer neuronalen Schnittstelle für vollständig gelähmte Patienten wurden in Frage gestellt</a></li>
<li><a href="../de469375/index.html">Warum stellen Mozilla, Coil und Creative Commons 100 Millionen US-Dollar für Open Source-Projekte zur Verfügung?</a></li>
<li><a href="../de469379/index.html">Anwendung formaler Modellvalidierungsmethoden für die Benutzeroberfläche</a></li>
<li><a href="../de469381/index.html">Agones, erstellen Sie einen Mehrbenutzer-Spieleserver. Architektur und Installation</a></li>
<li><a href="../de469387/index.html">Die Geschichte eines "Entwicklers" oder wie ein Neuling eine Anwendung für iOS schreibt</a></li>
<li><a href="../de469389/index.html">Parametrisierung eines physikalischen Modells durch ein neuronales Netzwerk zur Lösung eines topologischen Optimierungsproblems</a></li>
<li><a href="../de469391/index.html">Audio-Schnittstellen: Ton als Informationsquelle auf der Straße, im Büro und am Himmel</a></li>
<li><a href="../de469393/index.html">Flare-On 2019 Zuschreibung</a></li>
<li><a href="../de469395/index.html">Wo und wie werden Mehrspalten verwendet (CSS-Spalten)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>