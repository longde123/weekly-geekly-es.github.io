<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😥 🙇🏻 💴 Pergi untuk mengamankan 2FA di blockchain 🤹 🐿️ 🔛</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pesan SMS adalah metode otentikasi dua faktor (2FA) yang paling populer. Ini digunakan oleh bank, dompet elektronik dan kripto, kotak surat dan semua ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pergi untuk mengamankan 2FA di blockchain</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476090/">  Pesan SMS adalah metode otentikasi dua faktor (2FA) yang paling populer.  Ini digunakan oleh bank, dompet elektronik dan kripto, kotak surat dan semua jenis layanan;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jumlah pengguna metode ini mendekati 100%</a> . <br><br>  Saya memiliki kejadian seperti itu keterlaluan, karena metode ini tidak aman.  Penugasan kembali nomor dari satu kartu SIM ke yang lain dimulai pada awal era ponsel - ini adalah bagaimana nomor dikembalikan ketika SIM hilang.  “Spesialis Penyapihan Uang Digital” menyadari: opsi “menimpa kartu SIM” dapat digunakan dalam skema penipuan.  Lagi pula, orang yang mengontrol kartu SIM dapat mengelola perbankan online orang lain, e-wallet, dan bahkan cryptocurrency.  Dan Anda dapat mengambil alih nomor orang lain dengan menyuap karyawan telekomunikasi menggunakan penipuan atau dokumen palsu. <br><br><img src="https://habrastorage.org/webt/sm/lg/oh/smlgohi_vtrtginwsqvp3t2jqy8.png"><br><br>  Ribuan episode swap SIM telah terungkap - inilah yang disebut skema penipuan ini.  Skala bencana menunjukkan bahwa dunia akan segera meninggalkan 2FA melalui SMS.  Tapi ini tidak terjadi - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">studi</a> mengatakan bahwa bukan pengguna yang memilih metode 2FA, tetapi pemilik layanan. <br><br>  Kami menyarankan untuk menggunakan metode 2FA aman dengan pengiriman kode satu kali melalui blockchain, dan kami akan memberi tahu Anda cara menghubungkannya ke pemilik layanan. <br><a name="habracut"></a><br><h2>  Tagihannya menjadi jutaan </h2><br>  Pada tahun 2019, penipuan pertukaran SIM meningkat 63% menurut polisi London, dan "rata-rata cek" dari penyerang adalah 4.000 GBP.  Saya tidak menemukan statistik di Rusia, tetapi saya berasumsi bahwa ini bahkan lebih buruk. <br><br>  Pertukaran SIM digunakan untuk mencuri Twitter, Instagram, Facebook, akun VK populer, rekening bank, dan baru-baru ini mencapai cryptocurrency, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lapor surat kabar Times</a> dari pengusaha bitcoin, Joby Weeks.  Kasus-kasus pencurian cryptocurrency dengan bantuan pertukaran SIM telah muncul di media sejak 2016;  pada 2019 datang puncak yang nyata. <br><br>  Pada bulan Mei, jaksa penuntut AS di distrik timur Michigan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menuduh</a> sembilan orang muda berusia antara 19 dan 26: mereka diduga anggota geng peretas bernama The Community.  Geng tersebut didakwa dengan tujuh serangan swap, akibatnya peretas yang menggunakan cryptocurrency bernilai lebih dari $ 2,4 juta.  Dan pada bulan April, seorang siswa dari California, Joel Ortiz, menerima 10 tahun penjara karena bertukar SIM;  Cryptocurrency $ 7,5 juta menjadi mangsanya. <br><br><img src="https://habrastorage.org/webt/xy/b4/61/xyb4614ligd5ao0hslycslmxq3u.jpeg"><br>  <i>Foto oleh Joel Ortiz pada konferensi pers universitas.</i>  <i>Dua tahun kemudian, dia akan ditahan karena penipuan cyber.</i> <br><br><h2>  Prinsip pertukaran SIM </h2><br>  Swap berarti pertukaran.  Dalam semua skema semacam itu, penjahat menetapkan nomor telepon korban, biasanya dengan menerbitkan kembali kartu SIM, dan menggunakannya untuk mereset kata sandi.  Suatu pertukaran SIM tipikal dalam teori terlihat seperti ini: <br><br><ol><li>  Kecerdasan  Penipu mencari tahu data pribadi korban: nama dan telepon.  Mereka dapat ditemukan di sumber terbuka (jejaring sosial, teman) atau diperoleh dari kaki tangan - karyawan operator seluler. </li><li>  Memblokir.  Kartu SIM Korban dinonaktifkan;  Untuk melakukan ini, cukup hubungi dukungan teknis penyedia, laporkan nomornya dan katakan bahwa telepon telah hilang. </li><li>  Abadikan, transfer nomor ke kartu SIM Anda.  Biasanya ini juga dilakukan melalui kaki tangan di perusahaan telekomunikasi atau dengan memalsukan dokumen. </li></ol><br>  Dalam kehidupan nyata itu masih lebih parah.  Penyerang memilih korban, dan kemudian setiap hari memantau lokasi telepon - satu permintaan informasi bahwa pelanggan telah beralih ke biaya jelajah 1-2 sen.  Begitu pemilik kartu SIM pergi ke luar negeri, mereka setuju dengan manajer di salon komunikasi untuk mengeluarkan kartu SIM baru.  Harganya sekitar $ 50 (saya menemukan informasi - di berbagai negara dan dari operator yang berbeda dari $ 20 hingga $ 100), sementara manajer akan dipecat dalam kasus terburuk - tidak ada tanggung jawab untuk ini. <br><br>  Sekarang semua penyusup akan menerima semua SMS, dan pemilik ponsel tidak akan bisa berbuat apa-apa - dia ada di luar negeri.  Dan kemudian penjahat mendapatkan akses ke semua akun korban dan, jika diinginkan, ubah kata sandi. <br><br><h2>  Peluang untuk mengembalikan barang curian </h2><br>  Bank terkadang pergi ke arah para korban dan menarik transfer dari rekening mereka.  Oleh karena itu, dimungkinkan untuk mengembalikan uang fiat, meskipun pelanggar tidak ditemukan.  Tetapi dengan dompet cryptocurrency, semuanya lebih rumit - baik secara <i>teknis</i> maupun hukum.  Sejauh ini, tidak ada pertukaran / dompet telah membayar kompensasi untuk menukar korban. <br><br>  Jika korban ingin mempertahankan uang mereka di pengadilan, maka mereka menuduh operator: ia menciptakan kondisi untuk pencurian uang dari akun.  Ini persis seperti yang dilakukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Michael Turpin</a> , yang kehilangan $ 224 juta karena swap. Sekarang dia menggugat perusahaan telekomunikasi AT&amp;T. <br><br><img src="https://habrastorage.org/webt/1d/bx/cp/1dbxcp8cbskbzhc8dlpwm3rqggm.png"><br><br>  Sejauh ini, tidak ada negara yang memiliki skema kerja untuk melindungi pemilik cryptocurrency secara legal.  Tidak mungkin mengasuransikan modal Anda atau menerima kompensasi atas kerugiannya.  Oleh karena itu, mencegah serangan swap lebih mudah daripada melawan konsekuensinya.  Cara yang paling jelas adalah menggunakan "faktor kedua" yang lebih andal untuk 2FA. <br><br><h2>  SIM swap bukan satu-satunya masalah 2FA melalui SMS </h2><br>  Kode konfirmasi dalam SMS juga tidak aman dari sudut pandang teknis.  Pesan dapat dicegat karena kerentanan fatal di Signaling System 7 (SS7).  2FA melalui SMS secara resmi diakui tidak aman (Institut Nasional Standar dan Teknologi AS membicarakan hal ini dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan Otentikasi Digitalnya</a> ). <br><br>  Selain itu, kehadiran 2FA sering menginspirasi pengguna dengan rasa aman palsu, dan ia memilih kata sandi yang lebih sederhana.  Oleh karena itu, otentikasi tersebut tidak menyulitkan, tetapi memfasilitasi akses penyerang ke akun. <br><br>  Dan seringkali SMS datang dengan penundaan yang lama atau tidak datang sama sekali. <br><br><h2>  Metode 2FA lainnya </h2><br>  Tentu saja, pada smartphone dan SMS, lampu tidak menyatu.  Ada metode 2FA lainnya.  Misalnya, kode TAN satu kali: metode ini primitif, tetapi berfungsi - masih digunakan di beberapa bank.  Ada sistem yang menggunakan data biometrik: sidik jari, pemindaian retina.  Opsi lain yang tampaknya seperti kompromi yang wajar dalam hal kenyamanan, keandalan, dan harga adalah aplikasi khusus untuk 2FA: RSA Token, Google Authenticator.  Dan ada kunci fisik dan metode lainnya. <br><br>  Secara teori, semuanya terlihat logis dan dapat diandalkan.  Namun dalam praktiknya, solusi 2FA modern memiliki masalah, dan karena itu, kenyataan berbeda dari harapan. <br><br>  Menurut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penelitian tersebut</a> , penggunaan 2FA pada prinsipnya merupakan ketidaknyamanan, dan popularitas 2FA melalui SMS dijelaskan oleh “lebih sedikit ketidaknyamanan dibandingkan dengan metode lain” - menerima kode satu kali dapat dimengerti oleh pengguna. <br><br>  Banyak pengguna metode 2FA mengasosiasikan dengan ketakutan bahwa akses akan hilang.  Kunci fisik atau daftar kata sandi TAN dapat hilang atau dicuri.  Saya pribadi memiliki pengalaman negatif menggunakan Google Authenticator.  Ponsel cerdas pertama saya dengan aplikasi ini rusak - evaluasi upaya saya untuk memulihkan akses ke akun.  Masalah lain adalah transisi ke perangkat baru.  Google Authenticator tidak dapat mengekspor karena masalah keamanan (jika kunci dapat diekspor, jenis keamanan apa yang ada?).  Suatu kali saya mentransfer kunci secara manual, dan kemudian memutuskan bahwa lebih mudah meninggalkan smartphone lama di dalam kotak di rak. <br><br>  Metode 2FA harus: <br><br><ul><li>  Aman - hanya Anda yang harus mendapatkan akses ke akun Anda, bukan penyerang </li><li>  Andal - Anda mendapatkan akses ke akun Anda kapan pun Anda membutuhkannya </li><li>  Nyaman dan terjangkau - menggunakan 2FA jelas dan membutuhkan waktu minimum </li><li>  Murah </li></ul><br>  Kami percaya bahwa blockchain adalah solusi yang tepat. <br><br><h2>  Gunakan 2FA di blockchain </h2><br>  Untuk pengguna, 2FA pada blockchain terlihat sama dengan menerima kode satu kali melalui SMS.  Satu-satunya perbedaan adalah di saluran pengiriman.  Cara mendapatkan kode 2FA tergantung pada apa yang ditawarkan blockchain.  Dalam proyek kami (informasi ada di profil saya) ini adalah aplikasi Web, Tor, iOS, Android, Linux, Windows, MacOS. <br><br>  Layanan menghasilkan kode satu kali dan mengirimkannya ke messenger di blockchain.  Selanjutnya, sesuai dengan klasik: pengguna memasukkan kode yang diterima di antarmuka layanan dan masuk. <br><br><img src="https://habrastorage.org/webt/4a/yq/ph/4ayqphaul5iozz1f_v2g0q4ziqw.png"><br><br>  Dalam artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana messenger yang didesentralisasi bekerja di blockchain,</a> saya menulis bahwa blockchain memastikan keamanan dan privasi pengiriman pesan.  Mengenai masalah pengiriman kode 2FA, saya akan menyoroti: <br><br><ul><li>  Satu klik untuk membuat akun - tanpa telepon atau email. </li><li>  Semua pesan dengan kode 2FA dienkripsi kurva End-to-End25519xsalsa20poly1305. </li><li>  Serangan MITM dikecualikan - setiap pesan dengan kode 2FA adalah transaksi pada blockchain dan ditandatangani oleh Ed25519 EdDSA. </li><li>  Pesan dengan kode 2FA masuk dalam bloknya.  Urutan dan stempel waktu blok tidak dapat diperbaiki, dan karena itu urutan pesan. </li><li>  Tidak ada struktur utama yang memeriksa “keaslian” pesan.  Ini dilakukan oleh sistem node terdistribusi berbasis konsensus, dan itu milik pengguna. </li><li>  Ketidakmampuan untuk menonaktifkan - akun tidak dapat diblokir, dan pesan dapat dihapus. </li><li>  Akses kode 2FA dari perangkat apa saja kapan saja. </li><li>  Pesan konfirmasi pengiriman dengan kode 2FA.  Layanan yang mengirim kata sandi satu kali tahu dengan pasti kata sandi itu telah terkirim.  Tidak ada tombol "Kirim Lagi". </li></ul><br>  Untuk perbandingan dengan beberapa metode 2FA lainnya, saya telah menyusun tabel: <br><br><img src="https://habrastorage.org/webt/pl/am/tm/plamtmeiv5xnjmupd5bevfrpftu.png"><br><br>  Pengguna menerima akun di messenger blockchain untuk menerima kode dalam frasa sandi kedua saja yang digunakan untuk memasukkan.  Oleh karena itu, metode aplikasi dapat berbeda: Anda dapat menggunakan satu akun untuk mendapatkan kode untuk semua layanan, atau Anda dapat membuat akun terpisah untuk setiap layanan. <br><br>  Ada juga kerugian - akun harus memiliki setidaknya satu transaksi.  Agar pengguna menerima pesan terenkripsi dengan kode, Anda harus mengetahui kunci publiknya, dan ia muncul di blockchain hanya dengan transaksi pertama.  Kami keluar dengan cara ini: kami memberi kesempatan untuk menerima token gratis di dompet.  Namun, solusi yang lebih tepat adalah memberi nama akun kunci publik.  (Sebagai perbandingan, nomor akun kami <i>U1467838112172792705</i> adalah turunan dari kunci publik <i>cc1ca549413b942029c4742a6e6ed69767c325f8d989f7e4b71ad82a164c2ada</i> . Untuk <i>pengirim</i> pesan, ini lebih mudah dan mudah dibaca, tetapi untuk sistem pengiriman kode 2FA).  Saya pikir di masa depan seseorang akan membuat keputusan dan mentransfer "Kenyamanan dan Aksesibilitas" ke zona hijau. <br><br>  Biaya pengiriman kode 2FA sangat rendah - 0,001 ADM, sekarang 0,00001 USD.  Sekali lagi, Anda dapat meningkatkan blockchain Anda dan membuat harga nol. <br><br><h2>  Bagaimana menghubungkan 2FA di blockchain ke layanan Anda </h2><br>  Saya harap saya dapat menarik beberapa pembaca untuk menambahkan otorisasi blockchain ke layanan mereka. <br><br>  Saya akan memberi tahu Anda cara melakukan ini menggunakan contoh messenger kami, dan dengan analogi Anda dapat menggunakan blockchain lain.  Dalam aplikasi demo 2FA, kami menggunakan postgresql10 untuk menyimpan informasi akun. <br><br>  Langkah-langkah koneksi: <br><br><ol><li>  Buat akun di blockchain dari mana Anda akan mengirim kode 2FA.  Anda akan menerima frasa sandi, yang digunakan sebagai kunci pribadi untuk mengenkripsi pesan dengan kode dan untuk menandatangani transaksi. </li><li>  Tambahkan skrip ke server Anda untuk menghasilkan kode 2FA.  Jika Anda sudah menggunakan metode 2FA lainnya dengan pengiriman kata sandi satu kali, langkah ini telah selesai. </li><li>  Tambahkan skrip ke server Anda untuk mengirim kode ke pengguna di messenger blockchain. </li><li>  Buat antarmuka pengguna untuk mengirim dan memasukkan kode 2FA.  Jika Anda sudah menggunakan metode 2FA lainnya dengan pengiriman kata sandi satu kali, langkah ini telah selesai. </li></ol><br>  <b>1 Buat akun</b> <br><br>  Membuat akun di blockchain adalah pembuatan kunci pribadi, kunci publik, dan alamat akun yang berasal darinya. <br><br><img src="https://habrastorage.org/webt/7o/at/vs/7oatvsalils_l9wsl8av5cjqtkc.png"><br><br>  Pertama, kata sandi BIP39 dihasilkan, dari mana hash SHA-256 dipertimbangkan.  Hash digunakan untuk menghasilkan kunci privat ks dan kunci publik kp.  Dari kunci publik dengan SHA-256 yang sama dengan inversi, kami mendapatkan alamat di blockchain. <br><br>  Jika Anda ingin mengirim kode 2FA setiap kali dari akun baru, kode untuk membuat akun perlu ditambahkan ke server: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Mnemonic <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'bitcore-mnemonic'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.passphrase = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mnemonic(Mnemonic.Words.ENGLISH).toString() … <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> bip39 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'bip39'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> crypto <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'crypto'</span></span> adamant.createPassphraseHash = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">passphrase</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> seedHex = bip39.mnemonicToSeedSync(passphrase).toString(<span class="hljs-string"><span class="hljs-string">'hex'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> crypto.createHash(<span class="hljs-string"><span class="hljs-string">'sha256'</span></span>).update(seedHex, <span class="hljs-string"><span class="hljs-string">'hex'</span></span>).digest() } … <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sodium <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'sodium-browserify-tweetnacl'</span></span> adamant.makeKeypair = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">hash</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> keypair = sodium.crypto_sign_seed_keypair(hash) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">publicKey</span></span>: keypair.publicKey, <span class="hljs-attr"><span class="hljs-attr">privateKey</span></span>: keypair.secretKey } } … <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> crypto <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'crypto'</span></span> adamant.getAddressFromPublicKey = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">publicKey</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> publicKeyHash = crypto.createHash(<span class="hljs-string"><span class="hljs-string">'sha256'</span></span>).update(publicKey, <span class="hljs-string"><span class="hljs-string">'hex'</span></span>).digest() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> temp = Buffer.alloc(<span class="hljs-number"><span class="hljs-number">8</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; i++) { temp[i] = publicKeyHash[<span class="hljs-number"><span class="hljs-number">7</span></span> - i] } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'U'</span></span> + bignum.fromBuffer(temp).toString() }</code> </pre> <br>  Dalam aplikasi demo, kami menyederhanakannya - membuat satu akun di aplikasi web, dan mengirim kode darinya.  Dalam kebanyakan kasus, ini lebih nyaman bagi pengguna: ia tahu bahwa layanan mengirim kode 2FA dari akun tertentu, dan dapat menamainya. <br><br><img src="https://habrastorage.org/webt/j6/0p/pi/j60ppi_a1zvkc-ifcrdxkaz8ow8.png"><br><br>  <b>2 Generasi Kode 2FA</b> <br><br>  Kode 2FA perlu dibuat untuk setiap login pengguna.  Kami menggunakan perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">speakeasy</a> , tetapi Anda dapat memilih yang lain. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hotp = speakeasy.hotp({ counter, <span class="hljs-attr"><span class="hljs-attr">secret</span></span>: account.seSecretAscii, });</code> </pre><br>  Validasi kode 2FA pengguna yang dimasukkan oleh pengguna: <br><br><pre> <code class="javascript hljs">se2faVerified = speakeasy.hotp.verify({ <span class="hljs-attr"><span class="hljs-attr">counter</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.seCounter, <span class="hljs-attr"><span class="hljs-attr">secret</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.seSecretAscii, <span class="hljs-attr"><span class="hljs-attr">token</span></span>: hotp, });</code> </pre><br>  <b>3 Kirim Kode 2FA</b> <br><br>  Anda dapat menggunakan API node blockchain, pustaka JS API, atau konsol untuk mengirim kode 2FA.  Dalam contoh ini, kami menggunakan konsol - ini adalah Command Line Interface, utilitas yang menyederhanakan interaksi dengan blockchain.  Untuk mengirim pesan dengan kode 2FA, Anda harus menggunakan perintah <code>send message</code> dari konsol. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> util = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'util'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> exec = util.promisify(<span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'child_process'</span></span>).exec); … <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> command = <span class="hljs-string"><span class="hljs-string">`adm send message </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${adamantAddress}</span></span></span><span class="hljs-string"> "2FA code: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${hotp}</span></span></span><span class="hljs-string">"`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> { error, stdout, stderr } = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> exec(command);</code> </pre><br>  Cara alternatif untuk mengirim pesan adalah dengan menggunakan metode <code>send</code> di pustaka JS API. <br><br>  <b>4 antarmuka pengguna</b> <br><br>  Pengguna perlu diberi kesempatan untuk memasukkan kode 2FA, ini dapat dilakukan dengan berbagai cara tergantung pada platform aplikasi Anda.  Dalam contoh kita, ini Vue. <br><br><img src="https://habrastorage.org/webt/1g/yb/yv/1gybyvcmjucrqilrcpo74k8onoy.png"><br><br>  Kode sumber aplikasi demo otorisasi dua faktor pada blockchain dapat dilihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> .  Ada tautan di demo Langsung di Readme untuk mencobanya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id476090/">https://habr.com/ru/post/id476090/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id476060/index.html">Berita dari dunia OpenStreetMap No. 485 (10.29.2019 - 04.11.2019)</a></li>
<li><a href="../id476074/index.html">Mobil listrik buatan rumah - bagian 1</a></li>
<li><a href="../id476076/index.html">Terlalu bersih</a></li>
<li><a href="../id476082/index.html">Array.splice dan Array.slice di JavaScript</a></li>
<li><a href="../id476088/index.html">Konferensi BLACK HAT USA. Kaya atau mati: hasilkan uang di Internet menggunakan Black Hat. Bagian 1</a></li>
<li><a href="../id476092/index.html">Tentang arahan “Photonics”, “Programming and IT” dan “Information and Cybersecurity” dari Olimpiade “I am a Professional”</a></li>
<li><a href="../id476094/index.html">Kembalinya Zaman Kerajaan: Segala Tentang Zaman Kerajaan IV</a></li>
<li><a href="../id476096/index.html">Persediaan dari I hingga Z. Kami mempertimbangkan aset TI</a></li>
<li><a href="../id476098/index.html">Struktur data di Jawa. Metode kelas pembantu yang berguna</a></li>
<li><a href="../id476100/index.html">Arsitektur sistem komputer 1 bagian. Gerbang logika</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>