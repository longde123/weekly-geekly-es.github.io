<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍⚕️ 🙎🏼 👉🏿 Gestion des erreurs Kotlin / Java: comment le faire correctement? 👨🏻‍🏫 🙅🏾 🤦🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Source 


 La gestion des erreurs dans tout développement joue un rôle crucial. Presque tout peut mal tourner dans le programme: l'utilisateur entrera...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gestion des erreurs Kotlin / Java: comment le faire correctement?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/471766/"><img src="https://habrastorage.org/webt/hw/w3/mc/hww3mcjps5hwhykuwyzwj8upunu.jpeg"><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Source</a> </p><br><p>  La gestion des erreurs dans tout développement joue un rôle crucial.  Presque tout peut mal tourner dans le programme: l'utilisateur entrera des données incorrectes, ou elles peuvent provenir de telles via http, ou nous avons fait une erreur lors de l'écriture de la sérialisation / désérialisation et pendant le traitement, le programme se bloque avec une erreur.  Oui, il se peut que l'espace disque soit insuffisant. </p><br><div class="spoiler">  <b class="spoiler_title">spoiler</b> <div class="spoiler_text"><p>  ¯_ (ツ) _ / ¯, il n'y a pas de voie unique, et dans chaque situation spécifique, vous devrez choisir l'option la plus appropriée, mais il y a des recommandations sur la façon de mieux le faire. </p></div></div><a name="habracut"></a><br><h3 id="predislovie">  Préface </h3><br><p>  Malheureusement (ou tout simplement une telle vie?), Cette liste s'allonge encore et encore.  Le développeur doit constamment penser au fait que quelque part une erreur peut se produire, et il y a 2 situations: </p><br><ul><li>  lorsque l'erreur attendue se produit lors de l'appel de la fonction que nous avons fournie et que nous pouvons essayer de traiter; </li><li>  lorsqu'une erreur inattendue se produit pendant l'opération que nous n'avions pas prévue. </li></ul><br><p>  Et si les erreurs attendues sont au moins localisées, le reste peut se produire presque partout.  Si nous ne traitons rien d'important, nous pouvons simplement planter avec une erreur (bien que ce comportement ne soit pas suffisant et que vous deviez au moins ajouter un message au journal des erreurs).  Mais si en ce moment le paiement est en cours de traitement et que vous ne pouvez tout simplement pas tomber, mais au moins vous devez renvoyer une réponse au sujet de l'opération infructueuse? </p><br><p>  Avant d'examiner les moyens de gérer les erreurs, quelques mots sur l'exception (exceptions): </p><br><h3 id="exception">  Exception </h3><br><img src="https://habrastorage.org/webt/hn/mx/yz/hnmxyzwyfbelfe32oqi1nyite4o.png"><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Source</a> </p><br><p> La hiérarchie des exceptions est bien décrite et vous pouvez trouver beaucoup d'informations à ce sujet, il est donc inutile de la peindre ici.  Ce qui provoque parfois des discussions animées est des erreurs <code>checked</code> et <code>unchecked</code> <code>checked</code> .  Et bien que la majorité ait accepté les exceptions <code>unchecked</code> comme préférées (à Kotlin, il n'y a aucune exception <code>checked</code> ), tout le monde n'est pas d'accord avec cela. </p><br><p>  Les exceptions <code>checked</code> avaient vraiment la bonne intention d'en faire un mécanisme de gestion des erreurs pratique, mais la réalité a fait ses ajustements, bien que l'idée d'introduire toutes les exceptions qui peuvent être levées de cette fonction dans la signature soit compréhensible et logique. </p><br><p>  Regardons un exemple.  Supposons que nous ayons une fonction de <code>method</code> qui peut <code>PanicException</code> une <code>PanicException</code> vérifiée.  Une telle fonction ressemblerait à ceci: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> PanicException </span></span>{ }</code> </pre> <br><p>  D'après sa description, il est clair qu'elle peut lever une exception et qu'il ne peut y avoir qu'une seule exception.  Semble-t-il assez confortable?  Et bien que nous ayons un petit programme, c'est tout.  Mais si le programme est légèrement plus grand et qu'il y a plus de telles fonctions, alors certains problèmes apparaissent. </p><br><p>  Les exceptions vérifiées nécessitent, par spécification, que <strong>toutes les</strong> exceptions vérifiées <strong>possibles</strong> (ou un ancêtre commun pour elles) soient répertoriées dans la signature de la fonction.  Par conséquent, si nous avons une chaîne d'appels <code>a</code> -&gt; <code>b</code> -&gt; <code>c</code> et que la fonction la plus imbriquée lève une sorte d'exception, elle doit être supprimée pour tout le monde dans la chaîne.  Et s'il existe plusieurs exceptions, la fonction la plus haute de la signature doit avoir une description de toutes. </p><br><p>  Ainsi, à mesure que le programme devient plus complexe, cette approche conduit au fait que les exceptions à la fonction supérieure s'effondrent progressivement aux ancêtres communs et finissent par se <code>Exception</code> à <code>Exception</code> .  Ce qui sous cette forme devient similaire à une exception <code>unchecked</code> vérifiée et annule tous les avantages des exceptions vérifiées. </p><br><p>  Et étant donné que le programme, en tant qu’organisme vivant, est en constante évolution et évolution, il est presque impossible de prévoir à l’avance quelles exceptions peuvent en résulter.  Et en conséquence, la situation est que lorsque nous ajoutons une nouvelle fonction avec une nouvelle exception, nous devons parcourir toute la chaîne de son utilisation et changer les signatures de toutes les fonctions.  D'accord, ce n'est pas la tâche la plus agréable (même si les IDE modernes le font pour nous). </p><br><p>  Mais le dernier, et probablement le plus gros clou des exceptions vérifiées "a conduit" les lambdas de Java 8. Il n'y a pas d'exceptions vérifiées ¯_ (ツ) _ / ¯ dans leur signature (puisque n'importe quelle fonction peut être appelée dans lambda, avec n'importe quel signature), donc tout appel de fonction avec une exception vérifiée de lambda le force à être encapsulé dans un transfert d'exception comme non vérifié: </p><br><pre> <code class="java hljs">Stream.of(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>).forEach(item -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { functionWithCheckedException(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(<span class="hljs-string"><span class="hljs-string">"rethrow"</span></span>, e); } });</code> </pre> <br><p>  Heureusement, dans la spécification JVM, il n'y a aucune exception vérifiée, donc dans Kotlin vous ne pouvez rien encapsuler dans le même lambda, mais simplement appeler la fonction souhaitée. </p><br><div class="spoiler">  <b class="spoiler_title">bien que parfois ...</b> <div class="spoiler_text"><p>  Bien que cela entraîne parfois des conséquences inattendues, telles que, par exemple, le fonctionnement incorrect de <code>@Transactional</code> dans <code>Spring Framework</code> , qui "n'attend" que des exceptions non <code>unckecked</code> .  Mais c'est plus une caractéristique du framework, et peut-être que ce comportement au printemps changera dans le futur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">problème de github</a> . </p></div></div><br><p>  Les exceptions elles-mêmes sont des objets spéciaux.  Outre le fait qu'ils peuvent être "lancés" par des méthodes, ils collectent également stacktrace à la création.  Cette fonctionnalité aide ensuite à l'analyse des problèmes et à la recherche d'erreurs, mais elle peut également entraîner des problèmes de performances si la logique d'application devient fortement liée aux exceptions levées.  Comme indiqué dans l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> , la désactivation de l'assemblage stacktrace peut augmenter considérablement leurs performances dans ce cas, mais vous ne devez y recourir que dans des cas exceptionnels lorsque cela est vraiment nécessaire! </p><br><h3 id="obrabotka-oshibok">  Gestion des erreurs </h3><br><p>  La principale chose à faire avec les erreurs «inattendues» est de trouver un endroit où vous pouvez les intercepter.  Dans les langages JVM, cela peut être soit un point de création de flux, soit un point d'entrée / filtre pour la méthode http, où vous pouvez mettre un essai avec la gestion des erreurs <code>unchecked</code> .  Si vous utilisez un framework, il est très probable qu'il ait déjà la possibilité de créer des gestionnaires d'erreurs courants, comme, par exemple, dans le Spring Framework, vous pouvez utiliser des méthodes avec l'annotation <code>@ExceptionHandler</code> . </p><br><p>  Vous pouvez «lever» des exceptions à ces points de traitement central que nous ne voulons pas gérer à des endroits spécifiques en lançant les mêmes exceptions non <code>unckecked</code> (lorsque, par exemple, nous ne savons pas quoi faire à un endroit particulier et comment gérer l'erreur).  Mais cette méthode n'est pas toujours appropriée, car elle peut parfois nécessiter de gérer l'erreur sur place et vous devez vérifier que tous les appels de fonction sont traités correctement.  Réfléchissez aux moyens de procéder. </p><br><ol><li><p>  Utilisez toujours des exceptions et le même try-catch: </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sum; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { sum = calculateSum(a,b); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { sum = -<span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><p>  Le principal inconvénient est que nous pouvons «oublier» de l'envelopper dans un try-catch à l'endroit de l'appel et ignorer la tentative de traitement en place, à cause de quoi l'exception se retrouvera au point commun du traitement des erreurs.  Ici, nous pouvons aller aux exceptions <code>checked</code> (pour Java), mais nous obtiendrons ensuite tous les inconvénients mentionnés ci-dessus.  Cette approche est pratique à utiliser si la gestion des erreurs en place n'est pas toujours requise, mais dans de rares cas, elle est nécessaire. </p><br></li><li><p>  Utilisez la classe scellée à la suite d'un appel (Kotlin). <br>  Dans Kotlin, vous pouvez limiter le nombre d'héritiers de classe, les rendre calculables au stade de la compilation - cela permet au compilateur de vérifier que toutes les options possibles sont analysées dans le code.  En Java, vous pouvez cependant créer une interface commune et plusieurs descendants, en perdant les vérifications au niveau de la compilation. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Result</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SuccessResult</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> value: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>): Result() <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExceptionResult</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> exception: Exception): Result() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sum = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = calculateSum(a,b)) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> SuccessResult -&gt; result.value <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ExceptionResult -&gt; { result.exception.printStackTrace() -<span class="hljs-number"><span class="hljs-number">1</span></span> } }</code> </pre> <br><p>  Ici, nous obtenons quelque chose comme une approche d'erreur <code>golang</code> lorsque vous devez vérifier explicitement les valeurs résultantes (ou ignorer explicitement).  L'approche est assez pratique et particulièrement pratique lorsque vous devez lancer un grand nombre de paramètres dans chaque situation.  La classe <code>Result</code> peut être développée avec différentes méthodes qui facilitent l'obtention du résultat avec une exception levée ci-dessus, le cas échéant (c'est-à-dire que nous n'avons pas besoin de gérer l'erreur à l'endroit de l'appel).  L'inconvénient principal ne sera que la création d'objets superflus intermédiaires (et une entrée légèrement plus verbeuse), mais il peut également être supprimé en utilisant <code>inline</code> classes en <code>inline</code> (si un argument nous suffit).  et, comme exemple particulier, il existe une classe <code>Result</code> de Kotlin.  Certes, ce n'est que pour un usage interne, comme  à l'avenir, son implémentation peut changer légèrement, mais si vous souhaitez l'utiliser, vous pouvez ajouter l'indicateur de compilation <code>-Xallow-result-return-type</code> . </p><br></li><li><p>  Comme l'un des types possibles de la revendication 2, l'utilisation du type de la programmation fonctionnelle de <code>Either</code> , qui peut être soit un résultat soit une erreur.  Le type lui-même peut être une classe <code>sealed</code> ou une classe en <code>inline</code> .  Voici un exemple d'utilisation de l'implémentation de la bibliothèque de <code>arrow</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> value = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = calculateSum(a,b)) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Either.Left -&gt; { result.a.printStackTrace() -<span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Either.Right -&gt; result.b }</code> </pre> <br><p>  <code>Either</code> convient le mieux à ceux qui aiment une approche fonctionnelle et qui aiment construire des chaînes d'appels. </p><br></li><li><p>  Utilisez l' <code>Option</code> ou le type <code>nullable</code> de Kotlin: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sum = calculateSum(a,b) ?: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> RuntimeException(<span class="hljs-string"><span class="hljs-string">"some exception"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, b: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>?</code> </pre> <br><p>  Cette approche convient si la cause de l'erreur n'est pas très importante et lorsqu'elle n'en est qu'une.  Une réponse vide est considérée comme une erreur et est renvoyée plus haut.  L'enregistrement le plus court, sans créer d'objets supplémentaires, mais cette approche ne peut pas toujours être appliquée. </p><br></li><li><p>  Semblable à l'article 4, utilise uniquement une valeur de code dur comme marqueur d'erreur: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sum = calculateSum(a,b) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sum == -<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> RuntimeException(“error”) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, b: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span></code> </pre> <br><p>  C'est probablement la plus ancienne approche de gestion des erreurs qui soit revenue de <code>C</code> (ou même d'Algol).  Il n'y a pas de surcharge, seulement un code qui n'est pas entièrement clair (avec des restrictions sur le choix du résultat), mais, contrairement à l'étape 4, il est possible de faire divers codes d'erreur si plus d'une exception possible est requise. </p><br></li></ol><br><h3 id="vyvody">  Conclusions </h3><br><p>  Toutes les approches peuvent être combinées en fonction de la situation, et aucune d'entre elles ne convient dans tous les cas. </p><br><p>  Ainsi, par exemple, vous pouvez réaliser une approche <code>golang</code> des erreurs en utilisant <code>sealed</code> classes <code>sealed</code> , et là où ce n'est pas très pratique, passez aux erreurs <code>unchecked</code> vérifiées. </p><br><p>  Ou, dans la plupart des endroits, <code>nullable</code> type <code>nullable</code> comme marqueur qu'il n'a pas été possible de calculer la valeur ou de l'obtenir quelque part (par exemple, comme indicateur que la valeur n'a pas été trouvée dans la base de données). </p><br><p>  Et si vous avez du code entièrement fonctionnel avec une <code>arrow</code> ou une autre bibliothèque similaire, il est probablement préférable d'utiliser <code>Either</code> . </p><br><p>  En ce qui concerne les serveurs http, il est plus facile de signaler toutes les erreurs aux points centraux et, à certains endroits seulement, de combiner l'approche <code>nullable</code> avec <code>sealed</code> classes <code>sealed</code> . </p><br><p>  Je serai heureux de voir dans les commentaires que vous utilisez cela, ou peut-être existe-t-il d'autres méthodes de gestion des erreurs pratiques? </p><br><p>  Et merci à tous ceux qui ont lu jusqu'au bout! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr471766/">https://habr.com/ru/post/fr471766/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr471748/index.html">Optimisation en pharmacie: ce que nous avons fait avec les mathématiques</a></li>
<li><a href="../fr471750/index.html">La gestion des accès privilégiés en tant que tâche prioritaire dans la sécurité des informations (par exemple, Fudo PAM)</a></li>
<li><a href="../fr471756/index.html">Comment le serveur démarre</a></li>
<li><a href="../fr471758/index.html">Comment traduire du texte dans une autre langue?</a></li>
<li><a href="../fr471760/index.html">Edward Snowden: The Battlefield - Cryptage</a></li>
<li><a href="../fr471770/index.html">Découvrez les outils Big Data: prise en charge des ordinateurs portables Spark et Zeppelin dans IntelliJ IDEA</a></li>
<li><a href="../fr471772/index.html">Outils de lancement et de développement d'applications Java, compilation, exécution sur la JVM</a></li>
<li><a href="../fr471774/index.html">API Android Camera2 à partir de la théière, partie 2, écriture d'une vidéo</a></li>
<li><a href="../fr471776/index.html">Laravel: expliquer les concepts de base. Deuxième partie: pratique</a></li>
<li><a href="../fr471778/index.html">Breaking Micosoft Lunix à HackQuest 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>