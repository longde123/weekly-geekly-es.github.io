<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌘 🤴🏻 🧚🏻 现实的刻薄思考 👨🏼‍💼 🧗🏿 🏑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大多数技术艺术家在其职业生涯中的某个时刻都试图创建合理的焦散反射。 如果您是游戏开发人员，那么阅读Twitter的主要原因之一就是可以从中汲取无穷的灵感。 几天前，Florian Gelzenlichter（在Twitter上的kolyaTQ ）发布了使用着色器在Unity中创建的苛性效果的GIF。...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>现实的刻薄思考</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467887/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/hd/an/yo/hdanyowyfitt8zvoj7vaeu3drdi.gif"></div><br> 大多数技术艺术家在其职业生涯中的某个时刻都试图创建合理的焦散反射。 如果您是游戏开发人员，那么阅读Twitter的主要原因之一就是可以从中汲取无穷的灵感。 几天前，Florian Gelzenlichter（在Twitter上的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener noreferrer">kolyaTQ</a> ）发布了使用着色器在Unity中创建的苛性效果的GIF。 该帖子（如下所示）迅速获得了1500顶赞，表明对此类内容有浓厚的兴趣。 <br><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="1165251296720576512"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br> 尽管我通常对更长和技术复杂的系列文章更感兴趣（例如，关于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener noreferrer">体积大气光散射</a> [在Habré上的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">翻译</a> ]和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener noreferrer">逆运动学</a> [在Habré上的翻译的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第二</a>部分），但我无法抗拒编写简短而可爱的教程的诱惑。关于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener noreferrer">Florian</a>的影响。 <br><br> 本文结尾处有一个链接，用于下载Unity软件包和所有必需的资产。 <br><a name="habracut"></a><br><h2> 什么是苛性的 </h2><br> 尽管您每天都会遇到这种影响，但您可能并不<em>了解苛性碱的</em>概念。 焦散是由曲面引起的光反射。 在一般情况下，任何曲面都可以像透镜一样工作，将光聚焦在某些点上并将其散射在其他点上。 提供这种效果的最常见介质是玻璃和水，它们会产生所谓的<strong>苛性波</strong> （见下文）。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2cf/dcc/0c7/2cfdcc0c727f1637ffc5c360fd816a8f.jpg"></div><br> 焦散可以采取其他形式。 例如，彩虹是一种光学现象，当光线在雨滴中折射时发生。 因此，严格来说，它是苛性的。 <br><br><h2> 效果剖析 </h2><br> 苛刻波的一个可识别特征是其移动方式。 如果您曾经看过泳池底部，很可能看到了他。 重建真实的苛性碱非常昂贵，因为它需要模拟许多光线。 <br><br> 从单一的腐蚀性纹理开始， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener noreferrer">Florian</a>设法创造了合理的效果。 为了创建我的教程，我使用了如下所示的纹理，该纹理取自<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener noreferrer">OpenGameArt</a> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c3a/418/def/c3a418defd9ff05890f63c4c35e728ad.gif" width="250" height="250"></div><br> 可以实现此效果的一个重要属性是上面显示的苛性碱模式是<strong>无缝的</strong> 。 这意味着您可以将两个图像彼此相邻放置，并且它们之间不会出现明显的接缝。 由于我们想在较大的表面上使用此效果，因此重要的是，我们有机会拉伸此纹理而不会产生会破坏幻觉的泪水。 <br><br> 收到纹理后， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener noreferrer">Florian</a>建议采取以下三个步骤： <br><br><ul><li> 在模型表面两次施加苛性碱图案，每次使用不同的大小和速度 </li><li>使用<code>min</code>运算符混合两种模式 </li><li> 采样时分离RGB通道。 </li></ul><br> 让我们看看如何在Unity中实现每个步骤。 <br><br><h2> 着色器创建 </h2><br> 第一步是创建一个新的着色器。 由于这种效果很可能会在具有真实照明的3D游戏中使用，因此最好从<strong>表面着色器</strong>开始。 表面着色器是Unity支持的多种着色器之一（例如，用于未照明材质的<strong>顶点和片段着色</strong> <strong>器，</strong>用于后处理效果的<strong>屏幕着色器</strong>以及用于屏幕外模拟的<strong>计算着色器</strong> ）。 <br><br> 新的表面着色器仅具有一些功能。 要创建此效果，我们需要将信息传输到着色器。 首先是苛性纹理。 其次，这是用于缩放和偏移它的参数。 <br><br> 让我们创建两个<em>着色器属性</em> ： <br><br><pre> <code class="cpp hljs">Properties { ... [Header(Caustics)] _CausticsTex(<span class="hljs-string"><span class="hljs-string">"Caustics (RGB)"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-comment"><span class="hljs-comment">// Tiling X, Tiling Y, Offset X, Offset Y _Caustics_ST("Caustics ST", Vector) = (1,1,0,0) }</span></span></code> </pre> <br> 以及相应的<em>Cg变量</em> ： <br><br><pre> <code class="cpp hljs">sampler2D _CausticsTex; float4 _Caustics_ST;</code> </pre> <br>  <em>着色器属性</em>对应于Unity Material Inspector中显示的字段。 相应的<em>Cg变量</em>本身就是值，可以在着色器代码中使用。 <br><br> 从上面的代码中可以看到， <code>_Caustics_ST</code>是<code>float4</code> ，即它包含四个值。 我们将使用它们来控制苛性纹理的采样。 即： <br><br><ul><li>  <code>_Caustics_ST.x</code> ：沿X轴的苛性纹理比例； </li><li>  <code>_Caustics_ST.y</code> ：沿Y轴的苛性纹理比例； </li><li>  <code>_Caustics_ST.z</code> ：苛性纹理沿X轴的位移； </li><li>  <code>_Caustics_ST.w</code> ：沿Y轴的腐蚀性纹理的位移； </li></ul><br><div class="spoiler">  <b class="spoiler_title">为什么将变量称为_Caustics_ST？</b> <div class="spoiler_text"> 如果您已经对使用着色器有一点经验，那么您已经看到了其他属性，它们的后缀为<code>_ST</code> 。 在Unity中， <code>_ST</code>可用于添加有关如何采样纹理的其他信息。 <br><br> 例如，如果创建Cg变量<code>_MainTex_ST</code> ，则可以在将纹理应用于模型时使用它来设置大小和偏移。 <br><br> 通常<code>_ST</code>变量不需要属性，因为它们会自动显示在检查器中。 但是，在这种特殊情况下，我们不能依靠它，因为我们需要两次采样纹理，每次使用不同的比例和偏移量。 将来，我们需要将此变量复制为两个不同的变量。 </div></div><br><h2> 采样纹理 </h2><br> 每个<em>表面着色器都</em>包含一个函数，通常称为<code>surf</code> ，用于确定每个渲染像素的颜色。  “标准” <code>surf</code>功能如下所示： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutputStandard o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Albedo comes from a texture tinted by color fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color; o.Albedo = c.rgb; // Metallic and smoothness come from slider variables o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</span></span></code> </pre> <br> 最终颜色由着色器必须初始化并在名为<code>SurfaceOutputStandard</code>的结构中返回的字段数确定。 我们需要更改<code>Albedo</code> ，它大致与白光照明的对象的颜色匹配。 <br><br> 在新创建的曲面着色器中，反照率取自名为<code>_MainTex</code>的纹理。 由于苛性效应叠加在现有纹理的顶部，因此我们将不得不在<code>_CausticsTex</code>中对纹理进行附加采样。 <br><br> 称为<strong>UV覆盖</strong>的技术使您能够根据需要渲染几何体的哪一部分来了解需要对纹理的哪一部分进行采样。 这是使用<code>uv_MainTex</code>变量<code>float2</code> ，该变量存储在3D模型的每个顶点处，并指示纹理的坐标。 <br><br> 我们的想法是使用<code>_Caustics_ST</code>缩放和偏移<code>uv_MainTex</code>以在模型中拉伸和移动苛性纹理。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutputStandard o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Albedo comes from a texture tinted by color fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color; o.Albedo = c.rgb; // Caustics sampling fixed2 uv = IN.uv_MainTex * _Caustics_ST.xy + _Caustics_ST.zw; fixed3 caustics = tex2D(_CausticsTex, uv).rgb; // Add o.Albedo.rgb += caustics; // Metallic and smoothness come from slider variables o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">如果反照率超过1会怎样？</b> <div class="spoiler_text"> 在上面的代码中，我们添加了两个纹理。 颜色通常介于 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>0</mn></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="2.074ex" viewBox="0 -772.3 500.5 892.8" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/467887/&amp;usg=ALkJrhgGox4vtvj6uyb4lqtVdlJpLrSjtQ#MJMAIN-30" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>0</mn></math></span></span><script type="math/tex" id="MathJax-Element-1"> 0 </script> 之前 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>1</mn></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="2.074ex" viewBox="0 -772.3 500.5 892.8" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/467887/&amp;usg=ALkJrhgGox4vtvj6uyb4lqtVdlJpLrSjtQ#MJMAIN-31" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-2"> 1 </script> 但是，不能保证结果是某些值不会超出此间隔。 <br><br> 在较旧的着色器中，这可能会引起问题。 这实际上是一个<em>功能</em> 。 如果像素颜色值超过1，则意味着其影响应“扩展”到其边界之外并影响相邻像素。 <br><br> 当获得非常明亮的镜面反射时，就会发生这种情况。 但是，此效果不应仅由曲面着色器创建。 为了发挥效果，相机必须打开<strong>HDR</strong> 。 此属性代表“ <strong>高动态范围”</strong> ； 它允许颜色值超过 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>1</mn></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="2.074ex" viewBox="0 -772.3 500.5 892.8" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/467887/&amp;usg=ALkJrhgGox4vtvj6uyb4lqtVdlJpLrSjtQ#MJMAIN-31" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-3"> 1 </script>  。 另外，为了使相邻像素上的过多颜色模糊，需要后处理效果。 <br><br>  Unity有自己的后处理堆栈，该堆栈具有执行此操作的Bloom Bloom过滤器。 您可以在Unity博客上了解有关此内容的更多信息： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener noreferrer">PostFX v2-惊人的视觉效果，已升级</a> 。 </div></div><br> 初步结果如下所示： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9d5/16f/1de/9d516f1de5a00d84b60e95674cf35650.png" width="843" height="406"></div><br><h2> 动画焦散 </h2><br> 苛性碱的最重要特征之一是其如何运动。 目前，它们只是作为第二个纹理静态投射到模型的表面上。 <br><br> 可以使用Unity属性<code>_Time</code>来实现着色器中材质的动画。 它可用于访问当前游戏时间，即在方程式中增加时间。 <br><br> 最简单的方法是根据当前时间简单地偏移纹理。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Caustics UV fixed2 uv = IN.uv_MainTex * _Caustics_ST.xy + _Caustics_ST.zw; uv += _CausticsSpeed * _Time.y; // Sampling fixed3 caustics = tex2D(_CausticsTex, uv).rgb; // Add o.Albedo.rgb += caustics;</span></span></code> </pre> <br>  <code>_Time.y</code>字段包含当前播放时间（以<em>秒为单位）</em> 。 如果反射运动太快，可以乘以一个因子。 为此，在上面显示的代码中使用了<code>_CausticsSpeed</code>类型的<code>_CausticsSpeed</code>变量。 <br><br> 您可能需要为自己的目的振动正弦曲线中的腐蚀性纹理。 在这里重要的是要了解没有实现效果的标准方法。 根据您的需要，可以使苛性反射的移动方式完全不同。 <br><br> 下面显示的结果仍然相当中等。 这是正常现象：要使反射看起来更漂亮，我们还有很多事情要做。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b6e/37d/d6b/b6e37dd6b3d6e172c342c7902845f60d.gif"></div><br><h2> 多次采样 </h2><br> 如果您对苛性纹理进行一次采样而不是两次采样，则效果会变得生动起来。 如果将它们彼此叠放并以不同的速度移动，结果将完全不同。 <br><br> 首先，我们复制<code>_Caustics_ST</code>和<code>_CausticsSpeed</code>属性，以使两个纹理的样本具有不同的比例，位移和速度： <br><br><pre> <code class="cpp hljs">[Header(Caustics)] _CausticsTex(<span class="hljs-string"><span class="hljs-string">"Caustics (RGB)"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-comment"><span class="hljs-comment">// Tiling X, Tiling Y, Offset X, Offset Y _Caustics1_ST("Caustics 1 ST", Vector) = (1,1,0,0) _Caustics2_ST("Caustics 1 ST", Vector) = (1,1,0,0) // Speed X, Speed Y _Caustics1_Speed("Caustics 1 Speed", Vector) = (1, 1, 0 ,0) _Caustics2_Speed("Caustics 2 Speed", Vector) = (1, 1, 0 ,0)</span></span></code> </pre> <br> 现在我们有了两个苛性碱样品，可以使用<code>min</code>运算符将它们混合。 如果仅取平均值，结果将不会很好。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Caustics samplings fixed3 caustics1 = ... fixed3 caustics2 = ... // Blend o.Albedo.rgb += min(caustics1, caustics2);</span></span></code> </pre> <br> 如此小的变化带来了巨大的变化： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ea/c9d/444/3eac9d4448485555980e10424e3f4ad5.gif"></div><br> 为了使代码美观，您还可以将腐蚀性采样代码包装在自己的函数中： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Caustics fixed3 c1 = causticsSample(_CausticsTex, IN.uv_MainTex, _Caustics1_ST, _Caustics1_Speed); fixed3 c2 = causticsSample(_CausticsTex, IN.uv_MainTex, _Caustics2_ST, _Caustics2_Speed); o.Albedo.rgb += min(c1, c2);</span></span></code> </pre> <br><h2>  RGB分离 </h2><br> 为了使苛刻的反射看起来不错，您需要做最后一个技巧。 穿过切片，不同波长的光会有不同的折射。 这意味着当在水中移动时，灯光会“分裂”为不同的颜色。 <br><br> 为了模拟这种效果，我们可以将每个腐蚀性样品分为三个，每个颜色通道一个。 通过对红色，绿色和蓝色通道进行轻微采样来获得颜色不匹配。 <br><br> 让我们从添加<code>_SplitRGB</code>属性开始，该属性指示<code>_SplitRGB</code>效果的强度： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Caustics UV fixed2 uv = IN.uv_MainTex * _Caustics_ST.xy + _Caustics_ST.zw; uv += _CausticsSpeed * _Time.y; // RGB split fixed s = _SplitRGB; fixed r = tex2D(tex, uv + fixed2(+s, +s)).r; fixed g = tex2D(tex, uv + fixed2(+s, -s)).g; fixed b = tex2D(tex, uv + fixed2(-s, -s)).b; fixed3 caustics = fixed3(r, g, b);</span></span></code> </pre> <br>  RGB通道的偏移量可以任意选择，但是即使使用这种简单的偏移量，也可以获得令人信服的图像： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a96/ccc/bd8/a96cccbd861252130d289d9362ef0ec0.gif"></div><br><h2> 结论和下载 </h2><br> 如果您有兴趣学习如何创建无缝的苛性纹理，那么应该阅读有趣的文章<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener noreferrer">周期性苛性纹理</a> 。 <br><br> 同时， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener noreferrer">Florian</a>继续致力于他的苛性着色器，并做出了一些非常有趣的改进，可以看出。 <br><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-1" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="1167866285369131008"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br>  Patreon上提供了本教程的完整软件包，其中包括重新创建此技术的所有必要资产。 该软件包是从Unity 2019.2导出的，并且需要Postprocessing Stack v2。 <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">标准资产</a> ：仅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">着色器</a>文件 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">付费资产</a> ：完整的场景，包括腐蚀性纹理和材料。 </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN467887/">https://habr.com/ru/post/zh-CN467887/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN467875/index.html">别害羞</a></li>
<li><a href="../zh-CN467877/index.html">适用于无线电工程师的Android（不仅限于此）</a></li>
<li><a href="../zh-CN467881/index.html">Tutu.ru后端聚会</a></li>
<li><a href="../zh-CN467883/index.html">Kubernetes 1.16-如何升级而不破坏任何内容</a></li>
<li><a href="../zh-CN467885/index.html">产品和分部地雷</a></li>
<li><a href="../zh-CN467891/index.html">关于云[电子]签名的常见问题</a></li>
<li><a href="../zh-CN467893/index.html">只是gRPC和protobuf的另一个Qt包装器</a></li>
<li><a href="../zh-CN467895/index.html">神经网络会找到什么模式？</a></li>
<li><a href="../zh-CN467897/index.html">自动测试工具，Yandex Mapkit 3集成，出色的设计和服务器驱动的UI方法-Android Mitap公告</a></li>
<li><a href="../zh-CN467901/index.html">驳斥关于Rust编程语言的四种刻板印象</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>