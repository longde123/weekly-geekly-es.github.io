<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÜî üíáüèæ üë©üèª Python menghabiskan banyak memori atau cara mengurangi ukuran objek? ‚ù£Ô∏è ü§±üèæ ‚úäüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Masalah memori dapat muncul ketika sejumlah besar objek aktif dalam RAM selama pelaksanaan program, terutama jika ada batasan jumlah total memori yang...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python menghabiskan banyak memori atau cara mengurangi ukuran objek?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458518/"><p>  Masalah memori dapat muncul ketika sejumlah besar objek aktif dalam RAM selama pelaksanaan program, terutama jika ada batasan jumlah total memori yang tersedia. </p><br><p>  Di bawah ini adalah ikhtisar dari beberapa metode untuk mengurangi ukuran objek, yang secara signifikan dapat mengurangi jumlah RAM yang diperlukan untuk program dalam Python murni. </p><br><p>  <strong>Catatan:</strong> <em>Ini adalah versi bahasa Inggris dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting</a> asli saya (dalam bahasa Rusia).</em> </p><a name="habracut"></a><br><p> Untuk mempermudah, kami akan mempertimbangkan struktur dalam Python untuk mewakili titik dengan koordinat <code>x</code> , <code>y</code> , <code>z</code> dengan akses ke nilai koordinat berdasarkan nama. </p><br><h3 id="dict">  Diktik </h3><br><p>  Dalam program kecil, terutama dalam skrip, cukup sederhana dan nyaman untuk menggunakan <code>dict</code> untuk mewakili informasi struktural: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; ob = {'x':1, 'y':2, 'z':3} &gt;&gt;&gt; x = ob['x'] &gt;&gt;&gt; ob['y'] = y</code> </pre> <br><p>  Dengan munculnya implementasi yang lebih ringkas di Python 3.6 dengan serangkaian kunci yang tertata, <code>dict</code> telah menjadi lebih menarik.  Namun, mari kita lihat ukuran jejaknya di RAM: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; print(sys.getsizeof(ob)) 240</code> </pre> <br><p>  Dibutuhkan banyak memori, terutama jika Anda tiba-tiba harus membuat banyak contoh: </p><br><div class="scrollable-table"><table><thead><tr><th>  Jumlah contoh </th><th>  Ukuran benda </th></tr></thead><tbody><tr><td>  1.000.000 </td><td>  240 Mb </td></tr><tr><td>  10.000.000 </td><td>  2,40 Gb </td></tr><tr><td>  100.000.000 </td><td>  24 gb </td></tr></tbody></table></div><br><h3 id="class-instance">  Contoh kelas </h3><br><p>  Bagi mereka yang suka berpakaian segala sesuatu di kelas, lebih baik untuk mendefinisikan struktur sebagai kelas dengan akses berdasarkan nama atribut: </p><br><pre> <code class="plaintext hljs">class Point: # def __init__(self, x, y, z): self.x = x self.y = y self.z = z &gt;&gt;&gt; ob = Point(1,2,3) &gt;&gt;&gt; x = ob.x &gt;&gt;&gt; ob.y = y</code> </pre> <br><p>  Struktur instance kelas menarik: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Bidang </th><th>  Ukuran (byte) </th></tr><tr><td>  PyGC_Head </td><td>  24 </td></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  __weakref__ </td><td>  8 </td></tr><tr><td>  __dict__ </td><td>  8 </td></tr><tr><td>  <b>TOTAL:</b> </td><td>  <b>56</b> </td></tr></tbody></table></div><br><p>  Di sini <code>__weakref__</code> adalah referensi ke daftar yang disebut referensi lemah ke objek ini, bidang <code>__dict__</code> adalah referensi ke kamus instance kelas, yang berisi nilai atribut instance (perhatikan bahwa platform referensi 64-bit menempati 8 byte).  Mulai dengan Python 3.3, ruang bersama digunakan untuk menyimpan kunci dalam kamus untuk semua instance kelas.  Ini mengurangi ukuran jejak instance dalam RAM: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; print(sys.getsizeof(ob), sys.getsizeof(ob.__dict__)) 56 112</code> </pre> <br><p>  Akibatnya, sejumlah besar instance kelas memiliki jejak yang lebih kecil dalam memori daripada kamus biasa ( <code>dict</code> ): </p><br><div class="scrollable-table"><table><thead><tr><th>  Jumlah contoh </th><th>  Ukuran </th></tr></thead><tbody><tr><td>  1.000.000 </td><td>  168 Mb </td></tr><tr><td>  10.000.000 </td><td>  1,68 Gb </td></tr><tr><td>  100.000.000 </td><td>  16,8 Gb </td></tr></tbody></table></div><br><p>  Sangat mudah untuk melihat bahwa ukuran instance dalam RAM masih besar karena ukuran kamus instance. </p><br><h3 id="instance-of-class-with--__slots__">  Instance kelas dengan __slots__ </h3><br><p>  Pengurangan yang signifikan dalam ukuran instance kelas dalam RAM dicapai dengan menghilangkan <code>__dict__</code> dan <code>__weakref__</code> .  Ini dimungkinkan dengan bantuan "trik" dengan <code>__slots__</code> : </p><br><pre> <code class="plaintext hljs">class Point: __slots__ = 'x', 'y', 'z' def __init__(self, x, y, z): self.x = x self.y = y self.z = z &gt;&gt;&gt; ob = Point(1,2,3) &gt;&gt;&gt; print(sys.getsizeof(ob)) 64</code> </pre> <br><p>  Ukuran objek dalam RAM menjadi lebih kecil secara signifikan: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Bidang </th><th>  Ukuran (byte) </th></tr><tr><td>  PyGC_Head </td><td>  24 </td></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  x </td><td>  8 </td></tr><tr><td>  y </td><td>  8 </td></tr><tr><td>  z </td><td>  8 </td></tr><tr><td>  <b>TOTAL:</b> </td><td>  <b>64</b> </td></tr></tbody></table></div><br><p>  Menggunakan <code>__slots__</code> dalam definisi kelas menyebabkan jejak sejumlah besar contoh dalam memori berkurang secara signifikan: </p><br><div class="scrollable-table"><table><thead><tr><th>  Jumlah contoh </th><th>  Ukuran </th></tr></thead><tbody><tr><td>  1.000.000 </td><td>  64 Mb </td></tr><tr><td>  10.000.000 </td><td>  640 Mb </td></tr><tr><td>  100.000.000 </td><td>  6,4 Gb </td></tr></tbody></table></div><br><p>  Saat ini, ini adalah metode utama untuk secara substansial mengurangi jejak memori dari instance kelas di RAM. </p><br><p>  Pengurangan ini dicapai oleh fakta bahwa dalam memori setelah judul objek, referensi objek disimpan - nilai atribut, dan akses ke mereka dilakukan menggunakan deskriptor khusus yang ada di kamus kelas: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; pprint(Point.__dict__) mappingproxy( .................................... 'x': &lt;member 'x' of 'Point' objects&gt;, 'y': &lt;member 'y' of 'Point' objects&gt;, 'z': &lt;member 'z' of 'Point' objects&gt;})</code> </pre> <br><p>  Untuk mengotomatiskan proses membuat kelas dengan <code>__slots__</code> , ada perpustakaan [daftar nama] ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://pypi.org/project/namedlist</a> ).  Fungsi <code>namedlist.namedlist</code> membuat kelas dengan <code>__slots__</code> : </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; Point = namedlist('Point', ('x', 'y', 'z'))</code> </pre> <br><p>  Paket lain [attrs] ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://pypi.org/project/attrs</a> ) memungkinkan Anda untuk mengotomatiskan proses membuat kelas baik dengan dan tanpa <code>__slots__</code> . </p><br><h3 id="tuple">  Tuple </h3><br><p>  Python juga memiliki <code>tuple</code> tipe <code>tuple</code> untuk mewakili struktur data yang tidak dapat diubah.  Sebuah tuple adalah struktur atau catatan tetap, tetapi tanpa nama bidang.  Untuk akses bidang, indeks bidang digunakan.  Bidang tuple adalah sekali dan untuk semua yang terkait dengan objek nilai pada saat membuat instance tuple: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; ob = (1,2,3) &gt;&gt;&gt; x = ob[0] &gt;&gt;&gt; ob[1] = y # ERROR</code> </pre> <br><p>  Contoh tuple cukup ringkas: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; print(sys.getsizeof(ob)) 72</code> </pre> <br><p>  Mereka menempati 8 byte dalam memori lebih dari instance kelas dengan <code>__slots__</code> , karena jejak tuple dalam memori juga berisi sejumlah bidang: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Bidang </th><th>  Ukuran (byte) </th></tr><tr><td>  PyGC_Head </td><td>  24 </td></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  ob_size </td><td>  8 </td></tr><tr><td>  [0] </td><td>  8 </td></tr><tr><td>  [1] </td><td>  8 </td></tr><tr><td>  [2] </td><td>  8 </td></tr><tr><td>  <b>TOTAL:</b> </td><td>  <b>72</b> </td></tr></tbody></table></div><br><h3 id="namedtuple">  Namedtuple </h3><br><p>  Karena tuple digunakan secara luas, suatu hari ada permintaan bahwa Anda masih dapat memiliki akses ke bidang dan nama juga.  Jawaban atas permintaan ini adalah module <code>collections.namedtuple</code> . </p><br><p>  Fungsi <code>namedtuple</code> dirancang untuk mengotomatiskan proses menghasilkan kelas-kelas tersebut: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; Point = namedtuple('Point', ('x', 'y', 'z'))</code> </pre> <br><p>  Itu menciptakan subkelas tuple, di mana deskriptor didefinisikan untuk mengakses bidang dengan nama.  Sebagai contoh kita, akan terlihat seperti ini: </p><br><pre> <code class="plaintext hljs"> class Point(tuple): # @property def _get_x(self): return self[0] @property def _get_y(self): return self[1] @property def _get_z(self): return self[2] # def __new__(cls, x, y, z): return tuple.__new__(cls, (x, y, z))</code> </pre> <br><p>  Semua instance dari kelas tersebut memiliki jejak memori yang identik dengan tuple.  Sejumlah besar contoh meninggalkan jejak memori yang sedikit lebih besar: </p><br><div class="scrollable-table"><table><thead><tr><th>  Jumlah contoh </th><th>  Ukuran </th></tr></thead><tbody><tr><td>  1.000.000 </td><td>  72 Mb </td></tr><tr><td>  10.000.000 </td><td>  720 Mb </td></tr><tr><td>  100.000.000 </td><td>  7.2 Gb </td></tr></tbody></table></div><br><h3 id="recordclass-mutable-namedtuple-without-cyclic-gc">  Recordclass: dapat dinamai namesuple tanpa siklik GC </h3><br><p>  Karena <code>tuple</code> dan, dengan demikian, <code>namedtuple</code> -classes menghasilkan objek yang tidak dapat diubah dalam arti bahwa atribut <code>ob.x</code> tidak lagi dapat dikaitkan dengan objek nilai lain, permintaan untuk varian nametuple yang dapat berubah telah muncul.  Karena tidak ada tipe bawaan pada Python yang identik dengan tuple yang mendukung penugasan, banyak opsi telah dibuat.  Kami akan fokus pada [recordclass] ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://pypi.org/project/recordclass</a> ), yang menerima peringkat [stackoverflow] ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://stackoverflow.com/questions/29290359/existence-of-mutable-named- tuple-in</a> -python / 29419745).  Selain itu dapat digunakan untuk mengurangi ukuran objek dalam RAM dibandingkan dengan ukuran objek seperti <code>tuple</code> .. </p><br><p>  Paket <strong>recordclass</strong> memperkenalkan tipe <code>recordclass.mutabletuple</code> , yang hampir identik dengan tuple, tetapi juga mendukung penugasan.  Pada dasarnya, subclass dibuat yang hampir sepenuhnya identik dengan namedtuple, tetapi juga mendukung penugasan nilai baru ke bidang (tanpa membuat instance baru).  Fungsi <code>recordclass</code> , seperti fungsi <code>namedtuple</code> , memungkinkan Anda untuk mengotomatisasi pembuatan kelas-kelas ini: </p><br><pre> <code class="plaintext hljs"> &gt;&gt;&gt; Point = recordclass('Point', ('x', 'y', 'z')) &gt;&gt;&gt; ob = Point(1, 2, 3)</code> </pre> <br><p>  Instance kelas memiliki struktur yang sama dengan <code>tuple</code> , tetapi hanya tanpa <code>PyGC_Head</code> : </p><br><div class="scrollable-table"><table><tbody><tr><th>  Bidang </th><th>  Ukuran (byte) </th></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  ob_size </td><td>  8 </td></tr><tr><td>  x </td><td>  8 </td></tr><tr><td>  y </td><td>  8 </td></tr><tr><td>  y </td><td>  8 </td></tr><tr><td>  <b>TOTAL:</b> </td><td>  <b>48</b> </td></tr></tbody></table></div><br><p>  Secara default, fungsi <code>recordclass</code> membuat kelas yang tidak berpartisipasi dalam mekanisme pengumpulan sampah siklik.  Biasanya, <code>namedtuple</code> dan <code>recordclass</code> digunakan untuk menghasilkan kelas yang mewakili catatan atau struktur data sederhana (non-rekursif).  Menggunakannya dengan benar di Python tidak menghasilkan referensi melingkar.  Untuk alasan ini, setelah instance kelas yang dihasilkan oleh <code>recordclass</code> , secara <code>default, the</code> <code>fragment is excluded, which is necessary for classes supporting the cyclic garbage collection mechanism (more precisely: in the</code> PyGC_Head <code>fragment is excluded, which is necessary for classes supporting the cyclic garbage collection mechanism (more precisely: in the</code> <code>structure, corresponding to the created class, in the</code> PyTypeObject <code>structure, corresponding to the created class, in the</code> <code>field, by default, the flag</code> flag <code>field, by default, the flag</code> Py_TPFLAGS_HAVE_GC` tidak disetel). </p><br><p>  Ukuran jejak memori dari sejumlah besar instance lebih kecil dari instance kelas dengan <code>__slots__</code> : </p><br><div class="scrollable-table"><table><thead><tr><th>  Jumlah contoh </th><th>  Ukuran </th></tr></thead><tbody><tr><td>  1.000.000 </td><td>  48 Mb </td></tr><tr><td>  10.000.000 </td><td>  480 Mb </td></tr><tr><td>  100.000.000 </td><td>  4,8 Gb </td></tr></tbody></table></div><br><h3 id="dataobject">  Objek data </h3><br><p>  Solusi lain yang diusulkan dalam perpustakaan recordclass didasarkan pada ide: gunakan struktur penyimpanan yang sama dalam memori seperti dalam instance kelas dengan <code>__slots__</code> , tetapi jangan berpartisipasi dalam mekanisme pengumpulan sampah siklik.  Kelas-kelas tersebut dihasilkan menggunakan fungsi <code>recordclass.make_dataclass</code> : </p><br><pre> <code class="plaintext hljs"> &gt;&gt;&gt; Point = make_dataclass('Point', ('x', 'y', 'z'))</code> </pre> <br><p>  Kelas yang dibuat dengan cara ini, secara default, membuat instance yang bisa berubah. </p><br><p>  Cara lain - gunakan deklarasi kelas dengan pewarisan dari <code>recordclass.dataobject</code> : </p><br><pre> <code class="plaintext hljs">class Point(dataobject): x:int y:int z:int</code> </pre> <br><p>  Kelas yang dibuat dengan cara ini akan membuat instance yang tidak berpartisipasi dalam mekanisme pengumpulan sampah siklik.  Struktur instance dalam memori sama dengan dalam kasus dengan <code>__slots__</code> , tetapi tanpa <code>PyGC_Head</code> : </p><br><div class="scrollable-table"><table><tbody><tr><th>  Bidang </th><th>  Ukuran (byte) </th></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  x </td><td>  8 </td></tr><tr><td>  y </td><td>  8 </td></tr><tr><td>  y </td><td>  8 </td></tr><tr><td>  <b>TOTAL:</b> </td><td>  <b>40</b> </td></tr></tbody></table></div><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; ob = Point(1,2,3) &gt;&gt;&gt; print(sys.getsizeof(ob)) 40</code> </pre> <br><p>  Untuk mengakses bidang, deskriptor khusus juga digunakan untuk mengakses bidang dengan offsetnya dari awal objek, yang terletak di kamus kelas: </p><br><pre> <code class="plaintext hljs">mappingproxy({'__new__': &lt;staticmethod at 0x7f203c4e6be0&gt;, ....................................... 'x': &lt;recordclass.dataobject.dataslotgetset at 0x7f203c55c690&gt;, 'y': &lt;recordclass.dataobject.dataslotgetset at 0x7f203c55c670&gt;, 'z': &lt;recordclass.dataobject.dataslotgetset at 0x7f203c55c410&gt;})</code> </pre> <br><p>  Sizeo dari jejak memori sejumlah besar contoh adalah minimum yang mungkin untuk CPython: </p><br><div class="scrollable-table"><table><thead><tr><th>  Jumlah contoh </th><th>  Ukuran </th></tr></thead><tbody><tr><td>  1.000.000 </td><td>  40 Mb </td></tr><tr><td>  10.000.000 </td><td>  400 Mb </td></tr><tr><td>  100.000.000 </td><td>  4,0 Gb </td></tr></tbody></table></div><br><h3 id="cython">  Cython </h3><br><p>  Ada satu pendekatan berdasarkan penggunaan [Cython] ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://cython.org</a> ).  Keuntungannya adalah bahwa bidang dapat mengambil nilai dari tipe atom bahasa C.  Penjelas untuk mengakses bidang dari Python murni dibuat secara otomatis.  Sebagai contoh: </p><br><pre> <code class="plaintext hljs">cdef class Python: cdef public int x, y, z def __init__(self, x, y, z): self.x = x self.y = y self.z = z</code> </pre> <br><p>  Dalam hal ini, instans memiliki ukuran memori yang lebih kecil: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; ob = Point(1,2,3) &gt;&gt;&gt; print(sys.getsizeof(ob)) 32</code> </pre> <br><p>  Jejak instance dalam memori memiliki struktur berikut: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Bidang </th><th>  Ukuran (byte) </th></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  x </td><td>  4 </td></tr><tr><td>  y </td><td>  4 </td></tr><tr><td>  y </td><td>  4 </td></tr><tr><td>  kosong </td><td>  4 </td></tr><tr><td>  <b>TOTAL:</b> </td><td>  <b>32</b> </td></tr></tbody></table></div><br><p>  Ukuran jejak sejumlah besar salinan kurang: </p><br><div class="scrollable-table"><table><thead><tr><th>  Nomor </th><th>  Ukuran </th></tr></thead><tbody><tr><td>  1.000.000 </td><td>  32 Mb </td></tr><tr><td>  10.000.000 </td><td>  320 Mb </td></tr><tr><td>  100.000.000 </td><td>  3,2 Gb </td></tr></tbody></table></div><br><p>  Namun, harus diingat bahwa ketika mengakses dari kode Python, konversi dari <code>int</code> ke objek Python dan sebaliknya akan dilakukan setiap waktu. </p><br><h3 id="numpy">  Numpy </h3><br><p>  Menggunakan array multidimensi atau array rekaman untuk sejumlah besar data memberikan keuntungan dalam memori.  Namun, untuk pemrosesan efisien dalam Python murni, Anda harus menggunakan metode pemrosesan yang fokus pada penggunaan fungsi dari paket <code>numpy</code> . </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; Point = numpy.dtype(('x', numpy.int32), ('y', numpy.int32), ('z', numpy.int32)])</code> </pre> <br><p>  Array elemen <code>N</code> , diinisialisasi dengan nol, dibuat menggunakan fungsi: </p><br><pre> <code class="plaintext hljs"> &gt;&gt;&gt; points = numpy.zeros(N, dtype=Point)</code> </pre> <br><p>  Ukuran array dalam memori seminimal mungkin: </p><br><div class="scrollable-table"><table><thead><tr><th>  Jumlah objek </th><th>  Ukuran </th></tr></thead><tbody><tr><td>  1.000.000 </td><td>  12 Mb </td></tr><tr><td>  10.000.000 </td><td>  120 Mb </td></tr><tr><td>  100.000.000 </td><td>  1,20 Gb </td></tr></tbody></table></div><br><p>  Akses normal ke elemen dan baris array akan memerlukan konversi dari objek Python ke nilai C <code>int</code> dan sebaliknya.  Mengekstraksi satu baris menghasilkan penciptaan array yang mengandung elemen tunggal.  Jejaknya tidak akan begitu kompak lagi: </p><br><pre> <code class="plaintext hljs"> &gt;&gt;&gt; sys.getsizeof(points[0]) 68</code> </pre> <br><p>  Oleh karena itu, seperti disebutkan di atas, dalam kode Python, perlu untuk memproses array menggunakan fungsi dari paket <code>numpy</code> . </p><br><h3 id="conclusion">  Kesimpulan </h3><br><p>  Pada contoh yang jelas dan sederhana, dimungkinkan untuk memverifikasi bahwa komunitas pengembang dan pengguna bahasa pemrograman Python (CPython) memiliki kemungkinan nyata untuk pengurangan signifikan dalam jumlah memori yang digunakan oleh objek. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id458518/">https://habr.com/ru/post/id458518/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id458504/index.html">Trik 13 npm untuk menghemat waktu</a></li>
<li><a href="../id458506/index.html">Bukan Portal 3, tapi tutup: teleportasi kuantum informasi di dalam berlian</a></li>
<li><a href="../id458508/index.html">Pandangan dari dalam: sekolah pascasarjana di EPFL. Bagian 4.2: sisi keuangan</a></li>
<li><a href="../id458514/index.html">Pelanggaran GDPR dihukum lebih aktif - denda baru dan dampak peraturan di luar UE</a></li>
<li><a href="../id458516/index.html">Dapatkan worklog dari Jira</a></li>
<li><a href="../id458520/index.html">Buku "Kode kinerja tinggi pada platform .NET. Edisi ke-2</a></li>
<li><a href="../id458524/index.html">Kata cloud VC di atas lutut</a></li>
<li><a href="../id458530/index.html">Zabbix, seri waktu dan TimescaleDB</a></li>
<li><a href="../id458532/index.html">Pelopor teknologi baru: Vadim Artsev memberi tahu bagaimana ia tidak lagi buta</a></li>
<li><a href="../id458536/index.html">Python + Pyside2 atau cukup "Kalkulator"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>