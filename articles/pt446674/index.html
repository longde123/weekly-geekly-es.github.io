<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñïüèæ ü§∞üèæ üåº Modelamos o algoritmo MUSIC para determinar a dire√ß√£o de chegada de uma onda eletromagn√©tica üè• üë∞üèª üë®üèº‚Äçüç≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pref√°cio 


 Come√ßarei minha introdu√ß√£o de longe. Era uma vez, no distante 2016-2017, seu humilde servo conseguiu fazer um curso de treinamento de sei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Modelamos o algoritmo MUSIC para determinar a dire√ß√£o de chegada de uma onda eletromagn√©tica</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446674/"><p><img src="https://media.moddb.com/cache/images/groups/1/3/2392/thumb_620x2000/music-cats.jpg" alt="aaspcats"></p><br><h2 id="predislovie">  Pref√°cio </h2><br><p>  Come√ßarei minha introdu√ß√£o de longe.  Era uma vez, no distante 2016-2017, seu humilde servo conseguiu fazer um curso de treinamento de seis meses na cidade distante de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Ilmenau</a> (Alemanha), onde completou com sucesso (em geral) o programa de mestrado <strong>Comunica√ß√µes e processamento de sinais</strong> .  O programa n√£o foi f√°cil, mas agora √© agrad√°vel record√°-lo.  As vezes ... </p><a name="habracut"></a><br><p>  Portanto, ao final deste treinamento, al√©m do diploma, eu ainda tinha alguns materiais diferentes em m√£os, que eu achava errado n√£o compartilhar. </p><br><p>  Um desses materiais est√° na sua frente. </p><br><p>  <strong>Quais objetivos eu persegui enquanto preparava o semin√°rio</strong> : </p><br><ol><li>  falar sobre algumas abordagens j√° "inteligentes" j√° estabelecidas no t√≥pico dos arranjos de antenas mais acess√≠veis e faz√™-lo em russo; </li><li>  realize uma pequena simula√ß√£o no <strong><em>Python 3</em></strong> para agitar colegas engenheiros de r√°dio para examinar mais de perto as linguagens de programa√ß√£o (se voc√™ ainda n√£o o olhou de perto); </li><li>  forne√ßa links para boa literatura em ingl√™s - sem ler fontes estrangeiras, agora, infelizmente, em lugar nenhum. </li></ol><br><p>  <strong>O que considerar</strong> : </p><br><ul><li>  O m√©todo MUSIC (MUltiple SIgnal Classification) - isso, de fato, refere-se √† visualiza√ß√£o. </li></ul><br><blockquote>  Um exemplo de forma√ß√£o de gr√°fico e o m√©todo MVDR pode ser encontrado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">aqui</a> (se houver perguntas ou sugest√µes para material adicional, a discuss√£o poder√° ser continuada no Github.Gist). </blockquote><p>  Como eu disse acima, usaremos Python, a saber: </p><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt</code> </pre> <br><p>  Por que n√£o o MATLAB, um dos candidatos mais populares e convenientes para modelagem de √°lgebra linear, voc√™ pergunta?  Porque, quero mostrar que trabalho semelhante pode ser feito em Python, e o escopo do Python √© muito mais amplo que o do MATLAB.  Portanto, estar familiarizado com a sintaxe do Python √© uma coisa √∫til, na minha opini√£o. </p><br><p>  Vamos come√ßar! </p><br><blockquote>  As f√≥rmulas s√£o preparadas atrav√©s de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">https://upmath.me/</a> .  Obrigado aos criadores por uma √≥tima ferramenta! </blockquote><br><h2 id="postanovka-zadachi">  Declara√ß√£o do problema </h2><br><p>  Suponha que exista um conjunto de antenas lineares consistindo em v√°rios elementos espa√ßados um do outro <img src="https://tex.s2cms.ru/svg/%5CDelta%20%3D%20%5Cfrac%7B%5Clambda%7D%7B2%7D" alt="\ Delta = \ frac {\ lambda} {2}">  (passo do conjunto de antenas), onde <img src="https://tex.s2cms.ru/svg/%5Clambda" alt="\ lambda">  - o comprimento da onda eletromagn√©tica portadora (EM). </p><br><p>  Ondas eletromagn√©ticas caem nesse conjunto de antenas de diferentes dire√ß√µes. </p><br><p><img src="https://habrastorage.org/webt/mk/3w/zz/mk3wzzmb4bonpno72euep64v0ao.png"></p><br><blockquote>  Fig.  1. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Sistema de antena adapt√°vel.</a> </blockquote><p>  Como pode ser visto na figura, o conjunto de antenas √© considerado como um filtro adapt√°vel. </p><br><p>  Na verdade, encontrar o vetor ideal de coeficientes ( <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7Bw%7D_%7Bopt%7D" alt="\ mathbf {w} _ {opt}">  ) √© a principal tarefa dos arranjos de antenas adapt√°veis ‚Äã‚Äãdo ponto de vista matem√°tico. </p><br><p>  Inicialmente, n√£o sabemos de quais dire√ß√µes espec√≠ficas est√£o vindo os sinais e quantas delas.  Para resolver essa contradi√ß√£o, usaremos o algoritmo MUSIC, um algoritmo para estimar frequ√™ncias espaciais com alta resolu√ß√£o. </p><br><h2 id="modelirovanie-prinyatogo-signala">  Simula√ß√£o de sinal recebido </h2><br><p>  Podemos apresentar o modelo do sinal recebido atrav√©s da f√≥rmula: </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cmathbf%7BX%7D%20%3D%20%5Cmathbf%7BA%7D%20%5Cmathbf%7BS%7D%20%2B%20%5Cmathbf%7BN%7D%20" alt="\ mathbf {X} = \ mathbf {A} \ mathbf {S} + \ mathbf {N}"></div><p></p><br><p>  onde <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BA%7D%20%3D%20%5B%5Cmathbf%7Ba%7D(%5Ctheta_1)%20%5Cquad%20%5Cmathbf%7Ba%7D(%5Ctheta_2)%20%5Cquad%20...%20%5Cquad%20%5Cmathbf%7Ba%7D(%5Ctheta_d)%5D" alt="\ mathbf {A} = [\ mathbf {a} (\ theta_1) \ quad \ mathbf {a} (\ theta_2) \ quad ... \ quad \ mathbf {a} (\ theta_d)]">  - matriz de vetores de varredura (vetores de dire√ß√£o) do conjunto de antenas ( <img src="https://tex.s2cms.ru/svg/%20a_i%20%3D%20%5Cexp(-j%20%5Cmu%20m_i)" alt="a_i = \ exp (-j \ mu m_i)">  , <img src="https://tex.s2cms.ru/svg/m%20%3D%200%2C%201%20...%20(M-1)" alt="m = 0, 1 ... (M-1)">  , <img src="https://tex.s2cms.ru/svg/M" alt="M">  - o n√∫mero de elementos do conjunto de antenas, <img src="https://tex.s2cms.ru/svg/d" alt="d">  - o n√∫mero de fontes de ondas EM, <img src="https://tex.s2cms.ru/svg/%5Ctheta" alt="\ theta">  - √¢ngulo da dire√ß√£o de chegada da onda EM), <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BS%7D" alt="\ mathbf {S}">  - matriz de caracteres transmitidos, e <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BN%7D" alt="\ mathbf {N}">  - matriz de ru√≠do aditivo. </p><br><img src="https://raw.githubusercontent.com/kirlf/CSP/master/Different/assets/ULA.png" alt="ULA" width="600"><br><blockquote>  Fig.  2. Conjunto de antenas lineares omnidirecionais (ULAA - conjunto de anntenna linear uniforme) [1, p.  32] </blockquote><p>  Vamos repensar essa f√≥rmula da maneira "cotidiana": em nossa grade, temos uma "bagun√ßa" de v√°rios sinais, que denotamos por <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BX%7D" alt="\ mathbf {X}">  .  N√≥s n√£o recebemos explicitamente informa√ß√µes sobre o n√∫mero de fontes e dire√ß√µes; no entanto, informa√ß√µes sobre isso ainda est√£o contidas no sinal recebido. </p><br><p>  Estamos come√ßando a pesquisar! </p><br><p>  Para fazer isso, eles geralmente procedem √†s manipula√ß√µes n√£o com as matrizes de amplitudes complexas de sinal, mas com suas covari√¢ncias (isto √©, em ess√™ncia, com poderes): </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cmathbf%7BR%7D_%7Bxx%7D%20%3D%20%5Cmathbf%7BX%7D%5Cmathbf%7BX%7D%5EH%20%3D%20%20%5Cmathbf%7BA%7D%20%5Cmathbf%7BR%7D_%7Bss%7D%20%5Cmathbf%7BA%7D%5EH%20%2B%20%5Cmathbf%7BR%7D_%7Bnn%7D%20" alt="\ mathbf {R} _ {xx} = \ mathbf {X} \ mathbf {X} ^ H = \ mathbf {A} \ mathbf {R} _ {ss} \ mathbf {A} ^ H + \ mathbf {R} _ {nn}"></div><p></p><br><h2 id="usloviya">  Condi√ß√µes </h2><br><p>  Introduzimos uma condi√ß√£o importante a ser considerada: o limite de resolu√ß√£o do √¢ngulo Rayleigh: </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/sin%20(%5Ctheta_R)%20%3D%20%5Cfrac%7B%5Clambda%7D%7BD%7D" alt="sin (\ theta_R) = \ frac {\ lambda} {D}"></div><p></p><br><p>  onde <img src="https://tex.s2cms.ru/svg/D%20%3D%20M%20%5CDelta" alt="D = M \ Delta">  √â o comprimento da rede linear. </p><br><p>  Redefinimos o √¢ngulo de chegada de uma onda eletromagn√©tica atrav√©s do conceito de frequ√™ncia espacial: </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cmu_R%20%3D%20%5Cfrac%7B2%20%5Cpi%7D%7B%5Clambda%7D%5CDelta%20sin(%5Ctheta_R)%20%3D%20%5Cfrac%7B2%20%5Cpi%7D%7B%5Clambda%7D%5CDelta%20%5Cfrac%7B%5Clambda%7D%7B%5CDelta%20M%7D%20%3D%20%5Cfrac%7B2%20%5Cpi%7D%7BM%7D" alt="\ mu_R = \ frac {2 \ pi} {\ lambda} \ Delta sin (\ theta_R) = \ frac {2 \ pi} {\ lambda} \ Delta \ frac {\ lambda} {\ Delta M} = \ frac { 2 \ pi} {M}"></div><p></p><br><p>  onde <img src="https://tex.s2cms.ru/svg/%5Cmu_R" alt="\ mu_R">  - existe uma largura padr√£o do l√≥bulo principal do feixe ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">largura de</a> feixe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">padr√£o</a> ). </p><br><p>  Para verificar a efic√°cia do nosso m√©todo e sob quais condi√ß√µes, apresentamos alguns valores para a separa√ß√£o angular: </p><br><ol><li><p><img src="https://tex.s2cms.ru/svg/%5Cmu_1%20%3D%20-%20%5Cmu_R%2C%20%5Cquad%20%5Cmu_2%20%3D%200%2C%20%5Cquad%20%5Cmu_3%20%3D%20%20%5Cmu_R%20%5Cquad%20" alt="\ mu_1 = - \ mu_R, \ quad \ mu_2 = 0, \ quad \ mu_3 = \ mu_R \ quad">  - divis√£o em uma largura de feixe; </p><br></li><li><p><img src="https://tex.s2cms.ru/svg/%5Cmu_1%20%3D%20-0.5%20%5Cmu_R%2C%20%5Cquad%20%5Cmu_2%20%3D%200%2C%20%5Cquad%20%5Cmu_3%20%3D%200.5%20%5Cmu_R%20%5Cquad%20" alt="\ mu_1 = -0,5 \ mu_R, \ quad \ mu_2 = 0, \ quad \ mu_3 = 0,5 \ mu_R \ quad">  - divis√£o na largura de um segundo feixe; </p><br></li><li><p><img src="https://tex.s2cms.ru/svg/%5Cmu_1%20%3D%20-0.3%20%5Cmu_R%2C%20%5Cquad%20%5Cmu_2%20%3D%200%2C%20%5Cquad%20%5Cmu_3%20%3D%200.3%20%5Cmu_R%20%5Cquad%20" alt="\ mu_1 = -0,3 \ mu_R, \ quad \ mu_2 = 0, \ quad \ mu_3 = 0,3 \ mu_R \ quad">  - divis√£o em tr√™s d√©cimos da largura do feixe. </p><br></li></ol><br><p>  Defina os par√¢metros de entrada: </p><br><pre> <code class="python hljs">M = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-comment"><span class="hljs-comment">#    () SNR = 10 #  - (dB) d = 3 #     N = 50 #  "" (snapshots) S = ( np.sign(np.random.randn(d,N)) + 1j * np.sign(np.random.randn(d,N)) ) / np.sqrt(2) # QPSK W = ( np.random.randn(M,N) + 1j * np.random.randn(M,N) ) / np.sqrt(2) * 10**(-SNR/20) # AWGN #  : # sqrt(N0/2)*(G1 + jG2), #  G1  G2 -   . # .. Es( )  QPSK  1 ,    (noise spectral density): # N0 = (Es/N)^(-1) = SNR^(-1) [] (   ,  SNR = Es/N0); #    : # SNR_dB = 10log10(SNR) =&gt; N0_dB = -10log10(SNR) = -SNR_dB []; #    SNR    (..  ),   : # SNR = 10^(SNR_dB/10) =&gt; sqrt(N0) = (10^(-SNR_dB/10))^(1/2) = 10^(-SNR_dB/20) mu_R = 2*np.pi / M</span></span></code> </pre> <br><h2 id="nemnogo-teorii-o-samom-metode">  Um pouco de teoria sobre o pr√≥prio m√©todo </h2><br><p>  Primeiramente, notamos que o progenitor do m√©todo MUSIC √© o m√©todo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Pisarenko</a> (1973).  O problema considerado do m√©todo Pisarenko foi estimar as frequ√™ncias da soma de exponenciais complexas no ru√≠do branco.  V.F. Pisarenko demonstrou que frequ√™ncias podem ser encontradas a partir de vetores pr√≥prios correspondentes ao valor pr√≥prio m√≠nimo da matriz de autocorrela√ß√£o.  Posteriormente, esse m√©todo se tornou um caso especial do m√©todo MUSIC.  [2, p.  459] </p><br><p>  Schmidt e seus colegas propuseram o algoritmo de classifica√ß√£o de sinais m√∫ltiplos (MUSIC) em 1979 [4].  A principal abordagem desse algoritmo √© decompor a matriz de covari√¢ncia do sinal recebido em autovalores.  Como esse algoritmo leva em considera√ß√£o o ru√≠do n√£o correlacionado, a matriz de covari√¢ncia gerada tem uma forma diagonal.  Aqui, os subespa√ßos de sinal e ru√≠do s√£o calculados usando √°lgebra linear e s√£o ortogonais entre si.  Portanto, o algoritmo usa a propriedade de ortogonalidade para extrair os subespa√ßos de sinal e ru√≠do [5]. </p><br><p>  O algoritmo MUSIC generalizado pode ser definido da seguinte maneira: </p><br><ul><li>  Encontre a matriz de covari√¢ncia <img src="https://tex.s2cms.ru/svg/%20%5Cmathbf%7BR%7D_%7Bxx%7D%20" alt="\ mathbf {R} _ {xx}"></li><li>  Encontre autovetores via <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">EVD</a> ou outro algoritmo num√©rico adequado: </li></ul><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cmathbf%7BR%7D_%7Bxx%7D%20%3D%20%5Cmathbf%7BU%7D%5Cmathbf%7B%5CLambda%7D%5Cmathbf%7BU%7D%5EH%20%5Cqquad(1)" alt="\ mathbf {R} _ {xx} = \ mathbf {U} \ mathbf {\ Lambda} \ mathbf {U} ^ H \ qquad (1)"></div><p></p><br><ul><li>  Encontre o pseudo-espectro (por que com o prefixo pseudo, discutiremos abaixo) M√öSICA atrav√©s da seguinte f√≥rmula: </li></ul><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20P_%7BMU%7D(e%5E%7Bj%5Comega%7D)%20%3D%20%5Cfrac%7B1%7D%7B%5Csum%20%5Climits_%7Bi%3Dd%2B1%7D%5E%7BM%7D%7C%5Cmathbf%7Ba%7D%5EH%5Cmathbf%7Bu%7D_i%7C%5E2%7D%20%5Cqquad(2)%20" alt="P_ {MU} (e ^ {j \ omega}) = \ frac {1} {\ sum \ limits_ {i = d + 1} ^ {M} | \ mathbf {a} ^ H \ mathbf {u} _i | ^ 2} \ qquad (2)"></div><p></p><br><p>  onde <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7Ba%7D%20%3D%20%5Cbegin%7Bbmatrix%7D%20%20e%5E%7Bj0%5Comega%7D%20%26%20e%5E%7Bj1%5Comega%7D%20%26%20e%5E%7Bj2%5Comega%7D%20%26%20...%20%26%20e%5E%7Bj(M-1)%5Comega%7D%20%5Cend%7Bbmatrix%7D%5ET" alt="\ mathbf {a} = \ begin {bmatrix} e ^ {j0 \ omega} &amp; e ^ {j1 \ omega} &amp; e ^ {j2 \ omega} &amp; ... &amp; e ^ {j (M-1) \ omega } \ end {bmatrix} ^ T">  √â o vetor de exponenciais para a frequ√™ncia œâ situada em um determinado intervalo, e <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7Bu%7D_i" alt="\ mathbf {u} _i">  - o i-√©simo vetor pr√≥prio (vetor eigen) da matriz de covari√¢ncia (1) correspondente ao subespa√ßo de ru√≠do da matriz (1) - da√≠ a indexa√ß√£o com <img src="https://tex.s2cms.ru/svg/d%2B1" alt="d + 1">  ( <img src="https://tex.s2cms.ru/svg/d" alt="d">  √â a classifica√ß√£o da matriz (1)). </p><br><blockquote>  Para maior clareza, tente executar o script MATLAB apropriado fornecido por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">refer√™ncia</a> .  Preste aten√ß√£o a dois pontos principais: <br><ul><li>  em vez de calcular o quadrado da segunda norma no denominador (2), os autores aplicam o algoritmo FFT aos autovetores, o que facilita a modelagem usando fun√ß√µes internas e, em geral, n√£o contradiz a teoria do ponto de vista matem√°tico; </li><li>  a matriz de covari√¢ncia √© calculada atrav√©s de matrizes convolucionais; uma abordagem diferente foi mostrada acima para estimar frequ√™ncias espaciais. </li></ul><br></blockquote><p>  Como voc√™ pode imaginar pelo nome, MUSIC tamb√©m √© um m√©todo cl√°ssico para estimar a dire√ß√£o da recep√ß√£o em alta resolu√ß√£o.  O algoritmo para calcular pseudo-espectros neste contexto √© dado abaixo: </p><br><ul><li><p>  encontramos a matriz de covari√¢ncia do sinal recebido; </p><br></li><li><p>  encontre o subespa√ßo zero <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BU%7D_0" alt="\ mathbf {U} _0">  : </p><br></li></ul><br><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cmathbf%7BU%7D%20%3D%20%5B%5Cmathbf%7BU%7D_s%20%5Cquad%20%5Cmathbf%7BU%7D_0%5D%20" alt="\ mathbf {U} = [\ mathbf {U} _s \ quad \ mathbf {U} _0]"></div><p></p><br><ul><li>  selecione algum intervalo de pesquisa: </li></ul><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20a(%5Cmu)%20%3D%20%5Cbegin%7Bbmatrix%7D%20e%5E%7Bj0%5Cmu_1%7D%20%26%20...%20%26%20e%5E%7Bj0%5Cmu_Q%7D%20%5C%5C%20...%20%26...%26...%20%5C%5C%20e%5E%7Bj(M-1)%5Cmu_1%7D%20%26%20...%20%26%20e%5E%7Bj(M-1)%5Cmu_Q%7D%20%5Cend%7Bbmatrix%7D%20" alt="a (\ mu) = \ begin {bmatrix} e ^ {j0 \ mu_1} &amp; ... &amp; e ^ {j0 \ mu_Q} \\ ... &amp; ... &amp; ... \\ e ^ {j ( M-1) \ mu_1} &amp; ... &amp; e ^ {j (M-1) \ mu_Q} \ end {bmatrix}"></div><p></p><br><p>  onde <img src="https://tex.s2cms.ru/svg/%5Cmu%20%3D%20-%5Cfrac%7B2%5Cpi%20f_c%7D%7Bc%7D%5CDelta%20sin%5Ctheta%20%3D%20-%5Cfrac%7B2%5Cpi%20%7D%7B%5Clambda%20%7D%5CDelta%20sin%5Ctheta" alt="\ mu = - \ frac {2 \ pi f_c} {c} \ Delta sin \ theta = - \ frac {2 \ pi} {\ lambda} \ Delta sin \ theta"></p><br><ul><li>  calcule o pseudo-espectro: </li></ul><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20P_%7BMU%7D(%5Ctheta)%3D%5Cfrac%7B%5Cmathbf%7Ba%7D%5EH%20(%5Ctheta)%5Cmathbf%7Ba%7D(%5Ctheta)%7D%7B%5Cmathbf%7Ba%7D%5EH(%5Ctheta)%5Cmathbf%7BU%7D_0%20%5Cmathbf%7BU%7D_0%5EH%20%5Cmathbf%7Ba%7D(%5Ctheta)%7D%20" alt="P_ {MU} (\ theta) = \ frac {\ mathbf {a} ^ H (\ theta) \ mathbf {a} (\ theta)} {\ mathbf {a} ^ H (\ theta) \ mathbf {U} _0 \ mathbf {U} _0 ^ H \ mathbf {a} (\ theta)}"></div><p></p><br><p>  A rela√ß√£o entre an√°lise espectral e an√°lise dos √¢ngulos de chegada (DoA - dire√ß√£o do arriaval) das ondas EM √© descrita na tabela 1. </p><br><p>  Tabela 1 <strong>Comunica√ß√£o entre aplicativos MUSIC</strong> : Processamento da matriz de sinais e busca harm√¥nica [6]. </p><br><div class="scrollable-table"><table><thead><tr><th>  Vari√°vel </th><th>  Processamento de matriz de sinal </th><th>  Pesquisa harm√¥nica </th></tr></thead><tbody><tr><td><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/M" alt="M"></div></td><td>  N√∫mero de sensores </td><td>  O n√∫mero de per√≠odos </td></tr><tr><td><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/N" alt="N"></div></td><td>  O n√∫mero de per√≠odos </td><td>  N√∫mero de experi√™ncias </td></tr><tr><td><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/d" alt="d"></div></td><td>  N√∫mero de frentes de onda </td><td>  O n√∫mero de componentes complexos </td></tr><tr><td><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%5Cmu" alt="\ mu"></div></td><td>  Frequ√™ncias espaciais </td><td>  Frequ√™ncias normalizadas </td></tr></tbody></table></div><br><p>  Em geral, o processo de recebimento atrav√©s de matrizes (grades) pode ser comparado com o processo de discretiza√ß√£o cl√°ssica, porque  de fato, cada sensor, recebendo uma onda com um certo atraso de fase (isto √©, com um certo atraso de tempo), executa as fun√ß√µes de um pulso delta de amostragem.  O n√∫mero de realiza√ß√µes (experimentos) da an√°lise espectral cl√°ssica corresponder√° ao n√∫mero de segmentos de tempo (instant√¢neos).  Cada fonte ter√° sua pr√≥pria frente de onda, que √© equivalente ao n√∫mero de sinus√≥ides √∫nicos do sinal no caso de an√°lise espectral. </p><br><p>  E agora, de volta ao momento de calcular os autovetores.  J√° mencionamos acima que vetores <img src="https://tex.s2cms.ru/svg/a(%5Ctheta_i)%5Cepsilon%20A" alt="a (\ theta_i) \ epsilon A">  onde <img src="https://tex.s2cms.ru/svg/i%3D1%2C2%2C..%2Cd" alt="i = 1,2, .., d">  s√£o ortogonais ao subespa√ßo de ru√≠do da matriz de covari√¢ncia, ou seja: </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20a(%5Ctheta_i)%5ETU_0%3D0%5ET%20" alt="a (\ theta_i) ^ TU_0 = 0 ^ T"></div><p></p><br><p>  Na verdade, vemos um sistema de equa√ß√µes, resolvendo o que podemos encontrar as ra√≠zes - vetores pr√≥prios.  Tal m√©todo, em contraste com os algoritmos num√©ricos (que, como observamos acima, se aplica ao EVD), permite obter valores pr√≥prios reais e n√£o aproximados.  √â por isso que essa abordagem nos permite obter n√£o um pseudoespectro, mas um espectro.  A mesma id√©ia formou a base do algoritmo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Root MUSIC</a> . </p><br><h2 id="modelirovanie">  Modelagem </h2><br><p>  Fuf!  Finalmente, todas as f√≥rmulas s√£o descritas e um pouco explicadas.  Podemos come√ßar a modelar. </p><br><pre> <code class="python hljs">cases = [[<span class="hljs-number"><span class="hljs-number">-1.</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span>], [<span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>], [<span class="hljs-number"><span class="hljs-number">-0.3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.3</span></span>],] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idxm, c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(cases): <span class="hljs-comment"><span class="hljs-comment">#   ( ): mu_1 = c[0]*mu_R mu_2 = c[1]*mu_R mu_3 = c[2]*mu_R #   a_1 = np.exp(1j*mu_1*np.arange(M)) a_2 = np.exp(1j*mu_2*np.arange(M)) a_3 = np.exp(1j*mu_3*np.arange(M)) A = (np.array([a_1, a_2, a_3])).T #    X = np.dot(A,S) + W #    R = np.dot(X,np.matrix(X).H) U, Sigma, Vh = np.linalg.svd(X, full_matrices=True) U_0 = U[:,d:] #   thetas = np.arange(-90,91)*(np.pi/180) #   mus = np.pi*np.sin(thetas) #    a = np.empty((M, len(thetas)), dtype = complex) for idx, mu in enumerate(mus): a[:,idx] = np.exp(1j*mu*np.arange(M)) # MVDR: S_MVDR = np.empty(len(thetas), dtype = complex) for idx in range(np.shape(a)[1]): a_idx = (a[:, idx]).reshape((M, 1)) S_MVDR[idx] = 1 / (np.dot(np.matrix(a_idx).H, np.dot(np.linalg.pinv(R),a_idx))) # MUSIC: S_MUSIC = np.empty(len(thetas), dtype = complex) for idx in range(np.shape(a)[1]): a_idx = (a[:, idx]).reshape((M, 1)) S_MUSIC[idx] = np.dot(np.matrix(a_idx).H,a_idx)\ / (np.dot(np.matrix(a_idx).H, np.dot(U_0,np.dot(np.matrix(U_0).H,a_idx)))) plt.subplots(figsize=(10, 5), dpi=150) plt.semilogy(thetas*(180/np.pi), np.real( (S_MVDR / max(S_MVDR))), color='green', label='MVDR') plt.semilogy(thetas*(180/np.pi), np.real((S_MUSIC/ max(S_MUSIC))), color='red', label='MUSIC') plt.grid(color='r', linestyle='-', linewidth=0.2) plt.xlabel('Azimuth angles Œ∏ (degrees)') plt.ylabel('Power (pseudo)spectrum (normalized)') plt.legend() plt.title('Case #'+str(idxm+1)) plt.show()</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/g1/u-/al/g1u-almrcy6s22pas2skmwvw-t0.png"><br><img src="https://habrastorage.org/webt/cu/mo/ml/cumomltqiwfzp-4lpvly0gzrtby.png"><br><img src="https://habrastorage.org/webt/_j/bo/kn/_jboknyjydjcgjuk9igu7nbfo_a.png"></p><br><p>  Como podemos ver, a MUSIC possui uma resolu√ß√£o mais alta e permite obter, em geral, melhores resultados do que, por exemplo, o MVDR permite - o mesmo representante dos m√©todos param√©tricos de an√°lise espectral. </p><br><p>  No entanto, deve-se ter em mente que, ao usar MUSIC, usamos algoritmos computacionalmente mais caros, como EVD ou SVD, que t√™m um pre√ßo mais alto para maior precis√£o. </p><br><p>  Essas coisas. </p><br><h2 id="spisok-ispolzovannoy-literatury">  Lista de literatura usada: </h2><br><ol><li>  Haykin, Simon e KJ Ray Liu.  Manual sobre processamento de array e redes de sensores.  Vol.  63. John Wiley &amp; Sons, 2010. pp.  102-107 </li><li>  Hayes MH Processamento e modelagem estat√≠sticos de sinais digitais.  - John Wiley &amp; Sons, 2009. </li><li>  Haykin, Simon S. Teoria do filtro adaptativo.  Pearson Education India, 2008. pp.  422-427 </li><li>  Richmond, Christ D. "Algoritmo de Capon ao quadrado do erro m√©dio - predi√ß√£o SNR e probabilidade de resolu√ß√£o".  IEEE Transactions on Signal Processing 53.8 (2005): 2748-2764. </li><li>  SKP Gupta, MUSIC e algoritmo MUSIC aprimorado para estimar a dor de chegada, IEEE, 2015. </li><li>  Palestras do professor Martin Haardt ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">array array</a> ) </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt446674/">https://habr.com/ru/post/pt446674/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt446658/index.html">Entrevista com Andrei Stankevich sobre programa√ß√£o esportiva</a></li>
<li><a href="../pt446660/index.html">IA, aluno e grande pr√™mio: como fazer o aprendizado de m√°quina na 8¬™ s√©rie</a></li>
<li><a href="../pt446662/index.html">Transa√ß√µes e mecanismos para seu controle</a></li>
<li><a href="../pt446664/index.html">O SAP Forum 2019 est√° a apenas 2 semanas! O que vai estar a√≠?</a></li>
<li><a href="../pt446666/index.html">Aproveite ao m√°ximo as calculadoras gr√°ficas: jogos na TI-83</a></li>
<li><a href="../pt446676/index.html">Criando teclas ausentes para o teclado de borracha Commodore 116</a></li>
<li><a href="../pt446678/index.html">Live Battle: finais do Porto ICPC</a></li>
<li><a href="../pt446680/index.html">O principal instinto do codificador √© eliminar solu√ß√µes ineficazes de qualquer lugar</a></li>
<li><a href="../pt446682/index.html">Acelerando o WebGL / Three.js com OffscreenCanvas e Web Workers</a></li>
<li><a href="../pt446688/index.html">Extens√£o SIMD para C ++ OpenMP no Visual Studio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>