<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖕🏾 🤰🏾 🌼 Modelamos o algoritmo MUSIC para determinar a direção de chegada de uma onda eletromagnética 🏥 👰🏻 👨🏼‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prefácio 


 Começarei minha introdução de longe. Era uma vez, no distante 2016-2017, seu humilde servo conseguiu fazer um curso de treinamento de sei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Modelamos o algoritmo MUSIC para determinar a direção de chegada de uma onda eletromagnética</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446674/"><p><img src="https://media.moddb.com/cache/images/groups/1/3/2392/thumb_620x2000/music-cats.jpg" alt="aaspcats"></p><br><h2 id="predislovie">  Prefácio </h2><br><p>  Começarei minha introdução de longe.  Era uma vez, no distante 2016-2017, seu humilde servo conseguiu fazer um curso de treinamento de seis meses na cidade distante de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Ilmenau</a> (Alemanha), onde completou com sucesso (em geral) o programa de mestrado <strong>Comunicações e processamento de sinais</strong> .  O programa não foi fácil, mas agora é agradável recordá-lo.  As vezes ... </p><a name="habracut"></a><br><p>  Portanto, ao final deste treinamento, além do diploma, eu ainda tinha alguns materiais diferentes em mãos, que eu achava errado não compartilhar. </p><br><p>  Um desses materiais está na sua frente. </p><br><p>  <strong>Quais objetivos eu persegui enquanto preparava o seminário</strong> : </p><br><ol><li>  falar sobre algumas abordagens já "inteligentes" já estabelecidas no tópico dos arranjos de antenas mais acessíveis e fazê-lo em russo; </li><li>  realize uma pequena simulação no <strong><em>Python 3</em></strong> para agitar colegas engenheiros de rádio para examinar mais de perto as linguagens de programação (se você ainda não o olhou de perto); </li><li>  forneça links para boa literatura em inglês - sem ler fontes estrangeiras, agora, infelizmente, em lugar nenhum. </li></ol><br><p>  <strong>O que considerar</strong> : </p><br><ul><li>  O método MUSIC (MUltiple SIgnal Classification) - isso, de fato, refere-se à visualização. </li></ul><br><blockquote>  Um exemplo de formação de gráfico e o método MVDR pode ser encontrado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">aqui</a> (se houver perguntas ou sugestões para material adicional, a discussão poderá ser continuada no Github.Gist). </blockquote><p>  Como eu disse acima, usaremos Python, a saber: </p><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt</code> </pre> <br><p>  Por que não o MATLAB, um dos candidatos mais populares e convenientes para modelagem de álgebra linear, você pergunta?  Porque, quero mostrar que trabalho semelhante pode ser feito em Python, e o escopo do Python é muito mais amplo que o do MATLAB.  Portanto, estar familiarizado com a sintaxe do Python é uma coisa útil, na minha opinião. </p><br><p>  Vamos começar! </p><br><blockquote>  As fórmulas são preparadas através de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">https://upmath.me/</a> .  Obrigado aos criadores por uma ótima ferramenta! </blockquote><br><h2 id="postanovka-zadachi">  Declaração do problema </h2><br><p>  Suponha que exista um conjunto de antenas lineares consistindo em vários elementos espaçados um do outro <img src="https://tex.s2cms.ru/svg/%5CDelta%20%3D%20%5Cfrac%7B%5Clambda%7D%7B2%7D" alt="\ Delta = \ frac {\ lambda} {2}">  (passo do conjunto de antenas), onde <img src="https://tex.s2cms.ru/svg/%5Clambda" alt="\ lambda">  - o comprimento da onda eletromagnética portadora (EM). </p><br><p>  Ondas eletromagnéticas caem nesse conjunto de antenas de diferentes direções. </p><br><p><img src="https://habrastorage.org/webt/mk/3w/zz/mk3wzzmb4bonpno72euep64v0ao.png"></p><br><blockquote>  Fig.  1. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Sistema de antena adaptável.</a> </blockquote><p>  Como pode ser visto na figura, o conjunto de antenas é considerado como um filtro adaptável. </p><br><p>  Na verdade, encontrar o vetor ideal de coeficientes ( <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7Bw%7D_%7Bopt%7D" alt="\ mathbf {w} _ {opt}">  ) é a principal tarefa dos arranjos de antenas adaptáveis ​​do ponto de vista matemático. </p><br><p>  Inicialmente, não sabemos de quais direções específicas estão vindo os sinais e quantas delas.  Para resolver essa contradição, usaremos o algoritmo MUSIC, um algoritmo para estimar frequências espaciais com alta resolução. </p><br><h2 id="modelirovanie-prinyatogo-signala">  Simulação de sinal recebido </h2><br><p>  Podemos apresentar o modelo do sinal recebido através da fórmula: </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cmathbf%7BX%7D%20%3D%20%5Cmathbf%7BA%7D%20%5Cmathbf%7BS%7D%20%2B%20%5Cmathbf%7BN%7D%20" alt="\ mathbf {X} = \ mathbf {A} \ mathbf {S} + \ mathbf {N}"></div><p></p><br><p>  onde <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BA%7D%20%3D%20%5B%5Cmathbf%7Ba%7D(%5Ctheta_1)%20%5Cquad%20%5Cmathbf%7Ba%7D(%5Ctheta_2)%20%5Cquad%20...%20%5Cquad%20%5Cmathbf%7Ba%7D(%5Ctheta_d)%5D" alt="\ mathbf {A} = [\ mathbf {a} (\ theta_1) \ quad \ mathbf {a} (\ theta_2) \ quad ... \ quad \ mathbf {a} (\ theta_d)]">  - matriz de vetores de varredura (vetores de direção) do conjunto de antenas ( <img src="https://tex.s2cms.ru/svg/%20a_i%20%3D%20%5Cexp(-j%20%5Cmu%20m_i)" alt="a_i = \ exp (-j \ mu m_i)">  , <img src="https://tex.s2cms.ru/svg/m%20%3D%200%2C%201%20...%20(M-1)" alt="m = 0, 1 ... (M-1)">  , <img src="https://tex.s2cms.ru/svg/M" alt="M">  - o número de elementos do conjunto de antenas, <img src="https://tex.s2cms.ru/svg/d" alt="d">  - o número de fontes de ondas EM, <img src="https://tex.s2cms.ru/svg/%5Ctheta" alt="\ theta">  - ângulo da direção de chegada da onda EM), <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BS%7D" alt="\ mathbf {S}">  - matriz de caracteres transmitidos, e <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BN%7D" alt="\ mathbf {N}">  - matriz de ruído aditivo. </p><br><img src="https://raw.githubusercontent.com/kirlf/CSP/master/Different/assets/ULA.png" alt="ULA" width="600"><br><blockquote>  Fig.  2. Conjunto de antenas lineares omnidirecionais (ULAA - conjunto de anntenna linear uniforme) [1, p.  32] </blockquote><p>  Vamos repensar essa fórmula da maneira "cotidiana": em nossa grade, temos uma "bagunça" de vários sinais, que denotamos por <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BX%7D" alt="\ mathbf {X}">  .  Nós não recebemos explicitamente informações sobre o número de fontes e direções; no entanto, informações sobre isso ainda estão contidas no sinal recebido. </p><br><p>  Estamos começando a pesquisar! </p><br><p>  Para fazer isso, eles geralmente procedem às manipulações não com as matrizes de amplitudes complexas de sinal, mas com suas covariâncias (isto é, em essência, com poderes): </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cmathbf%7BR%7D_%7Bxx%7D%20%3D%20%5Cmathbf%7BX%7D%5Cmathbf%7BX%7D%5EH%20%3D%20%20%5Cmathbf%7BA%7D%20%5Cmathbf%7BR%7D_%7Bss%7D%20%5Cmathbf%7BA%7D%5EH%20%2B%20%5Cmathbf%7BR%7D_%7Bnn%7D%20" alt="\ mathbf {R} _ {xx} = \ mathbf {X} \ mathbf {X} ^ H = \ mathbf {A} \ mathbf {R} _ {ss} \ mathbf {A} ^ H + \ mathbf {R} _ {nn}"></div><p></p><br><h2 id="usloviya">  Condições </h2><br><p>  Introduzimos uma condição importante a ser considerada: o limite de resolução do ângulo Rayleigh: </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/sin%20(%5Ctheta_R)%20%3D%20%5Cfrac%7B%5Clambda%7D%7BD%7D" alt="sin (\ theta_R) = \ frac {\ lambda} {D}"></div><p></p><br><p>  onde <img src="https://tex.s2cms.ru/svg/D%20%3D%20M%20%5CDelta" alt="D = M \ Delta">  É o comprimento da rede linear. </p><br><p>  Redefinimos o ângulo de chegada de uma onda eletromagnética através do conceito de frequência espacial: </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cmu_R%20%3D%20%5Cfrac%7B2%20%5Cpi%7D%7B%5Clambda%7D%5CDelta%20sin(%5Ctheta_R)%20%3D%20%5Cfrac%7B2%20%5Cpi%7D%7B%5Clambda%7D%5CDelta%20%5Cfrac%7B%5Clambda%7D%7B%5CDelta%20M%7D%20%3D%20%5Cfrac%7B2%20%5Cpi%7D%7BM%7D" alt="\ mu_R = \ frac {2 \ pi} {\ lambda} \ Delta sin (\ theta_R) = \ frac {2 \ pi} {\ lambda} \ Delta \ frac {\ lambda} {\ Delta M} = \ frac { 2 \ pi} {M}"></div><p></p><br><p>  onde <img src="https://tex.s2cms.ru/svg/%5Cmu_R" alt="\ mu_R">  - existe uma largura padrão do lóbulo principal do feixe ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">largura de</a> feixe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">padrão</a> ). </p><br><p>  Para verificar a eficácia do nosso método e sob quais condições, apresentamos alguns valores para a separação angular: </p><br><ol><li><p><img src="https://tex.s2cms.ru/svg/%5Cmu_1%20%3D%20-%20%5Cmu_R%2C%20%5Cquad%20%5Cmu_2%20%3D%200%2C%20%5Cquad%20%5Cmu_3%20%3D%20%20%5Cmu_R%20%5Cquad%20" alt="\ mu_1 = - \ mu_R, \ quad \ mu_2 = 0, \ quad \ mu_3 = \ mu_R \ quad">  - divisão em uma largura de feixe; </p><br></li><li><p><img src="https://tex.s2cms.ru/svg/%5Cmu_1%20%3D%20-0.5%20%5Cmu_R%2C%20%5Cquad%20%5Cmu_2%20%3D%200%2C%20%5Cquad%20%5Cmu_3%20%3D%200.5%20%5Cmu_R%20%5Cquad%20" alt="\ mu_1 = -0,5 \ mu_R, \ quad \ mu_2 = 0, \ quad \ mu_3 = 0,5 \ mu_R \ quad">  - divisão na largura de um segundo feixe; </p><br></li><li><p><img src="https://tex.s2cms.ru/svg/%5Cmu_1%20%3D%20-0.3%20%5Cmu_R%2C%20%5Cquad%20%5Cmu_2%20%3D%200%2C%20%5Cquad%20%5Cmu_3%20%3D%200.3%20%5Cmu_R%20%5Cquad%20" alt="\ mu_1 = -0,3 \ mu_R, \ quad \ mu_2 = 0, \ quad \ mu_3 = 0,3 \ mu_R \ quad">  - divisão em três décimos da largura do feixe. </p><br></li></ol><br><p>  Defina os parâmetros de entrada: </p><br><pre> <code class="python hljs">M = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-comment"><span class="hljs-comment">#    () SNR = 10 #  - (dB) d = 3 #     N = 50 #  "" (snapshots) S = ( np.sign(np.random.randn(d,N)) + 1j * np.sign(np.random.randn(d,N)) ) / np.sqrt(2) # QPSK W = ( np.random.randn(M,N) + 1j * np.random.randn(M,N) ) / np.sqrt(2) * 10**(-SNR/20) # AWGN #  : # sqrt(N0/2)*(G1 + jG2), #  G1  G2 -   . # .. Es( )  QPSK  1 ,    (noise spectral density): # N0 = (Es/N)^(-1) = SNR^(-1) [] (   ,  SNR = Es/N0); #    : # SNR_dB = 10log10(SNR) =&gt; N0_dB = -10log10(SNR) = -SNR_dB []; #    SNR    (..  ),   : # SNR = 10^(SNR_dB/10) =&gt; sqrt(N0) = (10^(-SNR_dB/10))^(1/2) = 10^(-SNR_dB/20) mu_R = 2*np.pi / M</span></span></code> </pre> <br><h2 id="nemnogo-teorii-o-samom-metode">  Um pouco de teoria sobre o próprio método </h2><br><p>  Primeiramente, notamos que o progenitor do método MUSIC é o método <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Pisarenko</a> (1973).  O problema considerado do método Pisarenko foi estimar as frequências da soma de exponenciais complexas no ruído branco.  V.F. Pisarenko demonstrou que frequências podem ser encontradas a partir de vetores próprios correspondentes ao valor próprio mínimo da matriz de autocorrelação.  Posteriormente, esse método se tornou um caso especial do método MUSIC.  [2, p.  459] </p><br><p>  Schmidt e seus colegas propuseram o algoritmo de classificação de sinais múltiplos (MUSIC) em 1979 [4].  A principal abordagem desse algoritmo é decompor a matriz de covariância do sinal recebido em autovalores.  Como esse algoritmo leva em consideração o ruído não correlacionado, a matriz de covariância gerada tem uma forma diagonal.  Aqui, os subespaços de sinal e ruído são calculados usando álgebra linear e são ortogonais entre si.  Portanto, o algoritmo usa a propriedade de ortogonalidade para extrair os subespaços de sinal e ruído [5]. </p><br><p>  O algoritmo MUSIC generalizado pode ser definido da seguinte maneira: </p><br><ul><li>  Encontre a matriz de covariância <img src="https://tex.s2cms.ru/svg/%20%5Cmathbf%7BR%7D_%7Bxx%7D%20" alt="\ mathbf {R} _ {xx}"></li><li>  Encontre autovetores via <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">EVD</a> ou outro algoritmo numérico adequado: </li></ul><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cmathbf%7BR%7D_%7Bxx%7D%20%3D%20%5Cmathbf%7BU%7D%5Cmathbf%7B%5CLambda%7D%5Cmathbf%7BU%7D%5EH%20%5Cqquad(1)" alt="\ mathbf {R} _ {xx} = \ mathbf {U} \ mathbf {\ Lambda} \ mathbf {U} ^ H \ qquad (1)"></div><p></p><br><ul><li>  Encontre o pseudo-espectro (por que com o prefixo pseudo, discutiremos abaixo) MÚSICA através da seguinte fórmula: </li></ul><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20P_%7BMU%7D(e%5E%7Bj%5Comega%7D)%20%3D%20%5Cfrac%7B1%7D%7B%5Csum%20%5Climits_%7Bi%3Dd%2B1%7D%5E%7BM%7D%7C%5Cmathbf%7Ba%7D%5EH%5Cmathbf%7Bu%7D_i%7C%5E2%7D%20%5Cqquad(2)%20" alt="P_ {MU} (e ^ {j \ omega}) = \ frac {1} {\ sum \ limits_ {i = d + 1} ^ {M} | \ mathbf {a} ^ H \ mathbf {u} _i | ^ 2} \ qquad (2)"></div><p></p><br><p>  onde <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7Ba%7D%20%3D%20%5Cbegin%7Bbmatrix%7D%20%20e%5E%7Bj0%5Comega%7D%20%26%20e%5E%7Bj1%5Comega%7D%20%26%20e%5E%7Bj2%5Comega%7D%20%26%20...%20%26%20e%5E%7Bj(M-1)%5Comega%7D%20%5Cend%7Bbmatrix%7D%5ET" alt="\ mathbf {a} = \ begin {bmatrix} e ^ {j0 \ omega} &amp; e ^ {j1 \ omega} &amp; e ^ {j2 \ omega} &amp; ... &amp; e ^ {j (M-1) \ omega } \ end {bmatrix} ^ T">  É o vetor de exponenciais para a frequência ω situada em um determinado intervalo, e <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7Bu%7D_i" alt="\ mathbf {u} _i">  - o i-ésimo vetor próprio (vetor eigen) da matriz de covariância (1) correspondente ao subespaço de ruído da matriz (1) - daí a indexação com <img src="https://tex.s2cms.ru/svg/d%2B1" alt="d + 1">  ( <img src="https://tex.s2cms.ru/svg/d" alt="d">  É a classificação da matriz (1)). </p><br><blockquote>  Para maior clareza, tente executar o script MATLAB apropriado fornecido por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">referência</a> .  Preste atenção a dois pontos principais: <br><ul><li>  em vez de calcular o quadrado da segunda norma no denominador (2), os autores aplicam o algoritmo FFT aos autovetores, o que facilita a modelagem usando funções internas e, em geral, não contradiz a teoria do ponto de vista matemático; </li><li>  a matriz de covariância é calculada através de matrizes convolucionais; uma abordagem diferente foi mostrada acima para estimar frequências espaciais. </li></ul><br></blockquote><p>  Como você pode imaginar pelo nome, MUSIC também é um método clássico para estimar a direção da recepção em alta resolução.  O algoritmo para calcular pseudo-espectros neste contexto é dado abaixo: </p><br><ul><li><p>  encontramos a matriz de covariância do sinal recebido; </p><br></li><li><p>  encontre o subespaço zero <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BU%7D_0" alt="\ mathbf {U} _0">  : </p><br></li></ul><br><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cmathbf%7BU%7D%20%3D%20%5B%5Cmathbf%7BU%7D_s%20%5Cquad%20%5Cmathbf%7BU%7D_0%5D%20" alt="\ mathbf {U} = [\ mathbf {U} _s \ quad \ mathbf {U} _0]"></div><p></p><br><ul><li>  selecione algum intervalo de pesquisa: </li></ul><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20a(%5Cmu)%20%3D%20%5Cbegin%7Bbmatrix%7D%20e%5E%7Bj0%5Cmu_1%7D%20%26%20...%20%26%20e%5E%7Bj0%5Cmu_Q%7D%20%5C%5C%20...%20%26...%26...%20%5C%5C%20e%5E%7Bj(M-1)%5Cmu_1%7D%20%26%20...%20%26%20e%5E%7Bj(M-1)%5Cmu_Q%7D%20%5Cend%7Bbmatrix%7D%20" alt="a (\ mu) = \ begin {bmatrix} e ^ {j0 \ mu_1} &amp; ... &amp; e ^ {j0 \ mu_Q} \\ ... &amp; ... &amp; ... \\ e ^ {j ( M-1) \ mu_1} &amp; ... &amp; e ^ {j (M-1) \ mu_Q} \ end {bmatrix}"></div><p></p><br><p>  onde <img src="https://tex.s2cms.ru/svg/%5Cmu%20%3D%20-%5Cfrac%7B2%5Cpi%20f_c%7D%7Bc%7D%5CDelta%20sin%5Ctheta%20%3D%20-%5Cfrac%7B2%5Cpi%20%7D%7B%5Clambda%20%7D%5CDelta%20sin%5Ctheta" alt="\ mu = - \ frac {2 \ pi f_c} {c} \ Delta sin \ theta = - \ frac {2 \ pi} {\ lambda} \ Delta sin \ theta"></p><br><ul><li>  calcule o pseudo-espectro: </li></ul><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20P_%7BMU%7D(%5Ctheta)%3D%5Cfrac%7B%5Cmathbf%7Ba%7D%5EH%20(%5Ctheta)%5Cmathbf%7Ba%7D(%5Ctheta)%7D%7B%5Cmathbf%7Ba%7D%5EH(%5Ctheta)%5Cmathbf%7BU%7D_0%20%5Cmathbf%7BU%7D_0%5EH%20%5Cmathbf%7Ba%7D(%5Ctheta)%7D%20" alt="P_ {MU} (\ theta) = \ frac {\ mathbf {a} ^ H (\ theta) \ mathbf {a} (\ theta)} {\ mathbf {a} ^ H (\ theta) \ mathbf {U} _0 \ mathbf {U} _0 ^ H \ mathbf {a} (\ theta)}"></div><p></p><br><p>  A relação entre análise espectral e análise dos ângulos de chegada (DoA - direção do arriaval) das ondas EM é descrita na tabela 1. </p><br><p>  Tabela 1 <strong>Comunicação entre aplicativos MUSIC</strong> : Processamento da matriz de sinais e busca harmônica [6]. </p><br><div class="scrollable-table"><table><thead><tr><th>  Variável </th><th>  Processamento de matriz de sinal </th><th>  Pesquisa harmônica </th></tr></thead><tbody><tr><td><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/M" alt="M"></div></td><td>  Número de sensores </td><td>  O número de períodos </td></tr><tr><td><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/N" alt="N"></div></td><td>  O número de períodos </td><td>  Número de experiências </td></tr><tr><td><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/d" alt="d"></div></td><td>  Número de frentes de onda </td><td>  O número de componentes complexos </td></tr><tr><td><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%5Cmu" alt="\ mu"></div></td><td>  Frequências espaciais </td><td>  Frequências normalizadas </td></tr></tbody></table></div><br><p>  Em geral, o processo de recebimento através de matrizes (grades) pode ser comparado com o processo de discretização clássica, porque  de fato, cada sensor, recebendo uma onda com um certo atraso de fase (isto é, com um certo atraso de tempo), executa as funções de um pulso delta de amostragem.  O número de realizações (experimentos) da análise espectral clássica corresponderá ao número de segmentos de tempo (instantâneos).  Cada fonte terá sua própria frente de onda, que é equivalente ao número de sinusóides únicos do sinal no caso de análise espectral. </p><br><p>  E agora, de volta ao momento de calcular os autovetores.  Já mencionamos acima que vetores <img src="https://tex.s2cms.ru/svg/a(%5Ctheta_i)%5Cepsilon%20A" alt="a (\ theta_i) \ epsilon A">  onde <img src="https://tex.s2cms.ru/svg/i%3D1%2C2%2C..%2Cd" alt="i = 1,2, .., d">  são ortogonais ao subespaço de ruído da matriz de covariância, ou seja: </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20a(%5Ctheta_i)%5ETU_0%3D0%5ET%20" alt="a (\ theta_i) ^ TU_0 = 0 ^ T"></div><p></p><br><p>  Na verdade, vemos um sistema de equações, resolvendo o que podemos encontrar as raízes - vetores próprios.  Tal método, em contraste com os algoritmos numéricos (que, como observamos acima, se aplica ao EVD), permite obter valores próprios reais e não aproximados.  É por isso que essa abordagem nos permite obter não um pseudoespectro, mas um espectro.  A mesma idéia formou a base do algoritmo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Root MUSIC</a> . </p><br><h2 id="modelirovanie">  Modelagem </h2><br><p>  Fuf!  Finalmente, todas as fórmulas são descritas e um pouco explicadas.  Podemos começar a modelar. </p><br><pre> <code class="python hljs">cases = [[<span class="hljs-number"><span class="hljs-number">-1.</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span>], [<span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>], [<span class="hljs-number"><span class="hljs-number">-0.3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.3</span></span>],] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idxm, c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(cases): <span class="hljs-comment"><span class="hljs-comment">#   ( ): mu_1 = c[0]*mu_R mu_2 = c[1]*mu_R mu_3 = c[2]*mu_R #   a_1 = np.exp(1j*mu_1*np.arange(M)) a_2 = np.exp(1j*mu_2*np.arange(M)) a_3 = np.exp(1j*mu_3*np.arange(M)) A = (np.array([a_1, a_2, a_3])).T #    X = np.dot(A,S) + W #    R = np.dot(X,np.matrix(X).H) U, Sigma, Vh = np.linalg.svd(X, full_matrices=True) U_0 = U[:,d:] #   thetas = np.arange(-90,91)*(np.pi/180) #   mus = np.pi*np.sin(thetas) #    a = np.empty((M, len(thetas)), dtype = complex) for idx, mu in enumerate(mus): a[:,idx] = np.exp(1j*mu*np.arange(M)) # MVDR: S_MVDR = np.empty(len(thetas), dtype = complex) for idx in range(np.shape(a)[1]): a_idx = (a[:, idx]).reshape((M, 1)) S_MVDR[idx] = 1 / (np.dot(np.matrix(a_idx).H, np.dot(np.linalg.pinv(R),a_idx))) # MUSIC: S_MUSIC = np.empty(len(thetas), dtype = complex) for idx in range(np.shape(a)[1]): a_idx = (a[:, idx]).reshape((M, 1)) S_MUSIC[idx] = np.dot(np.matrix(a_idx).H,a_idx)\ / (np.dot(np.matrix(a_idx).H, np.dot(U_0,np.dot(np.matrix(U_0).H,a_idx)))) plt.subplots(figsize=(10, 5), dpi=150) plt.semilogy(thetas*(180/np.pi), np.real( (S_MVDR / max(S_MVDR))), color='green', label='MVDR') plt.semilogy(thetas*(180/np.pi), np.real((S_MUSIC/ max(S_MUSIC))), color='red', label='MUSIC') plt.grid(color='r', linestyle='-', linewidth=0.2) plt.xlabel('Azimuth angles θ (degrees)') plt.ylabel('Power (pseudo)spectrum (normalized)') plt.legend() plt.title('Case #'+str(idxm+1)) plt.show()</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/g1/u-/al/g1u-almrcy6s22pas2skmwvw-t0.png"><br><img src="https://habrastorage.org/webt/cu/mo/ml/cumomltqiwfzp-4lpvly0gzrtby.png"><br><img src="https://habrastorage.org/webt/_j/bo/kn/_jboknyjydjcgjuk9igu7nbfo_a.png"></p><br><p>  Como podemos ver, a MUSIC possui uma resolução mais alta e permite obter, em geral, melhores resultados do que, por exemplo, o MVDR permite - o mesmo representante dos métodos paramétricos de análise espectral. </p><br><p>  No entanto, deve-se ter em mente que, ao usar MUSIC, usamos algoritmos computacionalmente mais caros, como EVD ou SVD, que têm um preço mais alto para maior precisão. </p><br><p>  Essas coisas. </p><br><h2 id="spisok-ispolzovannoy-literatury">  Lista de literatura usada: </h2><br><ol><li>  Haykin, Simon e KJ Ray Liu.  Manual sobre processamento de array e redes de sensores.  Vol.  63. John Wiley &amp; Sons, 2010. pp.  102-107 </li><li>  Hayes MH Processamento e modelagem estatísticos de sinais digitais.  - John Wiley &amp; Sons, 2009. </li><li>  Haykin, Simon S. Teoria do filtro adaptativo.  Pearson Education India, 2008. pp.  422-427 </li><li>  Richmond, Christ D. "Algoritmo de Capon ao quadrado do erro médio - predição SNR e probabilidade de resolução".  IEEE Transactions on Signal Processing 53.8 (2005): 2748-2764. </li><li>  SKP Gupta, MUSIC e algoritmo MUSIC aprimorado para estimar a dor de chegada, IEEE, 2015. </li><li>  Palestras do professor Martin Haardt ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">array array</a> ) </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt446674/">https://habr.com/ru/post/pt446674/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt446658/index.html">Entrevista com Andrei Stankevich sobre programação esportiva</a></li>
<li><a href="../pt446660/index.html">IA, aluno e grande prêmio: como fazer o aprendizado de máquina na 8ª série</a></li>
<li><a href="../pt446662/index.html">Transações e mecanismos para seu controle</a></li>
<li><a href="../pt446664/index.html">O SAP Forum 2019 está a apenas 2 semanas! O que vai estar aí?</a></li>
<li><a href="../pt446666/index.html">Aproveite ao máximo as calculadoras gráficas: jogos na TI-83</a></li>
<li><a href="../pt446676/index.html">Criando teclas ausentes para o teclado de borracha Commodore 116</a></li>
<li><a href="../pt446678/index.html">Live Battle: finais do Porto ICPC</a></li>
<li><a href="../pt446680/index.html">O principal instinto do codificador é eliminar soluções ineficazes de qualquer lugar</a></li>
<li><a href="../pt446682/index.html">Acelerando o WebGL / Three.js com OffscreenCanvas e Web Workers</a></li>
<li><a href="../pt446688/index.html">Extensão SIMD para C ++ OpenMP no Visual Studio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>