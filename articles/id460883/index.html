<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©â€ğŸ”§ ğŸ’ªğŸ» ğŸ•› Tentang kehidupan di dunia perubahan persyaratan dan manfaat fitur kecil ğŸ‘¸ ğŸŒ½ â˜ğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selama lebih dari setahun sekarang, di MyStore, kami telah menciptakan fungsionalitas yang membantu pengguna kami membeli dan menjual barang berlabel....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tentang kehidupan di dunia perubahan persyaratan dan manfaat fitur kecil</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/moysklad/blog/460883/"><p>  Selama lebih dari setahun sekarang, di MyStore, kami telah menciptakan fungsionalitas yang membantu pengguna kami membeli dan menjual barang berlabel.  Berita tentang pelabelan telah berkali-kali menyelinap di HabrÃ©, begitu singkat: sejak 2019, barang-barang ditandai dengan sendirinya.  Tidak semuanya sekaligus, tetapi sekarang Anda perlu memberi label rokok, sepatu, parfum, dan ban mobil.  Pada saat yang sama, kami bekerja dalam situasi ketidakpastian ketika API sistem pemerintah terus berubah. </p><br><p>  Oleh karena itu, kami hanya memiliki dua cara untuk berintegrasi dengan lembaga pemerintah: tunggu sampai semuanya beres dan ketinggalan kepemimpinan pasar atau kembangkan sistem di dunia dengan persyaratan yang terus berubah. </p><br><p>  Kami memilih yang kedua - hanya dalam semangat metodologi yang fleksibel.  Saya pikir Agile dapat sangat membantu dalam memecahkan masalah yang diterapkan.  Dan kehidupan di dunia dengan tuntutan yang terus berubah adalah bidang di mana Anda bisa berbalik. </p><br><p><img src="https://habrastorage.org/webt/x4/ni/n1/x4nin1beett46tlmycu26ug-wxm.png"></p><a name="habracut"></a><br><p>  Nama saya Maxim Sukharenko, pemimpin tim platform layanan MySklad.  Dan hari ini saya akan memberi tahu Anda bagaimana kami bekerja dengan perubahan persyaratan. </p><br><h3 id="ot-klassicheskoy-sistemy-do-scrum">  Dari Klasik ke Scrum </h3><br><p>  Batas waktu awal untuk pengembangan sistem oleh otoritas pengawas direncanakan untuk April 2019, tetapi Anda mengerti segalanya.  Akibatnya, tenggat waktu dipindahkan ke Oktober.  Dan di mana ada tenggat waktu baru, ada persyaratan baru dan format baru.  Kami tidak bisa menunggu API diperbaiki - maka kami tidak akan punya waktu untuk mengimplementasikan integrasi.  Karena itu, mereka memutuskan untuk "ragu dengan garis partai." </p><br><p>  Kami memikirkan pendekatan klasik yang menawarkan kami membuat adaptor untuk sistem eksternal.  Lengkapi dengan steker dengan sakelar dan dari waktu ke waktu tarik fungsionalitas steker dan adaptor ke kondisi sistem eksternal saat ini. </p><br><p><img src="https://habrastorage.org/webt/0_/dg/ya/0_dgya04sgbr4twr93dvxknpakq.png"></p><br><p>  Logika menyarankan agar untuk mengembangkan sistem dengan antarmuka yang terus berubah, Anda perlu memperbaiki persyaratan di beberapa titik waktu.  Tetapi hanya pada apa?  Sampai kita mengembangkan beberapa bagian dari fungsionalitas? </p><br><p>  Anda harus mengakui bahwa tidak menyenangkan meninggalkan fungsionalitas yang belum selesai di mana tes tidak lulus, dan juga mulai merusaknya pada yang baru.  Anda dapat memperbaiki persyaratan untuk periode pengembangan fitur.  Tetapi apa yang harus dilakukan dengan fitur besar yang dapat hidup dalam pengembangan selama beberapa bulan?  Sangat tidak mungkin untuk memperbaiki persyaratan untuk jangka waktu yang lama. </p><br><p>  Jadi kami beralih ke Scrum.  Dia memberi tahu kita bahwa pada akhir sprint, kita harus menyediakan produk yang berfungsi dengan fungsionalitas baru.  Tapi bagaimana ini berkelahi dengan memperbaiki persyaratan dan fitur besar?  Ada lelucon tentang hal ini: </p><br><p>  "Dokter, ketika saya melakukannya seperti ini, itu menyakitkan saya." <br>  "Dan kamu tidak melakukannya seperti itu." </p><br><p>  Siapa yang tidak mengerti, <strong>jangan membuat fitur besar</strong> .  Anda dapat memperbaiki persyaratan untuk satu atau dua minggu agar sesuai dengan sprint, dan mengatur implementasi fungsional sesuai dengan persyaratan untuk tujuan sprint.  Dan fungsinya harus dikalahkan menjadi beberapa bagian sehingga cocok menjadi satu atau dua sprint.  Berpikir terlalu rumit?  Dan kemudian!  Anda tidak tahu cara memotong tiket.  Melihat, Syura, melihat, mereka emas. </p><br><p>  Tentu saja, ini tidak begitu sederhana, kita perlu dengan sengaja bergerak menuju hal ini - untuk meninggalkan pengembangan dari "kita akan melakukannya selama enam bulan, maka kita akan meluncurkan versi baru untuk ujian." </p><br><p>  <strong>Rahasianya adalah memiliki versi stabil di akhir setiap sprint</strong> .  Tentu saja, ini kelihatannya akan meningkatkan waktu pengembangan karena pertumbuhan biaya overhead untuk stabilisasi cabang dan bahwa pengembangan akan menjadi kurang optimal.  Tapi di sini situasinya hampir sama dengan tes, mari kita bicarakan di bawah ini. </p><br><h3 id="k-boevym-zadacham">  Untuk memerangi misi </h3><br><p>  Dan sekarang untuk situasi nyata.  Tugas kami adalah mengonfigurasi enkripsi antara sistem kami dan API sehingga pengguna menandatangani semua permintaan dengan kunci.  Saya pikir banyak dari Anda telah menemukan CryptoPro, jadi kami harus melakukannya. </p><br><p>  Jika Anda menggunakan pendekatan standar, satu tugas yang terisolasi akan dibentuk - menyiapkan kriptografi untuk layanan.  Kami akan menggantungnya di satu orang dan selama sebulan kami akan menghapus status dan membenci mengapa itu tidak akan berakhir dengan cara apa pun.  Dan pengembang secara bertahap akan berubah menjadi makhluk liar dari dunia lain, dengan busa di mulut dan mata liar. <br><img src="https://habrastorage.org/webt/3h/og/zz/3hogzzlu5mplp62bqvmg86ejg5a.png"></p><br><p>  Kami memotongnya menjadi tugas-tugas kecil dan tersebar di seluruh tim.  Saya membandingkan kriptografi dengan alkohol: bersama dan dalam dosis sedang, itu jauh lebih baik daripada banyak dan sendirian. <br>  Karena kami sedang mengembangkan layanan cloud, lebih mudah bagi kami untuk menggunakan plug-in CryptoPro EDS Browser (ini bukan iklan, ini adalah keputusasaan).  Ini memungkinkan CryptoPro CSP untuk memperluas kunci dan metode enkripsi ke halaman web. </p><br><p>  Pertama, pengguna memilih kunci yang akan digunakannya dalam bekerja dengan layanan, kemudian otentikasi dilakukan untuk mendapatkan token.  Dan hanya dengan bantuan enkripsi dan panggilan API token dibuat.  Sepertinya semuanya sederhana (tidak). </p><br><p>  Pertama-tama, kami melakukan MVP secara terpisah dari layanan kami - untuk mengonfigurasi interaksi plugin dengan API.  Apakah Anda tahu berapa banyak dokumentasi yang ada tentang plugin browser cryptoPro dari produsen?  Tidak semuanya!  Hanya contoh rekayasa terbalik, hanya hardcore.  Tanpa tidur malam dan upaya untuk menentukan apa yang mempengaruhi parameter ini atau lainnya. </p><br><p>  Dan hanya pada saat itulah kami dapat mencoba membangunnya ke dalam ekosistem kami.  Satu orang membawa penampilan komponen prototipe ke dalam bentuk manusia, yang kedua menghubungkannya dengan logika bisnis, yang ketiga menulis instruksi untuk anak cucu untuk mengkonfigurasinya.  Setiap tugas memiliki tujuan tertentu dan relatif terisolasi dari yang lain.  Dan orang-orang memiliki sesuatu untuk didiskusikan dan dengan siapa mereka berbagi rasa sakit. </p><br><p>  Jadi situasinya menjadi cukup stabil.  Dalam iterasi kecil, kami menambahkan fungsionalitas baru, dari waktu ke waktu kami memperbarui antarmuka eksternal dan menyebarkan perubahan jauh ke dalam sistem kami.  Tetapi muncul pertanyaan: hidup di cabang terpisah sampai yang terakhir, atau mencoba terus-menerus menjaga fitur kecil di master? </p><br><h3 id="testiruem-funkcional">  Fungsionalitas pengujian </h3><br><p>  Saya mengusulkan untuk mencari tahu apa yang harus dilakukan dengan pengujian dan apa yang harus dilakukan jika kita menambahkan integrasi ke proyek langsung. </p><br><p>  Mari kita mulai dengan pengujian.  Untuk memulainya, kita akan menentukan apa yang dapat kita sebut fungsionalitas yang diuji.  Saya mengusulkan untuk menyebutkan fungsional yang lulus tes penerimaan, termasuk yang regresi.  Kami hanya akan setuju bahwa kami tidak akan menggunakan hack "tidak ada tes - itu berarti semuanya telah diuji".  Kita perlu mempertahankan kode kita di dalam produk, dan semakin banyak cakupan pengujian, semakin baik.  Semakin besar persentase otomatisasi pengujian semacam itu, semakin murah setiap iterasi untuk menguji fungsionalitas dan semakin sering dapat dilakukan. </p><br><p>  Kami memiliki serangkaian tes penerimaan dan regresi tertentu, beberapa di antaranya otomatis, beberapa diadakan dengan tangan. </p><br><p>  Jika kita melakukan pendekatan secara formal, kita harus melakukan pengujian setelah setiap perubahan kode.  Misalnya, mereka memecah fitur Anda menjadi enam tiket dan selama proses pengujian ditemukan sepuluh kesalahan.  Dan biarkan setiap tes memakan waktu empat jam: otomatis tidak masuk hitungan, tetapi manual hanya membutuhkan empat jam.  Ternyata dengan cara kerja dasar dan formal, kita akan menghabiskan 64 jam. <br>  Sekarang mari kita coba untuk menguji bukan setelah setiap perubahan kode, tetapi setelah satu.  Logika menunjukkan bahwa kita hanya menghabiskan 32 jam.  Dan jika Anda melakukan pengujian hanya setelah mengembangkan fungsionalitas dan setelah memperbaiki semua cacat.  Tetapi ini disediakan bahwa semua cacat terisolasi satu sama lain, yang dalam hidup tidak terjadi. </p><br><p>  Dalam kehidupan, ternyata setelah pengembangan fungsionalitas, pengujian dilakukan dan gelombang bug pertama dilakukan.  Kemudian bug diperbaiki, fungsinya rusak, mereka diuji oleh bug bug.  Mereka melakukan tes global kedua, dan gelombang baru bug muncul.  Bug ini disembunyikan dan muncul ketika mereka memperbaiki gelombang pertama dan mengubah fungsinya.  Dan beberapa kali. </p><br><p>  Biasanya Anda mendapatkan tiga hingga lima tes penuh - tergantung pada kompleksitas fungsi dan keterusterangan tangan.  Tetapi prosesnya dapat dipercepat lebih - jika Anda mengalahkan fitur kecil. </p><br><p>  Misalnya, jika Anda memecah satu fitur dengan pengujian pada empat jam menjadi dua dengan pengujian pada tiga setengah jam, Anda mendapatkan lima jam alih-alih empat.  Sepertinya tidak ada untung.  Tapi itu memanifestasikan dirinya dalam penurunan kompleksitas fungsi yang dirilis dan penurunan kemungkinan rantai cacat terkait.  Akibatnya, iterasi pengujian penuh menjadi kurang. </p><br><p><img src="https://habrastorage.org/webt/ax/y2/tk/axy2tka0jmfnd0fnfbpnlnjru74.png"></p><br><h3 id="dobavlyaem-k-proektu">  Tambahkan ke proyek </h3><br><p>  Sekarang kita akan menganalisis situasi ketika Anda membuat fitur dalam proyek di mana pengembang masih bekerja.  Misalkan kita menggunakan konsep kode sumber Cabang Per Fitur (Cabang Per Tiket) yang relatif standar. </p><br><p>  Jelas, jumlah biaya untuk mempertahankan relevansi brunch sebanding dengan masa pakainya.  Semakin sedikit persimpangan kode dalam tiket saat ini, semakin sedikit masalah yang ada pada merger mereka.  Ini secara tidak langsung tergantung pada masa pakainya: semakin banyak waktu berlalu, semakin tinggi kemungkinan tiket terkait akan muncul.  Dengan demikian, semakin sedikit brunch hidup, semakin sedikit upaya yang kita habiskan untuk relevansinya. </p><br><p>  Masih memahami bagaimana cara meluncurkan fungsionalitas fungsional parsial pada prod.  Jawabannya cukup sederhana: seharusnya tidak dapat diakses oleh pengguna.  Jika Anda ingin bertanya mengapa Anda harus melakukan ini, Anda dapat mengembalikan beberapa paragraf di atas. </p><br><p>  Tampaknya menyimpan kode mati di wizard tidak terlalu baik.  Itu benar, tapi dia belum mati.  Anda dapat membuat halaman rahasia dengan pena yang akan menyertakan fungsionalitas tersebut.  Atau urutan tindakan khusus, yang, seperti telur Paskah dalam gim, akan membawa Anda ke fungsi ini.  Selain itu, Anda dapat mengujinya segera. </p><br><p>  Tentu saja, ada cara lain untuk menangani variabilitas persyaratan.  Dan pendekatan ini memiliki keterbatasan dan ketentuan penggunaan.  Seperti yang Anda tahu, masih belum ada peluru perak. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id460883/">https://habr.com/ru/post/id460883/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id460873/index.html">Why Turok: Dinosaur Hunter untuk N64 adalah tahun-tahun sebelumnya</a></li>
<li><a href="../id460875/index.html">Bagaimana kami di QIWI sampai pada gaya interaksi yang umum antara View dan ViewModel dalam MVVM</a></li>
<li><a href="../id460877/index.html">Kubernetes-adventure Dailymotion: membangun infrastruktur di awan + di tempat</a></li>
<li><a href="../id460879/index.html">DUMP Kazan 2019 - Tatarstan Developers Conference. Kami menerima aplikasi untuk laporan</a></li>
<li><a href="../id460881/index.html">Kesulitan menerapkan teknologi OCR dalam sistem DLP, atau Bagaimana kami mempersiapkan OCR</a></li>
<li><a href="../id460885/index.html">Laporan menarik di HighLoad ++ Siberia 2019 menurut Plesk</a></li>
<li><a href="../id460887/index.html">Bukan bahasa pemrograman lain. Bagian 3: Fisika</a></li>
<li><a href="../id460891/index.html">Bagaimana membedakan SCRUM baik dari buruk, menggunakan pendekatan pendiri komputasi kuantum</a></li>
<li><a href="../id460893/index.html">Melihat relokasi ke Estonia dari dalam ke luar - pro, kontra, dan perangkap</a></li>
<li><a href="../id460897/index.html">JUnit di GitLab CI dengan Kubernetes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>