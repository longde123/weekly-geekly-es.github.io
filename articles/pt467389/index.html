<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👦🏿 🉐 👩‍👧 Pinterest Sharding: como escalamos nosso parque MySQL 🍙 🐗 🐭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saudação, Khabrovites! Parabéns a todos no dia do programador e compartilhem a tradução do artigo, que foi especialmente preparado para os alunos do c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pinterest Sharding: como escalamos nosso parque MySQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/467389/">  <i>Saudação, Khabrovites!</i>  <i>Parabéns a todos no dia do programador e compartilhem a tradução do artigo, que foi especialmente preparado para os alunos do curso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"High Load Architect"</a> .</i> <br><br><img src="https://habrastorage.org/webt/3o/s-/k6/3os-k6l2f122mbs6d1lufcif6ke.png"><br><br>  <b><i>"Fragmento.</i></b>  <b><i>Ou não caco.</i></b>  <b><i>Sem tentar. "</i></b> <b><i><br></i></b>  <b><i>- Yoda</i></b> <br><br>  Hoje vamos mergulhar na separação de dados entre vários servidores MySQL.  Concluímos o sharding no início de 2012, e esse sistema ainda é usado para armazenar nossos dados básicos. <a name="habracut"></a><br><br>  Antes de discutirmos como compartilhar dados, vamos conhecê-los melhor.  Prepare uma luz agradável, pegue morangos no chocolate, lembre-se de citações de Star Trek ... <br><br>  O Pinterest é um mecanismo de pesquisa para tudo o que lhe interessa.  Em termos de dados, o Pinterest é o maior gráfico de interesses humanos em todo o mundo.  Ele contém mais de 50 bilhões de pinos que foram salvos pelos usuários em mais de um bilhão de placas.  As pessoas mantêm alguns alfinetes para si e, como outros alfinetes, assinam outros alfinetes, placas e interesses, visualizam o feed doméstico de todos os alfinetes, placas e interesses aos quais estão inscritos.  Ótimo!  Agora vamos torná-lo escalável! <br><br><h3>  Crescimento doloroso </h3><br>  Em 2011, começamos a ganhar impulso.  Segundo algumas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">estimativas</a> , crescemos mais rápido do que qualquer startup conhecida na época.  Por volta de setembro de 2011, todos os componentes de nossa infraestrutura foram sobrecarregados.  Tínhamos várias tecnologias NoSQL à nossa disposição e todas falharam catastroficamente.  Também tínhamos muitos escravos do MySQL, que costumávamos ler, o que causava muitos erros extraordinários, principalmente quando o cache era feito.  Nós reconstruímos todo o nosso modelo de armazenamento.  Para trabalhar com eficiência, abordamos cuidadosamente o desenvolvimento de requisitos. <br><br><h3>  Exigências </h3><br><ul><li>  Todo o sistema deve ser muito estável, fácil de usar e dimensionar do tamanho de uma caixa pequena ao tamanho da lua à medida que o local cresce. </li><li>  Todo o conteúdo gerado pelo pinner deve estar disponível no site a qualquer momento. </li><li>  O sistema deve suportar a solicitação de N pinos na placa em uma ordem determinística (por exemplo, na ordem inversa do horário de criação ou na ordem especificada pelo usuário).  O mesmo vale para pinners, pinos, etc. </li><li> Para simplificar, você deve se esforçar para atualizar de todas as maneiras possíveis.  Para obter a consistência necessária, serão necessários brinquedos adicionais, como um diário de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">transações</a> distribuídas.  É divertido e (não muito) fácil! </li></ul><br><h3>  Filosofia da Arquitetura e Notas </h3><br>  Como queremos que esses dados abranjam vários bancos de dados, não podemos usar apenas uma junção, chaves estrangeiras e índices para coletar todos os dados, embora possam ser usados ​​para subconsultas que não abrangem o banco de dados. <br><br>  Também precisávamos manter o balanceamento de carga nos dados.  Decidimos que a movimentação de dados, elemento por elemento, tornaria o sistema desnecessariamente complexo e causaria muitos erros.  Se precisássemos mover dados, era melhor mover o nó virtual inteiro para outro nó físico. <br><br>  Para que nossa implementação entre rapidamente em circulação, precisávamos da solução mais simples e conveniente e de nós muito estáveis ​​em nossa plataforma de dados distribuídos. <br>  Todos os dados tiveram que ser replicados na máquina escrava para criar um backup, com alta disponibilidade e despejo no S3 para o MapReduce.  Interagimos com o mestre apenas na produção.  Na produção, você não desejará escrever ou ler em escravo.  Escravo lag, e isso causa bugs estranhos.  Se o sharding for feito, não há sentido em interagir com um escravo na produção. <br><br>  Finalmente, precisamos de uma boa maneira de gerar identificadores exclusivos universais (UUIDs) para todos os nossos objetos. <br><br><h3>  Como fizemos sharding </h3><br>  O que íamos criar, tinha que atender aos requisitos, trabalhar de forma estável, em geral, ser viável e sustentável.  É por isso que escolhemos a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tecnologia</a> MySQL já bastante madura como a tecnologia subjacente.  É intencionalmente cauteloso com as novas tecnologias para o dimensionamento automático do MongoDB, Cassandra e Membase, porque elas estavam longe o suficiente da maturidade (e, no nosso caso, quebraram de maneira impressionante!). <br><blockquote>  Além disso: eu ainda recomendo startups para evitar coisas bizarras - tente usar o MySQL.  Confie em mim.  Eu posso provar isso com cicatrizes. </blockquote>  MySQL - a tecnologia é comprovada, estável e simples - ela funciona.  Além de usá-lo, ele é popular em outras empresas com escalas ainda mais impressionantes.  O MySQL atende totalmente a nossa necessidade de otimizar consultas de dados, selecionar intervalos de dados específicos e transações no nível de linha.  De fato, em seu arsenal, há muito mais oportunidades, mas todos nós não precisamos delas.  Mas o MySQL é uma solução "in a box", então os dados tiveram que ser fragmentados.  Aqui está a nossa solução: <br>  Começamos com oito servidores EC2, uma instância do MySQL em cada: <br><br><img src="https://habrastorage.org/webt/e0/d0/o0/e0d0o0fijurp6mabuvbwecacnfi.png"><br><br>  Cada servidor mestre do MySQL é replicado para o host de backup no caso de uma falha primária.  Nossos servidores de produção apenas lêem ou gravam no master.  Eu recomendo que você faça também.  Isso simplifica e evita erros com atrasos na replicação. <br><br>  Cada entidade do MySQL possui muitos bancos de dados: <br><br><img src="https://habrastorage.org/webt/zf/vl/sx/zfvlsxbhhh6uict7kf9ly6f2y9m.png"><br><br>  Observe que cada banco de dados é nomeado exclusivamente: db00000, db00001 a dbNNNNN.  Cada banco de dados é um fragmento de nossos dados.  Tomamos uma decisão arquitetural, com base na qual apenas parte dos dados cai no fragmento e nunca vai além desse fragmento.  No entanto, você pode obter mais capacidade movendo shards para outras máquinas (falaremos sobre isso mais adiante). <br><br>  Trabalhamos com uma tabela de configuração que indica quais máquinas possuem shards: <br><br><pre><code class="bash hljs">[{“range”: (0,511), “master”: “MySQL001A”, “slave”: “MySQL001B”}, {“range”: (512, 1023), “master”: “MySQL002A”, “slave”: “MySQL002B”}, ... {“range”: (3584, 4095), “master”: “MySQL008A”, “slave”: “MySQL008B”}]</code> </pre> <br>  Essa configuração muda apenas quando precisamos mover shards ou substituir o host.  Se o <code>master</code> morre, podemos usar o <code>slave</code> existente e depois pegar um novo.  A configuração está localizada no <a href="">ZooKeeper</a> e, quando atualizada, é enviada para serviços que atendem ao shard do MySQL. <br><br>  Cada shard possui o mesmo conjunto de tabelas: <code>pins</code> , <code>boards</code> , <code>users_has_pins</code> , <code>users_likes_pins</code> , <code>pin_liked_by_user</code> etc.  Vou falar sobre isso um pouco mais tarde. <br><br>  Como distribuímos dados para esses fragmentos? <br><br>  Criamos um ID de 64 bits que contém o ID do fragmento, o tipo de dados contido nele e o local em que esses dados estão na tabela (ID local).  O ID do shard consiste em 16 bits, o ID do tipo é 10 bits e o ID local é 36 bits.  Os matemáticos avançados perceberão que existem apenas 62 bits.  Minha experiência anterior como desenvolvedor de compiladores e placas de circuito me ensinou que os bits de backup valem seu peso em ouro.  Portanto, temos dois desses bits (definidos como zero). <br><br><pre> <code class="bash hljs">ID = (shard ID &lt;&lt; 46) | (<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> ID &lt;&lt; 36) | (<span class="hljs-built_in"><span class="hljs-built_in">local</span></span> ID&lt;&lt;0)</code> </pre> <br>  Vamos pegar este pino: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://www.pinterest.com/pin/241294492511762325/</a> , vamos analisar seu ID 241294492511762325: <br><br><pre> <code class="bash hljs">Shard ID = (241294492511762325 &gt;&gt; 46) &amp; 0xFFFF = 3429 Type ID = (241294492511762325 &gt;&gt; 36) &amp; 0x3FF = 1 Local ID = (241294492511762325 &gt;&gt; 0) &amp; 0xFFFFFFFFF = 7075733</code> </pre> <br>  Assim, o objeto pin vive no fragmento 3429.  Seu tipo é "1" (ou seja, "Pino") e está na linha 7075733 na tabela de pinos.  Por exemplo, vamos imaginar que esse fragmento está no MySQL012A.  Podemos chegar a ele da seguinte maneira: <br><br><pre> <code class="bash hljs">conn = MySQLdb.connect(host=”MySQL012A”) conn.execute(“SELECT data FROM db03429.pins <span class="hljs-built_in"><span class="hljs-built_in">where</span></span> local_id=7075733”)</code> </pre> <br><br>  Existem dois tipos de dados: objetos e mapeamentos.  Os objetos contêm partes, como dados de pinos. <br><br><h4>  Tabelas de Objetos </h4><br>  As tabelas de objetos, como Pins, usuários, quadros e comentários, têm um ID (ID local, com uma chave primária que aumenta automaticamente) e um blob que contém JSON com todos os dados do objeto. <br><br><pre> <code class="bash hljs">CREATE TABLE pins ( local_id INT PRIMARY KEY AUTO_INCREMENT, data TEXT, ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP ) ENGINE=InnoDB;</code> </pre> <br>  Por exemplo, os objetos pin são assim: <br><br><pre> <code class="bash hljs">{“details”: “New Star Wars character”, “link”: “http://webpage.com/asdf”, “user_id”: 241294629943640797, “board_id”: 241294561224164665, …}</code> </pre> <br>  Para criar um novo pino, coletamos todos os dados e criamos um blob JSON.  Em seguida, selecionamos o ID do shard (preferimos escolher o mesmo ID do shard no quadro em que ele está colocado, mas isso não é necessário).  Para o tipo de pino 1. Nós nos conectamos a esse banco de dados e inserimos JSON na tabela de pinos.  O MySQL retornará um ID local aumentado automaticamente.  Agora temos um fragmento, um tipo e um novo ID local, para que possamos compilar um identificador completo de 64 bits! <br><br>  Para editar o pino, lemos-modificamos-escrevemos JSON usando a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">transação MySQL</a> : <br><br><pre> <code class="bash hljs">&gt; BEGIN &gt; SELECT blob FROM db03429.pins WHERE local_id=7075733 FOR UPDATE [Modify the json blob] &gt; UPDATE db03429.pins SET blob=<span class="hljs-string"><span class="hljs-string">'&lt;modified blob&gt;'</span></span> WHERE local_id=7075733 &gt; COMMIT</code> </pre> <br>  Para remover um alfinete, você pode excluir sua linha no MySQL.  No entanto, é melhor adicionar o campo <i>"ativo"</i> no JSON e configurá-lo como <i>"falso"</i> , além de filtrar os resultados no lado do cliente. <br><br><h4>  Tabelas de mapeamento </h4><br>  A tabela de mapeamento vincula um objeto a outro, por exemplo, uma placa com pinos.  A tabela MySQL para mapeamentos contém três colunas: 64 bits para o ID "from", 64 bits para o ID "where" e o ID da sequência.  Nesta tripla (de onde, onde, sequência), existem chaves de índice e elas estão no fragmento do identificador "de". <br><br><pre> <code class="bash hljs">CREATE TABLE board_has_pins ( board_id INT, pin_id INT, sequence INT, INDEX(board_id, pin_id, sequence) ) ENGINE=InnoDB;</code> </pre> <br>  As tabelas de mapeamento são unidirecionais, por exemplo, como a tabela <code>board_has_pins</code> .  Se você precisar da direção oposta, precisará de uma tabela separada <code>pin_owned_by_board</code> .  O ID da sequência define a sequência (nossos IDs não podem ser comparados entre os shards, porque os novos IDs locais são diferentes).  Normalmente, inserimos novos pinos em uma nova placa com um ID de sequência igual ao tempo no unix (registro de data e hora unix).  Qualquer número pode estar na sequência, mas o tempo unix é uma boa maneira de armazenar novos materiais sequencialmente, pois esse indicador aumenta monotonamente.  Você pode dar uma olhada nos dados na tabela de mapeamento: <br><br><pre> <code class="bash hljs">SELECT pin_id FROM board_has_pins WHERE board_id=241294561224164665 ORDER BY sequence LIMIT 50 OFFSET 150</code> </pre> <br>  Isso fornecerá mais de 50 pinos_id, que você poderá usar para procurar objetos de pinos. <br>  O que acabamos de fazer é uma junção da camada de aplicação (board_id -&gt; pin_id -&gt; pin objects).  Uma das propriedades surpreendentes das conexões no nível do aplicativo é que você pode armazenar em cache a imagem separadamente do objeto.  Armazenamos pin_id no cache do objeto pin no cluster memcache, no entanto, salvamos board_id em pin_id no cluster redis.  Isso nos permite escolher a tecnologia certa que melhor se adequa ao objeto em cache. <br><br><h3>  Aumentar capacidade </h3><br>  Existem três maneiras principais de aumentar a capacidade em nosso sistema.  A maneira mais fácil de atualizar a máquina (para aumentar o espaço, colocar discos rígidos mais rápidos, mais RAM). <br>  A próxima maneira de aumentar a capacidade é abrir novos intervalos.  Inicialmente, criamos um total de 4096 shards, apesar do ID do shard consistir em 16 bits (um total de 64k shards).  Novos objetos só podem ser criados nesses primeiros 4k shards.  Em algum momento, decidimos criar novos servidores MySQL com shards de 4096 a 8191 e começamos a preenchê-los. <br><br>  A última maneira de aumentar a capacidade é transferir alguns fragmentos para novas máquinas.  Se queremos aumentar a capacidade do MySQL001A (com shards de 0 a 511), criamos um novo par mestre-mestre com os seguintes nomes máximos possíveis (por exemplo, MySQL009A e B) e iniciamos a replicação do MySQL001A. <br><br><img src="https://habrastorage.org/webt/d2/uf/gd/d2ufgd1tttsa6tmxvpywfzgqugs.png"><br><br>  Assim que a replicação é concluída, alteramos nossa configuração para que no MySQL001A existam apenas shards de 0 a 255 e no MySQL009A de 256 a 511. Agora, cada servidor deve processar apenas metade dos shards processados ​​anteriormente. <br><br><img src="https://habrastorage.org/webt/4f/cp/do/4fcpdo2g16molbdkkfbf8xvujbi.png"><br><br><h3>  Alguns recursos interessantes </h3><br>  Aqueles que já possuíam sistemas para gerar novos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">UUIDs</a> entenderão que neste sistema os obtemos sem nenhum custo!  Quando você cria um novo objeto e o insere na tabela de objetos, ele retorna um novo identificador local.  Esse ID local, combinado com o ID do shard e o ID do tipo, fornece um UUID. <br><br>  Aqueles de vocês que executaram ALTERs para adicionar mais colunas às tabelas MySQL sabem que eles podem trabalhar extremamente devagar e se tornar um grande problema.  Nossa abordagem não requer nenhuma alteração no nível do MySQL.  No Pinterest, provavelmente fizemos apenas um ALTER nos últimos três anos.  Para adicionar novos campos aos objetos, diga aos seus serviços que existem vários novos campos no esquema JSON.  Você pode alterar o valor padrão para que, ao desserializar o JSON de um objeto sem um novo campo, obtenha o valor padrão.  Se você precisar de uma tabela de mapeamento, crie uma nova tabela de mapeamento e comece a preenchê-la sempre que desejar.  E quando terminar, você pode enviar! <br><br><h3>  Fragmento de modificação </h3><br>  É quase como um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esquadrão de mods</a> , apenas completamente diferente. <br><br>  Alguns objetos precisam ser encontrados sem um ID.  Por exemplo, se um usuário efetuar login com uma conta do Facebook, precisamos mapear do ID do Facebook para o Pinterest.  Para nós, os IDs do Facebook são apenas bits, então os armazenamos em um sistema de fragmentos separado chamado mod shard. <br><br>  Outros exemplos incluem endereços IP, nome de usuário e endereço de email. <br>  O Mod Shard é muito semelhante ao sistema de sharding descrito na seção anterior, com a única diferença: você pode procurar dados usando dados de entrada arbitrários.  Essa entrada é dividida em hash e modificada de acordo com o número total de shards no sistema.  Como resultado, um fragmento será obtido no qual os dados estarão ou já estão localizados.  Por exemplo: <br><br><pre> <code class="bash hljs">shard = md5(“1.2.3.4<span class="hljs-string"><span class="hljs-string">") % 4096</span></span></code> </pre> <br>  Nesse caso, o shard será igual a 1524. Processamos o arquivo de configuração correspondente ao ID do shard: <br><br><pre> <code class="bash hljs">[{“range”: (0, 511), “master”: “msdb001a”, “slave”: “msdb001b”}, {“range”: (512, 1023), “master”: “msdb002a”, “slave”: “msdb002b”}, {“range”: (1024, 1535), “master”: “msdb003a”, “slave”: “msdb003b”}, …]</code> </pre> <br>  Portanto, para encontrar dados no endereço IP 1.2.3.4, precisamos fazer o seguinte: <br><br><pre> <code class="bash hljs">conn = MySQLdb.connect(host=”msdb003a”) conn.execute(“SELECT data FROM msdb001a.ip_data WHERE ip=<span class="hljs-string"><span class="hljs-string">'1.2.3.4'</span></span>”)</code> </pre> <br>  Você está perdendo algumas boas propriedades do ID do shard, como localidade espacial.  Você terá que começar com todos os shards criados no início e criar a chave você mesmo (ela não será gerada automaticamente).  É sempre melhor representar objetos no seu sistema com IDs imutáveis.  Portanto, você não precisa atualizar muitos links quando, por exemplo, o usuário altera seu "nome de usuário". <br><br><h3>  Últimos pensamentos </h3><br>  Este sistema produz produção no Pinterest há 3,5 anos e provavelmente permanecerá lá para sempre.  A implementação foi relativamente simples, mas foi difícil colocá-lo em operação e mover todos os dados de máquinas antigas.  Se você encontrar um problema ao criar um novo shard, considere criar um cluster de máquinas de processamento de dados em segundo plano (dica: use <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pyres</a> ) para mover seus dados com scripts de bancos de dados antigos para o novo shard.  Eu garanto que alguns dados serão perdidos, não importa o quanto você tente (é tudo gremlins, eu juro), então repita a transferência de dados várias vezes até que a quantidade de novas informações no fragmento se torne muito pequena ou não seja. <br><br>  Todo esforço foi feito para esse sistema.  Mas não fornece atomicidade, isolamento ou coerência de forma alguma.  Uau!  Isso parece ruim!  Mas não se preocupe.  Certamente, você se sentirá excelente sem eles.  Você sempre pode criar essas camadas com outros processos / sistemas, se necessário, mas, por padrão e sem nenhum custo, já obtém bastante: capacidade de trabalho.  Confiabilidade alcançada através da simplicidade e até funciona rápido! <br><br>  Mas e a tolerância a falhas?  Criamos um serviço para manutenção de shards do MySQL, salvamos a tabela de configuração de shard no ZooKeeper.  Quando o servidor mestre falha, aumentamos a máquina escrava e, em seguida, aumentamos a máquina que a substituirá (sempre atualizada).  Não usamos o processamento automático de falhas até hoje. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt467389/">https://habr.com/ru/post/pt467389/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt467377/index.html">Três em linha: os 10 principais relatórios do Mobius 2019 Piter</a></li>
<li><a href="../pt467381/index.html">LEDs de vários andares, luzes inteligentes e lâmpadas por 18 rublos</a></li>
<li><a href="../pt467383/index.html">“O gerente precisa continuar codificando”: entrevista com Stephen Chin</a></li>
<li><a href="../pt467385/index.html">Uma seleção de perguntas técnicas psicológicas e atípicas em entrevistas com desenvolvedores Java</a></li>
<li><a href="../pt467387/index.html">Soluções para trabalhar com feedback e experiência do cliente: de pequenos serviços a plataformas pesadas</a></li>
<li><a href="../pt467391/index.html">Yandex apresenta RPKI</a></li>
<li><a href="../pt467393/index.html">NX Bootcamp começa em outubro</a></li>
<li><a href="../pt467395/index.html">Habr Weekly # 18 / New Apple Gadgets, um smartphone totalmente modular, a vila de programadores na Bielorrússia, o fenômeno XY</a></li>
<li><a href="../pt467399/index.html">Você não pode proibir: como implementar o conceito BYOD e não prejudicar a segurança das informações</a></li>
<li><a href="../pt467401/index.html">Comparação de Tesla Model S e Porsche Taycan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>