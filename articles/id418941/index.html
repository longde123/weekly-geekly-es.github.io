<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â›ˆï¸ ğŸ‘¨â€â¤ï¸â€ğŸ‘¨ ğŸ‘†ğŸ¼ Jangan takut dengan microservice: Alexey Baitov tentang penggunaan arsitektur microservice dalam praktiknya ğŸ  â° ğŸ–•ğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagi sebagian orang, layanan microser adalah kemampuan untuk mengulang dan memperbaiki aplikasi ke gaya yang relatif modern. Solusi arsitektur ini tid...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jangan takut dengan microservice: Alexey Baitov tentang penggunaan arsitektur microservice dalam praktiknya</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/418941/"> Bagi sebagian orang, layanan microser adalah kemampuan untuk mengulang dan memperbaiki aplikasi ke gaya yang relatif modern.  Solusi arsitektur ini tidak cocok untuk orang lain karena kekhasan interaksi berbagai bagian aplikasi.  Dalam kasus apa pun, memilih arsitektur, akan berguna untuk mempelajari pengalaman orang lain dari transisi dari monolit ke serangkaian layanan. <br><br>  Kami diminta untuk berbagi studi kasus kami tentang pengembangan dan pengiriman layanan mikro Alexei Baitov, insinyur utama 2GIS.  Mari kita bicara tentang solusi arsitektur, penyebaran, dan skalabilitas.  Mari kita bertanya tentang trending dan alat yang nyaman untuk bekerja. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f87/346/860/f8734686085fb6cf3580ff6fa636e8bf.jpg"><br><a name="habracut"></a><br>  <b>- Alexey, tolong beri tahu kami sedikit tentang diri Anda dan tentang tim Anda di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2GIS</a> .</b>  <b>Apa yang sedang kamu kerjakan sekarang?</b> <br><br><img src="https://habrastorage.org/webt/gk/aa/_8/gkaa_8zwcfej8txrfq901zub1qs.jpeg" align="left">  Saya datang ke IT pada tahun 2003 sebagai administrator sistem, saya terjun ke pengembangan pada tahun 2011.  Selama ini, ia bekerja di PHP, JavaScript, mengimplementasikan serangkaian layanan RESTful dan driver Python untuk Git.  Saya telah bekerja di 2GIS sejak 2015. <br><br>  Dia berpartisipasi dalam pengembangan dua arsitektur layanan-mikro.  Yang pertama terdiri dari satu layanan.  Itu adalah proxy terbalik asinkron dengan cache.  Bahkan, dia terlibat dalam pengiriman pesan.  Saya adalah satu-satunya yang terlibat dalam mengerjakan persyaratan, mengembangkan dan membangun DevOps, tetapi para ahli dari perusahaan 2GIS kami membantu saya. <br><br>  Layanan ini ditulis dalam Go.  Kompilasi cepat memungkinkan saya untuk tidak menunggu, dan saya dapat berkonsentrasi pada Penerapan Berkelanjutan.  Kemudian kami baru mulai menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitLab CI</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Prometheus</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Grafana</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Deis</a> (analog open source <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Heroku</a> ).  Kami memiliki tim Infrastruktur dan Operasi, yang pada saat pengembangan saya membawa semua solusi infrastruktur ini ke tingkat siap produksi.  Saya memutuskan untuk mencoba semua ini dan berhasil mengimplementasikan microservice independen. <br><br>  Dua tahun lalu, saya pindah ke tim lain pada proyek baru, di mana saya mulai terlibat dalam pemrograman fungsional di Scala.  Tim kami dari awal telah mengembangkan arsitektur layanan mikro untuk penyimpanan materi iklan 2GIS di Scala, C # dan JavaScript.  Saya meletakkan dasar semua layanan dengan alat dan pengalaman yang diperoleh untuk membangun praktik DevOps (Penyebaran dan pemeliharaan berkelanjutan).  Arsitektur telah berubah dari prototipe ke operasi industri.  Dia menyerap dua monolit, sekarang terdiri dari 15 layanan dan terus berkembang. <br><br>  <b>- Apakah Anda setuju bahwa layanan microser pada dasarnya adalah serangkaian layanan yang disebarkan secara independen yang memiliki karakteristik umum, yaitu, serangkaian fitur tertentu memberi mereka tampilan layanan mikro?</b>  <b>Apakah definisi ini perlu diperluas?</b>  <b>Atau, pada kenyataannya, apakah perusahaan memiliki pemahaman yang berbeda tentang arsitektur layanan-mikro?</b> <br><br>  Saya suka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">definisi</a> berikut.  Arsitektur microservice adalah gaya arsitektur yang menyusun aplikasi sebagai kumpulan layanan yang digabungkan secara longgar yang menerapkan logika bisnis tertentu.  Layanan dalam arsitektur layanan mikro mungkin tidak memiliki karakteristik umum, tetapi digabungkan dalam logika bisnis bersama. <br><blockquote>  Tentu saja, setiap perusahaan akan memiliki microservice sendiri.  Ini adalah seperangkat praktik: arsitektur terdistribusi, integrasi dan pengiriman berkelanjutan, dan sebagainya.  Jika Anda memperluas konsep praktik ke alat yang digunakan, opsi untuk mengimplementasikan layanan microser akan sangat beragam. </blockquote>  <b>- Ada berbagai pendapat tentang komposisi tim, yang harus dilibatkan dalam penulisan dan dukungan layanan mikro.</b>  <b>Apa yang Anda pikirkan tentang ini?</b>  <b>Berapa ukuran tim yang optimal dan bagaimana seharusnya dibangun oleh interaksi di dalamnya ketika mengembangkan arsitektur layanan mikro?</b>  <b>Apakah ada contoh kerja tim yang baik dari latihan Anda?</b> <br><br>  Itu dianggap benar untuk mengembangkan layanan sedemikian rupa sehingga seluruh area subjeknya dapat masuk dalam kepala satu pengembang.  Pada saat yang sama, beberapa orang dapat berpartisipasi dalam pengembangan layanan ini.  Ini akan membantu untuk menghindari faktor bus ketika pengembang pergi berlibur atau jatuh sakit.  Rincian yang benar ke dalam layanan memungkinkan orang baru untuk dengan cepat memasuki konteks. <br><br>  Arsitektur microservice memberi tahu kita bahwa sering menyertakan beberapa layanan.  Dengan demikian, satu pengembang tidak bisa melakukannya.  Arsitektur microservice dibangun berdasarkan model produk (atau logika bisnis umum).  Pengembang dipilih sehingga ternyata mengimplementasikan model ini dan pada saat yang sama fokus pada klien. <br><br>  Berfokus pada klien diatur melalui kontak langsung antara pengembang dan klien.  Pengembang perlu melihat bagaimana produk mereka digunakan.  Dari ini, keinginan untuk pengetahuan di bidang teknologi, kemampuan untuk mengirimkan produk kepada klien dan menemani produk sesegera mungkin mengikuti. <br><br>  Sulit untuk mengatakan tentang ukuran tim.  Semua orang mungkin sudah mengetahui pernyataan Jeff Bezos, pendiri Amazon, bahwa ukuran tim dalam pengembangan berorientasi layanan harus cukup kecil sehingga setiap orang dapat diberi makan dua pizza.  Dalam komentar di HabrÃ©, ada diskusi tentang topik ini, dan mereka menulis bahwa satu orang mungkin tidak memiliki cukup satu pizza dan oleh karena itu tim harus terdiri dari satu atau dua orang.  Martin Fowler, mengutip pernyataan tentang dua pizza, mengatakan bahwa itu tentang pizza besar Amerika, setelah itu ia menetapkan bahwa tim tidak boleh memiliki 50, tetapi sekitar 12 orang.  Saya percaya bahwa itu semua tergantung pada model produk.  Tetapi klarifikasi Fowler tentang "tidak lebih dari 12 orang" telah memenangkan latihan saya sejauh ini.  Saya perhatikan bahwa di dalam tim diinginkan untuk membagi sesuai dengan minat teknologi, untuk menemukan orang yang berpikiran sama. <br><br>  Tidak perlu bahwa setiap orang di tim tahu semua bidang teknologi yang digunakan dalam pekerjaan, tetapi pengetahuan total tim harus mendalam secara seragam.  Misalnya, dua orang terlibat dalam pembangunan awal penyebaran dan di masa depan, kemungkinan besar, mereka juga akan meningkatkannya secara signifikan.  Tetapi pada saat yang sama, seluruh tim harus memiliki pemahaman yang baik tentang proses penempatan.  Ini akan memungkinkannya untuk mengekspresikan keinginannya dan membuat perubahan.  Kenapa dua orang?  Karena kadang-kadang satu orang bisa jatuh pingsan secara kreatif.  Dan dalam diskusi, kebenaran lahir. <br><br>  Kami secara alami membangun berdasarkan prinsip ini, disatukan oleh kepentingan teknologi.  Pada saat yang sama, pengembang juga dapat terlibat dalam membangun praktik-praktik DevOps, dan insinyur QA dapat mengembangkan layanan tambahan, non-produksi (misalnya, memanaskan cache atau layanan mencari anomali dalam data di lingkungan yang berbeda). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c0c/d3d/188/c0cd3d1883cefa481f26765dda16cba2.png"><br><br>  <b>- Hampir setiap laporan tentang layanan-layanan microser dimulai dengan cerita bahwa â€œdi sini kami memiliki gunung es dan kami menggergaji, menggergaji, menggergaji ... Bagian-bagian baru dari aplikasi dibuat berdasarkan pada layanan-layanan mikro, dan kemudian kami mulai memisahkanâ€œ potongan-potongan â€dari mesin utama ... "</b> <b><br><br></b>  <b>Katakan padaku, apakah Anda seorang pendukung pengembangan dari awal atau dapatkah ada situasi ketika layak membuat kesimpulan bertahap dari sebuah monolit?</b>  <b>Bagaimana cara menentukan strategi keluar?</b> <br><br>  Saya seorang pendukung pengembangan dari awal.  Tapi ini hanya berfungsi jika himpunan fungsi tidak terlalu rumit.  Biasanya monolit MVP kecil dibuat.  Dan kadang-kadang perlu untuk secara radikal mengubah implementasi internal beberapa kali.  Ini dapat disebabkan oleh perubahan dalam tugas teknis, dan oleh kenyataan bahwa pemahaman implementasi datang - abstraksi tingkat tinggi muncul di tingkat model bisnis.  Setelah itu, Anda dapat beralih ke arsitektur microservice. <br><br>  Tetapi jika Anda mengerjakan abstraksi ini di awal dan menggambarnya dalam notasi yang berbeda (UML, BPMN, IDEF), sehingga semua peserta dalam proses memahami apa yang mereka kerjakan, sangat mungkin untuk mengimplementasikan arsitektur layanan mikro segera. <br><br>  Jalan kami ke arsitektur layanan mikro tidak lurus.  Awalnya ada monolit.  Dia memproses materi iklan tekstual.  Tiga setengah tahun yang lalu, kami perlu bekerja dengan materi iklan grafis (gambar, logo).  Ada keinginan untuk memperkenalkan ke dalam logika bisnis apa yang kurang ketika bekerja dengan materi iklan teks. <br><blockquote>  Untuk menguji model bisnis baru, kami menerapkan pekerjaan dengan materi iklan grafis sebagai monolit kedua pada tumpukan teknologi lainnya.  Setelah satu setengah tahun beroperasi, kami menyadari bahwa pendekatan ini benar. </blockquote>  Selama ini, kami mendapat banyak Daftar Keinginan, mengungkapkan kekasaran logika bisnis. <br><br>  Implementasi monolit kedua sulit diperluas ke yang pertama.  Oleh karena itu, kami memutuskan untuk tidak melakukan pengembangan dalam dua monolit sekaligus, tetapi menggabungkannya dalam kerangka arsitektur ketiga sesuai dengan model bisnis yang sangat baru.  Sebuah tim yang terdiri dari tujuh pengembang, satu insinyur QA dan dua analis telah dibuat.  Dua pengembang dari tim ini sebelumnya membuat dan mendukung monolit pertama, dan satu lagi - monolit kedua.  Artinya, tim kami yang sudah di pintu masuk tahu betul perangkap dari monolith sebelumnya. <br><br>  Monolit pertama ditulis dalam bahasa C #.  Yang kedua adalah di PHP.  Kami tidak ingin kehilangan kepingan kode yang beraneka ragam dari monolith pertama, dan pada saat yang sama multithreading, kode aman, dan pengetikan yang kuat diperlukan.  Kode PHP sebagian tidak termasuk dalam persyaratan ini.  Oleh karena itu, C # tetap sebagai dasar dan menerapkan apa yang dilakukannya dengan baik dalam kerangka monolit pertama - bekerja dengan konten materi iklan - tetapi berdasarkan penyimpanan lain: penyimpanan yang kompatibel dengan S3 dan Kafka. <br><br>  Untuk bekerja dengan model bisnis yang sangat baru, Scala dan database PostgreSQL dipilih kali ini.  Scala memenuhi persyaratan teknis kami.  Selain itu, pengembang Scala berada di lantai yang sama dengan pengembang C #.  Ini mengurangi waktu untuk komunikasi tim.  Hukum Conway berfungsi - struktur perusahaan menentukan struktur aplikasi.  Pengembang PHP telah dibangun kembali menjadi pengembang Scala.  Saya baru saja menyelesaikan pekerjaan dengan layanan mikro mandiri di Golang dengan siklus CI / CD penuh, setelah itu saya bergabung dengan tim dan juga menjadi pengembang Scala. <br><br>  Sangat menarik apa sebenarnya yang saya usulkan untuk digunakan untuk bekerja dengan logika bisnis Scala, dan bukan C #.  Faktanya adalah bahwa kami tidak memiliki cukup pengembang C #.  PHP-shnik dan saya ingin melatih kembali untuk Scala.  Plus, kami memiliki kesempatan untuk menarik pengembang Scala yang berpengalaman.  Poin lain: jika kita mengimplementasikan semuanya dalam C #, maka kita bisa mendapatkan arsitektur microservice atau monolith lain di output.  Pembagian menjadi Scala dan C #, kebutuhan penyimpanan yang berbeda dan ketersediaan pengembang berpengalaman di setiap bidang yang diperlukan - semua ini secara langsung menunjuk ke arsitektur layanan-mikro.  Dan kami hanya mendapat manfaat dari ini.  Setahun yang lalu, arsitektur microservice untuk bekerja dengan bahan grafis dan tekstual masuk ke operasi komersial dan telah berhasil beroperasi hingga hari ini. <br><br>  Untuk pertanyaan apakah mungkin untuk membuat arsitektur layanan microser dari awal.  Setahun setengah yang lalu, dalam proses mengerjakan arsitektur layanan-mikro, kami muncul dengan permintaan untuk mendukung arah baru dalam produk kami - materi iklan video.  Itu perlu untuk dengan cepat menguji model penjualan baru.  Arsitektur kami masih bayi.  Bekerja dengan materi video mencakup bidang teknologi baru.  Kami memutuskan untuk tidak mengubah vektor pengembangan dan mengimplementasikan MVP untuk materi video sebagai arsitektur layanan mikro yang berdiri sendiri di C # dan hosting video tepercaya.  Ini adalah pengalaman yang sukses, dan kami memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan</a> tentang topik ini.  Dengan demikian, kami memiliki dua arsitektur layanan mikro paralel yang ada.  MVP tidak berkembang banyak, Wishlist juga terakumulasi di atasnya, dan segera kami akan menggabungkan semuanya dalam kerangka arsitektur layanan-mikro tunggal - kami akan mendapatkan satu repositori teks iklan, grafik, dan materi video. <br><br>  <b>- Segera, ada dua faktor penting yang mendukung microservices.</b>  <b>Yang pertama adalah kemampuan untuk mengeluarkan bagian-bagian individual ke cloud dan, sebagai hasilnya, skalabilitas kolosal.</b>  <b>Yang kedua adalah kemampuan untuk membuat layanan terpisah dalam bahasa lain.</b>  <b>Apa keuntungan lain dari beralih ke layanan microser yang Anda lihat?</b>  <b>Ya, dari minusnya, tentu saja, saya juga ingin mendengar.</b> <br><br>  Jika kita berbicara tentang komponen teknologi, maka kelebihannya, selain yang di atas, termasuk kemungkinan menggunakan tumpukan teknologi lainnya.  Dan jika dia tidak cocok dengan kita, kita akan memilih yang lain.  Teknologi baru memintas masalah solusi lama.  Arsitektur microservice juga memberikan stabilitas dan kemandirian: degradasi satu layanan tidak boleh mengarah pada degradasi lengkap seluruh sistem.  Kompabilitas layanan memungkinkan penggunaan kembali fungsionalitas layanan dalam arsitektur layanan-mikro lainnya.  Dari sudut pandang komponen organisasi, membagi ke dalam layanan memungkinkan Anda untuk membagi pengembangan dalam tim terdistribusi atau satu tim besar. <br><blockquote>  Kerugian utama dari arsitektur layanan-mikro: jauh lebih rumit, dan implementasinya lebih mahal. </blockquote>  Anda juga harus siap untuk mendukung kontrak layanan, memilih protokol akses jarak jauh yang benar, menyelesaikan masalah interaksi antar-layanan yang aman, kemungkinan kegagalan, serta menduplikat dan mengelola transaksi yang didistribusikan. <br><br>  Secara umum, dalam domain publik Anda dapat menemukan banyak informasi dan materi tentang cara bekerja dengannya.  Tapi sebenarnya itu semua tergantung tugas.  Dalam praktik saya, plus selalu lebih signifikan daripada minus. <br><br>  Masih layak untuk mengingat kata-kata Sam Newman: semakin sedikit layanannya, semakin banyak semua kelebihan dan kekurangan dari arsitektur layanan-mikro dimanifestasikan. <br><br>  <b>- Anda memiliki beberapa laporan menarik tentang layanan mikro.</b>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penerapan layanan microser</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pendekatan Penerapan Berkelanjutan dalam arsitektur layanan microser</a> .</b>  <b>Pada salah satu slide yang pertama ada templat penyebaran, dan dalam laporan Anda mengatakan bahwa bagi Anda pendekatan tren adalah distribusi melalui kontainer.</b>  <b>Selama ini, tidak ada yang berubah?</b>  <b>Sekelompok Docker + Kubernetes belum kehilangan relevansinya?</b> <br><br>  Kami mentransfer semakin banyak layanan ke bundel ini.  Saya pikir kami telah memilih arah yang benar dan untuk saat ini kami berencana untuk mematuhinya.  Jika ada perubahan, saya akan memberi tahu Anda tentang hal itu dalam laporan atau wawancara baru. <br><br>  <b>- Seberapa halus penyebaran dan transfer layanan microser yang berkelanjutan ke prod?</b> <br><br>  Itu semua tergantung pada bagaimana membangun proses.  Pada awalnya tampaknya semuanya sederhana.  Layanan bersifat independen, digunakan secara terpisah.  Koherensi yang lemah dijamin oleh berbagai pendekatan untuk bekerja dengan evolusi kontrak.  Dan di sini Anda harus memilih.  Misalnya, Anda dapat menerapkan versi kontrak atau menambahkan layanan untuk memutuskan kontrak (decoupling kontrak). <br><br>  Jika dalam arsitektur microservice dalam pengembangan aktif ada 10 atau lebih layanan sekaligus dan masing-masing memiliki versi sendiri, maka ada masalah konsistensi versi.  Kita harus berusaha untuk tidak menjadi bingung dalam kompatibilitas layanan dari versi yang berbeda. <br><br>  Penerapan berkelanjutan berarti bahwa kami dapat mengirimkan aplikasi kapan saja ke lingkungan apa pun. <br><blockquote>  Aplikasi dalam arsitektur microservice adalah kumpulan layanan.  Jadi, pada waktu tertentu, kita perlu mengetahui kombinasi stabil dari versi layanan.  Dan di tempat lain kita harus memiliki satu set alamat domain dan parameter lain khusus untuk lingkungan yang berbeda untuk mengkonfigurasi layanan dan menghubungkannya satu sama lain. </blockquote>  Semua ini perlu disimpan di suatu tempat, untuk memperbaiki perubahan di beberapa tempat (layanan microser independen setelah semua) dan tidak menjadi bingung. <br><br>  Penerapan berkelanjutan berarti kemampuan untuk memutar kembali ke versi apa pun kapan saja.  Oleh karena itu, mungkin Anda perlu memutar kembali beberapa layanan sekaligus dan Anda harus memperhatikan urutan terbalik penyebaran layanan yang benar. <br><br>  Dalam salah satu laporan saya, saya berbicara tentang pendekatan kami terhadap evolusi kontrak, bagaimana mereka memecahkan masalah konsistensi versi dan bagaimana mereka membangun proses penyebaran dalam arsitektur layanan mikro lebih dari sepuluh layanan.  Penempatan berkelanjutan mungkin tidak bebas masalah, tetapi semuanya dapat dipecahkan. <br><br>  <b>- Apa yang bisa menjadi seperangkat alat awal untuk penyebaran microservices yang berkelanjutan?</b>  <b>Opsi apa yang akan Anda rekomendasikan untuk digunakan dengan bekerja dengan layanan microser?</b> <br><br>  Penyebaran berkelanjutan adalah urutan jalur pipa, termasuk integrasi berkelanjutan, tes integrasi, dan pengiriman layanan ke lingkungan orkestrasi.  Alat urutan langkah yang paling populer adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jenkins 2 Pipelines</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TeamCity Build Chains</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pipelines Bitbucket</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pipeline</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitLab CI</a> .  Pertama, Anda perlu mengotomatiskan integrasi berkelanjutan (CI).  Kami membutuhkan server CI jarak jauh untuk membangun dan menjalankan tes pada perakitan ini. <br><br>  Alat yang terdaftar menawarkan solusi mereka.  Kami menggunakan GitLab CI, dan GitLab Runners bertindak sebagai server seperti itu.  Artefak build adalah gambar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Docker</a> .  Sebagai bagian dari tes integrasi, Anda dapat melakukan tes beban dan kapasitif menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gatling</a> , khususnya, untuk menentukan sumber daya yang dibutuhkan (prosesor dan memori) untuk berfungsi dalam lingkungan orkestrasi (misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kubernetes</a> ).  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Helm</a> banyak digunakan untuk penyebaran, memungkinkan Anda untuk menggambarkan arsitektur layanan mikro untuk lingkungan yang berbeda.  Di perusahaan kami, kami tidak menggunakan Helm.  Kami memiliki alat penyebaran kami sendiri, yang dibuat ketika Helm dalam versi Klasik dan tidak mendukung lingkungan yang berbeda.  Kedua alat ini memiliki kualitas bermanfaat yang serupa, tetapi implementasi dan distribusinya berbeda.  Dan alat kami sendiri memungkinkan kami untuk melakukan perbaikan dan menyesuaikan segalanya dengan infrastruktur kami. <br><br>  <b>- Teknologi apa yang optimal untuk perusahaan kecil dan menengah yang ingin mengimplementasikan layanan microser?</b>  <b>Apakah ini terlalu mahal untuk kesenangan mereka?</b> <br><br>  Semakin banyak, saya menemukan konfirmasi bahwa perusahaan kecil dan menengah tidak pantas untuk meningkatkan lingkungan orkestrasi mereka sendiri (misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kubernetes</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Docker Swarm</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apache Mesos</a> ).                  .       (  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Google Cloud Platform</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Amazon Web Services</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Microsoft Azure</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Oracle Cloud</a> )    . <br><br>     GitLab  GitLab CI.               . GitLab     Helm    .    Helm    .  Helm   ,           ,     ,        . <br><br>     ,     ,    ,      open source,       . <br><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spinnaker</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Heroku</a> â€”  ,    ,       . <br><br> <b>â€”   ,        ,    ,  .             .     ?</b> <br><br>      ,        .     ,          ,           . <br><br>      (       )       .               . <br><br>        .       .          ,    (package).                . <br><br>   ( )   Docker-,           Git.     ,      .       ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> .  ,              . <br><br>             ,       .  :       API.                  .       :    .     ,     API.  ,   API   ,   â€” .      ,         API,             . <br><br>         .     ,       ;         API,      ;   ,     ,     . <br><br> <b>,    ,        .    ,      ?</b> <br><br>  â€”  - .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>  ,        API,      ,            .    .            . <br><br> ,   ,      .       ,    ,              .    ,      ,      . <br><br> <b>â€”         ,      .   2. ,       ?   ?</b> <br><br>      .    .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mesosphere</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OpenShift</a>       PaaS  IaaS .    Deis     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   Deis</a>    .  open source  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Heroku</a> ,       Heroku Buildpack', Dockerfile'   Docker-.        .    make            Deis.       . <br><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Deis2</a> .       Deis,        Kubernetes. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> Infrastructure &amp; Operations</a> ,         ,       Kubernetes  Deis2. ,     ,     Deis2,    ,     â€”    Kubernetes.   . Deis2   :       , pod          pod'   namespace.         Infrastructure &amp; Operations. Kubernetes    .         Deis2  Kubernetes.       Deis2   Kubernetes. <br><br> <b>â€” ,          ,       ,      ?      ?</b> <br><br>      Helm.     ,        .  Helm       . <br><blockquote> Helm    ,    â€”   :        ,   . </blockquote>  Helm   chart'     chart,         ,   . <br><br>   2        ,         10 .       (          backing : Postgres, Kafka, Zookeeper, Ceph).  -   ,  yaml-    ,      IDE,       .  ,    .  Python,          Python       .   ,      .      ,    . ,     .       ,     ,       .          .   , ,   ,         (  )   .  ,    ,  Helm,        Kubernetes  -  ,    yaml. <br><br>     API        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API Gateway</a> .        ,   â€”  . <br><br>        ,    :    .       ,  ,     . <br><blockquote>  DevOps     ,         .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DevOpsConf Russia</a> . <br><br> DevOpsConf Russia  <b>1  2    </b>      RootConf,  , , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> ,   .    DevOps       ,   . <br><br>     DevOps  ,      ,      â€“     .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>  15 . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418941/">https://habr.com/ru/post/id418941/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418929/index.html">Unit Testing dan Python</a></li>
<li><a href="../id418931/index.html">RubyMine 2018.2: melampirkan debugger ke proses jarak jauh, chruby, analisis kode ditingkatkan dan banyak lagi</a></li>
<li><a href="../id418933/index.html">Ulasan OnePlus 6. Ketika orang Cina melakukan semuanya sama seperti terakhir kali</a></li>
<li><a href="../id418935/index.html">DZ Online Tech: ABBYY. Bagaimana tidak bingung dalam jaringan saraf?</a></li>
<li><a href="../id418937/index.html">Merayakan Ulang Tahun ke 8 dengan Rilis Pertama di GeekUniversity</a></li>
<li><a href="../id418943/index.html">Komputer bernyanyi, cyborg, dan musik gelombang - diskusikan suara dan gadget audio yang tidak biasa</a></li>
<li><a href="../id418945/index.html">ICO Terbaik Agustus 2018 (suara)</a></li>
<li><a href="../id418951/index.html">UE4 | Inventaris untuk Multi pemain # 2 | Hubungkan Cetak Biru ke C ++</a></li>
<li><a href="../id418953/index.html">Barang antik: antivirus antik dan arkeologi digital terapan</a></li>
<li><a href="../id418955/index.html">Dodo: Perusahaan IT yang membuat pizza. Pemrograman dan proses-TI / AichiHype</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>