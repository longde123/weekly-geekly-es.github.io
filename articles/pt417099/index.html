<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë≤üèæ üöö üôçüèº Como eu escrevi a biblioteca C ++ 11 padr√£o ou por que o impulso √© t√£o assustador? Cap√≠tulo 2 üßîüèº ü§∞üèº üëÉüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Resumo das pe√ßas anteriores 
 Devido a restri√ß√µes na capacidade de usar compiladores C ++ 11 e, devido √† falta de altern√¢ncia, o boost queria escrever...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como eu escrevi a biblioteca C ++ 11 padr√£o ou por que o impulso √© t√£o assustador? Cap√≠tulo 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417099/"><img src="https://habrastorage.org/webt/lr/zq/if/lrzqifvfeajppx2fdvqbxnwf4ce.png" alt="Sim - sim, com esse lema, corri para a batalha." width="300" height="350" align="left"><h3>  Resumo das pe√ßas anteriores </h3><br>  Devido a restri√ß√µes na capacidade de usar compiladores C ++ 11 e, devido √† falta de altern√¢ncia, o boost queria escrever sua pr√≥pria implementa√ß√£o da biblioteca C ++ 11 padr√£o na parte superior da biblioteca C ++ 98 / C ++ 03 fornecida com o compilador. <br><br>  Al√©m dos arquivos de cabe√ßalho padr√£o, <b>type_traits</b> , <b>thread</b> , <b>mutex</b> , <b>chrono</b> , <b>nullptr.h</b> foram adicionados <b>que</b> implementam <i>std :: nullptr_t</i> e <b>core.h</b> onde macros relacionadas √† <b>funcionalidade dependente do</b> compilador foram adicionadas, al√©m de expandir a biblioteca padr√£o. <br><br>  Link para o GitHub com o resultado de hoje para impacientes e n√£o leitores: <br><br><blockquote>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Compromissos e cr√≠ticas construtivas s√£o bem-vindos</a></b> </blockquote><a name="habracut"></a><br><h4>  Sum√°rio </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1. Introdu√ß√£o</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cap√≠tulo 1. Viam supervadet vadens</a> <br>  <b>Cap√≠tulo 2. #ifndef __CPP11_SUPPORT__ #define __COMPILER_SPECIFIC_BUILT_IN_AND_MACRO_HELL__ #endif</b> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cap√≠tulo 3. Localizando a Implementa√ß√£o NULLPTR Perfeita</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cap√≠tulo 4. C ++ Template Magic</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">4.1 Come√ßamos pequenos</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">4.2 Sobre quantos erros milagrosos o log compila para n√≥s</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">4.3 Ponteiros e tudo-tudo-tudo</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">4.4 O que mais √© necess√°rio para a biblioteca de modelos</a> <br>  Cap√≠tulo 5 <br>  ... <br><br><h3>  Cap√≠tulo 2. #ifndef __CPP11_SUPPORT__ #define __COMPILER_SPECIFIC_BUILT_IN_AND_MACRO_HELL__ #endif </h3><br>  Depois que todo o c√≥digo foi penteado um pouco e dividido por cabe√ßalhos ‚Äúpadr√£o‚Äù em um <b>espa√ßo de nomes</b> separado <b>stdex,</b> passei a preencher <b>type_traits</b> , <b>nullptr.he</b> ao longo do mesmo <b>core.h</b> , que continha macros para determinar a vers√£o do padr√£o usado pelo compilador e suport√°-lo <b>Nullptr</b> <b>nativo</b> , <b>char16_t</b> , <b>char32_t</b> e <b>static_assert</b> . <br><br>  Em teoria, tudo √© simples - de acordo com o padr√£o C ++ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">(cl√°usula 14.8), a</a> macro <b>__cplusplus</b> deve ser definida pelo compilador e corresponder √† vers√£o do padr√£o suportado: <br><br><pre><code class="cpp hljs">C++ pre-C++<span class="hljs-number"><span class="hljs-number">98</span></span>: <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __cplusplus 1 C++98: #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __cplusplus 199711L C++98 + TR1: #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __cplusplus 199711L </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// ??? C++11: #define __cplusplus 201103L C++14: #define __cplusplus 201402L C++17: #define __cplusplus 201703L</span></span></span></span></code> </pre> <br>  consequentemente, o c√≥digo para determinar se o suporte √© trivial: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (__cplusplus &gt;= 201103L) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  C++ 11   #define _STDEX_NATIVE_CPP11_SUPPORT //   11  (nullptr, static_assert) #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT //    char16_t, char32_t #endif</span></span></span></span></code> </pre><br><img src="https://habrastorage.org/webt/oq/qj/y8/oqqjy8dy_l8fyahlkfb3m-6uv3u.jpeg" alt="imagem" width="300" height="250" align="left">  De fato, nem tudo √© t√£o simples e agora come√ßam muletas interessantes com um ancinho. <br><br>  Primeiro, nem todos, ou melhor, nenhum dos compiladores n√£o implementam o pr√≥ximo padr√£o completa e imediatamente.  Por exemplo, no Visual Studio 2013, o <b>constexpr esteve</b> ausente <b>por</b> muito tempo, enquanto foi reivindicado que ele suporta C ++ 11 - com a ressalva de que a implementa√ß√£o n√£o est√° completa.  Ou seja, <b>auto</b> - por favor, <b>static_assert</b> - √© t√£o f√°cil (mesmo do MS VS anterior), mas <b>constexpr</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">n√£o</a> √©.  Em segundo lugar, nem todos os compiladores (e isso √© ainda mais surpreendente) exp√µem corretamente essa defini√ß√£o e a atualizam em tempo h√°bil.  Inesperadamente, no mesmo compilador, o Visual Studio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">n√£o alterou a vers√£o do __cplusplus</a> <b>define</b> desde as primeiras vers√µes do compilador, embora o suporte completo ao C ++ 11 tenha sido declarado h√° muito tempo (o que tamb√©m n√£o √© verdadeiro, para o qual existem raios separados de descontentamento - assim que a conversa chega √† funcionalidade espec√≠fica do ‚Äúnovo "11 desenvolvedores padr√£o dizem imediatamente que n√£o h√° pr√©-processador C99, n√£o h√° outros" recursos ").  E a situa√ß√£o √© agravada pelo fato de que, pelos compiladores padr√£o, podem definir isso como diferente dos valores acima, se eles n√£o cumprirem totalmente os padr√µes declarados.  Seria l√≥gico supor, por exemplo, um desenvolvimento de define para uma determinada macro (com a introdu√ß√£o de novas funcionalidades, aumente o n√∫mero oculto por tr√°s dessa defini√ß√£o): <br><br><pre> <code class="cpp hljs">standart C++<span class="hljs-number"><span class="hljs-number">98</span></span>: <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __cplusplus 199711L </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// C++98 standart C++98 + TR1: #define __cplusplus 200311L // C++03 nonstandart C++11: #define __cplusplus 200411L // C++03 + auto and dectype nonstandart C++11: #define __cplusplus 200511L // C++03 + auto, dectype and constexpr(partly) ... standart C++11: #define __cplusplus 201103L // C++11</span></span></span></span></code> </pre><br>  Mas, ao mesmo tempo, nenhum dos principais compiladores populares est√° "desgastado" com esse recurso. <br><br>  Por causa de tudo isso (n√£o tenho medo dessa palavra), agora para cada compilador n√£o padr√£o, voc√™ deve escrever suas pr√≥prias verifica√ß√µes espec√≠ficas para descobrir qual padr√£o C ++ e em que extens√£o ele suporta.  A boa not√≠cia √© que precisamos aprender apenas algumas fun√ß√µes do compilador para funcionar corretamente.  Primeiro, agora adicionamos a verifica√ß√£o de vers√£o do Visual Studio por meio da macro <b>_MSC_VER</b> , exclusiva deste compilador.  Como no meu arsenal de compiladores suportados, h√° tamb√©m o C ++ Borland Builder 6.0, cujos desenvolvedores, por sua vez, estavam muito interessados ‚Äã‚Äãem manter a compatibilidade com o Visual Studio (incluindo seus "recursos" e bugs), ent√£o de repente existe essa macro tamb√©m.  Para compiladores compat√≠veis com clang, existe uma macro n√£o padr√£o <b>__has_feature (</b> feature_name <b>)</b> , que permite descobrir se o compilador suporta essa ou aquela funcionalidade.  Como resultado, o c√≥digo √© inflado para: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __has_feature #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __has_feature(x) 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Compatibility with non-clang compilers. #endif // Any compiler claiming C++11 supports, Visual C++ 2015 and Clang version supporting constexpr #if ((__cplusplus &gt;= 201103L) || (_MSC_VER &gt;= 1900) || (__has_feature(cxx_constexpr))) // C++ 11 implementation #define _STDEX_NATIVE_CPP11_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif</span></span></span></span></code> </pre><br>  Deseja alcan√ßar mais compiladores?  Adicionamos verifica√ß√µes para o Codegear C ++ Builder, que √© o herdeiro da Borland (em suas piores manifesta√ß√µes, mas mais sobre isso mais tarde): <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __has_feature #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __has_feature(x) 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Compatibility with non-clang compilers. #endif // Any compiler claiming C++11 supports, Visual C++ 2015 and Clang version supporting constexpr #if ((__cplusplus &gt;= 201103L) || (_MSC_VER &gt;= 1900) || (__has_feature(cxx_constexpr))) // C++ 11 implementation #define _STDEX_NATIVE_CPP11_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #if !defined(_STDEX_NATIVE_CPP11_TYPES_SUPPORT) #if ((__cplusplus &gt; 199711L) || defined(__CODEGEARC__)) #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #endif</span></span></span></span></code> </pre><br>  Tamb√©m √© importante observar que, como o Visual Studio j√° implementou o suporte a <b>nullptr</b> da vers√£o do compilador <b>_MSC_VER 1600</b> , bem como os tipos <b>internos char16_t</b> e <b>char32_t</b> , precisamos lidar com isso corretamente.  Mais algumas verifica√ß√µes adicionadas: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __has_feature #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __has_feature(x) 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Compatibility with non-clang compilers. #endif // Any compiler claiming C++11 supports, Visual C++ 2015 and Clang version supporting constexpr #if ((__cplusplus &gt;= 201103L) || (_MSC_VER &gt;= 1900) || (__has_feature(cxx_constexpr))) // C++ 11 implementation #define _STDEX_NATIVE_CPP11_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #if !defined(_STDEX_NATIVE_CPP11_TYPES_SUPPORT) #if ((__cplusplus &gt; 199711L) || defined(__CODEGEARC__)) #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #endif #if ((!defined(_MSC_VER) || _MSC_VER &lt; 1600) &amp;&amp; !defined(_STDEX_NATIVE_CPP11_SUPPORT)) #define _STDEX_IMPLEMENTS_NULLPTR_SUPPORT #else #define _STDEX_NATIVE_NULLPTR_SUPPORT #endif #if (_MSC_VER &gt;= 1600) #ifndef _STDEX_NATIVE_CPP11_TYPES_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #endif</span></span></span></span></code> </pre><br>  Ao mesmo tempo, verificaremos o suporte ao C ++ 98, pois para compiladores sem ele n√£o haver√° alguns arquivos de cabe√ßalho da biblioteca padr√£o e n√£o podemos verificar a aus√™ncia deles usando o compilador. <br><br><div class="spoiler">  <b class="spoiler_title">Op√ß√£o completa</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __has_feature #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __has_feature(x) 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Compatibility with non-clang compilers. #endif // Any compiler claiming C++11 supports, Visual C++ 2015 and Clang version supporting constexpr #if ((__cplusplus &gt;= 201103L) || (_MSC_VER &gt;= 1900) || (__has_feature(cxx_constexpr))) // C++ 11 implementation #define _STDEX_NATIVE_CPP11_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #if !defined(_STDEX_NATIVE_CPP11_TYPES_SUPPORT) #if ((__cplusplus &gt; 199711L) || defined(__CODEGEARC__)) #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #endif #if ((!defined(_MSC_VER) || _MSC_VER &lt; 1600) &amp;&amp; !defined(_STDEX_NATIVE_CPP11_SUPPORT)) #define _STDEX_IMPLEMENTS_NULLPTR_SUPPORT #else #define _STDEX_NATIVE_NULLPTR_SUPPORT #endif #if (_MSC_VER &gt;= 1600) #ifndef _STDEX_NATIVE_CPP11_TYPES_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #endif #if _MSC_VER // Visual C++ fallback #define _STDEX_NATIVE_MICROSOFT_COMPILER_EXTENSIONS_SUPPORT #define _STDEX_CDECL __cdecl #if (__cplusplus &gt;= 199711L) #define _STDEX_NATIVE_CPP_98_SUPPORT #endif #endif // C++ 98 check: #if ((__cplusplus &gt;= 199711L) &amp;&amp; ((defined(__INTEL_COMPILER) || defined(__clang__) || (defined(__GNUC__) &amp;&amp; ((__GNUC__ &gt; 4) || (__GNUC__ == 4 &amp;&amp; __GNUC_MINOR__ &gt;= 4)))))) #ifndef _STDEX_NATIVE_CPP_98_SUPPORT #define _STDEX_NATIVE_CPP_98_SUPPORT #endif #endif</span></span></span></span></code> </pre><br></div></div><br>  E agora configura√ß√µes volumosas do impulso est√£o come√ßando a aparecer na minha mem√≥ria, na qual muitos desenvolvedores esfor√ßados escreveram todas essas macros dependentes do compilador e fizeram um mapa do que √© suportado e o que n√£o √© de um compilador espec√≠fico de uma vers√£o espec√≠fica, da qual eu pessoalmente me sinto desconfort√°vel, Eu quero nunca mais olhar para ele ou toc√°-lo.  Mas a boa not√≠cia √© que voc√™ pode parar por a√≠.  Pelo menos, isso √© suficiente para eu oferecer suporte aos compiladores mais populares, mas se voc√™ encontrar uma imprecis√£o ou quiser adicionar outro compilador, ficarei feliz em aceitar a solicita√ß√£o de recebimento. <br><br>  Uma grande conquista em compara√ß√£o ao impulso, acredito que foi poss√≠vel manter a difus√£o de macros dependentes do compilador pelo c√≥digo, o que torna o c√≥digo mais limpo e f√°cil de entender, al√©m de n√£o empilhar dezenas de arquivos de configura√ß√£o para cada sistema operacional e para cada compilador.  Falaremos sobre as desvantagens dessa abordagem um pouco mais tarde. <br><br>  Nesse est√°gio, j√° podemos come√ßar a conectar a funcionalidade ausente dos 11 padr√µes, e a primeira coisa que apresentamos √© <b>static_assert</b> . <br><br><h3>  static_assert </h3><br>  Definimos a estrutura <i>StaticAssertion</i> , que assumir√° um valor booleano como par√¢metro do modelo - haver√° nossa condi√ß√£o, se n√£o for atendida (a express√£o √© <b>falsa</b> ), ocorrer√° um erro na compila√ß√£o de um modelo n√£o especializado.  E outra estrutura fict√≠cia para receber <b>sizeof (</b> <i>StaticAssertion</i> <b>)</b> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> stdex { <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StaticAssertion</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StaticAssertion</span></span></span><span class="hljs-class">&lt;true&gt; {</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// StaticAssertion&lt;true&gt; template&lt;int i&gt; struct StaticAssertionTest { }; // StaticAssertionTest&lt;int&gt; } }</span></span></code> </pre><br>  e mais macro m√°gica <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _STDEX_NATIVE_CPP11_SUPPORT #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STATIC_ASSERT(expression, message) static_assert((expression), #message) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// no C++11 support #define CONCATENATE(arg1, arg2) CONCATENATE1(arg1, arg2) #define CONCATENATE1(arg1, arg2) CONCATENATE2(arg1, arg2) #define CONCATENATE2(arg1, arg2) arg1##arg2 #define STATIC_ASSERT(expression, message)\ struct CONCATENATE(__static_assertion_at_line_, __LINE__)\ {\ stdex::detail::StaticAssertion&lt;static_cast&lt;bool&gt;((expression))&gt; CONCATENATE(CONCATENATE(CONCATENATE(STATIC_ASSERTION_FAILED_AT_LINE_, __LINE__), _WITH__), message);\ };\ typedef stdex::detail::StaticAssertionTest&lt;sizeof(CONCATENATE(__static_assertion_at_line_, __LINE__))&gt; CONCATENATE(__static_assertion_test_at_line_, __LINE__) #ifndef _STDEX_NATIVE_NULLPTR_SUPPORT #define static_assert(expression, message) STATIC_ASSERT(expression, ERROR_MESSAGE_STRING) #endif #endif</span></span></span></span></code> </pre><br>  uso: <br><br><pre> <code class="cpp hljs">STATIC_ASSERT(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*) == <span class="hljs-number"><span class="hljs-number">4</span></span>, non_x32_platform_is_unsupported);</code> </pre><br><blockquote>  Uma diferen√ßa importante entre minha implementa√ß√£o e a <a href="">padr√£o</a> √© que n√£o h√° sobrecarga dessa palavra-chave <u>sem</u> informar o usu√°rio.  Isso se deve ao fato de que em C ++ √© imposs√≠vel definir v√°rias defini√ß√µes com um n√∫mero diferente de argumentos, exceto um nome, e uma implementa√ß√£o sem uma mensagem √© muito menos √∫til que a op√ß√£o selecionada.  Esse recurso leva ao fato de que, em ess√™ncia, <b>STATIC_ASSERT</b> na minha implementa√ß√£o j√° √© a vers√£o adicionada no C ++ 11. </blockquote>  Vamos dar uma olhada no que aconteceu.  Como resultado da verifica√ß√£o das vers√µes das <b>__cplusplus</b> e das macros de compilador n√£o padr√£o, temos informa√ß√µes suficientes sobre o suporte ao C ++ 11 (e, portanto, <b>static_assert</b> ), expressas pela <b>defini√ß√£o</b> _STDEX_NATIVE_CPP11_SUPPORT.  Portanto, se essa macro estiver definida, podemos simplesmente usar o <b>static_assert</b> padr√£o: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _STDEX_NATIVE_CPP11_SUPPORT #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STATIC_ASSERT(expression, message) static_assert((expression), #message)</span></span></code> </pre><br><blockquote>  Observe que o segundo par√¢metro da macro <b>STATIC_ASSERT</b> n√£o √© <b>literalmente uma string</b> e <b>,</b> portanto, usando o operador do pr√©-processador <b>#</b> , converteremos o par√¢metro de <i>mensagem</i> em uma string para transmiss√£o ao <b>static_assert</b> padr√£o. </blockquote>  Se n√£o tivermos suporte do compilador, prosseguiremos para nossa implementa√ß√£o.  Para come√ßar, declararemos macros auxiliares para "colar" as strings (o operador de pr√©-processador <b>##</b> √© o <b>√∫nico</b> respons√°vel por isso). <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONCATENATE(arg1, arg2) CONCATENATE1(arg1, arg2) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONCATENATE1(arg1, arg2) CONCATENATE2(arg1, arg2) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONCATENATE2(arg1, arg2) arg1##arg2</span></span></code> </pre><br><blockquote>  Especificamente, n√£o usei simplesmente <b>#define CONCATENATE (</b> <i>arg1</i> , <i>arg2</i> <b>)</b> <i>arg1 ## arg2</i> para poder passar o resultado da mesma macro <b>CONCATENATE</b> como argumento para <i>arg1</i> e <i>arg2</i> . </blockquote>  Em seguida, declaramos uma estrutura com o nome bonito __static_assertion_at_line_ {n√∫mero da linha} (a macro <b>__LINE__</b> tamb√©m √© definida pelo padr√£o e deve ser expandida para o n√∫mero da linha na qual foi chamada) e, dentro dessa estrutura, adicionamos um campo do nosso tipo <i>StaticAssertion</i> com o nome STATIC_ASSERTION_FAILED_AT_LINE_ {n√∫mero da linha} _WITH. mensagens de erro da macro de chamada}. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STATIC_ASSERT(expression, message)\ struct CONCATENATE(__static_assertion_at_line_, __LINE__)\ {\ stdex::detail::StaticAssertion</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;static_cast&lt;bool&gt;((expression))&gt; CONCATENATE(CONCATENATE(CONCATENATE(STATIC_ASSERTION_FAILED_AT_LINE_, __LINE__), _WITH__), message);\ };\ typedef stdex::detail::StaticAssertionTest&lt;sizeof(CONCATENATE(__static_assertion_at_line_, __LINE__))&gt; CONCATENATE(__static_assertion_test_at_line_, __LINE__)</span></span></span></span></code> </pre><br>  <i>Com o</i> par√¢metro de modelo em <i>StaticAssertion,</i> passamos uma express√£o que √© verificada em <b>STATIC_ASSERT</b> , levando-a a <b>bool</b> .  Finalmente, para evitar a cria√ß√£o de vari√°veis ‚Äã‚Äãlocais e a verifica√ß√£o de sobrecarga zero da condi√ß√£o do usu√°rio, um alias √© declarado para o tipo <i>StaticAssertionTest &lt;sizeof ({nome da estrutura declarada acima})</i> com o nome __static_assertion_test_at_line_ {n√∫mero da linha}. <br><br>  Toda a beleza da nomenclatura √© necess√°ria apenas para deixar claro a partir de um erro de compila√ß√£o que este √© um resultado de afirma√ß√£o, e n√£o apenas um erro, mas tamb√©m para exibir uma mensagem de erro que foi definida para essa afirma√ß√£o.  O truque <b>sizeof</b> √© necess√°rio para for√ßar o compilador a instanciar a classe de modelo <i>StaticAssertion</i> , que est√° dentro da estrutura rec√©m-declarada e, assim, verificar a condi√ß√£o passada para afirmar. <br><br><div class="spoiler">  <b class="spoiler_title">Resultados STATIC_ASSERT</b> <div class="spoiler_text"><blockquote>  GCC: <br>  30: 103: erro: o campo 'STATIC_ASSERTION_FAILED_AT_LINE_36_WITH__non_x32_platform_is_unsupported' possui um tipo incompleto 'stdex :: detail :: StaticAssertion &lt;false&gt;' <br>  25:36: nota: na defini√ß√£o da macro 'CONCATENATE2' <br>  23:36: nota: na expans√£o da macro 'CONCATENATE1' <br>  30:67: nota: na expans√£o da macro 'CONCATENATE' <br>  24:36: nota: na expans√£o da macro 'CONCATENATE2' <br>  23:36: nota: na expans√£o da macro 'CONCATENATE1' <br>  30:79: nota: na expans√£o da macro 'CONCATENATE' <br>  24:36: nota: na expans√£o da macro 'CONCATENATE2' <br>  23:36: nota: na expans√£o da macro 'CONCATENATE1' <br>  30:91: nota: na expans√£o da macro 'CONCATENATE' <br>  36: 3: note: na expans√£o da macro 'STATIC_ASSERT' <br><br>  Borland C ++ Builder: <br>  [Erro C ++] stdex_test.cpp (36): E2450 Estrutura indefinida 'stdex :: detail :: StaticAssertion &lt;0&gt;' <br>  [Erro C ++] stdex_test.cpp (36): E2449 O tamanho de 'STATIC_ASSERTION_FAILED_AT_LINE_36_WITH__non_x32_platform_is_unsupported' √© desconhecido ou zero <br>  [Erro C ++] stdex_test.cpp (36): E2450 Estrutura indefinida 'stdex :: detail :: StaticAssertion &lt;0&gt;' <br><br>  Visual Studio: <br>  Erro c2079 </blockquote><br></div></div><br>  O segundo "truque" que eu queria ter, embora <u>ausente</u> do padr√£o, √© contar o n√∫mero de elementos na matriz.  Os Sishers gostam muito de declarar essa macro atrav√©s de sizeof (arr) / sizeof (arr [0]), mas iremos al√©m. <br><br><h3>  contagem de </h3><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _STDEX_NATIVE_CPP11_SUPPORT #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstddef&gt; namespace stdex { namespace detail { template &lt;class T, std::size_t N&gt; constexpr std::size_t _my_countof(T const (&amp;)[N]) noexcept { return N; } } // namespace detail } #define countof(arr) stdex::detail::_my_countof(arr) #else //no C++11 support #ifdef _STDEX_NATIVE_MICROSOFT_COMPILER_EXTENSIONS_SUPPORT // Visual C++ fallback #include &lt;stdlib.h&gt; #define countof(arr) _countof(arr) #elif defined(_STDEX_NATIVE_CPP_98_SUPPORT)// C++ 98 trick #include &lt;cstddef&gt; template &lt;typename T, std::size_t N&gt; char(&amp;COUNTOF_REQUIRES_ARRAY_ARGUMENT(T(&amp;)[N]))[N]; #define countof(x) sizeof(COUNTOF_REQUIRES_ARRAY_ARGUMENT(x)) #else #define countof(arr) sizeof(arr) / sizeof(arr[0]) #endif</span></span></span></span></code> </pre><br>  Para compiladores com suporte ao <b>constexpr</b> , declararemos uma vers√£o constexpr deste modelo (que n√£o √© absolutamente necess√°ria, para todos os padr√µes, a implementa√ß√£o atrav√©s do modelo <i>COUNTOF_REQUIRES_ARRAY_ARGUMENT</i> √© <i>suficiente</i> ); para o resto, apresentaremos a vers√£o atrav√©s da fun√ß√£o de modelo <i>COUNTOF_REQUIRES_ARRAY_ARGUMENT</i> .  O Visual Studio aqui novamente se distingue pela presen√ßa de sua pr√≥pria implementa√ß√£o de <b>_countof</b> no arquivo de cabe√ßalho <b>stdlib.h</b> . <br><br>  A fun√ß√£o <i>COUNTOF_REQUIRES_ARRAY_ARGUMENT</i> parece intimidadora e <i>descobrir</i> o que faz √© bastante complicado.  Se voc√™ observar atentamente, poder√° entender que ele usa uma √∫nica matriz de elementos do tipo <i>T</i> e tamanho <i>N</i> como argumento - assim, no caso de transfer√™ncia de outros tipos de elementos (n√£o matrizes), obtemos um erro de compila√ß√£o, o que sem d√∫vida agrada.  Observando mais de perto, voc√™ pode descobrir (com dificuldade) que ele retorna uma matriz de elementos de <b>caracteres</b> do tamanho <i>N.</i>  A quest√£o √©: por que precisamos de tudo isso?  √â aqui que o <b>tamanho do</b> operador entra em a√ß√£o e sua capacidade exclusiva de trabalhar em tempo de compila√ß√£o.  A chamada <b>sizeof (</b> <i>COUNTOF_REQUIRES_ARRAY_ARGUMENT</i> <b>)</b> determina o tamanho da matriz de elementos <b>char</b> retornados pela fun√ß√£o e, como o <b>sizeof</b> padr√£o <b>(char)</b> == 1, esse √© o n√∫mero de <i>N</i> elementos na matriz original.  Elegante, bonito e totalmente gratuito. <br><br><h3>  para sempre </h3><br>  Outra macro auxiliar pequena que eu uso sempre que um loop infinito √© necess√°rio √© <b>para sempre</b> .  √â definido da seguinte forma: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> !defined(forever) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> forever for(;;) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STRINGIZE_HELPER(x) #x #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STRINGIZE(x) STRINGIZE_HELPER(x) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WARNING(desc) message(__FILE__ </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"("</span></span></span><span class="hljs-meta"> STRINGIZE(__LINE__) </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">") : warning: "</span></span></span><span class="hljs-meta"> desc) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> WARNING(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stdex library - macro 'forever' was previously defined by user; ignoring stdex macro definition"</span></span></span><span class="hljs-meta">) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> STRINGIZE_HELPER #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> STRINGIZE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> WARNING #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  Exemplo de sintaxe para definir um loop infinito expl√≠cito: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; forever { ++i; }</code> </pre><br>  Essa macro √© usada apenas para definir explicitamente um loop infinito e √© inclu√≠da na biblioteca apenas por raz√µes de "adicionar a√ß√∫car sint√°tico".  No futuro, proponho substitu√≠-lo por opcionalmente atrav√©s da defini√ß√£o da macro de plug-in <b>FOREVER</b>  O que √© not√°vel no trecho de c√≥digo acima da biblioteca √© a mesma macro <b>WARNING</b> que gera uma mensagem de aviso em todos os compiladores se a macro <b>forever</b> j√° tiver sido definida pelo usu√°rio.  Ele usa a macro <b>__LINE__</b> padr√£o familiar e a <b>macro __FILE__</b> padr√£o, que √© convertida em uma sequ√™ncia com o nome do arquivo de origem atual. <br><br><h3>  stdex_assert </h3><br>  Para implementar a <b>declara√ß√£o</b> em tempo de execu√ß√£o, a macro <b>stdex_assert √©</b> apresentada como: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(assert) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> NDEBUG #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #define stdex_assert(condition, message) \ do { \ if (! (condition)) { \ std::cerr &lt;&lt; "Assertion `" #condition "` failed in " &lt;&lt; __FILE__ \ &lt;&lt; " line " &lt;&lt; __LINE__ &lt;&lt; ": " &lt;&lt; message &lt;&lt; std::endl; \ std::terminate(); \ } \ } while (false) #else #define stdex_assert(condition, message) ((void)0) #endif #endif</span></span></span></span></code> </pre><br>  N√£o direi que estou muito orgulhoso dessa implementa√ß√£o (ela ser√° alterada no futuro), mas uma t√©cnica interessante foi usada aqui que eu gostaria de chamar a aten√ß√£o.  Para ocultar as verifica√ß√µes do escopo do c√≥digo do aplicativo, √© usada a constru√ß√£o <b>do</b> <i>{}</i> <b>while (false)</b> , que ser√° executada, o que √© √≥bvio uma vez e ao mesmo tempo n√£o introduzir√° o c√≥digo de "servi√ßo" no c√≥digo geral do aplicativo.  Essa t√©cnica √© bastante √∫til e √© usada em v√°rios outros lugares da biblioteca. <br><br>  Caso contr√°rio, a implementa√ß√£o √© muito semelhante √† <b>afirma√ß√£o</b> padr√£o - com uma determinada macro <b>NDEBUG</b> , que os compiladores geralmente configuram nas compila√ß√µes de lan√ßamento, a afirma√ß√£o n√£o faz nada; caso contr√°rio, interrompe a execu√ß√£o do programa com a sa√≠da da mensagem no fluxo de erro padr√£o se a condi√ß√£o de afirma√ß√£o n√£o for atendida. <br><br><h3>  noexcept </h3><br>  Para fun√ß√µes que n√£o <b>geram</b> exce√ß√µes, a palavra-chave <b>noexcept</b> foi introduzida no novo padr√£o.  Tamb√©m √© bastante simples e f√°cil de implementar atrav√©s da macro: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _STDEX_NATIVE_CPP11_SUPPORT #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> stdex_noexcept noexcept #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> stdex_noexcept throw() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  no entanto, √© necess√°rio entender que, no padr√£o, o <b>noexcept</b> pode levar o valor <b>bool</b> e tamb√©m <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ser usado</a> para determinar, em tempo de compila√ß√£o, que a express√£o transmitida a ele n√£o gera uma exce√ß√£o.  Essa funcionalidade n√£o pode ser implementada sem o suporte do compilador e, portanto, existe apenas um <b>stdex_noexcept</b> "despojado" na biblioteca. <br><br>  O final do segundo cap√≠tulo.  O <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">terceiro cap√≠tulo</a> abordar√° os meandros da implementa√ß√£o do nullptr, por que √© diferente para diferentes compiladores, bem como o desenvolvimento de type_traits e quais outros erros nos compiladores me deparei durante seu desenvolvimento. <br><br>  Obrigado pela aten√ß√£o. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt417099/">https://habr.com/ru/post/pt417099/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt417087/index.html">HPE Digitize 2018: evento e transmiss√£o ao vivo</a></li>
<li><a href="../pt417089/index.html">Computador qu√¢ntico: um f√≥ton para dominar tudo</a></li>
<li><a href="../pt417091/index.html">Crie um sombreador de √°gua de desenho animado para a web. Parte 3</a></li>
<li><a href="../pt417093/index.html">Interruptores sens√≠veis ao toque com Modbus: por que eles s√£o necess√°rios e como aplic√°-los em um apartamento inteligente</a></li>
<li><a href="../pt417097/index.html">Metaprograma√ß√£o JavaScript</a></li>
<li><a href="../pt417101/index.html">Defini√ß√£o de Ready - O que esquecemos de contar</a></li>
<li><a href="../pt417103/index.html">Spark SQL. Um pouco sobre o otimizador de consultas</a></li>
<li><a href="../pt417105/index.html">Imprimindo em uma impressora 3D. Experi√™ncias secretas do 3Dtool</a></li>
<li><a href="../pt417107/index.html">Criador do jogo enquanto True: aprenda () sobre programa√ß√£o de gamedev, problemas de VR e simula√ß√µes de ML</a></li>
<li><a href="../pt417109/index.html">Richard Hamming: Cap√≠tulo 10. Teoria da Codifica√ß√£o - I</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>