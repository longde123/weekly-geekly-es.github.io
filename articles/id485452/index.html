<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>âš•ï¸ ğŸ‘‹ğŸ¾ ğŸ‘¨ğŸ¿â€ğŸ”§ Mengapa Rust Memimpin Tolok Ukur Kerangka Kerja TechEmpower ğŸ¤¦ğŸ¿ ğŸ’› ğŸ‘¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sebenarnya, saya tidak berniat untuk melihat apa warna nyali Rust. Saya mengambil proyek hobi di Go, pergi ke GitHub untuk melihat keadaan fasthttp: a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengapa Rust Memimpin Tolok Ukur Kerangka Kerja TechEmpower</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485452/"><p>  Sebenarnya, saya tidak berniat untuk melihat apa warna nyali Rust.  Saya mengambil proyek hobi di Go, pergi ke GitHub untuk melihat keadaan fasthttp: apakah itu berkembang?  Ya, setidaknya didukung?  Tumbuh.  Pergi, melihat di mana fasthttp duduk di benchmark <a href="https://www.techempower.com/benchmarks/" rel="nofollow">TechEmpower</a> .  Saya melihat: dan di sana fasthttp hampir tidak menunjukkan setengah dari apa yang berhasil dilakukan pemimpin - untuk beberapa aksi pada beberapa Rust.  Menyedihkan sekali. </p><br><p>  Di sini saya akan melipat tangan saya, memukul kepala saya di lantai (tiga kali) dan berteriak: "Haleluya, sesungguhnya Rust adalah tuhan sejati, betapa buta sebelumnya saya!".  Tapi entah gagangnya tidak berhasil, atau dahi menyesal ... Sebaliknya, saya masuk ke kode tes yang ditulis dalam Go dan tes actix-web di Rust.  Untuk mengatasinya. </p><br><p>  Setelah beberapa jam saya menemukan: </p><br><ol><li>  mengapa kerangka kerja actix-web Rust menempati posisi pertama dalam semua tes TechEmpower, </li><li>  bagaimana Java memulai Script. </li></ol><br><p>  Sekarang saya akan menceritakan semuanya kepada Anda. </p><a name="habracut"></a><br><h2 id="chto-za-techempower-framework-benchmark">  Apa itu Benchmark TechEmpower Framework? </h2><br><p>  Jika kerangka kerja web menunjukkan apakah itu akan atau, katakanlah, kadang-kadang berpikir tentang berbisik kepada teman-teman "saya cepat," maka itu pasti akan jatuh ke dalam Tolok Ukur Kerangka Kerja TechEmpower.  Tempat populer untuk mengukur kinerja. </p><br><p>  Situs ini memiliki desain yang khas: tab filter, putaran, kondisi dan hasil untuk berbagai jenis tes tersebar di halaman dengan tangan murah hati.  Begitu murah hati dan luas sehingga Anda tidak memperhatikannya.  Tapi ada baiknya mengklik pada tab, informasi di belakangnya berguna. </p><br><p>  Cara termudah adalah dengan mendapatkan hasil tes plaintext, "Hello World!"  untuk server web.  Para penulis kerangka kerja biasanya memberikan tautan ke sana: kita seharusnya tinggal di seratus pertama.  Kasingnya benar dan bermanfaat.  Secara umum, membagikan plaintext itu baik untuk banyak orang, dan para pemimpin pergi dalam kelompok yang ketat. </p><br><p>  Di dekatnya, pada tab-tab itu, adalah hasil pengujian jenis lain (skenario).  Ada tujuh dari mereka, detail lebih lanjut dapat ditemukan di <a href="https://github.com/TechEmpower/FrameworkBenchmarks/wiki/Project-Information-Framework-Tests-Overview" rel="nofollow">sini</a> .  Skenario ini menguji tidak hanya bagaimana kerangka / platform menangani pemrosesan permintaan http sederhana, tetapi kombinasi dengan klien basis data, mesin templat, atau serializer JSON. </p><br><p>  Ada data uji di lingkungan virtual, pada perangkat keras fisik.  Selain grafik, ada data tabular.  Secara umum, banyak hal menarik, perlu digali, tidak hanya melihat posisi platform "Anda". </p><br><p>  Hal pertama yang terlintas di pikiran saya setelah melalui hasil tes: "Mengapa semuanya SO SO berbeda dari plaintext?!".  Dalam plaintext, para pemimpin pergi dalam kelompok yang ketat, tetapi ketika datang untuk bekerja dengan database, actix-web dipimpin oleh margin yang signifikan.  Pada saat yang sama, ini menunjukkan waktu pemrosesan permintaan yang stabil.  Setan. </p><br><p>  Keanehan lain: solusi JavaScript yang sangat kuat.  Ini disebut ex4x.  Ternyata kodenya sedikit kurang lengkap di Jawa.  Digunakan oleh Java runtime, JDBC.  Kode JavaScript diterjemahkan ke dalam bytecode dan merekatkan pustaka Java.  Mereka benar-benar mengambilnya - dan melampirkan Script ke Jawa.  Trik wajah pucat tidak memiliki batas. </p><br><h2 id="kak-posmotret-kod-i-chto-tam-vnutri">  Cara melihat kode dan apa yang ada di dalamnya </h2><br><p>  Kode untuk semua tes ada di GitHub.  Semuanya dalam satu repositori, yang sangat nyaman.  Anda dapat mengkloning dan menonton, Anda dapat menonton langsung di GitHub.  Pengujian ini melibatkan lebih dari 300 kombinasi kerangka kerja yang berbeda dengan serializer, mesin templat, dan klien basis data.  Dalam bahasa pemrograman yang berbeda, dengan pendekatan pengembangan yang berbeda.  Implementasi dalam satu bahasa terdekat, dapat dibandingkan dengan implementasi dalam bahasa lain.  Kode ini dikelola oleh komunitas, bukan pekerjaan satu orang atau tim. </p><br><p>  Kode benchmark adalah tempat yang tepat untuk memperluas wawasan Anda.  Sangat menarik untuk menganalisis bagaimana orang yang berbeda menyelesaikan masalah yang sama.  Tidak banyak kode, perpustakaan dan solusi yang digunakan mudah dibedakan.  Saya tidak menyesal sama sekali bahwa saya sampai di sana.  Saya belajar banyak.  Pertama-tama tentang Rust. </p><br><p>  Sebelum Rust, saya punya ide yang sangat kabur.  Setiap artikel tentang C, C ++, D, dan terutama Go pasti memiliki beberapa komentator yang menjelaskan secara rinci dan dengan kesedihan bahwa kesombongan, omong kosong dan kebodohan ditulis dalam sesuatu yang lain, selama ada <del>  Gascony </del>  Karat.  Kadang-kadang mereka begitu terbawa sehingga mereka memberikan contoh kode daripada orang yang tidak siap <del>  atau sedikit yang menerima </del>  didorong ke pingsan: "Mengapa, mengapa, mengapa semua simbol ini?!" </p><br><p>  Karena itu, membuka kode itu menakutkan. </p><br><p>  Saya melihat.  Ternyata program di Rust dapat dibaca.  Selain itu, kode dibaca dengan baik sehingga saya bahkan menginstal Rust, mencoba untuk mengkompilasi tes dan bermain-main sedikit dengannya. </p><br><p>  Di sini saya hampir meninggalkan bisnis ini, karena kompilasi berlangsung lama.  Waktu yang sangat lama  Jika saya adalah D'Artagnan, atau bahkan hanya seorang penderita penyakit kera, saya akan bergegas ke Gascony, dan seribu iblis akan jejak dengan sedih.  Tapi saya berhasil.  Saya minum teh lagi.  Tampaknya bahkan tidak satu cangkir: di laptop saya, kompilasi pertama memakan waktu sekitar 20 menit, namun, semuanya berjalan lebih menyenangkan.  Mungkin sampai peti besar pembaruan berikutnya. </p><br><h2 id="a-razve-delo-ne-v-samom-rust">  Tapi bukankah Rust itu sendiri? </h2><br><p>  Tidak.  Bukan bahasa pemrograman. </p><br><p>  Tentu saja, Rust adalah bahasa yang indah.  Kuat, fleksibel, meskipun karena kebiasaan dan bertele-tele.  Tetapi bahasa itu sendiri tidak akan menulis kode cepat.  Bahasa adalah salah satu alat, salah satu keputusan yang dibuat oleh programmer. </p><br><p>  Seperti yang saya katakan - membagikan plaintext dengan cepat diperoleh oleh banyak orang.  Kinerja kerangka kerja actix-web, fasthttp dan lainnya saat memproses permintaan sederhana cukup sebanding, yaitu, bahasa lain memiliki kemampuan teknis untuk bersaing dengan Rust. </p><br><p>  Actix-web itu sendiri, tentu saja, adalah "yang harus disalahkan": produk yang cepat, pragmatis, luar biasa.  Serialisasi sangat mudah, mesin templatnya bagus - ini juga banyak membantu. </p><br><p>  Terutama, hasil tes yang bekerja dengan database berbeda. </p><br><p>  Setelah menggali sedikit dalam kode, saya menyoroti tiga perbedaan utama yang (menurut saya) membantu tes actix untuk melepaskan diri dari pesaing dalam tes sintetis: </p><br><ol><li>  Mode operasi tokio-postgres pipelined pipeline; </li><li>  Menggunakan satu koneksi dengan uji Rust alih-alih kumpulan koneksi dengan tes yang ditulis dalam Go; </li><li>  Memperbarui tolok ukur actix dengan satu perintah yang dikirim melalui kueri sederhana alih-alih mengirim beberapa perintah UPDATE. </li></ol><br><h2 id="chto-esche-za-konveyernyy-rezhim">  Apa jenis mode konveyor? </h2><br><p>  Berikut ini cuplikan dari dokumentasi tokio-postgres (digunakan dalam tolok ukur pustaka klien PostgreSQL) yang menjelaskan apa yang dimaksud oleh pengembangnya: </p><br><pre><code class="plaintext hljs">Sequential Pipelined | Client | PostgreSQL | | Client | PostgreSQL | |----------------|-----------------| |----------------|-----------------| | send query 1 | | | send query 1 | | | | process query 1 | | send query 2 | process query 1 | | receive rows 1 | | | send query 3 | process query 2 | | send query 2 | | | receive rows 1 | process query 3 | | | process query 2 | | receive rows 2 | | | receive rows 2 | | | receive rows 3 | | | send query 3 | | | | process query 3 | | receive rows 3 | |</code> </pre> <br><p>  Klien dalam mode pipelined (pipelined) tidak menunggu respons PostgreSQL, tetapi mengirimkan permintaan berikutnya sementara PostgreSQL memproses yang sebelumnya.  Dapat dilihat bahwa dengan cara ini Anda dapat memproses urutan permintaan basis data yang sama secara signifikan lebih cepat. </p><br><p>  Jika koneksi dalam mode pipelined adalah duplex (memberikan kemungkinan memperoleh hasil secara paralel dengan pengiriman), kali ini mungkin sedikit berkurang.  Tampaknya sudah ada versi eksperimental tokio-postgres di mana koneksi duplex dibuka. </p><br><p>  Karena klien PostgreSQL mengirim beberapa pesan (Parse, Bind, Execute, dan Sync) ke setiap permintaan SQL yang dikirim untuk dieksekusi, dan menerima respons terhadap mereka, mode pipelined akan lebih efektif bahkan ketika memproses permintaan tunggal. </p><br><h2 id="a-pochemu-v-go-ne-tak">  Dan mengapa tidak di Go? </h2><br><p>  Karena Go biasanya menggunakan kumpulan koneksi database.  Koneksi tidak dimaksudkan untuk digunakan secara paralel. </p><br><p>  Jika Anda menjalankan kueri SQL yang sama melalui kumpulan, bukan dari satu koneksi, maka secara teoritis Anda bisa mendapatkan waktu eksekusi lebih pendek dengan klien serial biasa daripada ketika bekerja melalui satu koneksi, baik itu tiga kali disalurkan melalui pipa: </p><br><pre> <code class="plaintext hljs">| Connection | Connection 2 | Connection 3 | PostgreSQL | |----------------|----------------|----------------|-----------------| | send query 1 | | | | | | send query 2 | | process query 1 | | receive rows 1 | | send query 3 | process query 2 | | | receive rows 2 | | process query 3 | | | receive rows 3 | |</code> </pre><br><p>  Sepertinya kulit domba (mode konveyor) tidak sebanding dengan lilin. </p><br><p>  Hanya di bawah beban tinggi jumlah koneksi ke server PostgreSQL bisa menjadi masalah. </p><br><h2 id="a-pri-chyom-tut-voobsche-kolichestvo-soedineniy">  Dan apa hubungan jumlah koneksi dengan itu? </h2><br><p>  Intinya di sini adalah bagaimana server PostgreSQL merespons peningkatan jumlah koneksi. </p><br><p>  Grup kolom kiri menunjukkan naik turunnya kinerja PostgreSQL tergantung pada jumlah koneksi terbuka: </p><br><p><img src="https://habrastorage.org/webt/nj/rl/io/njrlior5dxzdovhnxrv4spx8q_w.png"></p><br><p>  <em>( <a href="https://www.percona.com/blog/2018/06/27/scaling-postgresql-with-pgbouncer-you-may-need-a-connection-pooler-sooner-than-you-expect/" rel="nofollow">Diadaptasi dari pos Percona</a> )</em> </p><br><p>  Dapat dilihat bahwa dengan peningkatan jumlah koneksi terbuka, kinerja server PostgreSQL turun dengan cepat. </p><br><p>  Selain itu, membuka koneksi langsung tidak "gratis."  Segera setelah membuka klien mengirim informasi layanan, "setuju" dengan server PostgreSQL tentang bagaimana permintaan akan diproses. </p><br><p>  Oleh karena itu, dalam praktiknya, Anda harus membatasi jumlah koneksi aktif ke PostgreSQL, seringkali juga meneruskannya melalui pgbouncer atau pengembaraan lainnya. </p><br><h2 id="tak-pochemu-actix-web-okazalsya-bystree">  Jadi mengapa actix-web lebih cepat? </h2><br><p>  Pertama, actix-web itu sendiri sangat cepat.  Dialah yang menetapkan "langit-langit", dan dia sedikit lebih tinggi dari yang lain.  Perpustakaan lain yang digunakan (serde, yarde) juga sangat, sangat produktif.  Tetapi bagi saya, dalam tes yang bekerja dengan PostgreSQL dimungkinkan untuk lepas karena server actix-web memulai satu utas pada inti prosesor.  Setiap utas membuka hanya satu koneksi ke PostgreSQL. </p><br><p>  Semakin sedikit koneksi aktif, semakin cepat PostgreSQL berfungsi (lihat grafik di atas). </p><br><p>  Klien yang beroperasi dalam mode pipelined (tokio-postgres) memungkinkan Anda untuk secara efektif menggunakan satu koneksi dengan PostgreSQL untuk pemrosesan paralel permintaan pengguna.  Penangan permintaan HTTP membuang perintah SQL mereka dalam satu antrian dan berbaris di yang lain untuk menerima hasil.  Hasilnya menyenangkan, keterlambatan minimal, semua orang senang.  Kinerja keseluruhan lebih tinggi daripada sistem dengan kumpulan koneksi. </p><br><p>  Jadi, Anda perlu meninggalkan kolam, menulis klien pipa PostgreSQL, dan kebahagiaan dan kecepatan luar biasa akan segera datang? </p><br><p>  Mungkin  Tapi tidak sekaligus. </p><br><h2 id="kogda-konveyernyy-rezhim-vryad-li-spaset-i-uzh-tochno-ne-sohranit">  Ketika mode konveyor tidak mungkin untuk menyimpan dan tentu saja tidak akan menyimpan </h2><br><p>  Skema yang digunakan dalam kode benchmark tidak akan berfungsi dengan transaksi PostgreSQL. </p><br><p>  Dalam tolok ukur, transaksi tidak diperlukan dan kode ditulis dengan mempertimbangkan bahwa tidak akan ada transaksi.  Dalam praktiknya, itu terjadi. </p><br><p>  Jika kode backend membuka transaksi PostgreSQL (misalnya, untuk membuat perubahan dalam dua tabel atom), semua perintah yang dikirim melalui koneksi ini akan dieksekusi di dalam transaksi ini. </p><br><p>  Karena koneksi dengan PostgreSQL digunakan secara paralel, semuanya menjadi kacau.  Perintah yang harus dijalankan dalam transaksi yang dirancang oleh pengembang dicampur dengan perintah sql yang diprakarsai oleh penangan permintaan http paralel.  Kami akan menerima kehilangan data acak dan masalah dengan integritasnya. </p><br><p>  Jadi halo transaksi - selamat tinggal penggunaan paralel satu koneksi.  Anda harus memastikan bahwa koneksi tidak digunakan oleh penangan permintaan http lain.  Anda harus berhenti memproses permintaan http masuk sebelum menutup transaksi, atau menggunakan kumpulan untuk transaksi, membuka beberapa koneksi ke server database.  Ada beberapa implementasi pool untuk Rust, dan bukan satu.  Selain itu, mereka ada di Rust secara terpisah dari implementasi klien database.  Anda dapat memilih sesuai selera, warna, bau atau secara acak.  Go tidak bekerja seperti itu.  Kekuatan generik, ya. </p><br><p>  Poin penting: dalam tes, kode yang saya cari, transaksi tidak terbuka.  Pertanyaan ini sama sekali tidak sepadan.  Kode benchmark dioptimalkan untuk tugas tertentu dan kondisi operasi aplikasi yang sangat spesifik.  Keputusan untuk menggunakan satu koneksi per aliran server mungkin dibuat secara sadar dan ternyata sangat efektif. </p><br><h2 id="est-v-kode-benchmarka-esche-chto-to-interesnoe">  Apakah ada hal lain yang menarik dalam kode benchmark? </h2><br><p>  Ya </p><br><p>  Skenario untuk mengukur kinerja dijabarkan dengan sangat rinci.  Serta kriteria yang harus dipenuhi oleh kode yang berpartisipasi dalam pengujian.  Salah satunya adalah bahwa semua permintaan ke server database harus dieksekusi secara berurutan. </p><br><p>  Fragmen kode berikut (sedikit disingkat) sepertinya tidak memenuhi kriteria: </p><br><pre> <code class="rust hljs"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> worlds = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::with_capacity(num); <span class="hljs-comment"><span class="hljs-comment">//  num    PostgreSQL for _ in 0..num { let w_id: i32 = self.rng.gen_range(1, 10_001); worlds.push( self.cl .query(&amp;self.world, &amp;[&amp;w_id]) .into_future() .map(move |(row, _)| { // ... }), ); } //     stream::futures_unordered(worlds) .collect() .and_then(move |worlds| { // ... })</span></span></code> </pre> <br><p>  Semuanya tampak seperti peluncuran khas proses paralel.  Tetapi, karena satu koneksi ke PostgreSQL digunakan, permintaan ke server database dikirim secara berurutan.  Satu per satu  Seperti yang diminta.  Tidak ada kejahatan </p><br><p>  Kenapa begitu  Yah, pertama, dalam kode (itu diberikan di kantor editorial, yang bekerja di ronde ke-18) async / menunggu belum digunakan, itu muncul di Rust nanti.  Dan melalui futures <code>num</code> , lebih mudah untuk mengirim query SQL "secara paralel" - seperti pada kode di atas.  Ini memungkinkan Anda untuk mendapatkan beberapa peningkatan kinerja tambahan: sementara PostgreSQL menerima dan memproses permintaan SQL pertama, sisanya dimasukkan ke dalamnya.  Server web tidak menunggu hasil dari masing-masing, tetapi beralih ke tugas-tugas lain dan kembali ke memproses permintaan http hanya ketika semua query SQL selesai. </p><br><p>  Untuk PostgreSQL, bonusnya adalah tipe kueri yang sama dalam konteks yang sama (koneksi) berjalan berurutan.  Kemungkinan bahwa rencana kueri tidak akan dibangun kembali meningkat. </p><br><p>  Ternyata keuntungan dari mode pipeline (lihat diagram dari dokumentasi tokio-postgres) sepenuhnya dieksploitasi bahkan ketika memproses satu permintaan http. </p><br><p>  Apa lagi </p><br><h2 id="ispolzovanie-uproschennogo-protokola-simple-query-dlya-paketnogo-obnovleniya">  Menggunakan protokol kueri sederhana untuk pembaruan kumpulan </h2><br><p>  Protokol komunikasi antara klien dan server PostgreSQL memungkinkan metode alternatif untuk mengeksekusi perintah SQL.  Protokol biasa (Extended Query) melibatkan pengiriman beberapa pesan kepada klien: Parse, Bind, Execute, dan Sync.  Alternatif adalah protokol Pertanyaan Sederhana, yang menurutnya satu pesan sudah cukup untuk mengeksekusi perintah dan mendapatkan hasil - Permintaan. </p><br><p>  Perbedaan utama antara protokol yang biasa adalah transfer parameter permintaan: mereka dikirimkan secara terpisah dari perintah itu sendiri.  Itu lebih aman.  Protokol yang disederhanakan mengasumsikan bahwa semua parameter kueri SQL akan dikonversi ke string dan dimasukkan ke dalam tubuh kueri. </p><br><p>  Solusi menarik yang digunakan dalam benchmark actix-web adalah memperbarui beberapa entri tabel dengan satu perintah yang dikirim melalui protokol Pertanyaan Sederhana. </p><br><p>  Menurut patokan, saat memproses permintaan pengguna, server web harus memperbarui beberapa catatan dalam tabel, menulis angka acak.  Jelas, memperbarui catatan secara berurutan dengan kueri berurutan membutuhkan waktu lebih lama dari satu kueri yang memperbarui semua catatan sekaligus. </p><br><p>  Permintaan yang dihasilkan dalam kode tes terlihat seperti ini: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> world <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> randomnumber = temp.randomnumber <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> temp(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, randomnumber) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> temp.id = world.id</code> </pre> <br><p>  Di mana <code>(1, 2), (2, 3)</code> adalah pasangan pengidentifikasi baris / nilai baru dari bidang nomor acak. </p><br><p>  Jumlah catatan yang diperbarui adalah variabel, persiapan (persiapan) terlebih dahulu tidak masuk akal.  Karena data untuk memperbarui adalah angka, dan sumbernya dapat dipercaya (kode tes itu sendiri), tidak ada risiko injeksi SQL, data hanya dimasukkan dalam tubuh SQL dan semuanya dikirim menggunakan protokol Pertanyaan Sederhana. </p><br><p>  Pertanyaan Sederhana dikabarkan sekitar.  Saya bertemu rekomendasi: "Bekerja hanya pada protokol Pertanyaan Sederhana, dan semuanya akan cepat dan baik."  Saya melihatnya dengan banyak skeptisisme.  Pertanyaan Sederhana memungkinkan Anda untuk mengurangi jumlah pesan yang dikirim ke server PostgreSQL dengan memindahkan pemrosesan parameter kueri ke sisi klien.  Anda dapat melihat keuntungan untuk kueri yang dihasilkan secara dinamis dengan sejumlah parameter variabel.  Untuk jenis kueri SQL yang sama (yang lebih umum), keuntungannya tidak jelas.  Baik dan seberapa aman pemrosesan parameter kueri akan berubah, dalam kasus Simple Query menentukan implementasi pustaka klien. </p><br><p>  Seperti yang saya tulis di atas, dalam hal ini, badan query SQL dihasilkan secara dinamis, data numerik dan dihasilkan oleh server itu sendiri.  Kombinasi sempurna untuk Permintaan Sederhana.  Tetapi bahkan dalam kasus ini, ada baiknya menguji opsi lain.  Alternatif tergantung pada platform PostgreSQL dan klien: pgx (klien untuk Go) memungkinkan untuk mengirim paket perintah, JDBC - untuk mengeksekusi satu perintah beberapa kali berturut-turut dengan parameter yang berbeda.  Kedua solusi dapat berjalan pada kecepatan yang sama atau bahkan lebih cepat. </p><br><h2 id="tak-pochemu-rust-lidiruet">  Jadi mengapa Rust memimpin? </h2><br><p>  Pemimpin, tentu saja, bukan Rust.  Tes berdasarkan actix-web memimpin - dialah yang menetapkan "langit-langit" kinerja.  Ada, misalnya, roket dan besi, yang menempati posisi sederhana.  Tetapi pada saat ini, itu adalah actix-web yang menentukan potensi untuk menggunakan Rust dalam pengembangan web.  Bagi saya, potensinya sangat tinggi. </p><br><p>  Server "rahasia" lain yang tidak terlihat, tetapi penting berdasarkan pada actix-web, yang memungkinkan kami untuk mengambil tempat pertama di semua tolok ukur TechEmpower - dalam cara kerjanya dengan PostgreSQL: </p><br><ol><li>  Hanya satu koneksi dengan PostgreSQL per aliran server web terbuka.  Koneksi ini menggunakan mode pipelined, yang memungkinkannya digunakan secara efektif untuk pemrosesan paralel permintaan pengguna. </li><li>  Semakin sedikit koneksi aktif, semakin cepat PostgreSQL merespons.  Kecepatan pemrosesan permintaan pengguna meningkat.  Pada saat yang sama, di bawah beban, seluruh sistem bekerja lebih stabil (keterlambatan dalam memproses permintaan yang masuk lebih rendah, mereka tumbuh lebih lambat). </li></ol><br><p>  Di mana kecepatan penting, opsi ini mungkin akan lebih cepat daripada menggunakan multiplexer (seperti pgbouncer dan pengembaraan).  Dan tentu saja dia lebih cepat dalam tolok ukur. </p><br><p>  Sangat menarik bagaimana async / menunggu, yang muncul di Rust, dan drama terbaru dengan actix-web akan memengaruhi popularitas Rust dalam pengembangan web.  Menarik juga bagaimana hasil tes akan berubah setelah memprosesnya pada async / menunggu. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id485452/">https://habr.com/ru/post/id485452/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id485428/index.html">Program LyX yang misterius. Bagian 5</a></li>
<li><a href="../id485430/index.html">Editor teks multi-pengguna yang sederhana dengan enkripsi ujung ke ujung</a></li>
<li><a href="../id485438/index.html">Menguji Komponen UI Bereaksi</a></li>
<li><a href="../id485448/index.html">Radio FM lain di RDA5807 menjalankan Arduino</a></li>
<li><a href="../id485450/index.html">Apa yang baru di SObjectizer-5.7.0 dan apa yang menunggu proyek ini selanjutnya?</a></li>
<li><a href="../id485454/index.html">Memulai dengan Pengembalian Pengguna: Kiat untuk Model Hooked</a></li>
<li><a href="../id485458/index.html">Knalpot howitzer</a></li>
<li><a href="../id485460/index.html">20 perpustakaan untuk aplikasi iOS yang spektakuler</a></li>
<li><a href="../id485462/index.html">Kami berurusan dengan eSIM (+ wawancara dengan pakar)</a></li>
<li><a href="../id485464/index.html">Game html5 pertama saya, dari Alice Yandex dan memberikan kemenangan untuk aplikasi seluler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>