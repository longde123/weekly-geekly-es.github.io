<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😊 ⛈️ 🎩 Matematika fixed-point cepat untuk aplikasi keuangan di Jawa 🌁 🐲 ✍🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bukan rahasia lagi bahwa informasi keuangan (akun, posting dan pembukuan lainnya) tidak terlalu ramah dengan angka floating point, dan banyak artikel ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Matematika fixed-point cepat untuk aplikasi keuangan di Jawa</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425565/"><p>  Bukan rahasia lagi bahwa informasi keuangan (akun, posting dan pembukuan lainnya) tidak terlalu ramah dengan angka floating point, dan banyak artikel merekomendasikan menggunakan aritmatika titik tetap.  Di Java, format ini, pada kenyataannya, hanya diwakili oleh kelas BigDecimal, yang tidak selalu dapat digunakan karena alasan kinerja.  Kami harus mencari alternatif.  Artikel ini menjelaskan perpustakaan Java yang ditulis sendiri untuk melakukan operasi aritmatika pada angka presisi-tetap.  Perpustakaan diciptakan untuk bekerja dalam aplikasi keuangan berkinerja tinggi dan memungkinkan Anda untuk bekerja dengan akurasi 9 desimal sambil mempertahankan kinerja yang dapat diterima.  Tautan ke sumber dan tolok ukur diberikan di akhir artikel. </p><a name="habracut"></a><br><h1 id="arifmetika-s-plavayuschey-tochkoy">  Aritmatika titik mengambang </h1><br><p>  Komputer modern dapat melakukan operasi aritmatika hanya dengan akurasi terbatas.  Ini adalah perangkat diskrit yang mungkin tidak berfungsi dengan semua angka yang mungkin, tetapi hanya dengan sebagian himpunan bagiannya yang dapat dihitung.  Format yang paling umum untuk bekerja dengan bilangan real dalam memori komputer adalah titik mengambang (biner) - titik mengambang (biner), ketika angka disimpan dalam bentuk M * 2 ^ E, di mana M dan E adalah bilangan bulat mantissa dan urutan bilangan.  Tetapi beberapa angka, seperti 0,1, tidak dapat direpresentasikan secara akurat dalam format ini.  Oleh karena itu, dalam proses perhitungan yang rumit, beberapa kesalahan pasti terakumulasi.  Artinya, hasil perhitungan mesin, katakan 0,1 + 0,1 + 0,1, tidak bertepatan dengan 0,3 matematis yang benar.  Mengingat hal di atas, saat pemrograman aritmatika kompleks, Anda dapat mengikuti beberapa strategi: </p><br><p>  Strategi 1 - abaikan.  Abaikan kesalahan, pertimbangkan semua operasi idealnya matematis dan berharap akurasi yang tersedia cukup untuk hasil yang dapat diterima.  Opsi paling umum. </p><br><p>  Strategi 2 - menghitung dengan cermat.  Rumus untuk menghitung kesalahan mesin telah dikenal selama beberapa dekade.  Mereka memungkinkan untuk memperkirakan kesalahan relatif dari operasi aritmatika dari atas.  Mungkin, inilah yang harus Anda lakukan untuk simulasi numerik serius.  Masalahnya adalah itu sangat memakan waktu.  Faktanya, setiap + - * / karakter dalam kode harus disertai dengan perhitungan kesalahan.  Anda harus memperhitungkan semua dependensi antara perhitungan dan ulangi prosedur setiap kali Anda mengubah kode. </p><br><p>  Strategi 3 - gunakan titik desimal (floating desimal point) alih-alih biner.  Artinya, simpan angka-angka dalam bentuk M * 10 ^ E.  Ini tidak menyelesaikan masalah kesalahan (mantissa masih dibulatkan ke sejumlah digit signifikan), tetapi setidaknya semua angka "sederhana" untuk seseorang (seperti 1,1) kini secara akurat terwakili dalam memori.  Pengembaliannya akan menjadi kinerja.  Setiap normalisasi angka (yaitu, penurunan setara dalam mantra dan peningkatan urutan) memerlukan pembagian dengan kekuatan 10, yang tidak terlalu cepat, tidak seperti pembagian dengan kekuatan 2. Dan Anda harus menormalkan banyak - dengan setiap penambahan atau pengurangan dengan urutan yang berbeda. </p><br><p>  Strategi 4 - gunakan titik tetap (titik desimal tetap).  Penyederhanaan strategi 3, ketika kita memperbaiki urutan E. Dalam hal ini, normalisasi tidak diperlukan untuk penambahan / pengurangan.  Selain itu, semua perhitungan akan memiliki kesalahan absolut yang sama.  Artikel ini dikhususkan untuk strategi ini. </p><br><h1 id="arifmetika-s-fiksirovannoy-tochkoy">  Aritmatika titik tetap </h1><br><p>  Berbeda dengan fisika, di mana kesalahan relatif adalah penting, hanya mutlak diperlukan dalam keuangan.  Jika, setelah transaksi keuangan yang rumit, pelanggan ditagih $ 1.000.000,23 sementara dia mengharapkan $ 1.000.000, 18, maka beberapa kesulitan mungkin timbul.  Penjelasan seperti "mengapa Anda perlu akurasi dalam 8 digit signifikan ??"  mungkin tidak naik  Dan intinya di sini bukan dalam 5 sen kerugian (untuk berbuat sebaliknya, "mendukung" klien tidak jauh lebih baik), tetapi dalam inkonsistensi dalam akuntansi.  Oleh karena itu, aturan perhitungan dan pembulatan secara jelas ditentukan antara para pihak, dan artefak dari penggunaan variabel ganda dan mengambang terkadang menyulitkan kehidupan. </p><br><p>  Java memiliki kelas standar untuk aritmatika titik tetap - BigDecimal.  Ada dua masalah dengan itu: itu lambat (karena universalitasnya) dan tidak stabil.  Ketidakstabilan berarti bahwa operasi apa pun mengalokasikan objek pada heap.  Memilih dan melepaskan dalam hal suatu objek membutuhkan sedikit waktu, tetapi perhitungan intensif dalam kode "panas" membuat beban yang layak pada GC, yang dalam beberapa kasus tidak dapat diterima.  Anda dapat mengandalkan analisis melarikan diri dan skalarisasi, tetapi mereka sangat tidak stabil dalam arti bahwa bahkan sedikit perubahan dalam kode atau JIT (seperti malas memuat implementasi antarmuka baru) dapat mengubah seluruh struktur inline terbalik, dan metode ini bekerja dengan baik beberapa menit yang lalu, tiba-tiba mulai mengalokasikan memori dengan marah. <br>  UPD karena pertanyaan dalam komentar: <strong>Alasan utama untuk</strong> meninggalkan BigDecimal dan BigInteger sama sekali bukan kinerja komputasi yang rendah, tetapi kurangnya stabilitas dan pemilihan objek. </p><br><p>  Perpustakaan yang dijelaskan adalah hasil dari bosan menulis ulang aritmatika non-memori titik-tetap dari awal untuk setiap perusahaan baru, dan saya memutuskan untuk menulis perpustakaan saya sendiri untuk insourcing berikutnya. </p><br><p>  Saya akan segera menunjukkan contoh penggunaan sebelum beralih ke detail implementasi: </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sample</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Decimal margin; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Quantity cumQuantity = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Quantity(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Quantity contraQuantity = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Quantity(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Quantity cumContraQuantity = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Quantity(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Price priceWithMargin = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Price(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Price avgPrice = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Price(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sample</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> marginBp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// 1 + margin / 10000 this.margin = Decimal.create(marginBp).divRD(10000L).add(1); } public Price calculateAvgPrice(Quantity[] quantities, Price[] prices) { cumQuantity.set(0); contraQuantity.set(0); // avg = sum(q * p * margin) / sum(q) for (int i = 0; i &lt; quantities.length; i++) { cumQuantity.add(quantities[i]); priceWithMargin.set(prices[i]).mulRD(margin); contraQuantity.set(quantities[i]).mulRD(priceWithMargin); cumContraQuantity.add(contraQuantity); } return avgPrice.quotientRD(cumContraQuantity, cumQuantity); } public static void main(String[] args) throws ParseException { Price p1 = Price.create("1.5"); Price p2 = Price.create(1.6); Quantity q1 = Quantity.create("100"); Quantity q2 = Quantity.create(200); // apply 0.05% margin to the prices Sample sample = new Sample(5); System.out.println(sample.calculateAvgPrice(new Quantity[]{q1, q2}, new Price[]{p1, p2})); } }</span></span></code> </pre> <br><h1 id="ideya-realizacii">  Ide implementasi </h1><br><p>  Jadi, kita membutuhkan pembungkus yang bisa berubah dari integer primitive, lebih tepatnya, long'a, yang akan memberi kita hampir 19 digit signifikan (cukup untuk integer dan bagian fraksional).  Panjang, yang kami maksud adalah N desimal.  Misalnya, dengan N = 2, angka 2,56 disimpan sebagai 256 (biner 100000000).  Nomor negatif disimpan sebagai standar, dalam kode tambahan: </p><br><p>  <em>-2,56</em> <br>  <strong>-256</strong> </p><br><p>  (Selanjutnya, <em>huruf miring</em> menunjukkan angka dan perhitungan "matematis", dan <strong>dengan tebal</strong> representasi internal mereka) </p><br><p>  Bagi saya bermanfaat juga untuk memasukkan NaN sebagai nilai terpisah, yang dikembalikan jika terjadi kesalahan aritmatika (bukan pengecualian atau sampah).  <em>NaN</em> direpresentasikan secara internal sebagai <strong>Long.MIN_VALUE</strong> , "diperbanyak" melalui semua operasi dan memungkinkan untuk menentukan inversi tanda untuk semua angka yang tersisa. </p><br><p>  Mari kita coba perkirakan algoritma operasi aritmatika untuk kasus ketika N = 2. </p><br><p>  Penambahan dan pengurangan tidak membutuhkan gerakan tambahan, cukup gunakan nilai-nilainya seperti apa adanya: </p><br><p>  <em>1,20 + 2,30 = 3,50</em> <br>  <strong>120 + 230 = 350</strong> </p><br><p>  Perkalian dan pembagian membutuhkan normalisasi tambahan, yaitu, perkalian / pembagian sebesar 10 ^ N (oleh 100 dalam contoh kita) </p><br><p>  <em>1.20 * 2.00 = 2.40</em> <br>  <strong>120 * 200/100 = 240</strong> </p><br><p>  <em>1.20 / 2.00 = 0.60</em> <br>  <strong>100 * 120/200 = 60</strong> </p><br><p>  Divisi tambahan bukanlah operasi tercepat.  Tetapi dalam kasus ini, ini adalah pembagian dengan konstanta, karena kami sebelumnya menetapkan N = 2 dan 10 ^ N = 100.  Pembagian dengan konstanta, terutama oleh "cantik" (tipe 10), dioptimalkan secara intensif dalam CPU dan jauh lebih cepat daripada pembagian dengan angka acak.  Kami melakukan banyak divisi dengan 10 setiap kali kami mengonversi angka apa pun menjadi string (misalnya, dalam log), dan produsen CPU mengetahuinya ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk rincian lebih lanjut tentang pengoptimalan,</a> lihat "Pembagian dengan konstanta"). </p><br><p>  Untuk mengkonsolidasikan pemahaman tentang apa yang kita lakukan, saya akan memberikan satu operasi lagi: inversi nomor, yaitu 1 / x.  Ini adalah kasus pembagian khusus, Anda hanya perlu mengirimkan 1,00 dalam format kami dan jangan lupa untuk menormalkan: </p><br><p>  <em>1,00 / 2,00 = 0,50</em> <br>  <strong>100 * 100/200 = 50</strong> </p><br><p>  Nah, sementara semuanya cukup sederhana, mari kita coba menyelidiki detailnya. </p><br><h1 id="okruglenie">  Pembulatan </h1><br><p>  Mari kita coba menggambar nomor lain: </p><br><p>  <em>1,00 / 3,00 = 0,33</em> <br>  <strong>100 * 100/300 = 33</strong> </p><br><p>  Hasil matematika yang jujur ​​terletak antara 0,33 dan 0,34, tetapi kita tidak dapat membayangkannya dengan tepat.  Jalan mana yang harus dilalui?  Biasanya dibulatkan menjadi 0, dan ini adalah cara tercepat (didukung perangkat keras).  Tetapi, kembali ke masalah keuangan nyata, ini tidak selalu terjadi.  Biasanya, saat memproses transaksi dengan klien, pembulatan adalah "mendukung klien."  Artinya, harga dibulatkan jika pelanggan menjual, dan turun jika pelanggan membeli.  Tetapi opsi lain mungkin diperlukan, misalnya, pembulatan aritmatika ke nomor terdekat dengan subtipe (setengah naik, setengah turun, setengah bahkan) untuk meminimalkan inkonsistensi akuntansi.  Atau pembulatan ke ± tak terhingga untuk harga negatif (untuk beberapa instrumen keuangan).  Java BigDecimal sudah berisi daftar mode pembulatan standar, dan perpustakaan yang dijelaskan mendukung semuanya.  TIDAK PERLU mengembalikan NaN jika operasi secara tak terduga membutuhkan pembulatan. </p><br><p>  Dalam mode round-up, perhitungan kami harus memberikan: </p><br><p>  <em>1,00 / 3,00 = 0,34</em> <br>  <strong>100 * 100/300 + 1 = 34</strong> </p><br><p>  Bagaimana cara mengetahui apa yang Anda butuhkan untuk menambahkan sebuah unit?  Anda membutuhkan sisa dari divisi 10.000% 300 = 100. Yang selambat divisi itu sendiri.  Untungnya, jika Anda menulis berturut-turut dalam kode "a / b; a% b", maka JIT akan menyadari bahwa 2 divisi tidak diperlukan, hanya satu perintah assembler div yang mengembalikan 2 angka (hasil bagi dan sisa). </p><br><p>  Opsi pembulatan lainnya sedikit lebih rumit, tetapi juga dapat dihitung berdasarkan sisanya dan pembagi. </p><br><p>  Dalam API, saya sengaja menyebutkan pembulatan di mana pun itu terjadi, baik sebagai parameter atau sebagai akhiran <strong>R</strong> <strong>D</strong> ound <strong>D</strong> sendiri dalam metode yang defaultnya nol. </p><br><h1 id="perepolnenie">  Overflow </h1><br><p>  Kita sampai pada bagian yang paling sulit.  Ingat kembali penggandaan kita: </p><br><p>  <em>1.20 * 2.00 = 2.40</em> <br>  <strong>120 * 200/100 = 240</strong> </p><br><p>  Sekarang bayangkan kita berada di tahun 1980-an dan kita memiliki prosesor 16-bit.  Artinya, hanya kekurangan yang tersedia bagi kami dengan nilai maksimum 65535. Perkalian pertama akan melimpah dan akan sama dengan 240000 &amp; 0xFFFF = 44392 (jika tidak ditandatangani, dengan tanda itu juga akan menjadi negatif), yang akan menghancurkan hasil bagi kami. </p><br><p>  Itu tidak akan berhasil.  Kami memiliki 2 argumen normal (sesuai dengan rentang nilai kami), dan hasil yang diharapkan normal yang sama, tetapi kami meluap di tengah jalan.  Situasi yang sama persis mungkin dengan long'om 64-bit, hanya angka yang membutuhkan lebih banyak. </p><br><p>  Pada 1980-an, kita membutuhkan multiplikasi yang memberikan hasil 32-bit.  Hari ini kita membutuhkan perkalian dengan hasil 128-bit.  Yang paling menjengkelkan adalah bahwa kedua perkalian tersedia di assembler 8086 dan x86-64, masing-masing, tetapi kita tidak dapat menggunakannya dari Jawa!  JNI, bahkan dalam kasus peretasan dengan JavaCritical cepat, memberikan overhead puluhan nanodetik, memperkenalkan kesulitan dengan penyebaran dan kompatibilitas, membekukan GC selama durasi panggilan.  Selain itu, kita bagaimanapun harus mengembalikan hasil 128-bit dari metode asli, dan menulis dengan referensi ke array (dalam memori) adalah penundaan tambahan. </p><br><p>  Secara umum, saya harus menulis perkalian dan pembagian manual.  Kolom  Saya membutuhkan 2 operasi tambahan: </p><br><ol><li>  A (64) * B (64) = T (128);  T (128) / N (32) = Q (64), R (32) - sebagai bagian dari titik tetap perkalian A * B </li><li>  N (32) * A (64) = T (96);  T (96) / B (64) = Q (64), R (64) - sebagai bagian dari divisi titik tetap A / B <br>  (dalam tanda kurung menunjukkan dimensi data dalam bit, T adalah variabel sementara yang tidak boleh meluap) </li></ol><br><p>  Kedua operasi mengembalikan hasil bagi dan sisanya (satu sebagai hasil dari metode, yang kedua di bidang objek).  Mereka juga bisa meluap, tetapi hanya pada langkah terakhir, ketika ini tidak bisa dihindari.  Berikut ini sebuah contoh (dari tahun 1980-an): </p><br><p>  <em>500,00 / 0,50 = 1000,00</em> <br>  <strong>100 * 50.000 / 50 = 100.000</strong> - melimpah! </p><br><p>  Pembagian kolom a la Knut bukan algoritma yang termudah.  Plus, itu juga harus relatif cepat.  Oleh karena itu, kode dari kedua operasi ini adalah ratusan baris bit magic yang agak berat, saya akan membutuhkan banyak waktu untuk mengingat kembali apa sebenarnya yang terjadi di sana.  Saya menarik mereka ke kelas yang terpisah dan berkomentar sedetail mungkin. </p><br><p>  Algoritma multiplikasi tidak terbatas pada menjalankan operasi 1, tetapi kode yang tersisa tidak begitu rumit dan hanya menambahkan dukungan untuk angka negatif, pembulatan, dan NaN. </p><br><p>  Biasanya (kecuali dalam kasus khusus), kedua operasi mengandung 4 perkalian dan 2 divisi.  Operasi 1 secara signifikan lebih cepat dari 2, karena di dalamnya pembagian ini konstan. </p><br><p>  By the way, jika ada yang memperhatikan, N (32) adalah 10 ^ N kami untuk normalisasi.  Ini adalah 32-bit, dari sini N dapat menjadi maksimum 9. Dalam aplikasi nyata yang saya lihat, 2, 4 atau 8 tempat desimal digunakan.  Saya belum melihat lebih dari 9, jadi itu sudah cukup.  Jika Anda membuat 10 ^ N 64-bit, kode menjadi lebih rumit (dan melambat) bahkan lebih. </p><br><h1 id="neskolko-raznyh-tochnostey">  Beberapa presisi berbeda </h1><br><p>  Kadang-kadang perlu untuk melakukan operasi pada argumen dengan jumlah desimal yang berbeda.  Minimal, masukkan operasi yang melibatkan panjang biasa. </p><br><p>  Sebagai contoh: </p><br><p>  <em>2.0000 (N = 4) + 3.00 (N = 2) = 5.0000 (N = 4)</em> <br>  <strong>20.000 + 300 * 100 = 50.000</strong> </p><br><p>  <em>3,00 (N = 2) + 2.0000 (N = 4) = 5.00 (N = 2)</em> <br>  <strong>300 + 20.000 / 100 = 500</strong> </p><br><p>  Dalam hal ini, diperlukan normalisasi tambahan dari salah satu argumen.  Perhatikan bahwa secara matematis kedua operasi adalah sama, tetapi karena akurasi hasil yang berbeda, mereka dihitung secara berbeda.  Perlu juga dicatat bahwa operasi kedua umumnya membutuhkan pembulatan. </p><br><p>  Jumlah tempat desimal TIDAK disimpan dalam objek.  Sebagai gantinya, sebuah subclass terpisah diasumsikan untuk setiap presisi.  Nama kelas dapat berorientasi bisnis, misalnya Harga (N = 8), Kuantitas (N = 2).  Dan mereka dapat digeneralisasi: Decimal1, Decimal2, Decimal3, ... Semakin besar akurasi, semakin kecil rentang nilai yang disimpan, kisaran minimum memiliki Decimal9: ± 9223372036.  Diasumsikan bahwa satu atau dua kelas akan cukup untuk mencakup fungsionalitas yang diperlukan, dalam hal ini metode getScale abstrak kemungkinan akan divirtualisasi dan sebaris.  Subkelas (bukan bidang tambahan) memungkinkan Anda untuk secara ketat menentukan akurasi argumen dan hasil, serta sinyal tentang kemungkinan pembulatan pada tahap kompilasi. </p><br><p>  Perpustakaan memungkinkan operasi dengan maksimum 2 (tetapi bukan 3) dengan akurasi berbeda.  Artinya, keakuratan kedua argumen harus bersamaan, atau keakuratan salah satu argumen dan hasilnya.  Sekali lagi, mendukung 3 presisi berbeda akan sangat memperlambat kode dan mempersulit API.  Sebagai argumen, Anda dapat melewati panjang reguler, yang untuk itu akurasi N = 0 diasumsikan. </p><br><p>  <em>2.0000 / 3.0 = 0.6667</em> - ok (2 presisi berbeda) <br>  <em>2/3 = 0.6667</em> - ok (argumen panjang, hasil desimal) <br>  <em>2 / 3.0 = 0.6667</em> - tidak mungkin!  (3 presisi berbeda) </p><br><h1 id="dostoinstva-i-nedostatki">  Keuntungan dan kerugian </h1><br><p>  Jelas, komputasi bit tinggi yang dilakukan oleh perpustakaan lebih lambat daripada yang didukung perangkat keras.  Namun, overhead tidak terlalu besar (lihat benchmark di bawah). </p><br><p>  Selain itu, karena kurangnya kelebihan operator di Jawa, menggunakan metode bukannya operator aritmatika mempersulit persepsi kode. </p><br><p>  Berdasarkan hal ini, perpustakaan biasanya digunakan di tempat-tempat di mana hilangnya keakuratan absolut sangat penting.  Misalnya, menghitung statistik keuangan yang akurat, dengan mempertimbangkan indikator keuangan saat ini (posisi perdagangan, PnL, pesanan yang dieksekusi).  Dalam pertukaran jaringan informasi keuangan antar sistem, juga lebih mudah menggunakan format dengan titik desimal (bukan biner). </p><br><p>  Algoritma matematika yang kompleks (pemodelan, statistik, peramalan) biasanya lebih mudah dilakukan secara ganda, karena hasilnya dalam hal apapun tidak sepenuhnya akurat. </p><br><h1 id="kod-i-benchmarki">  Kode dan tolok ukur </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode</a> </p><br><table><tbody><tr><th>  Tolok ukur </th><th>  Mode </th><th>  Cnt </th><th>  Skor </th><th>  Kesalahan </th><th>  Unit <br></th></tr><tr><td>  DecimalBenchmark.control </td><td>  rata </td><td>  200 </td><td>  10.072 </td><td>  ± 0,074 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.multiplyNative </td><td>  rata </td><td>  200 </td><td>  10.625 </td><td>  ± 0,142 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.multiplyMyDecimal </td><td>  rata </td><td>  200 </td><td>  35.840 </td><td>  ± 0,121 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.multiplyBigDecimal </td><td>  rata </td><td>  200 </td><td>  126.098 </td><td>  ± 0,408 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.quotientNative </td><td>  rata </td><td>  200 </td><td>  70.728 </td><td>  ± 0,230 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.quotientMyDecimal </td><td>  rata </td><td>  200 </td><td>  138.581 </td><td>  ± 7.102 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.quotientBigDecimal </td><td>  rata </td><td>  200 </td><td>  179.650 </td><td>  ± 0,849 </td><td>  ns / op <br></td></tr></tbody></table><br><p>  Secara umum, perkalian adalah 4 kali lebih cepat dari BigDecimal, pembagian 1,5.  Tingkat pembagian <em>sangat</em> tergantung pada argumen, karenanya penyebaran nilai. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id425565/">https://habr.com/ru/post/id425565/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id425555/index.html">Charles Nutter pada bahasa dinamis di JVM di jug.msk.ru</a></li>
<li><a href="../id425557/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 10: Eksekusi Simbolik, Bagian 1</a></li>
<li><a href="../id425559/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 10: Eksekusi Simbolik, Bagian 3</a></li>
<li><a href="../id425561/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 10: Eksekusi Simbolik, Bagian 2</a></li>
<li><a href="../id425563/index.html">California melarang penjualan perangkat IoT dengan atau tanpa kata sandi sederhana</a></li>
<li><a href="../id425569/index.html">Pengujian Fungsional PCB</a></li>
<li><a href="../id425571/index.html">Mengamankan server web di Linux</a></li>
<li><a href="../id425575/index.html">Peradangan saraf</a></li>
<li><a href="../id425581/index.html">Jetpack 11 Oktober 1961: Presiden membuka mulutnya ...</a></li>
<li><a href="../id425583/index.html">Segala sesuatu yang masih membingungkan robot mobil, dimulai dengan burung camar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>