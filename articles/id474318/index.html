<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌉 🏗️ 😔 Apa itu tabel tabel virtual? 🍯 👴🏽 👩🏾‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Suatu kali di Slack, saya menemukan akronim baru untuk glosarium akronim C ++ saya: “VTT.” Godbolt : 



test.o: In function `MyClass': test.cc:3: und...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apa itu tabel tabel virtual?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474318/">  Suatu kali di Slack, saya menemukan akronim baru untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">glosarium akronim C ++</a> saya: “VTT.”  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Godbolt</a> : <br><br><pre><code class="plaintext hljs">test.o: In function `MyClass': test.cc:3: undefined reference to `VTT for MyClass'</code> </pre> <br>  "VTT" dalam konteks ini berarti "tabel tabel virtual".  Ini adalah struktur data tambahan yang digunakan (dalam Itanium C ++ ABI) saat membuat beberapa kelas dasar yang diwarisi sendiri dari kelas basis virtual.  VTT mengikuti aturan tata letak yang sama dengan tabel virtual (vtable) dan mengetik informasi (typeinfo), jadi jika Anda mendapatkan kesalahan di atas, Anda bisa mengganti secara mental "vtable" untuk "VTT" dan mulai debugging.  (Kemungkinan besar, Anda meninggalkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi kunci dari</a> kelas tidak terdefinisi).  Untuk melihat mengapa VTT, atau struktur serupa, diperlukan, mari kita mulai dengan dasar-dasarnya. <br><a name="habracut"></a><br><h3>  Urutan Desain untuk Warisan Non-Virtual </h3><br>  Ketika kita memiliki hierarki warisan, kelas dasar dibangun <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mulai dari yang paling dasar</a> .  Untuk membangun Charlie, pertama-tama kita harus membangun kelas orang tuanya MrsBucket dan MrBucket, secara rekursif, untuk membangun MrBucket, pertama-tama kita harus membangun kelas orang tuanya GrandmaJosephine dan GrandpaJoe. <br><br>  Seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> :</span></span> A {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class"> :</span></span> C {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class"> :</span></span> B, D {}; <span class="hljs-comment"><span class="hljs-comment">//     // ABCDE</span></span></code> </pre> <br><h3>  Urutan Desain untuk Kelas Dasar Virtual </h3><br>  Tetapi warisan virtual membingungkan semua kartu!  Dengan warisan virtual, kita dapat memiliki hierarki berbentuk berlian di mana dua kelas induk yang berbeda dapat berbagi leluhur yang sama. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">G</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">M</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> G {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> G {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class"> :</span></span> M, F {}; <span class="hljs-comment"><span class="hljs-comment">//     // GMFE</span></span></code> </pre> <br>  Di bagian terakhir, setiap konstruktor bertanggung jawab untuk memanggil konstruktor dari kelas dasarnya.  Tapi sekarang kita memiliki warisan virtual, dan konstruktor M dan F entah bagaimana harus tahu bahwa tidak perlu untuk membangun G, karena itu umum.  Jika M dan F bertanggung jawab untuk membangun objek dasar dalam kasus ini, objek dasar umum akan dibangun dua kali, yang tidak terlalu baik. <br><br>  Untuk bekerja dengan sub-objek warisan virtual, Itanium C ++ ABI membagi setiap konstruktor menjadi dua bagian: konstruktor objek dasar dan konstruktor objek penuh.  Konstruktor objek dasar bertanggung jawab untuk membangun semua sub-objek warisan non-virtual (dan sub-objek mereka, dan menginstal vptr pada vtable mereka, dan menjalankan kode dalam kurung kurawal dalam kode C ++).  Konstruktor objek lengkap, yang disebut setiap kali Anda membuat objek C ++ lengkap, bertanggung jawab untuk membangun semua sub-objek dari warisan virtual objek yang diturunkan dan kemudian melakukan sisanya. <br><br>  Pertimbangkan perbedaan antara contoh ABCDE kami dari bagian sebelumnya dan contoh berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> A {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> C {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class"> :</span></span> B, D {}; <span class="hljs-comment"><span class="hljs-comment">//     // ACBDE</span></span></code> </pre> <br>  Konstruktor objek lengkap E pertama memanggil konstruktor objek dasar dari sub-objek virtual A dan C;  maka konstruktor dari objek pewarisan non-virtual B dan D disebut. B dan D tidak lagi bertanggung jawab untuk membangun A dan C, masing-masing. <br><br><h3>  Merancang tabel vtable </h3><br>  Misalkan kita memiliki kelas dengan beberapa metode virtual, misalnya, seperti ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Godbolt</a> ): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cat</span></span></span><span class="hljs-class"> {</span></span> Cat() { poke(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">poke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"meow"</span></span>); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lion</span></span></span><span class="hljs-class"> :</span></span> Cat { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> roar = <span class="hljs-string"><span class="hljs-string">"roar"</span></span>; Lion() { poke(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">poke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ roar += <span class="hljs-string"><span class="hljs-string">'!'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(roar.c_str()); } };</code> </pre> <br>  Ketika kita membangun Lion, kita mulai dengan membangun subobject Cat dasar.  Konstruktor poke Panggilan kucing ().  Pada titik ini, kami hanya memiliki satu objek Cat - kami belum menginisialisasi data anggota yang diperlukan untuk membuat objek Lion.  Jika konstruktor Cat memanggil Lion :: poke (), ia dapat mencoba mengubah anggota std :: string roar yang belum diinisialisasi dan kami mendapatkan UB.  Jadi, standar C ++ mengharuskan kita untuk melakukan ini di konstruktor Cat, panggilan ke metode virtual poke () harus memanggil Cat :: poke (), bukan Lion :: poke ()! <br><br>  Tidak ada masalah.  Kompiler hanya menyebabkan Cat :: Cat () (baik versi untuk objek dasar dan versi untuk objek lengkap) untuk memulai dengan mengatur vptr objek ke tabel objek Cat.  Lion :: Lion () akan memanggil Cat :: Cat (), dan kemudian mengatur ulang vptr ke pointer ke vtable untuk objek Cat di dalam Lion, sebelum menjalankan kode dalam tanda kurung.  Tidak masalah! <br><br><h3>  Penyeimbangan Warisan Virtual </h3><br>  Biarkan Kucing mewarisi dari Hewan.  Kemudian, vtable untuk Cat tidak hanya menyimpan pointer fungsi untuk fungsi anggota virtual Cat, tetapi juga offset dari subobjek virtual Hewan di dalam Cat.  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Godbolt</a> .) <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *data = <span class="hljs-string"><span class="hljs-string">"hi"</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cat</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Animal { Cat() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(data); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Nermal</span></span></span><span class="hljs-class"> :</span></span> Cat {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Garfield</span></span></span><span class="hljs-class"> :</span></span> Cat { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> padding; };</code> </pre> <br>  Konstruktor Cat menanyakan data Animal :: anggota.  Jika objek Cat ini adalah sub objek dasar objek Nermal, maka data anggotanya adalah pada offset 8, tepat di belakang vptr.  Tetapi jika objek Cat adalah subobject yang mendasari objek Garfield, maka data anggota berada pada offset 16, di belakang vptr dan Garfield :: padding.  Untuk mengatasinya, Itanium ABI menyimpan offset objek dasar virtual dalam tabel objek Cat.  Tabel untuk Cat-in-Nermal mempertahankan fakta bahwa Animal, subobject Cat yang mendasarinya, disimpan pada offset 8;  Tabel untuk Cat-in-Garfield mempertahankan fakta bahwa Animal, subobject Cat yang mendasarinya, disimpan pada offset 16. <br><br>  Sekarang gabungkan ini dengan bagian sebelumnya.  Compiler harus memastikan bahwa Cat :: Cat () (baik versi objek dasar dan versi objek lengkap) dimulai dengan menginstal vptr pada vtable untuk Cat-in-Nermal atau pada vtable untuk Cat-in-Garfield, tergantung pada jenisnya sebagian besar fasilitas turunan!  Tetapi bagaimana cara kerjanya? <br><br>  Konstruktor objek lengkap untuk objek yang paling diturunkan harus melakukan prapenghitungan tabel tabel mana yang ia inginkan untuk vptr dari sub objek objek yang akan direferensikan pada saat membangun objek, dan kemudian konstruktor objek lengkap untuk objek yang paling diturunkan harus meneruskan informasi ini ke konstruktor objek dasar sub objek objek. sebagai parameter tersembunyi!  Mari kita lihat kode yang dihasilkan untuk Cat :: Cat () ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Godbolt</a> ): <br><br><pre> <code class="cpp hljs">_ZN3CatC1Ev: #    Cat movq $_ZTV3Cat+<span class="hljs-number"><span class="hljs-number">24</span></span>, (%rdi) <span class="hljs-meta"><span class="hljs-meta"># this-&gt;vptr = &amp;vtable-for-Cat; retq _ZN3CatC2Ev: #     Cat movq (%rsi), %rax # fetch a value from rsi movq %rax, (%rdi) # this-&gt;vptr = *rsi; retq</span></span></code> </pre> <br>  Konstruktor objek dasar tidak hanya menerima parameter tersembunyi ini di% rdi, tetapi juga parameter VTT tersembunyi di% rsi!  Konstruktor objek dasar memuat alamat dari (% rsi) dan menyimpan alamat dalam tabel objek Cat. <br><br>  Siapa pun yang memanggil konstruktor objek Cat dasar bertanggung jawab untuk memprediksi alamat Cat :: Cat () mana yang harus ditulis dalam vptr dan untuk mengatur pointer di (% rsi) ke alamat itu. <br><br><h3>  Mengapa kita membutuhkan tingkat identitas lain? </h3><br>  Pertimbangkan konstruktor objek Nermal penuh. <br><br><pre> <code class="cpp hljs">_ZN3CatC2Ev: #    <span class="hljs-function"><span class="hljs-function">Cat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">movq</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%rsi)</span></span></span><span class="hljs-function">, %rax #    rsi movq %rax, </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%rdi)</span></span></span><span class="hljs-function"> </span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-meta"># this-&gt;vptr = *rsi; retq _ZN6NermalC1Ev: #    Nermal pushq %rbx movq %rdi, %rbx movl $_ZTT6Nermal+8, %esi # %rsi = &amp;VTT-for-Nermal callq _ZN3CatC2Ev #     Cat movq $_ZTV6Nermal+24, (%rbx) # this-&gt;vptr = &amp;vtable-for-Nermal popq %rbx retq _ZTT6Nermal: .quad _ZTV6Nermal+24 # vtable-for-Nermal .quad _ZTC6Nermal0_3Cat+24 # construction-vtable-for-Cat-in-Nermal</span></span></span></span></code> </pre> <br>  Mengapa _ZTC6Nermal0_3Cat + 24 terletak di bagian data dan alamatnya dilewatkan ke% rsi, alih-alih hanya meneruskan _ZTC6Nermal0_3Cat + 24 secara langsung? <br><br><pre> <code class="cpp hljs">#   ? _ZN3CatC2Ev: #     Cat movq %rsi, (%rdi) <span class="hljs-meta"><span class="hljs-meta"># this-&gt;vptr = rsi; retq _ZN6NermalC1Ev: #     Nermal pushq %rbx movq %rdi, %rbx movl $_ZTC6Nermal0_3Cat+24, %esi # %rsi = &amp;construction-vtable-for-Cat-in-Nermal callq _ZN3CatC2Ev #     Cat movq $_ZTV6Nermal+24, (%rbx) # this-&gt;vptr = &amp;vtable-for-Nermal popq %rbx retq</span></span></code> </pre> <br>  Ini karena kita dapat memiliki beberapa tingkat warisan!  Pada setiap tingkat pewarisan, konstruktor objek dasar harus mengatur vptr dan kemudian, mungkin, meneruskan kontrol ke rantai ke konstruktor basis berikutnya, yang dapat mengatur vptr ke beberapa nilai lain.  Ini menyiratkan daftar atau tabel pointer ke vtable. <br><br>  Berikut ini adalah contoh nyata ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Godbolt</a> ): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VB</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> member_of_vb = <span class="hljs-number"><span class="hljs-number">42</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Grandparent</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> VB { Grandparent() {} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parent</span></span></span><span class="hljs-class"> :</span></span> Grandparent { Parent() {} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Gretel</span></span></span><span class="hljs-class"> :</span></span> Parent { Gretel() : VB{<span class="hljs-number"><span class="hljs-number">1000</span></span>} {} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Hansel</span></span></span><span class="hljs-class"> :</span></span> Parent { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> padding; Hansel() : VB{<span class="hljs-number"><span class="hljs-number">2000</span></span>} {} };</code> </pre> <br>  Objek konstruktor dasar Grandparent harus mengatur vptr ke Grandparent - sesuatu yang lain, yang merupakan kelas yang paling diturunkan.  Konstruktor objek dasar Induk harus terlebih dahulu memanggil Grandparent :: Grandparent () dengan% rsi yang sesuai, dan kemudian mengatur vptr ke Induk - sesuatu yang lain, yang merupakan kelas yang paling diturunkan.  Cara untuk menerapkan ini untuk Gretel: <br><br><pre> <code class="cpp hljs">Gretel::Gretel() [  ]: pushq %rbx movq %rdi, %rbx movl $<span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>(%rdi) <span class="hljs-meta"><span class="hljs-meta"># imm = 0x3E8 movl $VTT for Gretel+8, %esi callq Parent::Parent() [  ] movq $vtable for Gretel+24, (%rbx) popq %rbx retq VTT for Gretel: .quad vtable for Gretel+24 .quad construction vtable for Parent-in-Gretel+24 .quad construction vtable for Grandparent-in-Gretel+24</span></span></code> </pre> <br>  Anda dapat melihat di Godbolt bahwa konstruktor objek dasar dari kelas Induk pertama memanggil Grandparent :: Grandparent () dengan% rsi + 8, kemudian menetapkan vptr sendiri ke (% rsi).  Jadi, di sini kita menggunakan fakta bahwa Gretel, dengan kata lain, dengan hati-hati meletakkan jalur remah roti yang diikuti oleh semua kelas dasar selama konstruksi. <br><br>  VTT yang sama digunakan dalam destructor ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Godbolt</a> ).  Sejauh yang saya tahu, baris nol dari tabel VTT tidak pernah digunakan.  Konstruktor Gretel memuat vtable untuk Gretel + 24 ke dalam vptr, tetapi ia tahu bahwa alamat ini statis, tidak perlu dimuat dari VTT.  Saya berpikir bahwa baris nol tabel dipertahankan hanya karena alasan historis.  (Dan tentu saja, kompiler tidak bisa begitu saja membuangnya, karena itu akan menjadi pelanggaran Itanium ABI dan tidak mungkin untuk menautkan ke kode lama yang menganut Itanium-ABI). <br><br>  Itu saja, kami melihat tabel tabel virtual, atau VTT. <br><br><h3>  Informasi lebih lanjut </h3><br>  Anda dapat menemukan informasi VTT di tempat-tempat ini: <br><br>  StackOverflow: “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa VTT untuk sebuah kelas?</a>  ” <br>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=http://web.archive.org/web/20190930143149/">Catatan VTable pada Berbagai Warisan dalam GCC C ++ Compiler v4.0.1</a> " (Morgan Deters, 2005) <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian Itanium C ++ ABI</a> , “VTT Order” <br><br>  Akhirnya, saya harus mengulangi bahwa VTT adalah fitur dari Itanium C ++ ABI, dan digunakan di Linux, OSX, dll.  MSVC ABI yang digunakan pada Windows tidak memiliki VTT, dan menggunakan mekanisme yang sama sekali berbeda untuk warisan virtual.  Saya (sejauh ini) hampir tidak tahu apa-apa tentang MSVC ABI, tapi mungkin suatu hari saya akan mengetahui semuanya dan menulis posting tentang itu! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id474318/">https://habr.com/ru/post/id474318/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id474306/index.html">Buat gaya penunjuk, fokus, dan status aktif berbeda.</a></li>
<li><a href="../id474308/index.html">Jenis untuk HTTP API yang ditulis dalam Python: pengalaman Instagram</a></li>
<li><a href="../id474310/index.html">Apakah ada angka acak di CSS?</a></li>
<li><a href="../id474312/index.html">Menginstal GUI pada Windows Server Core</a></li>
<li><a href="../id474316/index.html">Mobil listrik buatan rumah-bagian 1. Bagaimana semuanya dimulai dan bagaimana saya mencetak 1.000.000 tampilan di youtube</a></li>
<li><a href="../id474320/index.html">Krisis Komunitas DDD</a></li>
<li><a href="../id474322/index.html">ScalaConf 2019 - John Preacher, Holy Grail, dan Profesor Haskell</a></li>
<li><a href="../id474324/index.html">Mengapa matahari berputar mengelilingi bumi</a></li>
<li><a href="../id474326/index.html">Memahami perbedaan antara CI dan CD: "jika sesuatu menyebabkan rasa sakit, lakukan lebih sering"</a></li>
<li><a href="../id474330/index.html">Intisari materi menarik untuk pengembang seluler # 320 (28 Oktober - 3 November)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>