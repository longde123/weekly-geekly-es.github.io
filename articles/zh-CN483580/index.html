<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏇🏽 🚶🏽 🥉 VIM-这不仅是编辑器，而且还与您的所有工作环境集成在一起 👃🏿 ◽️ 🤚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="为什么Vim / Neovim特别好？ 您的工具包不仅是一个编辑器（它本身可以通过插件很好地扩展并且具有丰富的基本功能，并且在定制领域非常灵活），而且还包括您的整个工作环境 ，以及gnu / coreutils和不只是 您可以在不离开编辑器的情况下使用任何程序或解释器，并直接在编辑器中使用它。 
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>VIM-这不仅是编辑器，而且还与您的所有工作环境集成在一起</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483580/"><p> 为什么<strong>Vim</strong> / <strong>Neovim</strong>特别好？ 您的工具包不仅是一个编辑器（它本身可以通过插件很好地扩展并且具有丰富的基本功能，并且在定制领域非常灵活），而且还包括<strong>您的整个工作环境</strong> ，以及gnu / coreutils和不只是 您可以在不离开编辑器的情况下使用任何程序或解释器，并直接在编辑器中使用它。 </p><a name="habracut"></a><br><h2 id="predislovie"> 前言 </h2><br><p> 这篇文章是为某个私人圈子而匆忙撰写的，但是我认为很有可能将其发布在Habr上。 对于某些人来说，这可能会成为一种灵感，有人会帮助更好地理解Vim的哲学，而别人会为自己采取一些技巧。 为了以防万一，我会保留一点意见，我不希望我会在评论中向某人证明某些事情，例如，说服您一定要放弃自己的胖IDE并开始使用Vim，我对此一点都不感兴趣。 </p><br><h2 id="k-delu"> 对企业 </h2><br><p>例如，在这里，采用这样的一段代码（来自Haskell项目配置），一个包依赖关系列表（例如在真空中）： </p><br><pre><code class="plaintext hljs">build-depends: X11 , base , directory , extra , GLFW-b , safe , aeson , containers , data-default , text , process , time , dbus</code> </pre> <br><h2 id="chto-my-hotim"> 我们想要什么？ </h2><br><ol><li> 依字母顺序排序依存关系 </li><li> 不区分大小写地排序（ <code>X11</code>和<code>GLFW-b</code>不应超过所有内容） </li><li> 还原逗号（ <code>aeson</code>会移到最顶部，并且它的左侧不再应该有逗号，但是<code>X11</code>的左侧应该有一个逗号） </li><li> 恢复缩进（以便您还可以从历史记录中获取命令，并在具有不同嵌套级别的另一个配置中重用该命令，甚至可以在Vim配置中绑定热键命令） </li></ol><br><h2 id="reshenie"> 解决方案 </h2><br><p> 首先，选择（通过视觉突出显示）除第一行<code>build-depends</code>外的依赖项列表。 当然，您可以按<code>V</code> （具有逐行选择的可视模式），然后通过<code>jk</code>或向上和向下箭头选择所需的行。 就我而言，我使用可视模式的自定义热键一挥手来完成此操作： </p><br><pre> <code class="plaintext hljs">xn iz &lt;esc&gt;[zV]z</code> </pre> <br><p> 例如，在依赖项列表的中间，我只按<code>viz</code>键，所有依赖项都被突出显示，因为 整个折叠都突出显示，这又是当前的嵌套块（因为我已将<code>foldmethod</code>定义为<code>indent</code> ）。 但您也可以按顺序手动键入<code>[zV]z</code>而无需自定义热键（ <code>[z</code>跳到折叠的开头，a <code>]z</code>到结尾），但是 对我来说，经常使用这样的操作，然后我将其缩短为<code>viz</code> -没有像shift这样的修饰符，它会在反射时立即压缩（最接近的标准类似物是<code>vip</code>以选择一个最接近的空行的块）。 </p><br><p> 然后按<code>:</code>冒号）进入命令模式，以执行相对于当前视觉突出显示的命令。 实际上，这是通常的命令模式，但是会立即添加选择标记，即 看起来像<code>:'&lt;,'&gt;</code>其中<code>'&lt;,'&gt;</code>是选择范围，其中<code>'&lt;</code>是视觉选择的第一行，而<code>'&gt;</code>是最后一行。 </p><br><p> 单击后<code>!</code>  （感叹号）在键盘上，这意味着进一步操作都是shell / bash（取决于设置）命令。 它看起来像<code>:'&lt;,'&gt;!</code>  。 实际上，突出显示后，您可以立即单击<code>!</code> 并得到相同的结果- <code>:'&lt;,'&gt;!</code>  。 </p><br><p> 此操作会将突出显示的行重定向到STDIN命令，并将突出显示的行替换为该命令的STDOUT排气口。 例如，您可以使用<code>sort</code>命令，仅用于验证，结果不是我们需要的- <code>'&lt;,'&gt;!sort</code> ，然后按<em>Enter</em> ，我们得到： </p><br><pre> <code class="plaintext hljs"> build-depends: , aeson , base , containers , data-default , dbus , directory , extra , GLFW-b , process , safe , text , time X11</code> </pre> <br><h3 id="sposob-s-coreutils-i-voobsche-bashem">  coreutils和一般塔楼的时尚 </h3><br><p> 恢复上一个选择（您可以按<code>gv</code>恢复上一个选择），然后按<code>!</code> 然后是向上箭头-这将恢复历史记录中的最后一条命令，因此我们无需再次编写，我们只需从历史记录中提取先前的命令并进行更改即可。 为了更舒适地编辑命令，可以按<code>Ctrl</code> + <code>f</code>这将打开其他命令。 顺便说一句，具有标准命令编辑功能的窗口以及Vim的所有功能，历史记录中的所有以前的团队都将在这里显示为单独的行，也可以选择，编辑和执行这些行。 </p><br><p> 正确的做法-您可以想到一个发现，我的意思是：首先删除逗号，对它们进行排序（不区分大小写）（不区分大小写），然后返回逗号（第一行除外）。 </p><br><p> 首先，使用<code>sed</code>命令和正则表达式（ <code>[, ]</code> -逗号或空格，然后是另一个空格， <code>\(\w\)</code>转义括号以突出显示，以除去逗号（第一行具有一个额外的缩进，以便所有行都具有相同的缩进）块进行替换，因此它可以用作<code>\1</code> ， <code>\w</code>是第一个字母字符，在替换中，我们将通过替换<code>\1</code>来恢复字母字符： </p><br><pre> <code class="plaintext hljs">:'&lt;,'&gt;!sed 's/[, ] \(\w\)/\1/'</code> </pre> <br><p> 我们得到以下内容： </p><br><pre> <code class="plaintext hljs"> build-depends: X11 base directory extra GLFW-b safe aeson containers data-default text process time dbus</code> </pre> <br><p> 接下来，我们将（通过符号<code>|</code>是bash的功能）通过管道传递给sort <code>sort</code>命令，并传递<code>-f</code>以区分大小写： </p><br><pre> <code class="plaintext hljs">:'&lt;,'&gt;!sed 's/[, ] \(\w\)/\1/' | sort -f</code> </pre> <br><p> 我们得到： </p><br><pre> <code class="plaintext hljs"> build-depends: aeson base containers data-default dbus directory extra GLFW-b process safe text time X11</code> </pre> <br><p> 快完成了！ 它仅保留添加逗号和第一行-几个空格。 我们使用相同的<code>sed</code> ，在其操作语法中，您可以指定字符串和字符串范围（如在Vim本身中，语法是相同的，很好的或几乎相同的）。 前缀<code>1</code>表示第一行， <code>2,$</code>表示从第二行到末尾的范围（ <code>$</code>类似于<code>^</code>表示文件的开头，类似于正则表达式中的相同字符，表示该行的结尾和开头）。 我们将使用<code>\w</code>跳过缩进并立即选择第一个字母字符： <code>1s/\w/ &amp;/</code> -在这里，我们替换第一行，通过<code>&amp;</code>还原第一个字母字符（类似于<code>\1</code> ，只有<code>&amp;</code>表示所有内容在整个正则表达式下， <code>\1</code>表示第一个用括号括起来的块），并在其前面添加了两个空格。 对于其余的行，而不是两个空格，请添加逗号+空格，后跟： <code>2,$s/\w/, &amp;/</code> ，整个命令将如下所示： <code>sed -e '1s/\w/ &amp;/' -e '2,$s/\w/, &amp;/'</code> ，-- <code>-e</code>我们用来将2个操作彼此分开。 在Vim中，整个操作如下所示： </p><br><pre> <code class="plaintext hljs">:'&lt;,'&gt;!sed 's/[, ] \([^, ]\)/\1/' | sort -f | sed -e '1s/\w/ &amp;/' -e '2,$s/\w/, &amp;/'</code> </pre> <br><p> 我们申请并获得： </p><br><pre> <code class="plaintext hljs"> build-depends: aeson , base , containers , data-default , dbus , directory , extra , GLFW-b , process , safe , text , time , X11</code> </pre> <br><p> 做完了！ 不再需要写第二遍了，只需键入前几个字符即可，例如： <code>:'&lt;,'&gt;!se</code> （实际上，您只需要按<code>!se</code> ），然后使用向上箭头从历史记录中获取所需的命令。 一种或另一种方式，我经常建议立即练习写这类东西。 因此，您将同时在bash和Vim本身中提高日常工作技能， 本质上，您在做同一件事。 </p><br><p> 最后，可以将整个命令分配给一个热键，或抽象为一个函数，然后在任何地方重复使用一个或两个。 </p><br><h3 id="ispolzuya-storonniy-yap"> 使用第三方PL </h3><br><p> 您可以运行某种对您方便的<strong>语言</strong>的解释器，而不是从coreutils中启动某些东西，我喜欢通过<strong>Perl6</strong> （最近将它重命名为<strong>Raku</strong> ）来做这些事情： </p><br><pre> <code class="plaintext hljs">:'&lt;,'&gt;!perl6 -e 'my @x=lines.map(*.subst(/&lt;[,\s]&gt;\s(\w)/,{$0})).sort(*.lc); @x.shift.subst(/\w/,{q/ /~$_}).say; .subst(/\w/,{q/, /~$_}).say for @x'</code> </pre> <br><p> 是的，至少在zoskoscript（node.js）上： </p><br><pre> <code class="plaintext hljs">:'&lt;,'&gt;!node -e 'let fs=require("fs"), x=fs.readFileSync(process.stdin.fd).toString().replace(/\n$/,'').split(/\n/).map(x=&gt;x.replace(/[, ] (\w)/,"$1")).sort((a,b)=&gt;a.toLowerCase().localeCompare(b.toLowerCase())); console.log(x.shift().replace(/(\w)/," $1")); process.stdout.write(x.map(x=&gt;x.replace(/(\w)/,", $1")).join("\n"))'</code> </pre> <br><p> 这也可以在Vim本身的VimL / Vimscript上完成，而无需调用外部命令。 但是这篇文章不是关于这个的。 </p><br><p> 自然，正如您可能已经猜到的那样，您可以轻松地将脚本保存到单独的文件中，甚至可以编译自己的程序，该程序需要输入STDIN并输出在STDOUT中处理的内容，然后只需调用以下命令即可在Vim中使用它： ，同样，可以将其分配给热键）： </p><br><pre> <code class="plaintext hljs">:'&lt;,'&gt;!~/my-program-or-script</code> </pre> <br><p> 因此，当您在Vim中编写代码时，不仅Vim本身可以使用，而且整个工作环境都可以使用。 </p><br><p> 最简单的示例之一是拒绝JSON文件： </p><br><pre> <code class="plaintext hljs">:%!jq</code> </pre> <br><p> 只需几次按键操作，当您可以通过<code>jq</code>获取并运行文件而无需离开Vim时，为什么还要为任何新的编辑器/ IDE /等等重新发明AST解析器和prettifayer的JSON？ 我不是在谈论这样一个事实，您可以通过<code>jq</code>以这种方式处理大型JSON文件，而无需离开Vim，例如在树中找到所需的键，进行排序，仅保留必要的数据，等等。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN483580/">https://habr.com/ru/post/zh-CN483580/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN483564/index.html">IT中的文案撰写：如何开始撰写有关技术的文章</a></li>
<li><a href="../zh-CN483568/index.html">从头开始创建原始计算机</a></li>
<li><a href="../zh-CN483570/index.html">但是，如果地球是平坦的呢？</a></li>
<li><a href="../zh-CN483574/index.html">震动电子设备的可靠性分析-概述</a></li>
<li><a href="../zh-CN483578/index.html">OpenStreetMap第493号世界的新闻（12.24.2019-12.30.2019）</a></li>
<li><a href="../zh-CN483584/index.html">将PHP后端传输到Redis流总线并选择独立于框架的库</a></li>
<li><a href="../zh-CN483586/index.html">在python中使用zmq，创建简单的键/值存储的基础知识</a></li>
<li><a href="../zh-CN483588/index.html">如何尝试使用ILV阻止任何站点</a></li>
<li><a href="../zh-CN483590/index.html">搜索不是的FDCAN错误</a></li>
<li><a href="../zh-CN483594/index.html">物理学家的未来经济学</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>