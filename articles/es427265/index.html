<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôìÔ∏è ü§ûüèø ‚öñÔ∏è Protobuffers est√°n equivocados üßïüèæ üëÜüèº üé´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Durante la mayor parte de mi vida profesional, me opongo al uso de Protocol Buffers. Est√°n claramente escritos por aficionados, incre√≠blemente altamen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Protobuffers est√°n equivocados</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427265/">  Durante la mayor parte de mi vida profesional, me opongo al uso de Protocol Buffers.  Est√°n claramente escritos por aficionados, incre√≠blemente altamente especializados, sufren muchas dificultades, son dif√≠ciles de compilar y resuelven un problema que nadie m√°s que Google realmente tiene.  Si estos problemas de prototipos se mantuvieran en la cuarentena de las abstracciones de serializaci√≥n, entonces mis reclamos terminar√≠an all√≠.  Pero desafortunadamente, el dise√±o deficiente de Protobuffers es tan intrusivo que estos problemas pueden filtrarse en su c√≥digo. <br><br>  <b>Especializaci√≥n estrecha y desarrollo por aficionados</b> <br><br>  Para  Cierra tu cliente de correo electr√≥nico donde ya me escribiste una carta diciendo que "los mejores ingenieros del mundo trabajan en Google", que "sus dise√±os, por definici√≥n, no pueden ser creados por aficionados".  No quiero escuchar eso. <br><br>  Simplemente no discutamos este tema.  Divulgaci√≥n completa: sol√≠a trabajar en Google.  Este fue el primer lugar (pero desafortunadamente no el √∫ltimo) en el que utilic√© Protobuffers.  Todos los problemas de los que quiero hablar existen en la base de c√≥digo de Google;  no se trata solo de "mal uso de protofobres" y cosas por el estilo. <br><a name="habracut"></a><br>  De lejos, el mayor problema con los Protobuffers es el horrible sistema de tipos.  Los fan√°ticos de Java deber√≠an sentirse como en casa aqu√≠, pero desafortunadamente, literalmente, nadie piensa que Java es un sistema de tipos bien dise√±ado.  Los chicos del campo de escritura din√°mico se quejan de restricciones innecesarias, mientras que los representantes del campo de escritura est√°tico, como yo, se quejan de restricciones innecesarias y de la falta de todo lo que realmente quieres del sistema de escritura.  Perder en ambos casos. <br><br>  La estrecha especializaci√≥n y el desarrollo por parte de aficionados van de la mano.  Gran parte de las especificaciones parec√≠an estar atornilladas en el √∫ltimo momento, y obviamente estaban atornilladas en el √∫ltimo momento.  Algunas restricciones lo obligar√°n a detenerse, rascarse la cabeza y preguntar: "¬øQu√© demonios?"  Pero estos son solo s√≠ntomas de un problema m√°s profundo: <br><br>  Obviamente, los protobuffers son creados por aficionados porque ofrecen soluciones deficientes a problemas conocidos y ya resueltos. <br><br><h1>  Falta de composici√≥n </h1><br>  Los Protobuffers ofrecen varias caracter√≠sticas que no funcionan entre s√≠.  Por ejemplo, mire la lista de funciones de escritura ortogonales, pero al mismo tiempo limitadas que encontr√© en la documentaci√≥n. <br><br><ul><li> <code>oneof</code> campos no se puede <code>repeated</code> . </li><li>  Los campos <code>map&lt;k,v&gt;</code> tienen una sintaxis especial para claves y valores, pero no se utilizan en ning√∫n otro tipo. </li><li>  Aunque <code>map</code> campos del <code>map</code> se pueden parametrizar, ya no se permite ning√∫n tipo definido por el usuario.  Esto significa que tiene que especificar manualmente sus propias especializaciones en estructuras de datos comunes. </li><li>  <code>map</code> campos del <code>map</code> no se pueden <code>repeated</code> . </li><li>  <code>map</code> claves de <code>map</code> <i>pueden</i> ser <code>string</code> , pero <i>no</i> <code>bytes</code> .  Enum tambi√©n est√° prohibido, aunque estos √∫ltimos se consideran equivalentes a los enteros en todas las dem√°s partes de la especificaci√≥n de Protobuffers. </li><li>  <code>map</code> valores del <code>map</code> no pueden ser otro <code>map</code> . </li></ul><br>  Esta lista loca de restricciones es el resultado de una elecci√≥n sin principios de dise√±o y funciones de atornillado en el √∫ltimo momento.  Por ejemplo, uno de los campos no puede <code>repeated</code> , porque en lugar de un tipo lateral, el generador de c√≥digo producir√° campos opcionales mutuamente excluyentes.  Tal transformaci√≥n es v√°lida solo para un campo singular (y, como veremos m√°s adelante, ni siquiera funciona para √©l). <br><br>  La restricci√≥n de <code>map</code> campos del <code>map</code> , que no se puede <code>repeated</code> , es aproximadamente de la misma √≥pera, pero muestra una restricci√≥n diferente del sistema de tipos.  Detr√°s de escena, el <code>map&lt;k,v&gt;</code> transforma en algo similar al <code>repeated Pair&lt;k,v&gt;</code> .  Y dado que se <code>repeated</code> la palabra clave m√°gica del idioma, y ‚Äã‚Äãno el tipo normal, no se combina consigo misma. <br><br>  Sus conjeturas sobre el problema con la <code>enum</code> son tan ciertas como las m√≠as. <br><br>  Lo que es tan frustrante de todo esto es una mala comprensi√≥n de c√≥mo funcionan los sistemas de tipos modernos.  Esta comprensi√≥n <i>simplificar√≠a dram√°ticamente la</i> especificaci√≥n de Protobuffers y al mismo tiempo <i>eliminar√≠a todas las restricciones arbitrarias</i> . <br><br>  La soluci√≥n es la siguiente: <br><br><ul><li>  Realice todos los campos en el mensaje <code>required</code> .  Esto hace que cada mensaje sea <i>un</i> tipo de producto. </li><li>  Eleve el valor del campo <code>oneof</code> a tipos de datos independientes.  Este ser√° un tipo de coproducto. </li><li>  Permitir la parametrizaci√≥n de tipos de productos y coproductos de otros tipos. </li></ul><br>  Eso es todo!  Estos tres cambios son todo lo que necesita para determinar cualquier posible dato.  Con este sistema simple, puede rehacer todas las dem√°s especificaciones de Protobuffers. <br><br>  Por ejemplo, puede rehacer los campos <code>optional</code> : <br><br><pre> <code class="hljs pgsql">product Unit { // <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> fields } coproduct Optional&lt;t&gt; { t <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; Unit unset = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  Crear campos <code>repeated</code> tambi√©n es simple: <br><br><pre> <code class="hljs php">coproduct <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;t&gt; { Unit <span class="hljs-keyword"><span class="hljs-keyword">empty</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; Pair&lt;t, <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;t&gt;&gt; cons = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  Por supuesto, la l√≥gica real de la serializaci√≥n le permite hacer algo m√°s inteligente que enviar listas vinculadas a la red; despu√©s de todo, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">implementaci√≥n y la sem√°ntica no tienen que corresponder entre s√≠</a> . <br><br><h1>  Elecci√≥n dudosa </h1><br>  Los protobuffers de estilo Java distinguen entre tipos <i>escalares</i> y de <i>mensajes</i> .  Los escalares corresponden m√°s o menos a las primitivas de la m√°quina, como <code>int32</code> , <code>bool</code> y <code>string</code> .  Los tipos de mensajes, por otro lado, son todo lo dem√°s.  Todos los tipos de bibliotecas y usuarios son mensajes. <br><br>  Por supuesto, los dos tipos de tipos tienen una sem√°ntica completamente diferente. <br><br>  Los campos con tipos escalares siempre est√°n presentes.  Incluso si no los instal√≥.  Ya dije eso (al menos en proto3 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><sup>1</sup></a> <a name="1_1"></a>  ) ¬øtodos los prototipos se inicializan a ceros, incluso si no tienen absolutamente ning√∫n dato?  Los campos escalares obtienen valores falsos: por ejemplo, <code>uint32</code> inicializa a <code>0</code> y la <code>string</code> inicializa a <code>""</code> . <br><br>  No es posible distinguir un campo que no estaba en el proto-buffer de un campo que tiene asignado un valor predeterminado.  Presumiblemente, esta decisi√≥n se tom√≥ para la optimizaci√≥n a fin de no reenviar los valores predeterminados escalares.  Esto es solo una suposici√≥n, porque la documentaci√≥n no menciona esta optimizaci√≥n, por lo que su suposici√≥n no ser√° peor que la m√≠a. <br><br>  Cuando analicemos las afirmaciones de Protobuffers de una soluci√≥n ideal para la compatibilidad con API anteriores y futuras, veremos que esta incapacidad para distinguir entre valores indefinidos y predeterminados es una verdadera pesadilla.  Especialmente si es realmente una decisi√≥n consciente guardar un bit (establecido o no) para el campo. <br><br>  Compare este comportamiento con los tipos de mensajes.  Mientras que los campos escalares son "tontos", el comportamiento de los campos de mensajes es completamente <i>loco</i> .  Internamente, los campos de mensaje est√°n all√≠ o no, pero el comportamiento es una locura.  Un peque√±o pseudoc√≥digo para su descriptor vale m√°s que mil palabras.  Imagina esto en Java o en otro lugar: <br><br><pre> <code class="hljs pgsql">private Foo m_foo; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Foo foo { // <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> `foo` <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> used <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> an expression <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_foo != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_foo; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Foo(); } // <span class="hljs-keyword"><span class="hljs-keyword">instead</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> `foo` <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> used <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> an lvalue mutable <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_foo = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) m_foo = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Foo(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_foo; } }</code> </pre> <br>  En teor√≠a, si el campo <code>foo</code> no est√° configurado, ver√° una copia inicializada predeterminada, lo solicite o no, pero no puede cambiar el contenedor.  Pero si cambias a <code>foo</code> , ¬°tambi√©n cambiar√° a su padre!  Todo esto es solo para evitar el uso del tipo <code>Maybe Foo</code> y su "dolor de cabeza" asociado para descubrir qu√© debe significar un valor indefinido. <br><br>  ¬°Tal comportamiento es particularmente atroz porque viola la ley!  Esperamos el trabajo <code>msg.foo = msg.foo;</code>  No funcionar√°.  En cambio, la implementaci√≥n en realidad cambia silenciosamente <code>msg</code> a una copia de <code>foo</code> con inicializaci√≥n cero si no exist√≠a antes. <br><br>  A diferencia de los campos escalares, al menos puede determinar que el campo del mensaje no est√° configurado.  Los enlaces de idioma para protobuffers ofrecen algo como el m√©todo <code>bool has_foo()</code> generado.  Si est√° presente, en el caso de una copia frecuente del campo de mensaje de un protobuffer a otro, debe escribir el siguiente c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (src.has_foo(src)) { dst.set_foo(src.foo()); }</code> </pre> <br>  Tenga en cuenta que, al menos en los idiomas con escritura est√°tica, esta plantilla <i>no se puede abstraer</i> debido a la relaci√≥n nominal entre los <code>has_foo()</code> <code>foo()</code> , <code>set_foo()</code> y <code>has_foo()</code> .  Dado que todas estas funciones son sus propios <i>identificadores</i> , no tenemos los medios para generarlas mediante programaci√≥n, con la excepci√≥n de la macro del preprocesador: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> COPY_IFF_SET(src, dst, field) \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (src.has_##field(src)) { \ dst.set_##field(src.field()); \ }</span></span></code> </pre> <br>  (pero la gu√≠a de estilo de Google proh√≠be las macros de preprocesador). <br><br>  Si, en cambio, todos los campos adicionales se implementaron como <code>Maybe</code> , podr√≠a establecer de forma segura los pares de marcado abstra√≠dos. <br><br>  Para cambiar de tema, hablemos de otra decisi√≥n dudosa.  Aunque puede definir uno de los campos en <code>oneof</code> , ¬°su sem√°ntica <i>no coincide con el</i> tipo de coproducto!  Newbie error chicos!  En cambio, obtienes un campo opcional para cada caso y c√≥digo m√°gico en los setters, que simplemente deshacer√° cualquier otro campo si est√° configurado. <br><br>  A primera vista, parece que esto deber√≠a ser sem√°nticamente equivalente al tipo correcto de uni√≥n.  ¬°Pero en cambio, obtenemos una fuente de error repugnante e indescriptible!  Cuando este comportamiento se combina con una implementaci√≥n ilegal <code>msg.foo = msg.foo;</code>  , ¬°una tarea aparentemente normal elimina silenciosamente cantidades arbitrarias de datos! <br><br>  Como resultado, esto significa que uno de los campos no forma un <code>Prism</code> respetuoso de la ley, y los mensajes no forman una <code>Lens</code> respetuosa de la ley.  As√≠ que buena suerte con tus intentos de escribir manipulaciones de protobuffer no triviales sin errores.  <i>Es literalmente imposible escribir un c√≥digo polim√≥rfico universal, libre de errores en protobuffers</i> . <br><br>  Esto no es muy agradable de escuchar, especialmente para aquellos de nosotros que amamos el polimorfismo param√©trico, que <i>promete exactamente lo contrario</i> . <br><br><h1>  La compatibilidad con versiones anteriores y futuras radica </h1><br>  Una de las "caracter√≠sticas asesinas" mencionadas a menudo de los Protobuffers es su "capacidad sin problemas para escribir API compatibles con versiones anteriores y posteriores".  Esta declaraci√≥n fue colgada ante tus ojos para oscurecer la verdad. <br><br>  Que los protobuffers son <i>permisivos</i> .  Se las arreglan para hacer frente a los mensajes del pasado o del futuro, porque no hacen absolutamente ninguna promesa sobre c√≥mo se ver√°n sus datos.  ¬°Todo es opcional!  Pero si lo necesita, Protobuffers estar√° encantado de prepararse y darle algo con la verificaci√≥n de tipo, independientemente de si tiene sentido. <br><br>  Esto significa que los Protobuffers llevan a cabo el "viaje en el tiempo" prometido mientras <i>hacen silenciosamente lo incorrecto por defecto</i> .  Por supuesto, un programador cuidadoso puede (y debe) escribir c√≥digo que verifique la correcci√≥n de los protobuffers recibidos.  Pero si escribe verificaciones de correcci√≥n de protecci√≥n en cada sitio, tal vez solo significa que el paso de deserializaci√≥n fue demasiado permisivo.  Todo lo que logr√≥ hacer fue descentralizar la l√≥gica de validaci√≥n desde un l√≠mite bien definido y difuminarla en toda la base del c√≥digo. <br><br>  Uno de los posibles argumentos es que los protobuffers guardar√°n cualquier informaci√≥n que no entiendan en el mensaje.  En principio, esto significa una transmisi√≥n no destructiva del mensaje a trav√©s de un intermediario que no comprende esta versi√≥n del esquema.  Esta es una victoria clara, ¬øno? <br><br>  Por supuesto, en papel esta es una caracter√≠stica genial.  Pero nunca he visto una aplicaci√≥n donde esta propiedad est√© realmente almacenada.  Con la excepci√≥n del software de enrutamiento, ning√∫n programa quiere verificar solo ciertos bits de un mensaje y luego reenviarlo sin cambios.  La gran mayor√≠a de los programas en protobuffers decodificar√°n el mensaje, lo transformar√°n en otro y lo enviar√°n a otro lugar.  Por desgracia, estas conversiones se hacen por encargo y se codifican manualmente.  Y las conversiones manuales de un protobuffer a otro no conservan campos desconocidos, porque es literalmente in√∫til. <br><br>  Esta actitud ubicua hacia los protobuffers como universalmente compatible tambi√©n se manifiesta de otras maneras feas.  Las gu√≠as de estilo para Protobuffers se oponen activamente a DRY y sugieren insertar definiciones en el c√≥digo siempre que sea posible.  Argumentan que esto permitir√° el uso de mensajes separados en el futuro si las definiciones divergen.  Insisto en que ofrecen abandonar la pr√°ctica de 60 a√±os de una buena programaci√≥n por <i>si acaso</i> , de repente, en alg√∫n momento en el futuro tendr√° que cambiar algo. <br><br>  La ra√≠z del problema es que Google combina el significado de los datos con su representaci√≥n f√≠sica.  Cuando est√°s en una escala de Google, eso tiene sentido.  Al final, tienen una herramienta interna que compara el pago por hora del programador usando la red, el costo de almacenar X bytes y otras cosas.  A diferencia de la mayor√≠a de las compa√±√≠as de tecnolog√≠a, el salario de los programadores es uno de los gastos m√°s peque√±os de Google.  Financieramente, tiene sentido que pasen el tiempo de los programadores para ahorrar un par de bytes. <br><br>  Adem√°s de las cinco compa√±√≠as tecnol√≥gicas l√≠deres, nadie m√°s est√° dentro de los cinco √≥rdenes de magnitud de Google.  Su startup <i>no puede permitirse el lujo de</i> pasar horas de ingenier√≠a ahorrando bytes.  Pero ahorrar bytes y perder el tiempo de los programadores en el proceso es exactamente para lo que est√°n optimizados los Protobuffers. <br><br>  Seamos realistas.  No se ajusta a la escala de Google y nunca se ajustar√°.  Deje de usar el culto a la carga de la tecnolog√≠a solo porque "Google la usa" y porque "estas son las mejores pr√°cticas de la industria". <br><br><h1>  Protobuffers contamina las bases de c√≥digo </h1><br>  Si fuera posible limitar el uso de Protobuffers solo a la red, no hablar√≠a tan duramente sobre esta tecnolog√≠a.  Desafortunadamente, aunque en principio hay varias soluciones, ninguna de ellas es lo suficientemente buena como para ser utilizada en un software real. <br><br>  Los protobuffers corresponden a los datos que desea enviar a trav√©s del canal de comunicaci√≥n.  A menudo son <i>consistentes</i> , pero no <i>id√©nticos</i> , con los datos reales con los que la aplicaci√≥n quisiera trabajar.  Esto nos coloca en una posici√≥n inc√≥moda, debe elegir entre una de las tres malas opciones: <br><br><ol><li>  Mantenga un tipo separado que describa los datos que realmente necesita y aseg√∫rese de que ambos tipos sean compatibles simult√°neamente. </li><li>  Empaquete los datos completos en un formato para su transmisi√≥n y uso por la aplicaci√≥n. </li><li>  Recupere datos completos cada vez que sea necesario del formato corto para la transmisi√≥n. </li></ol><br>  La opci√≥n 1 es claramente la soluci√≥n "correcta", pero no es adecuada para Protobuffers.  El lenguaje no es lo suficientemente potente como para codificar tipos que pueden hacer doble trabajo en dos formatos.  Esto significa que debe escribir un tipo de datos completamente separado, desarrollarlo sincr√≥nicamente con Protobuffers y <i>escribir espec√≠ficamente un c√≥digo de serializaci√≥n para ellos</i> .  Pero dado que la mayor√≠a de las personas parecen usar Protobuffers para no escribir c√≥digo de serializaci√≥n, esta opci√≥n obviamente nunca se implementa. <br><br>  En cambio, el c√≥digo que usa protobuffers les permite distribuirse a trav√©s de la base de c√≥digo.  Es una realidad.  Mi proyecto principal en Google fue un compilador que tom√≥ un "programa" escrito en una variaci√≥n de Protobuffers y produjo un "programa" equivalente en otra.  Los formatos de entrada y salida eran bastante diferentes, por lo que sus versiones paralelas correctas de C ++ nunca funcionaron.  Como resultado, mi c√≥digo no pudo usar ninguna de las t√©cnicas de escritura del compilador, porque los datos de Protobuffers (y el c√≥digo generado) eran demasiado dif√≠ciles de hacer algo interesante con ellos. <br><br>  Como resultado, en lugar de 50 l√≠neas de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esquemas</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">recursi√≥n</a> , se usaron 10,000 l√≠neas de barajado de buffer especial.  El c√≥digo que quer√≠a escribir era literalmente imposible con los proto-buffers. <br><br>  Aunque este es un caso, no es √∫nico.  Debido a la naturaleza √°spera de la generaci√≥n de c√≥digo, las manifestaciones de los prototipos de buffers en los idiomas nunca ser√°n idiom√°ticas, y no pueden hacerse as√≠, a menos que vuelva a escribir el generador de c√≥digos. <br><br>  Pero incluso entonces, todav√≠a tiene un problema para incorporar un sistema de tipo malo en su idioma de destino.  Como la mayor√≠a de las funciones de los Protobuffers est√°n mal pensadas, estas dudosas propiedades se filtran en nuestras bases de c√≥digo.  Esto significa que no solo estamos obligados a implementar, sino tambi√©n a usar estas malas ideas en cualquier proyecto que espere interactuar con Protobuffers. <br><br>  Sobre una base s√≥lida, es f√°cil darse cuenta de cosas sin sentido, pero si vas en una direcci√≥n diferente, en el mejor de los casos encontrar√°s dificultades, y en el peor de los casos, con verdadero horror antiguo. <br><br>  En general, pierda la esperanza de cualquiera que implemente Protobuffers en sus proyectos. <br><br><hr><br><a name="1"></a>  1. Hasta el d√≠a de hoy, hay una acalorada discusi√≥n en Google sobre proto2 y si los campos deber√≠an marcarse como <code>required</code> .  Los manifiestos ‚Äú <code>optional</code> se considera da√±ino‚Äù <i>y</i> ‚Äúlos <code>required</code> consideran da√±inos‚Äù se distribuyen al mismo tiempo.  Buena suerte, descifren chicos.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">‚Üë</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es427265/">https://habr.com/ru/post/es427265/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es427253/index.html">tipo de todo y malentendidos de pato</a></li>
<li><a href="../es427255/index.html">Cowon D2: Musical Long-Liver</a></li>
<li><a href="../es427257/index.html">Cameron Craig: Siete lecciones aprendidas de 10 a√±os de gesti√≥n de relaciones p√∫blicas de Apple</a></li>
<li><a href="../es427259/index.html">Lo que realmente comprueba la prueba de Turing</a></li>
<li><a href="../es427263/index.html">S√© un ninja de seguridad: grabaci√≥n de seminarios web y nivel de bonificaci√≥n</a></li>
<li><a href="../es427267/index.html">SNMP + Java: experiencia personal. Escribir un analizador de archivos MIB</a></li>
<li><a href="../es427269/index.html">Video de Google OKR cinco a√±os despu√©s: una revisi√≥n de la experiencia de Google Ventures en la implementaci√≥n de OKR (2012-2017)</a></li>
<li><a href="../es427271/index.html">Historia y experiencia en el uso de la traducci√≥n autom√°tica. Conferencia de Yandex</a></li>
<li><a href="../es427273/index.html">¬øPuede la inteligencia artificial dejar a los corredores de apuestas sin trabajo?</a></li>
<li><a href="../es427275/index.html">Arquitectura de la informaci√≥n de Internet Parte 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>