<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≤üèª üå©Ô∏è üìó Excepciones especiales en .NET y c√≥mo prepararlas. üë©üèæ‚Äç‚úàÔ∏è üë®üèº‚Äçüîß üë©üèª‚Äçüîß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Varias excepciones en .NET tienen sus propias caracter√≠sticas, y conocerlas puede ser muy √∫til. ¬øC√≥mo enga√±ar al CLR? ¬øC√≥mo mantenerse vivo en tiempo ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Excepciones especiales en .NET y c√≥mo prepararlas.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/426045/">  Varias excepciones en .NET tienen sus propias caracter√≠sticas, y conocerlas puede ser muy √∫til.  ¬øC√≥mo enga√±ar al CLR?  ¬øC√≥mo mantenerse vivo en tiempo de ejecuci√≥n capturando una excepci√≥n StackOverflowException?  ¬øQu√© excepciones parece imposible atrapar, pero si realmente quieres, puedes? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4f1/314/78d/4f131478de33b4a6acd0ed25a0e53987.png"><br><br>  Debajo del corte, la transcripci√≥n del informe de Eugene ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">epeshk</a> ) Peshkov de nuestra conferencia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DotNext 2018 Piter</a> , donde habl√≥ sobre estas y otras caracter√≠sticas de las excepciones. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WLSrYgMWif4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Hola  Me llamo Eugene  Trabajo para SKB Kontur y desarrollo un sistema de alojamiento e implemento aplicaciones para Windows.  La conclusi√≥n es que tenemos muchos equipos de productos que escriben sus propios servicios y los alojan con nosotros.  Les brindamos una soluci√≥n f√°cil y sencilla para una variedad de tareas de infraestructura.  Por ejemplo, para monitorear el consumo de recursos del sistema o finalizar r√©plicas al servicio. <br><br>  A veces resulta que las aplicaciones que est√°n alojadas en nuestro sistema se desmoronan.  Hemos visto muchas maneras en que una aplicaci√≥n puede bloquearse en tiempo de ejecuci√≥n.  Uno de esos m√©todos es lanzar alguna excepci√≥n inesperada y encantadora. <br><br>  Hoy hablar√© sobre las caracter√≠sticas de las excepciones en .NET.  Encontramos algunas de estas caracter√≠sticas en la producci√≥n, y algunas de ellas en el curso de los experimentos. <br><br><h2>  Plan </h2><br><ol><li>  Comportamiento de excepci√≥n .NET <br></li><li>  Manejo de excepciones de Windows y hacks <br></li></ol><br>  Todo lo siguiente es cierto para Windows.  Todos los ejemplos se probaron en la √∫ltima versi√≥n del framework completo .NET 4.7.1.  Tambi√©n habr√° algunas referencias a .NET Core. <br><br>
<h2>  Infracci√≥n de acceso </h2><br>  Esta excepci√≥n ocurre durante operaciones de memoria incorrectas.  Por ejemplo, si una aplicaci√≥n intenta acceder a un √°rea de memoria a la que no tiene acceso.  La excepci√≥n es de bajo nivel y, por lo general, si ocurre, se requerir√° una depuraci√≥n muy larga. <br><br>  Intentemos obtener esta excepci√≥n usando C #.  Para hacer esto, escribiremos el byte 42 a la direcci√≥n 1000 (suponemos que 1000 es una direcci√≥n bastante aleatoria y que nuestra aplicaci√≥n probablemente no tiene acceso a ella). <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Marshal.WriteByte((IntPtr) <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (AccessViolationException) { ... }</code> </pre> <br>  WriteByte hace justo lo que necesitamos: escribe un byte en la direcci√≥n dada.  Esperamos que esta llamada arroje una AccessViolationException.  De hecho, este c√≥digo arrojar√° esta excepci√≥n, podr√° manejarlo y la aplicaci√≥n continuar√° funcionando.  Ahora cambiemos un poco el c√≥digo: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] {<span class="hljs-number"><span class="hljs-number">42</span></span>}; Marshal.Copy(bytes, <span class="hljs-number"><span class="hljs-number">0</span></span>, (IntPtr) <span class="hljs-number"><span class="hljs-number">1000</span></span>, bytes.Length); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (AccessViolationException) { ... }</code> </pre><br>  Si en lugar de WriteByte usa el m√©todo Copy y copia el byte 42 a la direcci√≥n 1000, entonces usando try-catch, AccessViolation no puede ser capturado.  Al mismo tiempo, se mostrar√° un mensaje en la consola que indica que la aplicaci√≥n se finaliz√≥ debido a una AccessViolationException no controlada. <br><br><pre> <code class="cs hljs">Marshal.Copy(bytes, <span class="hljs-number"><span class="hljs-number">0</span></span>, (IntPtr) <span class="hljs-number"><span class="hljs-number">1000</span></span>, bytes.Length); Marshal.WriteByte((IntPtr) <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>);</code> </pre><br>  Resulta que tenemos dos l√≠neas de c√≥digo, mientras que la primera bloquea toda la aplicaci√≥n con AccessViolation, y la segunda arroja una excepci√≥n procesada del mismo tipo.  Para entender por qu√© sucede esto, veremos c√≥mo se organizan estos m√©todos desde adentro. <br><br>  Comencemos con el m√©todo Copiar. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Copy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...</span></span></span><span class="hljs-function">)</span></span> { Marshal.CopyToNative((<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>) source, startIndex, destination, length); } [MethodImpl(MethodImplOptions.InternalCall)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyToNative</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> source, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> startIndex, IntPtr destination, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  Lo √∫nico que hace el m√©todo Copy es llamar al m√©todo CopyToNative, implementado dentro de .NET.  Si nuestra aplicaci√≥n todav√≠a falla y ocurre una excepci√≥n en alg√∫n lugar, esto solo puede ocurrir dentro de CopyToNative.  Desde aqu√≠ podemos hacer la primera observaci√≥n: si el c√≥digo .NET llamado c√≥digo nativo y AccessViolation se produjo dentro de √©l, entonces el c√≥digo .NET no puede manejar esta excepci√≥n por alguna raz√≥n. <br><br>  Ahora entenderemos por qu√© fue posible procesar AccessViolation usando el m√©todo WriteByte.  Veamos el c√≥digo para este m√©todo: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteByte</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { *(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>*) ptr = val; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (NullReferenceException) {     <span class="hljs-comment"><span class="hljs-comment">// this method is documented to throw AccessViolationException on any AV throw new AccessViolationException(); } }</span></span></code> </pre><br>  Este m√©todo est√° completamente implementado en c√≥digo administrado.  Utiliza el puntero C # para escribir datos en la direcci√≥n deseada y tambi√©n captura una excepci√≥n NullReferenceException.  Si se intercepta la NRE, se lanza una excepci√≥n AccessViolationException.  Por lo tanto, es necesario debido a la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">especificaci√≥n</a> .  En este caso, se manejan todas las excepciones lanzadas por la construcci√≥n de lanzamiento.  En consecuencia, si se produce una NullReferenceException durante la ejecuci√≥n del c√≥digo dentro de WriteByte, podemos detectar AccessViolation.  ¬øPodr√≠a ocurrir una NRE, en nuestro caso, al acceder a la direcci√≥n 1000 en lugar de a la direcci√≥n cero? <br><br>  Reescribimos el c√≥digo usando punteros C # directamente, y vemos que cuando se accede a una direcci√≥n que no es cero, se produce una NullReferenceException: <br><br><pre> <code class="cs hljs">*(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>*) <span class="hljs-number"><span class="hljs-number">1000</span></span> = <span class="hljs-number"><span class="hljs-number">42</span></span>;</code> </pre><br>  Para entender por qu√© sucede esto, debemos recordar c√≥mo funciona la memoria del proceso.  En la memoria del proceso, todas las direcciones son virtuales.  Esto significa que la aplicaci√≥n tiene un gran espacio de direcciones y solo algunas p√°ginas se muestran en la memoria f√≠sica real.  Pero hay una peculiaridad: los primeros 64 KB de direcciones nunca se asignan a la memoria f√≠sica y no se entregan a la aplicaci√≥n.  Rantime .NET lo sabe y lo usa.  Si AccessViolation se produjo en el c√≥digo administrado, el tiempo de ejecuci√≥n verifica a qu√© direcci√≥n en la memoria se accedi√≥ y genera una excepci√≥n apropiada.  Para direcciones de 0 a 2 ^ 16 - NullReference, para todos los dem√°s - AccessViolation. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/775/3d4/38f/7753d438fc8a977ac0bb54e431d81c6f.png"><br><br>  Veamos por qu√© se lanza la NullReference no solo cuando se accede a la direcci√≥n cero.  Imagine que est√° accediendo a un campo de un objeto de un tipo de referencia, y la referencia a este objeto es nula: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/127/a27/867/127a27867ef7a568a242797758855b44.png"><br><br>  En esta situaci√≥n, esperamos obtener una NullReferenceException.  El acceso al campo del objeto se produce en un desplazamiento relativo a la direcci√≥n de este objeto.  Resulta que recurriremos a una direcci√≥n que est√© lo suficientemente cerca de cero (recuerde que el enlace a nuestro objeto original es cero).  Con este comportamiento de tiempo de ejecuci√≥n, obtenemos la excepci√≥n esperada sin verificaci√≥n adicional de la direcci√≥n del objeto en s√≠. <br><br>  Pero, ¬øqu√© sucede si pasamos al campo de un objeto y este objeto en s√≠ ocupa m√°s de 64 KB? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/356/897/143/356897143b1275403569dc9f9a71471a.png"><br><br>  ¬øPodemos obtener AccessViolation en este caso?  Hagamos un experimento.  Creemos un objeto muy grande y nos referiremos a sus campos.  Un campo al principio del objeto, el segundo al final: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/08d/619/95a/08d61995a01630f94f31f759890af4a8.png"><br><br>  Ambos m√©todos arrojar√°n una NullReferenceException.  No se producir√° AccessViolationException. <br>  Veamos las instrucciones que se generar√°n para estos m√©todos.  En el segundo caso, el compilador JIT agreg√≥ una instrucci√≥n cmp adicional que accede a la direcci√≥n del objeto en s√≠, llamando a AccessViolation con una direcci√≥n cero, que el tiempo de ejecuci√≥n convertir√° en una excepci√≥n NullReferenceException. <br><br>  Vale la pena se√±alar que para este experimento no es suficiente usar una matriz como un objeto grande.  Por qu√©  Deje esta pregunta al lector, escriba ideas en los comentarios :) <br><br>  Resumamos los experimentos con AccessViolation. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ffa/86b/0a8/ffa86b0a85f29a16936c92845f5d3e1e.png"><br><br>  AccessViolationException se comporta de manera diferente dependiendo de d√≥nde ocurri√≥ la excepci√≥n (en c√≥digo administrado o en nativo).  Adem√°s, si se produjo una excepci√≥n en el c√≥digo administrado, se verificar√° la direcci√≥n del objeto. <br><br>  La pregunta es: ¬øpodemos manejar una AccessViolationException que ocurri√≥ en el c√≥digo nativo o en el c√≥digo administrado, pero que no se convirti√≥ a NullReference y no se lanz√≥ mediante throw?  Esta es a veces una caracter√≠stica √∫til, especialmente cuando se trabaja con c√≥digo inseguro.  La respuesta a esta pregunta depende de la versi√≥n de .NET. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/67a/785/318/67a785318bc8b5f084a3b23fa36e766b.png"><br><br>  En .NET 1.0, no hab√≠a AccessViolationException en absoluto.  Todos los enlaces se consideraron v√°lidos o nulos.  En el momento de .NET 2.0, qued√≥ claro que sin trabajo directo con memoria, de ninguna manera, y apareci√≥ AccessViolation, mientras era procesable.  En 4.0 y versiones posteriores, segu√≠a siendo viable, pero procesarlo no es tan simple.  Para detectar esta excepci√≥n, ahora debe marcar el m√©todo en el que se encuentra el bloque catch con el atributo HandleProcessCorruptedStateException.  Aparentemente, los desarrolladores hicieron esto porque pensaron que AccessViolationException no era la excepci√≥n que deber√≠a quedar atrapada en una aplicaci√≥n normal. <br>  Adem√°s, para la compatibilidad con versiones anteriores, es posible utilizar la configuraci√≥n de tiempo de ejecuci√≥n: <br><br><ul><li>  legacyNullReferenceExceptionPolicy devuelve el comportamiento de .NET 1.0: todos los AV se convierten en NRE <br></li><li>  legacyCorruptedStateExceptionsPolicy devuelve el comportamiento de .NET 2.0: todos los AV est√°n interceptados <br></li></ul><br>  En .NET, Core AccessViolation no se maneja en absoluto. <br><br>  En nuestra producci√≥n hab√≠a tal situaci√≥n: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad7/0f1/6d3/ad70f16d3438d1e8ab80e43ba29d5412.png"><br><br>  Una aplicaci√≥n creada bajo .NET 4.7.1 utiliz√≥ una biblioteca de c√≥digo compartido construida bajo .NET 3.5.  Hab√≠a un ayudante en esta biblioteca para ejecutar una acci√≥n peri√≥dica: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (isRunning) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { action(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { log.Error(e); } WaitForNextExecution(... ); }</code> </pre><br>  Pasamos la acci√≥n de nuestra aplicaci√≥n a este ayudante.  Dio la casualidad de que se estrell√≥ con AccessViolation.  Como resultado, nuestra aplicaci√≥n registr√≥ constantemente AccessViolation, en lugar de fallar porque  el c√≥digo en la biblioteca bajo 3.5 podr√≠a atraparlo.  Cabe se√±alar que la intercepci√≥n no depende de la versi√≥n del tiempo de ejecuci√≥n en el que se ejecuta la aplicaci√≥n, sino del TargetFramework, bajo el cual se construy√≥ la aplicaci√≥n, y sus dependencias. <br><br>  Para resumir.  El procesamiento de AccessVilolation depende de d√≥nde se origin√≥, en c√≥digo nativo o administrado, as√≠ como de TargetFramework y la configuraci√≥n de tiempo de ejecuci√≥n. <br><br><h2>  Hilo abortar </h2><br>  A veces, en el c√≥digo, debe detener la ejecuci√≥n de uno de los hilos.  Para hacer esto, puede usar el thread.Abort (); <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ThreadAbortException e) { ... Thread.ResetAbort(); } }); ... thread.Abort();</code> </pre><br>  Cuando se llama al m√©todo Abort en un subproceso detenido, se genera una ThreadAbortException.  Analicemos sus caracter√≠sticas.  Por ejemplo, un c√≥digo como este: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ThreadAbortException e) { ‚Ä¶ } }); ... thread.Abort();</code> </pre><br>  Absolutamente equivalente a esto: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ThreadAbortException e) { ... <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; } }); ... thread.Abort();</code> </pre><br>  Si a√∫n necesita procesar ThreadAbort y realizar otras acciones en el hilo detenido, puede usar el m√©todo Thread.ResetAbort ();  Detiene el proceso de detener el flujo y la excepci√≥n deja de arrojar m√°s arriba en la pila.  Es importante comprender que el m√©todo thread.Abort () en s√≠ mismo no garantiza nada; el c√≥digo en el hilo detenido puede evitar que se detenga. <br><br>  Otra caracter√≠stica de thread.Abort () es que no podr√° interrumpir el c√≥digo si est√° en la captura y finalmente se bloquea. <br><br>  Dentro del c√≥digo marco, a menudo puede encontrar m√©todos en los que el bloque try est√° vac√≠o y toda la l√≥gica est√° finalmente dentro.  Esto se hace solo para evitar que este c√≥digo sea lanzado por una ThreadAbortException. <br><br>  Adem√°s, una llamada al thread.Abort () espera a que se produzca una ThreadAbortException.  Combine estos dos hechos y obtenga el hilo. El m√©todo Abort () puede bloquear el hilo que llama. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { }       <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { } <span class="hljs-comment"><span class="hljs-comment">// &lt;-- No ThreadAbortException in catch       finally { // &lt;-- No ThreadAbortException in finally           Thread.Sleep(- 1); } }); thread.Start(); ... thread.Abort(); // Never returns</span></span></code> </pre><br>  En realidad, esto se puede encontrar al usar el uso.  Se implementa en try / finally, dentro de finalmente, se llama al m√©todo Dispose.  Puede ser arbitrariamente complejo, contener controladores de eventos, usar bloqueos.  Y si se llam√≥ a thread.Abort en tiempo de ejecuci√≥n, Dispose - thread.Abort () lo esperar√°.  Entonces obtenemos un bloqueo casi desde cero. <br><br>  En .NET Core, el m√©todo thread.Abort () produce una excepci√≥n PlatformNotSupportedException.  Y creo que esto es muy bueno, porque me motiva a usar no thread.Abort (), sino m√©todos no invasivos para detener la ejecuci√≥n de c√≥digo, por ejemplo, usando CancellationToken. <br><br><h2>  FUERA DE MEMORIA </h2><br>  Esta excepci√≥n se puede obtener si la memoria en la m√°quina es menor que la requerida.  O cuando nos encontramos con las limitaciones de un proceso de 32 bits.  Pero puede obtenerlo incluso si la computadora tiene mucha memoria libre, y el proceso es de 64 bits. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr4gb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue/<span class="hljs-number"><span class="hljs-number">2</span></span>];</code> </pre><br>  El c√≥digo anterior arrojar√° OutOfMemory.  El problema es que, por defecto, los objetos de m√°s de 2 GB no est√°n permitidos.  Esto se puede solucionar configurando gcAllowVeryLargeObjects en App.config.  En este caso, se crea una matriz de 4 GB. <br><br>  Ahora intentemos crear una matriz a√∫n m√°s. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> largeArr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue];</code> </pre><br>  Ahora, incluso gcAllowVeryLargeObjects no ayudar√°.  Esto se debe a que .NET tiene un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">l√≠mite en el √≠ndice m√°ximo en una matriz</a> .  Esta restricci√≥n es menor que int.MaxValue. <br><br>  √çndice de matriz m√°x .: <br><br><ul><li>  conjuntos de bytes - 0x7FFFFFC7 <br></li><li>  otras matrices - 0X7F <b>E</b> FFFFF <br></li></ul><br>  En este caso, se producir√° una excepci√≥n OutOfMemoryException, aunque de hecho hemos encontrado una restricci√≥n de tipo de datos, no una falta de memoria. <br><br>  A veces, OutOfMemory es expl√≠citamente descartado por el c√≥digo administrado dentro del marco .NET: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/efd/c84/d98/efdc84d98a7786e39c9c5931ac523d13.png"><br>  Esta es una implementaci√≥n del m√©todo string.Concat.  Si la longitud de la cadena de resultado es mayor que int.MaxValue, se emite inmediatamente una OutOfMemoryException. <br><br>  Pasemos a la situaci√≥n en la que surge OutOfMemory en el caso en que la memoria realmente se agota. <br><br><pre> <code class="cs hljs">LimitMemory(<span class="hljs-number"><span class="hljs-number">64.</span></span>Mb()); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>)   list.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[size]); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (OutOfMemoryException e) { Console.WriteLine(e); }</code> </pre><br>  Primero, limitamos la memoria de nuestro proceso a 64 MB.  A continuaci√≥n, dentro del bucle, seleccione nuevas matrices de bytes, gu√°rdelas en alguna hoja para que el GC no las recopile e intente capturar OutOfMemory. <br><br>  En este caso, cualquier cosa puede suceder: <br><br><ul><li>  Excepci√≥n manejada <br></li><li>  El proceso caer√° <br></li><li>  Vamos a atrapar, pero la excepci√≥n se bloquear√° nuevamente <br></li><li>  Vamos a atrapar, pero StackOverflow se bloquear√° <br></li></ul><br>  En este caso, el programa ser√° completamente no determinista.  Analicemos todas las opciones: <br><br><ol><li>  Se puede manejar una excepci√≥n.  Dentro de .NET, no hay nada que le impida manejar una excepci√≥n OutOfMemoryException. <br></li><li>  El proceso puede caer.  No olvides que tenemos una aplicaci√≥n administrada.  Esto significa que en su interior se ejecuta no solo nuestro c√≥digo, sino tambi√©n el c√≥digo de tiempo de ejecuci√≥n.  Por ejemplo, GC.  Por lo tanto, una situaci√≥n puede ocurrir cuando el tiempo de ejecuci√≥n quiere asignar memoria para s√≠ mismo, pero no puede hacerlo, entonces no podremos detectar la excepci√≥n. <br></li><li>  Vayamos a la captura, pero la excepci√≥n se bloquear√° nuevamente.  Dentro de catch, tambi√©n hacemos el trabajo donde necesitamos memoria (imprimimos una excepci√≥n a la consola), y esto puede causar una nueva excepci√≥n. <br></li><li>  Vamos a atrapar, pero StackOverflow se bloquear√°.  StackOverflow en s√≠ ocurre cuando se llama al m√©todo WriteLine, pero no hay desbordamiento de pila aqu√≠, pero ocurre una situaci√≥n diferente.  Analic√©moslo con m√°s detalle. <br></li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/6e3/d32/752/6e3d32752ba10fd39d1f4a5e2e6648a7.png"><br><br>  En la memoria virtual, las p√°ginas no solo se pueden asignar a la memoria f√≠sica, sino que tambi√©n se pueden reservar.  Si la p√°gina est√° reservada, la aplicaci√≥n se√±al√≥ que la iba a usar.  Si la p√°gina ya est√° asignada a memoria real o intercambio, entonces se llama "comprometida" (comprometida).  La pila utiliza esta capacidad para dividir la memoria en reservada y comprometida.  Se parece a esto: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b17/9e4/41f/b179e441f0c00f18e2a5fdf12b3093a9.png"><br><br>  Resulta que llamamos al m√©todo WriteLine, que ocupa un lugar en la pila.  Resulta que toda la memoria comprometida ya ha finalizado, lo que significa que el sistema operativo en este momento deber√≠a tomar otra p√°gina reservada en la pila y asignarla a la memoria f√≠sica real, que ya est√° llena de conjuntos de bytes.  Esto lleva a la excepci√≥n de StackOverflow. <br><br>  El siguiente c√≥digo le permitir√° enviar toda la memoria a la pila al comienzo de la secuencia a la vez. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; F(), <span class="hljs-number"><span class="hljs-number">4</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>).Start();</code> </pre><br>  Alternativamente, puede usar la configuraci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tiempo de ejecuci√≥n</a> disableCommitThreadStack.  Debe deshabilitarse para que la pila de subprocesos se confirme de antemano.  Vale la pena se√±alar que el comportamiento predeterminado descrito en la documentaci√≥n y observado en la realidad es diferente. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/46e/0e6/dbd/46e0e6dbd47906fb1d0ddf74ac927383.png"><br><br><h2>  Desbordamiento de pila </h2><br>  Echemos un vistazo m√°s de cerca a StackOverflowException.  Veamos dos ejemplos de c√≥digo.  En uno de ellos, ejecutamos una recursi√≥n infinita, lo que conduce a un desbordamiento de la pila, en el segundo simplemente lanzamos esta excepci√≥n con throw. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { InfiniteRecursion(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception) { ... }</code> </pre><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StackOverflowException(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception) { ... }</code> </pre><br>  Como todas las excepciones lanzadas con lanzamiento se manejan, en el segundo caso capturaremos la excepci√≥n.  Y con el primer caso, todo es m√°s interesante.  Gire a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MSDN</a> : <br><br><blockquote>  "No se pueden detectar excepciones de desbordamiento de pila, porque el c√≥digo de manejo de excepciones puede requerir la pila". <br>  MSDN </blockquote><br>  Aqu√≠ dice que no podremos capturar una StackOverflowException, ya que la intercepci√≥n en s√≠ misma puede requerir espacio de pila adicional que ya ha finalizado. <br><br>  Para proteger de alguna manera contra esta excepci√≥n, podemos hacer lo siguiente.  Primero, puede limitar la profundidad de la recursi√≥n.  En segundo lugar, puede usar los m√©todos de la clase RuntimeHelpers: <br><br><blockquote>  RuntimeHelpers.EnsureSufficientExecutionStack (); <br><br><ul><li>  "Asegura que el espacio de pila restante sea lo suficientemente grande como para ejecutar la funci√≥n promedio de .NET Framework".  - MSDN <br></li><li>  InsufficientExecutionStackException <br></li><li>  512 KB - x86, AnyCPU, 2 MB - x64 (la mitad del tama√±o de la pila) <br></li><li>  64/128 KB - .NET Core <br></li><li>  Comprobar solo el espacio de direcciones de la pila <br></li></ul><br></blockquote><br>  La documentaci√≥n de este m√©todo dice que verifica que haya suficiente espacio en la pila para ejecutar la funci√≥n .NET <i>promedio</i> .  Pero, ¬øcu√°l es la funci√≥n <i>promedio</i> ?  De hecho, en .NET Framework este m√©todo verifica que al menos la mitad de su tama√±o est√© libre en la pila.  En .NET Core, busca 64K gratis. <br><br>  Tambi√©n ha aparecido un an√°logo en .NET Core: RuntimeHelpers. TryEnsureSufficientExecutionStack () que devuelve un bool, en lugar de lanzar una excepci√≥n. <br><br>  C # 7.2 introdujo la capacidad de usar Span y stackallock juntos sin usar c√≥digo inseguro.  Quiz√°s debido a esto, stackalloc se usar√° con m√°s frecuencia en el c√≥digo y ser√° √∫til tener una forma de protegerse de StackOverflow cuando lo use, eligiendo d√≥nde asignar memoria.  Como tal m√©todo, se propone un m√©todo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">que verifica la posibilidad de asignaci√≥n en la pila</a> y la construcci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">trystackalloc</a> . <br><br><pre> <code class="cs hljs">Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; span; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CanAllocateOnStack(size)) span = <span class="hljs-keyword"><span class="hljs-keyword">stackalloc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[size]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> span = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[size];</code> </pre><br>  Volver a la documentaci√≥n de StackOverflow en MSDN <br><br><blockquote>  En cambio, cuando se produce un desbordamiento de pila en una <b>aplicaci√≥n normal</b> , Common Language Runtime (CLR) finaliza el proceso ". <br>  MSDN <br></blockquote><br>  Si hay una aplicaci√≥n "normal" que cae durante StackOverflow, ¬øhay aplicaciones no normales que no caen?  Para responder a esta pregunta, deber√° bajar un nivel desde el nivel de la aplicaci√≥n administrada hasta el nivel CLR. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/186/516/64d/18651664dd1c1d1346e5377f0e0b3995.png"><br><br><blockquote>  "Una aplicaci√≥n que <b>aloja el CLR</b> puede cambiar el comportamiento predeterminado y especificar que el CLR <b>descargue el dominio de la aplicaci√≥n</b> donde se produce la excepci√≥n, pero permite que el proceso contin√∫e".  - MSDN <br>  StackOverflowException -&gt; AppDomainUnloadedException <br></blockquote><br>  Una aplicaci√≥n que aloja el CLR puede redefinir el comportamiento del desbordamiento de la pila para que, en lugar de completar todo el proceso, el dominio de la aplicaci√≥n se descargue, en la secuencia en la que se produjo este desbordamiento.  Entonces podemos convertir una StackOverflowException en una AppDomainUnloadedException. <br><br>  Cuando se inicia una aplicaci√≥n administrada, el tiempo de ejecuci√≥n de .NET se inicia autom√°ticamente.  Pero puedes ir por el otro lado.  Por ejemplo, escriba una aplicaci√≥n no administrada (en C ++ u otro lenguaje) que utilizar√° una API especial para elevar el CLR e iniciar nuestra aplicaci√≥n.  Una aplicaci√≥n que ejecuta el CLR internamente se llamar√° CLR-host.  Al escribirlo, podemos configurar muchas cosas en tiempo de ejecuci√≥n.  Por ejemplo, reemplace el administrador de memoria y el administrador de hilos.  En producci√≥n usamos CLR-host para evitar intercambiar p√°ginas de memoria. <br><br>  El siguiente c√≥digo configura el CLR-host para que AppDomain (C ++) se descargue durante StackOverflow: <br><br><pre> <code class="cpp hljs">ICLRPolicyManager *policyMgr; pCLRControl-&gt;GetCLRManager(IID_ICLRPolicyManager, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>**) (&amp;policyMgr)); policyMgr-&gt;SetActionOnFailure(FAIL_StackOverflow, eRudeUnloadAppDomain);</code> </pre><br>  ¬øEs esta una buena manera de escapar de StackOverflow?  Probablemente no muy.  En primer lugar, ten√≠amos que escribir c√≥digo C ++, que no querr√≠amos hacer.  En segundo lugar, debemos cambiar nuestro c√≥digo C # para que la funci√≥n que puede lanzar una StackOverflowException se ejecute en un AppDomain separado y en un hilo separado.  Nuestro c√≥digo se convertir√° inmediatamente en tales fideos: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> appDomain = AppDomain.CreateDomain(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); appDomain.DoCallBack(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; InfiniteRecursion()); thread.Start(); thread.Join(); }); AppDomain.Unload(appDomain); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (AppDomainUnloadedException) { }</code> </pre><br>  Para llamar al m√©todo InfiniteRecursion, escribimos un mont√≥n de l√≠neas.  Tercero, comenzamos a usar AppDomain.  Y esto casi garantiza un mont√≥n de nuevos problemas.  Incluyendo con excepciones.  Considere un ejemplo: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomException</span></span> : <span class="hljs-title"><span class="hljs-title">Exception</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> appDomain = AppDomain.CreateDomain( <span class="hljs-string"><span class="hljs-string">"..."</span></span>); appDomain.DoCallBack(() =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomException()); System.Runtime.Serialization.SerializationException: Type <span class="hljs-string"><span class="hljs-string">'CustomException'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> not marked <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> serializable. at System.AppDomain.DoCallBack(CrossAppDomainDelegate callBackDelegate)</code> </pre><br>  Como nuestra excepci√≥n no est√° marcada como serializable, nuestro c√≥digo caer√° con una SerializationException.  Y para solucionar este problema, no es suficiente para nosotros marcar nuestra excepci√≥n con el atributo Serializable, a√∫n necesitamos implementar un constructor adicional para la serializaci√≥n. <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomException</span></span> : <span class="hljs-title"><span class="hljs-title">Exception</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SerializationInfo info, StreamingContext ctx</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">info, context</span></span></span><span class="hljs-function">)</span></span>{} } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> appDomain = AppDomain.CreateDomain(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); appDomain.DoCallBack(() =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomException());</code> </pre><br>  Todo resulta no muy hermoso, por lo que vamos m√°s all√°: al nivel del sistema operativo y los hacks, que no deber√≠an usarse en la producci√≥n. <br><br><h2>  Seh / veh </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/2c5/7a2/aff/2c57a2aff0542b2a02ad8ab34d097412.png"><br><br>  Tenga en cuenta que si bien las excepciones administradas volaron entre administrado y CLR, las excepciones SEH vuelan entre CLR y Windows. <br><br>  SEH - Manejo de excepciones estructuradas <br><br><ul><li>  Motor de manejo de excepciones de Windows <br></li><li>  Manejo uniforme de excepciones de software y hardware <br></li><li>  Excepciones de C # implementadas sobre SEH <br></li></ul><br>  SEH es un mecanismo de manejo de excepciones en Windows, le permite manejar de manera uniforme todas las excepciones que vinieron, por ejemplo, desde el nivel del procesador, o que se asociaron con la l√≥gica de la aplicaci√≥n misma. <br><br>  Rantime .NET conoce las excepciones SEH y puede convertirlas en excepciones administradas: <br><br><ul><li>  EXCEPTION_STACK_OVERFLOW -&gt; Crash <br></li><li>  EXCEPTION_ACCESS_VIOLATION -&gt; AccessViolationException <br></li><li>  EXCEPTION_ACCESS_VIOLATION -&gt; NullReferenceException <br></li><li>  EXCEPTION_INT_DIVIDE_BY_ZERO -&gt; DivideByZeroException <br></li><li>  Excepciones SEH desconocidas -&gt; SEHException <br></li></ul><br>  Podemos interactuar con SEH a trav√©s de WinApi. <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"kernel32.dll"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaiseException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dwExceptionCode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dwExceptionFlags, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nNumberOfArguments,IntPtr lpArguments</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-comment"><span class="hljs-comment">// DivideByZeroException RaiseException(0xc0000094, 0, 0, IntPtr.Zero); // Stack overflow RaiseException(0xc00000fd, 0, 0, IntPtr.Zero);</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> De hecho, la construcci√≥n de lanzamiento tambi√©n funciona a trav√©s de SEH. </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> -&gt; RaiseException(<span class="hljs-number"><span class="hljs-number">0xe0434f4d</span></span>, ...)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vale la pena se√±alar aqu√≠ que el c√≥digo de excepci√≥n CLR es siempre el mismo, por lo que no importa qu√© tipo de excepci√≥n arrojemos, siempre se procesar√°. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VEH es un manejo de excepciones de vectores, una extensi√≥n de SEH, pero que funciona a nivel de proceso y no a nivel de un solo subproceso. </font><font style="vertical-align: inherit;">Si SEH es sem√°nticamente similar a try-catch, entonces VEH es sem√°nticamente similar a un controlador de interrupciones. </font><font style="vertical-align: inherit;">Simplemente configuramos nuestro controlador y podemos recibir informaci√≥n sobre todas las excepciones que ocurren en nuestro proceso. </font><font style="vertical-align: inherit;">Una caracter√≠stica interesante de VEH es que le permite cambiar la excepci√≥n SEH antes de que llegue al controlador.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/7b8/79d/848/7b879d848390b9e3d1b9156b00b8e2bf.png"><br><br>           ,    SEH-     EXCEPTION_STACK_OVERFLOW   ,   .NET   . <br><br>  VEH    WinApi: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"kernel32.dll"</span></span></span><span class="hljs-meta">, SetLastError = true)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> IntPtr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddVectoredExceptionHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr FirstHandler,  VECTORED_EXCEPTION_HANDLER VectoredHandler</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> VEH </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PVECTORED_EXCEPTION_HANDLER</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EXCEPTION_POINTERS exceptionPointers</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> VEH : <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> { EXCEPTION_CONTINUE_SEARCH = <span class="hljs-number"><span class="hljs-number">0</span></span>, EXCEPTION_EXECUTE_HANDLER = <span class="hljs-number"><span class="hljs-number">1</span></span>, EXCEPTION_CONTINUE_EXECUTION = <span class="hljs-number"><span class="hljs-number">-1</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> VEH </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PVECTORED_EXCEPTION_HANDLER</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EXCEPTION_POINTERS exceptionPointers</span></span></span><span class="hljs-function">)</span></span>; [StructLayout(LayoutKind.Sequential)] <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> EXCEPTION_POINTERS { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> EXCEPTION_RECORD* ExceptionRecord; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IntPtr Context; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> VEH </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PVECTORED_EXCEPTION_HANDLER</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EXCEPTION_POINTERS exceptionPointers</span></span></span><span class="hljs-function">)</span></span>; [StructLayout(LayoutKind.Sequential)] <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> EXCEPTION_RECORD { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> ExceptionCode; ... }</code> </pre><br>  Context          .     EXCEPTION_RECORD   ExceptionCode  .        ,   CLR    .    : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> VEH </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EXCEPTION_POINTERS e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e.ExceptionRecord == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> VEH. EXCEPTION_CONTINUE_SEARCH; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> record = e. ExceptionRecord; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (record-&gt;ExceptionCode != ExceptionStackOverflow) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> VEH. EXCEPTION_CONTINUE_SEARCH; record-&gt;ExceptionCode = <span class="hljs-number"><span class="hljs-number">0x01234567</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> VEH. EXCEPTION_EXECUTE_HANDLER; }</code> </pre><br>   ,       HandleSO,     ,      StackOverflowException (        WinApi    ). <br><br><pre> <code class="cs hljs">HandleSO(() =&gt; InfiniteRecursion()) ; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T HandleSO&lt;T&gt;(Func&lt;T&gt; action) { Kernel32. AddVectoredExceptionHandler(IntPtr.Zero, Handler); Kernel32.SetThreadStackGuarantee(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> size); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> action(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) when ((<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>) Marshal. GetExceptionCode() == <span class="hljs-number"><span class="hljs-number">0x01234567</span></span>) {} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>(T); } HandleSO(() =&gt; InfiniteRecursion());</code> </pre><br>      SetThreadStackGuarantee.         StackOverflow. <br><br>          .          ,      . <br><br> ,  ,   HandleSO    ? <br><br><pre> <code class="cs hljs">HandleSO(() =&gt; InfiniteRecursion()); HandleSO(() =&gt; InfiniteRecursion());</code> </pre><br>   AccessViolationException.    . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/639/e93/c8d/639e93c8d187dc31fc37a2ac7247f193.png"><br>      .       ,   Guard page.          ‚Äì STATUS_GUARD_PAGE_VIOLATION,   Guard page   .     ,         ‚Äì           stack-pointer    ,   .   ‚Äî  AccessViolationException.        StackOverflow ‚Äì c     ‚Äì   _resetstkoflw    C (msvcrt.dll). <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"msvcrt.dll"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _resetstkoflw();</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De manera similar, puede detectar una excepci√≥n AccessViolationException en .NET Core en Windows, lo que hace que el proceso se bloquee. </font><font style="vertical-align: inherit;">En este caso, debe tener en cuenta el orden en que se llaman los manejadores de vectores y establecer su manejador al comienzo de la cadena, ya que .NET Core tambi√©n usa VEH al procesar AccessViolation. </font><font style="vertical-align: inherit;">El primer par√°metro de la funci√≥n AddVectoredExceptionHandler es responsable del orden en que se llaman los controladores:</font></font><br><br><pre> <code class="cs hljs">Kernel32.AddVectoredExceptionHandler(FirstHandler: (IntPtr) <span class="hljs-number"><span class="hljs-number">1</span></span>, handler);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Despu√©s de estudiar cuestiones pr√°cticas, resumimos los resultados generales: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Las excepciones no son tan simples como parecen; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No todas las excepciones se manejan de la misma manera; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El manejo de excepciones ocurre en diferentes niveles de abstracci√≥n; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Puede intervenir en el proceso de manejo de excepciones y hacer que el tiempo de ejecuci√≥n de .NET funcione de manera diferente a la prevista originalmente. </font></font><br></li></ul><br><h2>  Referencias </h2><br> ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">    </a> <br> ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Dotnext 2016 Moscow ‚Äî Adam Sitnik ‚Äî Exceptional Exceptions in .NET</a> <br> ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DotNetBook: Exceptions</a> <br> ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">.NET Inside Out Part 8 ‚Äî Handling Stack Overflow Exception in C# with VEH</a> ‚Äî    StackOverflow. <br><br><blockquote> 22-23     <b>DotNext 2018 Moscow</b>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬´ :   ¬ª</a> .       ,  ,        .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> ,    ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> . ! </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es426045/">https://habr.com/ru/post/es426045/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es426029/index.html">¬øTe rindes y quieres abandonar la tarea? As√≠ es como se ve la capacitaci√≥n efectiva para desarrolladores</a></li>
<li><a href="../es426031/index.html">Preocuparse por capturar el mundo con inteligencia artificial puede basarse en suposiciones no cient√≠ficas</a></li>
<li><a href="../es426033/index.html">Choque de titanes matem√°ticos sobre prueba √©pica de hip√≥tesis ABC</a></li>
<li><a href="../es426039/index.html">Lanzamiento de emergencia "Soyuz MS-10" (equipo rescatado, transmitido)</a></li>
<li><a href="../es426041/index.html">Soluci√≥n simb√≥lica de ecuaciones diferenciales lineales y sistemas mediante el m√©todo de transformaci√≥n de Laplace utilizando SymPy</a></li>
<li><a href="../es426047/index.html">10 grandes libros para principiantes en ingl√©s</a></li>
<li><a href="../es426051/index.html">Mejora de las habilidades de depuraci√≥n de software: algunos consejos</a></li>
<li><a href="../es426053/index.html">Mejora del rendimiento de la aplicaci√≥n de almacenamiento en cach√© del controlador de eventos y React Application</a></li>
<li><a href="../es426055/index.html">TensorFlow.js y clmtrackr.js: seguimiento de la direcci√≥n de la mirada del usuario en el navegador</a></li>
<li><a href="../es426059/index.html">Tutu PHP Meetup # 2: Discursos Video</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>