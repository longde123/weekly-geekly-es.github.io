<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✊🏼 👨🏼‍💼 👉 Top 10 des rapports C ++ Russie et liste de lecture de conférence en accès libre 👨‍🔬 ▶️ 👩🏼‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ce hub rassemble les dix meilleurs rapports de conférenciers tels que Nicolai Josuttis, Timur Doumler, Andrey Davydov et bien d'autres. 


 C ++ 17/20...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Top 10 des rapports C ++ Russie et liste de lecture de conférence en accès libre</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/462939/"><p>  Ce hub rassemble les dix meilleurs rapports de conférenciers tels que Nicolai Josuttis, Timur Doumler, Andrey Davydov et bien d'autres. </p><br><p>  C ++ 17/20/23, concepts, structures de données immuables, concurrence, parallélisme, métaprogrammation - tous ces thèmes sont abordés lors de la conférence C ++ Russie 2019 qui s'est tenue ce printemps à Moscou.  Plus de six cents participants, des conférenciers internationaux bien connus, des rapports détaillés.  Veuillez noter - les rapports sont tels qu'ils seront obsolètes très bientôt, et vous pouvez appliquer les connaissances acquises même maintenant. </p><br><p><img src="https://habrastorage.org/webt/ab/ih/eg/abihegoiqc7l912fnxnmipgjgum.jpeg"></p><br><p>  Le format est le suivant: </p><br><ul><li>  Vidéo YouTube obligatoire </li><li>  Une description détaillée du rapport en russe (avec des diapositives, le cas échéant) </li><li>  Brève biographie de l'orateur </li></ul><br><p>  N'hésitez pas à écrire des commentaires!  Au fait, dans la playlist publiée sous la coupe, il n'y a pas que le top 10.  Et nous avons désactivé les publicités sur YouTube, afin que personne n'interfère. </p><a name="habracut"></a><br><p>  Tous les rapports vont de «junior» à «senior», mais les différences entre les places des dix premiers sont minimes et dépendent fortement de la méthodologie d'évaluation.  En modifiant légèrement la méthodologie, vous pouvez considérablement changer de lieu.  Alors regardez tout! </p><br><p>  La playlist complète de la conférence <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">est ici</a> . </p><br><h2 id="10-the-hitchhikers-guide-to-faster-buildshttps2019cppconf-moscowrutalks4hyczllx72s6gqq2isucy0">  10. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le guide de l'auto-stoppeur pour des constructions plus rapides</a> </h2><br><p>  <em>Viktor Kirilov</em> </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/5rRLHRRqg5A" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Diapositives</a> </p><br><p>  C ++ est connu pour ses performances, sa vitesse, son absence de système de construction standard et de gestionnaire de packages, ainsi que la complexité et la durée de la compilation.  L'impossibilité d'un développement itératif rapide est l'un des plus grands tueurs de la productivité des développeurs.  Ce rapport est destiné à tous ceux qui souhaitent améliorer les trois derniers points: d'abord, quelques idées pour lesquelles la compilation et la liaison prennent autant de temps, puis une liste de techniques et d'outils pour résoudre le problème, par exemple: </p><br><ul><li>  réglage et infrastructure - matériel, systèmes d'assemblage, mise en cache, assemblages distribués, diagnostics des goulots d'étranglement, hygiène du code; </li><li> techniques - constructions d'unité, en-têtes précompilés, statique vs partagé; </li><li>  changements dans les sources - idiome PIMPL, utilisation plus correcte des modèles, annotations; </li><li>  modules - qu'est-ce que c'est lorsqu'ils apparaissent en C ++, ce qui s'avérera plus inutile à cause de cela. </li></ul><br><p>  <strong>À propos de Speaker</strong> </p><br><p><img width="200" align="left" src="https://habrastorage.org/getpro/habr/post_images/3e1/0a9/1e6/3e10a91e6e7586dab6b64245e9c05123.jpg">  Six ans d'expérience professionnelle en C ++ dans les secteurs du jeu et des effets visuels.  Maintenant, Victor développe l'open source et de temps en temps - le travail contractuel habituel.  L'une des dernières tâches intéressantes est l'implémentation de code remplaçable à chaud dans le runtime Nim.  Il est également l'auteur de doctest, "la bibliothèque de tests à en-tête unique la plus rapide et la plus puissante pour C ++".  Il s'intéresse au développement de jeux et de moteurs de jeux, de code haute performance, de crypto-monnaies, à l'optimisation du flux de travail et à l'intégration de bonnes pratiques de développement, telles que l'analyse statique moderne et les outils d'instrumentation.  Victor vit à Sofia (Bulgarie) et la programmation est à la fois sa profession et son hobby.  Ayez votre propre site Web: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://onqtam.com/</a> <br clear="all"></p><br><hr><br><h2 id="9-shablony-c-i-bazy-dannyhhttps2019cppconf-moscowrutalks3zbzmnvl2qqmyfx61jlrql">  9. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Modèles et bases de données C ++</a> </h2><br><p>  <em>Sergey Fedorov</em> </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/7qCtCXxpgfw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Diapositives</a> </p><br><p>  Lorsque nous travaillons avec des bases de données, nous obtenons souvent des tampons bruts, alors que nous voulons recevoir des données sous la forme de structures, de classes et de conteneurs C ++. </p><br><p>  Une histoire sur la conception et l'implémentation du pilote PostgreSQL avec une interface humaine utilisant presque tous les outils de langage C ++ 17 actuellement disponibles. </p><br><p>  L'approche décrite dans le rapport peut être adaptée à presque tous les protocoles de niveau application. </p><br><p>  <strong>À propos de Speaker</strong> </p><br><p><img width="200" align="left" src="https://habrastorage.org/getpro/habr/post_images/984/7be/df1/9847bedf11e6ab7fd3505278dac7e35a.jpg">  Sergey Fedorov, l'un des principaux développeurs de Yandex.Taxi, développe un cadre asynchrone pour le backend Taxi.  Un grand fan de métaprogrammation et open source. <br clear="all"></p><br><hr><br><h2 id="8-move-only-c-designhttps2019cppconf-moscowrutalks11auqe0dbeawgemasoqws2">  8. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Conception C ++ à déplacement uniquement</a> </h2><br><p>  <em>Ivan Čukić</em> </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/04HcVuqlZ5E" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  RAII libère les ressources capturées.  Mais il y a une ressource qui ne peut pas être retournée - c'est le moment. </p><br><p>  L'une des erreurs les plus chronophages est la création de copies inutiles.  La sémantique C ++ 11 Move a fait un pas dans la bonne direction.  Il vous permet de donner des données inutiles à quelqu'un d'autre sans amende pour en créer une copie et sans risque de course selon les données lorsque les données ont de nombreux utilisateurs. </p><br><p>  Dans cet exposé, nous prendrons part à une discussion sur une approche d'architecture qui ne permet que l'utilisation de types spéciaux, non copiables et déplaçables appelés types linéaires.  Nous discuterons des fonctionnalités de C ++ qui nous permettront de forcer l'utilisation de tels types. </p><br><p>  Pour cela, il est proposé d'utiliser des concepts de C ++ 20, &amp;&amp; - fonctions qualifiées, etc. </p><br><p>  <strong>À propos de Speaker</strong> </p><br><p><img width="200" align="left" src="https://habrastorage.org/getpro/habr/post_images/8ea/c6a/160/8eac6a16009fbed602542b6fa5c55e28.jpg">  Ivan Chukich est l'auteur de Functional Programming in C ++, publié par Manning.  Le contributeur KDE est l'un des plus grands projets open source open source.  De plus, il enseigne les techniques de programmation modernes à l'université, transférant à ses étudiants ses 20 ans d'expérience en C ++.  Il a étudié la programmation fonctionnelle en C ++ pendant et avant le post-doc, et a utilisé ces techniques dans des projets du monde réel. <br clear="all"></p><br><hr><br><h2 id="7-concurrency-and-parallelism-in-c17-and-c2023https2019cppconf-moscowrutalks6hdip4v8eo46ii6eeoiw2a">  7. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Concurrence et parallélisme en C ++ 17 et C ++ 20/23</a> </h2><br><p>  <em>Rainer grimm</em> </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/qE4AxHg_H_A" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Qu'est-ce qui est commun entre les threads, les atomes, les mutex et les variables conditionnelles?  Tous ces éléments sont les blocs de base pour la construction de toutes les applications multithread en C ++, et ils peuvent causer des problèmes même pour les développeurs C ++ expérimentés. </p><br><p>  Cette situation a radicalement changé en C ++ 17, et plus encore en C ++ 20/23.  À partir de C ++ 17, la plupart des algorithmes standard sont disponibles sous forme série, parallèle et vectorisée.  Dans les dernières normes, nous attendons des exécuteurs et de la mémoire transactionnelle, nous pouvons nous attendre à de grandes améliorations dans les futures et les coroutines.  Pour le multithreading et la concurrence, ce n'est que le début.  Il est à espérer qu'à l'avenir, seuls (exécuteurs, mémoire transactionnelle, futurs, coroutines) seront utilisés dans les abstractions, et les threads, atomes, mutex et variables conditionnelles deviendront de simples détails d'implémentation. </p><br><p>  Le but de ce rapport est de voir ce que nous avons déjà reçu en C ++ 17 et ce que nous pouvons espérer en C ++ 20/23. </p><br><p>  <strong>À propos de Speaker</strong> </p><br><p><img width="200" align="left" src="https://habrastorage.org/getpro/habr/post_images/ded/14e/b66/ded14eb6614064a6bdbc84576acfde1c.jpg">  Rainer Grimm travaille en tant qu'architecte, chef d'équipe et instructeur depuis environ 20 ans.  Dans ses temps libres, il aime écrire des articles sur C ++, Python et Haskell et parler lors de conférences, écrit souvent sur son blog «Modern C ++».  Il anime actuellement des séminaires sur le C ++ moderne et Python.  Ses livres C ++ 11 für Programmierer, C ++, C ++ Standardbibliothek et The C ++ Standard Library sont publiés par O'Reilly et Leanpub. <br clear="all"></p><br><hr><br><h2 id="6-metaprogrammirovanie-schadyaschee-kompilyatorhttps2019cppconf-moscowrutalks6lf5gnsfecyae8ek0u2ymy">  6. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Métaprogrammation, compilateur doux</a> </h2><br><p>  <em>Andrey Davydov</em> </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/udTEfwCkmaw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Tout programmeur qui a plongé dans le monde du C ++ sait que les modèles sont complets, «l'échec de la substitution n'est pas une erreur» et au moment de la compilation, vous pouvez faire des choses incroyables et parfois même utiles.  D'un autre côté, un développeur C ++ expérimenté comprend que «vous pouvez» ne signifie pas «vous avez besoin» et que vous devez payer pour l'abus de la métaprogrammation.  L'une des principales contraintes est le temps de compilation, c'est pourquoi le rapport discute quelles opérations / techniques sont les plus coûteuses du point de vue du compilateur et comment les éviter. </p><br><p>  En particulier, les problèmes suivants ont été mis en évidence: </p><br><ul><li>  pourquoi SFINAE est la dernière chose à utiliser; </li><li>  pourquoi std :: conditional_t ​​est défini de manière inefficace; </li><li>  quelle est la différence entre les implémentations de tuple dans Microsoft STL et libc ++; </li><li>  quand utiliser std :: {conjonction, disjonction} et quand utiliser les expressions de repli; </li><li>  pourquoi vous ne devriez pas utiliser std :: void_t; </li><li>  comment les concepts apparaissant en C ++ 20 peuvent aider. </li></ul><br><p>  <strong>À propos de Speaker</strong> </p><br><p><img width="200" align="left" src="https://habrastorage.org/getpro/habr/post_images/ea9/264/0dd/ea92640ddd4e716ba67055404ebc0685.jpg">  Au cours des 3 dernières années, Andrey a travaillé dans l'équipe ReSharper C ++ chez JetBrains.  Dans le passé, il était engagé dans la programmation industrielle dans des domaines liés aux SIG et aux systèmes de visualisation 3D. <br clear="all"></p><br><hr><br><h2 id="5-nezamenimyy-shttps2019cppconf-moscowrutalks6m9dubhdowimis6g8womwe">  5. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">C ++ essentiel</a> </h2><br><p>  <em>Anton Polukhin</em> </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/LZflL44SVVY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Chaque nouveau langage de programmation s'efforce de déclarer qu'il est plus rapide, plus fiable et généralement à tous égards plusieurs fois meilleur que C ++. </p><br><p>  Voyons voir - où est la vérité, et où est la fiction.  Que la bataille commence entre C ++ et Asm / Rust / Go / Java / C # ...! </p><br><p>  <strong>À propos de Speaker</strong> </p><br><p><img width="200" align="left" src="https://habrastorage.org/getpro/habr/post_images/16f/005/661/16f00566146a92689a0cff14e4524a28.jpg">  Représentant de la Russie à l'ISO aux réunions internationales du groupe de travail sur la normalisation C ++.  L'auteur de plusieurs propositions acceptées pour la norme de langage C ++. </p><br><p>  Auteur des bibliothèques Boost TypeIndex, DLL, Stacktrace et mainteneur actif Any, Conversion, LexicalCast, Variant. </p><br><p>  Il est l'auteur de Boost C ++ Application Development Cookbook and Second Edition. <br clear="all"></p><br><hr><br><h2 id="4-postmodern-immutable-data-structureshttps2019cppconf-moscowrutalks6mfmvol8iguwd8p4exulld">  4. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Structures de données immuables postmodernes</a> </h2><br><p>  <em>Juan Pedro Bolívar Puente</em> </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/dbFfpTp3EhA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  L'élite C ++ parle de sémantique de valeur, d'immuabilité et de partage en communiquant depuis des années.  Nous attendons un monde meilleur sans mutex, races, observateurs, schémas «d'équipe» et tout ce jazz.  Quand il s'agit de pratiquer, il y a de gros problèmes.  L'un des principaux problèmes concerne les structures de données. </p><br><p>  Les structures de données immuables ne modifient pas les valeurs pour pouvoir les utiliser - vous devez créer de nouvelles valeurs.  Les anciennes valeurs restent telles quelles et vous pouvez donc les utiliser à partir de plusieurs threads sans les bloquer.  Cela nous donne une séparation structurelle des ressources, car les valeurs nouvelles et anciennes peuvent utiliser les mêmes données communes - elles peuvent être rapidement comparées et un historique très annulé stocké de manière très compacte.  C'est pourquoi ils sont si agréables à utiliser dans les systèmes multi-threads et interactifs: ils simplifient l'architecture des logiciels de bureau et permettent aux serveurs de mieux évoluer.  C'est l'ingrédient secret qui a déterminé le succès de Clojure et Scala, et même les développeurs JavaScript aiment l'utiliser avec quelque chose comme Immutable.js de Facebook. </p><br><p>  Juan présente Immer, une bibliothèque C ++ qui implémente des structures de données modernes, efficaces et immuables. </p><br><p>  Dans cet exposé, il a parlé des avantages architecturaux de l'immuabilité et a montré comment un vecteur persistant extrêmement efficace et puissant peut être construit au-dessus de structures de données modernes perfectionnées (Relaxed Radix Balanced Trees).  Nous avons examiné un exemple de programme - un éditeur de texte conçu dans un tel style architectural.  Le code n'est pas seulement super simple, il a également surpassé la plupart des programmes similaires en termes de performances.  Ne croyez pas?  Ouvrez le rapport et voyez par vous-même! </p><br><p>  Technologies utilisées: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/arximboldi/immer</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/arximboldi/ewig</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/arximboldi/lager</a> </li></ul><br><p>  <strong>À propos de Speaker</strong> </p><br><p><img width="200" align="left" src="https://habrastorage.org/getpro/habr/post_images/e2d/048/2bf/e2d0482bf72ab93b14bddb8f69484742.jpg">  Juan est un consultant et ingénieur indépendant de Berlin spécialisé dans la conception axée sur la valeur, les logiciels interactifs, le C ++ moderne, la programmation fonctionnelle et l'utilisation stratégique de l'open source.  Auparavant, il a travaillé à Ableton et a participé à divers projets liés à la musique.  Il a également participé au projet GNU et co-fondé Hacklab à Grenade. <br clear="all"></p><br><hr><br><h2 id="3-koncepty-uproschaem-realizaciyu-klassov-std-utilityhttps2019cppconf-moscowrutalks571hb6uadyeikamsm2kusa">  3. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Concepts: simplifier l'implémentation des classes d'utilité std</a> </h2><br><p>  <em>Andrey Davydov</em> </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/vYzjV0xSqJE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Les concepts apparaissant en C ++ 20 sont un sujet long et largement discuté.  Malgré l'excès de matériel accumulé au fil des ans (y compris les discours d'experts de classe mondiale), il existe toujours une confusion parmi les programmeurs appliqués (qui ne s'endorment pas quotidiennement avec la norme) ce que sont les concepts C ++ 20 et sont-ils nous avons besoin s'il y a enable_if vérifié au fil des ans.  En partie, la faute est de savoir comment les concepts ont évolué sur ~ 15 ans (Concepts Full + Concept Map -&gt; Concepts Lite), et en partie parce que les concepts se sont révélés ne pas ressembler à des outils similaires dans d'autres langages (limites génériques Java / C #, traits de rouille, ... ) </p><br><p>  Le rapport commencera par un bref aperçu des innovations liées au concept de C ++ 20, après quoi nous examinerons la mise en œuvre de certaines classes et fonctions de STL, en comparant les solutions C ++ 17 et C ++ 20.  Par exemple: </p><br><ul><li>  pour implémenter std :: optional maintenant vous devez utiliser la hiérarchie d'héritage de profondeur 7, en C ++ 20 ce ne sera pas nécessaire; </li><li>  pour le constructeur par défaut std :: pair nécessite désormais 2 fonctions de modèle, en C ++ 20 - 1 non-modèle; </li><li>  souvent, les classes de modèles se spécialisent partiellement, dans le cas où les paramètres de modèle ont des propriétés spéciales, il est plus pratique et plus correct de le faire avec des concepts. </li></ul><br><p>  Le public est censé avoir une idée générale de ce que sont les concepts et SFINAE.  Une connaissance de la bibliothèque C ++ standard sera également utile; la connaissance des subtilités et des détails d'implémentation n'est pas requise. </p><br><p>  <strong>À propos de Speaker</strong> </p><br><p><img width="200" align="left" src="https://habrastorage.org/getpro/habr/post_images/ea9/264/0dd/ea92640ddd4e716ba67055404ebc0685.jpg">  Au cours des 3 dernières années, Andrey a travaillé dans l'équipe ReSharper C ++ chez JetBrains.  Dans le passé, il était engagé dans la programmation industrielle dans des domaines liés aux SIG et aux systèmes de visualisation 3D. <br clear="all"></p><br><hr><br><h2 id="2-initialisation-in-modern-chttps2019cppconf-moscowrutalks6agyo6ro5ebrb45kagrw1i">  2. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Initialisation en C ++ moderne</a> </h2><br><p>  <em>Timur Doumler</em> </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/2jJumNzcp6Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Il est bien connu que la sémantique d'initialisation est l'une des parties les plus complexes du C ++.  Il existe de nombreux types d'initialisation, décrits par différentes syntaxes, et ils interagissent tous de manière complexe et difficile.  C ++ 11 a apporté le concept de "l'initialisation universelle".  Malheureusement, elle a introduit des règles encore plus complexes, et à leur tour, elles ont été bloquées en C ++ 14, C ++ 17 et modifiées à nouveau en C ++ 20. </p><br><p>  Dans ce rapport, Timur a d'abord résumé les résultats historiques de l'évolution de l'initialisation en C ++.  Il a donné un aperçu systématique de la version actuelle de la règle d'initialisation, des problèmes typiques et des surprises.  Introduit des règles pratiques sur la façon d'utiliser efficacement toutes ces règles.  Et enfin, Timur a parlé des dernières propositions de la norme, ce qui peut rendre la sémantique de l'initialisation C ++ 20 un peu plus pratique. </p><br><p>  <strong>À propos de Speaker</strong> </p><br><p><img width="200" align="left" src="https://habrastorage.org/getpro/habr/post_images/076/f66/d80/076f66d80baa7ee786b6094876cb5cbf.jpg">  Timur est un développeur C ++ spécialisé dans le son et la musique, membre du comité ISO C ++, directeur de programme de l'Audio Developer Conference (ADC).  Il s'efforce d'écrire du code propre, de développer de bons outils, de promouvoir l'évolution du langage C ++ et de construire des communautés inclusives. <br clear="all"></p><br><hr><br><h2 id="1-c17--the-biggest-trapshttps2019cppconf-moscowrutalks75xt7yxs4phphnnxq0rygs">  1. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">C ++ 17 - les plus gros pièges</a> </h2><br><p>  <em>Nicolai josuttis</em> </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/h-zy1hBqT74" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  C ++ 17 est une énorme combinaison de petites nouvelles fonctionnalités, à la fois dans le langage et dans la bibliothèque.  Ces capacités vous permettent non seulement de faire plus de nouvelles choses, mais offrent également de nouvelles façons de tirer dans les jambes - beaucoup plus souvent que prévu.  Ce n'est pas une théorie.  Cela se passe dans la vraie vie, ici et maintenant. </p><br><p>  Dans ce rapport, Nikolai a trié tous ces pièges, a discuté des raisons de leurs idées et de leur architecture et a donné des instructions sur la façon de contourner les problèmes.  En tant qu'effet secondaire, vous pouvez approfondir les nouvelles fonctionnalités de C ++ 17. </p><br><p>  <strong>À propos de Speaker</strong> </p><br><p><img width="200" align="left" src="https://habrastorage.org/getpro/habr/post_images/929/296/158/929296158deb3ee24a98aabb78412890.png">  Nikolay est architecte de systèmes indépendant, responsable technique, auteur et consultant.  Il développe des systèmes logiciels de moyenne et grande taille pour les télécommunications, la finance et la fabrication. </p><br><p>  Il est largement connu dans la communauté pour ses rapports et le fait qu'il écrit des livres sur C ++ ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">The C ++ Standard Library</a> and <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">C ++ Templates</a> ), parle des nouvelles fonctionnalités du langage. </p><br><p>  Depuis 20 ans, il est membre actif du comité de normalisation C ++. <br clear="all"></p><br><hr><br><blockquote>  Une playlist complète avec tous les rapports <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">est disponible ici</a> .  Nous vous rappelons que le nouveau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">C ++ Russia est</a> déjà en route et se tiendra du 31 octobre au 1er novembre 2019 à Saint-Pétersbourg.  Les billets peuvent être <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">achetés sur le site officiel</a> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr462939/">https://habr.com/ru/post/fr462939/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr462923/index.html">Entrée dans Aeronet Épisode 3: Trouver la balle</a></li>
<li><a href="../fr462929/index.html">Je te vois: tactiques de masquage de chauve-souris</a></li>
<li><a href="../fr462933/index.html">Comment fonctionne le blocage d'Internet: un examen des méthodes modernes avec un exemple réel</a></li>
<li><a href="../fr462935/index.html">Comment rester concentré tout en travaillant dans un bureau à aire ouverte?</a></li>
<li><a href="../fr462937/index.html">Le concept de tissu persistant pour contrôler l'infrastructure informatique</a></li>
<li><a href="../fr462943/index.html">Chasser les Wumpus ou expérimenter l'écriture d'un jeu Android classique</a></li>
<li><a href="../fr462945/index.html">Générez des mots de passe à usage unique pour 2FA dans JS à l'aide de l'API Web Crypto</a></li>
<li><a href="../fr462947/index.html">L'histoire de la façon dont PVS-Studio a trouvé une erreur dans la bibliothèque utilisée dans ... PVS-Studio</a></li>
<li><a href="../fr462949/index.html">L'histoire de la façon dont PVS-Studio a trouvé une erreur dans la bibliothèque utilisée dans ... PVS-Studio</a></li>
<li><a href="../fr462951/index.html">Là où une personne voit des formes, l'IA voit des textures</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>