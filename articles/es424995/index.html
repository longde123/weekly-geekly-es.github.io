<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï∫üèª ü§© üßó Otro sistema de part√≠culas. Post mortem üë©üèΩ‚Äçü§ù‚Äçüë®üèª üè≠ üëêüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En septiembre de este a√±o, se lanzar√≠a el juego m√≥vil Titan World de Unstoppable, la oficina de Minsk de Glu mobile. El proyecto fue cancelado justo a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Otro sistema de part√≠culas. Post mortem</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424995/"><img src="https://habrastorage.org/webt/mr/k9/jt/mrk9jtkw0lnm7z8b6gh-hkxmwru.png" alt="imagen"><br><br>  <b>En septiembre de este a√±o, se lanzar√≠a el juego m√≥vil Titan World de Unstoppable, la oficina de Minsk de Glu mobile.</b>  <b>El proyecto fue cancelado justo antes del lanzamiento mundial.</b>  <b>Pero los logros permanecieron, y el m√°s interesante de ellos, con el amable permiso de los jefes del estudio Dennis Zdonov y Alex Paley, me gustar√≠a compartir con el p√∫blico.</b> <br><a name="habracut"></a><br>  En marzo de 2018, el l√≠der del equipo y yo mantuvimos una reuni√≥n en la que discutimos qu√© hacer a continuaci√≥n: se complet√≥ el c√≥digo de representaci√≥n y no hab√≠a nuevas caracter√≠sticas y efectos especiales en los planes.  Parec√≠a una elecci√≥n l√≥gica reescribir el sistema de part√≠culas desde cero: de acuerdo con todas las pruebas, proporcion√≥ los mayores inconvenientes en productividad, adem√°s de enloquecer a los dise√±adores con su interfaz (archivo de configuraci√≥n de texto) y capacidades extremadamente escasas. <br><br>  Cabe se√±alar que la mayor√≠a de las veces el equipo trabaj√≥ en el juego en el modo "lanzamiento de ma√±ana", as√≠ que escrib√≠ todos los subsistemas, en primer lugar, tratando de no romper lo que ya funciona, y en segundo lugar, con un ciclo de desarrollo corto.  En particular, la mayor√≠a de los efectos de los que el sistema est√°ndar no era capaz se realizaron en el sombreador de fragmentos sin afectar el c√≥digo principal. <br><br>  La restricci√≥n en el n√∫mero de part√≠culas (las matrices de transformaci√≥n para cada part√≠cula se formaron en la CPU, la conclusi√≥n fue a trav√©s del instalador del ios extensible gl), por ejemplo, era necesario escribir un sombreador que "emulara" una gran variedad de part√≠culas en funci√≥n de una representaci√≥n anal√≠tica de la forma de los objetos y combinada con el espacio palma de datos falsos en el b√∫fer de profundidad. <br><br>  La coordenada z del fragmento se calcul√≥ para una part√≠cula plana, como si estuvi√©ramos dibujando una esfera, y el radio de esta esfera fue modulado por el seno del ruido de Perlin teniendo en cuenta el tiempo: <br><br><pre><code class="hljs pgsql">r=<span class="hljs-number"><span class="hljs-number">.5</span></span>+<span class="hljs-number"><span class="hljs-number">.5</span></span>*sin(perlin(specialUV)+<span class="hljs-type"><span class="hljs-type">time</span></span>)</code> </pre> <br>  Se puede encontrar una descripci√≥n completa de la reconstrucci√≥n de la profundidad de la esfera en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√ç√±igo Qu√≠lez</a> , pero utilic√© un c√≥digo simplificado y m√°s r√°pido.  Por supuesto, era una aproximaci√≥n aproximada, pero en formas geom√©tricas complejas (humo, explosiones) dio una imagen bastante decente. <br><br><img src="https://habrastorage.org/webt/tt/un/lw/ttunlwe3v4wj0snsxkjt-drx_fi.png" alt="imagen"><br>  <i>Captura de pantalla del juego.</i>  <i>La "falda" de humo se hizo en una peque√±a parte, varias m√°s quedaron en el cuerpo principal de la explosi√≥n.</i>  <i>Por supuesto, se ve√≠a espectacularmente "desde el suelo", cuando el humo envolvi√≥ suavemente edificios y unidades, sin embargo, las propuestas para cambiar la posici√≥n de la c√°mara durante la explosi√≥n no entraron en producci√≥n.</i> <br><br><h4>  Declaraci√≥n del problema. </h4><br>  ¬øQu√© quer√≠as sacar?  M√°s bien, pasamos de las limitaciones con las que nos atormentaron el sistema de part√≠culas anterior.  La situaci√≥n empeor√≥ por el hecho de que el presupuesto del marco estaba casi agotado, y en dispositivos d√©biles (como el ipad air), las tuber√≠as de p√≠xeles y v√©rtices estaban completamente cargadas.  Por lo tanto, quer√≠a obtener el sistema m√°s productivo como resultado, incluso si limitaba un poco la funcionalidad. <br><br>  Los dise√±adores compilaron una lista de caracter√≠sticas y dibujaron un boceto de la interfaz de usuario basada en su propia experiencia y pr√°ctica con unidad, irreal y efectos posteriores. <br><br><h4>  Tecnolog√≠a disponible </h4><br>  Debido al legado y las restricciones impuestas por la oficina central, est√°bamos limitados a las operaciones 2. Por lo tanto, las tecnolog√≠as como la retroalimentaci√≥n de transformaci√≥n utilizada en los sistemas de part√≠culas modernos no estaban disponibles. <br><br>  Lo que quedaba?  ¬øUsar la b√∫squeda de textura de v√©rtice y almacenar posiciones / aceleraciones en texturas?  Una opci√≥n de trabajo, pero la memoria tambi√©n est√° casi terminada, el rendimiento de una soluci√≥n de este tipo no es el m√°s √≥ptimo y el resultado no es diferente en belleza arquitect√≥nica. <br><br>  En este momento, hab√≠a le√≠do muchos art√≠culos sobre la implementaci√≥n de sistemas de part√≠culas en gpu.  La gran mayor√≠a conten√≠a un t√≠tulo brillante ("millones de part√≠culas en gpu m√≥vil, con preferencia y poetas"), sin embargo, la implementaci√≥n se redujo a ejemplos de emisores / atractores simples, aunque divertidos, y en general fue casi in√∫til para un uso real en el juego. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Este art√≠culo</a> trajo el m√°ximo beneficio: el autor resolvi√≥ el problema real y no hizo "part√≠culas esf√©ricas en el vac√≠o".  Los n√∫meros de referencia de este art√≠culo y los resultados de la creaci√≥n de perfiles ahorraron mucho tiempo en la etapa de dise√±o. <br><br><h4>  Buscar enfoques </h4><br>  Comenc√© clasificando los problemas resueltos por el sistema de part√≠culas y buscando casos particulares.  Result√≥ aproximadamente lo siguiente (una parte de los muelles reales del concepto de la correspondencia con el l√≠der del equipo): <br><blockquote>  "- Conjuntos de part√≠culas / mallas con movimiento c√≠clico.  Sin posici√≥n de procesamiento, todo a trav√©s de la ecuaci√≥n de movimiento.  Aplicaciones: es posible el humo de las tuber√≠as, el vapor sobre el agua, la nieve / lluvia, la niebla volum√©trica, los √°rboles que se balancean, el uso parcial de los efectos no c√≠clicos de las explosiones aka. <br><br>  - Cintas  Formaci√≥n de vb por evento, procesando solo en la GPU (disparos por rayos, vuelos a lo largo de una trayectoria fija (?) Con un rastro).  Tal vez la variante con la transferencia de las coordenadas de inicio-fin a los uniformes y la construcci√≥n de la cinta por vertexID despegue.  con t.z.  renderizar cruz con fresnel como en directlights + uvscroll. <br><br>  - Generaci√≥n de part√≠culas y procesamiento de velocidad.  La opci√≥n m√°s vers√°til y m√°s dif√≠cil / m√°s lenta, vea el procesamiento de movimiento tecnol√≥gico ‚Äù. </blockquote><br>  En resumen: hay diferentes efectos de part√≠culas, y algunos de ellos pueden implementarse m√°s f√°cilmente que otros. <br><br>  Decidimos dividir la tarea en varias iteraciones, de simples a complejas.  La creaci√≥n de prototipos se realiz√≥ en mi motor / editor en windows / directx11 debido al hecho de que la velocidad de dicho desarrollo fue varias veces mayor.  El proyecto se compil√≥ en un par de segundos, y los sombreadores se editaron completamente "sobre la marcha" y se compilaron en segundo plano, mostrando el resultado en tiempo real y sin requerir gestos adicionales como presionar botones.  Creo que cualquiera que haya construido grandes proyectos con un mont√≥n de macbook / xcode entender√° los motivos de esta decisi√≥n. <br><br>  Todos los ejemplos de c√≥digo se tomar√°n del prototipo de Windows. <br><br><img src="https://habrastorage.org/webt/of/p6/pi/ofp6pi_sus1zqlyamxxkb8-zoem.png" alt="imagen"><br>  <i>Entorno de desarrollo para ventanas.</i> <br><br><h4>  Implementaci√≥n </h4><br>  La primera etapa es la salida est√°tica de una matriz de part√≠culas.  Nada complicado: inicie la protecci√≥n de v√©rtices, rellene con quads (escriba el uv correcto para cada quad) y cosa la identificaci√≥n del v√©rtice en el uv "adicional".  Despu√©s de eso, en el sombreador, mediante la identificaci√≥n del v√©rtice en funci√≥n de la configuraci√≥n del emisor, formamos las posiciones de las part√≠culas y, por medio de UV, restauramos las coordenadas de la pantalla. <br><br>  Si vertex_id est√° disponible de forma nativa, puede prescindir completamente de un b√∫fer y sin uv para restaurar las coordenadas de la pantalla (como resultado de lo cual se hizo en la versi√≥n de Windows). <br><br>  Shader: <br><br><pre> <code class="hljs pgsql">struct VS_INPUT { ‚Ä¶ uint v_id:SV_VertexID; ‚Ä¶ } //<span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.uv2.x/<span class="hljs-number"><span class="hljs-number">6.0</span></span>;// vertex_id   <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = floor(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.v_id/<span class="hljs-number"><span class="hljs-number">6.0</span></span>);// vertex_id float2 map[<span class="hljs-number"><span class="hljs-number">6</span></span>]={<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}; float2 quaduv=map[frac(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.v_id/<span class="hljs-number"><span class="hljs-number">6.0</span></span>)*<span class="hljs-number"><span class="hljs-number">6</span></span>];</code> </pre> <br>  Despu√©s de eso, puede implementar escenarios simples con una cantidad muy peque√±a de c√≥digo, por ejemplo, el movimiento c√≠clico con peque√±as desviaciones es adecuado para el efecto de nieve.  Sin embargo, nuestro objetivo era dar el control del comportamiento de las part√≠culas al lado de los artistas, y ellos, como saben, rara vez saben c√≥mo sombrear.  La opci√≥n con valores predeterminados de comportamiento y par√°metros de edici√≥n a trav√©s de los controles deslizantes tampoco result√≥ atractiva: cambiar los sombreadores o bifurcarse en el interior, multiplicar las opciones predeterminadas, falta de control total. <br><br>  La siguiente tarea fue implementar la aparici√≥n y desaparici√≥n gradual de este sistema.  Las part√≠culas no deber√≠an aparecer de la nada y desaparecer en la nada.  En la implementaci√≥n cl√°sica de un sistema de part√≠culas, procesamos el b√∫fer mediante programaci√≥n utilizando CPU, creando nuevas part√≠culas y eliminando las antiguas.  De hecho, para obtener un buen rendimiento, debe escribir un administrador de memoria inteligente.  Pero, ¬øqu√© sucede si simplemente no dibujas las part√≠culas "muertas"? <br><br>  Supongamos (para empezar) que el intervalo de tiempo de emisi√≥n de part√≠culas y la vida √∫til de una part√≠cula es una constante dentro de un solo emisor. <br><br><img src="https://habrastorage.org/webt/96/bp/du/96bpdunpa_v6apnh6gqeoyh-7yq.jpeg" alt="imagen"><br>  Luego podemos presentar especulativamente nuestro b√∫fer (que contiene solo la identificaci√≥n del v√©rtice) como circular y determinar su tama√±o m√°ximo de la siguiente manera: <br><br><pre> <code class="cpp hljs">pCount = round (prtPerSec * LifeTime / <span class="hljs-number"><span class="hljs-number">60.0</span></span>); pCountT = <span class="hljs-built_in"><span class="hljs-built_in">floor</span></span> (prtPerSec * EmissionEndTime / <span class="hljs-number"><span class="hljs-number">60.0</span></span>); pCount=min (pCount, pCountT);</code> </pre> <br>  y en el sombreador, calcule el tiempo en funci√≥n del √≠ndice y el tiempo (tiempo transcurrido desde el inicio del efecto) <br><br><pre> <code class="cpp hljs">pTime=time-index/prtPerSec;</code> </pre> <br>  Si el emisor est√° en una fase c√≠clica (todas las part√≠culas se emiten y ahora mueren y nacen sincr√≥nicamente), hacemos fractura desde el momento de la part√≠cula y, por lo tanto, obtenemos un bucle. <br><br>  No necesitamos dibujar part√≠culas con pTime menor que cero; a√∫n no han nacido.  Lo mismo se aplica a las part√≠culas en las que la suma de la vida √∫til y el tiempo actual excede el tiempo de finalizaci√≥n de la emisi√≥n.  En ambos casos, no dibujaremos nada anulando el tama√±o de part√≠cula y / o coloc√°ndolo detr√°s de la pantalla.  Este enfoque proporcionar√° una peque√±a sobrecarga en las fases de desvanecimiento / desvanecimiento, al tiempo que mantiene el m√°ximo rendimiento en la fase de sostenido. <br><br>  El algoritmo se puede mejorar ligeramente enviando solo esa parte del b√∫fer de v√©rtices que contiene part√≠culas vivas para renderizar.  Debido al hecho de que la emisi√≥n se produce secuencialmente, las part√≠culas vivas se segmentar√°n como m√°ximo una vez, es decir.  Se requieren dos llamadas. <br><br>  Ahora, conociendo el tiempo actual de cada part√≠cula, puede establecer la velocidad, la aceleraci√≥n (y, en general, cualquier otro par√°metro) para escribir la ecuaci√≥n de movimiento, obteniendo finalmente las coordenadas en el espacio mundial. <br><br>  Usando restablecido desde vertex_id uv, ya obtendremos cuatro puntos (m√°s precisamente, moveremos cada uno de los puntos cu√°druples en la direcci√≥n que necesitemos), sobre los cuales el sombreador de v√©rtices, despu√©s de completar la proyecci√≥n, completar√° su trabajo. <br><br><pre> <code class="hljs">p.xy+=(quaduv-.5);</code> </pre><br>  Con la bonificaci√≥n gratuita, tuvimos la oportunidad no solo de pausar el emisor, sino tambi√©n de rebobinar el tiempo de un lado a otro con precisi√≥n en el cuadro.  Esta caracter√≠stica result√≥ ser muy √∫til en el dise√±o de efectos complejos. <br><br><h4>  Aumentamos la funcionalidad </h4><br>  La siguiente iteraci√≥n en el desarrollo fue la soluci√≥n al problema de un emisor en movimiento.  Nuestro sistema en particular no sab√≠a nada acerca de su posici√≥n, y cuando el emisor se movi√≥, todo el efecto se movi√≥ sincr√≥nicamente detr√°s de √©l.  Para el humo del tubo de escape y efectos similares, parec√≠a m√°s que extra√±o. <br><br>  La idea era registrar la posici√≥n del emisor en un buffer de v√©rtices cuando naci√≥ una nueva part√≠cula.  Como el n√∫mero de tales part√≠culas es peque√±o, la sobrecarga deber√≠a haber sido m√≠nima. <br><br>  Un colega sugiri√≥ que al desarrollar su propia interfaz de usuario, usaba map / unmap solo parte del buffer de v√©rtices y estaba bastante satisfecho con el rendimiento de esta soluci√≥n.  Hice pruebas, y result√≥ que este enfoque realmente funciona bien tanto en plataformas de escritorio como m√≥viles. <br><br>  La dificultad surgi√≥ con la sincronizaci√≥n del tiempo en CPU y GPU.  Era necesario asegurarse de que la actualizaci√≥n del b√∫fer se hiciera exactamente cuando la "nueva" part√≠cula en bucle estaba en su posici√≥n inicial.  Es decir, en relaci√≥n con el b√∫fer de anillo, es necesario sincronizar los l√≠mites de la regi√≥n de actualizaci√≥n con el tiempo de funcionamiento del emisor. <br><br>  Transfer√≠ el c√≥digo hlsl a C ++, para la prueba escrib√≠ el emisor movi√©ndose alrededor de Lissajous, y todo esto funcion√≥ de repente.  Sin embargo, de vez en cuando, el sistema "escupi√≥" una o m√°s part√≠culas, dispar√°ndolas en una direcci√≥n arbitraria, sin eliminarlas a tiempo o creando otras nuevas en lugares arbitrarios. <br><br>  El problema se resolvi√≥ auditando la precisi√≥n del c√°lculo del tiempo en el motor y verificando simult√°neamente el delta de tiempo al registrar la nueva posici√≥n del emisor, de modo que se actualizara toda la secci√≥n del b√∫fer que no se vio afectada por la iteraci√≥n anterior.  Tambi√©n era necesario que el sistema funcionara en condiciones de desincronizaci√≥n forzada: una reducci√≥n repentina de fps no deber√≠a romper el efecto, especialmente porque para diferentes dispositivos nuestro juego registr√≥ diferentes fps de acuerdo con el rendimiento: 60/30/20. <br><br>  El c√≥digo del m√©todo ha crecido bastante (el buffer de anillo es dif√≠cil de procesar con elegancia), sin embargo, despu√©s de tener en cuenta todas las condiciones, el sistema funcion√≥ de manera correcta y estable. <br><br>  Alrededor de este tiempo, el socio ya hab√≠a hecho el "pez" del editor, suficiente para probar el sistema, y ‚Äã‚Äãescribi√≥ las plantillas / api para integrar el sistema en nuestro motor. <br><br>  Port√© todo el c√≥digo a ios / opengl, lo integr√© y finalmente realic√© pruebas de efectos reales en un dispositivo real.  Qued√≥ claro que el sistema no solo funciona, sino que tambi√©n es adecuado para la producci√≥n.  Quedaba por terminar el editor de IU y pulir el c√≥digo al estado "no da miedo darlo para que se publique ma√±ana". <br><br>  Incluso nos preparamos para escribir un administrador de memoria para no asignar / destruir un b√∫fer (que finalmente almacenaba vertex_id, uv, posici√≥n y vector de part√≠culas inicial) para cada nuevo efecto con un emisor din√°mico, ya que se me ocurri√≥ otra idea. <br><br>  El hecho de la existencia del b√∫fer de v√©rtices en este sistema me persegu√≠a.  √âl claramente mir√≥ en su arca√≠smo, "el legado de las edades oscuras del transportador fijo".  Al realizar efectos de prueba en un prototipo de Windows, pens√© que el movimiento del emisor siempre es suave y mucho m√°s lento que el movimiento de la part√≠cula.  Adem√°s, con una gran cantidad de part√≠culas, la actualizaci√≥n de la posici√≥n lleva al hecho de que cientos de part√≠culas registran los mismos datos.  La soluci√≥n result√≥ ser simple: presentamos una matriz fija en la que caer√° el "historial" de la posici√≥n del emisor, normalizado por la vida √∫til de la part√≠cula.  Y en gpu interpolaremos los datos.  Despu√©s de eso, la necesidad de b√∫feres din√°micos desapareci√≥ en la versi√≥n ios / gles2 (solo quedaba la est√°tica general para implementar vertex_id), y en las versiones de windows / dx11 los b√∫feres desaparecieron por completo debido al v√©rtice_id nativo y la capacidad de d3d api para aceptar nulo en lugar de vincularse al b√∫fer de v√©rtices. <br><br>  Por lo tanto, la versi√≥n ganadora del sistema, seg√∫n los est√°ndares modernos, no consume memoria en absoluto, sin importar cu√°ntas part√≠culas queramos mostrar.  Solo un peque√±o buffer constante con par√°metros, un buffer de posiciones / bases (60 pares de vectores resultaron ser suficientes, con un margen, en cualquier caso) y, si es necesario, textura.  Las mediciones de rendimiento muestran una velocidad cercana a las pruebas sint√©ticas. <br><br>  Adem√°s, la "cola" en efectos como chispas comenz√≥ a verse mucho m√°s natural, ya que la interpolaci√≥n permiti√≥ eliminar la discretizaci√≥n por cuadros y, por lo tanto, el emisor cambi√≥ su posici√≥n suavemente, como si las llamadas de dibujo se realizaran a una frecuencia de cientos de hercios. <br><br><h4>  Caracteristicas </h4><br>  Adem√°s de la funcionalidad b√°sica del vuelo de la part√≠cula (velocidad, aceleraci√≥n, gravedad, resistencia del medio), necesit√°bamos una cierta cantidad de "grasa" funcional. <br>  Como resultado, el desenfoque de movimiento (estirando una part√≠cula a lo largo de un vector de movimiento), la orientaci√≥n de las part√≠culas a trav√©s del vector de movimiento (esto permite, por ejemplo, hacer una esfera de part√≠culas), redimensionar la part√≠cula de acuerdo con el momento actual de su vida, y se implementaron docenas de otras peque√±as cosas. <br><br>  La complejidad surgi√≥ con los campos vectoriales: dado que el sistema no almacena su estado (posici√≥n, aceleraci√≥n, etc.) para cada part√≠cula, sino que los calcula cada vez a trav√©s de la ecuaci√≥n de movimiento, una serie de efectos (como el movimiento de la espuma cuando se agita el caf√©) eran imposibles en principio.  Sin embargo, una simple modulaci√≥n de la velocidad y la aceleraci√≥n por el ruido de perlin dio resultados que parecen bastante modernos.  El c√°lculo de ruido en tiempo real para tantas part√≠culas result√≥ ser demasiado costoso (incluso con un l√≠mite de cinco octavas), por lo que se gener√≥ una textura a partir de la cual el sombreador de v√©rtices luego tomar√≠a muestras.  Para mejorar el efecto de un campo de vector falso, se agreg√≥ un peque√±o desplazamiento de las coordenadas de la muestra dependiendo del tiempo actual del emisor. <br><br><img src="https://habrastorage.org/webt/sq/vu/xs/sqvuxsyjwxocojucmja_ynqtnjc.png" alt="imagen"><br>  <i>La prueba de humo de cigarrillo funciona mediante la distribuci√≥n de la velocidad inicial y la aceleraci√≥n sobre el ruido perlin.</i> <br><br><h4>  Transportador de p√≠xeles </h4><br>  Inicialmente, solo planeamos cambiar el color / transparencia de la part√≠cula dependiendo de su tiempo.  Agregu√© varios algoritmos al sombreador de p√≠xeles. <br><br>  Rotaci√≥n de color de textura: simplificado, sin (color + tiempo).  Permite en cierta medida imitar el efecto de permutaci√≥n de AfterEffects. <br><br>  Iluminaci√≥n falsa: modulaci√≥n del color de una part√≠cula por un gradiente en coordenadas mundiales, independientemente del √°ngulo de rotaci√≥n de la part√≠cula. <br><br>  Evoluci√≥n de los bordes: cuando una part√≠cula se mueve en el espacio, sus bordes (canal alfa) se modulan mediante una combinaci√≥n de reflector y ruido perlin, lo que proporciona una din√°mica de flujo muy similar a las nubes, el humo y otros efectos de fluidos. <br><br>  Pseudoc√≥digo de sombreador: <br><br><pre> <code class="hljs lisp">b=perlin(<span class="hljs-name"><span class="hljs-name">uv</span></span>)<span class="hljs-comment"><span class="hljs-comment">;// , uv      a=saturate(1-length(input.uv.xy-.5)*2);//     a-=abs(ab);//‚Äù‚Äù,  </span></span></code> </pre> <br>  En una versi√≥n un poco complicada, este sombreador puede dibujar bordes con suavidad arbitraria y con un resaltado de contorno, lo que agrega efectos "explosivos" al realismo. <br><br><img src="https://habrastorage.org/webt/fz/sp/lf/fzsplfbanmnupkdppk2gqj3mlcy.png" alt="imagen"><br>  <i>Los primeros experimentos con la evoluci√≥n de los l√≠mites.</i> <br><br><h4>  Que sigue </h4><br>  A pesar del editor, ya listo para trabajar e integrado en el motor, los dise√±adores no tuvieron tiempo de hacer un solo efecto: el proyecto se cerr√≥.  Sin embargo, no existen obst√°culos para utilizar estas pr√°cticas en otros lugares, por ejemplo, para trabajar en la revisi√≥n de demostraci√≥n. <br><br>  Desde un punto de vista tecnol√≥gico, tambi√©n hay espacio para moverse; ahora, por ejemplo, est√°n en funcionamiento varios efectos de destrucci√≥n de objetos con estructura de alambre: <br><br><img src="https://habrastorage.org/webt/g7/-0/ab/g7-0abs_dlath0s8dxewlrgs1ju.png" alt="imagen"><br><br>  La cuesti√≥n de clasificar las part√≠culas para la mezcla alfa sigue abierta hasta ahora: dado que todo se considera anal√≠ticamente en el sombreador, en realidad no hay datos de entrada para la clasificaci√≥n.  ¬°Pero hay un gran campo para la experimentaci√≥n! <br><br>  Durante el desarrollo de Titan World, se aplicaron muchos trucos en la parte gr√°fica del juego, pero m√°s sobre eso la pr√≥xima vez. <br><br>  PD: puede profundizar en el motor alfa de origen <a href="">aqu√≠</a> .  Los ejemplos est√°n en la carpeta release / samples, las teclas de control principales son espacio, alt | control + mouse.  Los sombreadores se encuentran directamente en los archivos fxp, su c√≥digo est√° disponible a trav√©s de la ventana del editor. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es424995/">https://habr.com/ru/post/es424995/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es424985/index.html">En un importante precedente judicial, las agencias de inteligencia de EE. UU. No pudieron interceptar llamadas telef√≥nicas en el mensajero</a></li>
<li><a href="../es424987/index.html">Recupere im√°genes borrosas y desenfocadas utilizando el filtro Wiener. Implementaci√≥n en C ++ OpenCV</a></li>
<li><a href="../es424989/index.html">Proceso de dise√±o: 7 pasos para el proyecto perfecto</a></li>
<li><a href="../es424991/index.html">Cuando los viejos m√©todos no funcionan: Vasily Mazin - en un enfoque h√≠brido para el desarrollo de IA</a></li>
<li><a href="../es424993/index.html">Pr√°cticas de marketing de productos en Epic Growth Conference</a></li>
<li><a href="../es424997/index.html">‚ÄúLa aplicaci√≥n VKontakte iOS tiene un umbral de entrada alto‚Äù: entrevista con Alexei Savin</a></li>
<li><a href="../es425001/index.html">Validaci√≥n de par√°metros gen√©ricos en controladores Spring</a></li>
<li><a href="../es425003/index.html">Compare las compras de hardware de TCO y los alquileres en la nube</a></li>
<li><a href="../es425005/index.html">Rust News # 1 (septiembre de 2018)</a></li>
<li><a href="../es425007/index.html">Iridium y Jeff Bezos AWS se unieron para desarrollar un proyecto global de Internet satelital IoT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>