<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üå¨Ô∏è üç∑ ‚úäüèæ 3D Game Shader f√ºr Anf√§nger ‚ù§Ô∏è üí´ ‚úñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="M√∂chten Sie lernen, wie Sie Ihrem 3D-Spiel Texturen, Beleuchtung, Schatten, normale Karten, leuchtende Objekte, Umgebungsokklusion und andere Effekte ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>3D Game Shader f√ºr Anf√§nger</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453300/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba2/494/983/ba2494983fe869e14d259f717aa8fc19.gif" alt="Bild"></div><br>  M√∂chten Sie lernen, wie Sie Ihrem 3D-Spiel Texturen, Beleuchtung, Schatten, normale Karten, leuchtende Objekte, Umgebungsokklusion und andere Effekte hinzuf√ºgen k√∂nnen?  Gro√üartig!  Dieser Artikel enth√§lt eine Reihe von Schattierungstechniken, mit denen Sie die Grafik Ihres Spiels auf ein neues Niveau heben k√∂nnen.  Ich erkl√§re jede Technik so, dass Sie diese Informationen auf jeden Werkzeugstapel anwenden / portieren k√∂nnen, sei es Godot, Unity oder etwas anderes. <br><br>  Als ‚ÄûKlebstoff‚Äú zwischen den Shadern habe ich mich f√ºr die gro√üartige Spiel-Engine Panda3D und OpenGL Shading Language (GLSL) entschieden.  Wenn Sie denselben Stapel verwenden, erhalten Sie einen zus√§tzlichen Vorteil: Sie lernen, wie Sie Schattierungstechniken speziell in Panda3D und OpenGL verwenden. <br><a name="habracut"></a><br><h2>  Vorbereitung </h2><br>  Unten ist das System, mit dem ich den Beispielcode entwickelt und getestet habe. <br><br><h3>  Mittwoch </h3><br>  Der Beispielcode wurde in der folgenden Umgebung entwickelt und getestet: <br><br><ul><li>  Linux Manjaro 4.9.135-1-MANJARO </li><li>  OpenGL-Renderer-Zeichenfolge: GeForce GTX 970 / PCIe / SSE2 </li><li>  OpenGL-Versionszeichenfolge: 4.6.0 NVIDIA 410.73 </li><li>  g ++ (GCC) 8.2.1 20180831 </li><li>  Panda3D 1.10.1-1 </li></ul><br><h3>  Material </h3><br>  Jedes der zum Erstellen von <code>mill-scene.egg</code> verwendeten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Blender-</a> Materialien <code>mill-scene.egg</code> √ºber zwei Texturen. <br><br>  Die erste Textur ist eine normale Karte, die zweite ist eine diffuse Karte.  Wenn ein Objekt die Normalen seiner Scheitelpunkte verwendet, wird eine "normale blaue" Normalkarte verwendet.  Aufgrund der Tatsache, dass alle Modelle dieselben Karten an denselben Positionen haben, k√∂nnen Shader verallgemeinert und auf den Wurzelknoten des Szenendiagramms angewendet werden. <br><br>  Beachten Sie, dass das Szenendiagramm eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Funktion</a> der Panda3D-Engine- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Implementierung ist</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19f/9c0/14f/19f9c014f06aee0e2204aa95f87c6306.png"></div><br>  Hier ist eine einfarbige normale Karte, die nur die Farbe enth√§lt <code>[red = 128, green = 128, blue = 255]</code> . <br><br>  Diese Farbe zeigt die Einheitennormale an, die in der positiven Richtung der z-Achse <code>[0, 0, 1]</code> anzeigt. <br><br><pre> <code class="cpp hljs">[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>] = [ round((<span class="hljs-number"><span class="hljs-number">0</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * <span class="hljs-number"><span class="hljs-number">255</span></span>) , round((<span class="hljs-number"><span class="hljs-number">0</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * <span class="hljs-number"><span class="hljs-number">255</span></span>) , round((<span class="hljs-number"><span class="hljs-number">1</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * <span class="hljs-number"><span class="hljs-number">255</span></span>) ] = [<span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>] = [ round(<span class="hljs-number"><span class="hljs-number">128</span></span> / <span class="hljs-number"><span class="hljs-number">255</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) , round(<span class="hljs-number"><span class="hljs-number">128</span></span> / <span class="hljs-number"><span class="hljs-number">255</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) , round(<span class="hljs-number"><span class="hljs-number">255</span></span> / <span class="hljs-number"><span class="hljs-number">255</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) ] = [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre> <br>  Hier sehen wir die Einheitsnormalen <code>[0, 0, 1]</code> die in eine einfache blaue Farbe <code>[128, 128, 255]</code> , und das durchgezogene Blau, das in eine Einheitsnormalen umgewandelt wurde. <br><br>  Dies wird ausf√ºhrlicher im Abschnitt √ºber normale Karten√ºberlagerungstechniken beschrieben. <br><br><h3>  Panda3d </h3><br>  In diesem Codebeispiel wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Panda3D</a> als ‚ÄûKlebstoff‚Äú zwischen den Shadern verwendet.  Dies hat keinen Einfluss auf die unten beschriebenen Techniken. Das hei√üt, Sie k√∂nnen die hier untersuchten Informationen in jedem ausgew√§hlten Stack oder jeder ausgew√§hlten Spiel-Engine verwenden.  Panda3D bietet bestimmte Annehmlichkeiten.  In dem Artikel habe ich √ºber sie gesprochen, sodass Sie entweder ihr Gegenst√ºck in Ihrem Stapel finden oder sie selbst neu erstellen k√∂nnen, wenn sie nicht auf dem Stapel sind. <br><br>  Es ist zu ber√ºcksichtigen, dass <code>gl-coordinate-system default</code> , <code>textures-power-2 down</code> und <code>textures-auto-power-2 1</code> hinzugef√ºgt <code>config.prc</code> .  Sie sind nicht in der Standardkonfiguration von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Panda3D enthalten</a> . <br><br>  Standardm√§√üig verwendet Panda3D ein rechtsh√§ndiges Koordinatensystem mit einer z-Achse nach oben, w√§hrend OpenGL ein rechtsh√§ndiges Koordinatensystem mit einer y-Achse nach oben verwendet. <br><br>  <code>gl-coordinate-system default</code> k√∂nnen Sie Transformationen zwischen zwei Koordinatensystemen in Shadern entfernen. <br><br>  <code>textures-auto-power-2 1</code> erm√∂glicht die Verwendung von Texturgr√∂√üen, die keine Zweierpotenzen sind, wenn das System sie unterst√ºtzt. <br><br>  Dies ist praktisch, wenn Sie SSAO ausf√ºhren oder andere Techniken innerhalb eines Bildschirms / Fensters implementieren, da die Bildschirm- / Fenstergr√∂√üe normalerweise keine Zweierpotenz ist. <br><br>  <code>textures-power-2 down</code> reduziert die Gr√∂√üe von Texturen auf eine Zweierpotenz, wenn das System nur Texturen mit Gr√∂√üen unterst√ºtzt, die Zweierpotenzen entsprechen. <br><br><h2>  Beispielcode erstellen </h2><br>  Wenn Sie den Beispielcode ausf√ºhren m√∂chten, m√ºssen Sie ihn zuerst erstellen. <br><br>  Panda3D l√§uft unter Linux, Mac und Windows. <br><br><h3>  Linux </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Installieren Sie zun√§chst das</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Panda3D SDK</a> f√ºr Ihre Distribution. <br><br>  Finden Sie heraus, wo sich Panda3D-Header und -Bibliotheken befinden.  H√∂chstwahrscheinlich befinden sie sich in <code>/usr/include/panda3d/</code> bzw. in <code>/usr/lib/panda3d/</code> . <br><br>  Klonen Sie dann dieses Repository und navigieren Sie zu seinem Verzeichnis. <br><br> <code>git clone https://github.com/lettier/3d-game-shaders-for-beginners.git <br> cd 3d-game-shaders-for-beginners</code> <br> <br>  Kompilieren Sie nun den Quellcode in eine Ausgabedatei. <br><br> <code>g++ \ <br> -c main.cxx \ <br> -o 3d-game-shaders-for-beginners.o \ <br> -std=gnu++11 \ <br> -O2 \ <br> -I/usr/include/python2.7/ \ <br> -I/usr/include/panda3d/</code> <br> <br>  Erstellen Sie nach dem Erstellen der Ausgabedatei eine ausf√ºhrbare Datei, indem Sie die Ausgabedatei ihren Abh√§ngigkeiten zuordnen. <br><br> <code>g++ \ <br> 3d-game-shaders-for-beginners.o \ <br> -o 3d-game-shaders-for-beginners \ <br> -L/usr/lib/panda3d \ <br> -lp3framework \ <br> -lpanda \ <br> -lpandafx \ <br> -lpandaexpress \ <br> -lp3dtoolconfig \ <br> -lp3dtool \ <br> -lp3pystub \ <br> -lp3direct \ <br> -lpthread</code> <br> <br>  Weitere Informationen finden Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Panda3D-Handbuch</a> . <br><br><h3>  Mac </h3><br>  Beginnen Sie mit der Installation des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Panda3D SDK</a> f√ºr Mac. <br><br>  Finden Sie heraus, wo sich die Header und Bibliotheken von Panda3D befinden. <br><br>  Klonen Sie dann das Repository und navigieren Sie zu seinem Verzeichnis. <br><br> <code>git clone https://github.com/lettier/3d-game-shaders-for-beginners.git <br> cd 3d-game-shaders-for-beginners</code> <br> <br>  Kompilieren Sie nun den Quellcode in eine Ausgabedatei.  Sie m√ºssen herausfinden, wo sich die Include-Verzeichnisse in Python 2.7 und Panda3D befinden. <br><br> <code>clang++ \ <br> -c main.cxx \ <br> -o 3d-game-shaders-for-beginners.o \ <br> -std=gnu++11 \ <br> -g \ <br> -O2 \ <br> -I/usr/include/python2.7/ \ <br> -I/Developer/Panda3D/include/</code> <br> <br>  Erstellen Sie nach dem Erstellen der Ausgabedatei eine ausf√ºhrbare Datei, indem Sie die Ausgabedatei ihren Abh√§ngigkeiten zuordnen. <br><br>  Sie m√ºssen herausfinden, wo sich die Panda3D-Bibliotheken befinden. <br><br> <code>clang++ \ <br> 3d-game-shaders-for-beginners.o \ <br> -o 3d-game-shaders-for-beginners \ <br> -L/Developer/Panda3D/lib \ <br> -lp3framework \ <br> -lpanda \ <br> -lpandafx \ <br> -lpandaexpress \ <br> -lp3dtoolconfig \ <br> -lp3dtool \ <br> -lp3pystub \ <br> -lp3direct \ <br> -lpthread</code> <br> <br>  Weitere Informationen finden Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Panda3D-Handbuch</a> . <br><br><h3>  Windows </h3><br>  Beginnen Sie mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Installation des</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Panda3D SDK</a> f√ºr Windows. <br><br>  Finden Sie heraus, wo sich Panda3D-Header und -Bibliotheken befinden. <br><br>  Klonen Sie dieses Repository und navigieren Sie zu seinem Verzeichnis. <br><br> <code>git clone https://github.com/lettier/3d-game-shaders-for-beginners.git <br> cd 3d-game-shaders-for-beginners</code> <br> <br>  Weitere Informationen finden Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Panda3D-Handbuch</a> . <br><br><h2>  Demo starten </h2><br>  Nach dem Erstellen des Beispielcodes k√∂nnen Sie die ausf√ºhrbare Datei oder Demo ausf√ºhren.  So laufen sie unter Linux oder Mac. <br><br> <code>./3d-game-shaders-for-beginners</code> <br> <br>  Und so laufen sie unter Windows: <br><br> <code>3d-game-shaders-for-beginners.exe</code> <br> <br><h3>  Tastatursteuerung </h3><br>  Die Demo verf√ºgt √ºber eine Tastatursteuerung, mit der Sie die Kamera bewegen und den Status verschiedener Effekte √§ndern k√∂nnen. <br><br><h3>  Bewegung </h3><br><ul><li>  <code>w</code> - tief in die Szene eintauchen. </li><li>  <code>a</code> - Drehen Sie die Szene im Uhrzeigersinn. </li><li>  <code>s</code> - entferne dich von der Szene. </li><li>  <code>d</code> - Drehen Sie die Szene gegen den Uhrzeigersinn. </li></ul><br><h3>  Umschaltbare Effekte </h3><br><ul><li>  <code>y</code> - SSAO aktivieren. </li><li>  <code>Shift</code> + <code>y</code> - SSAO deaktivieren. </li><li>  <code>u</code> - Einbeziehung von Schaltkreisen. </li><li>  <code>Shift</code> + <code>u</code> - Konturen deaktivieren. </li><li>  <code>i</code> - Bl√ºte aktivieren. </li><li>  <code>Shift</code> + <code>i</code> - Bl√ºte deaktivieren. </li><li>  <code>o</code> - Aktivieren Sie normale Karten. </li><li>  <code>Shift</code> + <code>o</code> - normale Karten deaktivieren. </li><li>  <code>p</code> - Einschluss von Nebel. </li><li>  <code>Shift</code> + <code>p</code> - Nebel ausschalten. </li><li>  <code>h</code> - Einbeziehung der Sch√§rfentiefe. </li><li>  <code>Shift</code> + <code>h</code> - Sch√§rfentiefe deaktivieren. </li><li>  <code>j</code> - Posterisierung aktivieren. </li><li>  <code>Shift</code> + <code>j</code> - Posterisierung deaktivieren </li><li>  <code>k</code> - Pixelierung aktivieren. </li><li>  <code>Shift</code> + <code>k</code> - Pixelisierung deaktivieren. </li><li>  <code>l</code> - Sch√§rfen. </li><li>  <code>Shift</code> + <code>l</code> - Sch√§rfe deaktivieren. </li><li>  <code>n</code> Einschluss von Filmkorn. </li><li>  <code>Shift</code> + <code>n</code> - Filmkorn deaktivieren. </li></ul><br><h2>  Referenzsystem </h2><br>  Bevor Sie mit dem Schreiben von Shadern beginnen, m√ºssen Sie sich mit den folgenden Referenzsystemen oder Koordinatensystemen vertraut machen.  Alle von ihnen h√§ngen davon ab, woher die aktuellen Koordinaten des Ursprungs der Referenz stammen <code>(0, 0, 0)</code> .  Sobald wir es herausfinden, k√∂nnen wir sie mithilfe einer Matrix oder eines anderen Vektorraums transformieren.  Wenn die Ausgabe eines Shaders nicht richtig aussieht, liegt die Ursache normalerweise in verwirrten Koordinatensystemen. <br><br><h3>  Modell </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e06/9ce/863/e069ce863ffc7bd3b94394dc20b25687.gif"></div><br>  Das Koordinatensystem des Modells oder Objekts ist relativ zum Ursprung des Modells.  In dreidimensionalen Modellierungsprogrammen, beispielsweise in Blender, wird es normalerweise in der Mitte des Modells platziert. <br><br><h3>  Die Welt </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0a/9de/1f7/d0a9de1f741bb90174efd93d174ef1f9.gif"></div><br>  Der Weltraum ist relativ zum Ursprung der Szene / Ebene / des Universums, die Sie erstellt haben. <br><br><h3>  R√ºckblick </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd2/15b/b6e/bd215bb6ee79a6904eba3f6ad4ff56d3.gif"></div><br>  Der Koordinatenraum der Ansicht ist relativ zur Position der aktiven Kamera. <br><br><h3>  Ausschnitt </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d77/505/a34/d77505a349f37a695f77625400857d58.png"></div><br>  Beschneidungsraum relativ zur Mitte des Kamerarahmens.  Alle darin enthaltenen Koordinaten sind homogen und liegen im Intervall <code>(-1, 1)</code> .  X und y sind parallel zum Kamerafilm und die z-Koordinate ist die Tiefe. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc7/0be/d7c/dc70bed7ca78c39cc9f538b127d7176e.gif"></div><br>  Alle Scheitelpunkte, die nicht innerhalb der Grenzen der Sichtbarkeitspyramide oder des Sichtbarkeitsvolumens der Kamera liegen, werden abgeschnitten oder verworfen.  Wir sehen, wie dies mit einem W√ºrfel geschieht, der von der hinteren Ebene der Kamera abgeschnitten wird, und mit einem W√ºrfel, der sich an der Seite befindet. <br><br><h3>  Bildschirm </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5b/47d/336/e5b47d33660b9c1744faa12fec8ef256.png"></div><br>  Der Bildschirmbereich ist (normalerweise) relativ zur unteren linken Ecke des Bildschirms.  X √§ndert sich von Null auf die Bildschirmbreite.  Y wechselt von Null auf Bildschirmh√∂he. <br><br><h2>  GLSL </h2><br>  Anstatt mit einer Pipeline fester Funktionen zu arbeiten, verwenden wir eine programmierbare GPU-Rendering-Pipeline.  Da es programmierbar ist, m√ºssen wir ihm den Programmcode in Form von Shadern √ºbergeben.  Ein Shader ist ein (normalerweise kleines) Programm, dessen Syntax der C-Sprache √§hnelt. Eine programmierbare GPU-Rendering-Pipeline besteht aus verschiedenen Schritten, die mit Shadern programmiert werden k√∂nnen.  Verschiedene Arten von Shadern umfassen Vertex-Shader, Tessellation-Shader, geometrische Shader, Fragment-Shader und Computer-Shader.  Um die im Artikel beschriebenen Techniken zu verwenden, reicht es aus, Scheitelpunkt und Fragment zu verwenden <br>  Stufen. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 void main() {}</span></span></code> </pre> <br>  Hier ist der minimale GLSL-Shader, bestehend aus der GLSL-Versionsnummer und der Hauptfunktion. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 uniform mat4 p3d_ModelViewProjectionMatrix; in vec4 p3d_Vertex; void main() { gl_Position = p3d_ModelViewProjectionMatrix * p3d_Vertex; }</span></span></code> </pre> <br>  Hier ist der abgeschnittene Scheitelpunkt-Shader GLSL, der den Eingabescheitelpunkt in einen Beschneidungsraum umwandelt und diese neue Position als einheitliche Scheitelpunktposition anzeigt. <br><br>  Die <code>main</code> gibt nichts zur√ºck, da sie <code>void</code> ist und die Variable <code>gl_Position</code> die Inline-Ausgabe ist. <br><br>  Zwei erw√§hnenswerte Schl√ºsselw√∂rter sind: <code>uniform</code> und <code>in</code> . <br><br>  Das <code>uniform</code> Schl√ºsselwort bedeutet, dass diese globale Variable f√ºr alle Scheitelpunkte gleich ist.  Panda3D selbst setzt <code>p3d_ModelViewProjectionMatrix</code> und f√ºr jeden Scheitelpunkt ist es dieselbe Matrix. <br><br>  Das Schl√ºsselwort in bedeutet, dass diese globale Variable an den Shader √ºbergeben wird.  Ein Vertex-Shader ruft jeden Vertex ab, aus dem die Geometrie besteht, an den ein Vertex-Shader angeh√§ngt ist. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 out vec4 fragColor; void main() { fragColor = vec4(0, 1, 0, 1); }</span></span></code> </pre> <br>  Hier ist der zugeschnittene GLSL-Fragment-Shader, der undurchsichtiges Gr√ºn als Farbe des Fragments anzeigt. <br><br>  Vergessen Sie nicht, dass ein Fragment nur ein Bildschirmpixel betrifft, aber mehrere Fragmente ein Pixel betreffen k√∂nnen. <br><br>  Achten Sie auf das Schl√ºsselwort out. <br><br>  Das Schl√ºsselwort <code>out</code> bedeutet, dass diese globale Variable vom Shader festgelegt wird. <br><br>  Der Name <code>fragColor</code> optional, sodass Sie einen anderen ausw√§hlen k√∂nnen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8b4/276/b2d/8b4276b2d7e735cc05484e80e0c046e8.gif"></div><br>  Hier ist die Ausgabe der beiden oben gezeigten Shader. <br><br><h2>  Textur-Rendering </h2><br>  Anstatt direkt auf dem Bildschirm zu rendern / zu zeichnen, verwendet der Beispielcode eine Technik f√ºr <br>  der Name "In Textur rendern" (In Textur rendern).  Um eine Textur zu rendern, m√ºssen Sie den Frame-Puffer konfigurieren und die Textur daran binden.  Sie k√∂nnen mehrere Texturen an einen einzelnen Frame-Puffer binden. <br><br>  Die an den Bildspeicher gebundenen Texturen speichern die vom Fragment-Shader zur√ºckgegebenen Vektoren.  Normalerweise sind diese Vektoren Farbvektoren <code>(r, g, b, a)</code> , aber sie k√∂nnen entweder Positionen oder normale Vektoren <code>(x, y, z, w)</code> .  F√ºr jede gebundene Textur kann ein Fragment-Shader einen separaten Vektor ausgeben.  Zum Beispiel k√∂nnen wir in einem Durchgang die Position und Normalen des Scheitelpunkts ableiten. <br><br>  Der Gro√üteil des Beispielcodes, der mit Panda3D funktioniert, bezieht sich auf das Festlegen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">der Bildspeichertexturen</a> .  Zur Vereinfachung hat jeder Fragment-Shader im Beispielcode nur eine Ausgabe.  Um jedoch eine hohe Bildrate (FPS) zu gew√§hrleisten, m√ºssen wir in jedem Rendering-Durchgang so viele Informationen wie m√∂glich ausgeben. <br><br>  Hier sind zwei Texturstrukturen f√ºr den Bildpuffer aus dem Beispielcode. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ac9/d2b/d50/ac9d2bd50cd1c0bc991ffe7569bf5432.gif"></div><br>  Die erste Struktur rendert eine Wasserm√ºhlenszene unter Verwendung einer Vielzahl von Scheitelpunkt- und Fragment-Shadern in eine Bildpuffertextur.  Diese Struktur verl√§uft mit der M√ºhle und entlang der entsprechenden Fragmente durch jeden der Eckpunkte der B√ºhne. <br><br>  In dieser Struktur funktioniert der Beispielcode wie folgt. <br><br><ul><li>  Speichert Geometriedaten (z. B. Position oder Scheitelpunktnormal) f√ºr die zuk√ºnftige Verwendung. </li><li>  Speichert Materialdaten (z. B. diffuse Farbe) f√ºr die zuk√ºnftige Verwendung. </li><li>  Erzeugt eine UV-Bindung verschiedener Texturen (diffuse, normale Karten, Schattenkarten usw.). </li><li>  Berechnet Umgebungslicht, diffuses, reflektiertes und emittiertes Licht. </li><li>  Macht Nebel. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e5/554/0c2/7e55540c20fe190246f3180b3f06a731.png"></div><br>  Die zweite Struktur ist eine orthogonale Kamera, die auf ein Rechteck in Form eines Bildschirms gerichtet ist. <br>  Diese Struktur durchl√§uft nur vier Peaks und ihre entsprechenden Fragmente. <br><br>  In der zweiten Struktur f√ºhrt der Beispielcode die folgenden Aktionen aus: <br><br><ul><li>  Verarbeitet die Ausgabe einer anderen Bildpuffertextur. </li><li>  Kombiniert verschiedene Frame Buffer Texturen zu einer. </li></ul><br>  Im Codebeispiel sehen wir die Ausgabe einer Frame-Buffer-Textur, wobei der entsprechende Frame auf true und f√ºr alle anderen auf false gesetzt wird. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... bool showPositionBuffer = false; bool showNormalBuffer = false; bool showSsaoBuffer = false; bool showSsaoBlurBuffer = false; bool showMaterialDiffuseBuffer = false; bool showOutlineBuffer = false; bool showBaseBuffer = false; bool showSharpenBuffer = false; bool showBloomBuffer = false; bool showCombineBuffer = false; bool showCombineBlurBuffer = false; bool showDepthOfFieldBuffer = false; bool showPosterizeBuffer = false; bool showPixelizeBuffer = false; bool showFilmGrainBuffer = true; // ...</span></span></code> </pre> <br><h2>  Texturierung </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d1c/0eb/1c6/d1c0eb1c650b9b05e2372b33259ed8a6.gif"></div><br>  Texturierung ist die Bindung einer Farbe oder eines anderen Vektors an ein Fragment unter Verwendung von UV-Koordinaten.  Die Werte von U und V variieren von Null bis Eins.  Jeder Scheitelpunkt erh√§lt eine UV-Koordinate und wird im Scheitelpunkt-Shader angezeigt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/519/487/fee/519487fee2bb16357b225ce32649fb91.png"></div><br>  Der Fragment-Shader erh√§lt die interpolierte UV-Koordinate.  Interpolation bedeutet, dass die UV-Koordinate f√ºr das Fragment irgendwo zwischen den UV-Koordinaten der Eckpunkte liegt, aus denen die Fl√§che des Dreiecks besteht. <br><br><h3>  Vertex-Shader </h3><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 uniform mat4 p3d_ModelViewProjectionMatrix; in vec2 p3d_MultiTexCoord0; in vec4 p3d_Vertex; out vec2 texCoord; void main() { texCoord = p3d_MultiTexCoord0; gl_Position = p3d_ModelViewProjectionMatrix * p3d_Vertex; }</span></span></code> </pre> <br>  Hier sehen wir, dass der Vertex-Shader die Koordinate der Textur an den Fragment-Shader ausgibt.  Beachten Sie, dass dies ein zweidimensionaler Vektor ist: ein Wert f√ºr U und einer f√ºr V. <br><br><h3>  Fragment Shader </h3><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 uniform sampler2D p3d_Texture0; in vec2 texCoord; out vec2 fragColor; void main() { texColor = texture(p3d_Texture0, texCoord); fragColor = texColor; }</span></span></code> </pre> <br>  Hier sehen wir, dass der Fragment-Shader nach der Farbe in seiner UV-Koordinate sucht und diese als Farbe des Fragments anzeigt. <br><br><h4>  Bildschirmf√ºlltextur </h4><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 uniform sampler2D screenSizedTexture; out vec2 fragColor; void main() { vec2 texSize = textureSize(texture, 0).xy; vec2 texCoord = gl_FragCoord.xy / texSize; texColor = texture(screenSizedTexture, texCoord); fragColor = texColor; }</span></span></code> </pre> <br>  Beim Rendern einer Textur ist das Netz ein flaches Rechteck mit demselben Seitenverh√§ltnis wie der Bildschirm.  Daher k√∂nnen wir die UV-Koordinaten nur wissend berechnen <br><br>  A) die Breite und H√∂he der Textur mit der Gr√∂√üe des Bildschirms, der dem Rechteck unter Verwendung von UV-Koordinaten √ºberlagert ist, und <br>  B) die x- und y-Koordinaten des Fragments. <br><br>  Um x an U zu binden, m√ºssen Sie x durch die Breite der eingehenden Textur teilen.  Um y an V zu binden, m√ºssen Sie y durch die H√∂he der eingehenden Textur teilen.  Sie werden sehen, dass diese Technik im Beispielcode verwendet wird. <br><br><h2>  Beleuchtung </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f98/05e/0ca/f9805e0ca9717c961dd9618f49475381.gif"></div><br>  Um die Beleuchtung zu bestimmen, m√ºssen Aspekte der Umgebungsbeleuchtung, der diffusen, reflektierten und emittierten Beleuchtung berechnet und kombiniert werden.  Der Beispielcode verwendet Phong-Beleuchtung. <br><br><h3>  Vertex-Shader </h3><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform struct p3d_LightSourceParameters { vec4 color ; vec4 ambient ; vec4 diffuse ; vec4 specular ; vec4 position ; vec3 spotDirection ; float spotExponent ; float spotCutoff ; float spotCosCutoff ; float constantAttenuation ; float linearAttenuation ; float quadraticAttenuation ; vec3 attenuation ; sampler2DShadow shadowMap ; mat4 shadowViewMatrix ; } p3d_LightSource[NUMBER_OF_LIGHTS]; // ...</span></span></code> </pre><br>  F√ºr jede Lichtquelle mit Ausnahme des Umgebungslichts bietet Panda3D eine praktische Struktur, die sowohl f√ºr Vertex- als auch f√ºr Fragment-Shader verf√ºgbar ist.  Am bequemsten ist eine Schattenkarte und eine Matrix zum Anzeigen von Schatten, um Scheitelpunkte in einen Schatten- oder Beleuchtungsraum umzuwandeln. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vertexPosition = p3d_ModelViewMatrix * p3d_Vertex; // ... for (int i = 0; i &lt; p3d_LightSource.length(); ++i) { vertexInShadowSpaces[i] = p3d_LightSource[i].shadowViewMatrix * vertexPosition; } // ...</span></span></code> </pre> <br>  Beginnend mit dem Vertex-Shader m√ºssen wir den Vertex aus dem Betrachtungsraum in den Schatten- oder Beleuchtungsraum f√ºr jede Lichtquelle in der Szene transformieren und entfernen.  Dies wird sich in Zukunft als n√ºtzlich erweisen, damit der Fragment-Shader Schatten rendern kann.  Ein Schatten- oder Lichtraum ist ein Raum, in dem jede Koordinate relativ zur Position der Lichtquelle ist (der Ursprung ist die Lichtquelle). <br><br><h3>  Fragment Shader </h3><br>  Der Fragment-Shader √ºbernimmt den Gro√üteil der Beleuchtungsberechnung. <br><br><h4>  Material </h4><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform struct { vec4 ambient ; vec4 diffuse ; vec4 emission ; vec3 specular ; float shininess ; } p3d_Material; // ...</span></span></code> </pre> <br>  Panda3D stellt uns Material (in Form einer Struktur) f√ºr das Netz oder Modell zur Verf√ºgung, das wir gerade rendern. <br><br><h4>  Mehrere Lichtquellen </h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 diffuseSpecular = vec4(0.0, 0.0, 0.0, 0.0); // ...</span></span></code> </pre> <br>  Bevor wir uns mit den Beleuchtungsquellen der Szene befassen, erstellen wir ein Laufwerk, das sowohl diffuse als auch reflektierte Farben enth√§lt. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... for (int i = 0; i &lt; p3d_LightSource.length(); ++i) { // ... } // ...</span></span></code> </pre> <br>  Jetzt k√∂nnen wir die Lichtquellen in einem Zyklus umgehen und die diffusen und reflektierten Farben f√ºr jede berechnen. <br><br><h4>  Beleuchtungsbezogene Vektoren </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/307/035/ce7/307035ce7bf5a52b8f25c7aeb862b9d4.gif"></div><br>  Hier sind vier Grundvektoren erforderlich, um die diffusen und reflektierten Farben zu berechnen, die von jeder Lichtquelle eingef√ºhrt werden.  Der Beleuchtungsrichtungsvektor ist ein blauer Pfeil, der auf die Lichtquelle zeigt.  Der normale Vektor ist ein gr√ºner Pfeil, der vertikal nach oben zeigt.  Der Reflexionsvektor ist ein blauer Pfeil, der den Richtungsvektor des Lichts widerspiegelt.  Der Augen- oder Ansichtsvektor ist der orangefarbene Pfeil, der zur Kamera zeigt. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 lightDirection = p3d_LightSource[i].position.xyz - vertexPosition.xyz * p3d_LightSource[i].position.w; // ...</span></span></code> </pre> <br>  Die Beleuchtungsrichtung ist der Vektor von der Scheitelpunktposition zur Position der Lichtquelle. <br><br>  Wenn dies eine gerichtete Beleuchtung ist, setzt Panda3D <code>p3d_LightSource[i].position.w</code> Null.  Richtungsbeleuchtung hat keine Position, nur Richtung.  Wenn dies eine gerichtete Beleuchtung ist, ist die Beleuchtungsrichtung daher eine negative oder entgegengesetzte Richtung zur Quelle, da Panda3D f√ºr eine gerichtete Beleuchtung <code>p3d_LightSource[i].position.xyz</code> auf <code>p3d_LightSource[i].position.xyz</code> . <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... normal = normalize(vertexNormal); // ...</span></span></code> </pre> <br>  Die Normale zum Scheitelpunkt muss ein Einheitsvektor sein.  Die Einheitsvektoren haben einen Wert gleich eins. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 unitLightDirection = normalize(lightDirection); vec3 eyeDirection = normalize(-vertexPosition.xyz); vec3 reflectedDirection = normalize(-reflect(unitLightDirection, normal)); // ...</span></span></code> </pre> <br>  Als n√§chstes brauchen wir drei weitere Vektoren. <br><br>  Wir brauchen ein skalares Produkt unter Beteiligung der Beleuchtungsrichtung, daher ist es besser, es zu normalisieren.  Dies gibt uns einen Abstand oder eine Gr√∂√üe gleich Eins (Einheitsvektor). <br><br>  Die Blickrichtung ist entgegengesetzt zur Position des Scheitelpunkts / Fragments, da die Position des Scheitelpunkts / Fragments relativ zur Position der Kamera ist.  Vergessen Sie nicht, dass sich die Position des Scheitelpunkts / Fragments im Betrachtungsraum befindet.  Anstatt uns von der Kamera (Auge) zum Scheitelpunkt / Fragment zu bewegen, bewegen wir uns daher vom Scheitelpunkt / Fragment zur Kamera (Auge). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Der Reflexionsvektor</a> ist eine Reflexion der Beleuchtungsrichtung senkrecht zur Oberfl√§che.  Wenn der "Lichtstrahl" die Oberfl√§che ber√ºhrt, wird er in demselben Winkel reflektiert, in dem er gefallen ist.  Der Winkel zwischen dem Richtungsvektor der Beleuchtung und der Normalen wird als "Einfallswinkel" bezeichnet.  Der Winkel zwischen dem Reflexionsvektor und der Normalen wird als "Reflexionswinkel" bezeichnet. <br><br>  Sie m√ºssen das Vorzeichen des reflektierten Lichtvektors √§ndern, da dieser in die gleiche Richtung wie der Vektor des Auges zeigen sollte.  Vergessen Sie nicht, dass die Richtung des Auges von der Oberseite / dem Fragment zur Position der Kamera reicht.  Wir werden den Reflexionsvektor verwenden, um die Helligkeit des reflektierten Lichts zu berechnen. <br><br><h4>  Diffuse Beleuchtung </h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float diffuseIntensity = max(dot(normal, unitLightDirection), 0.0); if (diffuseIntensity &gt; 0) { // ... } // ...</span></span></code> </pre> <br>  Die Helligkeit der diffusen Beleuchtung ist das Skalarprodukt der Normalen zur Oberfl√§che und der Beleuchtungsrichtung eines einzelnen Vektors.  Das Skalarprodukt kann von minus eins bis eins reichen.  Wenn beide Vektoren in die gleiche Richtung zeigen, ist die Helligkeit Eins.  In allen anderen F√§llen wird es weniger als die Einheit sein. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/168/5bc/5e7/1685bc5e759e638b5c2bcc4a6c56bbd3.gif"></div><br>  Wenn sich der Beleuchtungsvektor der gleichen Richtung wie normal n√§hert, tendiert die Helligkeit der diffusen Beleuchtung zur Einheit. <br><br>  Wenn die Helligkeit der diffusen Beleuchtung kleiner oder gleich Null ist, m√ºssen Sie zur n√§chsten Lichtquelle gehen. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 diffuse = vec4 ( clamp ( diffuseTex.rgb * p3d_LightSource[i].diffuse.rgb * diffuseIntensity , 0 , 1 ) , 1 ); diffuse.r = clamp(diffuse.r, 0, diffuseTex.r); diffuse.g = clamp(diffuse.g, 0, diffuseTex.g); diffuse.b = clamp(diffuse.b, 0, diffuseTex.b); // ...</span></span></code> </pre> <br>  Jetzt k√∂nnen wir die diffuse Farbe berechnen, die von dieser Quelle eingef√ºhrt wird.  Wenn die Helligkeit der diffusen Beleuchtung eins ist, ist die diffuse Farbe eine Mischung aus der Farbe der diffusen Textur und der Farbe der Beleuchtung.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei jeder anderen Helligkeit ist die diffuse Farbe dunkler. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie, dass ich die diffuse Farbe so beschr√§nke, dass sie nicht heller als die Farbe der diffusen Textur ist. </font><font style="vertical-align: inherit;">Dies verhindert eine √úberbelichtung der Szene.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reflektiertes Licht </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nach diffuser Beleuchtung wird die Reflexion berechnet. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/989/ade/77c/989ade77c01b7137f437f97fe83ccd17.gif"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 specular = clamp ( vec4(p3d_Material.specular, 1) * p3d_LightSource[i].specular * pow ( max(dot(reflectedDirection, eyeDirection), 0) , p3d_Material.shininess ) , 0 , 1 ); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Helligkeit des reflektierten Lichts ist das Skalarprodukt zwischen dem Augenvektor und dem Reflexionsvektor. </font><font style="vertical-align: inherit;">Wie im Fall der Helligkeit von diffusem Licht ist die Helligkeit des reflektierten Lichts gleich Eins, wenn zwei Vektoren in die gleiche Richtung zeigen. </font><font style="vertical-align: inherit;">Jede andere Helligkeit verringert die Menge der von dieser Lichtquelle eingebrachten reflektierten Farbe.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2e/046/570/c2e046570e770e1804544d6ae67ae2f8.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Glanz des Materials bestimmt, wie stark die Beleuchtung des reflektierten Lichts gestreut wird. </font><font style="vertical-align: inherit;">Normalerweise wird es in einem Simulationsprogramm eingestellt, zum Beispiel in Blender. </font><font style="vertical-align: inherit;">In Blender wird es Spiegelh√§rte genannt.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Scheinwerfer </font></font></h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float unitLightDirectionDelta = dot ( normalize(p3d_LightSource[i].spotDirection) , -unitLightDirection ); if (unitLightDirectionDelta &gt;= p3d_LightSource[i].spotCosCutoff) { // ... } // ... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Code erlaubt nicht, dass die Beleuchtung Fragmente au√üerhalb des Scheinwerferkegels oder der Scheinwerferpyramide beeinflusst. Gl√ºcklicherweise kann Panda3D </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definieren</font></font></a> <code>spotDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><code>spotCosCutoff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zur Arbeit mit Richtungs- und Spot - </font><font style="vertical-align: inherit;">Lichtern. Scheinwerfer haben sowohl eine Position als auch eine Richtung. Richtungsbeleuchtung hat jedoch nur Richtung und Punktquellen haben nur Position. Dieser Code funktioniert jedoch f√ºr alle drei Beleuchtungsarten, ohne dass verwirrende if-Anweisungen erforderlich sind.</font></font><br><br><pre> <code class="cpp hljs">spotCosCutoff = cosine(<span class="hljs-number"><span class="hljs-number">0.5</span></span> * spotlightLensFovAngle);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn bei Projektionsbeleuchtung das Skalarprodukt des Vektors "Fragment-Beleuchtungsquelle" und der Richtungsvektor des Projektors kleiner als der Kosinus des halben Winkels des Sichtfelds des </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Projektors ist, ber√ºcksichtigt der Shader den Einfluss dieser Quelle nicht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie, dass Sie das Vorzeichen √§ndern m√ºssen </font></font><code>unitLightDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>unitLightDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">geht vom Fragment zum Suchscheinwerfer, und wir m√ºssen vom Suchscheinwerfer zum Fragment wechseln, da es </font></font><code>spotDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in einem bestimmten Abstand von der Position des Suchscheinwerfers direkt zur Mitte der Pyramide des Suchscheinwerfers geht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei Richtungs- und Spotbeleuchtung setzt Panda3D den </font></font><code>spotCosCutoff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wert auf -1. Denken Sie daran, dass das Skalarprodukt im Bereich von -1 bis 1 variiert. Daher spielt es keine Rolle, was es sein wird </font></font><code>unitLightDirectionDelta</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, da es immer gr√∂√üer oder gleich -1 ist.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... diffuse *= pow(unitLightDirectionDelta, p3d_LightSource[i].spotExponent); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie der Code </font></font><code>unitLightDirectionDelta</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funktioniert auch dieser Code f√ºr alle drei Arten von Lichtquellen. </font><font style="vertical-align: inherit;">Bei Scheinwerfern werden die Fragmente heller, wenn sie sich der Mitte der Scheinwerferpyramide n√§hern. </font><font style="vertical-align: inherit;">F√ºr Richtungs- und Punktlichtquellen </font></font><code>spotExponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist Null. </font><font style="vertical-align: inherit;">Denken Sie daran, dass jeder Wert mit der Potenz Null gleich Eins ist, sodass die diffuse Farbe gleich sich selbst ist, multipliziert mit Eins, das hei√üt, sie √§ndert sich nicht.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schatten </font></font></h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float shadow = textureProj ( p3d_LightSource[i].shadowMap , vertexInShadowSpaces[i] ); diffuse.rgb *= shadow; specular.rgb *= shadow; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panda3D vereinfacht die Verwendung von Schatten, da f√ºr jede Lichtquelle in der Szene eine Schattenkarte und eine Schattentransformationsmatrix erstellt werden. Um selbst eine Transformationsmatrix zu erstellen, m√ºssen Sie eine Matrix sammeln, die die Koordinaten des Betrachtungsraums in den Beleuchtungsraum umwandelt (die Koordinaten sind relativ zur Position der Lichtquelle). Um selbst eine Schattenkarte zu erstellen, m√ºssen Sie die Szene aus Sicht der Lichtquelle in die Bildpuffertextur rendern. Die Bildpuffertextur sollte den Abstand von der Lichtquelle zu den Fragmenten enthalten. Dies wird als "Tiefenkarte" bezeichnet. Schlie√ülich m√ºssen Sie Ihre hausgemachte Tiefenkarte als </font></font><code>uniform sampler2DShadow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und die Schattentransformationsmatrix als </font><font style="vertical-align: inherit;">manuell in den Shader √ºbertragen </font></font><code>uniform mat4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Also werden wir neu erstellen, was Panda3D automatisch f√ºr uns tut.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird das gezeigte Code-Snippet verwendet </font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, das sich von der oben gezeigten Funktion unterscheidet </font></font><code>texture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zuerst teilt </font></font><code>vertexInShadowSpaces[i].xyz</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">durch </font></font><code>vertexInShadowSpaces[i].w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sie verwendet es dann </font></font><code>vertexInShadowSpaces[i].xy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um die in der Schattenkarte gespeicherte Tiefe zu finden. Dann </font></font><code>vertexInShadowSpaces[i].z</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vergleicht sie die Tiefe der Oberseite mit der Tiefe der Schattenkarte in </font></font><code>vertexInShadowSpaces[i].xy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn der Vergleich erfolgreich ist, wird </font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einer zur√ºckgegeben. Andernfalls wird Null zur√ºckgegeben. Null bedeutet, dass sich dieser Scheitelpunkt / Fragment im Schatten befindet, und eins bedeutet, dass sich der Scheitelpunkt / Fragment nicht im Schatten befindet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten </font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie, dass abh√§ngig von der Konfiguration der Schattenkarte auch ein Wert von null bis eins zur√ºckgegeben werden kann. In diesem Beispiel</font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºhrt mehrere Tiefentests basierend auf benachbarten Tiefen durch und gibt einen gewichteten Durchschnitt zur√ºck. </font><font style="vertical-align: inherit;">Dieser gewichtete Durchschnitt kann Schatten glatt machen.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D√§mpfung </font></font></h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/381/e8d/bfb/381e8dbfb118dac85b139d0c1ec41bad.png"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float lightDistance = length(lightDirection); float attenuation = 1 / ( p3d_LightSource[i].constantAttenuation + p3d_LightSource[i].linearAttenuation * lightDistance + p3d_LightSource[i].quadraticAttenuation * (lightDistance * lightDistance) ); diffuse.rgb *= attenuation; specular.rgb *= attenuation; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Abstand zur Lichtquelle ist einfach die Gr√∂√üe oder L√§nge des Beleuchtungsrichtungsvektors. </font><font style="vertical-align: inherit;">Beachten Sie, dass wir nicht die normalisierte Beleuchtungsrichtung verwenden, da ein solcher Abstand gleich Eins w√§re. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Abstand zur Lichtquelle ist erforderlich, um die D√§mpfung zu berechnen. </font><font style="vertical-align: inherit;">D√§mpfung bedeutet, dass die Wirkung von Licht von der Quelle weg abnimmt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameter </font></font><code>constantAttenuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>linearAttenuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>quadraticAttenuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen beliebige Werte festlegen. </font><font style="vertical-align: inherit;">Es sollte mit beginnen </font></font><code>constantAttenuation = 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>linearAttenuation = 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>quadraticAttenuation = 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mit diesen Parametern ist sie in der Position der Lichtquelle gleich Eins und tendiert gegen Null, wenn sie sich von ihr entfernt.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Endg√ºltige Farbbeleuchtung </font></font></h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... diffuseSpecular += (diffuse + specular); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die endg√ºltige Farbe der Beleuchtung zu berechnen, m√ºssen Sie die diffuse und reflektierte Farbe hinzuf√ºgen. </font><font style="vertical-align: inherit;">Dies muss dem Laufwerk in einem Zyklus hinzugef√ºgt werden, in dem die Lichtquellen in der Szene umgangen werden.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Umgebung </font></font></h4><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform sampler2D p3d_Texture1; // ... uniform struct { vec4 ambient ; } p3d_LightModel; // ... in vec2 diffuseCoord; // ... vec4 diffuseTex = texture(p3d_Texture1, diffuseCoord); // ... vec4 ambient = p3d_Material.ambient * p3d_LightModel.ambient * diffuseTex; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Umgebungslichtkomponente im Beleuchtungsmodell basiert auf der Umgebungsfarbe des Materials, der Farbe der Umgebungsbeleuchtung und der Farbe der diffusen Textur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es sollte niemals mehr als eine Umgebungslichtquelle geben, daher sollte diese Berechnung im Gegensatz zu den Berechnungen der f√ºr jede Lichtquelle akkumulierten diffusen und reflektierten Farben nur einmal durchgef√ºhrt werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bitte beachten Sie, dass die Farbe des Umgebungslichts bei der Durchf√ºhrung von SSAO n√ºtzlich ist.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alles zusammenf√ºgen </font></font></h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 outputColor = ambient + diffuseSpecular + p3d_Material.emission; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die endg√ºltige Farbe ist die Summe aus Umgebungsfarbe, diffuser Farbe, reflektierter Farbe und emittierter Farbe. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quellcode </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base.frag</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Normale Karten </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d1/6bb/9de/6d16bb9deae1520429083896b7492a3f.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit normalen Karten k√∂nnen Sie der Oberfl√§che ohne zus√§tzliche Geometrie neue Teile hinzuf√ºgen. </font><font style="vertical-align: inherit;">Wenn Sie in einem 3D-Modellierungsprogramm arbeiten, werden normalerweise High- und Low-Poly-Versionen des Netzes erstellt. </font><font style="vertical-align: inherit;">Dann werden die Normalen der Eckpunkte aus dem Hochpolynetz genommen und in die Textur eingebrannt. </font><font style="vertical-align: inherit;">Diese Textur ist eine normale Karte. </font><font style="vertical-align: inherit;">Dann ersetzen wir im Fragment-Shader die Normalen der Eckpunkte des Low-Poly-Netzes durch die Normalen des High-Poly-Netzes, die in die Normalkarte eingebrannt sind. </font><font style="vertical-align: inherit;">Aus diesem Grund scheint es beim Beleuchten eines Netzes mehr Polygone zu geben, als es tats√§chlich ist. </font><font style="vertical-align: inherit;">Auf diese Weise k√∂nnen Sie hohe FPS beibehalten und gleichzeitig die meisten Details aus der High-Poly-Version √ºbertragen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e1/92b/4ae/8e192b4ae48d96a65b92456ba640c7d0.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hier sehen wir den √úbergang von einem High-Poly-Modell zu einem Low-Poly-Modell und dann zu einem Low-Poly-Modell mit einer √ºberlagerten normalen Karte. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/987/20d/ee1/98720dee1f77246721e1905abf2ebea4.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vergessen Sie jedoch nicht, dass das √úberlagern einer normalen Karte nur eine Illusion ist. </font><font style="vertical-align: inherit;">Ab einem bestimmten Winkel sieht die Oberfl√§che wieder flach aus.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vertex-Shader </font></font></h3><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform mat3 p3d_NormalMatrix; // ... in vec3 p3d_Normal; // ... in vec3 p3d_Binormal; in vec3 p3d_Tangent; // ... vertexNormal = normalize(p3d_NormalMatrix * p3d_Normal); binormal = normalize(p3d_NormalMatrix * p3d_Binormal); tangent = normalize(p3d_NormalMatrix * p3d_Tangent); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beginnend mit dem Vertex-Shader m√ºssen wir den Normalenvektor, den Binormalvektor und den Tangentenvektor an den Fragment-Shader ausgeben. </font><font style="vertical-align: inherit;">Diese Vektoren werden im Fragment-Shader verwendet, um die Normalen der normalen Karte vom Tangentenraum in den Betrachtungsraum zu transformieren. </font></font><br><br> <code>p3d_NormalMatrix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">konvertiert die Normalenvektoren des Scheitelpunkt-, Binormal- und Tangentenvektors in den Betrachtungsraum. </font><font style="vertical-align: inherit;">Vergessen Sie nicht, dass im Betrachtungsraum alle Koordinaten relativ zur Position der Kamera sind.</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[p3d_NormalMatrix] sind die besten 3x3-Reverse-Transponierungselemente von ModelViewMatrix. </font><font style="vertical-align: inherit;">Diese Struktur wird verwendet, um den Normalenvektor in die Koordinaten des Betrachtungsraums umzuwandeln.</font></font><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Quelle</a> </blockquote><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... in vec2 p3d_MultiTexCoord0; // ... out vec2 normalCoord; // ... normalCoord = p3d_MultiTexCoord0; // ...</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b40/f21/575/b40f21575482aa633de61643a1c497aa.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir m√ºssen auch die UV-Koordinaten der normalen Karte an den Fragment-Shader ausgeben. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fragment Shader </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Denken Sie daran, dass die Scheitelpunktnormalen zur Berechnung der Beleuchtung verwendet wurden. </font><font style="vertical-align: inherit;">Um die Beleuchtung zu berechnen, gibt uns die normale Karte jedoch andere Normalen. </font><font style="vertical-align: inherit;">Im Fragment-Shader m√ºssen wir die Normalen der Eckpunkte durch die Normalen in der Normalkarte ersetzen.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform sampler2D p3d_Texture0; // ... in vec2 normalCoord; // ... /* Find */ vec4 normalTex = texture(p3d_Texture0, normalCoord); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unter Verwendung der Koordinaten der vom Vertex-Shader √ºbertragenen Normalkarte extrahieren wir die entsprechende Normalen aus der Karte. </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 normal; // ... /* Unpack */ normal = normalize ( normalTex.rgb * 2.0 - 1.0 ); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oben habe ich gezeigt, wie Normalen in Farben konvertiert werden, um normale Karten zu erstellen. </font><font style="vertical-align: inherit;">Jetzt m√ºssen wir diesen Prozess umkehren, damit wir die urspr√ºnglichen Normalen auf die Karte bringen k√∂nnen.</font></font><br><br><pre> <code class="cpp hljs">[ r, g, b] = [ r * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>, g * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>, b * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>] = [ x, y, z]</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> So sieht das Entpacken von Normalen von der normalen Karte aus. </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... /* Transform */ normal = normalize ( mat3 ( tangent , binormal , vertexNormal ) * normal ); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die aus der Normalkarte erhaltenen Normalen befinden sich normalerweise im Tangentenraum. </font><font style="vertical-align: inherit;">Sie k√∂nnen sich jedoch in einem anderen Raum befinden. </font><font style="vertical-align: inherit;">Mit Blender k√∂nnen Sie beispielsweise Normalen im Tangentenraum, Objektraum, Weltraum und Kameraraum backen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/009/cfc/62c/009cfc62c03b455a1e22b68e8636e735.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Normalen der Normalkarte vom Tangentenraum in den Betrachtungsraum zu √ºbertragen, erstellen Sie eine 3x3-Matrix, die auf dem Tangentenvektor, den binormalen Vektoren und der Scheitelpunktnormalen basiert. </font><font style="vertical-align: inherit;">Multiplizieren Sie die Normalen mit dieser Matrix und normalisieren Sie sie. </font><font style="vertical-align: inherit;">Hier sind wir zu den Normalen gekommen. </font><font style="vertical-align: inherit;">Alle anderen Beleuchtungsberechnungen werden weiterhin durchgef√ºhrt.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quellcode </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base.frag</font></font></a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de453300/">https://habr.com/ru/post/de453300/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de453290/index.html">Data Science Digest (Mai 2019)</a></li>
<li><a href="../de453292/index.html">"Ein kleines Buch √ºber Schwarze L√∂cher"</a></li>
<li><a href="../de453294/index.html">Reagiere Faules Laden</a></li>
<li><a href="../de453296/index.html">Verwalten der Asynchronit√§t in PHP: Von Versprechen zu Coroutinen</a></li>
<li><a href="../de453298/index.html">Sommer: Upgrade-Zeit ... selbst</a></li>
<li><a href="../de453302/index.html">Die erste Lebensstunde mit Yandex.Module</a></li>
<li><a href="../de453304/index.html">Hauptvorteile von Zextras PowerStore</a></li>
<li><a href="../de453306/index.html">Kubernetes wird die Welt √ºbernehmen. Wann und wie?</a></li>
<li><a href="../de453310/index.html">Datenaustausch zwischen React-Komponenten mithilfe der RxJS-Bibliothek</a></li>
<li><a href="../de453312/index.html">PDF Business E-Mail-Generator basierend auf XML-Daten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>