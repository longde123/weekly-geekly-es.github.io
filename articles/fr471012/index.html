<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üàÅ ü§òüèΩ üìò Approche d'ing√©nierie du d√©veloppement logiciel. De la th√©orie √† la pratique üïì üëÑ üôáüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Comment tester des id√©es, l'architecture et les algorithmes sans √©crire de code? Comment formuler et v√©rifier leurs propri√©t√©s? Que sont les v√©rificat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Approche d'ing√©nierie du d√©veloppement logiciel. De la th√©orie √† la pratique</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/471012/"><p> Comment tester des id√©es, l'architecture et les algorithmes sans √©crire de code?  Comment formuler et v√©rifier leurs propri√©t√©s?  Que sont les v√©rificateurs de mod√®les et les chercheurs de mod√®les?  Que faire lorsque les capacit√©s des tests ne sont pas suffisantes? </p><br><p>  Salut  Je m'appelle Vasil Dyadov, maintenant je travaille comme programmeur dans Yandex.Mail, avant de travailler chez Intel, je d√©veloppais le code RTL (niveau de transfert de registre) sur Verilog / VHDL pour ASIC / FPGA encore plus t√¥t.  Je m'int√©resse depuis longtemps au sujet de la fiabilit√© des logiciels et du mat√©riel, des math√©matiques, des outils et des m√©thodes utilis√©s pour d√©velopper des logiciels et de la logique avec des propri√©t√©s pr√©d√©finies garanties. </p><br><p>  Il s'agit du deuxi√®me article d'une s√©rie (le premier article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ), con√ßu pour attirer l'attention des d√©veloppeurs et des gestionnaires sur l'approche d'ing√©nierie du d√©veloppement logiciel.  R√©cemment, il a √©t√© ind√ªment ignor√©, malgr√© des changements r√©volutionnaires dans son approche et ses outils de soutien. </p><a name="habracut"></a><br><p>  Le premier article a sembl√© √† certains lecteurs trop abstrait.  Beaucoup aimeraient voir un exemple d'utilisation d'une approche d'ing√©nierie et de sp√©cifications formelles dans des conditions proches de la r√©alit√©. </p><br><p>  Dans cet article, nous examinerons un exemple d'application r√©elle de TLA + pour r√©soudre un probl√®me pratique. </p><br><p>  Je suis toujours ouvert pour discuter des questions li√©es au d√©veloppement de logiciels, et je serai heureux de discuter avec les lecteurs (les coordonn√©es de communication sont dans mon profil). </p><br><h1 id="chto-takoe-tla">  Qu'est-ce que TLA +? </h1><br><p>  Pour commencer, je voudrais dire quelques mots sur TLA + et TLC. </p><br><p>  TLA + (Logique temporelle des actions + donn√©es) est un formalisme bas√© sur une sorte de logique temporelle.  Con√ßu par Leslie Lamport. </p><br><p>  Dans le cadre de ce formalisme, on peut d√©crire l'espace des variantes de comportement du syst√®me et les propri√©t√©s de ces comportements. </p><br><p>  Pour simplifier, nous pouvons supposer que le comportement du syst√®me est repr√©sent√© par une s√©quence de ses √©tats (comme des perles infinies, des boules sur une cha√Æne), et la formule TLA + d√©finit une classe de cha√Ænes qui d√©crivent toutes les variantes possibles du comportement du syst√®me (un grand nombre de perles). </p><br><p>  TLA + est bien adapt√© pour d√©crire les machines √† √©tats finis non d√©terministes en interaction (par exemple, l'interaction des services dans un syst√®me), bien que son expressivit√© soit suffisante pour d√©crire beaucoup d'autres choses (qui peuvent √™tre exprim√©es dans une logique de premier ordre). </p><br><p>  Et TLC est un v√©rificateur de mod√®le √† √©tat explicite: un programme qui, selon une description de syst√®me TLA + et des formules de propri√©t√© donn√©es, parcourt les √©tats du syst√®me et d√©termine si le syst√®me satisfait les propri√©t√©s sp√©cifi√©es. </p><br><p>  Typiquement, travailler avec TLA + / TLC est construit de cette fa√ßon: nous d√©crivons le syst√®me dans TLA +, formalisons des propri√©t√©s int√©ressantes dans TLA +, ex√©cutons TLC pour v√©rification. </p><br><p>  Puisqu'il n'est pas facile de d√©crire directement un syst√®me plus ou moins complexe dans TLA +, un langage de niveau sup√©rieur a √©t√© invent√© - PlusCal, qui se traduit par TLA +.  PlusCal existe de deux mani√®res: avec Pascal et la syntaxe de type C.  Dans l'article que j'ai utilis√© la syntaxe de type Pascal, il me semble qu'il vaut mieux la lire.  PlusCal par rapport √† TLA + est √† peu pr√®s le m√™me que C par rapport √† l'assembleur. </p><br><p>  Ici, nous n'entrerons pas profond√©ment dans la th√©orie.  La documentation sur l'immersion dans TLA + / PlusCal / TLC est fournie √† la fin de l'article. </p><br><p>  Ma t√¢che principale est de montrer l'application de TLA + / TLC dans un exemple concret simple et compr√©hensible. </p><br><p>  Dans certains commentaires de l'article pr√©c√©dent, on m'a reproch√© de ne pas avoir peint les fondements th√©oriques des outils, mais le but de cette s√©rie d'articles √©tait de montrer l'application pratique des outils pour l'approche d'ing√©nierie dans le d√©veloppement de logiciels. </p><br><p>  Je pense qu'une immersion profonde dans la th√©orie int√©resse peu de monde, mais si vous √™tes int√©ress√©, vous pouvez toujours vous rendre au PM pour des liens et des explications, et pour autant que j'ai suffisamment de connaissances (apr√®s tout, je ne suis pas un math√©maticien th√©orique, mais un ing√©nieur logiciel), je vais essayer de r√©pondre . </p><br><h1 id="postanovka-zadachi">  √ânonc√© du probl√®me </h1><br><p>  Je vais d'abord parler un peu de la t√¢che pour laquelle TLA + a √©t√© utilis√©. </p><br><p>  La t√¢che est li√©e au traitement du flux d'√©v√©nements.  √Ä savoir, pour cr√©er une file d'attente pour stocker des √©v√©nements et envoyer des notifications sur ces √©v√©nements. </p><br><p>  L'entrep√¥t de donn√©es est organis√© physiquement sur la base du SGBD PostgreSQL. </p><br><p>  La principale chose que vous devez savoir: </p><br><ol><li>  Il existe des sources d'√©v√©nements.  Pour nos besoins, nous pouvons nous limiter au fait que chaque √©v√©nement est caract√©ris√© par le temps dans lequel son traitement est planifi√©.  Ces sources √©crivent des √©v√©nements dans la base de donn√©es.  Habituellement, l'heure de l'√©criture dans la base de donn√©es et l'heure du traitement pr√©vu ne sont en aucun cas li√©es. </li><li>  Il existe des processus de coordination qui lisent les √©v√©nements de la base de donn√©es et envoient des notifications d'√©v√©nements √† venir aux composants du syst√®me qui doivent r√©pondre √† ces notifications. </li><li>  Exigence fondamentale: nous ne devons pas perdre d'√©v√©nements.  La notification de l'√©v√©nement dans les cas extr√™mes peut √™tre r√©p√©t√©e, c'est-√†-dire qu'il doit y avoir une garantie <em>au moins une fois</em> .  Dans les syst√®mes distribu√©s, il est extr√™mement difficile de r√©aliser une garantie une <em>seule fois</em> (cela peut m√™me √™tre impossible, mais cela doit √™tre prouv√©) sans m√©canismes de consensus, et ils (au moins tout ce que je sais) ont un effet tr√®s fort sur le syst√®me en termes de retard et de d√©bit. </li></ol><br><p>  Maintenant quelques d√©tails: </p><br><ol><li>  Il existe de nombreux processus sources; ils peuvent g√©n√©rer des millions (dans le pire des cas) d'√©v√©nements tombant dans un intervalle de temps √©troit. </li><li>  Des √©v√©nements peuvent √™tre g√©n√©r√©s √† la fois pour le futur et pour le temps pass√© (par exemple, si le processus source a ralenti et enregistr√© un √©v√©nement pendant un moment qui s'est d√©j√† √©coul√©). </li><li>  La priorit√© du traitement des √©v√©nements est dans le temps, c'est-√†-dire que nous devons d'abord traiter les premiers √©v√©nements. </li><li>  Pour chaque √©v√©nement, le processus source g√©n√®re un nombre al√©atoire <em>worker_id</em> , en raison duquel les √©v√©nements sont r√©partis entre les coordinateurs. </li><li>  Il existe plusieurs processus de coordination (√©chelles en fonction des besoins en fonction de la charge du syst√®me). </li><li>  Chaque processus de coordinateur traite les √©v√©nements pour son propre ensemble <em>worker_id</em> , c'est-√†-dire <em>qu'en</em> raison de <em>worker_id,</em> nous √©vitons la concurrence entre les coordinateurs et le besoin de verrous. </li></ol><br><p>  Comme on peut le voir dans la description, nous ne pouvons consid√©rer qu'un seul processus de coordination et ne pas prendre en compte <em>worker_id</em> dans notre t√¢che. </p><br><p>  Autrement dit, pour simplifier, nous supposons que: </p><br><ol><li>  Il existe de nombreux processus source. </li><li>  Le processus de coordination en est un. </li></ol><br><p>  Je d√©crirai l'√©volution de l'id√©e de r√©soudre ce probl√®me par √©tapes, afin de mieux comprendre comment la pens√©e est pass√©e d'une impl√©mentation simple √† une impl√©mentation optimis√©e. </p><br><h1 id="reshenie-v-lob">  D√©cision frontale </h1><br><p>  Nous allons cr√©er une plaque pour les √©v√©nements o√π nous stockerons les √©v√©nements sous la forme d'un simple <em>horodatage</em> (nous ne sommes pas int√©ress√©s par d'autres param√®tres dans cette t√¢che).  Construisons un index sur le champ d' <em>horodatage</em> . </p><br><p>  Cela semble √™tre une solution parfaitement normale. </p><br><p>  Seulement, il y a un probl√®me d'√©volutivit√©: plus il y a d'√©v√©nements, plus les op√©rations de base de donn√©es sont lentes. </p><br><p>  Les √©v√©nements peuvent venir pour le temps pass√©, donc le coordinateur devra constamment revoir la chronologie enti√®re. </p><br><p>  Le probl√®me peut √™tre r√©solu de mani√®re approfondie en divisant la base de donn√©es en fragments par le temps, etc. Mais c'est un moyen gourmand en ressources. </p><br><p>  En cons√©quence, le travail des coordinateurs ralentira, car vous devrez lire et combiner les donn√©es de plusieurs bases de donn√©es. </p><br><p>  Il est difficile d'impl√©menter la mise en cache des √©v√©nements dans le coordinateur afin de ne pas aller aux bases pour traiter chaque √©v√©nement. </p><br><p>  Plus de bases de donn√©es - plus de probl√®mes de tol√©rance aux pannes. </p><br><p>  Et ainsi de suite. </p><br><p>  Nous ne nous attarderons pas sur cette solution frontale en d√©tail, car elle est triviale et sans int√©r√™t. </p><br><h1 id="pervaya-optimizaciya">  Premi√®re optimisation </h1><br><p>  Voyons comment am√©liorer la solution frontale. </p><br><p>  Pour optimiser l'acc√®s √† la base de donn√©es, vous pouvez compliquer un peu l'index, ajouter un identifiant augmentant de fa√ßon monotone aux √©v√©nements qui seront g√©n√©r√©s lors de la validation d'une transaction dans la base de donn√©es.  Autrement dit, l'√©v√©nement est maintenant caract√©ris√© par la paire <em>{time, id}</em> , o√π <em>time</em> est l'heure √† laquelle l'√©v√©nement est planifi√©, <em>id</em> est un compteur √† augmentation monotone.  Il y a une garantie de l'unicit√© de <em>id</em> pour chaque √©v√©nement, mais il n'y a aucune garantie que les valeurs <em>id</em> vont sans trous (c'est-√†-dire qu'il peut y avoir une telle s√©quence: <em>1</em> , <em>2</em> , <em>7</em> , <em>15</em> ). </p><br><p>  Il semblerait que nous pouvons maintenant stocker l'identifiant du dernier √©v√©nement lu dans le processus de coordination et, lors de la r√©cup√©ration, s√©lectionner des √©v√©nements avec des identifiants sup√©rieurs au dernier √©v√©nement trait√©. </p><br><p>  Mais ici, le probl√®me appara√Æt imm√©diatement: les processus source peuvent enregistrer un √©v√©nement avec un horodatage dans le futur.  Ensuite, nous devrons constamment prendre en compte l'ensemble des √©v√©nements avec de petits identifiants dans le processus de coordination, dont le temps de traitement n'est pas encore arriv√©. </p><br><p>  Vous pouvez remarquer que les √©v√©nements relatifs √† l'heure actuelle sont divis√©s en deux classes: </p><br><ol><li>  √âv√©nements avec un horodatage dans le pass√©, mais avec un grand identifiant.  Ils ont √©t√© √©crits dans la base de donn√©es r√©cemment, apr√®s que nous ayons trait√© cet intervalle de temps.  Ce sont des √©v√©nements hautement prioritaires, et ils doivent √™tre trait√©s en premier afin que la notification - qui est d√©j√† en retard - ne soit m√™me pas en retard. </li><li>  √âv√©nements enregistr√©s une fois avec des horodatages proches de l'instant pr√©sent.  De tels √©v√©nements auront une faible valeur d'identification. </li></ol><br><p>  Par cons√©quent, l'√©tat actuel du processus de coordination est caract√©ris√© par la paire {state.time, state.id}. </p><br><p>  Il s'av√®re que les √©v√©nements de haute priorit√© sont √† gauche et au-dessus de ce point (r√©gion rose), et les √©v√©nements normaux sont √† droite (bleu clair): </p><br><p><img src="https://habrastorage.org/webt/n3/x3/q-/n3x3q-kjbxuerrkffffqqnh6hh8.png"></p><br><h2 id="blok-shema">  Organigramme </h2><br><p>  L'algorithme de travail du coordinateur est le suivant: </p><br><p><img src="https://habrastorage.org/webt/j6/4d/ge/j64dgeq_jubcbyn4e3zu9ekfasy.png"></p><br><p><img src="https://habrastorage.org/webt/8y/ux/si/8yuxsi4nubi7q5yvclqizezo6xq.png"></p><br><p>  Lors de l'√©tude de l'algorithme, des questions peuvent se poser: </p><br><ol><li>  Que se passe-t-il si le traitement des √©v√©nements normaux commence et √† ce moment-l√† de nouveaux √©v√©nements du pass√© arrivent (dans la r√©gion rose), ne seront-ils pas perdus?  R√©ponse: ils seront trait√©s lors du prochain cycle de traitement des √©v√©nements de haute priorit√©.  Ils ne peuvent pas se perdre, car leur <em>identifiant est</em> garanti sup√©rieur √† state.id. </li><li>  Que se passe-t-il si apr√®s le traitement de tous les √©v√©nements normaux - au moment du passage au traitement des √©v√©nements de haute priorit√© - de nouveaux √©v√©nements avec des horodatages de l'intervalle [state.time, state.time + Delta] arrivent, les perdons-nous?  R√©ponse: ils tomberont dans la zone rose, car ils auront le <em>temps</em> &lt;state.time and <em>id</em> &gt; state.id: ils sont arriv√©s r√©cemment et <em>id</em> augmente de fa√ßon monotone. </li></ol><br><h2 id="primer-raboty-algoritma">  Exemple de fonctionnement d'algorithme </h2><br><p>  Regardons quelques √©tapes de l'algorithme: </p><br><p><img src="https://habrastorage.org/webt/jl/lf/5v/jllf5vhoz843at6gfrtmjmasppw.png"></p><br><p><img src="https://habrastorage.org/webt/z-/ri/zx/z-rizxhocuxtepr7_wnflvgqm14.png"></p><br><p><img src="https://habrastorage.org/webt/oc/dr/pv/ocdrpv4ozmf-pq_itridvcjookc.png"></p><br><p><img src="https://habrastorage.org/webt/uv/xt/aw/uvxtawqbs5ftd8uzebcwqosdrvw.png"></p><br><p><img src="https://habrastorage.org/webt/uo/_s/cg/uo_scglk7ucb_yze8he8b___wro.png"></p><br><p><img src="https://habrastorage.org/webt/ko/8q/24/ko8q24qizzqz5ddew4jbodavvts.png"></p><br><p><img src="https://habrastorage.org/webt/iw/-f/el/iw-felnslp1mdme-thbu_nicbly.png"></p><br><p><img src="https://habrastorage.org/webt/vf/vs/tz/vfvstz05jy9aowpndr-okgajxpk.png"></p><br><h2 id="model">  Mod√®le </h2><br><p>  Nous veillerons √† ce que l'algorithme ne manque pas d'√©v√©nements et toutes les notifications seront envoy√©es: nous composerons un mod√®le simple et le v√©rifierons. </p><br><p>  Pour le mod√®le, nous utilisons TLA +, plus pr√©cis√©ment PlusCal, qui se traduit par TLA +. </p><br><pre><code class="plaintext hljs">---------------- MODULE events ---------------- EXTENDS Naturals, FiniteSets, Sequences, TLC (* --algorithm Events \*      \*   (by Daniel Jackson) \* small-scope hypothesis,   \*  ,  ÃÅ   \*     \*   \*  : \* Events -   - ,   \*    [time, id], \*     \*      \*   \* Event_Id -    \*   id \* MAX_TIME -  ,   \*   \* TIME_DELTA -   Delta, \*     \*  variables Events = {}, Event_Id = 0, MAX_TIME = 5, TIME_DELTA \in 1..3 define \*   \*   ZERO_EVT == [time |-&gt; 0, id |-&gt; 0] MAX(S) == CHOOSE x \in S: \A y \in S: y &lt;= x MIN(S) == CHOOSE x \in S: \A y \in S: y &gt;= x \*  fold_left/fold_right    RECURSIVE SetReduce(_, _, _) SetReduce(Op(_, _), S, value) == IF S = {} THEN value ELSE LET s == CHOOSE s \in S : TRUE IN SetReduce(Op, S \ {s}, Op(s, value)) (*     (  ) *) ToSeq(S) == LET op(e, val) == Append(val, e) IN SetReduce(op, S, &lt;&lt; &gt;&gt;) (* :    *) ToSet(S) == {S[i] : i \in DOMAIN(S)} (*  map    *) MapSet(Op(_), S) == {Op(x) : x \in S} (*   *) \*   id  GetIds(Evts) == MapSet(LAMBDA x: x.id, Evts) \*   time  GetTimes(Evts) == MapSet(LAMBDA x: x.time, Evts) (*   SQL  *) \*     \*   ORDER BY EventsOrderByTime(e1, e2) == e1.time &lt; e2.time EventsOrderById(e1, e2) == e1.id &lt; e2.id EventsOrder(e1, e2) == \*   time, id \/ EventsOrderByTime(e1, e2) \/ /\ e1.time = e2.time /\ EventsOrderById(e1, e2) \* SELECT * FROM events \* WHERE time &lt;= curr_time AND id &gt;= max_id \* ORDER BY time, id SELECT_HIGH_PRIO(state) == LET \*      \* time &lt;= curr_time \* AND id &gt;= maxt_id selected == {e \in Events : /\ e.time &lt;= state.time /\ e.id &gt;= state.id } IN selected \* SELECT * FROM events \* WHERE time &gt; current_time AND time - Time &lt;= delta_time \* ORDER BY time, id SELECT_NORMAL(state, delta_time) == LET selected == {e \in Events : /\ e.time &lt;= state.time + delta_time /\ e.time &gt; state.time } IN selected \* Safety predicate \*       ALL_EVENTS_PROCESSED(state) == \A e \in Events: \/ e.time &gt;= state.time \/ e.id &gt;= state.id end define; \*  -   fair process inserter = "Sources" variable n, t; begin forever: while TRUE do \*      get_time: \*     \* ,     , \*    with evt_time \in 0..MAX_TIME do t := evt_time; end with; \*     ; \*   : \* 1.   . \* 2.  ,    \* Event_Id -   , \*     commit: \* either -     either Events := Events \cup {[time |-&gt; t, id |-&gt; Event_Id]} || Event_Id := Event_Id + 1; or Event_Id := Event_Id + 1; end either; end while; end process fair process coordinator = "Coordinator" variable state = ZERO_EVT, events = {}; begin forever: while TRUE do \*    high_prio: events := SELECT_HIGH_PRIO(state); \*   process_high_prio: \*          , \*    Events, \*       state.id := MAX({state.id} \union GetIds(events)) || \*      , \*      Events := Events \ events || \*  events  , \*      events := {}; \*  -   normal: events := SELECT_NORMAL(state, TIME_DELTA); process_normal: state.time := MAX({state.time} \union GetTimes(events)) || Events := Events \ events || events := {}; end while; end process end algorithm; *) \* BEGIN TRANSLATION \*  TLA+,     PlusCal  \* END TRANSLATION ================================</code> </pre> <br><p>  Comme vous pouvez le voir, la description est relativement petite, malgr√© la section assez volumineuse des d√©finitions (d√©finir), qui pourrait √™tre extraite dans un module s√©par√©, puis r√©utilis√©e. </p><br><p>  Dans les commentaires, j'ai essay√© d'expliquer ce qui se passe dans le mod√®le.  J'esp√®re que √ßa <br>  J'ai r√©ussi et il n'est pas n√©cessaire de peindre le mod√®le plus en d√©tail. </p><br><p>  Je voudrais seulement clarifier un point concernant l'atomicit√© des transitions entre les √©tats et les caract√©ristiques de mod√©lisation. </p><br><p>  La mod√©lisation est r√©alis√©e en effectuant des √©tapes atomiques de processus.  Dans une transition, une √©tape atomique d'un processus est effectu√©e au cours de laquelle cette √©tape peut √™tre effectu√©e.  Le choix de l'√©tape et du processus est non d√©terministe: lors de la mod√©lisation, toutes les cha√Ænes possibles d'√©tapes atomiques de tous les processus sont tri√©es. </p><br><p>  La question peut se poser: qu'en est-il de la mod√©lisation du vrai parall√©lisme, lorsque nous r√©alisons simultan√©ment plusieurs √©tapes atomiques dans des processus diff√©rents? </p><br><p>  Cette question, Leslie Lamport a longtemps √©t√© r√©pondu dans le livre Specifying Systems et d'autres travaux. </p><br><p>  Je ne citerai pas compl√®tement la r√©ponse, en bref, l'essentiel est le suivant: s'il n'y a pas d'√©chelle de temps exacte o√π chaque √©v√©nement est li√© √† un moment sp√©cifique, il n'y a pas de diff√©rence dans la mod√©lisation des √©v√©nements parall√®les comme des √©v√©nements s√©quentiels non d√©terministes, car nous pouvons toujours supposer qu'un √©v√©nement s'est produit plus t√¥t qu'un autre valeur infinit√©simale. </p><br><p>  Mais ce qui est vraiment important, c'est l'allocation comp√©tente des √©tapes atomiques.  S'il y en a trop, une explosion combinatoire de l'espace d'√©tat se produira.  Si vous prenez moins de mesures que n√©cessaire ou si vous les s√©lectionnez incorrectement, c'est-√†-dire la probabilit√© de manquer un √©tat / une transition non valide (c'est-√†-dire que nous manquerons les erreurs sur le mod√®le). </p><br><p>  Afin de d√©composer correctement les processus en √©tapes atomiques, vous devez avoir une bonne id√©e du fonctionnement du syst√®me en termes de d√©pendance des processus vis-√†-vis des donn√©es et des m√©canismes de synchronisation. </p><br><p>  En r√®gle g√©n√©rale, la division des processus en √©tapes atomiques ne pose pas de gros probl√®mes.  Et si c'est le cas, cela indique plut√¥t un manque de compr√©hension du probl√®me, et non des probl√®mes de compilation du mod√®le et d'√©criture de la sp√©cification TLA +.  C'est une autre caract√©ristique tr√®s utile des sp√©cifications formelles: elles n√©cessitent une √©tude et une analyse approfondies. <br>  un probl√®me.  En r√®gle g√©n√©rale, si la t√¢che est significative et bien comprise, sa formalisation ne pose aucun probl√®me. </p><br><h2 id="proverka-modeli">  V√©rification du mod√®le </h2><br><p>  Pour la mod√©lisation, j'utiliserai la bo√Æte √† outils TLA.  Vous pouvez bien s√ªr tout ex√©cuter √† partir de la ligne de commande, mais l' <em>EDI</em> est encore plus pratique, en particulier pour commencer √† apprendre la mod√©lisation √† l'aide de TLA +. </p><br><p>  La cr√©ation du projet est bien d√©crite dans les manuels, articles et livres, les liens vers lesquels j'ai cit√© √† la fin de l'article, donc je ne vais pas me r√©p√©ter.  La seule chose sur laquelle j'attirerai votre attention est les param√®tres de simulation. </p><br><p>  TLC est un <em>v√©rificateur de mod√®le</em> avec <em>v√©rification</em> explicite de l'√©tat.  Il est clair que l'espace √©tatique doit √™tre limit√© par des limites raisonnables.  D'une part, elle doit √™tre suffisamment grande pour pouvoir v√©rifier les propri√©t√©s qui nous int√©ressent, et d'autre part, suffisamment petite pour que la simulation soit r√©alis√©e dans un d√©lai raisonnable en utilisant des ressources acceptables. </p><br><p>  C'est un point assez d√©licat, ici vous devez comprendre les propri√©t√©s du syst√®me et du mod√®le.  Mais cela vient rapidement avec l'exp√©rience.  Pour commencer, vous pouvez simplement d√©finir les limites maximales possibles qui sont toujours acceptables en termes de temps de simulation et de ressources consomm√©es. </p><br><p>  Il existe √©galement un mode de v√©rification non pas de la totalit√© de l'espace d'√©tat, mais de cha√Ænes s√©lectives jusqu'√† une certaine profondeur.  Il est √©galement parfois possible et n√©cessaire de l'utiliser. </p><br><p>  Nous revenons aux param√®tres de simulation. </p><br><p>  Tout d'abord, nous d√©finissons les restrictions sur l'espace d'√©tat du syst√®me.  Les limites sont d√©finies dans la section Param√®tres de simulation <em>Options avanc√©es / Contrainte d'√©tat</em> . </p><br><p>  L√†, j'ai indiqu√© une expression TLA +: <code>Cardinality(Events) &lt;= 5 /\ Event_Id &lt;= 5</code> , <br>  o√π Event_Id est la limite sup√©rieure de la valeur de l'identificateur d'√©v√©nement, <code>Cardinality(Events)</code> est la taille de l'ensemble des enregistrements d'√©v√©nements (limit√© le mod√®le de base <br>  donn√©es par cinq enregistrements dans une plaque). </p><br><p>  Dans la simulation, la CCM ne regardera que les √©tats dans lesquels cette formule est vraie. </p><br><p>  Vous pouvez toujours autoriser des transitions d'√©tat valides ( <em>Options avanc√©es / Contrainte d'action</em> ), <br>  mais nous n'en avons pas besoin. </p><br><p>  Ensuite, nous indiquons la formule TLA + qui d√©crit notre syst√®me: <em>Pr√©sentation du mod√®le / Formule temporelle</em> = <code>Spec</code> , o√π <em>Spec</em> est le nom de la formule TLA + g√©n√©r√©e automatiquement par PlusCal (dans le code du mod√®le ci-dessus, ce n'est pas: pour √©conomiser de l'espace, je n'ai pas cit√© le r√©sultat de la traduction de PlusCal en TLA +) . </p><br><p>  Le prochain param√®tre √† surveiller est le contr√¥le de l'impasse. <br>  (coche dans <em>Aper√ßu du mod√®le / Blocage</em> ).  Lorsque ce drapeau est activ√©, le TLC v√©rifie le mod√®le pour les √©tats ¬´suspendus¬ª, c'est-√†-dire ceux dont il n'y a pas de transitions sortantes.  S'il y a de tels √©tats dans l'espace d'√©tats, cela signifie une erreur claire dans le mod√®le.  Ou dans TLC, qui, comme tout autre programme non trivial, n'est pas √† l'abri des erreurs :) Dans ma pratique (pas si grande), je n'ai pas encore rencontr√© de blocages. </p><br><p>  Et enfin, pour le bien de tous ces tests, la formule de s√©curit√© dans <em>Model Overview / Invariants</em> = <code>ALL_EVENTS_PROCESSED(state)</code> . </p><br><p>  TLC v√©rifiera la validit√© de la formule dans chaque √©tat, et si elle devient fausse, <br>  affichera un message d'erreur et montrera la s√©quence des √©tats qui ont conduit √† l'erreur. </p><br><p>  Apr√®s avoir d√©marr√© TLC, apr√®s avoir travaill√© pendant environ 8 minutes, il a signal√© "Aucune erreur".  Cela signifie que le mod√®le est test√© et r√©pond aux propri√©t√©s sp√©cifi√©es. </p><br><p>  TLC affiche √©galement de nombreuses statistiques int√©ressantes.  Par exemple, pour ce mod√®le, 7 677 824 √©tats uniques ont √©t√© obtenus; au total, le TLC a examin√© 27 109 029 √©tats, le diam√®tre de l'espace d'√©tats est de 47 (il s'agit de la longueur maximale de la cha√Æne d'√©tats avant r√©p√©tition, <br>  longueur de cycle maximale √† partir d'√©tats non r√©p√©titifs dans le graphique d'√©tat et de transition). </p><br><p>  Si nous divisons 27 millions d'√©tats en 8 minutes, nous obtenons environ 56 000 √©tats par seconde, ce qui peut ne pas sembler tr√®s rapide.  Mais gardez √† l'esprit que j'ai ex√©cut√© la simulation sur un ordinateur portable qui fonctionnait en mode d'√©conomie d'√©nergie (j'ai forc√© la fr√©quence centrale √† 800 MHz, parce que je conduisais √† ce moment-l√† dans le train), et n'ai pas optimis√© du tout le mod√®le pour la vitesse de simulation. </p><br><p>  Il existe de nombreuses fa√ßons d'acc√©l√©rer la simulation: du portage d'une partie du code du mod√®le TLA + √† Java et √† la connexion √† TLC √† la vol√©e (il est utile d'acc√©l√©rer toutes sortes de fonctions d'assistance) √† l'ex√©cution de TLC dans les nuages ‚Äã‚Äãet sur les clusters (la prise en charge d'Amazon et Azure est int√©gr√©e directement dans TLC lui-m√™me). </p><br><h1 id="vtoraya-optimizaciya">  Deuxi√®me optimisation </h1><br><p>  Dans l'algorithme pr√©c√©dent, tout va bien, √† l'exception de quelques probl√®mes: </p><br><ol><li>  Tant que nous n'avons pas trait√© tous les √©v√©nements de la zone bleue dans l'intervalle <code>[state.time, state.time + Delta]</code> , nous ne pouvons pas passer aux √©v√©nements de haute priorit√©.  Autrement dit, les √©v√©nements tardifs seront encore plus tard.  Et g√©n√©ralement, le retard est impr√©visible.  Pour cette raison, state.time peut √™tre loin derri√®re l'heure actuelle, et c'est la cause du probl√®me suivant. </li><li>  Les √©v√©nements arrivant dans la r√©gion des √©v√©nements normaux peuvent √™tre en retard ( <em>id</em> &gt; state.id).  Ils sont d√©j√† hautement prioritaires et doivent √™tre consid√©r√©s comme des √©v√©nements de la r√©gion rose, et nous les consid√©rons toujours comme normaux et les traitons comme normaux. </li><li>  Il est difficile d'organiser la mise en cache des √©v√©nements et le r√©approvisionnement du cache (lecture √† partir de la base de donn√©es). </li></ol><br><p>  Si les deux premiers points sont √©vidents, le troisi√®me soul√®vera probablement le plus de questions.  Arr√™tons-nous dessus plus en d√©tail. </p><br><p>  Supposons que nous voulons d'abord lire un nombre fixe d'√©v√©nements en m√©moire, puis les traiter. </p><br><p>  Apr√®s le traitement, nous voulons marquer les √©v√©nements dans la base de donn√©es avec des requ√™tes de bloc comme trait√©s, car si vous ne travaillez pas avec des blocs, mais avec des √©v√©nements uniques, il n'y aura pas de gros gain √† partir de la mise en cache. </p><br><p>  Supposons que nous ayons trait√© une partie des blocs et voulons compl√©ter le cache.  Ensuite, si des √©v√©nements tardifs de haute priorit√© arrivent pendant le traitement, nous pouvons les traiter t√¥t. </p><br><p>  Autrement dit, il est tr√®s souhaitable de pouvoir lire les √©v√©nements en petits blocs afin de traiter les plus tard le plus rapidement possible, mais de mettre √† jour l'attribut de traitement dans la base de donn√©es avec de gros blocs √† la fois - pour plus d'efficacit√©. </p><br><p>  Que faire dans ce cas? </p><br><p>  Essayez de travailler avec la base de donn√©es en petits blocs avec une zone bleue et rose et d√©placez le point d'√©tat par petites √©tapes. </p><br><p>  Ainsi, le cache a √©t√© introduit et lu √† partir des √©l√©ments de donn√©es de la base de donn√©es, apr√®s chaque lecture, le point d'√©tat a √©t√© d√©cal√© afin de ne pas relire les √©v√©nements d√©j√† lus. </p><br><p>  Maintenant que l'algorithme est devenu un peu plus compliqu√©, nous avons commenc√© √† lire en portions limit√©es. </p><br><h2 id="blok-shema-1">  Organigramme </h2><br><p><img src="https://habrastorage.org/webt/as/8n/qk/as8nqk0dmos8bsiwiigzphb7gns.png"></p><br><p><img src="https://habrastorage.org/webt/wn/9x/yx/wn9xyxfi4j2021hibcqxe3abhn8.png"></p><br><p>  Dans cet algorithme, on peut voir qu'en raison de la restriction sur les blocs d'√©v√©nements lisibles, le retard maximum dans la transition du traitement de faible priorit√© au traitement de haute priorit√© sera √©gal au temps de traitement maximal du bloc. </p><br><p>  Autrement dit, nous pouvons maintenant √† la fois lire les √©v√©nements dans le cache en petits blocs et contr√¥ler le retard maximal dans la transition vers le traitement des √©v√©nements de haute priorit√© en contr√¥lant la taille maximale des blocs pour la lecture. </p><br><h2 id="primer-raboty-algoritma-1">  Exemple de fonctionnement d'algorithme </h2><br><p>  Regardons l'algorithme en cours, par √©tapes.  Pour plus de commodit√©, prenez <code>LIMIT = 2</code> . </p><br><p><img src="https://habrastorage.org/webt/-i/u8/qz/-iu8qzxfabbn9gcig_ekb1xhabu.png"></p><br><p><img src="https://habrastorage.org/webt/3x/if/ju/3xifju7ktzac6eyyutbhfanpufs.png"></p><br><p><img src="https://habrastorage.org/webt/ab/dg/o7/abdgo7ieinh8ddx6tnthfcsrwre.png"></p><br><p><img src="https://habrastorage.org/webt/ei/qg/al/eiqgal0lfwfiwtdltnb-e1bjyc0.png"></p><br><p><img src="https://habrastorage.org/webt/hp/2i/kd/hp2ikd4mgcqsswoiwwexz_kmp-e.png"></p><br><p><img src="https://habrastorage.org/webt/tq/ct/fv/tqctfvtnrqo939zqut2-8lwjale.png"></p><br><p><img src="https://habrastorage.org/webt/yk/3j/jk/yk3jjkf9htxfmdvwsa1dyrogqqo.png"></p><br><p><img src="https://habrastorage.org/webt/ym/9d/vt/ym9dvt1_ykho82n4xhxwtlbkeow.png"></p><br><p>  Il s'av√®re que le probl√®me est r√©solu?  Mais non.  (Il est clair que si le probl√®me a √©t√© compl√®tement r√©solu √† ce stade, alors <br>  cet article n'aurait pas √©t√© :)) </p><br><h2 id="oshibka">  L'erreur? </h2><br><p>  Sous cette forme, l'algorithme a fonctionn√© assez longtemps.  Les tests se sont tous bien d√©roul√©s.  Aucun probl√®me de production non plus. </p><br><p>  Mais le d√©veloppeur de l'algorithme et de son impl√©mentation (mon coll√®gue Peter Reznikov) est tr√®s exp√©riment√©, et il a intuitivement senti que quelque chose n'allait pas ici.  Par cons√©quent, un v√©rificateur a √©t√© fait √† c√¥t√© du code principal, qui v√©rifiait de temps en temps sur une minuterie pour voir s'il y avait des √©v√©nements manqu√©s, et <br>  le cas √©ch√©ant, je les ai trait√©s. </p><br><p>  Sous cette forme, le syst√®me a fonctionn√© avec succ√®s.  Certes, personne n'a conserv√© de statistiques sur le nombre d'√©v√©nements s√©lectionn√©s par le v√©rificateur.  Donc, malheureusement, nous ne savons pas combien d'√©checs ont √©t√© associ√©s √† un traitement d'√©v√©nement intempestif. </p><br><p>  J'ai impl√©ment√© une file d'attente similaire d'objets limit√©s dans le temps.  En discutant de la mise en ≈ìuvre et de l'optimisation des algorithmes avec Peter Reznikov, nous avons parl√© de cet algorithme pour travailler avec des √©v√©nements.  Ils doutaient que l'algorithme soit correct.  Nous avons d√©cid√© de faire un petit mod√®le pour confirmer ou dissiper les doutes.  En cons√©quence, nous avons trouv√© une erreur. </p><br><h2 id="model-1">  Mod√®le </h2><br><p>  Avant de d√©monter la trace avec une erreur, je donnerai le code source du mod√®le sur lequel l'erreur a √©t√© d√©tect√©e. </p><br><p>  Les diff√©rences par rapport au mod√®le pr√©c√©dent sont tr√®s faibles, il n'y a qu'une limite sur la taille des blocs lus: l'op√©rateur Limit est ajout√© et, en cons√©quence, les op√©rateurs de s√©lection d'√©v√©nement sont modifi√©s. </p><br><p>  Pour √©conomiser de l'espace, j'ai laiss√© des commentaires uniquement sur les parties modifi√©es du mod√®le. </p><br><pre> <code class="plaintext hljs">---------------- MODULE events ---------------- EXTENDS Naturals, FiniteSets, Sequences, TLC (* --algorithm Events \*    LIMIT, \*     \*     \*   variables Events = {}, Event_Id = 0, MAX_TIME = 5, LIMIT \in 1..3, TIME_DELTA \in 1..2 define ZERO_EVT == [time |-&gt; 0, id |-&gt; 0] MAX(S) == CHOOSE x \in S: \A y \in S: y &lt;= x MIN(S) == CHOOSE x \in S: \A y \in S: y &gt;= x RECURSIVE SetReduce(_, _, _) SetReduce(Op(_, _), S, value) == IF S = {} THEN value ELSE LET s == CHOOSE s \in S : TRUE IN SetReduce(Op, S \ {s}, Op(s, value)) ToSeq(S) == LET op(e, val) == Append(val, e) IN SetReduce(op, S, &lt;&lt; &gt;&gt;) ToSet(S) == {S[i] : i \in DOMAIN(S)} MapSet(Op(_), S) == {Op(x) : x \in S} GetIds(Evts) == MapSet(LAMBDA x: x.id, Evts) GetTimes(Evts) == MapSet(LAMBDA x: x.time, Evts) EventsOrderByTime(e1, e2) == e1.time &lt; e2.time EventsOrderById(e1, e2) == e1.id &lt; e2.id EventsOrder(e1, e2) == \/ EventsOrderByTime(e1, e2) \/ /\ e1.time = e2.time /\ EventsOrderById(e1, e2) Limit(S, limit) == LET amount == MIN({limit, Len(S)}) result == IF amount &gt; 0 THEN SubSeq(S, 1, amount) ELSE &lt;&lt; &gt;&gt; IN result \* SELECT * FROM events \* WHERE time &lt;= curr_time AND id &gt; max_id \* ORDER BY id \* LIMIT limit SELECT_HIGH_PRIO(state, limit) == LET selected == {e \in Events : /\ e.time &lt;= state.time /\ e.id &gt;= state.id } \*   Id sorted == SortSeq(ToSeq(selected), EventsOrderById) \*    limited == Limit(sorted, limit) IN ToSet(limited) \* SELECT * FROM events \* WHERE time &gt; current_time \* AND time - Time &lt;= delta_time \* ORDER BY time, id \* LIMIT limit SELECT_NORMAL(state, delta_time, limit) == LET selected == {e \in Events: /\ e.time &lt;= state.time + delta_time /\ e.time &gt; state.time } \*   sorted == SortSeq(ToSeq(selected), EventsOrder) \*   limited == Limit(sorted, limit) IN ToSet(limited) ALL_EVENTS_PROCESSED(state) == \A e \in Events: \/ e.time &gt;= state.time \/ e.id &gt;= state.id end define; fair process inserter = "Sources" variable t; begin forever: while TRUE do get_time: with evt_time \in 0..MAX_TIME do t := evt_time; end with; commit: either Events := Events \union {[time |-&gt; t, id |-&gt; Event_Id]} || Event_Id := Event_Id + 1; or Event_Id := Event_Id + 1; end either; end while; end process fair process event_processor = "Event_processor" variable state = ZERO_EVT, events = {}; begin forever: while TRUE do select: events := LET evts_high_prio == SELECT_HIGH_PRIO(state, LIMIT) new_limit == LIMIT - Cardinality(evts_high_prio) evts_normal == SELECT_NORMAL(state, TIME_DELTA, new_limit) IN evts_high_prio \union evts_normal; proc_evts: Events := Events \ events || state := [ time |-&gt; MAX({state.time} \union GetTimes(events)), id |-&gt; MAX({state.id} \union GetIds(events))] || events := {}; end while; end process end algorithm; *) \* BEGIN TRANSLATION \*  TLA+,     PlusCal  \* END TRANSLATION ===================================================</code> </pre> <br><p>  Un lecteur attentif peut remarquer qu'en plus d'introduire Limit, les √©tiquettes dans event_processor ont √©galement √©t√© modifi√©es.  Le but est un peu mieux de simuler du code r√©el que deux <em>s√©lections</em> ex√©cutent en une seule transaction, c'est-√†-dire que la s√©lection d'√©v√©nements peut √™tre consid√©r√©e comme effectu√©e de mani√®re atomique. </p><br><p>  Eh bien, si nous trouvons une erreur dans un mod√®le avec des op√©rations atomiques plus grandes, cela garantit pratiquement que la m√™me erreur se produit dans le m√™me mod√®le, mais avec des √©tapes atomiques plus petites (une d√©claration plut√¥t forte, mais je pense que c'est intuitif; bien que il doit √™tre bon sinon prouv√©, puis v√©rifi√© sur une large s√©lection de mod√®les). </p><br><h2 id="proverka-modeli-1">  V√©rification du mod√®le </h2><br><p>  Nous commen√ßons la simulation avec les m√™mes param√®tres que dans le premier mode de r√©alisation. </p><br><p>  Et nous obtenons une violation de la propri√©t√© ALL_EVENTS_PROCESSED √† la 19e √©tape de la simulation lors de la recherche en largeur. </p><br><p>  Pour des donn√©es initiales donn√©es (il s'agit d'un tr√®s petit espace d'√©tat), l'erreur √† la 19e √©tape indique que l'erreur est tr√®s rare et difficile √† d√©tecter, car avant cela, toutes les cha√Ænes d'√©tat d'une longueur inf√©rieure √† 19 ont √©t√© examin√©es. </p><br><p>  Par cons√©quent, cette erreur est difficile √† d√©tecter dans les tests.  Uniquement si vous savez o√π chercher et si vous s√©lectionnez sp√©cifiquement des tests et des huttes temporaires. </p><br><p>  Je n'apporterai pas tout l'itin√©raire pour gagner de l'espace et du temps.  Voici un segment de plusieurs √©tats avec une erreur: </p><br><p><img src="https://habrastorage.org/webt/1g/xq/en/1gxqen3cvdftawczsxb5apskzlc.png"></p><br><p><img src="https://habrastorage.org/webt/5r/b6/ml/5rb6mlga8u0rfalc1_3klnb6-ky.png"></p><br><p><img src="https://habrastorage.org/webt/5_/cz/n4/5_czn4pqrkbkhy6uocf3zllz39w.png"></p><br><p><img src="https://habrastorage.org/webt/_v/s8/d6/_vs8d6feegcimnw9bla8ylm-878.png"></p><br><p><img src="https://habrastorage.org/webt/wo/0j/qu/wo0jquth7jszanamlk7l3dpkspc.png"></p><br><h2 id="analiz-i-ispravlenie">  Analyse et correction </h2><br><p>  Que s'est-il pass√©? </p><br><p>  Comme vous pouvez le voir, l'erreur s'est manifest√©e par le fait que nous avons manqu√© l'√©v√©nement {2, 3} en raison du fait que la limite s'est termin√©e √† l'√©v√©nement {2, 1}, et apr√®s cela, nous avons chang√© l'√©tat du coordinateur.  Cela ne peut se produire que si √† un moment donn√© il y a plusieurs √©v√©nements. </p><br><p>  C'est pourquoi l'erreur √©tait insaisissable dans les tests.  Pour sa manifestation, il faut que des choses assez rares co√Øncident: </p><br><ol><li>  Plusieurs √©v√©nements ont touch√© le m√™me moment. </li><li>  La limite de s√©lection des √©v√©nements s'est termin√©e avant le moment de la lecture de tous ces √©v√©nements. </li></ol><br><p>  L'erreur peut √™tre relativement facilement corrig√©e si l'√©tat du coordinateur est un peu d√©velopp√©: ajoutez l'heure et l'identifiant du dernier √©v√©nement lu dans la zone d'√©v√©nements normale avec l'id maximum si l'heure de cet √©v√©nement correspond √† la valeur state.time suivante. </p><br><p>  S'il n'y a pas un tel √©v√©nement, nous d√©finissons l'√©tat suppl√©mentaire (extra_state) sur un √©tat non valide (UNDEF_EVT) et ne le prenons pas en compte lors du travail. </p><br><p>  Ces √©v√©nements de la r√©gion normale qui n'ont pas √©t√© trait√©s √† l'√©tape pr√©c√©dente du coordinateur, nous consid√©rerons d√©j√† une priorit√© √©lev√©e et corrigerons en cons√©quence la s√©lection du pr√©dicat de haute priorit√© et de s√©curit√©. </p><br><p>  Il serait possible d'introduire une autre zone interm√©diaire entre haute priorit√© et normale, et de changer l'algorithme.  Tout d'abord, il traitera les plus prioritaires, puis les interm√©diaires, puis passera aux normaux avec le changement d'√©tat suivant. </p><br><p>  Mais de tels changements conduiraient √† un plus grand volume de refactoring avec des avantages non √©vidents (l'algorithme sera un peu plus clair; d'autres avantages ne sont pas visibles tout de suite). </p><br><p>  Par cons√©quent, nous avons d√©cid√© d'ajuster l√©g√®rement l'√©tat actuel et la s√©lection des √©v√©nements de la base de donn√©es. </p><br><h2 id="skorrektirovannaya-model">  Mod√®le ajust√© </h2><br><p>  Voici le mod√®le corrig√©. </p><br><pre> <code class="plaintext hljs">------------------- MODULE events ------------------- EXTENDS Naturals, FiniteSets, Sequences, TLC \*        CONSTANTS MAX_TIME, LIMIT, TIME_DELTA (* --algorithm Events variables Events = {}, Limit \in LIMIT, Delta \in TIME_DELTA, Event_Id = 0 define \*    \*  ,   extra_state UNDEF_EVT == [time |-&gt; MAX_TIME + 1, id |-&gt; 0] ZERO_EVT == [time |-&gt; 0, id |-&gt; 0] MAX(S) == CHOOSE x \in S: \A y \in S: y &lt;= x MIN(S) == CHOOSE x \in S: \A y \in S: y &gt;= x RECURSIVE SetReduce(_, _, _) SetReduce(Op(_, _), S, value) == IF S = {} THEN value ELSE LET s == CHOOSE s \in S : TRUE IN SetReduce(Op, S \ {s}, Op(s, value)) ToSeq(S) == LET op(e, val) == Append(val, e) IN SetReduce(op, S, &lt;&lt; &gt;&gt;) ToSet(S) == {S[i] : i \in DOMAIN(S)} MapSet(Op(_), S) == {Op(x) : x \in S} GetIds(Evts) == MapSet(LAMBDA x: x.id, Evts) GetTimes(Evts) == MapSet(LAMBDA x: x.time, Evts) EventsOrderByTime(e1, e2) == e1.time &lt; e2.time EventsOrderById(e1, e2) == e1.id &lt; e2.id EventsOrder(e1, e2) == \/ EventsOrderByTime(e1, e2) \/ /\ e1.time = e2.time /\ EventsOrderById(e1, e2) TakeN(S, limit) == LET amount == MIN({limit, Len(S)}) result == IF amount &gt; 0 THEN SubSeq(S, 1, amount) ELSE &lt;&lt; &gt;&gt; IN result (* SELECT * FROM events WHERE time &lt;= curr_time AND id &gt; max_id ORDER BY id Limit limit *) SELECT_HIGH_PRIO(state, limit, extra_state) == LET \*      \* time &lt;= curr_time \* AND id &gt; maxt_id selected == {e \in Events : \/ /\ e.time &lt;= state.time /\ e.id &gt;= state.id \/ /\ e.time = extra_state.time /\ e.id &gt; extra_state.id} sorted == \*  SortSeq(ToSeq(selected), EventsOrderById) limited == TakeN(sorted, limit) IN ToSet(limited) SELECT_NORMAL(state, delta_time, limit) == LET selected == {e \in Events : /\ e.time &lt;= state.time + delta_time /\ e.time &gt; state.time } sorted == SortSeq(ToSeq(selected), EventsOrder) limited == TakeN(sorted, limit) IN ToSet(limited) \*    extra_state UpdateExtraState(events, state, extra_state) == LET exact == {evt \in events : evt.time = state.time} IN IF exact # {} THEN CHOOSE evt \in exact : \A e \in exact: e.id &lt;= evt.id ELSE UNDEF_EVT \*    extra_state ALL_EVENTS_PROCESSED(state, extra_state) == \A e \in Events: \/ e.time &gt;= state.time \/ e.id &gt; state.id \/ /\ e.time = extra_state.time /\ e.id &gt; extra_state.id end define; fair process inserter = "Sources" variable t; begin forever: while TRUE do get_time: with evt_time \in 0..MAX_TIME do t := evt_time; end with; commit: either Events := Events \union {[time |-&gt; t, id |-&gt; Event_Id]} || Event_Id := Event_Id + 1; or Event_Id := Event_Id + 1; end either; end while; end process fair process event_processor = "Event_processor" variable events = {}, state = ZERO_EVT, extra_state = UNDEF_EVT; begin forever: while TRUE do select: events := LET evts_high_prio == SELECT_HIGH_PRIO(state, Limit, extra_state) new_limit == Limit - Cardinality(evts_high_prio) evts_normal == SELECT_NORMAL(state, Delta, new_limit) IN evts_high_prio \union evts_normal; proc_evts: Events := Events \ events || state := [ time |-&gt; MAX({state.time} \union GetTimes(events)), id |-&gt; MAX({state.id} \union GetIds(events)) ]; extra_state := UpdateExtraState(events, state, extra_state) || events := {}; end while; end process end algorithm; *) \* BEGIN TRANSLATION \*  TLA+,     PlusCal  \* END TRANSLATION ===================================================</code> </pre> <br><p>  Comme vous pouvez le voir, les changements sont tr√®s faibles: </p><br><ol><li>  Ajout de donn√©es suppl√©mentaires √† l'√©tat extra_state. </li><li>  Modification de la s√©lection des √©v√©nements hautement prioritaires. </li><li>   UpdateExtraState   extra_state. </li><li>  <em>safety</em> -    . </li></ol><br><h2 id="modelirovanie">  Mod√©lisation </h2><br><p>    ,   . ,      (,  ,    ,     ). <br>       ,       ,  TLA+/TLC .  :) </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>     , ,     ( , ,  ,    ). </p><br><p>  ,            ,        TLA+/TLC,     . ,    . </p><br><p>         TLA+/TLC  ,   ,           ( ,     )  . </p><br><p>  ,     ,     ,  TLA+/TLC                . </p><br><h1 id="bibliografiya">  Bibliographie </h1><br><h2 id="knigi">  Livres </h2><br><h3 id="dlya-pogruzheniya-v-oblast">     </h3><br><p>   ,    ,   ,    .      . </p><br><ol><li><p> Michael Jackson <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Problem Frames: Analysing &amp; Structuring Software Development Problems</a> </p><br><p>      (  !),     .   ,   .      ,        . </p><br></li><li><p> Hillel Wayne <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Practical TLA+: Planning Driven Development</a> </p><br><p>     TLA+/PlusCal     .  ,    .      .         :    . </p><br></li><li><p>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MODEL CHECKING.      </a> </p><br><p>     .  ,    ,  .      ,            . </p><br></li><li><p> Leslie Lamport <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Specifying Systems: The TLA+ Language and Tools for Hardware and Software Engineers</a> </p><br><p>    TLA+.   ,   .      :     ,   .  ,     TLA+  ,    . </p><br></li></ol><br><h3 id="primery-iz-promyshlennosti">    </h3><br><ol><li><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Formal Development of a Network-Centric RTOS</a> </p><br><p>    TLA+          ( <em>RTOS</em> )       TLC. </p><br><p>      ,      .   ,   TLA+      ,             ,    <em>RTOS</em>   ‚Äî Virtuoso.       ,       . </p><br><p>          ,           (, ,  ,  ,    ). </p><br></li><li><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">w Amazon Web Services Uses Formal Methods</a> </p><br><p>   TLA+      AWS.        : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://lamport.azurewebsites.net/tla/amazon-excerpt.html</a> </p><br></li></ol><br><h2 id="internet">  Internet </h2><br><h3 id="blogi">  Blogs </h3><br><ol><li><p> Hillel Wayne (  "Practical TLA+") <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> </p><br><p>     .  ,  .   ,  -   . </p><br></li><li><p> Ron Pressler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> </p><br><p>   .        .  ,      TLA+.       TLA+,    <em>computer</em> <em>science</em>    . </p><br></li><li><p> Leslie Lamport <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> </p><br><p>      TLA+  <em>computer</em> <em>science</em> .  <em>TLA+</em>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . </p><br></li></ol><br><h3 id="prezentacii-i-videokursy">    </h3><br><ol><li><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">. . , . . , . . .      </a> </p><br><p>  ,   ,       . </p><br></li><li><p>   TLA+,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> </p><br><p>   ,     TLA+. ,       TLA+. </p><br></li><li><p> Hillel Wayne </p><br><p>      Hillel Wayne  .      . </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">The Two Hardest Problems in CS (June 5, 2018)</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Everything about distributed systems is terrible | Code Mesh LDN 18</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Designing Distributed Systems with TLA+ | √òredev 2018</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tackling Concurrency Bugs with TLA+</a> </li></ul><br></li><li><p> Ron Pressler </p><br><p>  ,   Hillel Wayne,     .  ,    . Ron Pressler      . ÃÅ       ,    ,     . </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">The Practice and Theory of TLA+</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Why Writing Correct Software Is Hard and Why Math (Alone) Won't Help Us</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">On the Nature of Abstraction</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Finite of sense &amp; infinite of thought | Code Mesh LDN 18</a> </li></ul><br></li></ol><br><h3 id="modelirovanie-1">  Mod√©lisation </h3><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TLA toolbox</a> + <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TLAPS</a> :        TLA+  <br>           .          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Alloy Analyzer</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr471012/">https://habr.com/ru/post/fr471012/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr471000/index.html">Jouets en bois, derni√®re partie - 1997</a></li>
<li><a href="../fr471004/index.html">Jouets en bois - un √©pilogue qui reste clou√© au plafond</a></li>
<li><a href="../fr471006/index.html">500 $ par mois: sur quoi les b√©n√©ficiaires d'un revenu de base inconditionnel d√©pensent-ils leur argent?</a></li>
<li><a href="../fr471008/index.html">Parlons de surveillance: enregistrement en direct du podcast Devops Deflope avec New Relic lors de la r√©union du 23 octobre</a></li>
<li><a href="../fr471010/index.html">Algorithme Grover et recherche de donn√©es</a></li>
<li><a href="../fr471014/index.html">Nous fabriquons un drone aquatique autonome, ou comme je r√™vais d'aider le Ba√Økal, mais je ne suis pas Gazprom. Partie 1</a></li>
<li><a href="../fr471016/index.html">Conception de base de donn√©es. Meilleures pratiques</a></li>
<li><a href="../fr471018/index.html">Comparaison des performances du PC et du smartphone, y compris l'iPhone 11</a></li>
<li><a href="../fr471020/index.html">Comment trouver un bug dans un microprocesseur sorti il ‚Äã‚Äãy a trente-cinq ans</a></li>
<li><a href="../fr471022/index.html">R√©v√©ler un secret de 140 ans en physique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>