<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍💻 🌓 💼 Wo speichern Sie die Daten? 🧑🏼 🏷️ 🔘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Wir setzen unsere experimentelle Artikelserie fort und beobachten, wie Sie in Echtzeit den Prozess der Erstellung eines Spiels auf UWP bee...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wo speichern Sie die Daten?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/414261/">  Hallo Habr!  Wir setzen unsere experimentelle Artikelserie fort und beobachten, wie Sie in Echtzeit den Prozess der Erstellung eines Spiels auf UWP beeinflussen können.  Heute werden wir über die Frage "Wo werden Daten gespeichert?" Sprechen, die in den Reihen der Entwickler ständig auftaucht.  Mach mit und teile deine Gedanken in den Kommentaren! <br><br><img src="https://habrastorage.org/webt/bi/xw/n9/bixwn96nclriud-rklafycm_rma.jpeg"><a name="habracut"></a><br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Teil 1: Wo soll ich anfangen?</b></a> </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2: Erweiterter Begrüßungsbildschirm</a></b> </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3: Der Stil des Sohnes von Mamas Sohn</a></b> </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 4: Benutzerdaten abrufen (freiwillig)</a></b> </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 5: Wo speichern Sie die Daten?</a></b> </li></ul><br>  <i>Ich gebe dem Autor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alexei Plotnikov</a> das Wort.</i> <br><br>  In einem früheren Artikel habe ich das Problem der bequemen Synchronisation von Benutzerdaten zwischen Geräten angesprochen und zunächst das Problem mit der Identifizierung gelöst. Dies ist jedoch der kleinste Teil dessen, was noch zu tun ist, um die Ziele zu erreichen. <br><br>  Ein viel komplexeres Problem ist die Art und vor allem der Speicherort von Benutzerdaten. Wenn Microsoft eine solche Frage stellt, fällt ihm als Erstes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Microsoft Azure ein</a> .  Die Azure-Cloud-Plattform umfasst eine so breite Palette von Diensten, dass es anscheinend keine Aufgaben gibt, die mit ihrer Hilfe nicht gelöst werden können.  Ob es wahr ist oder nicht, kann ich nicht beurteilen, aber meine Aufgabe liegt definitiv in der Macht dieser Plattform.  Das Wichtigste zuerst. <br><br>  Wir fangen klein an - was ist eine Wolke?  Zum ersten Mal hörte ich 2012 von der Cloud und dann wurde der Ausdruck "Cloud Computing" am häufigsten verwendet.  Die ursprüngliche Idee solcher Berechnungen bestand darin, die Rechenarbeit auf verschiedene Geräte zu verteilen, die voneinander entfernt sind.  Besonders eindrucksvoll wurde über die Zukunft gesprochen, in der selbst die schwierigsten Aufgaben in wenigen Augenblicken erledigt werden, da die Berechnungen auf alle Computer der Welt verteilt werden. <br><br>  In der Praxis kam es auf Rechenzentren an, die auf der ganzen Welt verstreut waren und den Verbrauchern ihre Rechenleistung zur Verfügung stellten. Das ursprüngliche Konzept war nur die Verteilung zwischen den Maschinen innerhalb des Rechenzentrums und zwischen den Rechenzentren selbst (meistens innerhalb derselben Region). <br><br>  Basierend auf dem Vorstehenden können wir davon ausgehen, dass Sie das Wort "Cloud" als vertrauteres "Hosting" wahrnehmen können, mit dem einzigen Unterschied, dass die Leistung der Cloud ohne zusätzlichen Aufwand von Ihrer Seite erweitert werden kann. <br><br>  Die zweite Frage, die Sie möglicherweise haben, ist, warum Azure?  "Da dies ein Artikel im Microsoft-Blog ist, wird der Autor nur über seine Produkte sprechen" - Sie sagen, und Sie werden sich irren.  Die Motive für die Verwendung von Azure sind weitaus häufiger anzutreffen. Da es sich um ein Microsoft-Produkt handelt, ist die Integration mit den anderen Produkten, mit deren Hilfe meine Anwendung entwickelt wird, höchstmöglich. <br><br>  Ich stelle jedoch fest, dass das Unternehmen alle Anstrengungen unternimmt, um die Verwendung von Azure für Entwickler für Android oder iOS attraktiv zu machen.  Nun, das zuletzt erwähnte, aber nicht das geringste Problem sind die Kosten für die Nutzung der Cloud.  Da ich Inhaber eines BizSpark-Abonnements bin, wurde mir ein monatliches Darlehen für eine Tasche gewährt, deren Zinsen mehr sind als die Deckung meiner Cloud-Anforderungen. Die Bedingungen, die kostenlos zur Verfügung gestellt werden, können jedoch auch die meisten Anforderungen eines privaten Entwicklers abdecken. <br><br>  Fahren wir nun mit der direkten Auswahl eines Synchronisations- und Datenspeicherungsmechanismus fort.  Ich werde nicht schlau sein, als Autodidakt muss ich mich oft mit Technologien auseinandersetzen, von denen ich keine Ahnung habe, bevor ich UWP kennen gelernt habe. Ich habe ähnliche Probleme mithilfe von SQL-Datenbanken gelöst. <br><br>  UWP verfügt jedoch nicht über die Mittel, um mit klassischen SQL-DBMS zu arbeiten, aber SQLite wird als Alternative angeboten. Nachdem ich mit der Studie begonnen hatte, stellte ich fest, dass eine solche Datenbank integriert ist, die für die bequeme Speicherung und Verwendung lokaler Daten geeignet ist, für die Datenplatzierung jedoch völlig ungeeignet ist im Remote-Speicher.  Bereits beim Schreiben dieses Artikels, als die erforderliche Technologie ausgewählt wurde, stieß ich auf eine der Azure-Lösungen im Bereich der Entwicklung mobiler Anwendungen, mit denen Sie Daten aus der SQLite-Tabelle zwischen Geräten synchronisieren können. Nach sorgfältiger Überlegung blieb ich jedoch bei der ersten Wahl. <br><br>  Übrigens war es nicht schwierig, die erste Wahl zu treffen, da Microsoft höflich eine Liste von Technologien erstellt hat, mit denen sich der UWP-Entwickler wahrscheinlich auseinandersetzen müsste.  In den neuesten Versionen von Visual Studio wird beim Erstellen eines neuen UWP-Projekts eine Seite mit Empfehlungen für den Einstieg angezeigt, auf der einer der Links "Hinzufügen eines empfohlenen Dienstes" lautet.  Wenn Sie auf diesen Link klicken, wird die Registerkarte "Dienst verbinden" geöffnet. Bereits darin wird die Option "Cloud-Speicher mit Azure-Speicherdienst" angezeigt. <br><br><img src="https://habrastorage.org/webt/fr/wx/k9/frwxk9themsqsxrjnxuhfnuzljw.png"><br><br>  Die Intuition legt nahe, dass dies genau das ist, was Sie brauchen. Ich habe mich daher entschlossen, mich auf eine eingehende Untersuchung dieses Themas zu konzentrieren, um es im Projekt weiter zu verwenden. <br><br>  Cloud-Speicher besteht aus mehreren Produkten für verschiedene Aufgaben, über die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> mehr gelesen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> kann. Ich interessierte mich jedoch hauptsächlich für den Tabellenspeicher, der sich als NoSQL-Datenbank herausstellte. <br><br>  NoSQL ist eine schemafreie Datenbank, in der die Tabelle nicht im Voraus strukturiert werden muss.  Tatsächlich ist die Tabelle in diesem Fall nur ein Teil des Pfads zum sogenannten Abschnitt. Dies bedeutet, dass eine einzelne Tabelle Zeilen mit beispielsweise drei und fünf Spalten gleichzeitig enthalten kann.  Um die Funktionen des Tabellenspeichers vollständig zu verstehen, empfehle ich Ihnen, das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Handbuch</a> sorgfältig zu lesen, aber ich werde dieses Thema aus meiner alltäglichen Sicht betrachten, da sich das Material letztendlich an Anfänger richtet, die ich in diesem Thema bin. <br><br>  <b>Lassen Sie uns zunächst herausfinden, wie eine NoSQL-Tabelle erstellt wird:</b> <br><br>  1. Registrieren Sie ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kostenloses</a> Azure-Konto.  Wenn Sie ein MSDN- oder BizSpark-Abonnement haben und es bereits in Azure aktiviert ist, können Sie diesen Schritt überspringen.  Mit einem kostenlosen Konto erhalten Sie für den ersten Monat ein Darlehen von 200 USD und anschließend freien Zugriff auf eine bestimmte Menge an Ressourcen der meisten Azure-Dienste.  In eine verständliche Sprache übersetzt, wird alles so ausgeführt, dass Sie erst bezahlen müssen, wenn Ihr Produkt genug verdient, um die Kosten zu decken, ganz zu schweigen von der Verwendung von Azure für die Selbstbildung. <br><br>  Aber selbst wenn Sie den freien Schwellenwert überschreiten, sind die Preise für einen Tabellenspeicher viel loyaler als für eine ähnliche Menge von SQL-Datenbanken.  Zum Zeitpunkt des Schreibens dieses Artikels habe ich beispielsweise zwei Tabellen mit bisher nur einem Eintrag erstellt.  Während 18 Tagen des Berichtszeitraums habe ich mich durchschnittlich 20 bis 30 Mal am Tag an sie gewandt, und für diesen Zeitraum wurden 2 Kopeken vom Guthabenkonto abgeschrieben.  Als ich diese Kosten für das geplante Volumen hochskalierte, stellte ich fest, dass sie mehr als durch die potenziellen Einnahmen aus dem Antrag gedeckt sind. <br><br>  2. Nachdem Sie ein Konto in Azure haben, erstellen wir ein Speicherkonto. <br><br><img src="https://habrastorage.org/webt/pk/zf/ci/pkzfciggnj3px9azcypmku_rgd8.png"><br><br>  Sie können dies alles auf derselben Visual Studio Services-Verbindungsseite tun, die ich oben beschrieben habe.  Wenn Sie diese Seite plötzlich geschlossen haben, können Sie sie öffnen, indem Sie im Projektmappen-Explorer auf „Verbundene Dienste“ doppelklicken.  Nach Auswahl des gewünschten Dienstes wird ein Fenster mit den verfügbaren Speicherkonten geöffnet. Um ein neues hinzuzufügen, klicken Sie auf die entsprechende Schaltfläche. <br><br>  <b>Im neuen Fenster müssen Sie die folgenden Schritte ausführen:</b> <br><br><ul><li>  Um zu beginnen, müssen Sie sich mit Ihrem Microsoft-Konto anmelden.  Sie müssen das Konto verwenden, an das Ihre Abonnements gebunden sind, oder ein kostenloses Azure-Konto. </li><li>  Nachdem Sie sich in Ihrem Konto angemeldet haben, wird Ihr Abonnement (a) im Feld "Abonnement" angezeigt.  Bei der Auswahl ist alles einfach, daher sind Kommentare überflüssig. </li><li>  Geben Sie im Feld "Name" den gewünschten Namen des Speicherdienstes an.  Da dies auch der Domänenname des Dienstes ist, muss er in allen in Azure verfügbaren Konten eindeutig sein und nicht nur in Ihren eigenen. </li><li>  Im Feld "Preiskategorie" müssen Sie die Unterschiede zwischen einer Cloud-Plattform und herkömmlichem Hosting verstehen, da Sie durch Klicken auf den Link unter dem Feld eine Preisliste sehen, jedoch keine verständliche Erklärung, die Ihnen jede Option bietet.  In der Wildnis der Sitelinks finden Sie natürlich umfassende Informationen zu all diesen Abkürzungen wie GRS und LRS, aber dies ist für den durchschnittlichen Entwickler überflüssig.  Es genügt zu verstehen, dass je teurer der Tarif ist, desto mehr Rechenzentren an der Verarbeitung und Speicherung Ihrer Daten beteiligt sind und desto höher ist die Wahrscheinlichkeit ihrer Sicherheit.  Für ein kleines Projekt ist die niedrigste LRS-Rate in Ordnung. </li><li>  Eine „Ressourcengruppe“ ist eine Kombination mehrerer Azure-Dienste für eine einzelne Verwaltung.  In unserem Fall erstellen Sie einen neuen, weisen Sie einen beliebigen Anzeigenamen zu und fahren Sie fort. </li><li>  Als letztes müssen Sie den „Standort“ für Ihren Service auswählen.  Mit Standort ist der tatsächliche Standort der Rechenzentren gemeint, die für die Arbeit mit unseren Daten verantwortlich sind.  Bitte beachten Sie, dass ich im Plural spreche, da es in einer Region mehrere Rechenzentren geben kann und die Arbeit auf diese verteilt werden kann (falls Sie eine beratende Preiskategorie wählen).  Wählen Sie diejenige aus, die Ihrer primären Benutzerbasis am nächsten liegt.  Wenn Sie jedoch vorhaben, auf der ganzen Welt zu wachsen, und überall auf der Welt maximale Reaktion benötigen, stört Sie niemand für jede regionale Version der Anwendung, ein separates Speicherkonto zu erstellen und die Datensynchronisation zwischen ihnen zu implementieren.  Ein hohes Maß an Erweiterbarkeit ist der Hauptvorteil der Cloud. </li></ul><br>  3. Nachdem Sie das Speicherkonto erstellt haben, wird es der Liste hinzugefügt. Sie können fortfahren, indem Sie auf die Schaltfläche "Hinzufügen" klicken.  Das Ergebnis dieser Aktion ist das Hinzufügen eines NuGet-Pakets für die Arbeit mit Azure zum Projekt und das Speichern der Verbindungszeichenfolge in der Datei app.config des Projekts. <br><br>  Leider ist es nicht möglich, mit Werten aus dieser Datei in UWP (oder möglicherweise mit schrecklichen Krücken) zu arbeiten. Kopieren Sie daher einfach die Verbindungszeichenfolge zum Speicherdienst von dort an eine geeignete Stelle im Projekt und fahren Sie mit dem nächsten Schritt fort. <br><br>  4. Nun bleibt es, eine Tabelle zu erstellen und damit zu arbeiten.  Und hier beginnt die individuelle Arbeit, abhängig von den Aufgaben. <br><br>  Tatsache ist, dass Sie vor dem Erstellen von Tabellen sorgfältig über die Architektur zum Speichern Ihrer Daten nachdenken sollten.  Das Arbeiten mit dem Tabellenspeicher ist so bequem, dass das Erstellen einer neuen Tabelle direkt aus dem Code nur wenige Zeilen umfasst. Mit dieser Bequemlichkeit besteht natürlich der Wunsch, jedem Benutzer eine separate Tabelle zuzuweisen, da die ultimative Aufgabe darin besteht, Daten zwischen seinen Geräten zu synchronisieren.  Wenn Sie jedoch mit einer unbekannten Technologie arbeiten, sollten Sie keine voreiligen Entscheidungen treffen und die Vor- und Nachteile sorgfältig abwägen.  Ein spezieller <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel im Handbuch</a> kann <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ihnen</a> dabei helfen, die richtige Entscheidung zu treffen. Machen Sie sich jedoch bereit, ihn mehrmals neu zu lesen, da es sehr schwierig ist, alle Daten sofort zu lernen, insbesondere unter Berücksichtigung der Masse neuer Begriffe. <br><br>  Ich werde die Geschichte unter Berücksichtigung der Tatsache fortsetzen, dass Sie das Handbuch noch gelesen und einige der Funktionen der Arbeit mit der Tischspeicherung verstanden haben.  Zum Beispiel wurde mir klar, dass eine Tabelle konzeptionell keine isolierte Einheit ist, sondern vielmehr ein Ort für eine logische Gruppierung von Datensätzen.  Dies ist leicht zu verstehen, wenn Sie die Tabelle als Ordner präsentieren, in dem Sie Datendateien speichern.  Ein Ordner selbst nimmt keinen Speicherplatz ein und ist kein integraler Bestandteil von Dateien, sondern definiert lediglich einen Teil des Pfads zu Dateien, die logisch, aber nicht erforderlich sind, um in diesem Ordner gespeichert zu werden. <br><br>  Die Schlussfolgerung daraus ist recht einfach: Niemand stört sich daran, die Einstellungen aller Benutzer in einer Tabelle zu speichern. Hauptsache, das Wertepaar in den Spalten PartitionKey und RowKey ist in der Tabelle eindeutig.  Dies wird in meinem Projekt erneut implementiert, da die Benutzer-ID als PartitionKey fungiert und beispielsweise die Zeichenfolge "UserName" als RowKey, mit der wir den eindeutigen Datensatz bestimmen können, in dem der Benutzername gespeichert ist.  Aber wie ich oben sagte, müssen wir alle Vor- und Nachteile abwägen, also lasst uns abwägen: <br><br><ul><li>  "Für" eine separate Tabelle für die Daten jedes Benutzers ist die Bequemlichkeit bei der Wahrnehmung der Datenstruktur.  Wenn wir die Tabelle als Ordner mit Dateien betrachten, ist es logisch, dass sich alle Dateien eines Benutzers im selben Ordner befinden, und es ist üblicher, mit einer solchen Architektur zu arbeiten. </li><li>  Alle anderen Faktoren sprechen gegen eine separate Tabelle.  Benutzerdaten in einer separaten Tabelle - dies ist praktisch genau, bis die Anzahl solcher Tabellen in Tausenden liegt.  Da sich das Speicherkonto auf einer höheren Ebene über der Tabelle befindet, wird für sie keine andere Gruppierung bereitgestellt. <br><br>  Angesichts der potenziellen Benutzerbasis besteht die Gefahr, dass wir in Tausenden von einzelnen Tabellen ertrinken und diejenigen verlieren, die einen Prioritätswert haben.  Gleichzeitig vereinfacht das Speichern der Einstellungen aller Benutzer in einer Tabelle die Verwaltung und das Arbeiten mit Daten, um statistische Informationen zu sammeln oder soziale Funktionen zu implementieren. <br><br>  Darüber hinaus können Sie aufgrund der geringen Kosten für die Verwendung des Tabellenspeichers alle Daten gemäß der erforderlichen Logik in separaten Tabellen duplizieren.  Insbesondere plane ich, eine zusätzliche Tabelle mit dem Benutzernamen, einem Link zum Avatar und einem Hinweis auf die Zugehörigkeit zum Land zu erstellen, die für Bewertungstabellen oder andere soziale Funktionen verwendet wird, die der Anwendung hinzugefügt werden können. </li></ul><br>  Wenn Sie also die Datenspeicherstruktur herausgefunden haben, fügen wir endlich eine neue Tabelle hinzu.  Da wir uns geweigert haben, es auf Codeebene zu erstellen, bleiben zwei Optionen: über das Azure-Webportal oder über das spezielle Microsoft Azure Storage Explorer-Tool, das von storageexplorer.com heruntergeladen werden kann.  In beiden Fällen muss das gewünschte Speicherkonto ausgewählt und im Abschnitt "Tables / Tables Service" die Option "+ Table / Create Table" ausgewählt werden.  Geben Sie im angezeigten Dialogfeld den gewünschten Namen ein und übernehmen Sie die Änderungen. <br><br><img src="https://habrastorage.org/webt/ca/0b/j9/ca0bj92etkk7v2qpp-r63wtymeq.png"><br><br>  Danach können Sie problemlos mit der neuen Tabelle aus dem Code arbeiten. <br><br>  Die Hauptoperationen, die ich mit der Tabelle ausführen werde, sind das Einfügen und Extrahieren von Zeilen, die in der Tabellenspeicherterminologie als "Entitäten" bezeichnet werden.  Ein solcher Begriff ist leichter zu verstehen, wenn Sie feststellen, dass Sie zum Einfügen und Abrufen einer Entität eine Klasse zuordnen müssen, die von TableEntity von Microsoft.WindowsAzure.Storage.Table geerbt wurde.  Die Nachfolgerklasse enthält bereits einige erforderliche Felder, z. B. PartitionKey (Abschnittsname) und RowKey (Zeilenname). Die Felder, die wir unabhängig voneinander implementieren, sind Spalten in der Zeile (Entitätseigenschaften). <br><br>  Stellen Sie sich ein Beispiel für eine Tabelle vor, in der eine Liste aller Spieler mit Namen, Avatar und Länderzugehörigkeit gespeichert wird. <br><br><pre><code class="cs hljs">    : Imports Microsoft.WindowsAzure.Storage Imports Microsoft.WindowsAzure.Storage.Table</code> </pre> <br>  Ich habe mich entschlossen, die Methoden für die Arbeit mit der Tabelle in eine separate Klasse einzuteilen, um das Arbeiten an verschiedenen Stellen der Anwendung zu vereinfachen.  Erstellen Sie es und fügen Sie sofort die zuvor bekannten Konstanten hinzu: <br><br><pre> <code class="cs hljs">Public Class AzureWorker Private Const AzureStorageConnectionString As String = <span class="hljs-string"><span class="hljs-string">"  ,     app.config"</span></span> Private Const GamerListTableNameString As String = <span class="hljs-string"><span class="hljs-string">"GamerList"</span></span> <span class="hljs-string"><span class="hljs-string">'    … End Class</span></span></code> </pre> <br>  Jetzt müssen wir eine Klasse erstellen, die wir der Entität (Zeile) in der Tabelle zuordnen: <br><br><pre> <code class="cs hljs"> Private Class GamerListClodTableDataClass Inherits TableEntity Public Const RowKeyValue As String = <span class="hljs-string"><span class="hljs-string">"UserID"</span></span> <span class="hljs-function"><span class="hljs-function">Public Sub </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">New</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) RowKey</span></span> = RowKeyValue End Sub Public Property UserName As String = <span class="hljs-string"><span class="hljs-string">""</span></span> Public Property UserountryID As String = <span class="hljs-string"><span class="hljs-string">""</span></span> Public Property UserAvatar As String = <span class="hljs-string"><span class="hljs-string">""</span></span> End Class</code> </pre> <br>  Die zuzuordnende Klasse muss von TableEntity geerbt sein und Felder für die Daten enthalten, die in die Tabelle eingefügt werden sollen.  Beachten Sie, dass das Festlegen von Werten für einen RowKey oder PartitionKey auf Klassenebene nicht erforderlich ist. In meinem Fall wird der RowKey jedoch festgelegt, da er unabhängig von anderen Eingaben unveränderlich ist. <br><br>  Da Sie zu diesem Zeitpunkt wahrscheinlich die Essenz der Arbeit mit dem Tabellenspeicher nicht vollständig verstanden haben, werde ich die in dieser Phase festgelegte Logik erläutern.  Der schnellste Weg, mit einer Tabelle zu arbeiten, besteht darin, die Entität nach dem Namen der Zeichenfolge und dem Abschnittsnamen abzufragen. Daher müssen Sie diese Daten im Voraus kennen.  Darüber hinaus muss die Kombination von PartitionKey und RowKey innerhalb der Tabelle eindeutig sein. Dies bedeutet, dass es logisch ist, eine eindeutige Benutzer-ID in einen dieser Schlüssel zu schreiben und dem zweiten Schlüssel einen Namen zuzuweisen, den wir immer kennen.  Genau dies wird in der GamerListClodTableDataClass-Klasse ausgeführt. <br><br>  Die letzte vorbereitende Phase vor direkten Abfragen an die Tabelle ist die Erstellung des Objekts in einer separaten Funktion: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Private Shared Function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCloudTable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tableName As String</span></span></span><span class="hljs-function">) As CloudTable Dim storageAccount As CloudStorageAccount</span></span> = CloudStorageAccount.Parse(AzureStorageConnectionString) Dim tableClient As CloudTableClient = storageAccount.CreateCloudTableClient() Dim table As CloudTable = tableClient.GetTableReference(tableName) Return table End Function</code> </pre> <br>  Dies geschieht, um den Code nicht jedes Mal zu duplizieren, wenn wir Daten in die Tabelle lesen oder schreiben möchten.  Bitte beachten Sie, dass dieser Code keine direkten Anforderungen an die Cloud stellt und ohne Probleme ausgeführt wird, wenn keine Verbindung besteht.  Er erstellt lediglich Schritt für Schritt ein Tabellenobjekt aus vorhandenen Daten, z. B. der Speicherverbindungszeichenfolge und dem Tabellennamen. <br><br>  Lassen Sie uns abschließend direkt mit der Tabelle arbeiten und zunächst die aktuellen Benutzerdaten speichern: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Public Shared Async Function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SavedOrUpdateUserData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">u As UserManager</span></span></span><span class="hljs-function">) As </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Task</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Of Boolean</span></span></span><span class="hljs-function">) Dim table As CloudTable</span></span> = GetCloudTable(GamerListTableNameString) Try If Await table.ExistsAsync Then Dim UserDataClodTableData As New GamerListClodTableDataClass With {.PartitionKey = u.UserId, .UserName = u.UserName.Trim, .UserountryID = u.UserountryID, .UserAvatar = <span class="hljs-string"><span class="hljs-string">"https://apis.live.net/v5.0/"</span></span> &amp; u.UserId &amp; <span class="hljs-string"><span class="hljs-string">"/picture"</span></span>} Dim insertOperation As TableOperation = TableOperation.InsertOrReplace(UserDataClodTableData) Await table.ExecuteAsync(insertOperation) Return True End If Catch ex As Exception End Try Return False End Function</code> </pre> <br>  Die Anforderung wird als asynchrone Funktion gestellt, damit der aufrufende Code das Ergebnis der Ausführung erhalten kann (True bei Erfolg und False bei Fehler).  Außerdem wird ein Parameter vom Typ UserManager an die Funktion übergeben, die auf die Klasse mit Benutzerdaten verweist.  Wir haben eine solche Klasse in einem früheren Artikel erstellt. Der einzige Unterschied besteht darin, dass in dieser Version ein Feld UserountryID vorhanden ist, in dem Daten zum Land des Benutzers gespeichert werden. <br><br>  Bei Abfragen an die Tabelle müssen Sie zuerst das Objekt mithilfe der Verbindungszeichenfolge zum Repository und des Tabellennamens erstellen (wir haben diesen Prozess zuvor in eine separate Funktion gestellt).  Als Nächstes sollten Sie die Existenz der Tabelle überprüfen. Obwohl wir sicher sind, dass wir eine Tabelle mit diesem Namen haben, kann ein Fehler auftreten, z. B. aufgrund mangelnder Netzwerkverbindung oder aufgrund eines Fehlers in der Cloud (weshalb dieser Code im Try / Block abgelegt wird Fang).  Bevor Sie in die Tabelle schreiben, müssen Sie eine Instanz der UserDataClodTableData-Klasse erstellen, den Feldern den erforderlichen Wert zuweisen und erst dann die InsertOrReplace-Operation erstellen.  Wie Sie dem Namen der Operation entnehmen können, wird eine neue Zeile in die Tabelle eingefügt, wenn Zeilen mit demselben PartitionKey- und RowKey-Paar nicht in der Tabelle vorhanden sind, und die Daten ersetzt, wenn eine solche Zeile bereits vorhanden ist.  Nun, das endgültige ExecuteAsync-Team wird tatsächlich die geplante Aktion auf der Tischspeicherseite ausführen. <br><br>  Das Lesen von Daten aus einer Tabelle ist so einfach wie das Schreiben.  Fordern wir zum Beispiel einen Benutzernamen an: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Public Shared Async Function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetUserName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id As String</span></span></span><span class="hljs-function">) As </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Task</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Of String</span></span></span><span class="hljs-function">) Dim table As CloudTable</span></span> = GetCloudTable(GamerListTableNameString) Try If Await table.ExistsAsync Then Dim retrieveOperation As TableOperation = TableOperation.Retrieve(Of GamerListClodTableDataClass)(id, GamerListClodTableDataClass.RowKeyValue) Dim retrievedResult As TableResult = Await table.ExecuteAsync(retrieveOperation) If retrievedResult.<span class="hljs-function"><span class="hljs-function">Result IsNot Nothing Then Return </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CType</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">retrievedResult.Result, GamerListClodTableDataClass</span></span></span><span class="hljs-function">).UserName End If End If Catch ex As Exception End Try Return "" End Function</span></span></code> </pre> <br>  Dieser Code unterscheidet sich fast nicht vom vorherigen und beginnt auch damit, ein Tabellenobjekt zu erstellen und seine Existenz zu überprüfen.  Außerdem erstellen wir wie bei der Aufzeichnung eine Operation, diesmal jedoch eine Extraktionsoperation, für die die Angabe von PartitionKey und RowKey erforderlich ist.  Danach extrahieren wir das Ergebnis mit ExecuteAsync und arbeiten mit dem resultierenden Objekt vom Typ TableResult. Dabei wird die Result-Eigenschaft in den Typ der zugeordneten Klasse umgewandelt und der Benutzername extrahiert. <br><br>  Das Arbeiten mit einer Tabelle ist nicht auf Lese- und Schreibvorgänge beschränkt und unterstützt viele verschiedene Skripte.  Sie können beispielsweise eine Abfrage erstellen, mit der alle Entitäten mit dem angegebenen PartitionKey oder alle Entitäten mit dem angegebenen Feld extrahiert werden. Es ist jedoch wichtig, die Geschwindigkeit solcher Vorgänge sowie die Datenmenge zu berücksichtigen, die über das Netzwerk übertragen wird. <br><br>  Das obige Beispiel ist unter dem Gesichtspunkt der Abfragegeschwindigkeit am optimalsten, da das Adressierungssystem höchstwahrscheinlich eine Entität entlang des Pfads "Speichername \ Tabellenname \ PartitionKey + RowKey" findet. Um jedoch nur einen Namen zu erhalten, laden wir die gesamte Entität als Ganzes, was nicht vorteilhaft ist auf die Menge der übertragenen Daten. <br><br>  Das Folgende ist ein modifizierter Funktionscode, der die maximale Abfrageoptimierung berücksichtigt: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Public Shared Async Function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetUserName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id As String</span></span></span><span class="hljs-function">) As </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Task</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Of String</span></span></span><span class="hljs-function">) Dim table As CloudTable</span></span> = GetCloudTable(GamerListTableNameString) Try If Await table.<span class="hljs-function"><span class="hljs-function">ExistsAsync Then Dim projectionQuery As </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TableQuery</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Of DynamicTableEntity</span></span></span><span class="hljs-function">)</span></span> = <span class="hljs-function"><span class="hljs-function">New </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TableQuery</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Of DynamicTableEntity</span></span></span><span class="hljs-function">)(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>).</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Where</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TableQuery.CombineFilters(TableQuery.GenerateFilterCondition(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"PartitionKey"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, QueryComparisons.Equal, id</span></span></span><span class="hljs-function">), "and", TableQuery.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateFilterCondition</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"RowKey"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, QueryComparisons.Equal, GamerListClodTableDataClass.RowKeyValue</span></span></span><span class="hljs-function">))).</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Select</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"UserName"</span></span></span></span><span class="hljs-function"><span class="hljs-params">}</span></span></span><span class="hljs-function">) Dim resolver As </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EntityResolver</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Of String</span></span></span><span class="hljs-function">)</span></span> = Function(pk, rk, ts, props, etag) <span class="hljs-function"><span class="hljs-function">Return </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">props</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"UserName"</span></span></span></span></span><span class="hljs-function">).StringValue End Function Dim result As </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TableQuerySegment</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Of String</span></span></span><span class="hljs-function">)</span></span> = Await table.ExecuteQuerySegmentedAsync(projectionQuery, resolver, Nothing) If result.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-function">Then Return </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">) End If End If Catch ex As Exception End Try Return "" End Function</span></span></code> </pre> <br>  Anstatt ein Operationsobjekt zu erstellen, erstellen wir in diesem Code ein Anforderungsobjekt, das verschiedene Methoden enthält, um zu bestimmen, was als Ergebnis abgerufen werden muss.  Die Where-Methode erstellt einen Filter, der angibt, dass nur die Zeilen zurückgegeben werden müssen, für die PartitionKey und RowKey den angegebenen Werten entsprechen, und die nächste Auswahl gibt an, dass nur die Spalte Benutzername ausgewählt werden muss. <br><br>  Bei einer solchen Abfrage ist es nicht sinnvoll, das Ergebnis mit einer Klasse zu vergleichen. Daher wird das IDictionary als Rückgabewert verwendet, wobei der Schlüssel der Name der Spalte und der Wert der Inhalt ist.  Da die Funktion ExecuteQuerySegmentedAsync nicht weiß, welches Ergebnis ihrer Ausführung erhalten wird, ist es möglich (und in diesem Fall erforderlich), einen EntityResolver-Delegaten zu übergeben, der auf eine Funktion verweist, die den gewünschten Wert aus dem Wörterbuch übernimmt.  Das Ergebnis all dessen wird TableQuerySegment, in dessen erstem Index der Name des angeforderten Benutzers gespeichert ist. <br><br>  Im Allgemeinen können Sie durch die Verwendung von Abfragen anstelle der grundlegenden Extraktionsoperation die Möglichkeiten der Arbeit mit einer Tabelle erheblich erweitern. Seien Sie jedoch vorsichtig, da hier im Gegensatz zu klassischem SQL die Geschwindigkeit der Abfrageverarbeitung direkt von den Parametern abhängt.  Niemand stört Sie daran, eine Abfrage auszuführen, um alle Benutzerdatensätze abzurufen, deren Namen dem angegebenen entsprechen. Eine solche Abfrage ist jedoch länger als das Gegenstück in SQL.  Um dies zu lernen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verweise</a> ich Sie noch einmal auf den oben erwähnten Leitfaden zum Tischdesign. Außerdem empfehle ich Ihnen, den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel zu lesen</a> , der Beispiele für die Arbeit mit der Tabellenspeicherung enthält. <br><br>  <i>Wichtig!</i>  <i>Die Linkartikel verwenden Code für klassische .NET-Anwendungen und unterscheiden sich von der UWP-Implementierung.</i>  <i>Glücklicherweise ist dieser Unterschied nicht signifikant und die Analoga sind intuitiv (meistens liegen die Unterschiede im Async-Präfix).</i> <br><br>  Abschließend werde ich die Ergebnisse der Verwendung des Azure-Speichers in meinem Projekt im Moment mitteilen.  Beim ersten Start, nachdem ich die Benutzer-ID erhalten und Daten von der Live-ID heruntergeladen habe, schlage ich vor, dass er einen Alias ​​(Spitznamen) wählt, falls der im Profil gespeicherte Name nicht zu ihm passt.  Anschließend wird der eingegebene Kurzname in der UserManager-Klasse anstelle der Standardklasse gespeichert, und alle diese Daten werden in der GamerList-Tabelle gespeichert.  Beim nächsten Start wird die Benutzer-ID im Hintergrund empfangen und ein Alias ​​vom Geschäft angefordert.  Infolgedessen sieht der Benutzer seinen Spitznamen im Spiel und nicht den Namen aus dem Standardprofil. <br><br>  Auch in Zukunft wird eine Tabelle mit einer Liste von Benutzern nützlich sein, um soziale Funktionen in das Spiel einzugeben, und jetzt habe ich mindestens eine Anwendung für diese Daten entwickelt.  Bei der Implementierung dieser Aufgabe helfen mir Azure-Tools wie Warteschlangenspeicher und Azure-Funktionen erneut, aber ich werde in einem der folgenden Artikel darauf eingehen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de414261/">https://habr.com/ru/post/de414261/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de414245/index.html">Polynom-Regressionsmodell</a></li>
<li><a href="../de414249/index.html">Public-Key-Infrastruktur: GCrypt-Bibliothek als Alternative zu OpenSSL mit Unterstützung für russische Kryptografie</a></li>
<li><a href="../de414251/index.html">Entwicklung ohne Programmierung: Immerhin Life Hack?</a></li>
<li><a href="../de414253/index.html">Muster für Tester. Proxy (alternativ)</a></li>
<li><a href="../de414255/index.html">Patentierter Traum des Programmierers - Teil II</a></li>
<li><a href="../de414263/index.html">Gibt es Leben außerhalb von Roscosmos? Überblick über die Erforschung des russischen Privatraums</a></li>
<li><a href="../de414265/index.html">Richard Hamming: Kapitel 7. Künstliche Intelligenz - II</a></li>
<li><a href="../de414267/index.html">Wie ersetze ich einen Buchhalter durch einen Roboter?</a></li>
<li><a href="../de414269/index.html">"20.000 IOPS pro Knoten bieten eine gute Leistung bei einer Latenz von 5 ms." Für OLTP - nein</a></li>
<li><a href="../de414271/index.html">So zähmen Sie eine Festplatte in einem Laptop und verhindern das Parken in 8 Sekunden Ausfallzeit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>