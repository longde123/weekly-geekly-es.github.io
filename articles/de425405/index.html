<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíê ‚õìÔ∏è üå≥ Newtypen der Gro√ümacht üßïüèø üë®üèø‚Äçüè´ üßúüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Newtype ist eine spezielle Datentypdeklaration. So dass es nur einen Konstruktor und ein Feld enth√§lt. 



newtype Foo a = Bar a newtype Id = MkId Wor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Newtypen der Gro√ümacht</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425405/">  Newtype ist eine spezielle Datentypdeklaration.  So dass es nur einen Konstruktor und ein Feld enth√§lt. <br><br><pre><code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Foo</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bar</span></span></span><span class="hljs-class"> a </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Id</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkId</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word</span></span></span></span></code> </pre> <br><img src="https://habrastorage.org/webt/_5/zw/n9/_5zwn9jwjjngjatmg_y57dwddaq.png"><br><h3>  Typische Fragen f√ºr Neulinge </h3><br>  <i>Was ist der Unterschied zu Datentypdaten?</i> <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Foo</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bar</span></span></span><span class="hljs-class"> a </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Id</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkId</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word</span></span></span></span></code> </pre><br>  Die Hauptspezifit√§t des <b>Newtype</b> besteht darin, dass er aus denselben Teilen besteht wie sein einziges Feld.  Genauer gesagt unterscheidet es sich vom Original auf Typebene, hat jedoch die gleiche Darstellung im Speicher und wird streng (nicht tr√§ge) berechnet. <br>  Kurz gesagt - <b>Newtype sind</b> aufgrund ihrer Pr√§sentation effektiver. <br><br>  <i>Ja, es bedeutet mir nichts ... Ich werde <b>Daten verwenden</b></i> <br>  Nein, am Ende k√∂nnen Sie immer die Erweiterung <b>-funpack-strict-fields</b> :) f√ºr strenge (nicht faule) Felder <b>aktivieren</b> oder direkt angeben <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Id</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkId</span></span></span><span class="hljs-class"> !</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word</span></span></span></span></code> </pre><br>  Die Leistung des <b>Newtype ist jedoch</b> nicht auf die Recheneffizienz beschr√§nkt.  Sie sind viel st√§rker! <a name="habracut"></a><br><br><h2>  3 <b>neue</b> Rollen </h2><br><img src="https://habrastorage.org/webt/6t/zt/kp/6tztkpdj2y4fosehxg3_ogz-ark.jpeg"><br><br><h3>  Implementierung ausblenden </h3><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span> Data.Id (<span class="hljs-type"><span class="hljs-type">Id</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Id</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkId</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word</span></span></span></span></code> </pre><br>  <b>newtype</b> unterscheidet sich vom urspr√ºnglichen, intern nur <b>Word</b> . <br>  Wir verstecken den <b>MkId-</b> Konstruktor jedoch au√üerhalb des Moduls. <br><br><h3>  Implementierung Implementierung </h3><br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Id</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkId</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Num</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  Obwohl dies nicht im Haskell2010-Standard enthalten ist, k√∂nnen Sie durch Erweitern der Ausgabe generischer newTypes automatisch auf das Verhalten von <b>newtype</b> schlie√üen, das dem Verhalten des internen Felds entspricht.  In unserem Fall ist das Verhalten von <b>Gl. Id</b> und <b>Num Id</b> dasselbe wie bei <b>Gl. Wort</b> und <b>Num Wort</b> . <br><br>  Durch den Ausbau der raffinierten Zucht ( <b>DerivingVia</b> ) kann viel mehr erreicht werden, dazu sp√§ter mehr. <br><br><h3>  Umsetzung der Wahl </h3><br>  In einigen F√§llen k√∂nnen Sie trotz eines eigenen Konstruktors Ihre interne Darstellung verwenden. <br><br><h4>  Herausforderung </h4><br>  Es gibt eine Liste von ganzen Zahlen.  Finden Sie den Maximal- und Gesamtbetrag in nur einem Durchgang auf der Liste. <br>  Und verwenden Sie keine <b>Foldl-</b> und <b>Fold-</b> <b>Pakete</b> . <br><br><h4>  Typische Antwort </h4><br>  Nat√ºrlich <b>falten</b> !  :) :) <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">foldr</span></span> :: <span class="hljs-type"><span class="hljs-type">Foldable</span></span> t =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; ta -&gt; b <span class="hljs-comment"><span class="hljs-comment">{- -- instance Foldable [] foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b -}</span></span></code> </pre><br>  Und die endg√ºltige Funktion wird folgenderma√üen beschrieben: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">aggregate</span></span> :: [<span class="hljs-type"><span class="hljs-type">Integer</span></span>] -&gt; (<span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Integer</span></span>, <span class="hljs-type"><span class="hljs-type">Integer</span></span>) aggregate = foldr (\el (m, s) -&gt; (<span class="hljs-type"><span class="hljs-type">Just</span></span> el `max` m, el + s)) (<span class="hljs-type"><span class="hljs-type">Nothing</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">{- ghci&gt; aggregate [1, 2, 3, 4] (Just 4, 10) -}</span></span></code> </pre><br>  Wenn Sie genau hinschauen, sehen Sie √§hnliche Operationen auf beiden Seiten: <b>Nur el `max` m</b> und <b>el + s</b> .  In beiden F√§llen Mapping und Bin√§roperation.  Und die leeren Elemente sind <b>Nichts</b> und <b>0</b> . <br><br>  Ja, das sind Monoide! <br><br><div class="spoiler">  <b class="spoiler_title">Monoid und Halbgruppe im Detail</b> <div class="spoiler_text">  Eine Halbgruppe ist eine Eigenschaft einer assoziativen bin√§ren Operation <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">x</span></span> ‚ãÑ (y ‚ãÑ z) == (x ‚ãÑ y) ‚ãÑ z</code> </pre><br>  Ein Monoid ist eine Eigenschaft einer assoziativen Operation (d. H. Einer Halbgruppe). <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">x</span></span> ‚ãÑ (y ‚ãÑ z) == (x ‚ãÑ y) ‚ãÑ z</code> </pre><br>  Das hat ein leeres Element, das weder rechts noch links ein Element √§ndert <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">x</span></span> ‚ãÑ empty == x == empty ‚ãÑ x</code> </pre><br></div></div><br>  Sowohl <b>max</b> als auch <b>(+)</b> sind assoziativ, beide haben leere Elemente - <b>Nothing</b> und <b>0</b> . <br><br>  Und die Kombination der Kartierung von Monoiden zusammen mit der Faltung ist <b>faltbar</b> ! <br><br><div class="spoiler">  <b class="spoiler_title">Faltbarer detaillierter</b> <div class="spoiler_text">  Erinnern Sie sich an die Definition des Faltens: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Foldable</span></span></span><span class="hljs-class"> t </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> foldMap :: (<span class="hljs-type"><span class="hljs-type">Monoid</span></span> m) =&gt; (a -&gt; m) -&gt; ta -&gt; m ...</code> </pre><br></div></div><br>  Wenden wir das Faltverhalten auf <b>max</b> und <b>(+) an</b> .  Wir k√∂nnen nicht mehr als eine Implementierung des <b>Word-</b> Monoids organisieren.  Es ist Zeit, die Implementierung der <b>Newtype-</b> Auswahl zu nutzen! <br><br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span> <span class="hljs-comment"><span class="hljs-comment">-- already in Data.Semigroup &amp; Data.Monoid newtype Sum a = Sum {getSum :: a} deriving (Num, Eq, Ord) instance (Num a, Ord a) =&gt; Semigroup (Sum a) where (&lt;&gt;) = (+) instance (Num a, Ord a) =&gt; Monoid (Sum a) where mempty = Sum 0 newtype Max a = Max {getMax :: a} deriving (Num, Eq, Ord) instance (Num a, Ord a) =&gt; Semigroup (Max a) where (&lt;&gt;) = max</span></span></code> </pre><br>  Es ist notwendig, eine Bemerkung zu machen. <br><br>  Tatsache ist, dass wir, um ein Monoid f√ºr den Datentyp <b>Max a zu sein</b> , ein minimales Element ben√∂tigen, dh, dass ein leeres Element existiert.  So kann nur ein begrenzter <b>Max a</b> ein Monoid sein. <br><br><div class="spoiler">  <b class="spoiler_title">Theoretisch korrektes maximales Elementmonoid</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Max</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Max</span></span></span><span class="hljs-class"> a instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class"> a =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Semigroup</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Max</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bounded</span></span></span><span class="hljs-class"> a =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monoid</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Max</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)</span></span></code> </pre><br></div></div><br>  Irgendwie m√ºssen wir also unseren Datentyp konvertieren, damit ein leeres Element erscheint und wir die Koagulation verwenden k√∂nnen. <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- already in Prelude data Maybe a = Nothing | Just a instance Semigroup a =&gt; Semigroup (Maybe a) where Nothing &lt;&gt; b = b b &lt;&gt; Nothing = b (Just a) &lt;&gt; (Just b) = Just (a &lt;&gt; b) instance Semigroup a =&gt; Monoid (Maybe a) where mempty = Nothing -- ------ instance Functor Maybe where fmap _ Nothing = Nothing fmap f (Just b) = Just (fb)</span></span></code> </pre><br>  Das konjugierte <b>Vielleicht-</b> Element verwandelt eine Halbgruppe in ein Monoid! <br><br><div class="spoiler">  <b class="spoiler_title">Liberalisierung von Beschr√§nkungen in neueren Versionen von GHC</b> <div class="spoiler_text">  Zur√ºck in GHC 8.2 war eine Monoid-Typ-Einschr√§nkung erforderlich <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monoid</span></span></span><span class="hljs-class"> a =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monoid</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  was bedeutet, wir brauchten einen anderen neuen Typ: <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- already in Data.Semigroup &amp; Data.Monoid newtype Option a = Option {getOption :: Maybe a} deriving (Eq, Ord, Semigroup) instance (Ord a, Semigroup a) =&gt; Monoid (Option a) where mempty = Option Nothing</span></span></code> </pre><br>  Und es ist bereits in GHC 8.4 viel einfacher, wo nur eine Halbgruppe mit Typbeschr√§nkung erforderlich ist und selbst kein Optionstyp erstellt werden muss. <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Semigroup</span></span></span><span class="hljs-class"> a =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monoid</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)</span></span></code> </pre><br></div></div><br><h4>  Faltreaktion </h4><br>  Nun aktualisieren Sie den Code mithilfe von Reduzierbarkeit und Pfeilen. <br>  Wir erinnern uns, dass (.) Nur eine funktionale Zusammensetzung ist: <br><br><pre> <code class="haskell hljs"> (.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c f . g = \x -&gt; f (gx)</code> </pre> <br>  Und denken <b>Sie</b> daran, dass <b>fmap</b> ein Funktor ist: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fmap</span></span> :: <span class="hljs-type"><span class="hljs-type">Functor</span></span> f =&gt; (a -&gt; b) -&gt; fa -&gt; fb</code> </pre> <br>  und seine Implementierung f√ºr <b>Vielleicht</b> wird etwas h√∂her beschrieben. <br><br><div class="spoiler">  <b class="spoiler_title">Pfeil detaillierter</b> <div class="spoiler_text">  Pfeile sind Eigenschaften einiger Funktionen, mit denen Sie in einem Blockdiagramm damit arbeiten k√∂nnen. <br>  Weitere Details finden Sie hier: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pfeile: Eine allgemeine Schnittstelle zur Berechnung</a> <br>  In unserem Fall verwenden wir die Pfeilfunktion <br>  Also <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Arrow</span></span></span><span class="hljs-class"> (-&gt;)</span></span></code> </pre> <br>  Wir werden die Funktionen verwenden: <br><br><pre> <code class="haskell hljs">(***) :: <span class="hljs-type"><span class="hljs-type">Arrow</span></span> a =&gt; abc -&gt; ab' c' -&gt; a (b, b') (c, c') (&amp;&amp;&amp;) :: <span class="hljs-type"><span class="hljs-type">Arrow</span></span> a =&gt; abc -&gt; abc' -&gt; ab (c, c')</code> </pre> <br>  F√ºr unseren Fall <pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">abc</span></span> == (-&gt;) bc == b -&gt; c</code> </pre> <br>  Dementsprechend reduziert sich die Signatur unserer Funktionen auf: <br><br><pre> <code class="haskell hljs">(***) :: (b -&gt; c) -&gt; (b' -&gt; c') -&gt; ((b, b') -&gt; (c, c')) (&amp;&amp;&amp;) :: (b -&gt; c) -&gt; (b -&gt; c') -&gt; (b -&gt; (c, c'))</code> </pre> <br>  Oder in ganz einfachen Worten, die Funktion <b>(***)</b> kombiniert zwei Funktionen mit einem Argument (und einem Ausgabetyp) zu einer Funktion mit der Arbeit eines Paares von Argumenten am Eingang bzw. am Ausgang, einem Paar von Ausgabetypen. <br><br>  Die Funktion <b>(&amp;&amp;&amp;)</b> ist eine abgespeckte Version <b>(***)</b> , bei der der Typ der Eingabeargumente der beiden Funktionen gleich ist und bei der Eingabe nicht zwei Argumente, sondern ein Argument vorhanden sind. <br></div></div><br>  Insgesamt hat die Vereinigungsfunktion die Form erhalten: <br><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Semigroup <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Monoid <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Arrow aggregate :: [Integer] -&gt; (<span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Integer</span></span>, <span class="hljs-type"><span class="hljs-type">Integer</span></span>) aggregate = (<span class="hljs-title"><span class="hljs-title">fmap</span></span> <span class="hljs-title"><span class="hljs-title">getMax</span></span> *** <span class="hljs-title"><span class="hljs-title">getSum</span></span>) . (<span class="hljs-title"><span class="hljs-title">foldMap</span></span> (<span class="hljs-type"><span class="hljs-type">Just</span></span> . <span class="hljs-type"><span class="hljs-type">Max</span></span> &amp;&amp;&amp; <span class="hljs-type"><span class="hljs-type">Sum</span></span>)) <span class="hljs-comment"><span class="hljs-comment">{- -- for GHC 8.2 aggregate = (fmap getMax . getOption *** getSum) . (foldMap (Option . Just . Max &amp;&amp;&amp; Sum)) -}</span></span></code> </pre><br>  Es stellte sich sehr kurz heraus! <br><br>  Es ist jedoch immer noch anstrengend, Daten von verschachtelten Typen zu verpacken und zu invertieren! <br>  Sie k√∂nnen es weiter reduzieren, und eine ressourcenfreie erzwungene Konvertierung hilft uns! <br><br><h2>  Sichere, ressourcenfreie erzwungene Konvertierung und Typrollen </h2><br>  Es gibt eine Funktion aus dem <b>Unsafe.Coerce-</b> Paket - <b>unsafeCoerce</b> <br><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Unsafe.Coerce(<span class="hljs-title"><span class="hljs-title">unsafeCoerce</span></span>) unsafeCoerce :: a -&gt; b</code> </pre><br>  Die Funktion zwangsweise unsicher konvertiert den Typ: von <b>a</b> nach <b>b</b> . <br>  Tats√§chlich ist die Funktion magisch und weist den Compiler an, Daten vom Typ <b>a als</b> Typ <b>b zu betrachten</b> , ohne die Konsequenzen dieses Schritts zu ber√ºcksichtigen. <br><br>  Es kann verwendet werden, um verschachtelte Typen zu konvertieren, aber Sie m√ºssen sehr vorsichtig sein. <br><br>  Im Jahr 2014 gab es eine Revolution mit <b>Newtype</b> , n√§mlich eine sichere, ressourcenlose erzwungene Konvertierung! <br><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Coerce(<span class="hljs-title"><span class="hljs-title">coerce</span></span>) coerce :: Coercible ab =&gt; a -&gt; b</code> </pre><br>  Diese Funktion hat eine neue √Ñra in der Arbeit mit <b>Newtype eingeleitet</b> . <br><br>  <b>Coercible</b> Forced Converter arbeitet mit Typen, die im Speicher dieselbe Struktur haben.  Es sieht aus wie eine Typklasse, aber tats√§chlich konvertiert der GHC Typen zur Kompilierungszeit und es ist nicht m√∂glich, Instanzen selbst zu definieren. <br>  Mit der Funktion <b>Data.Coerce.coerce</b> k√∂nnen Sie Typen ohne Ressourcen konvertieren. Dazu ben√∂tigen wir jedoch Zugriff auf die <b>Typkonstruktoren</b> . <br><br>  Vereinfachen Sie nun unsere Funktion: <br><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Semigroup <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Monoid <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Arrow <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Coerce aggregate :: [Integer] -&gt; (<span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Integer</span></span>, <span class="hljs-type"><span class="hljs-type">Integer</span></span>) aggregate = coerce . (<span class="hljs-title"><span class="hljs-title">foldMap</span></span> (<span class="hljs-type"><span class="hljs-type">Just</span></span> . <span class="hljs-type"><span class="hljs-type">Max</span></span> &amp;&amp;&amp; <span class="hljs-type"><span class="hljs-type">Sum</span></span>)) <span class="hljs-comment"><span class="hljs-comment">-- coerce :: (Maybe (Max Integer), Sum Integer) -&gt; (Maybe Integer, Integer)</span></span></code> </pre><br>  Wir haben die Routine vermieden, verschachtelte Typen abzurufen, ohne Ressourcen mit nur einer Funktion zu verschwenden. <br><br><h3>  Rollen verschachtelter Datentypen </h3><br>  Mit der <b>Coerce-</b> Funktion <b>k√∂nnen</b> wir die Konvertierung verschachtelter Typen erzwingen. <br>  Aber ist es notwendig, diese Funktion so weit zu nutzen? <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- already in Data.Ord -- Down a - reversed order newtype Down a = Down a deriving (Eq, Show) instance Ord a =&gt; Ord (Down a) where compare (Down x) (Down y) = y `compare` x import Data.List(sort) -- Sorted data Sorted a = Sorted [a] deriving (Show, Eq, Ord) fromList2Sorted :: Ord a =&gt; [a] -&gt; Sorted a fromList2Sorted = Sorted . sort -- minimum: O(1) ! minView :: Sorted a -&gt; Maybe a minView (Sorted []) = Nothing minView (Sorted (a : _)) = Just a</span></span></code> </pre><br>  Semantisch ist es absurd, von <b>Sorted (Down a)</b> nach <b>Sorted a</b> zu konvertieren. <br>  Sie k√∂nnen jedoch versuchen: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> h = fromList2Sorted [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>] :: <span class="hljs-type"><span class="hljs-type">Sorted</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> ghci&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hDown = fromList2Sorted $ fmap <span class="hljs-type"><span class="hljs-type">Down</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>] :: <span class="hljs-type"><span class="hljs-type">Sorted</span></span> (<span class="hljs-type"><span class="hljs-type">Down</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span>) ghci&gt; minView h <span class="hljs-type"><span class="hljs-type">Just</span></span> (<span class="hljs-type"><span class="hljs-type">Down</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) ghci&gt; minView (coerce h :: <span class="hljs-type"><span class="hljs-type">Sorted</span></span> (<span class="hljs-type"><span class="hljs-type">Down</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span>)) <span class="hljs-type"><span class="hljs-type">Just</span></span> (<span class="hljs-type"><span class="hljs-type">Down</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) ghci&gt; minView hDown <span class="hljs-type"><span class="hljs-type">Just</span></span> (<span class="hljs-type"><span class="hljs-type">Down</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre><br>  Alles w√§re in Ordnung, aber die richtige Antwort ist <b>Just (Down 3)</b> . <br>  Um falsches Verhalten auszuschlie√üen, wurden n√§mlich Typrollen eingef√ºhrt. <br><br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE RoleAnnotations #-}</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> role </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sorted</span></span></span><span class="hljs-class"> nominal</span></span></code> </pre><br>  Versuchen wir es jetzt: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; minView (coerce h :: <span class="hljs-type"><span class="hljs-type">Sorted</span></span> (<span class="hljs-type"><span class="hljs-type">Down</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span>)) error: <span class="hljs-type"><span class="hljs-type">Couldn't</span></span> match <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int'</span></span></span><span class="hljs-class"> with '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Down</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int'</span></span></span><span class="hljs-class"> arising from a use of 'coerce'</span></span></code> </pre><br>  Deutlich besser! <br><br>  Insgesamt gibt es 3 Rollen ( <b>Typ Rolle</b> ): <br><br><ul><li>  <b>repr√§sentativ</b> - √§quivalent bei gleicher Darstellung </li><li>  <b>nominal</b> - muss genau den gleichen Typ haben </li><li>  <b>Phantom</b> - unabh√§ngig von echten Inhalten.  Entspricht allem </li></ul><br>  In den meisten F√§llen ist der Compiler intelligent genug, um die Rolle des Typs aufzudecken, aber es kann geholfen werden. <br><br><h2>  Verfeinertes Ableiten des Ableitungsverhaltens </h2><br>  Dank der Erweiterung der <b>DerivingVia-</b> Sprache hat sich die Verteilungsrolle von <b>newtype</b> verbessert. <br><br>  Beginnend mit GHC 8.6, das k√ºrzlich ver√∂ffentlicht wurde, ist diese neue Erweiterung erschienen. <br><br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE DerivingVia #-}</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Id</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkId</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Semigroup</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monoid</span></span></span><span class="hljs-class">) via </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Max</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word</span></span></span></span></code> </pre><br>  Wie Sie sehen k√∂nnen, wird das Typverhalten aufgrund der Verfeinerung der Ausgabe automatisch abgeleitet. <br>  <b>DerivingVia</b> kann auf jeden Typ angewendet werden, der <b>Coercible</b> unterst√ºtzt und <b>vor</b> allem - ganz ohne Ressourcenverbrauch! <br><br>  <b>Dar√ºber</b> hinaus kann <b>DerivingVia</b> nicht nur auf <b>neue</b> Typen <b>angewendet werden</b> , sondern auch auf alle isomorphen Typen, wenn sie <b>Generika-</b> Generika und <b>Zwangskonvertierung mit</b> Zwang unterst√ºtzen. <br><br><h2>  Schlussfolgerungen </h2><br>  Types <b>newtype</b> ist eine leistungsstarke Kraft, die Code erheblich vereinfacht und verbessert, Routine eliminiert und den Ressourcenverbrauch reduziert. <br><br>  <i>Original√ºbersetzung</i> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Gro√ümacht der Newtypes</a> <i>(Hiromi Ishii)</i> <br><br>  <i><b>PS</b> Ich denke, nach diesem Artikel, der vor mehr als einem Jahr [nicht von meinem] Artikel ver√∂ffentlicht wurde, wird die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Magie des Newtype in Haskell</a> √ºber neue Typen etwas klarer!</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425405/">https://habr.com/ru/post/de425405/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425393/index.html">QIWI Server Party 3.0: Bericht + vollst√§ndige Videos aller Berichte</a></li>
<li><a href="../de425395/index.html">10 physikalische Fakten, die Sie in der Schule h√§tten kennen m√ºssen, aber m√∂glicherweise nicht kennen</a></li>
<li><a href="../de425397/index.html">10 Bibliotheken, √ºber die jeder Android-Entwickler Bescheid wissen sollte</a></li>
<li><a href="../de425401/index.html">Bericht des Club of Rome 2018, Kapitel 1.11: Disruptive Technologie und die digitale Revolution</a></li>
<li><a href="../de425403/index.html">Craigslist Creator Finances: Website gegen gef√§lschte Nachrichten, Diskriminierung und Exzesse von Internetgiganten</a></li>
<li><a href="../de425407/index.html">Firecore - ein lustiges Spiel auf AVR</a></li>
<li><a href="../de425409/index.html">DevBoy: einen Signalgenerator machen</a></li>
<li><a href="../de425411/index.html">Scrum ist tot</a></li>
<li><a href="../de425413/index.html">Sind Joons so gut?</a></li>
<li><a href="../de425415/index.html">Perl 5: Wie Makros Fehler versteckten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>