<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💐 ⛓️ 🌳 Newtypen der Großmacht 🧕🏿 👨🏿‍🏫 🧜🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Newtype ist eine spezielle Datentypdeklaration. So dass es nur einen Konstruktor und ein Feld enthält. 



newtype Foo a = Bar a newtype Id = MkId Wor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Newtypen der Großmacht</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425405/">  Newtype ist eine spezielle Datentypdeklaration.  So dass es nur einen Konstruktor und ein Feld enthält. <br><br><pre><code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Foo</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bar</span></span></span><span class="hljs-class"> a </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Id</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkId</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word</span></span></span></span></code> </pre> <br><img src="https://habrastorage.org/webt/_5/zw/n9/_5zwn9jwjjngjatmg_y57dwddaq.png"><br><h3>  Typische Fragen für Neulinge </h3><br>  <i>Was ist der Unterschied zu Datentypdaten?</i> <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Foo</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bar</span></span></span><span class="hljs-class"> a </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Id</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkId</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word</span></span></span></span></code> </pre><br>  Die Hauptspezifität des <b>Newtype</b> besteht darin, dass er aus denselben Teilen besteht wie sein einziges Feld.  Genauer gesagt unterscheidet es sich vom Original auf Typebene, hat jedoch die gleiche Darstellung im Speicher und wird streng (nicht träge) berechnet. <br>  Kurz gesagt - <b>Newtype sind</b> aufgrund ihrer Präsentation effektiver. <br><br>  <i>Ja, es bedeutet mir nichts ... Ich werde <b>Daten verwenden</b></i> <br>  Nein, am Ende können Sie immer die Erweiterung <b>-funpack-strict-fields</b> :) für strenge (nicht faule) Felder <b>aktivieren</b> oder direkt angeben <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Id</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkId</span></span></span><span class="hljs-class"> !</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word</span></span></span></span></code> </pre><br>  Die Leistung des <b>Newtype ist jedoch</b> nicht auf die Recheneffizienz beschränkt.  Sie sind viel stärker! <a name="habracut"></a><br><br><h2>  3 <b>neue</b> Rollen </h2><br><img src="https://habrastorage.org/webt/6t/zt/kp/6tztkpdj2y4fosehxg3_ogz-ark.jpeg"><br><br><h3>  Implementierung ausblenden </h3><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span> Data.Id (<span class="hljs-type"><span class="hljs-type">Id</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Id</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkId</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word</span></span></span></span></code> </pre><br>  <b>newtype</b> unterscheidet sich vom ursprünglichen, intern nur <b>Word</b> . <br>  Wir verstecken den <b>MkId-</b> Konstruktor jedoch außerhalb des Moduls. <br><br><h3>  Implementierung Implementierung </h3><br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Id</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkId</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Num</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  Obwohl dies nicht im Haskell2010-Standard enthalten ist, können Sie durch Erweitern der Ausgabe generischer newTypes automatisch auf das Verhalten von <b>newtype</b> schließen, das dem Verhalten des internen Felds entspricht.  In unserem Fall ist das Verhalten von <b>Gl. Id</b> und <b>Num Id</b> dasselbe wie bei <b>Gl. Wort</b> und <b>Num Wort</b> . <br><br>  Durch den Ausbau der raffinierten Zucht ( <b>DerivingVia</b> ) kann viel mehr erreicht werden, dazu später mehr. <br><br><h3>  Umsetzung der Wahl </h3><br>  In einigen Fällen können Sie trotz eines eigenen Konstruktors Ihre interne Darstellung verwenden. <br><br><h4>  Herausforderung </h4><br>  Es gibt eine Liste von ganzen Zahlen.  Finden Sie den Maximal- und Gesamtbetrag in nur einem Durchgang auf der Liste. <br>  Und verwenden Sie keine <b>Foldl-</b> und <b>Fold-</b> <b>Pakete</b> . <br><br><h4>  Typische Antwort </h4><br>  Natürlich <b>falten</b> !  :) :) <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">foldr</span></span> :: <span class="hljs-type"><span class="hljs-type">Foldable</span></span> t =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; ta -&gt; b <span class="hljs-comment"><span class="hljs-comment">{- -- instance Foldable [] foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b -}</span></span></code> </pre><br>  Und die endgültige Funktion wird folgendermaßen beschrieben: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">aggregate</span></span> :: [<span class="hljs-type"><span class="hljs-type">Integer</span></span>] -&gt; (<span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Integer</span></span>, <span class="hljs-type"><span class="hljs-type">Integer</span></span>) aggregate = foldr (\el (m, s) -&gt; (<span class="hljs-type"><span class="hljs-type">Just</span></span> el `max` m, el + s)) (<span class="hljs-type"><span class="hljs-type">Nothing</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">{- ghci&gt; aggregate [1, 2, 3, 4] (Just 4, 10) -}</span></span></code> </pre><br>  Wenn Sie genau hinschauen, sehen Sie ähnliche Operationen auf beiden Seiten: <b>Nur el `max` m</b> und <b>el + s</b> .  In beiden Fällen Mapping und Binäroperation.  Und die leeren Elemente sind <b>Nichts</b> und <b>0</b> . <br><br>  Ja, das sind Monoide! <br><br><div class="spoiler">  <b class="spoiler_title">Monoid und Halbgruppe im Detail</b> <div class="spoiler_text">  Eine Halbgruppe ist eine Eigenschaft einer assoziativen binären Operation <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">x</span></span> ⋄ (y ⋄ z) == (x ⋄ y) ⋄ z</code> </pre><br>  Ein Monoid ist eine Eigenschaft einer assoziativen Operation (d. H. Einer Halbgruppe). <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">x</span></span> ⋄ (y ⋄ z) == (x ⋄ y) ⋄ z</code> </pre><br>  Das hat ein leeres Element, das weder rechts noch links ein Element ändert <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">x</span></span> ⋄ empty == x == empty ⋄ x</code> </pre><br></div></div><br>  Sowohl <b>max</b> als auch <b>(+)</b> sind assoziativ, beide haben leere Elemente - <b>Nothing</b> und <b>0</b> . <br><br>  Und die Kombination der Kartierung von Monoiden zusammen mit der Faltung ist <b>faltbar</b> ! <br><br><div class="spoiler">  <b class="spoiler_title">Faltbarer detaillierter</b> <div class="spoiler_text">  Erinnern Sie sich an die Definition des Faltens: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Foldable</span></span></span><span class="hljs-class"> t </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> foldMap :: (<span class="hljs-type"><span class="hljs-type">Monoid</span></span> m) =&gt; (a -&gt; m) -&gt; ta -&gt; m ...</code> </pre><br></div></div><br>  Wenden wir das Faltverhalten auf <b>max</b> und <b>(+) an</b> .  Wir können nicht mehr als eine Implementierung des <b>Word-</b> Monoids organisieren.  Es ist Zeit, die Implementierung der <b>Newtype-</b> Auswahl zu nutzen! <br><br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span> <span class="hljs-comment"><span class="hljs-comment">-- already in Data.Semigroup &amp; Data.Monoid newtype Sum a = Sum {getSum :: a} deriving (Num, Eq, Ord) instance (Num a, Ord a) =&gt; Semigroup (Sum a) where (&lt;&gt;) = (+) instance (Num a, Ord a) =&gt; Monoid (Sum a) where mempty = Sum 0 newtype Max a = Max {getMax :: a} deriving (Num, Eq, Ord) instance (Num a, Ord a) =&gt; Semigroup (Max a) where (&lt;&gt;) = max</span></span></code> </pre><br>  Es ist notwendig, eine Bemerkung zu machen. <br><br>  Tatsache ist, dass wir, um ein Monoid für den Datentyp <b>Max a zu sein</b> , ein minimales Element benötigen, dh, dass ein leeres Element existiert.  So kann nur ein begrenzter <b>Max a</b> ein Monoid sein. <br><br><div class="spoiler">  <b class="spoiler_title">Theoretisch korrektes maximales Elementmonoid</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Max</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Max</span></span></span><span class="hljs-class"> a instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class"> a =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Semigroup</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Max</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bounded</span></span></span><span class="hljs-class"> a =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monoid</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Max</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)</span></span></code> </pre><br></div></div><br>  Irgendwie müssen wir also unseren Datentyp konvertieren, damit ein leeres Element erscheint und wir die Koagulation verwenden können. <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- already in Prelude data Maybe a = Nothing | Just a instance Semigroup a =&gt; Semigroup (Maybe a) where Nothing &lt;&gt; b = b b &lt;&gt; Nothing = b (Just a) &lt;&gt; (Just b) = Just (a &lt;&gt; b) instance Semigroup a =&gt; Monoid (Maybe a) where mempty = Nothing -- ------ instance Functor Maybe where fmap _ Nothing = Nothing fmap f (Just b) = Just (fb)</span></span></code> </pre><br>  Das konjugierte <b>Vielleicht-</b> Element verwandelt eine Halbgruppe in ein Monoid! <br><br><div class="spoiler">  <b class="spoiler_title">Liberalisierung von Beschränkungen in neueren Versionen von GHC</b> <div class="spoiler_text">  Zurück in GHC 8.2 war eine Monoid-Typ-Einschränkung erforderlich <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monoid</span></span></span><span class="hljs-class"> a =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monoid</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  was bedeutet, wir brauchten einen anderen neuen Typ: <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- already in Data.Semigroup &amp; Data.Monoid newtype Option a = Option {getOption :: Maybe a} deriving (Eq, Ord, Semigroup) instance (Ord a, Semigroup a) =&gt; Monoid (Option a) where mempty = Option Nothing</span></span></code> </pre><br>  Und es ist bereits in GHC 8.4 viel einfacher, wo nur eine Halbgruppe mit Typbeschränkung erforderlich ist und selbst kein Optionstyp erstellt werden muss. <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Semigroup</span></span></span><span class="hljs-class"> a =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monoid</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)</span></span></code> </pre><br></div></div><br><h4>  Faltreaktion </h4><br>  Nun aktualisieren Sie den Code mithilfe von Reduzierbarkeit und Pfeilen. <br>  Wir erinnern uns, dass (.) Nur eine funktionale Zusammensetzung ist: <br><br><pre> <code class="haskell hljs"> (.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c f . g = \x -&gt; f (gx)</code> </pre> <br>  Und denken <b>Sie</b> daran, dass <b>fmap</b> ein Funktor ist: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fmap</span></span> :: <span class="hljs-type"><span class="hljs-type">Functor</span></span> f =&gt; (a -&gt; b) -&gt; fa -&gt; fb</code> </pre> <br>  und seine Implementierung für <b>Vielleicht</b> wird etwas höher beschrieben. <br><br><div class="spoiler">  <b class="spoiler_title">Pfeil detaillierter</b> <div class="spoiler_text">  Pfeile sind Eigenschaften einiger Funktionen, mit denen Sie in einem Blockdiagramm damit arbeiten können. <br>  Weitere Details finden Sie hier: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pfeile: Eine allgemeine Schnittstelle zur Berechnung</a> <br>  In unserem Fall verwenden wir die Pfeilfunktion <br>  Also <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Arrow</span></span></span><span class="hljs-class"> (-&gt;)</span></span></code> </pre> <br>  Wir werden die Funktionen verwenden: <br><br><pre> <code class="haskell hljs">(***) :: <span class="hljs-type"><span class="hljs-type">Arrow</span></span> a =&gt; abc -&gt; ab' c' -&gt; a (b, b') (c, c') (&amp;&amp;&amp;) :: <span class="hljs-type"><span class="hljs-type">Arrow</span></span> a =&gt; abc -&gt; abc' -&gt; ab (c, c')</code> </pre> <br>  Für unseren Fall <pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">abc</span></span> == (-&gt;) bc == b -&gt; c</code> </pre> <br>  Dementsprechend reduziert sich die Signatur unserer Funktionen auf: <br><br><pre> <code class="haskell hljs">(***) :: (b -&gt; c) -&gt; (b' -&gt; c') -&gt; ((b, b') -&gt; (c, c')) (&amp;&amp;&amp;) :: (b -&gt; c) -&gt; (b -&gt; c') -&gt; (b -&gt; (c, c'))</code> </pre> <br>  Oder in ganz einfachen Worten, die Funktion <b>(***)</b> kombiniert zwei Funktionen mit einem Argument (und einem Ausgabetyp) zu einer Funktion mit der Arbeit eines Paares von Argumenten am Eingang bzw. am Ausgang, einem Paar von Ausgabetypen. <br><br>  Die Funktion <b>(&amp;&amp;&amp;)</b> ist eine abgespeckte Version <b>(***)</b> , bei der der Typ der Eingabeargumente der beiden Funktionen gleich ist und bei der Eingabe nicht zwei Argumente, sondern ein Argument vorhanden sind. <br></div></div><br>  Insgesamt hat die Vereinigungsfunktion die Form erhalten: <br><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Semigroup <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Monoid <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Arrow aggregate :: [Integer] -&gt; (<span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Integer</span></span>, <span class="hljs-type"><span class="hljs-type">Integer</span></span>) aggregate = (<span class="hljs-title"><span class="hljs-title">fmap</span></span> <span class="hljs-title"><span class="hljs-title">getMax</span></span> *** <span class="hljs-title"><span class="hljs-title">getSum</span></span>) . (<span class="hljs-title"><span class="hljs-title">foldMap</span></span> (<span class="hljs-type"><span class="hljs-type">Just</span></span> . <span class="hljs-type"><span class="hljs-type">Max</span></span> &amp;&amp;&amp; <span class="hljs-type"><span class="hljs-type">Sum</span></span>)) <span class="hljs-comment"><span class="hljs-comment">{- -- for GHC 8.2 aggregate = (fmap getMax . getOption *** getSum) . (foldMap (Option . Just . Max &amp;&amp;&amp; Sum)) -}</span></span></code> </pre><br>  Es stellte sich sehr kurz heraus! <br><br>  Es ist jedoch immer noch anstrengend, Daten von verschachtelten Typen zu verpacken und zu invertieren! <br>  Sie können es weiter reduzieren, und eine ressourcenfreie erzwungene Konvertierung hilft uns! <br><br><h2>  Sichere, ressourcenfreie erzwungene Konvertierung und Typrollen </h2><br>  Es gibt eine Funktion aus dem <b>Unsafe.Coerce-</b> Paket - <b>unsafeCoerce</b> <br><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Unsafe.Coerce(<span class="hljs-title"><span class="hljs-title">unsafeCoerce</span></span>) unsafeCoerce :: a -&gt; b</code> </pre><br>  Die Funktion zwangsweise unsicher konvertiert den Typ: von <b>a</b> nach <b>b</b> . <br>  Tatsächlich ist die Funktion magisch und weist den Compiler an, Daten vom Typ <b>a als</b> Typ <b>b zu betrachten</b> , ohne die Konsequenzen dieses Schritts zu berücksichtigen. <br><br>  Es kann verwendet werden, um verschachtelte Typen zu konvertieren, aber Sie müssen sehr vorsichtig sein. <br><br>  Im Jahr 2014 gab es eine Revolution mit <b>Newtype</b> , nämlich eine sichere, ressourcenlose erzwungene Konvertierung! <br><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Coerce(<span class="hljs-title"><span class="hljs-title">coerce</span></span>) coerce :: Coercible ab =&gt; a -&gt; b</code> </pre><br>  Diese Funktion hat eine neue Ära in der Arbeit mit <b>Newtype eingeleitet</b> . <br><br>  <b>Coercible</b> Forced Converter arbeitet mit Typen, die im Speicher dieselbe Struktur haben.  Es sieht aus wie eine Typklasse, aber tatsächlich konvertiert der GHC Typen zur Kompilierungszeit und es ist nicht möglich, Instanzen selbst zu definieren. <br>  Mit der Funktion <b>Data.Coerce.coerce</b> können Sie Typen ohne Ressourcen konvertieren. Dazu benötigen wir jedoch Zugriff auf die <b>Typkonstruktoren</b> . <br><br>  Vereinfachen Sie nun unsere Funktion: <br><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Semigroup <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Monoid <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Arrow <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Coerce aggregate :: [Integer] -&gt; (<span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Integer</span></span>, <span class="hljs-type"><span class="hljs-type">Integer</span></span>) aggregate = coerce . (<span class="hljs-title"><span class="hljs-title">foldMap</span></span> (<span class="hljs-type"><span class="hljs-type">Just</span></span> . <span class="hljs-type"><span class="hljs-type">Max</span></span> &amp;&amp;&amp; <span class="hljs-type"><span class="hljs-type">Sum</span></span>)) <span class="hljs-comment"><span class="hljs-comment">-- coerce :: (Maybe (Max Integer), Sum Integer) -&gt; (Maybe Integer, Integer)</span></span></code> </pre><br>  Wir haben die Routine vermieden, verschachtelte Typen abzurufen, ohne Ressourcen mit nur einer Funktion zu verschwenden. <br><br><h3>  Rollen verschachtelter Datentypen </h3><br>  Mit der <b>Coerce-</b> Funktion <b>können</b> wir die Konvertierung verschachtelter Typen erzwingen. <br>  Aber ist es notwendig, diese Funktion so weit zu nutzen? <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- already in Data.Ord -- Down a - reversed order newtype Down a = Down a deriving (Eq, Show) instance Ord a =&gt; Ord (Down a) where compare (Down x) (Down y) = y `compare` x import Data.List(sort) -- Sorted data Sorted a = Sorted [a] deriving (Show, Eq, Ord) fromList2Sorted :: Ord a =&gt; [a] -&gt; Sorted a fromList2Sorted = Sorted . sort -- minimum: O(1) ! minView :: Sorted a -&gt; Maybe a minView (Sorted []) = Nothing minView (Sorted (a : _)) = Just a</span></span></code> </pre><br>  Semantisch ist es absurd, von <b>Sorted (Down a)</b> nach <b>Sorted a</b> zu konvertieren. <br>  Sie können jedoch versuchen: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> h = fromList2Sorted [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>] :: <span class="hljs-type"><span class="hljs-type">Sorted</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> ghci&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hDown = fromList2Sorted $ fmap <span class="hljs-type"><span class="hljs-type">Down</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>] :: <span class="hljs-type"><span class="hljs-type">Sorted</span></span> (<span class="hljs-type"><span class="hljs-type">Down</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span>) ghci&gt; minView h <span class="hljs-type"><span class="hljs-type">Just</span></span> (<span class="hljs-type"><span class="hljs-type">Down</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) ghci&gt; minView (coerce h :: <span class="hljs-type"><span class="hljs-type">Sorted</span></span> (<span class="hljs-type"><span class="hljs-type">Down</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span>)) <span class="hljs-type"><span class="hljs-type">Just</span></span> (<span class="hljs-type"><span class="hljs-type">Down</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) ghci&gt; minView hDown <span class="hljs-type"><span class="hljs-type">Just</span></span> (<span class="hljs-type"><span class="hljs-type">Down</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre><br>  Alles wäre in Ordnung, aber die richtige Antwort ist <b>Just (Down 3)</b> . <br>  Um falsches Verhalten auszuschließen, wurden nämlich Typrollen eingeführt. <br><br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE RoleAnnotations #-}</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> role </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sorted</span></span></span><span class="hljs-class"> nominal</span></span></code> </pre><br>  Versuchen wir es jetzt: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; minView (coerce h :: <span class="hljs-type"><span class="hljs-type">Sorted</span></span> (<span class="hljs-type"><span class="hljs-type">Down</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span>)) error: <span class="hljs-type"><span class="hljs-type">Couldn't</span></span> match <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int'</span></span></span><span class="hljs-class"> with '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Down</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int'</span></span></span><span class="hljs-class"> arising from a use of 'coerce'</span></span></code> </pre><br>  Deutlich besser! <br><br>  Insgesamt gibt es 3 Rollen ( <b>Typ Rolle</b> ): <br><br><ul><li>  <b>repräsentativ</b> - äquivalent bei gleicher Darstellung </li><li>  <b>nominal</b> - muss genau den gleichen Typ haben </li><li>  <b>Phantom</b> - unabhängig von echten Inhalten.  Entspricht allem </li></ul><br>  In den meisten Fällen ist der Compiler intelligent genug, um die Rolle des Typs aufzudecken, aber es kann geholfen werden. <br><br><h2>  Verfeinertes Ableiten des Ableitungsverhaltens </h2><br>  Dank der Erweiterung der <b>DerivingVia-</b> Sprache hat sich die Verteilungsrolle von <b>newtype</b> verbessert. <br><br>  Beginnend mit GHC 8.6, das kürzlich veröffentlicht wurde, ist diese neue Erweiterung erschienen. <br><br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE DerivingVia #-}</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Id</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkId</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Semigroup</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monoid</span></span></span><span class="hljs-class">) via </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Max</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word</span></span></span></span></code> </pre><br>  Wie Sie sehen können, wird das Typverhalten aufgrund der Verfeinerung der Ausgabe automatisch abgeleitet. <br>  <b>DerivingVia</b> kann auf jeden Typ angewendet werden, der <b>Coercible</b> unterstützt und <b>vor</b> allem - ganz ohne Ressourcenverbrauch! <br><br>  <b>Darüber</b> hinaus kann <b>DerivingVia</b> nicht nur auf <b>neue</b> Typen <b>angewendet werden</b> , sondern auch auf alle isomorphen Typen, wenn sie <b>Generika-</b> Generika und <b>Zwangskonvertierung mit</b> Zwang unterstützen. <br><br><h2>  Schlussfolgerungen </h2><br>  Types <b>newtype</b> ist eine leistungsstarke Kraft, die Code erheblich vereinfacht und verbessert, Routine eliminiert und den Ressourcenverbrauch reduziert. <br><br>  <i>Originalübersetzung</i> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Großmacht der Newtypes</a> <i>(Hiromi Ishii)</i> <br><br>  <i><b>PS</b> Ich denke, nach diesem Artikel, der vor mehr als einem Jahr [nicht von meinem] Artikel veröffentlicht wurde, wird die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Magie des Newtype in Haskell</a> über neue Typen etwas klarer!</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425405/">https://habr.com/ru/post/de425405/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425393/index.html">QIWI Server Party 3.0: Bericht + vollständige Videos aller Berichte</a></li>
<li><a href="../de425395/index.html">10 physikalische Fakten, die Sie in der Schule hätten kennen müssen, aber möglicherweise nicht kennen</a></li>
<li><a href="../de425397/index.html">10 Bibliotheken, über die jeder Android-Entwickler Bescheid wissen sollte</a></li>
<li><a href="../de425401/index.html">Bericht des Club of Rome 2018, Kapitel 1.11: Disruptive Technologie und die digitale Revolution</a></li>
<li><a href="../de425403/index.html">Craigslist Creator Finances: Website gegen gefälschte Nachrichten, Diskriminierung und Exzesse von Internetgiganten</a></li>
<li><a href="../de425407/index.html">Firecore - ein lustiges Spiel auf AVR</a></li>
<li><a href="../de425409/index.html">DevBoy: einen Signalgenerator machen</a></li>
<li><a href="../de425411/index.html">Scrum ist tot</a></li>
<li><a href="../de425413/index.html">Sind Joons so gut?</a></li>
<li><a href="../de425415/index.html">Perl 5: Wie Makros Fehler versteckten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>