<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥛 👊🏻 👨🏿‍🏫 Node.js Handbuch, Teil 7: Asynchrone Programmierung 👋🏽 🕺🏼 🐓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In der Übersetzung des siebten Teils des Node.js-Handbuchs werden wir heute über asynchrone Programmierung sprechen, Probleme wie die Verwendung von R...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Node.js Handbuch, Teil 7: Asynchrone Programmierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/424555/">  In der Übersetzung des siebten Teils des Node.js-Handbuchs werden wir heute über asynchrone Programmierung sprechen, Probleme wie die Verwendung von Rückrufen, Versprechungen und das Konstrukt async / await berücksichtigen und die Arbeit mit Ereignissen diskutieren. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/he/di/2j/hedi2j_qyfbnwfo_jqnnqd3ub6o.png"></a> <br><br><div class="spoiler">  <b class="spoiler_title">[Wir empfehlen Ihnen zu lesen] Andere Teile des Zyklus</b> <div class="spoiler_text">  Teil 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Allgemeine Informationen und erste Schritte</a> <br>  Teil 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JavaScript, V8, einige Entwicklungstricks</a> <br>  Teil 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hosting, REPL, Arbeit mit der Konsole, Module</a> <br>  Teil 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dateien npm, package.json und package-lock.json</a> <br>  Teil 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">npm und npx</a> <br>  Teil 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisschleife, Aufrufstapel, Timer</a> <br>  Teil 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Asynchrone Programmierung</a> <br>  Teil 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Node.js-Handbuch, Teil 8: HTTP- und WebSocket-Protokolle</a> <br>  Teil 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Node.js-Handbuch, Teil 9: Arbeiten mit dem Dateisystem</a> <br>  Teil 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Node.js-Handbuch, Teil 10: Standardmodule, Streams, Datenbanken, NODE_ENV</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vollständiges PDF des Node.js-Handbuchs</a> <br></div></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Asynchronität in Programmiersprachen</font> </h2><br>  JavaScript selbst ist eine synchrone Single-Threaded-Programmiersprache.  Dies bedeutet, dass Sie keine neuen Threads im Code erstellen können, die parallel ausgeführt werden.  Computer sind jedoch von Natur aus asynchron.  Das heißt, bestimmte Aktionen können unabhängig vom Ablauf der Hauptprogrammausführung ausgeführt werden.  In modernen Computern wird jedem Programm eine bestimmte Prozessorzeit zugewiesen. Wenn diese Zeit abgelaufen ist, gibt das System auch für eine Weile Ressourcen an ein anderes Programm weiter.  Solche Umschaltungen werden zyklisch durchgeführt, so schnell, dass eine Person es einfach nicht bemerken kann. Daher denken wir, dass unsere Computer viele Programme gleichzeitig ausführen.  Dies ist jedoch eine Illusion (ganz zu schweigen von Multiprozessor-Maschinen). <br><br>  Im Darm von Programmen werden Interrupts verwendet - Signale, die an den Prozessor übertragen werden und die Aufmerksamkeit des Systems auf sich ziehen.  Wir werden nicht auf Details eingehen. Das Wichtigste ist, sich daran zu erinnern, dass asynchrones Verhalten, wenn ein Programm angehalten wird, bis es Prozessorressourcen benötigt, völlig normal ist.  Zu einem Zeitpunkt, an dem das Programm das System nicht mit Arbeit lädt, kann der Computer andere Probleme lösen.  Wenn ein Programm bei diesem Ansatz beispielsweise auf eine Antwort auf eine an ihn gerichtete Netzwerkanforderung wartet, blockiert es den Prozessor erst, wenn eine Antwort empfangen wird. <br><br>  Programmiersprachen sind in der Regel asynchron. Einige von ihnen bieten dem Programmierer die Möglichkeit, asynchrone Mechanismen mithilfe der integrierten Sprachtools oder spezialisierter Bibliotheken zu steuern.  Wir sprechen über Sprachen wie C, Java, C #, PHP, Go, Ruby, Swift, Python.  Mit einigen von ihnen können Sie asynchron programmieren, Threads verwenden und neue Prozesse starten. <br><br><h2>  <font color="#3AC1EF">JavaScript-Asynchronität</font> </h2><br>  Wie bereits erwähnt, ist JavaScript eine synchrone Sprache mit einem Thread.  In JS geschriebene Codezeilen werden in der Reihenfolge ausgeführt, in der sie nacheinander im Text erscheinen.  Hier ist beispielsweise ein ganz normales JS-Programm, das dieses Verhalten demonstriert: <br><br><pre><code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c = a * b console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(c) doSomething()</code> </pre> <br>  JavaScript wurde jedoch für die Verwendung in Browsern erstellt.  Die Hauptaufgabe bestand zu Beginn darin, die Verarbeitung von Ereignissen im Zusammenhang mit Benutzeraktivitäten zu organisieren.  Dies sind beispielsweise Ereignisse wie <code>onClick</code> , <code>onMouseOver</code> , <code>onChange</code> , <code>onSubmit</code> usw.  Wie können solche Probleme im Rahmen eines synchronen Programmiermodells gelöst werden? <br><br>  Die Antwort liegt in der Umgebung, in der JavaScript ausgeführt wird.  Mit dem Browser können Sie nämlich solche Probleme effektiv lösen und dem Programmierer die entsprechenden APIs zur Verfügung stellen. <br><br>  In der Umgebung von Node.js gibt es Tools zum Ausführen nicht blockierender E / A-Vorgänge, z. B. Arbeiten mit Dateien, Organisieren des Datenaustauschs über ein Netzwerk usw. <br><br><h2>  <font color="#3AC1EF">Rückrufe</font> </h2><br>  Wenn wir über browserbasiertes JavaScript sprechen, kann festgestellt werden, dass es unmöglich ist, im Voraus zu wissen, wann der Benutzer auf eine Schaltfläche klickt.  Um sicherzustellen, dass das System auf ein solches Ereignis reagiert, wird ein Handler dafür erstellt. <br><br>  Der Ereignishandler akzeptiert eine Funktion, die beim Auftreten des Ereignisses aufgerufen wird.  Es sieht so aus: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'button'</span></span>).addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    })</code> </pre> <br>  Solche Funktionen werden auch Rückruffunktionen oder Rückrufe genannt. <br><br>  Ein Rückruf ist eine reguläre Funktion, die als Wert an eine andere Funktion übergeben wird.  Es wird nur aufgerufen, wenn ein bestimmtes Ereignis eintritt.  JavaScript implementiert das Konzept erstklassiger Funktionen.  Solche Funktionen können Variablen zugewiesen und an andere Funktionen übergeben werden (sogenannte Funktionen höherer Ordnung). <br><br>  Ein gängiger Ansatz bei der clientseitigen JavaScript-Entwicklung besteht darin, dass der gesamte Clientcode in einen Listener des <code>load</code> eines <code>window</code> wird, der den Rückruf aufruft, der an ihn übergeben wird, nachdem die Seite betriebsbereit ist: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'load'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     })</code> </pre> <br>  Rückrufe werden überall verwendet und nicht nur zur Behandlung von DOM-Ereignissen.  Zum Beispiel haben wir uns bereits mit ihrer Verwendung in Timern getroffen: <br><br><pre> <code class="hljs javascript">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   2  }, 2000)</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">XHR-Anforderungen verwenden</a> auch Rückrufe.  In diesem Fall sieht es so aus, als würde der entsprechenden Eigenschaft eine Funktion zugewiesen.  Eine ähnliche Funktion wird aufgerufen, wenn ein bestimmtes Ereignis eintritt.  Im folgenden Beispiel handelt es sich bei einem solchen Ereignis um eine Änderung des Anforderungsstatus: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> xhr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest() xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xhr.readyState === <span class="hljs-number"><span class="hljs-number">4</span></span>) {   xhr.status === <span class="hljs-number"><span class="hljs-number">200</span></span> ? <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(xhr.responseText) : <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(<span class="hljs-string"><span class="hljs-string">'error'</span></span>) } } xhr.open(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'https://yoursite.com'</span></span>) xhr.send()</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Fehlerbehandlung bei Rückrufen</font> </h3><br>  Lassen Sie uns darüber sprechen, wie Fehler in Rückrufen behandelt werden.  Es gibt eine gemeinsame Strategie zur Behandlung solcher Fehler, die auch in Node.js verwendet wird.  Es besteht darin, dass der erste Parameter einer Rückruffunktion ein Fehlerobjekt ist.  Wenn keine Fehler <code>null</code> wird <code>null</code> in diesen Parameter geschrieben.  Andernfalls wird ein Fehlerobjekt angezeigt, das seine Beschreibung und zusätzliche Informationen dazu enthält.  So sieht es aus: <br><br><pre> <code class="hljs coffeescript">fs.readFile(<span class="hljs-string"><span class="hljs-string">'/file.json'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, data)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) {   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data) })</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Rückrufproblem</font> </h3><br>  Rückrufe sind in einfachen Situationen bequem zu verwenden.  Jeder Rückruf ist jedoch eine zusätzliche Ebene der Codeverschachtelung.  Wenn mehrere verschachtelte Rückrufe verwendet werden, führt dies schnell zu einer erheblichen Komplikation der Codestruktur: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'load'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'button'</span></span>).addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {     items.forEach(item =&gt; {       <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>,  -      })   }, <span class="hljs-number"><span class="hljs-number">2000</span></span>) }) })</code> </pre> <br>  In diesem Beispiel werden nur 4 Codeebenen angezeigt. In der Praxis kann es jedoch zu einer großen Anzahl von Ebenen kommen, die normalerweise als "Rückrufhölle" bezeichnet werden.  Sie können dieses Problem mit anderen Sprachkonstrukten lösen. <br><br><h2>  <font color="#3AC1EF">Versprechen und asynchron / warten</font> </h2><br>  Beginnend mit dem ES6-Standard führt JavaScript neue Funktionen ein, die das Schreiben von asynchronem Code erleichtern und Rückrufe überflüssig machen.  Wir sprechen über die Versprechen, die in ES6 erschienen sind, und das asynchrone / warten-Konstrukt, das in ES8 erschienen ist. <br><br><h3>  <font color="#3AC1EF">▍ Versprechen</font> </h3><br>  Versprechen (Versprechenobjekte) sind eine der Möglichkeiten, mit asynchronen Softwarekonstrukten in JavaScript zu arbeiten, wodurch die Verwendung von Rückrufen im Allgemeinen reduziert wird. <br><br><h4>  Bekanntschaft mit Versprechen </h4><br>  Versprechen werden normalerweise als Proxy-Objekte für bestimmte Werte definiert, deren Erscheinungsbild in Zukunft erwartet wird.  Versprechen werden auch "Versprechen" oder "versprochene Ergebnisse" genannt.  Obwohl dieses Konzept seit vielen Jahren besteht, wurden Versprechen erst in ES2015 standardisiert und der Sprache hinzugefügt.  In ES2017 ist das asynchrone / wartende Design erschienen, das auf Versprechungen basiert und als praktischer Ersatz angesehen werden kann.  Selbst wenn Sie nicht vorhaben, regelmäßige Versprechen zu verwenden, ist daher ein Verständnis der Funktionsweise wichtig, um das asynchrone / warten-Konstrukt effektiv nutzen zu können. <br><br><h4>  Wie Versprechen funktionieren </h4><br>  Nachdem ein Versprechen aufgerufen wurde, geht es in einen ausstehenden Zustand über.  Dies bedeutet, dass die Funktion, die das Versprechen verursacht hat, weiterhin ausgeführt wird, während einige Berechnungen im Versprechen ausgeführt werden, wonach das Versprechen darüber informiert.  Wenn die vom Versprechen ausgeführte Operation erfolgreich abgeschlossen wurde, wird das Versprechen in den erfüllten Zustand versetzt.  Ein solches Versprechen soll erfolgreich gelöst worden sein.  Wenn der Vorgang mit einem Fehler abgeschlossen wird, wird das Versprechen in den abgelehnten Zustand versetzt. <br><br>  Sprechen wir über die Arbeit mit Versprechungen. <br><br><h4>  Versprechen erstellen </h4><br>  Die API zum Arbeiten mit Versprechungen gibt uns den entsprechenden Konstruktor, der durch einen Befehl der Form <code>new Promise()</code> aufgerufen wird.  So entstehen Versprechen: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> done = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isItDoneYet = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (done) {     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> workDone = <span class="hljs-string"><span class="hljs-string">'Here is the thing I built'</span></span>     resolve(workDone)   } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> why = <span class="hljs-string"><span class="hljs-string">'Still working on something else'</span></span>     reject(why)   } } )</code> </pre> <br>  Promis überprüft die globale Konstante und wenn ihr Wert <code>true</code> , wird sie erfolgreich aufgelöst.  Andernfalls wird das Versprechen abgelehnt.  Mit den <code>resolve</code> und <code>reject</code> , die Funktionen sind, können wir Werte aus dem Versprechen zurückgeben.  In diesem Fall geben wir eine Zeichenfolge zurück, aber hier kann ein Objekt verwendet werden. <br><br><h4>  Mit Versprechen arbeiten </h4><br>  Wir haben oben ein Versprechen erstellt und überlegen, jetzt damit zu arbeiten.  Es sieht so aus: <br><br><pre> <code class="hljs coffeescript">const isItDoneYet = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise( <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>... ) const checkIfItsDone = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { isItDoneYet   .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ok)</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(ok)   })   .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err)   }) } checkIfItsDone()</code> </pre> <br>  Das Aufrufen von <code>checkIfItsDone()</code> führt zur Ausführung des isItDoneYet <code>isItDoneYet()</code> -Versprechens und zur Organisation des Wartens auf dessen Lösung.  Wenn das Versprechen erfolgreich aufgelöst wird, funktioniert der an die <code>.then()</code> -Methode übergebene Rückruf.  Wenn ein Fehler auftritt, <code>.catch()</code> das Versprechen abgelehnt wird, kann es in der an die <code>.catch()</code> -Methode übergebenen Funktion verarbeitet werden. <br><br><h4>  Verkettungsversprechen </h4><br>  Versprechensmethoden geben Versprechungen zurück, sodass Sie sie zu Ketten kombinieren können.  Ein gutes Beispiel für dieses Verhalten ist der browserbasierte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">API-Abruf</a> , bei dem es sich um eine Abstraktionsschicht über <code>XMLHttpRequest</code> .  Es gibt ein ziemlich beliebtes npm-Paket für Node.js, das die Fetch-API implementiert, auf die wir später noch eingehen werden.  Diese API kann verwendet werden, um bestimmte Netzwerkressourcen zu laden und dank der Möglichkeit, Versprechen in Ketten zu kombinieren, die nachfolgende Verarbeitung heruntergeladener Daten zu organisieren.  Wenn Sie die Fetch-API über einen Aufruf der Funktion <code>fetch()</code> aufrufen, wird ein Versprechen erstellt. <br><br>  Betrachten Sie das folgende Beispiel für Verkettungsversprechen: <br><br><pre> <code class="hljs coffeescript">const fetch = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'node-fetch'</span></span>) const status = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.status &gt;= <span class="hljs-number"><span class="hljs-number">200</span></span> &amp;&amp; response.status &lt; <span class="hljs-number"><span class="hljs-number">300</span></span>) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Promise.resolve(response) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Promise.reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(response.statusText)) } const json = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response)</span></span></span><span class="hljs-function"> =&gt;</span></span> response.json() fetch(<span class="hljs-string"><span class="hljs-string">'https://jsonplaceholder.typicode.com/todos'</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(status) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(json) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Request succeeded with JSON response'</span></span>, data) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Request failed'</span></span>, error) })</code> </pre> <br>  Hier verwenden wir das npm-Paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">node-fetch</a> und die Ressource <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">jsonplaceholder.typicode.com</a> als Quelle für JSON-Daten. <br><br>  In diesem Beispiel wird die Funktion <code>fetch()</code> verwendet, um ein TODO-Listenelement mithilfe einer Versprechungskette zu laden.  Nach dem Ausführen von <code>fetch()</code> wird eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Antwort</a> zurückgegeben, die viele Eigenschaften aufweist, von denen wir Folgendes interessieren: <br><br><ul><li>  <code>status</code> ist ein numerischer Wert, der den HTTP-Statuscode darstellt. </li><li>  <code>statusText</code> - Eine <code>statusText</code> des HTTP-Statuscodes, die durch die Zeichenfolge <code>OK</code> wenn die Anforderung erfolgreich war. </li></ul><br>  Das <code>response</code> verfügt über eine <code>json()</code> -Methode, die ein Versprechen zurückgibt, bei dessen Auflösung der verarbeitete Inhalt des Anforderungshauptteils im JSON-Format dargestellt wird. <br><br>  Vor diesem Hintergrund beschreiben wir, was in diesem Code geschieht.  Das erste Versprechen in der Kette wird durch die von uns angekündigte Funktion <code>status()</code> , die den Status der Antwort überprüft. Wenn angezeigt wird, dass die Anforderung fehlgeschlagen ist (dh der HTTP-Statuscode liegt nicht im Bereich zwischen 200 und 299), wird das Versprechen abgelehnt.  Diese Operation führt dazu, dass andere <code>.then()</code> in der Versprechenskette nicht ausgeführt werden und wir sofort zur <code>.catch()</code> -Methode gelangen, die zusammen mit der Fehlermeldung den Text <code>Request failed</code> an die Konsole ausgibt. <br><br>  Wenn der HTTP-Statuscode zu uns passt, wird die von uns deklarierte Funktion <code>json()</code> aufgerufen.  Da das vorherige Versprechen bei erfolgreicher Auflösung ein <code>response</code> zurückgibt, verwenden wir es als Eingabewert für das zweite Versprechen. <br><br>  In diesem Fall geben wir die verarbeiteten JSON-Daten zurück, sodass das dritte Versprechen sie erhält. Anschließend wird in der Konsole eine Meldung angezeigt, dass aufgrund der Anforderung die erforderlichen Daten abgerufen werden konnten. <br><br><h4>  Fehlerbehandlung </h4><br>  Im vorherigen Beispiel hatten wir eine <code>.catch()</code> -Methode, die an eine Kette von Versprechungen angehängt war.  Wenn etwas in der Kette der Versprechen schief geht und ein Fehler auftritt oder wenn sich herausstellt, dass eines der Versprechen abgelehnt wird, wird die Kontrolle auf den nächsten Ausdruck <code>.catch()</code> .  Hier ist die Situation, in der ein Fehler in einem Versprechen auftritt: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve, reject)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(<span class="hljs-string"><span class="hljs-string">'Error'</span></span>) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br>  Hier ist ein Beispiel für das Auslösen von <code>.catch()</code> nach dem Ablehnen eines Versprechens: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve, reject)</span></span></span><span class="hljs-function"> =&gt;</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Error'</span></span>) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br><h4>  Kaskadierende Fehlerbehandlung </h4><br>  Was <code>.catch()</code> wenn im Ausdruck <code>.catch()</code> ein Fehler auftritt?  Um diesen Fehler zu behandeln, können Sie einen weiteren Ausdruck <code>.catch()</code> in die Kette der Versprechen aufnehmen (und dann der Kette so viele <code>.catch()</code> , wie erforderlich): <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve, reject)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(<span class="hljs-string"><span class="hljs-string">'Error'</span></span>) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(<span class="hljs-string"><span class="hljs-string">'Error'</span></span>) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br>  Schauen wir uns nun einige nützliche Methoden an, mit denen Versprechen verwaltet werden. <br><br><h4>  Promise.all () </h4><br>  Wenn Sie nach dem Auflösen mehrerer Versprechen eine Aktion ausführen müssen, können Sie dies mit dem Befehl <code>Promise.all()</code> tun.  Betrachten Sie ein Beispiel: <br><br><pre> <code class="hljs coffeescript">const f1 = fetch(<span class="hljs-string"><span class="hljs-string">'https://jsonplaceholder.typicode.com/todos/1'</span></span>) const f2 = fetch(<span class="hljs-string"><span class="hljs-string">'https://jsonplaceholder.typicode.com/todos/2'</span></span>) Promise.all([f1, f2]).<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(res)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Array of results'</span></span>, res) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br>  In ES2015 wurde die Syntax der destruktiven Zuweisung angezeigt. Mit ihr können Sie Konstruktionen in der folgenden Form erstellen: <br><br><pre> <code class="hljs powershell">Promise.all([<span class="hljs-type"><span class="hljs-type">f1</span></span>, <span class="hljs-type"><span class="hljs-type">f2</span></span>]).then(([<span class="hljs-type"><span class="hljs-type">res1</span></span>, <span class="hljs-type"><span class="hljs-type">res2</span></span>]) =&gt; {   console.log(<span class="hljs-string"><span class="hljs-string">'Results'</span></span>, res1, res2) })</code> </pre> <br>  Hier haben wir als Beispiel den API-Abruf betrachtet, aber mit <code>Promise.all()</code> können Sie natürlich mit allen Versprechungen arbeiten. <br><br><h4>  Promise.race () </h4><br>  Mit dem Befehl <code>Promise.race()</code> können Sie die angegebene Aktion ausführen, nachdem eines der an ihn übergebenen Versprechen aufgelöst wurde.  Der entsprechende Rückruf mit den Ergebnissen dieses ersten Versprechens wird nur einmal aufgerufen.  Betrachten Sie ein Beispiel: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> first = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> {   setTimeout(resolve, <span class="hljs-number"><span class="hljs-number">500</span></span>, <span class="hljs-string"><span class="hljs-string">'first'</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> second = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> {   setTimeout(resolve, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-string"><span class="hljs-string">'second'</span></span>) }) <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.race([first, second]).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result) <span class="hljs-comment"><span class="hljs-comment">// second })</span></span></code> </pre> <br><h4>  Nicht erfasster TypeError-Fehler, der beim Arbeiten mit Versprechungen auftritt </h4><br>  Wenn Sie beim Arbeiten mit Versprechungen auf den nicht <code>Uncaught TypeError: undefined is not a promise</code> , stellen Sie sicher, dass beim Erstellen von Versprechungen das <code>new Promise()</code> <code>Uncaught TypeError: undefined is not a promise</code> anstelle von nur <code>Promise()</code> . <br><br><h3>  <font color="#3AC1EF">▍ asynchrones / wartendes Design</font> </h3><br>  Das Async / Await-Konstrukt ist ein moderner Ansatz zur asynchronen Programmierung, der es vereinfacht.  Asynchrone Funktionen können als eine Kombination von Versprechungen und Generatoren dargestellt werden, und im Allgemeinen ist diese Konstruktion eine Abstraktion über Versprechungen. <br><br>  Das asynchrone / wartende Design reduziert die Menge an Boilerplate-Code, die Sie schreiben müssen, wenn Sie mit Versprechungen arbeiten.  Als im ES2015-Standard Versprechungen auftauchten, zielten sie darauf ab, das Problem der Erstellung von asynchronem Code zu lösen.  Sie haben diese Aufgabe bewältigt, aber in zwei Jahren, als sie die Ergebnisse der Standards ES2015 und ES2017 teilten, wurde klar, dass sie nicht als endgültige Lösung des Problems angesehen werden konnten. <br><br>  Eines der Probleme, die Versprechen gelöst haben, war die berühmte „Hölle der Rückrufe“, aber sie haben bei der Lösung dieses Problems ihre eigenen Probleme ähnlicher Art geschaffen. <br><br>  Versprechen waren einfache Konstrukte, um die man etwas mit einer einfacheren Syntax bauen konnte.  Als die Zeit gekommen war, erschien das Konstrukt async / await.  Durch seine Verwendung können Sie Code schreiben, der synchron aussieht, aber asynchron ist, insbesondere blockiert er den Hauptthread nicht. <br><br><h4>  Wie das Konstrukt async / await funktioniert </h4><br>  Eine asynchrone Funktion gibt ein Versprechen zurück, wie im folgenden Beispiel: <br><br><pre> <code class="hljs coffeescript">const doSomethingAsync = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve)</span></span></span><span class="hljs-function"> =&gt;</span></span> {       setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">'I did something'</span></span>), <span class="hljs-number"><span class="hljs-number">3000</span></span>)   }) }</code> </pre> <br>  Wenn Sie eine ähnliche Funktion aufrufen müssen, müssen Sie das Schlüsselwort <code>await</code> vor dem Befehl zum Aufrufen platzieren.  Dies führt dazu, dass der aufrufende Code auf die Erlaubnis oder Ablehnung des entsprechenden Versprechens wartet.  Es ist zu beachten, dass eine Funktion, die das Schlüsselwort <code>await</code> verwendet, mit dem <code>async</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> doSomethingAsync()) }</code> </pre> <br>  Kombinieren Sie die beiden obigen Codefragmente und untersuchen Sie ihr Verhalten: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomethingAsync = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) =&gt;</span></span> {       setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">'I did something'</span></span>), <span class="hljs-number"><span class="hljs-number">3000</span></span>)   }) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> doSomethingAsync()) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Before'</span></span>) doSomething() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'After'</span></span>)</code> </pre> <br>  Dieser Code gibt Folgendes aus: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Before</span></span> <span class="hljs-keyword"><span class="hljs-keyword">After</span></span> I did something</code> </pre> <br>  Der Text, den <code>I did something</code> wird mit einer Verzögerung von 3 Sekunden in die Konsole eingegeben. <br><br><h4>  Über Versprechen und asynchrone Funktionen </h4><br>  Wenn Sie eine bestimmte Funktion mit dem <code>async</code> , bedeutet dies, dass eine solche Funktion ein Versprechen <code>async</code> , auch wenn dies nicht explizit erfolgt.  Aus diesem Grund ist das folgende Beispiel beispielsweise ein Arbeitscode: <br><br><pre> <code class="hljs powershell">const a<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">Function</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">async</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'test'</span></span> } aFunction().then(console.log) //    <span class="hljs-string"><span class="hljs-string">'test'</span></span></code> </pre> <br>  Dieser Entwurf ähnelt diesem: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> aFunction = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'test'</span></span>) } aFunction().then(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log) <span class="hljs-comment"><span class="hljs-comment">//    'test'</span></span></code> </pre> <br><h4>  Stärken der Asynchronität / warten </h4><br>  Wenn Sie die obigen Beispiele analysieren, können Sie feststellen, dass der Code, der async / await verwendet, einfacher ist als der Code, der die Verkettung von Versprechungen verwendet, oder Code, der auf Rückruffunktionen basiert.  Hier haben wir uns natürlich sehr einfache Beispiele angesehen.  Sie können die oben genannten Vorteile voll ausschöpfen, indem Sie mit viel komplexerem Code arbeiten.  Hier erfahren Sie beispielsweise, wie Sie JSON-Daten mithilfe von Versprechungen laden und analysieren: <br><br><pre> <code class="hljs pgsql">const getFirstUserData = () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(<span class="hljs-string"><span class="hljs-string">'/users.json'</span></span>) //      .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(response =&gt; response.json()) //  <span class="hljs-type"><span class="hljs-type">JSON</span></span>   .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(users =&gt; users[<span class="hljs-number"><span class="hljs-number">0</span></span>]) //      .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(`/users/${<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.name}`)) //       .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(userResponse =&gt; userResponse.json()) //  <span class="hljs-type"><span class="hljs-type">JSON</span></span> } getFirstUserData()</code> </pre> <br>  So sieht die Lösung für dasselbe Problem mit async / await aus: <br><br><pre> <code class="hljs pgsql">const getFirstUserData = async () =&gt; { const response = await <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(<span class="hljs-string"><span class="hljs-string">'/users.json'</span></span>) //    const users = await response.json() //  <span class="hljs-type"><span class="hljs-type">JSON</span></span> const <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = users[<span class="hljs-number"><span class="hljs-number">0</span></span>] //    const userResponse = await <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(`/users/${<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.name}`) //     const userData = await userResponse.json() //  <span class="hljs-type"><span class="hljs-type">JSON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> userData } getFirstUserData()</code> </pre> <br><h4>  Verwenden von Sequenzen aus asynchronen Funktionen </h4><br>  Asynchrone Funktionen können leicht zu Designs kombiniert werden, die Promise-Ketten ähneln.  Die Ergebnisse einer solchen Kombination sind jedoch viel besser lesbar: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promiseToDoSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> {       setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">'I did something'</span></span>), <span class="hljs-number"><span class="hljs-number">10000</span></span>)   }) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> watchOverSomeoneDoingSomething = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> promiseToDoSomething()   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> something + <span class="hljs-string"><span class="hljs-string">' and I watched'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> watchOverSomeoneWatchingSomeoneDoingSomething = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> watchOverSomeoneDoingSomething()   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> something + <span class="hljs-string"><span class="hljs-string">' and I watched as well'</span></span> } watchOverSomeoneWatchingSomeoneDoingSomething().then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function">) =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res) })</code> </pre> <br>  Dieser Code gibt den folgenden Text aus: <br><br><pre> <code class="hljs pgsql">I did something <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> I watched <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> I watched <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> well</code> </pre> <br><h4>  Vereinfachtes Debugging </h4><br>  Versprechen sind schwer zu debuggen, da Sie mit ihnen die üblichen Tools des Debuggers (wie "Step Bypass", Step-Over) nicht effektiv verwenden können.  Mit async / await geschriebener Code kann mit denselben Methoden wie normaler synchroner Code debuggt werden. <br><br><h2>  <font color="#3AC1EF">Ereignisgenerierung in Node.js.</font> </h2><br>  Wenn Sie in einem Browser mit JavaScript gearbeitet haben, wissen Sie, dass Ereignisse eine große Rolle bei der Handhabung von Benutzerinteraktionen mit Seiten spielen.  Es geht um die Behandlung von Ereignissen, die durch Klicks und Mausbewegungen, Tastenanschläge auf der Tastatur usw. verursacht werden.  In Node.js können Sie mit Ereignissen arbeiten, die der Programmierer selbst erstellt.  Hier können Sie mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignismodul</a> Ihr eigenes Ereignissystem erstellen.  Dieses Modul bietet uns insbesondere die <code>EventEmitter</code> Klasse, mit deren Hilfe die Arbeit mit Ereignissen organisiert werden kann.  Bevor Sie diesen Mechanismus verwenden können, müssen Sie ihn anschließen: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> EventEmitter = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'events'</span></span>).EventEmitter</code> </pre> <br>  Bei der Arbeit damit stehen uns unter anderem die Methoden <code>on()</code> und <code>emit()</code> zur Verfügung.  Die <code>emit</code> Methode <code>emit</code> zum Aufrufen von Ereignissen verwendet.  Die <code>on</code> Methode wird verwendet, um Rückrufe zu konfigurieren, Ereignishandler, die aufgerufen werden, wenn ein bestimmtes Ereignis aufgerufen wird. <br><br>  Erstellen wir beispielsweise ein Startereignis.  In diesem Fall geben wir etwas an die Konsole aus: <br><br><pre> <code class="hljs coffeescript">eventEmitter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventEmitter(); eventEmitter.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'started'</span></span>) })</code> </pre> <br>  Um dieses Ereignis auszulösen, wird die folgende Konstruktion verwendet: <br><br><pre> <code class="hljs mel">eventEmitter.<span class="hljs-keyword"><span class="hljs-keyword">emit</span></span>(<span class="hljs-string"><span class="hljs-string">'start'</span></span>)</code> </pre> <br>  Als Ergebnis der Ausführung dieses Befehls wird der Ereignishandler aufgerufen und die <code>started</code> Zeichenfolge gelangt zur Konsole. <br><br>  Sie können Argumente an den Ereignishandler übergeben und sie als zusätzliche Argumente für die <code>emit()</code> -Methode darstellen: <br><br><pre> <code class="hljs coffeescript">eventEmitter.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(number)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(`<span class="javascript"><span class="javascript">started ${number}</span></span>`) }) eventEmitter.emit(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>)</code> </pre> <br>  Dasselbe passiert in Fällen, in denen der Handler mehrere Argumente übergeben muss: <br><br><pre> <code class="hljs pgsql">eventEmitter.<span class="hljs-keyword"><span class="hljs-keyword">on</span></span>(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) =&gt; { console.log(`started <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ${<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> ${<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>}`) }) eventEmitter.emit(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>)</code> </pre> <br>  <code>EventEmitter</code> Klassenobjekte verfügen über einige andere nützliche Methoden: <br><br><ul><li>  <code>once()</code> - Ermöglicht die Registrierung eines Ereignishandlers, der nur einmal aufgerufen werden kann. </li><li>  <code>removeListener()</code> - Mit dieser <code>removeListener()</code> können Sie den an ihn übergebenen Handler aus dem Array der Handler des an ihn übergebenen Ereignisses entfernen. </li><li>  <code>removeAllListeners()</code> - Ermöglicht das Entfernen aller Handler des an ihn übergebenen Ereignisses. </li></ul><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Heute haben wir über asynchrone Programmierung in JavaScript gesprochen, insbesondere über Rückrufe, Versprechen und das Konstrukt async / await.  Hier haben wir das Problem der Arbeit mit Ereignissen angesprochen, die vom Entwickler mithilfe des <code>events</code> .  Unser nächstes Thema werden Netzwerkmechanismen der Node.js-Plattform sein. <br><br>  <b>Liebe Leser!</b>  Verwenden Sie beim Programmieren für Node.js das Konstrukt async / await? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424555/">https://habr.com/ru/post/de424555/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424539/index.html">Java 11: neu in String</a></li>
<li><a href="../de424541/index.html">UGJ 2018 Fiasko-Geschichte: Wie man ein Spiel macht, das niemand mag (tu es nicht!)</a></li>
<li><a href="../de424543/index.html">Java 11 / JDK 11: Allgemeine Verfügbarkeit</a></li>
<li><a href="../de424551/index.html">Warm and Tube: Fünf Balalaikas über magnetische Audiotechnologie</a></li>
<li><a href="../de424553/index.html">Node.js Guide, Teil 6: Ereignisschleife, Call Stack, Timer</a></li>
<li><a href="../de424557/index.html">Node.js-Handbuch, Teil 8: HTTP- und WebSocket-Protokolle</a></li>
<li><a href="../de424559/index.html">Big Data Resistance 1 oder schwer fassbarer Joe. Internet-Anonymität, Anti-Erkennung, Anti-Tracking für Anti-Sie und Anti-uns</a></li>
<li><a href="../de424563/index.html">Beeline sendet Einzelheiten zu Gesprächen an Fremde</a></li>
<li><a href="../de424565/index.html">Übersicht: 3D-Scannen von Immobilien</a></li>
<li><a href="../de424567/index.html">Die Erfahrung, Online-Werbung im lokalen Netzwerk des Unternehmens zu blockieren</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>