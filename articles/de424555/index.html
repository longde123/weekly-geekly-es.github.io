<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•õ üëäüèª üë®üèø‚Äçüè´ Node.js Handbuch, Teil 7: Asynchrone Programmierung üëãüèΩ üï∫üèº üêì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In der √úbersetzung des siebten Teils des Node.js-Handbuchs werden wir heute √ºber asynchrone Programmierung sprechen, Probleme wie die Verwendung von R...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Node.js Handbuch, Teil 7: Asynchrone Programmierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/424555/">  In der √úbersetzung des siebten Teils des Node.js-Handbuchs werden wir heute √ºber asynchrone Programmierung sprechen, Probleme wie die Verwendung von R√ºckrufen, Versprechungen und das Konstrukt async / await ber√ºcksichtigen und die Arbeit mit Ereignissen diskutieren. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/he/di/2j/hedi2j_qyfbnwfo_jqnnqd3ub6o.png"></a> <br><br><div class="spoiler">  <b class="spoiler_title">[Wir empfehlen Ihnen zu lesen] Andere Teile des Zyklus</b> <div class="spoiler_text">  Teil 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Allgemeine Informationen und erste Schritte</a> <br>  Teil 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JavaScript, V8, einige Entwicklungstricks</a> <br>  Teil 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hosting, REPL, Arbeit mit der Konsole, Module</a> <br>  Teil 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dateien npm, package.json und package-lock.json</a> <br>  Teil 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">npm und npx</a> <br>  Teil 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisschleife, Aufrufstapel, Timer</a> <br>  Teil 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Asynchrone Programmierung</a> <br>  Teil 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Node.js-Handbuch, Teil 8: HTTP- und WebSocket-Protokolle</a> <br>  Teil 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Node.js-Handbuch, Teil 9: Arbeiten mit dem Dateisystem</a> <br>  Teil 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Node.js-Handbuch, Teil 10: Standardmodule, Streams, Datenbanken, NODE_ENV</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vollst√§ndiges PDF des Node.js-Handbuchs</a> <br></div></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Asynchronit√§t in Programmiersprachen</font> </h2><br>  JavaScript selbst ist eine synchrone Single-Threaded-Programmiersprache.  Dies bedeutet, dass Sie keine neuen Threads im Code erstellen k√∂nnen, die parallel ausgef√ºhrt werden.  Computer sind jedoch von Natur aus asynchron.  Das hei√üt, bestimmte Aktionen k√∂nnen unabh√§ngig vom Ablauf der Hauptprogrammausf√ºhrung ausgef√ºhrt werden.  In modernen Computern wird jedem Programm eine bestimmte Prozessorzeit zugewiesen. Wenn diese Zeit abgelaufen ist, gibt das System auch f√ºr eine Weile Ressourcen an ein anderes Programm weiter.  Solche Umschaltungen werden zyklisch durchgef√ºhrt, so schnell, dass eine Person es einfach nicht bemerken kann. Daher denken wir, dass unsere Computer viele Programme gleichzeitig ausf√ºhren.  Dies ist jedoch eine Illusion (ganz zu schweigen von Multiprozessor-Maschinen). <br><br>  Im Darm von Programmen werden Interrupts verwendet - Signale, die an den Prozessor √ºbertragen werden und die Aufmerksamkeit des Systems auf sich ziehen.  Wir werden nicht auf Details eingehen. Das Wichtigste ist, sich daran zu erinnern, dass asynchrones Verhalten, wenn ein Programm angehalten wird, bis es Prozessorressourcen ben√∂tigt, v√∂llig normal ist.  Zu einem Zeitpunkt, an dem das Programm das System nicht mit Arbeit l√§dt, kann der Computer andere Probleme l√∂sen.  Wenn ein Programm bei diesem Ansatz beispielsweise auf eine Antwort auf eine an ihn gerichtete Netzwerkanforderung wartet, blockiert es den Prozessor erst, wenn eine Antwort empfangen wird. <br><br>  Programmiersprachen sind in der Regel asynchron. Einige von ihnen bieten dem Programmierer die M√∂glichkeit, asynchrone Mechanismen mithilfe der integrierten Sprachtools oder spezialisierter Bibliotheken zu steuern.  Wir sprechen √ºber Sprachen wie C, Java, C #, PHP, Go, Ruby, Swift, Python.  Mit einigen von ihnen k√∂nnen Sie asynchron programmieren, Threads verwenden und neue Prozesse starten. <br><br><h2>  <font color="#3AC1EF">JavaScript-Asynchronit√§t</font> </h2><br>  Wie bereits erw√§hnt, ist JavaScript eine synchrone Sprache mit einem Thread.  In JS geschriebene Codezeilen werden in der Reihenfolge ausgef√ºhrt, in der sie nacheinander im Text erscheinen.  Hier ist beispielsweise ein ganz normales JS-Programm, das dieses Verhalten demonstriert: <br><br><pre><code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c = a * b console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(c) doSomething()</code> </pre> <br>  JavaScript wurde jedoch f√ºr die Verwendung in Browsern erstellt.  Die Hauptaufgabe bestand zu Beginn darin, die Verarbeitung von Ereignissen im Zusammenhang mit Benutzeraktivit√§ten zu organisieren.  Dies sind beispielsweise Ereignisse wie <code>onClick</code> , <code>onMouseOver</code> , <code>onChange</code> , <code>onSubmit</code> usw.  Wie k√∂nnen solche Probleme im Rahmen eines synchronen Programmiermodells gel√∂st werden? <br><br>  Die Antwort liegt in der Umgebung, in der JavaScript ausgef√ºhrt wird.  Mit dem Browser k√∂nnen Sie n√§mlich solche Probleme effektiv l√∂sen und dem Programmierer die entsprechenden APIs zur Verf√ºgung stellen. <br><br>  In der Umgebung von Node.js gibt es Tools zum Ausf√ºhren nicht blockierender E / A-Vorg√§nge, z. B. Arbeiten mit Dateien, Organisieren des Datenaustauschs √ºber ein Netzwerk usw. <br><br><h2>  <font color="#3AC1EF">R√ºckrufe</font> </h2><br>  Wenn wir √ºber browserbasiertes JavaScript sprechen, kann festgestellt werden, dass es unm√∂glich ist, im Voraus zu wissen, wann der Benutzer auf eine Schaltfl√§che klickt.  Um sicherzustellen, dass das System auf ein solches Ereignis reagiert, wird ein Handler daf√ºr erstellt. <br><br>  Der Ereignishandler akzeptiert eine Funktion, die beim Auftreten des Ereignisses aufgerufen wird.  Es sieht so aus: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'button'</span></span>).addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    })</code> </pre> <br>  Solche Funktionen werden auch R√ºckruffunktionen oder R√ºckrufe genannt. <br><br>  Ein R√ºckruf ist eine regul√§re Funktion, die als Wert an eine andere Funktion √ºbergeben wird.  Es wird nur aufgerufen, wenn ein bestimmtes Ereignis eintritt.  JavaScript implementiert das Konzept erstklassiger Funktionen.  Solche Funktionen k√∂nnen Variablen zugewiesen und an andere Funktionen √ºbergeben werden (sogenannte Funktionen h√∂herer Ordnung). <br><br>  Ein g√§ngiger Ansatz bei der clientseitigen JavaScript-Entwicklung besteht darin, dass der gesamte Clientcode in einen Listener des <code>load</code> eines <code>window</code> wird, der den R√ºckruf aufruft, der an ihn √ºbergeben wird, nachdem die Seite betriebsbereit ist: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'load'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     })</code> </pre> <br>  R√ºckrufe werden √ºberall verwendet und nicht nur zur Behandlung von DOM-Ereignissen.  Zum Beispiel haben wir uns bereits mit ihrer Verwendung in Timern getroffen: <br><br><pre> <code class="hljs javascript">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   2  }, 2000)</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">XHR-Anforderungen verwenden</a> auch R√ºckrufe.  In diesem Fall sieht es so aus, als w√ºrde der entsprechenden Eigenschaft eine Funktion zugewiesen.  Eine √§hnliche Funktion wird aufgerufen, wenn ein bestimmtes Ereignis eintritt.  Im folgenden Beispiel handelt es sich bei einem solchen Ereignis um eine √Ñnderung des Anforderungsstatus: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> xhr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest() xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xhr.readyState === <span class="hljs-number"><span class="hljs-number">4</span></span>) {   xhr.status === <span class="hljs-number"><span class="hljs-number">200</span></span> ? <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(xhr.responseText) : <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(<span class="hljs-string"><span class="hljs-string">'error'</span></span>) } } xhr.open(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'https://yoursite.com'</span></span>) xhr.send()</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Fehlerbehandlung bei R√ºckrufen</font> </h3><br>  Lassen Sie uns dar√ºber sprechen, wie Fehler in R√ºckrufen behandelt werden.  Es gibt eine gemeinsame Strategie zur Behandlung solcher Fehler, die auch in Node.js verwendet wird.  Es besteht darin, dass der erste Parameter einer R√ºckruffunktion ein Fehlerobjekt ist.  Wenn keine Fehler <code>null</code> wird <code>null</code> in diesen Parameter geschrieben.  Andernfalls wird ein Fehlerobjekt angezeigt, das seine Beschreibung und zus√§tzliche Informationen dazu enth√§lt.  So sieht es aus: <br><br><pre> <code class="hljs coffeescript">fs.readFile(<span class="hljs-string"><span class="hljs-string">'/file.json'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, data)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) {   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data) })</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç R√ºckrufproblem</font> </h3><br>  R√ºckrufe sind in einfachen Situationen bequem zu verwenden.  Jeder R√ºckruf ist jedoch eine zus√§tzliche Ebene der Codeverschachtelung.  Wenn mehrere verschachtelte R√ºckrufe verwendet werden, f√ºhrt dies schnell zu einer erheblichen Komplikation der Codestruktur: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'load'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'button'</span></span>).addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {     items.forEach(item =&gt; {       <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>,  -      })   }, <span class="hljs-number"><span class="hljs-number">2000</span></span>) }) })</code> </pre> <br>  In diesem Beispiel werden nur 4 Codeebenen angezeigt. In der Praxis kann es jedoch zu einer gro√üen Anzahl von Ebenen kommen, die normalerweise als "R√ºckrufh√∂lle" bezeichnet werden.  Sie k√∂nnen dieses Problem mit anderen Sprachkonstrukten l√∂sen. <br><br><h2>  <font color="#3AC1EF">Versprechen und asynchron / warten</font> </h2><br>  Beginnend mit dem ES6-Standard f√ºhrt JavaScript neue Funktionen ein, die das Schreiben von asynchronem Code erleichtern und R√ºckrufe √ºberfl√ºssig machen.  Wir sprechen √ºber die Versprechen, die in ES6 erschienen sind, und das asynchrone / warten-Konstrukt, das in ES8 erschienen ist. <br><br><h3>  <font color="#3AC1EF">‚ñç Versprechen</font> </h3><br>  Versprechen (Versprechenobjekte) sind eine der M√∂glichkeiten, mit asynchronen Softwarekonstrukten in JavaScript zu arbeiten, wodurch die Verwendung von R√ºckrufen im Allgemeinen reduziert wird. <br><br><h4>  Bekanntschaft mit Versprechen </h4><br>  Versprechen werden normalerweise als Proxy-Objekte f√ºr bestimmte Werte definiert, deren Erscheinungsbild in Zukunft erwartet wird.  Versprechen werden auch "Versprechen" oder "versprochene Ergebnisse" genannt.  Obwohl dieses Konzept seit vielen Jahren besteht, wurden Versprechen erst in ES2015 standardisiert und der Sprache hinzugef√ºgt.  In ES2017 ist das asynchrone / wartende Design erschienen, das auf Versprechungen basiert und als praktischer Ersatz angesehen werden kann.  Selbst wenn Sie nicht vorhaben, regelm√§√üige Versprechen zu verwenden, ist daher ein Verst√§ndnis der Funktionsweise wichtig, um das asynchrone / warten-Konstrukt effektiv nutzen zu k√∂nnen. <br><br><h4>  Wie Versprechen funktionieren </h4><br>  Nachdem ein Versprechen aufgerufen wurde, geht es in einen ausstehenden Zustand √ºber.  Dies bedeutet, dass die Funktion, die das Versprechen verursacht hat, weiterhin ausgef√ºhrt wird, w√§hrend einige Berechnungen im Versprechen ausgef√ºhrt werden, wonach das Versprechen dar√ºber informiert.  Wenn die vom Versprechen ausgef√ºhrte Operation erfolgreich abgeschlossen wurde, wird das Versprechen in den erf√ºllten Zustand versetzt.  Ein solches Versprechen soll erfolgreich gel√∂st worden sein.  Wenn der Vorgang mit einem Fehler abgeschlossen wird, wird das Versprechen in den abgelehnten Zustand versetzt. <br><br>  Sprechen wir √ºber die Arbeit mit Versprechungen. <br><br><h4>  Versprechen erstellen </h4><br>  Die API zum Arbeiten mit Versprechungen gibt uns den entsprechenden Konstruktor, der durch einen Befehl der Form <code>new Promise()</code> aufgerufen wird.  So entstehen Versprechen: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> done = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isItDoneYet = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (done) {     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> workDone = <span class="hljs-string"><span class="hljs-string">'Here is the thing I built'</span></span>     resolve(workDone)   } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> why = <span class="hljs-string"><span class="hljs-string">'Still working on something else'</span></span>     reject(why)   } } )</code> </pre> <br>  Promis √ºberpr√ºft die globale Konstante und wenn ihr Wert <code>true</code> , wird sie erfolgreich aufgel√∂st.  Andernfalls wird das Versprechen abgelehnt.  Mit den <code>resolve</code> und <code>reject</code> , die Funktionen sind, k√∂nnen wir Werte aus dem Versprechen zur√ºckgeben.  In diesem Fall geben wir eine Zeichenfolge zur√ºck, aber hier kann ein Objekt verwendet werden. <br><br><h4>  Mit Versprechen arbeiten </h4><br>  Wir haben oben ein Versprechen erstellt und √ºberlegen, jetzt damit zu arbeiten.  Es sieht so aus: <br><br><pre> <code class="hljs coffeescript">const isItDoneYet = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise( <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>... ) const checkIfItsDone = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { isItDoneYet   .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ok)</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(ok)   })   .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err)   }) } checkIfItsDone()</code> </pre> <br>  Das Aufrufen von <code>checkIfItsDone()</code> f√ºhrt zur Ausf√ºhrung des isItDoneYet <code>isItDoneYet()</code> -Versprechens und zur Organisation des Wartens auf dessen L√∂sung.  Wenn das Versprechen erfolgreich aufgel√∂st wird, funktioniert der an die <code>.then()</code> -Methode √ºbergebene R√ºckruf.  Wenn ein Fehler auftritt, <code>.catch()</code> das Versprechen abgelehnt wird, kann es in der an die <code>.catch()</code> -Methode √ºbergebenen Funktion verarbeitet werden. <br><br><h4>  Verkettungsversprechen </h4><br>  Versprechensmethoden geben Versprechungen zur√ºck, sodass Sie sie zu Ketten kombinieren k√∂nnen.  Ein gutes Beispiel f√ºr dieses Verhalten ist der browserbasierte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">API-Abruf</a> , bei dem es sich um eine Abstraktionsschicht √ºber <code>XMLHttpRequest</code> .  Es gibt ein ziemlich beliebtes npm-Paket f√ºr Node.js, das die Fetch-API implementiert, auf die wir sp√§ter noch eingehen werden.  Diese API kann verwendet werden, um bestimmte Netzwerkressourcen zu laden und dank der M√∂glichkeit, Versprechen in Ketten zu kombinieren, die nachfolgende Verarbeitung heruntergeladener Daten zu organisieren.  Wenn Sie die Fetch-API √ºber einen Aufruf der Funktion <code>fetch()</code> aufrufen, wird ein Versprechen erstellt. <br><br>  Betrachten Sie das folgende Beispiel f√ºr Verkettungsversprechen: <br><br><pre> <code class="hljs coffeescript">const fetch = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'node-fetch'</span></span>) const status = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.status &gt;= <span class="hljs-number"><span class="hljs-number">200</span></span> &amp;&amp; response.status &lt; <span class="hljs-number"><span class="hljs-number">300</span></span>) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Promise.resolve(response) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Promise.reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(response.statusText)) } const json = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response)</span></span></span><span class="hljs-function"> =&gt;</span></span> response.json() fetch(<span class="hljs-string"><span class="hljs-string">'https://jsonplaceholder.typicode.com/todos'</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(status) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(json) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Request succeeded with JSON response'</span></span>, data) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Request failed'</span></span>, error) })</code> </pre> <br>  Hier verwenden wir das npm-Paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">node-fetch</a> und die Ressource <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">jsonplaceholder.typicode.com</a> als Quelle f√ºr JSON-Daten. <br><br>  In diesem Beispiel wird die Funktion <code>fetch()</code> verwendet, um ein TODO-Listenelement mithilfe einer Versprechungskette zu laden.  Nach dem Ausf√ºhren von <code>fetch()</code> wird eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Antwort</a> zur√ºckgegeben, die viele Eigenschaften aufweist, von denen wir Folgendes interessieren: <br><br><ul><li>  <code>status</code> ist ein numerischer Wert, der den HTTP-Statuscode darstellt. </li><li>  <code>statusText</code> - Eine <code>statusText</code> des HTTP-Statuscodes, die durch die Zeichenfolge <code>OK</code> wenn die Anforderung erfolgreich war. </li></ul><br>  Das <code>response</code> verf√ºgt √ºber eine <code>json()</code> -Methode, die ein Versprechen zur√ºckgibt, bei dessen Aufl√∂sung der verarbeitete Inhalt des Anforderungshauptteils im JSON-Format dargestellt wird. <br><br>  Vor diesem Hintergrund beschreiben wir, was in diesem Code geschieht.  Das erste Versprechen in der Kette wird durch die von uns angek√ºndigte Funktion <code>status()</code> , die den Status der Antwort √ºberpr√ºft. Wenn angezeigt wird, dass die Anforderung fehlgeschlagen ist (dh der HTTP-Statuscode liegt nicht im Bereich zwischen 200 und 299), wird das Versprechen abgelehnt.  Diese Operation f√ºhrt dazu, dass andere <code>.then()</code> in der Versprechenskette nicht ausgef√ºhrt werden und wir sofort zur <code>.catch()</code> -Methode gelangen, die zusammen mit der Fehlermeldung den Text <code>Request failed</code> an die Konsole ausgibt. <br><br>  Wenn der HTTP-Statuscode zu uns passt, wird die von uns deklarierte Funktion <code>json()</code> aufgerufen.  Da das vorherige Versprechen bei erfolgreicher Aufl√∂sung ein <code>response</code> zur√ºckgibt, verwenden wir es als Eingabewert f√ºr das zweite Versprechen. <br><br>  In diesem Fall geben wir die verarbeiteten JSON-Daten zur√ºck, sodass das dritte Versprechen sie erh√§lt. Anschlie√üend wird in der Konsole eine Meldung angezeigt, dass aufgrund der Anforderung die erforderlichen Daten abgerufen werden konnten. <br><br><h4>  Fehlerbehandlung </h4><br>  Im vorherigen Beispiel hatten wir eine <code>.catch()</code> -Methode, die an eine Kette von Versprechungen angeh√§ngt war.  Wenn etwas in der Kette der Versprechen schief geht und ein Fehler auftritt oder wenn sich herausstellt, dass eines der Versprechen abgelehnt wird, wird die Kontrolle auf den n√§chsten Ausdruck <code>.catch()</code> .  Hier ist die Situation, in der ein Fehler in einem Versprechen auftritt: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve, reject)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(<span class="hljs-string"><span class="hljs-string">'Error'</span></span>) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br>  Hier ist ein Beispiel f√ºr das Ausl√∂sen von <code>.catch()</code> nach dem Ablehnen eines Versprechens: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve, reject)</span></span></span><span class="hljs-function"> =&gt;</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Error'</span></span>) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br><h4>  Kaskadierende Fehlerbehandlung </h4><br>  Was <code>.catch()</code> wenn im Ausdruck <code>.catch()</code> ein Fehler auftritt?  Um diesen Fehler zu behandeln, k√∂nnen Sie einen weiteren Ausdruck <code>.catch()</code> in die Kette der Versprechen aufnehmen (und dann der Kette so viele <code>.catch()</code> , wie erforderlich): <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve, reject)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(<span class="hljs-string"><span class="hljs-string">'Error'</span></span>) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(<span class="hljs-string"><span class="hljs-string">'Error'</span></span>) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br>  Schauen wir uns nun einige n√ºtzliche Methoden an, mit denen Versprechen verwaltet werden. <br><br><h4>  Promise.all () </h4><br>  Wenn Sie nach dem Aufl√∂sen mehrerer Versprechen eine Aktion ausf√ºhren m√ºssen, k√∂nnen Sie dies mit dem Befehl <code>Promise.all()</code> tun.  Betrachten Sie ein Beispiel: <br><br><pre> <code class="hljs coffeescript">const f1 = fetch(<span class="hljs-string"><span class="hljs-string">'https://jsonplaceholder.typicode.com/todos/1'</span></span>) const f2 = fetch(<span class="hljs-string"><span class="hljs-string">'https://jsonplaceholder.typicode.com/todos/2'</span></span>) Promise.all([f1, f2]).<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(res)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Array of results'</span></span>, res) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br>  In ES2015 wurde die Syntax der destruktiven Zuweisung angezeigt. Mit ihr k√∂nnen Sie Konstruktionen in der folgenden Form erstellen: <br><br><pre> <code class="hljs powershell">Promise.all([<span class="hljs-type"><span class="hljs-type">f1</span></span>, <span class="hljs-type"><span class="hljs-type">f2</span></span>]).then(([<span class="hljs-type"><span class="hljs-type">res1</span></span>, <span class="hljs-type"><span class="hljs-type">res2</span></span>]) =&gt; {   console.log(<span class="hljs-string"><span class="hljs-string">'Results'</span></span>, res1, res2) })</code> </pre> <br>  Hier haben wir als Beispiel den API-Abruf betrachtet, aber mit <code>Promise.all()</code> k√∂nnen Sie nat√ºrlich mit allen Versprechungen arbeiten. <br><br><h4>  Promise.race () </h4><br>  Mit dem Befehl <code>Promise.race()</code> k√∂nnen Sie die angegebene Aktion ausf√ºhren, nachdem eines der an ihn √ºbergebenen Versprechen aufgel√∂st wurde.  Der entsprechende R√ºckruf mit den Ergebnissen dieses ersten Versprechens wird nur einmal aufgerufen.  Betrachten Sie ein Beispiel: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> first = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> {   setTimeout(resolve, <span class="hljs-number"><span class="hljs-number">500</span></span>, <span class="hljs-string"><span class="hljs-string">'first'</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> second = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> {   setTimeout(resolve, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-string"><span class="hljs-string">'second'</span></span>) }) <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.race([first, second]).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result) <span class="hljs-comment"><span class="hljs-comment">// second })</span></span></code> </pre> <br><h4>  Nicht erfasster TypeError-Fehler, der beim Arbeiten mit Versprechungen auftritt </h4><br>  Wenn Sie beim Arbeiten mit Versprechungen auf den nicht <code>Uncaught TypeError: undefined is not a promise</code> , stellen Sie sicher, dass beim Erstellen von Versprechungen das <code>new Promise()</code> <code>Uncaught TypeError: undefined is not a promise</code> anstelle von nur <code>Promise()</code> . <br><br><h3>  <font color="#3AC1EF">‚ñç asynchrones / wartendes Design</font> </h3><br>  Das Async / Await-Konstrukt ist ein moderner Ansatz zur asynchronen Programmierung, der es vereinfacht.  Asynchrone Funktionen k√∂nnen als eine Kombination von Versprechungen und Generatoren dargestellt werden, und im Allgemeinen ist diese Konstruktion eine Abstraktion √ºber Versprechungen. <br><br>  Das asynchrone / wartende Design reduziert die Menge an Boilerplate-Code, die Sie schreiben m√ºssen, wenn Sie mit Versprechungen arbeiten.  Als im ES2015-Standard Versprechungen auftauchten, zielten sie darauf ab, das Problem der Erstellung von asynchronem Code zu l√∂sen.  Sie haben diese Aufgabe bew√§ltigt, aber in zwei Jahren, als sie die Ergebnisse der Standards ES2015 und ES2017 teilten, wurde klar, dass sie nicht als endg√ºltige L√∂sung des Problems angesehen werden konnten. <br><br>  Eines der Probleme, die Versprechen gel√∂st haben, war die ber√ºhmte ‚ÄûH√∂lle der R√ºckrufe‚Äú, aber sie haben bei der L√∂sung dieses Problems ihre eigenen Probleme √§hnlicher Art geschaffen. <br><br>  Versprechen waren einfache Konstrukte, um die man etwas mit einer einfacheren Syntax bauen konnte.  Als die Zeit gekommen war, erschien das Konstrukt async / await.  Durch seine Verwendung k√∂nnen Sie Code schreiben, der synchron aussieht, aber asynchron ist, insbesondere blockiert er den Hauptthread nicht. <br><br><h4>  Wie das Konstrukt async / await funktioniert </h4><br>  Eine asynchrone Funktion gibt ein Versprechen zur√ºck, wie im folgenden Beispiel: <br><br><pre> <code class="hljs coffeescript">const doSomethingAsync = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve)</span></span></span><span class="hljs-function"> =&gt;</span></span> {       setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">'I did something'</span></span>), <span class="hljs-number"><span class="hljs-number">3000</span></span>)   }) }</code> </pre> <br>  Wenn Sie eine √§hnliche Funktion aufrufen m√ºssen, m√ºssen Sie das Schl√ºsselwort <code>await</code> vor dem Befehl zum Aufrufen platzieren.  Dies f√ºhrt dazu, dass der aufrufende Code auf die Erlaubnis oder Ablehnung des entsprechenden Versprechens wartet.  Es ist zu beachten, dass eine Funktion, die das Schl√ºsselwort <code>await</code> verwendet, mit dem <code>async</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> doSomethingAsync()) }</code> </pre> <br>  Kombinieren Sie die beiden obigen Codefragmente und untersuchen Sie ihr Verhalten: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomethingAsync = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) =&gt;</span></span> {       setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">'I did something'</span></span>), <span class="hljs-number"><span class="hljs-number">3000</span></span>)   }) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> doSomethingAsync()) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Before'</span></span>) doSomething() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'After'</span></span>)</code> </pre> <br>  Dieser Code gibt Folgendes aus: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Before</span></span> <span class="hljs-keyword"><span class="hljs-keyword">After</span></span> I did something</code> </pre> <br>  Der Text, den <code>I did something</code> wird mit einer Verz√∂gerung von 3 Sekunden in die Konsole eingegeben. <br><br><h4>  √úber Versprechen und asynchrone Funktionen </h4><br>  Wenn Sie eine bestimmte Funktion mit dem <code>async</code> , bedeutet dies, dass eine solche Funktion ein Versprechen <code>async</code> , auch wenn dies nicht explizit erfolgt.  Aus diesem Grund ist das folgende Beispiel beispielsweise ein Arbeitscode: <br><br><pre> <code class="hljs powershell">const a<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">Function</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">async</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'test'</span></span> } aFunction().then(console.log) //    <span class="hljs-string"><span class="hljs-string">'test'</span></span></code> </pre> <br>  Dieser Entwurf √§hnelt diesem: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> aFunction = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'test'</span></span>) } aFunction().then(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log) <span class="hljs-comment"><span class="hljs-comment">//    'test'</span></span></code> </pre> <br><h4>  St√§rken der Asynchronit√§t / warten </h4><br>  Wenn Sie die obigen Beispiele analysieren, k√∂nnen Sie feststellen, dass der Code, der async / await verwendet, einfacher ist als der Code, der die Verkettung von Versprechungen verwendet, oder Code, der auf R√ºckruffunktionen basiert.  Hier haben wir uns nat√ºrlich sehr einfache Beispiele angesehen.  Sie k√∂nnen die oben genannten Vorteile voll aussch√∂pfen, indem Sie mit viel komplexerem Code arbeiten.  Hier erfahren Sie beispielsweise, wie Sie JSON-Daten mithilfe von Versprechungen laden und analysieren: <br><br><pre> <code class="hljs pgsql">const getFirstUserData = () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(<span class="hljs-string"><span class="hljs-string">'/users.json'</span></span>) //      .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(response =&gt; response.json()) //  <span class="hljs-type"><span class="hljs-type">JSON</span></span>   .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(users =&gt; users[<span class="hljs-number"><span class="hljs-number">0</span></span>]) //      .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(`/users/${<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.name}`)) //       .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(userResponse =&gt; userResponse.json()) //  <span class="hljs-type"><span class="hljs-type">JSON</span></span> } getFirstUserData()</code> </pre> <br>  So sieht die L√∂sung f√ºr dasselbe Problem mit async / await aus: <br><br><pre> <code class="hljs pgsql">const getFirstUserData = async () =&gt; { const response = await <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(<span class="hljs-string"><span class="hljs-string">'/users.json'</span></span>) //    const users = await response.json() //  <span class="hljs-type"><span class="hljs-type">JSON</span></span> const <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = users[<span class="hljs-number"><span class="hljs-number">0</span></span>] //    const userResponse = await <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(`/users/${<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.name}`) //     const userData = await userResponse.json() //  <span class="hljs-type"><span class="hljs-type">JSON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> userData } getFirstUserData()</code> </pre> <br><h4>  Verwenden von Sequenzen aus asynchronen Funktionen </h4><br>  Asynchrone Funktionen k√∂nnen leicht zu Designs kombiniert werden, die Promise-Ketten √§hneln.  Die Ergebnisse einer solchen Kombination sind jedoch viel besser lesbar: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promiseToDoSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> {       setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">'I did something'</span></span>), <span class="hljs-number"><span class="hljs-number">10000</span></span>)   }) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> watchOverSomeoneDoingSomething = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> promiseToDoSomething()   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> something + <span class="hljs-string"><span class="hljs-string">' and I watched'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> watchOverSomeoneWatchingSomeoneDoingSomething = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> watchOverSomeoneDoingSomething()   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> something + <span class="hljs-string"><span class="hljs-string">' and I watched as well'</span></span> } watchOverSomeoneWatchingSomeoneDoingSomething().then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function">) =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res) })</code> </pre> <br>  Dieser Code gibt den folgenden Text aus: <br><br><pre> <code class="hljs pgsql">I did something <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> I watched <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> I watched <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> well</code> </pre> <br><h4>  Vereinfachtes Debugging </h4><br>  Versprechen sind schwer zu debuggen, da Sie mit ihnen die √ºblichen Tools des Debuggers (wie "Step Bypass", Step-Over) nicht effektiv verwenden k√∂nnen.  Mit async / await geschriebener Code kann mit denselben Methoden wie normaler synchroner Code debuggt werden. <br><br><h2>  <font color="#3AC1EF">Ereignisgenerierung in Node.js.</font> </h2><br>  Wenn Sie in einem Browser mit JavaScript gearbeitet haben, wissen Sie, dass Ereignisse eine gro√üe Rolle bei der Handhabung von Benutzerinteraktionen mit Seiten spielen.  Es geht um die Behandlung von Ereignissen, die durch Klicks und Mausbewegungen, Tastenanschl√§ge auf der Tastatur usw. verursacht werden.  In Node.js k√∂nnen Sie mit Ereignissen arbeiten, die der Programmierer selbst erstellt.  Hier k√∂nnen Sie mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignismodul</a> Ihr eigenes Ereignissystem erstellen.  Dieses Modul bietet uns insbesondere die <code>EventEmitter</code> Klasse, mit deren Hilfe die Arbeit mit Ereignissen organisiert werden kann.  Bevor Sie diesen Mechanismus verwenden k√∂nnen, m√ºssen Sie ihn anschlie√üen: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> EventEmitter = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'events'</span></span>).EventEmitter</code> </pre> <br>  Bei der Arbeit damit stehen uns unter anderem die Methoden <code>on()</code> und <code>emit()</code> zur Verf√ºgung.  Die <code>emit</code> Methode <code>emit</code> zum Aufrufen von Ereignissen verwendet.  Die <code>on</code> Methode wird verwendet, um R√ºckrufe zu konfigurieren, Ereignishandler, die aufgerufen werden, wenn ein bestimmtes Ereignis aufgerufen wird. <br><br>  Erstellen wir beispielsweise ein Startereignis.  In diesem Fall geben wir etwas an die Konsole aus: <br><br><pre> <code class="hljs coffeescript">eventEmitter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventEmitter(); eventEmitter.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'started'</span></span>) })</code> </pre> <br>  Um dieses Ereignis auszul√∂sen, wird die folgende Konstruktion verwendet: <br><br><pre> <code class="hljs mel">eventEmitter.<span class="hljs-keyword"><span class="hljs-keyword">emit</span></span>(<span class="hljs-string"><span class="hljs-string">'start'</span></span>)</code> </pre> <br>  Als Ergebnis der Ausf√ºhrung dieses Befehls wird der Ereignishandler aufgerufen und die <code>started</code> Zeichenfolge gelangt zur Konsole. <br><br>  Sie k√∂nnen Argumente an den Ereignishandler √ºbergeben und sie als zus√§tzliche Argumente f√ºr die <code>emit()</code> -Methode darstellen: <br><br><pre> <code class="hljs coffeescript">eventEmitter.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(number)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(`<span class="javascript"><span class="javascript">started ${number}</span></span>`) }) eventEmitter.emit(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>)</code> </pre> <br>  Dasselbe passiert in F√§llen, in denen der Handler mehrere Argumente √ºbergeben muss: <br><br><pre> <code class="hljs pgsql">eventEmitter.<span class="hljs-keyword"><span class="hljs-keyword">on</span></span>(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) =&gt; { console.log(`started <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ${<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> ${<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>}`) }) eventEmitter.emit(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>)</code> </pre> <br>  <code>EventEmitter</code> Klassenobjekte verf√ºgen √ºber einige andere n√ºtzliche Methoden: <br><br><ul><li>  <code>once()</code> - Erm√∂glicht die Registrierung eines Ereignishandlers, der nur einmal aufgerufen werden kann. </li><li>  <code>removeListener()</code> - Mit dieser <code>removeListener()</code> k√∂nnen Sie den an ihn √ºbergebenen Handler aus dem Array der Handler des an ihn √ºbergebenen Ereignisses entfernen. </li><li>  <code>removeAllListeners()</code> - Erm√∂glicht das Entfernen aller Handler des an ihn √ºbergebenen Ereignisses. </li></ul><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Heute haben wir √ºber asynchrone Programmierung in JavaScript gesprochen, insbesondere √ºber R√ºckrufe, Versprechen und das Konstrukt async / await.  Hier haben wir das Problem der Arbeit mit Ereignissen angesprochen, die vom Entwickler mithilfe des <code>events</code> .  Unser n√§chstes Thema werden Netzwerkmechanismen der Node.js-Plattform sein. <br><br>  <b>Liebe Leser!</b>  Verwenden Sie beim Programmieren f√ºr Node.js das Konstrukt async / await? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424555/">https://habr.com/ru/post/de424555/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424539/index.html">Java 11: neu in String</a></li>
<li><a href="../de424541/index.html">UGJ 2018 Fiasko-Geschichte: Wie man ein Spiel macht, das niemand mag (tu es nicht!)</a></li>
<li><a href="../de424543/index.html">Java 11 / JDK 11: Allgemeine Verf√ºgbarkeit</a></li>
<li><a href="../de424551/index.html">Warm and Tube: F√ºnf Balalaikas √ºber magnetische Audiotechnologie</a></li>
<li><a href="../de424553/index.html">Node.js Guide, Teil 6: Ereignisschleife, Call Stack, Timer</a></li>
<li><a href="../de424557/index.html">Node.js-Handbuch, Teil 8: HTTP- und WebSocket-Protokolle</a></li>
<li><a href="../de424559/index.html">Big Data Resistance 1 oder schwer fassbarer Joe. Internet-Anonymit√§t, Anti-Erkennung, Anti-Tracking f√ºr Anti-Sie und Anti-uns</a></li>
<li><a href="../de424563/index.html">Beeline sendet Einzelheiten zu Gespr√§chen an Fremde</a></li>
<li><a href="../de424565/index.html">√úbersicht: 3D-Scannen von Immobilien</a></li>
<li><a href="../de424567/index.html">Die Erfahrung, Online-Werbung im lokalen Netzwerk des Unternehmens zu blockieren</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>