<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçü ‚öìÔ∏è üîí Manuel Node.js, partie 7: programmation asynchrone üë¶üèæ üõ¥ ü§ï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aujourd'hui, dans la traduction de la septi√®me partie du manuel Node.js, nous parlerons de la programmation asynchrone, examinerons des questions tell...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Manuel Node.js, partie 7: programmation asynchrone</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/424555/">  Aujourd'hui, dans la traduction de la septi√®me partie du manuel Node.js, nous parlerons de la programmation asynchrone, examinerons des questions telles que l'utilisation des rappels, des promesses et de la construction async / wait, et discuterons de la fa√ßon de travailler avec les √©v√©nements. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/he/di/2j/hedi2j_qyfbnwfo_jqnnqd3ub6o.png"></a> <br><br><div class="spoiler">  <b class="spoiler_title">[Nous vous conseillons de lire] Autres parties du cycle</b> <div class="spoiler_text">  Partie 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Informations g√©n√©rales et mise en route</a> <br>  Partie 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JavaScript, V8, quelques astuces de d√©veloppement</a> <br>  Partie 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">H√©bergement, REPL, travailler avec la console, les modules</a> <br>  Partie 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fichiers npm, package.json et package-lock.json</a> <br>  Partie 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">npm et npx</a> <br>  Partie 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">boucle d'√©v√©nements, pile d'appels, temporisateurs</a> <br>  Partie 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Programmation asynchrone</a> <br>  Partie 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Guide Node.js, Partie 8: Protocoles HTTP et WebSocket</a> <br>  Partie 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Guide Node.js, partie 9: utilisation du syst√®me de fichiers</a> <br>  Partie 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Guide Node.js, Partie 10: Modules standard, flux, bases de donn√©es, NODE_ENV</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PDF complet du guide Node.js</a> <br></div></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Asynchronie dans les langages de programmation</font> </h2><br>  JavaScript lui-m√™me est un langage de programmation synchrone √† un seul thread.  Cela signifie que vous ne pouvez pas cr√©er de nouveaux threads dans le code qui s'ex√©cutent en parall√®le.  Cependant, les ordinateurs sont intrins√®quement asynchrones.  Autrement dit, certaines actions peuvent √™tre effectu√©es quel que soit le flux d'ex√©cution du programme principal.  Dans les ordinateurs modernes, chaque programme est allou√© une certaine quantit√© de temps processeur, lorsque ce temps est √©coul√©, le syst√®me donne des ressources √† un autre programme, √©galement pendant un certain temps.  Ces commutations sont effectu√©es de mani√®re cyclique, cela se fait si rapidement qu'une personne ne peut tout simplement pas le remarquer, en cons√©quence, nous pensons que nos ordinateurs ex√©cutent de nombreux programmes simultan√©ment.  Mais c'est une illusion (sans parler des machines multiprocesseurs). <br><br>  Dans les entrailles des programmes, des interruptions sont utilis√©es - des signaux transmis au processeur et permettant d'attirer l'attention du syst√®me.  Nous n'entrerons pas dans les d√©tails, le plus important est de se rappeler que le comportement asynchrone, lorsque le programme est suspendu jusqu'au moment o√π il a besoin de ressources processeur, est tout √† fait normal.  √Ä un moment o√π le programme ne charge pas le syst√®me de travail, l'ordinateur peut r√©soudre d'autres probl√®mes.  Par exemple, avec cette approche, lorsqu'un programme attend une r√©ponse √† une requ√™te r√©seau qui lui est adress√©e, il ne bloque pas le processeur tant qu'une r√©ponse n'est pas re√ßue. <br><br>  En r√®gle g√©n√©rale, les langages de programmation sont asynchrones, certains d'entre eux donnent au programmeur la possibilit√© de contr√¥ler les m√©canismes asynchrones, √† l'aide des outils de langage int√©gr√©s ou de biblioth√®ques sp√©cialis√©es.  Nous parlons de langages tels que C, Java, C #, PHP, Go, Ruby, Swift, Python.  Certains d'entre eux vous permettent de programmer en style asynchrone, en utilisant des threads, en d√©marrant de nouveaux processus. <br><br><h2>  <font color="#3AC1EF">Asynchronie JavaScript</font> </h2><br>  Comme d√©j√† mentionn√©, JavaScript est un langage synchrone √† un seul thread.  Les lignes de code √©crites en JS sont ex√©cut√©es dans l'ordre dans lequel elles apparaissent dans le texte, l'une apr√®s l'autre.  Par exemple, voici un programme JS tr√®s normal qui illustre ce comportement: <br><br><pre><code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c = a * b console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(c) doSomething()</code> </pre> <br>  Mais JavaScript a √©t√© cr√©√© pour √™tre utilis√© dans les navigateurs.  Sa t√¢che principale, au tout d√©but, √©tait d'organiser le traitement des √©v√©nements li√©s aux activit√©s des utilisateurs.  Par exemple, ce sont des √©v√©nements tels que <code>onClick</code> , <code>onSubmit</code> , <code>onSubmit</code> , <code>onSubmit</code> , etc.  Comment r√©soudre de tels probl√®mes dans le cadre d'un mod√®le de programmation synchrone? <br><br>  La r√©ponse r√©side dans l'environnement dans lequel JavaScript s'ex√©cute.  √Ä savoir, le navigateur vous permet de r√©soudre efficacement ces probl√®mes, en donnant au programmeur les API appropri√©es. <br><br>  Dans l'environnement de Node.js, il existe des outils pour effectuer des op√©rations d'E / S non bloquantes, comme travailler avec des fichiers, organiser l'√©change de donn√©es sur un r√©seau, etc. <br><br><h2>  <font color="#3AC1EF">Rappels</font> </h2><br>  Si nous parlons de JavaScript bas√© sur un navigateur, on peut noter qu'il est impossible de savoir √† l'avance lorsque l'utilisateur clique sur un bouton.  Afin de garantir que le syst√®me r√©ponde √† un tel √©v√©nement, un gestionnaire est cr√©√© pour lui. <br><br>  Le gestionnaire d'√©v√©nements accepte une fonction qui sera appel√©e lorsque l'√©v√©nement se produit.  Cela ressemble √† ceci: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'button'</span></span>).addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    })</code> </pre> <br>  Ces fonctions sont √©galement appel√©es fonctions de rappel ou rappels. <br><br>  Un rappel est une fonction r√©guli√®re qui est pass√©e en tant que valeur √† une autre fonction.  Il sera appel√© uniquement lorsqu'un certain √©v√©nement se produit.  JavaScript impl√©mente le concept de fonctions de premi√®re classe.  Ces fonctions peuvent √™tre affect√©es √† des variables et transmises √† d'autres fonctions (appel√©es fonctions d'ordre sup√©rieur). <br><br>  Une approche courante dans le d√©veloppement JavaScript c√¥t√© client est lorsque tout le code client est envelopp√© dans un √©couteur de l'√©v√©nement de <code>load</code> d'un objet <code>window</code> , qui appelle le rappel qui lui est pass√© une fois que la page est pr√™te √† fonctionner: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'load'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     })</code> </pre> <br>  Les rappels sont utilis√©s partout, et pas seulement pour g√©rer les √©v√©nements DOM.  Par exemple, nous avons d√©j√† rencontr√© leur utilisation dans les minuteries: <br><br><pre> <code class="hljs javascript">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   2  }, 2000)</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les demandes XHR</a> utilisent √©galement des rappels.  Dans ce cas, cela ressemble √† l'attribution d'une fonction √† la propri√©t√© correspondante.  Une fonction similaire sera appel√©e lorsqu'un certain √©v√©nement se produit.  Dans l'exemple suivant, un tel √©v√©nement est un changement d'√©tat de la demande: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> xhr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest() xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xhr.readyState === <span class="hljs-number"><span class="hljs-number">4</span></span>) {   xhr.status === <span class="hljs-number"><span class="hljs-number">200</span></span> ? <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(xhr.responseText) : <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(<span class="hljs-string"><span class="hljs-string">'error'</span></span>) } } xhr.open(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'https://yoursite.com'</span></span>) xhr.send()</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Gestion des erreurs dans les rappels</font> </h3><br>  Parlons de la fa√ßon de g√©rer les erreurs dans les rappels.  Il existe une strat√©gie commune pour g√©rer ces erreurs, qui est √©galement utilis√©e dans Node.js.  Il consiste dans le fait que le premier param√®tre de toute fonction de rappel est un objet d'erreur.  S'il n'y a aucune erreur, <code>null</code> sera √©crit dans ce param√®tre.  Sinon, il y aura un objet d'erreur contenant sa description et des informations suppl√©mentaires √† son sujet.  Voici √† quoi √ßa ressemble: <br><br><pre> <code class="hljs coffeescript">fs.readFile(<span class="hljs-string"><span class="hljs-string">'/file.json'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, data)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) {   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data) })</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Probl√®me de rappel</font> </h3><br>  Les rappels sont pratiques √† utiliser dans des situations simples.  Cependant, chaque rappel est un niveau suppl√©mentaire d'imbrication de code.  Si plusieurs rappels imbriqu√©s sont utilis√©s, cela conduit rapidement √† une complication importante de la structure du code: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'load'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'button'</span></span>).addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {     items.forEach(item =&gt; {       <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>,  -      })   }, <span class="hljs-number"><span class="hljs-number">2000</span></span>) }) })</code> </pre> <br>  Dans cet exemple, seuls 4 niveaux de code sont affich√©s, mais en pratique, on peut rencontrer un grand nombre de niveaux, g√©n√©ralement appel√©s ¬´enfer de rappel¬ª.  Vous pouvez r√©soudre ce probl√®me en utilisant d'autres constructions de langage. <br><br><h2>  <font color="#3AC1EF">Promesses et asynchronisation / attente</font> </h2><br>  √Ä partir de la norme ES6, JavaScript introduit de nouvelles fonctionnalit√©s qui facilitent l'√©criture de code asynchrone, √©liminant ainsi le besoin de rappels.  Nous parlons des promesses qui sont apparues dans ES6 et de la construction async / wait qui est apparue dans ES8. <br><br><h3>  <font color="#3AC1EF">‚ñç Promesses</font> </h3><br>  Les promesses (objets de promesse) sont l'une des fa√ßons de travailler avec des constructions logicielles asynchrones en JavaScript, ce qui, en g√©n√©ral, r√©duit l'utilisation des rappels. <br><br><h4>  Connaissance des promesses </h4><br>  Les promesses sont g√©n√©ralement d√©finies comme des objets proxy pour certaines valeurs, dont l'apparition est attendue √† l'avenir.  Les promesses sont √©galement appel√©es ¬´promesses¬ª ou ¬´r√©sultats promis¬ª.  Bien que ce concept existe depuis de nombreuses ann√©es, les promesses ont √©t√© normalis√©es et ajout√©es au langage uniquement dans ES2015.  Dans ES2017, la conception asynchrone / attendent, qui est bas√©e sur des promesses et qui peut √™tre consid√©r√©e comme leur remplacement pratique, est apparue.  Par cons√©quent, m√™me si vous ne pr√©voyez pas d'utiliser des promesses r√©guli√®res, il est important de comprendre comment elles fonctionnent pour une utilisation efficace de la construction async / wait. <br><br><h4>  Comment fonctionnent les promesses </h4><br>  Une fois qu'une promesse est appel√©e, elle passe dans un √©tat en attente.  Cela signifie que la fonction qui a provoqu√© la promesse continue d'√™tre ex√©cut√©e, tandis que certains calculs sont effectu√©s dans la promesse, apr√®s quoi la promesse en informe.  Si l'op√©ration effectu√©e par la promesse se termine avec succ√®s, la promesse est alors transf√©r√©e √† l'√©tat rempli.  On dit qu'une telle promesse a √©t√© men√©e √† bien.  Si l'op√©ration se termine avec une erreur, la promesse est plac√©e √† l'√©tat rejet√©. <br><br>  Parlons de travailler avec des promesses. <br><br><h4>  Cr√©er des promesses </h4><br>  L'API pour travailler avec des promesses nous donne le constructeur correspondant, qui est appel√© par une commande de la forme <code>new Promise()</code> .  Voici comment les promesses sont cr√©√©es: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> done = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isItDoneYet = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (done) {     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> workDone = <span class="hljs-string"><span class="hljs-string">'Here is the thing I built'</span></span>     resolve(workDone)   } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> why = <span class="hljs-string"><span class="hljs-string">'Still working on something else'</span></span>     reject(why)   } } )</code> </pre> <br>  Promis v√©rifie la constante globale <code>done</code> et si sa valeur est <code>true</code> , elle est r√©solue avec succ√®s.  Sinon, la promesse est rejet√©e.  En utilisant les param√®tres de <code>resolve</code> et de <code>reject</code> , qui sont des fonctions, nous pouvons renvoyer des valeurs de la promesse.  Dans ce cas, nous renvoyons une cha√Æne, mais ici un objet peut √™tre utilis√©. <br><br><h4>  Travailler avec des promesses </h4><br>  Nous avons cr√©√© une promesse ci-dessus, envisagez maintenant de travailler avec elle.  Cela ressemble √† ceci: <br><br><pre> <code class="hljs coffeescript">const isItDoneYet = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise( <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>... ) const checkIfItsDone = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { isItDoneYet   .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ok)</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(ok)   })   .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err)   }) } checkIfItsDone()</code> </pre> <br>  L'appel de <code>checkIfItsDone()</code> entra√Ænera l'ex√©cution de la <code>isItDoneYet()</code> isItDoneYet <code>isItDoneYet()</code> et l'organisation de l'attente de sa r√©solution.  Si la promesse se r√©sout avec succ√®s, le rappel pass√© √† la m√©thode <code>.then()</code> fonctionnera.  Si une erreur se produit, c'est-√†-dire que la promesse sera rejet√©e, elle peut √™tre trait√©e dans la fonction pass√©e √† la m√©thode <code>.catch()</code> . <br><br><h4>  Encha√Æner les promesses </h4><br>  Les m√©thodes de promesse renvoient des promesses, ce qui vous permet de les combiner en cha√Ænes.  Un bon exemple de ce comportement est l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">API Fetch</a> bas√©e sur navigateur, qui est une couche d'abstraction sur <code>XMLHttpRequest</code> .  Il existe un package npm assez populaire pour Node.js qui impl√©mente l'API Fetch, dont nous discuterons plus tard.  Cette API peut √™tre utilis√©e pour charger certaines ressources du r√©seau et, gr√¢ce √† la possibilit√© de combiner des promesses en cha√Æne, pour organiser le traitement ult√©rieur des donn√©es t√©l√©charg√©es.  En fait, lorsque vous appelez l'API Fetch via un appel √† la fonction <code>fetch()</code> , une promesse est cr√©√©e. <br><br>  Prenons l'exemple suivant de l'encha√Ænement des promesses: <br><br><pre> <code class="hljs coffeescript">const fetch = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'node-fetch'</span></span>) const status = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.status &gt;= <span class="hljs-number"><span class="hljs-number">200</span></span> &amp;&amp; response.status &lt; <span class="hljs-number"><span class="hljs-number">300</span></span>) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Promise.resolve(response) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Promise.reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(response.statusText)) } const json = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response)</span></span></span><span class="hljs-function"> =&gt;</span></span> response.json() fetch(<span class="hljs-string"><span class="hljs-string">'https://jsonplaceholder.typicode.com/todos'</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(status) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(json) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Request succeeded with JSON response'</span></span>, data) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Request failed'</span></span>, error) })</code> </pre> <br>  Ici, nous utilisons le package npm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">-fetch</a> et la ressource <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jsonplaceholder.typicode.com</a> comme source de donn√©es JSON. <br><br>  Dans cet exemple, la fonction <code>fetch()</code> est utilis√©e pour charger un √©l√©ment de liste TODO √† l'aide d'une cha√Æne de promesses.  Apr√®s avoir ex√©cut√© <code>fetch()</code> , une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©ponse est</a> retourn√©e qui a de nombreuses propri√©t√©s, parmi lesquelles nous nous int√©ressons aux suivantes: <br><br><ul><li>  <code>status</code> est une valeur num√©rique qui repr√©sente le code d'√©tat HTTP. </li><li>  <code>statusText</code> - une description textuelle du code d'√©tat HTTP, qui est repr√©sent√© par la cha√Æne <code>OK</code> si la demande a r√©ussi. </li></ul><br>  L'objet de <code>response</code> a une m√©thode <code>json()</code> qui renvoie une promesse, √† la r√©solution de laquelle le contenu trait√© du corps de la requ√™te est pr√©sent√©, pr√©sent√© au format JSON. <br><br>  Compte tenu de ce qui pr√©c√®de, nous d√©crivons ce qui se passe dans ce code.  La premi√®re promesse de la cha√Æne est repr√©sent√©e par la fonction <code>status()</code> que nous avons annonc√©e, qui v√©rifie le statut de la r√©ponse, et si elle indique que la demande a √©chou√© (c'est-√†-dire que le code de statut HTTP n'est pas compris entre 200 et 299), la promesse est rejet√©e.  Cette op√©ration conduit au fait que les autres expressions <code>.then()</code> dans la cha√Æne de promesses ne sont pas ex√©cut√©es et nous arrivons imm√©diatement √† la m√©thode <code>.catch()</code> , sortie sur la console, avec le message d'erreur, le texte <code>Request failed</code> . <br><br>  Si le code d'√©tat HTTP nous convient, la fonction <code>json()</code> d√©clar√©e par nous est appel√©e.  √âtant donn√© que la promesse pr√©c√©dente, si elle est r√©solue avec succ√®s, renvoie un objet de <code>response</code> , nous l'utilisons comme valeur d'entr√©e pour la deuxi√®me promesse. <br><br>  Dans ce cas, nous renvoyons les donn√©es JSON trait√©es, de sorte que la troisi√®me promesse les re√ßoive, apr√®s quoi, pr√©c√©d√©es d'un message indiquant que la demande a permis d'obtenir les donn√©es n√©cessaires, sont affich√©es dans la console. <br><br><h4>  Gestion des erreurs </h4><br>  Dans l'exemple pr√©c√©dent, nous avions une m√©thode <code>.catch()</code> attach√©e √† une cha√Æne de promesses.  Si quelque chose se passe mal dans la cha√Æne de promesses et qu'une erreur se produit, ou si l'une des promesses se r√©v√®le rejet√©e, le contr√¥le est transf√©r√© vers l'expression la plus proche <code>.catch()</code> .  Voici la situation lorsqu'une erreur se produit dans une promesse: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve, reject)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(<span class="hljs-string"><span class="hljs-string">'Error'</span></span>) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br>  Voici un exemple de d√©clenchement de <code>.catch()</code> apr√®s avoir rejet√© une promesse: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve, reject)</span></span></span><span class="hljs-function"> =&gt;</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Error'</span></span>) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br><h4>  Gestion des erreurs en cascade </h4><br>  Que faire si une erreur se produit dans l'expression <code>.catch()</code> ?  Pour g√©rer cette erreur, vous pouvez inclure une autre expression <code>.catch()</code> dans la cha√Æne de promesses (puis vous pouvez attacher autant d'expressions <code>.catch()</code> √† la cha√Æne que n√©cessaire): <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve, reject)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(<span class="hljs-string"><span class="hljs-string">'Error'</span></span>) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(<span class="hljs-string"><span class="hljs-string">'Error'</span></span>) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br>  Voyons maintenant quelques m√©thodes utiles pour g√©rer les promesses. <br><br><h4>  Promise.all () </h4><br>  Si vous devez effectuer une action apr√®s avoir r√©solu plusieurs promesses, vous pouvez le faire √† l'aide de la commande <code>Promise.all()</code> .  Prenons un exemple: <br><br><pre> <code class="hljs coffeescript">const f1 = fetch(<span class="hljs-string"><span class="hljs-string">'https://jsonplaceholder.typicode.com/todos/1'</span></span>) const f2 = fetch(<span class="hljs-string"><span class="hljs-string">'https://jsonplaceholder.typicode.com/todos/2'</span></span>) Promise.all([f1, f2]).<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(res)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Array of results'</span></span>, res) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br>  Dans ES2015, la syntaxe de l'affectation destructive est apparue; en l'utilisant, vous pouvez cr√©er des constructions de la forme suivante: <br><br><pre> <code class="hljs powershell">Promise.all([<span class="hljs-type"><span class="hljs-type">f1</span></span>, <span class="hljs-type"><span class="hljs-type">f2</span></span>]).then(([<span class="hljs-type"><span class="hljs-type">res1</span></span>, <span class="hljs-type"><span class="hljs-type">res2</span></span>]) =&gt; {   console.log(<span class="hljs-string"><span class="hljs-string">'Results'</span></span>, res1, res2) })</code> </pre> <br>  Ici, √† titre d'exemple, nous avons consid√©r√© l'API Fetch, mais <code>Promise.all()</code> , bien s√ªr, vous permet de travailler avec toutes les promesses. <br><br><h4>  Promise.race () </h4><br>  La commande <code>Promise.race()</code> vous permet d'effectuer l'action sp√©cifi√©e une fois qu'une des promesses qui lui a √©t√© transmise est r√©solue.  Le rappel correspondant contenant les r√©sultats de cette premi√®re promesse n'est appel√© qu'une seule fois.  Prenons un exemple: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> first = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> {   setTimeout(resolve, <span class="hljs-number"><span class="hljs-number">500</span></span>, <span class="hljs-string"><span class="hljs-string">'first'</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> second = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> {   setTimeout(resolve, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-string"><span class="hljs-string">'second'</span></span>) }) <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.race([first, second]).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result) <span class="hljs-comment"><span class="hljs-comment">// second })</span></span></code> </pre> <br><h4>  Erreur TypeError non intercept√©e qui se produit lors de l'utilisation de promesses </h4><br>  Si, lorsque vous travaillez avec des promesses, vous rencontrez l' <code>Uncaught TypeError: undefined is not a promise</code> erreur de <code>Uncaught TypeError: undefined is not a promise</code> , assurez-vous que la <code>new Promise()</code> construction <code>new Promise()</code> est utilis√©e au lieu de simplement <code>Promise()</code> lors de la cr√©ation de promesses. <br><br><h3>  <font color="#3AC1EF">‚ñç conception asynchrone / en attente</font> </h3><br>  La construction async / wait est une approche moderne de la programmation asynchrone, la simplifiant.  Les fonctions asynchrones peuvent √™tre repr√©sent√©es comme une combinaison de promesses et de g√©n√©rateurs, et, en g√©n√©ral, cette construction est une abstraction sur les promesses. <br><br>  La conception asynchrone / attente r√©duit la quantit√© de code passe-partout que vous devez √©crire lorsque vous travaillez avec des promesses.  Lorsque des promesses sont apparues dans la norme ES2015, elles visaient √† r√©soudre le probl√®me de la cr√©ation de code asynchrone.  Ils ont fait face √† cette t√¢che, mais en deux ans, partageant la sortie des normes ES2015 et ES2017, il est devenu clair qu'ils ne pouvaient pas √™tre consid√©r√©s comme la solution finale au probl√®me. <br><br>  L'un des probl√®mes que les promesses ont r√©solu √©tait le fameux ¬´enfer des rappels¬ª, mais ils, r√©solvant ce probl√®me, ont cr√©√© leurs propres probl√®mes de nature similaire. <br><br>  Les promesses √©taient de simples constructions autour desquelles on pouvait construire quelque chose avec une syntaxe plus simple.  Par cons√©quent, le moment venu, la construction async / wait est apparue.  Son utilisation vous permet d'√©crire du code qui ressemble √† synchrone, mais il est asynchrone, en particulier, il ne bloque pas le thread principal. <br><br><h4>  Fonctionnement de la construction asynchrone / attendent </h4><br>  Une fonction asynchrone renvoie une promesse, comme dans l'exemple suivant: <br><br><pre> <code class="hljs coffeescript">const doSomethingAsync = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve)</span></span></span><span class="hljs-function"> =&gt;</span></span> {       setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">'I did something'</span></span>), <span class="hljs-number"><span class="hljs-number">3000</span></span>)   }) }</code> </pre> <br>  Lorsque vous devez appeler une fonction similaire, vous devez placer le mot-cl√© <code>await</code> avant la commande pour l'appeler.  Cela entra√Ænera le code appelant √† attendre l'autorisation ou le rejet de la promesse correspondante.  Il convient de noter qu'une fonction qui utilise le mot-cl√© <code>await</code> doit √™tre d√©clar√©e √† l'aide du <code>async</code> - <code>async</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> doSomethingAsync()) }</code> </pre> <br>  Combinez les deux fragments de code ci-dessus et examinez son comportement: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomethingAsync = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) =&gt;</span></span> {       setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">'I did something'</span></span>), <span class="hljs-number"><span class="hljs-number">3000</span></span>)   }) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> doSomethingAsync()) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Before'</span></span>) doSomething() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'After'</span></span>)</code> </pre> <br>  Ce code affichera les √©l√©ments suivants: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Before</span></span> <span class="hljs-keyword"><span class="hljs-keyword">After</span></span> I did something</code> </pre> <br>  Le texte que <code>I did something</code> entre dans la console avec un retard de 3 secondes. <br><br><h4>  √Ä propos des promesses et des fonctions asynchrones </h4><br>  Si vous d√©clarez une certaine fonction √† l'aide du <code>async</code> - <code>async</code> , cela signifie qu'une telle fonction renverra une promesse m√™me si elle n'est pas explicitement effectu√©e.  C'est pourquoi, par exemple, l'exemple suivant est un code de travail: <br><br><pre> <code class="hljs powershell">const a<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">Function</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">async</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'test'</span></span> } aFunction().then(console.log) //    <span class="hljs-string"><span class="hljs-string">'test'</span></span></code> </pre> <br>  Cette conception est similaire √† ceci: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> aFunction = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'test'</span></span>) } aFunction().then(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log) <span class="hljs-comment"><span class="hljs-comment">//    'test'</span></span></code> </pre> <br><h4>  Points forts de l'async / attente </h4><br>  En analysant les exemples ci-dessus, vous pouvez voir que le code qui utilise async / wait est plus simple que le code qui utilise le cha√Ænage de promesses, ou un code bas√© sur des fonctions de rappel.  Ici, bien s√ªr, nous avons examin√© des exemples tr√®s simples.  Vous pouvez profiter pleinement des avantages ci-dessus en travaillant avec du code beaucoup plus complexe.  Voici, par exemple, comment charger et analyser des donn√©es JSON √† l'aide de promesses: <br><br><pre> <code class="hljs pgsql">const getFirstUserData = () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(<span class="hljs-string"><span class="hljs-string">'/users.json'</span></span>) //      .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(response =&gt; response.json()) //  <span class="hljs-type"><span class="hljs-type">JSON</span></span>   .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(users =&gt; users[<span class="hljs-number"><span class="hljs-number">0</span></span>]) //      .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(`/users/${<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.name}`)) //       .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(userResponse =&gt; userResponse.json()) //  <span class="hljs-type"><span class="hljs-type">JSON</span></span> } getFirstUserData()</code> </pre> <br>  Voici √† quoi ressemble la solution au m√™me probl√®me en utilisant async / wait: <br><br><pre> <code class="hljs pgsql">const getFirstUserData = async () =&gt; { const response = await <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(<span class="hljs-string"><span class="hljs-string">'/users.json'</span></span>) //    const users = await response.json() //  <span class="hljs-type"><span class="hljs-type">JSON</span></span> const <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = users[<span class="hljs-number"><span class="hljs-number">0</span></span>] //    const userResponse = await <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(`/users/${<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.name}`) //     const userData = await userResponse.json() //  <span class="hljs-type"><span class="hljs-type">JSON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> userData } getFirstUserData()</code> </pre> <br><h4>  Utilisation de s√©quences de fonctions asynchrones </h4><br>  Les fonctions asynchrones peuvent facilement √™tre combin√©es dans des conceptions qui ressemblent √† des cha√Ænes Promise.  Les r√©sultats d'une telle combinaison sont cependant d'une bien meilleure lisibilit√©: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promiseToDoSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> {       setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">'I did something'</span></span>), <span class="hljs-number"><span class="hljs-number">10000</span></span>)   }) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> watchOverSomeoneDoingSomething = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> promiseToDoSomething()   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> something + <span class="hljs-string"><span class="hljs-string">' and I watched'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> watchOverSomeoneWatchingSomeoneDoingSomething = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> watchOverSomeoneDoingSomething()   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> something + <span class="hljs-string"><span class="hljs-string">' and I watched as well'</span></span> } watchOverSomeoneWatchingSomeoneDoingSomething().then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function">) =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res) })</code> </pre> <br>  Ce code affichera le texte suivant: <br><br><pre> <code class="hljs pgsql">I did something <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> I watched <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> I watched <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> well</code> </pre> <br><h4>  D√©bogage simplifi√© </h4><br>  Les promesses sont difficiles √† d√©boguer, car en les utilisant, vous ne pouvez pas utiliser efficacement les outils habituels du d√©bogueur (comme "bypass d'√©tape", step-over).  Le code √©crit en utilisant async / expect peut √™tre d√©bogu√© en utilisant les m√™mes m√©thodes que le code synchrone normal. <br><br><h2>  <font color="#3AC1EF">G√©n√©ration d'√©v√©nements dans Node.js</font> </h2><br>  Si vous avez travaill√© avec JavaScript dans un navigateur, vous savez que les √©v√©nements jouent un r√¥le √©norme dans la gestion des interactions des utilisateurs avec les pages.  Il s'agit de g√©rer les √©v√©nements provoqu√©s par les clics et les mouvements de la souris, les frappes sur le clavier, etc.  Dans Node.js, vous pouvez travailler avec des √©v√©nements que le programmeur cr√©e lui-m√™me.  Ici, vous pouvez cr√©er votre propre syst√®me d'√©v√©nements √† l'aide du module d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©v√©nements</a> .  En particulier, ce module nous offre la classe <code>EventEmitter</code> , dont les capacit√©s peuvent √™tre utilis√©es pour organiser le travail avec les √©v√©nements.  Avant d'utiliser ce m√©canisme, vous devez le connecter: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> EventEmitter = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'events'</span></span>).EventEmitter</code> </pre> <br>  Lorsque vous travaillez avec, les m√©thodes on <code>on()</code> et <code>emit()</code> sont disponibles, entre autres.  La m√©thode <code>emit</code> utilis√©e pour appeler des √©v√©nements.  La m√©thode on est utilis√©e pour configurer les rappels, les gestionnaires d'√©v√©nements qui sont appel√©s lorsqu'un certain √©v√©nement est appel√©. <br><br>  Par exemple, cr√©ons un √©v√©nement de <code>start</code> .  Lorsque cela se produit, nous afficherons quelque chose sur la console: <br><br><pre> <code class="hljs coffeescript">eventEmitter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventEmitter(); eventEmitter.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'started'</span></span>) })</code> </pre> <br>  Pour d√©clencher cet √©v√©nement, la construction suivante est utilis√©e: <br><br><pre> <code class="hljs mel">eventEmitter.<span class="hljs-keyword"><span class="hljs-keyword">emit</span></span>(<span class="hljs-string"><span class="hljs-string">'start'</span></span>)</code> </pre> <br>  √Ä la suite de cette commande, le gestionnaire d'√©v√©nements est appel√© et la cha√Æne <code>started</code> arrive √† la console. <br><br>  Vous pouvez passer des arguments au gestionnaire d'√©v√©nements, en les repr√©sentant comme des arguments suppl√©mentaires √† la m√©thode <code>emit()</code> : <br><br><pre> <code class="hljs coffeescript">eventEmitter.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(number)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(`<span class="javascript"><span class="javascript">started ${number}</span></span>`) }) eventEmitter.emit(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>)</code> </pre> <br>  La m√™me chose se produit dans les cas o√π le gestionnaire doit passer plusieurs arguments: <br><br><pre> <code class="hljs pgsql">eventEmitter.<span class="hljs-keyword"><span class="hljs-keyword">on</span></span>(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) =&gt; { console.log(`started <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ${<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> ${<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>}`) }) eventEmitter.emit(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>)</code> </pre> <br>  <code>EventEmitter</code> classe <code>EventEmitter</code> ont d'autres m√©thodes utiles: <br><br><ul><li>  <code>once()</code> - vous permet d'enregistrer un gestionnaire d'√©v√©nements qui ne peut √™tre appel√© qu'une seule fois. </li><li>  <code>removeListener()</code> - vous permet de supprimer le gestionnaire qui lui est transmis du tableau des gestionnaires de l'√©v√©nement qui lui est transmis. </li><li>  <code>removeAllListeners()</code> - vous permet de supprimer tous les gestionnaires de l'√©v√©nement qui lui sont pass√©s. </li></ul><br><h2>  <font color="#3AC1EF">R√©sum√©</font> </h2><br>  Aujourd'hui, nous avons parl√© de la programmation asynchrone en JavaScript, en particulier, nous avons discut√© des rappels, des promesses et de la construction async / wait.  Ici, nous avons abord√© la question de l'utilisation des √©v√©nements d√©crits par le d√©veloppeur √† l'aide du module d' <code>events</code> .  Notre prochain sujet sera les m√©canismes de mise en r√©seau de la plate-forme Node.js. <br><br>  <b>Chers lecteurs!</b>  Lors de la programmation de Node.js, utilisez-vous la construction async / wait? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr424555/">https://habr.com/ru/post/fr424555/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr424539/index.html">Java 11: nouveau dans String</a></li>
<li><a href="../fr424541/index.html">Histoire du fiasco UGJ 2018: comment cr√©er un jeu que personne n'aime (ne le faites pas!)</a></li>
<li><a href="../fr424543/index.html">Java 11 / JDK 11: disponibilit√© g√©n√©rale</a></li>
<li><a href="../fr424551/index.html">Warm and tube: cinq balala√Økas sur la technologie audio magn√©tique</a></li>
<li><a href="../fr424553/index.html">Guide Node.js, partie 6: boucle d'√©v√©nement, pile d'appels, minuteurs</a></li>
<li><a href="../fr424557/index.html">Guide Node.js, partie 8: protocoles HTTP et WebSocket</a></li>
<li><a href="../fr424559/index.html">R√©sistance Big Data 1 ou Joe insaisissable. Anonymat Internet, anti-d√©tection, anti-tracking pour anti-you et anti-us</a></li>
<li><a href="../fr424563/index.html">Beeline envoie les d√©tails des conversations √† des √©trangers</a></li>
<li><a href="../fr424565/index.html">Pr√©sentation: num√©risation 3D de locaux immobiliers</a></li>
<li><a href="../fr424567/index.html">L'exp√©rience du blocage de la publicit√© en ligne dans le r√©seau local de l'entreprise</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>