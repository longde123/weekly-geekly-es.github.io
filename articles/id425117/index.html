<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤³ğŸ½ ğŸ‘¨ğŸ¾â€ğŸ’¼ ğŸ‘©ğŸ¼â€ğŸš’ Dua bit per transistor: ROM densitas tinggi dalam chip Intel 8087 floating-point ğŸ›« ğŸ‘¨ğŸ¼â€ğŸ’» ğŸ‘©ğŸ»â€ğŸ”§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Intel mengembangkan chip 8087 pada tahun 1980 untuk meningkatkan kinerja PC dengan prosesor garis 8086/8088 (seperti PC IBM) saat melakukan operasi fl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dua bit per transistor: ROM densitas tinggi dalam chip Intel 8087 floating-point</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/425117/">  Intel mengembangkan chip 8087 pada tahun 1980 untuk meningkatkan kinerja PC dengan prosesor garis 8086/8088 (seperti PC IBM) saat melakukan operasi floating point.  Karena mikroprosesor pertama dirancang untuk melakukan operasi dengan bilangan bulat, pelaksanaan operasi dengan angka floating point lambat, yaitu tentang kinerja operasi transendental, seperti fungsi trigonometri atau logaritma.  Coprocessor 8087 secara signifikan meningkatkan kecepatan melaksanakan tugas floating point, semuanya dilakukan hampir 100 kali lebih cepat.  Arsitektur 8087 juga diimplementasikan pada prosesor Intel yang lebih baru, dan instruksi 8087 masih digunakan pada PC x86 modern.  Intel memperkenalkan chip 8087 pada 1980, yang dirancang untuk meningkatkan kinerja komputasi floating point pada prosesor 8086 dan 8088. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/za/uw/rf/zauwrfyx0v8mkj7aqjq7bx0kmhw.jpeg"></div><a name="habracut"></a><br>  Karena mikroprosesor awal hanya bekerja dengan bilangan bulat, aritmatika floating-point lambat, dan operasi transendental seperti pemicu atau logaritma tampak lebih buruk.  Menambahkan 8087 coprocessor matematika ke sistem memungkinkan kami untuk mempercepat operasi floating-point sebanyak 100 kali.  Arsitektur 8087 menjadi bagian dari prosesor Intel yang lebih baru, dan instruksi 8087 (meskipun sudah ketinggalan zaman) masih merupakan bagian dari desktop x86 modern. <br><br>  Chip 8087 memberikan aritmatika floating point cepat untuk PC IBM asli dan menjadi bagian dari arsitektur x86 yang digunakan saat ini.  Salah satu fitur yang tidak biasa dari 8087 adalah ROM multi-level (memori read-only), yang mampu menyimpan dua bit per transistor, yang dua kali kepadatan ROM konvensional.  Alih-alih menyimpan data biner, setiap sel dalam ROM 8087 menyimpan satu dari empat nilai yang berbeda, yang kemudian diterjemahkan ke dalam dua bit.  Karena 8087 membutuhkan ROM dalam jumlah besar untuk mikrokode (1), dan jumlah transistor pada chip sangat terbatas, Intel menggunakan teknologi yang tidak biasa untuk menyelesaikan masalah.  Pada artikel ini, saya akan menjelaskan bagaimana Intel mengimplementasikan ROM berlapis ini. <br><br>  Saya membuka chip 8087 dan memotretnya dengan mikroskop, mengambil foto di bawah.  Dalam foto itu, saya menunjukkan blok fungsional utama berdasarkan teknik reverse saya sendiri (Klik untuk memperbesar gambar).  Matriks prosesor 8087 cukup kompleks, dengan 40.000 transistor (2).  The 8087 menggunakan angka floating point 80-bit: 64 bit dicadangkan untuk mantissa, 15 bit untuk eksponen, dan bit lain yang ditandatangani.  (Contoh angka dengan basis 10: antara 6.02 Ã— 1023, 6.02 adalah mantissa dan 23 adalah eksponen).  Di bagian bawah foto, kata "pemrosesan fraksi" menandai bagian dari sirkuit mantissa.  Dari kiri ke kanan, ini termasuk: penyimpanan konstan, pergeseran 64-bit, 64-bit adder / subtracter, dan register stack.  Sedikit lebih tinggi adalah skema untuk memproses eksponen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hj/gx/q8/hjgxq8dq_dzulzxp79by-ue27jm.jpeg"></div><br>  <i>Chip coprocessor matematika untuk operasi Intel 8087 floating point, dengan penunjukan blok fungsional utama</i> <br><br>  Melaksanakan instruksi pada 8087 membutuhkan beberapa langkah, dan dalam beberapa kasus lebih dari 1000. Firmware 8087 menggunakan mikrokode untuk menentukan operasi tingkat rendah pada setiap langkah: pergeseran, kenaikan, sampel memori, konstanta membaca, dll. Anda dapat melihat mikrokode sebagai program sederhana, ditulis dalam bentuk perintah mikro, di mana setiap perintah mikro menghasilkan sinyal kontrol untuk berbagai komponen chip.  Foto di atas menunjukkan ROM dengan program mikrokode 8087. ROM menempati sebagian besar chip, jelas menunjukkan mengapa ROM multi-level yang kompak diperlukan.  Di sebelah kiri ROM adalah "mesin" di mana program mikrokode diluncurkan, pada kenyataannya, prosesor sederhana. <br><br>  8087 bekerja sebagai coprocessor dengan prosesor 8086. Ketika 8086 mendeteksi instruksi floating point khusus, prosesor mengabaikannya dan membiarkan 8087 untuk menjalankan instruksi secara paralel.  Saya tidak akan menjelaskan secara rinci cara kerja bagian dalam 8087, tetapi, singkatnya, operasi floating point diimplementasikan menggunakan operasi integer add / kurangi dan shift.  Untuk menambah atau mengurangi dua angka floating-point, 8087 melakukan pergeseran bitwise dari angka sampai pembatas biner (yaitu, pemisah desimal adalah koma, tetapi dalam sistem biner) adalah sama, dan kemudian menambahkan atau mengurangi mantissa.  Penggandaan, pembagian dan akar kuadrat dilakukan oleh shift, penambahan atau pengurangan berulang.  Operasi transendental (tan, arctan, log, power) menggunakan algoritma CORDIC, yang menggunakan shift dan penambahan konstanta khusus, memproses satu bit pada satu waktu.  8087 juga menemui banyak kasus khusus: infinity, overflow, NaN (bukan angka), angka denormalized, dan beberapa mode pembulatan.  Mikrokode yang disimpan dalam ROM mengendalikan semua operasi ini. <br><br><h3>  Implementasi ROM </h3><br>  Chip 8087 terdiri dari matriks silikon kecil di mana silikon didoping dengan pengotor di beberapa tempat untuk mendapatkan sifat semikonduktor yang diinginkan.  Polisilikon (jenis silikon khusus) diterapkan pada permukaan silikon, yang membentuk kabel dan transistor.  Dan akhirnya, lapisan logam di atas silikon melengkapi rangkaian listrik yang berfungsi.  Dalam foto di bawah ini, di sisi kiri, sebagian kecil chip ditunjukkan, seperti yang terlihat di bawah mikroskop, menunjukkan kabel logam kekuningan.  Di sisi kanan foto, logam dihilangkan dengan asam, memperlihatkan polisilikon dan silikon.  Ketika polisilikon melintasi silikon, sebuah transistor terbentuk.  Area merah muda adalah silikon yang diolah, dan garis vertikal tipis adalah polisilikon.  Lingkaran kecil adalah kontak antara lapisan silikon dan logam, yang menghubungkan keduanya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cg/us/9j/cgus9jmdjvhec5j30deqymfz8r4.png"></div><br>  <i>Struktur ROM di Intel 8087 FPU.</i>  <i>Lapisan logam ditampilkan di sebelah kiri, dan polisilikon dan silikon di sebelah kanan.</i> <br><br>  Meskipun ada banyak cara untuk membangun ROM, cara standar adalah membuat kisi "sel" di mana setiap sel menyimpan satu bit.  Setiap sel mungkin memiliki transistor (yang berarti 0 bit) atau tidak memiliki transistor, yang berarti 1 bit.  Pada gambar di atas, Anda dapat melihat kisi sel dengan transistor (di mana polisilikon diterapkan pada silikon) dan transistor yang hilang (di mana ada kesenjangan dalam silikon).  Untuk membaca informasi dari ROM, satu baris pemilihan kolom diaktifkan (berdasarkan alamat) untuk memilih bit yang disimpan dalam kolom ini dan mendapatkan satu bit dari setiap baris pada output.  Anda dapat melihat garis pemilihan kolom vertikal (garis pilih kolom) dari polisilikon, dan baris logam horizontal pada foto di atas.  Garis-garis vertikal dari silikon yang di-ground dibumikan. <br><br>  Diagram di bawah ini (sesuai dengan segmen ROM 4x4) menjelaskan bagaimana fungsi ROM.  Setiap sel memiliki transistor (hitam), atau tidak memiliki transistor (berwarna abu-abu).  Ketika tegangan diberikan ke jalur pemilihan kolom polisilikon, transistor dalam kolom ini menghidupkan dan membumikan baris logam yang sesuai.  (dalam hal ini, transistor NMOS seperti gerbang yang terbuka jika inputnya adalah 0, dan ditutup jika inputnya adalah 1.) â€œBarisâ€ logam dari rangkaian menghasilkan data yang disimpan dalam â€œkolomâ€ yang dipilih. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oi/sl/q_/oislq_mbf-lyx6kbddwl4wxbgya.png"></div><br>  <i>Segmen Skema 4x4 ROM</i> <br><br>  Sinyal pemilihan kolom dihasilkan oleh rangkaian dekoder.  Karena rangkaian ini dibangun dari katup NOR, saya pertama-tama akan menjelaskan desain katup.  Diagram di bawah ini menunjukkan gerbang NOR empat input yang dibangun dari empat transistor dan resistor pull-up (walaupun sebenarnya, transistor khusus melakukan fungsi resistor).  Di sisi kiri rangkaian, semua input adalah 0, sehingga semua transistor dimatikan, dan resistor pull-up mempertahankan sinyal output pada level "tinggi".  Di sisi kanan, 1 diterapkan ke salah satu input, menyalakan transistor.  Transistor di-ground, jadi sinyal keluarannya sekarang "rendah".  Jadi, jika ada input yang tinggi (1), outputnya rendah (0).  Jadi sirkuit ini mengimplementasikan katup NOR. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_n/if/hi/_nifhiurrurn523sddqmq8w3eq8.png"></div><br>  <i>Gerbang NOR 4 arah dibangun dari transistor NMOS</i> <br><br>  Rangkaian dekoder pemilihan kolom menerima bit alamat yang masuk dan mengaktifkan jalur pilihan yang sesuai.  Dekoder berisi 8-input gerbang NOR untuk setiap kolom, yaitu, satu gerbang NOR untuk setiap alamat.  Foto menunjukkan dua elemen NOR yang menghasilkan sinyal pemilihan kolom (untuk kesederhanaan, saya hanya akan menampilkan empat dari 8 input).  Setiap kolom menggunakan kombinasi berbeda dari garis alamat dan garis alamat empuk sebagai input, memilih alamat yang berbeda.  Baris alamat berada dalam lapisan logam, yang dihapus pada foto di bawah ini;  garis alamat disorot dalam warna hijau.  Untuk menentukan alamat yang terkait dengan kolom, lihat pin persegi yang terkait dengan setiap transistor dan catat garis alamat mana yang terhubung.  Jika semua garis alamat yang terhubung ke transistor kolom berada pada level rendah (0), gerbang NOR akan memilih kolom itu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hd/va/bt/hdvabtftpvkypgl28rpwa2ev2vy.png"></div><br>  <i>Bagian dari decoder alamat.</i>  <i>Dekoder alamat memilih kolom ganjil dalam ROM, dihitung dari kanan ke kiri.</i>  <i>Angka-angka di atas menunjukkan alamat yang terkait dengan setiap output.</i> <br><br>  Foto di bawah ini menunjukkan sebagian kecil dari dekoder ROM dengan semua 8 input untuk gerbang NOR.  Anda dapat membaca alamat biner dengan memeriksa dengan seksama koneksi di bilah alamat.  Perhatikan pola biner: a1 bergabung dengan nilai perubahan di setiap kolom, a2 bergabung bergantian setiap dua kolom, a3 bergabung setiap empat kolom, dll. A0 diperbaiki karena sirkuit dekoder ini memilih kolom ganjil;  sirkuit ROM yang sama memilih alamat genap (pemisahan seperti itu diperlukan agar decoder cocok dengan chip, karena setiap kolom decoder selebar dua kali sel ROM). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l-/el/lv/l-ellviplb3kupadfsrcgwqp_ui.png"></div><br>  <i>Bagian dari decoder alamat untuk mikrokode ROM 8087. Dekoder mengubah alamat 8-bit menjadi sinyal pemilihan kolom</i> <br><br>  Komponen terakhir dari ROM adalah seperangkat multiplexer yang mengurangi 64 saluran keluaran menjadi 8 saluran.  Setiap multiplexer 8-ke-1 memilih salah satu dari 8 inputnya berdasarkan alamat.  Diagram di bawah ini menunjukkan salah satu dari multiplexer jalur prosesor 8087, dibangun dari delapan transistor pass-through besar, yang masing-masing terhubung ke salah satu jalur "line".  Semua transistor terhubung ke output, jadi ketika transistor yang dipilih dihidupkan, ia mentransfer inputnya ke output.  Transistor multiplexer jauh, jauh lebih besar daripada transistor dalam ROM untuk mengurangi distorsi sinyal ROM.  Sebuah decoder (mirip dengan yang dipertimbangkan sebelumnya, tetapi lebih kecil) menghasilkan delapan garis kontrol multiplexer dari tiga garis alamat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/m2/kx/_o/m2kx_ochmi4nes3z-bjryrrsmbq.png"></div><br>  <i>Salah satu multiplexer 8-baris dalam ROM.</i>  <i>Di sini Anda dapat melihat lapisan silikon (poli), dengan senyawa logam dicat oranye</i> <br><br>  Untuk meringkas, ROM menyimpan bit dalam kotak.  Ia menggunakan delapan bit alamat untuk memilih kolom di kisi.  Kemudian tiga bit alamat pilih delapan output yang diinginkan dari "garis". <br><br><h3>  ROM berlapis </h3><br>  Sejauh ini, saya telah menjelaskan perangkat ROM khas yang menyimpan satu bit per sel.  Jadi bagaimana 8087 dapat menyimpan dua bit per sel?  Jika Anda perhatikan dengan teliti, mikrokode ROM 8087 berisi empat ukuran transistor yang berbeda - jika Anda menganggap tidak adanya transistor sebagai salah satu ukuran (6).  Dengan empat opsi untuk setiap transistor, satu sel dapat menyandikan dua bit, kira-kira menggandakan densitas (7).  Bagian saat ini menjelaskan bagaimana empat ukuran transistor menghasilkan empat arus yang berbeda, dan bagaimana sirkuit analog dan digital dari chip mengubah arus ini menjadi dua bit. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yk/fb/g2/ykfbg2a-lsfxfa2c7ijsmcjxlzk.png"></div><br>  <i>Sebuah mikrograf ROM mikrokode 8087 menunjukkan empat ukuran transistor yang berbeda.</i>  <i>Ini memungkinkan ROM untuk menyimpan dua bit per sel.</i> <br><br>  Ukuran transistor mengendalikan arus melalui transistor (8).  Faktor geometris yang penting adalah lebar silikon yang berbeda (merah muda), di mana ia bersinggungan dengan polisilikon (garis vertikal), menciptakan transistor dengan lebar gerbang yang berbeda.  Karena lebar gerbang mengontrol arus melalui transistor, empat ukuran transistor menghasilkan empat arus yang berbeda: transistor terbesar melewati sebagian besar arus, dan tidak ada arus yang mengalir sama sekali jika tidak ada transistor. <br><br>  Arus ROM dikonversi menjadi bit dalam beberapa langkah.  Pertama, resistor pull-up mengubah arus menjadi tegangan.  Kemudian, tiga pembanding membandingkan tegangan dengan tegangan referensi untuk menghasilkan sinyal digital, menentukan tegangan mana yang lebih tinggi / lebih rendah.  Akhirnya, gerbang logika mengubah sinyal keluaran komparator menjadi dua bit keluaran.  Pola ini diulang delapan kali, menghasilkan total 16 bit pada output. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ad/a6/go/ada6goh-_wnbiaam90ai_nxgfdk.png"></div><br>  <i>Skema untuk membaca dua bit dari sel ROM</i> <br><br>  Diagram di atas melakukan langkah-langkah konversi ini.  Akibatnya, salah satu transistor ROM dipilih oleh jalur pemilihan "kolom" dan multiplexer (dibahas sebelumnya) yang menghasilkan satu dari empat arus.  Kemudian, resistor pull-up (12) mengubah arus transistor menjadi tegangan, akibatnya tegangan tergantung pada ukuran transistor yang dipilih.  Komparator membandingkan tegangan ini dengan tiga tegangan referensi, dan output 1 jika tegangan ROM lebih tinggi dari tegangan referensi.  Komparator dan tegangan referensi memerlukan desain yang hati-hati, karena tegangan ROM dapat berbeda hanya 200 mV. <br><br>  Tegangan referensi berada di tengah-tengah antara nilai tegangan yang diharapkan dari ROM, yang memungkinkan beberapa fluktuasi tegangan.  Tegangan ROM "rendah" lebih rendah dari semua tegangan referensi, sehingga semua komparator akan menghasilkan 0. Tegangan ROM kedua lebih tinggi dari Ref 0, sehingga output komparator lebih rendah 1. Pada tegangan ROM ketiga, dua komparator yang lebih rendah menghasilkan 1, dan maksimum tegangan ROM pada output dari ketiga pembanding 1. Dengan demikian, tiga pembanding menghasilkan empat pola keluaran yang berbeda, tergantung pada ROM transistor.  Elemen logika kemudian mengubah output komparator menjadi dua bit output (10). <br><br>  Desain komparator menarik karena merupakan jembatan antara dunia analog dan digital, menghasilkan 1 atau 0 jika tegangan ROM lebih tinggi atau lebih rendah dari tegangan referensi.  Setiap komparator berisi penguat diferensial yang memperkuat perbedaan antara tegangan ROM dan tegangan referensi.  Output dari penguat diferensial menggerakkan gerbang yang menstabilkan output dan mengubahnya menjadi sinyal level logika.  Penguat diferensial (di bawah) adalah rangkaian analog standar.  Sumber saat ini (simbol di bawah) memberikan arus searah.  Jika salah satu transistor memiliki tegangan input yang lebih tinggi daripada yang lain, sebagian besar arus melewati transistor ini.  Penurunan tegangan melintasi resistor akan menyebabkan output yang sesuai menjadi lebih rendah dan output lainnya menjadi lebih tinggi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d6/fn/ns/d6fnnswmm1veissvrruouwjrrmi.png"></div><br>  <i>Diagram yang menunjukkan operasi pasangan diferensial.</i>  <i>Sebagian besar arus akan melewati transistor dengan tegangan input yang lebih tinggi, menghasilkan sinyal output yang lebih rendah.</i>  <i>Simbol lingkaran ganda di bawah ini adalah sumber arus searah I</i> <br><br>  Foto di bawah ini menunjukkan salah satu pembanding pada sebuah chip;  lapisan logam di atas, transistor di bawahnya.  Saya hanya akan mempertimbangkan poin utama skema rumit ini;  Lihat catatan 12 untuk detailnya.  Sinyal dari ROM dan multiplexer disuplai ke kiri.  Sirkuit pull-up 12 mengubah arus menjadi tegangan.  Dua transistor penguat diferensial besar membandingkan tegangan ROM dengan tegangan referensi (input dari atas).  Output dari penguat diferensial pergi ke sirkuit rana (tersebar di foto);  output rana berada di sudut kanan bawah.  Sumber arus dari penguat diferensial dan resistor pull-up terbuat dari transistor mode penipisan.  Tiga komparator output digunakan di setiap sirkuit output, memberikan total 24 komparator. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pm/ec/jr/pmecjrsutl-vzf3k0qvzgw5t1cw.png"></div><br>  <i>Salah satu pembanding pada 8087. Chip ini berisi 24 pembanding untuk mengubah level tegangan dari ROM bertingkat ke data biner</i> <br><br>  Setiap tegangan referensi dihasilkan oleh transistor dengan ukuran yang dipilih dengan cermat dan sirkuit pull-up.  Rangkaian referensi tegangan dirancang sedekat mungkin dengan sirkuit sinyal ROM, sehingga setiap perubahan dalam pembuatan chip akan mempengaruhi kedua elemen secara sama.  Tegangan referensi dan sinyal ROM menggunakan sirkuit beban yang sama.  Selain itu, setiap rangkaian tegangan referensi termasuk transistor yang sangat besar, identik dengan transistor multiplexer, meskipun tidak ada multiplexing di sirkuit sinyal referensi - hanya untuk memastikan "kecocokan" dari sirkuit.  Tiga rangkaian tegangan referensi identik kecuali untuk ukuran transistor referensi (9). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/11/je/wn/11jewn6dap_lxtfqtvrh7vdzcfw.png"></div><br>  <i>Sebuah sirkuit menghasilkan tiga tegangan referensi.</i>  <i>Ukuran transistor referensi berada di antara ukuran transistor ROM.</i>  <i>Lapisan oksida tidak sepenuhnya dihapus dari bagian matriks ini, karena warna yang berputar muncul di foto</i> <br><br>  Untuk merakit seluruh puzzle, foto di bawah ini menunjukkan lokasi komponen-komponen mikrokode ROM pada chip (12).  Bagian utama dari rangkaian ROM terdiri dari transistor yang menyimpan data.  Rangkaian dekoder kolom terletak di atas dan di bawah data ROM.  Setengah dari decoder pemilihan kolom di atas dan setengah di bawah, untuk tata letak yang lebih baik.  Sirkuit output di sebelah kanan.  Delapan multiplexer memotong 64 baris menjadi delapan.  Kemudian delapan baris memasuki komparator, menghasilkan 16 bit pada output ROM ke kanan.  Rangkaian referensi di atas komparator menghasilkan tiga tegangan referensi.  Di kanan bawah, decoder garis kecil mengontrol multiplexer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-q/df/9s/-qdf9s_vh19u5bxltwg59ye7_2o.png"></div><br>  <i>ROM firmware dari Intel 8087 FPU dilabeli dengan komponen utama</i> <br><br>  Meskipun pada awalnya mungkin tampak bahwa ROM multilevel akan setengah dari ROM konvensional, efeknya tidak begitu terlihat karena rangkaian tambahan komparator, dan karena fakta bahwa transistor itu sendiri sedikit lebih besar, karena kebutuhan untuk menggunakan beberapa ukuran.  Meskipun demikian, ROM multilevel menghemat sekitar 40% dari ruang yang akan ditempati oleh ROM biasa. <br><br>  Sekarang saya mengerti struktur ROM, saya bisa dengan sederhana (tapi membosankan) membaca isi ROM, hanya melihat ukuran masing-masing transistor di bawah mikroskop.  Tapi, tidak mengetahui set instruksi mikrokode, isi ROM tidak berguna. <br><br><h3>  Kesimpulan </h3><br>        8087    Â«   Â»     . Intel       1981     iAPX 432.11    ,           1980-    . , - , ,   ,          ,    ,    ,     (14). <br><br> ,     ,    -.  -        (13). -    4    ( 16   )   ,   (QLC, quad-level cell).  ,   1980-    ,  . <br><br>          ,     @kenshirriff      8087.     RSS-.        8087. <br><br><h3>    </h3><br><ol><li>  8087  1648   (   ),  16    ,  26368 .       ,  Intel      . </li><li>         8087: Intel ,  40 000 ,   ,  45 000.         .  ,     , PLA      ,   ,    Â«Â» ,     .       ,               . </li><li>    8086        8087  ;     .     ,  8087     8086    ,    8087.    ,  8086     ,      .  , 8087     8086 (     8088),   ,   8086.       ,  8086,     . 8087      ,        8086.  ,  8086   8087,        ,   .  , 8087    ,     ,    .  8087 ,      ,    .      8087    8087,       . </li><li> ,         ,   ,            ,     ,   .    ,    ROM,     ,         . ,     8     1/8 ,     1/8 .  , ,   (, 1  Ã— 16)    ,        .   , Â«Â»     . ,     Intel   ; 1405  512      .     ,    Â«Â» -  20 . </li><li>   IBM       :       (  ,    ),      (link).  ,   Xerox Alto,      .     ,       .      ,       . </li><li>         ,       Hacker News ,  8087      .    ,        ,    . </li><li>       1980-       . Mostek        :        .     ,      .      Intel,      (      ),            .     (  )          .                (    ),    ,      .       Z-80     Â«Â», ,       ,   ,    .     ,  ,      Z-80      ,     ,     ,      . </li><li>          . ( â€”      .)   ( ,    )      ,     .   MOSFET . Wikipedia </li><li>        ,   -.    ,          .  ,  Reference 0    ,     .        ,   ,   . :    , ,    ,    .   -       ,      ,    ,       . </li><li>         :   = 00,   = 01,   = 11,   = 10.          ;         ,   ,      . (. Â«Two Bits Per Cell ROMÂ», Stark). </li><li>   Intel iAPX 43203 (1981)   ,     8087.     Â«The interface processor for the Intel VLSI 432 32 bit computer,Â» J. Bayliss et al., IEEE J. Solid-State Circuits, vol. SC-16, . 522-530,  1981 .   43203   -   iAPX 432. Intel   iAPX 432  1975 ,   Â«Â»,     Intel  1980- .    iAPX 432  , Intel   8086    ,  1978 .  Intel 8086   ,        x86,  iAPX 432    1986 . </li><li>   ( Â«Multiple-Valued ROM Output CircuitsÂ»)       .            .      (T3, T4, T5)   . 4  5    ,      3,        (   ).       ( )  T6,     .             (). </li><li> -   SLC ( single level cell â€”    ), MLC (multi level cell â€”    ), TLC (triple level cell â€”    )  QLC (quad level cell â€”    ). , -       ,   ,     -   . </li><li>   Â«ElectronicsÂ»     Â«Four-State Cell Doubles ROM Bit CapacityÂ» (. 39, 9  1980 .),   Intel,        . Intel    Â«    Â»  COMPCON (. 209-212,  1981 .).           Intel  Â«Multiple-valued ROM output circuitsÂ» (Proc. 14th Int. Symp. Multivalue Logic, 1984).  ,      , â€” Â« <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">A Survey of Multivalued Memories</a> Â» (Â«IEEE Transactions on ComputersÂ»,  1986 ., . 99â€“106)  Â« <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">A review of multiple-valued memory technology</a> Â» (IEEE Symposium on Multivalued Logic, 1998). </li></ol><br> ,    .  Apakah Anda suka artikel kami?  Ingin melihat materi yang lebih menarik?  Dukung kami dengan melakukan pemesanan atau merekomendasikannya kepada teman-teman Anda, <b>diskon 30% untuk pengguna Habr pada analog unik dari server entry-level yang kami temukan untuk Anda:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Seluruh kebenaran tentang VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps dari $ 20 atau bagaimana membagi server?</a>  (pilihan tersedia dengan RAID1 dan RAID10, hingga 24 core dan hingga 40GB DDR4). <br><br> <b>VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps  1  </b>      ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . <br><br>  <b>Dell R730xd 2 kali lebih murah?</b>  Hanya kami yang memiliki <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2 x Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 TV dari $ 249</a> di Belanda dan Amerika Serikat!</b>  Baca tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara Membangun Infrastruktur</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kelas menggunakan server Dell R730xd E5-2650 v4 seharga 9.000 euro untuk satu sen?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id425117/">https://habr.com/ru/post/id425117/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id425107/index.html">Fintech digest: masalah biometrik pada ponsel, penyewaan ponsel Samsung, sekuritas pada blockchain</a></li>
<li><a href="../id425109/index.html">Buku â€œJava in the cloud. Spring Boot, Spring Cloud, Cloud Foundry Â»</a></li>
<li><a href="../id425111/index.html">Trik beriklan yang dapat membuat Anda kehilangan uang dan reputasi</a></li>
<li><a href="../id425113/index.html">"Digital tipografi" atau pengalaman saya dalam digitalisasi buku</a></li>
<li><a href="../id425115/index.html">Full-blown DevOps: Tragedi Yunani dalam tiga babak</a></li>
<li><a href="../id425123/index.html">Jantung misterius mesin drum Roland TR-808</a></li>
<li><a href="../id425125/index.html">@Pythonetc September 2018</a></li>
<li><a href="../id425129/index.html">Bagaimana cara mengotomatisasi pembuatan mesin virtual? Kami memberi tahu secara detail</a></li>
<li><a href="../id425131/index.html">Apa yang harus dibaca tentang teknologi blockchain: panduan, buku, dan artikel</a></li>
<li><a href="../id425133/index.html">Masalah pembayaran lintas batas - mengapa dan bagaimana blockchain digunakan di sini</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>