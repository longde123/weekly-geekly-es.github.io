<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëå üë®üèø‚Äçüîß üëÇüèº [√úbersetzung] Wann werden parallele Streams verwendet? ‚õµÔ∏è üë©üèø‚Äçüíº üëá</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quelle 
 Autoren: Doug Lea mit Brian Goetz, Paul Sandoz, Alexei Shipilev, Heinz Kabutz, Joe Bowbeer, ... 

 Das Framework java.util.streams enth√§lt da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>[√úbersetzung] Wann werden parallele Streams verwendet?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420805/"><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quelle</a> <br>  Autoren: Doug Lea mit Brian Goetz, Paul Sandoz, Alexei Shipilev, Heinz Kabutz, Joe Bowbeer, ... </blockquote><p> Das Framework <code>java.util.streams</code> enth√§lt datengesteuerte Operationen f√ºr Sammlungen und andere Datenquellen.  Die meisten Stream-Methoden f√ºhren f√ºr jedes Element dieselbe Operation aus.  Wenn Sie mit der Erfassungsmethode <code>parallelStream()</code> mehrere Kerne haben, k√∂nnen Sie <em>datengesteuert</em> in <em>datenparallel umwandeln</em> .  Aber wann lohnt es sich? </p><a name="habracut"></a><br><p>  <code>S.parallelStream().operation(F)</code> Sie die Verwendung von <code>S.parallelStream().operation(F)</code> anstelle von <code>S.stream().operation(F)</code> , vorausgesetzt, die Operationen sind unabh√§ngig voneinander und entweder rechenintensiv oder werden auf eine gro√üe Anzahl von Elementen angewendet, die effektiv aufgeteilt werden (teilbare) Datenstrukturen oder beides.  Genauer gesagt: </p><br><ul><li>  <code>F</code> : Eine Funktion zum Arbeiten mit einem einzelnen Element, normalerweise einem Lambda, ist unabh√§ngig, d.h.  Die Operation f√ºr eines der Elemente ist unabh√§ngig und wirkt sich nicht auf Operationen f√ºr andere Elemente aus (Empfehlungen zur Verwendung nicht st√∂render zustandsloser Funktionen finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation zum <em>Stream-</em> Paket</a> ). </li><li>  <code>S</code> : Die urspr√ºngliche Sammlung wird effektiv aufgeteilt.  Neben Sammlungen gibt es andere, die f√ºr die Parallelisierung geeignet sind und Datenquellen streamen, z. B. <code>java.util.SplittableRandom</code> (f√ºr deren Parallelisierung Sie die <code>stream.parallel()</code> -Methode verwenden k√∂nnen).  Die meisten Quellen mit E / A im Kern sind jedoch haupts√§chlich f√ºr den sequentiellen Betrieb ausgelegt. </li><li>  Die Gesamtlaufzeit im sequentiellen Modus √ºberschreitet die minimal zul√§ssige Grenze.  Heutzutage liegt das Limit f√ºr die meisten Plattformen ungef√§hr gleich (innerhalb von x10) bei 100 Mikrosekunden.  Genaue Messungen sind in diesem Fall nicht erforderlich.  F√ºr praktische Zwecke reicht es aus, <code>N</code> (die Anzahl der Elemente) einfach mit <code>Q</code> (der Betriebszeit eines <code>F</code> ) zu multiplizieren, und <code>Q</code> kann ungef√§hr durch die Anzahl der Operationen oder die Anzahl der Codezeilen gesch√§tzt werden.  Danach m√ºssen Sie √ºberpr√ºfen, ob <code>N * Q</code> mindestens <code>10000</code> betr√§gt (wenn Sie sch√ºchtern sind, f√ºgen Sie eine oder mehrere Nullen hinzu).  Wenn also <code>F</code> eine kleine Funktion wie <code>x -&gt; x + 1</code> , ist eine parallele Ausf√ºhrung sinnvoll, wenn <code>N &gt;= 10000</code> .  Wenn umgekehrt <code>F</code> eine gewichtige Berechnung ist, √§hnlich wie beim Finden des n√§chstbesten Zuges in einer Schachpartie, dann ist der Wert von <code>Q</code> so gro√ü, dass <code>N</code> vernachl√§ssigt werden kann, aber bis die Sammlung vollst√§ndig aufgeteilt ist. </li></ul><br><p>  Das Streaming-Verarbeitungs-Framework wird (und kann) auf keinem der oben genannten Punkte bestehen.  Wenn die Berechnungen voneinander abh√§ngig sind, ist ihre parallele Ausf√ºhrung nicht sinnvoll oder √ºberhaupt sch√§dlich und f√ºhrt zu Fehlern.  Weitere Kriterien, die sich aus den oben genannten technischen Problemen und Kompromissen ergeben, sind: </p><br><ul><li>  <em>Inbetriebnahme</em> <br>  Das Auftreten zus√§tzlicher Kerne in Prozessoren ging in den meisten F√§llen mit der Hinzuf√ºgung eines Energieverwaltungsmechanismus einher, der zu einer Verlangsamung des Kernelstarts f√ºhren kann, manchmal mit zus√§tzlichen √úberlagerungen von JVM, Betriebssystem und Hypervisor.  In diesem Fall entspricht die Grenze, bei der der Parallelmodus sinnvoll ist, in etwa der Zeit, die erforderlich ist, um die Verarbeitung der Unteraufgaben mit einer ausreichenden Anzahl von Kernen zu starten.  Danach kann paralleles Rechnen energieeffizienter als sequentielles sein (abh√§ngig von den Details der Prozessoren und Systeme. Ein Beispiel finden Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> ). </li><li>  <em>Detaillierung (Granularit√§t)</em> <br>  Es ist selten sinnvoll, kleine Berechnungen aufzuteilen.  Das Framework teilt die Aufgabe normalerweise so auf, dass die einzelnen Teile auf allen verf√ºgbaren Systemkernen arbeiten k√∂nnen.  Wenn nach dem Start praktisch keine Arbeit f√ºr jeden Kern vorhanden ist, werden (normalerweise sequentielle) Anstrengungen zur Organisation des parallelen Rechnens verschwendet.  Da in der Praxis die Anzahl der Kerne zwischen 2 und 256 Schwellenwerten liegt, wird auch der unerw√ºnschte Effekt einer √ºberm√§√üigen Aufteilung der Aufgabe verhindert. </li><li>  <em>Teilbarkeit</em> <br>  Zu den am effizientesten aufgeteilten Sammlungen geh√∂ren <code>ArrayList</code> und <code>{Concurrent}HashMap</code> sowie regul√§re Arrays ( <code>T[]</code> , die mithilfe statischer <code>java.util.Arrays</code> Methoden in Teile aufgeteilt werden).  Die am wenigsten effizienten Splitter sind <code>LinkedList</code> , <code>BlockingQueue</code> und die meisten Quellen mit E / A-Basis.  Der Rest befindet sich irgendwo in der Mitte (Datenstrukturen, die Direktzugriff und / oder effiziente Suche unterst√ºtzen, werden normalerweise effizient aufgeteilt).  Wenn das Aufteilen von Daten l√§nger dauert als die Verarbeitung, ist der Aufwand vergeblich.  Wenn <code>Q</code> gro√ü genug ist, k√∂nnen Sie aufgrund der Parallelisierung auch f√ºr <code>LinkedList</code> einen Anstieg <code>LinkedList</code> . Dies ist jedoch ein eher seltener Fall.  Dar√ºber hinaus k√∂nnen einige Quellen nicht in ein einzelnes Element aufgeteilt werden, und daher kann der Zersetzungsgrad des Problems eingeschr√§nkt sein. </li></ul><br><p>  Es kann schwierig sein, die genauen Eigenschaften dieser Effekte zu ermitteln (wenn Sie dies jedoch versuchen, k√∂nnen Sie Tools wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JMH verwenden</a> ).  Der kumulative Effekt ist jedoch leicht zu bemerken.  Um es selbst zu f√ºhlen - machen Sie ein Experiment.  Wenn Sie beispielsweise auf einem 32-Core-Testcomputer kleine Funktionen wie <code>max()</code> oder <code>sum()</code> √ºber der <code>ArrayList</code> betr√§gt <code>ArrayList</code> Break-Even-Punkt ungef√§hr 10.000.  F√ºr mehr Elemente wird eine bis zu 20-fache Beschleunigung angegeben.  Die √ñffnungszeiten f√ºr Sammlungen mit weniger als 10.000 Artikeln sind nicht viel geringer als f√ºr 10.000 und daher langsamer als die sequentielle Verarbeitung.  Das schlechteste Ergebnis tritt bei weniger als 100 Elementen auf - in diesem Fall werden die beteiligten Threads gestoppt, ohne etwas N√ºtzliches zu tun, weil  Berechnungen werden abgeschlossen, bevor sie beginnen.  Wenn Operationen an Elementen zeitaufw√§ndig sind und effizient und vollst√§ndig aufteilbare Sammlungen wie <code>ArrayList</code> , sind die Vorteile sofort sichtbar. </p><br><p>  Um all das zu paraphrasieren: Die Verwendung von <code>parallel()</code> im Fall einer unangemessen kleinen Rechenmenge kann etwa <code>100</code> Mikrosekunden kosten. Andernfalls sollte die Verwendung mindestens diese Zeit selbst (oder m√∂glicherweise Stunden f√ºr sehr gro√üe Aufgaben) sparen.  Die spezifischen Kosten und Nutzen variieren im Laufe der Zeit f√ºr verschiedene Plattformen und auch je nach Kontext.  Wenn Sie beispielsweise kleine Berechnungen innerhalb eines sequentiellen Zyklus parallel ausf√ºhren, wird der Effekt von H√∂hen und Tiefen verst√§rkt (Leistungsmikrotests, bei denen dies auftritt, spiegeln m√∂glicherweise nicht die tats√§chliche Situation wider). </p><br><h2 id="voprosy-i-otvety">  Fragen und Antworten </h2><br><ul><li>  Warum kann die JVM nicht verstehen, wann Operationen parallel ausgef√ºhrt werden m√ºssen? </li></ul><br><p>  Sie k√∂nnte es versuchen, aber zu oft war die Entscheidung falsch.  Die Suche nach vollautomatischer Multi-Core-Parallelit√§t hat in den letzten drei√üig Jahren nicht zu einer universellen L√∂sung gef√ºhrt. Daher verwendet das Framework einen zuverl√§ssigeren Ansatz, bei dem der Benutzer nur zwischen <em>Ja und Nein</em> w√§hlen muss.  Diese Wahl basiert auf technischen Problemen, die bei der sequentiellen Programmierung st√§ndig auftreten und die wahrscheinlich nie vollst√§ndig verschwinden werden.  Beispielsweise kann es zu einer hundertfachen Verlangsamung kommen, wenn Sie nach dem Maximalwert in einer Sammlung suchen, die ein einzelnes Element enth√§lt, und diesen Wert direkt (ohne Sammlung) verwenden.  Manchmal kann die JVM solche F√§lle f√ºr Sie optimieren.  Dies geschieht jedoch selten in aufeinanderfolgenden F√§llen und niemals im Parallelmodus.  Auf der anderen Seite k√∂nnen wir erwarten, dass die Tools den Benutzern bei ihrer Entwicklung helfen, bessere Entscheidungen zu treffen. </p><br><ul><li>  Was ist, wenn ich f√ºr eine gute Entscheidung nicht gen√ºgend Kenntnisse √ºber die Parameter ( <code>F</code> , <code>N</code> , <code>Q</code> , <code>S</code> ) habe? </li></ul><br><p>  Auch dies √§hnelt Problemen, die bei der sequentiellen Programmierung auftreten.  Beispielsweise wird die <code>S.contains(x)</code> -Methode der <code>Collection</code> Klasse normalerweise schnell ausgef√ºhrt, wenn <code>S</code> ein <code>HashSet</code> , langsam, wenn <code>LinkedList</code> , und in anderen F√§llen durchschnittlich.  F√ºr den Autor einer Komponente, die die Sammlung verwendet, besteht der beste Ausweg aus dieser Situation normalerweise darin, sie zu kapseln und nur einen bestimmten Vorgang darauf zu ver√∂ffentlichen.  Dann werden Benutzer von der Notwendigkeit der Auswahl isoliert.  Gleiches gilt f√ºr Paralleloperationen.  Beispielsweise kann eine Komponente mit einer internen <em>Preiserfassung</em> eine Methode bestimmen, die ihre Gr√∂√üe bis zum Limit √ºberpr√ºft. Dies ist sinnvoll, bis die bitweise Berechnung zu teuer ist.  Ein Beispiel: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMaxPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> priceStream().max(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Stream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">priceStream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (prices.size() &lt; MIN_PAR) ? prices.stream() : prices.parallelStream(); }</code> </pre> <br><p>  Diese Idee kann auf andere √úberlegungen zum Zeitpunkt und zur Verwendung der Parallelit√§t erweitert werden. </p><br><ul><li>  Was ist, wenn meine Funktion wahrscheinlich E / A- oder synchronisierte Vorg√§nge ausf√ºhrt? </li></ul><br><p>  Ein Extrem sind Funktionen, die die Unabh√§ngigkeitskriterien nicht erf√ºllen, einschlie√ülich sequentieller E / A-Operationen, Zugriff auf das Blockieren synchronisierter Ressourcen und F√§lle, in denen ein Fehler in einer parallelen Unteraufgabe, die E / A ausf√ºhrt, andere betrifft.  Ihre Parallelisierung macht wenig Sinn.  Andererseits gibt es Berechnungen, die gelegentlich E / A durchf√ºhren oder die Synchronisation selten blockieren (z. B. die meisten F√§lle der Protokollierung und die Verwendung wettbewerbsf√§higer Sammlungen wie <code>ConcurrentHashMap</code> ).  Sie sind harmlos.  Was zwischen ihnen ist, erfordert mehr Forschung.  Wenn jede Unteraufgabe f√ºr eine betr√§chtliche Zeit blockiert werden kann und auf E / A oder Zugriff wartet, sind die CPU-Ressourcen ohne die M√∂glichkeit ihrer Verwendung durch das Programm oder die JVM inaktiv.  Davon ist schlecht f√ºr alle.  In diesen F√§llen ist die parallele Streaming-Verarbeitung nicht immer die richtige Wahl.  Es gibt jedoch gute Alternativen - zum Beispiel asynchrone E / A und den <code>CompletableFuture</code> Ansatz. </p><br><ul><li>  Was ist, wenn meine Quelle auf E / A basiert? </li></ul><br><p>  Derzeit werden sie mithilfe der JDK- <code>Stream</code> / I / O-Generatoren (z. B. <code>BufferedReader.lines()</code> ) haupts√§chlich f√ºr die Verwendung im sequentiellen Modus angepasst und verarbeiten Elemente nacheinander, <code>BufferedReader.lines()</code> sie verf√ºgbar sind.  Die Unterst√ºtzung der Hochleistungs-Massenverarbeitung von gepufferten E / A ist m√∂glich, erfordert jedoch derzeit die Entwicklung spezieller Generatoren <code>Stream</code> , <code>Spliterator</code> und <code>Collector</code> .  Unterst√ºtzung f√ºr einige h√§ufige F√§lle wird m√∂glicherweise in zuk√ºnftigen Versionen des JDK hinzugef√ºgt. </p><br><ul><li>  Was ist, wenn mein Programm auf einem ausgelasteten Computer ausgef√ºhrt wird und alle Kernel ausgelastet sind? </li></ul><br><p>  Maschinen haben normalerweise eine feste Anzahl von Kernen und k√∂nnen bei parallelen Operationen keine magischen neuen erstellen.  Solange jedoch die Kriterien f√ºr die Wahl eines Parallelmodus eindeutig sprechen, besteht kein Zweifel.  Ihre parallelen Aufgaben konkurrieren mit anderen um die CPU und Sie werden weniger Beschleunigung bemerken.  In den meisten F√§llen ist dies immer noch effektiver als andere Alternativen.  Der zugrunde liegende Mechanismus ist so konzipiert, dass Sie, wenn keine Kerne verf√ºgbar sind, im Vergleich zur sequentiellen Version nur eine geringf√ºgige Verlangsamung bemerken, es sei denn, das System ist so √ºberlastet, dass es seine gesamte Zeit damit verbringt, Kontexte zu wechseln, anstatt echte Arbeit zu leisten, oder konfiguriert in der Erwartung, dass die gesamte Verarbeitung nacheinander ausgef√ºhrt wird.  Wenn Sie √ºber ein solches System verf√ºgen, hat der Administrator m√∂glicherweise die Verwendung von Multithreading / Nuklearit√§t in den JVM-Einstellungen bereits deaktiviert.  Und wenn Sie der Systemadministrator sind, ist es sinnvoll, dies zu tun. </p><br><ul><li>  Sind alle Operationen im Parallelmodus parallelisiert? </li></ul><br><p>  Ja  Zumindest bis zu einem gewissen Grad.  Es ist jedoch zu ber√ºcksichtigen, dass das Stream-Framework die Einschr√§nkungen von Quellen und Methoden bei der Auswahl ber√ºcksichtigt.  Im Allgemeinen ist das Potenzial f√ºr Parallelit√§t umso gr√∂√üer, je weniger Einschr√§nkungen bestehen.  Andererseits gibt es keine Garantie daf√ºr, dass das Framework alle verf√ºgbaren M√∂glichkeiten f√ºr Parallelit√§t identifiziert und anwendet.  In einigen F√§llen kann Ihre eigene L√∂sung, wenn Sie Zeit und Kompetenz haben, die M√∂glichkeiten der Parallelit√§t viel besser nutzen. </p><br><ul><li>  Welche Beschleunigung bekomme ich durch Parallelit√§t? </li></ul><br><p>  Wenn Sie sich an diese Tipps halten, reicht dies normalerweise aus, um einen Sinn zu ergeben.  Vorhersagbarkeit ist keine St√§rke moderner Hardware und Systeme, und daher gibt es keine universelle Antwort.  Die Cache-Lokalit√§t, GC-Eigenschaften, JIT-Kompilierung, Speicherzugriffskonflikte, Datenspeicherort, Planungsrichtlinien f√ºr das Betriebssystem und das Vorhandensein eines Hypervisors sind einige der Faktoren, die einen erheblichen Einfluss haben.  Die Leistung des sequentiellen Modus unterliegt auch ihrem Einfluss, der bei Verwendung der Parallelit√§t h√§ufig verst√§rkt wird: Das Problem, das bei der sequentiellen Ausf√ºhrung einen Unterschied von 10 Prozent verursacht, kann zu einem 10-fachen Unterschied bei der parallelen Verarbeitung f√ºhren. </p><br><p>  Das Stream-Framework enth√§lt einige Funktionen, mit denen sich die Beschleunigungschancen erh√∂hen lassen.  Beispielsweise hat die Verwendung der Spezialisierung f√ºr <code>IntStream</code> wie <code>IntStream</code> im <code>IntStream</code> normalerweise einen gr√∂√üeren Effekt als im sequentiellen Modus.  Der Grund daf√ºr ist, dass in diesem Fall nicht nur der Ressourcen- (und Speicher-) Verbrauch abnimmt, sondern auch die Cache-Lokalit√§t verbessert wird.  Die Verwendung von <code>ConcurrentHashMap</code> anstelle von <code>HashMap</code> reduziert im Fall des Parallelbetriebs des <code>collect</code> die internen Kosten.  Neue Tipps und Tricks werden als Erfahrungen mit dem Framework angezeigt. </p><br><ul><li>  Das alles ist zu be√§ngstigend!  K√∂nnen wir nicht einfach Regeln f√ºr die Verwendung von JVM-Eigenschaften zum Deaktivieren der Parallelit√§t entwickeln? </li></ul><br><p>  Wir m√∂chten Ihnen nicht sagen, was Sie tun sollen.  Die Entstehung neuer M√∂glichkeiten f√ºr Programmierer, etwas falsch zu machen, kann be√§ngstigend sein.  Fehler in Code, Architektur und Auswertungen werden sicherlich auftreten.  Vor Jahrzehnten sagten einige Leute voraus, dass Parallelit√§t auf Anwendungsebene zu gro√üen Katastrophen f√ºhren w√ºrde.  Aber es wurde nie wahr. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420805/">https://habr.com/ru/post/de420805/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420793/index.html">Debuggen als Prozess</a></li>
<li><a href="../de420795/index.html">Missverst√§ndnisse des Analytikers</a></li>
<li><a href="../de420797/index.html">Lernen kann nicht verschoben werden</a></li>
<li><a href="../de420799/index.html">MPS 2018.2: Generatortests, GitHub-Plugin, VCS-Aspekt, Migrationsbenachrichtigungen und mehr</a></li>
<li><a href="../de420803/index.html">3D-Druckunterricht. Speichern von Kunststoff beim Drucken nicht funktionsf√§higer Modelle aus 3Dtool</a></li>
<li><a href="../de420809/index.html">Sicherheitswoche 31: F√ºnfzig Schattierungen von Unsicherheit unter Android</a></li>
<li><a href="../de420811/index.html">Dezentrales Messenger- und Telefonnetz der neuen Generation</a></li>
<li><a href="../de420813/index.html">Backstage-Netzwerke bei Kubernetes</a></li>
<li><a href="../de420815/index.html">Wie "die digitale Welt entschl√ºsseln" die Halle in die Luft jagte: Top 10 Berichte von DotNext 2018 Piter</a></li>
<li><a href="../de420819/index.html">Top 10 Python-Tools f√ºr maschinelles Lernen und Datenwissenschaft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>