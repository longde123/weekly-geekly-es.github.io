<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👌 👨🏿‍🔧 👂🏼 [Übersetzung] Wann werden parallele Streams verwendet? ⛵️ 👩🏿‍💼 👇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quelle 
 Autoren: Doug Lea mit Brian Goetz, Paul Sandoz, Alexei Shipilev, Heinz Kabutz, Joe Bowbeer, ... 

 Das Framework java.util.streams enthält da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>[Übersetzung] Wann werden parallele Streams verwendet?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420805/"><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quelle</a> <br>  Autoren: Doug Lea mit Brian Goetz, Paul Sandoz, Alexei Shipilev, Heinz Kabutz, Joe Bowbeer, ... </blockquote><p> Das Framework <code>java.util.streams</code> enthält datengesteuerte Operationen für Sammlungen und andere Datenquellen.  Die meisten Stream-Methoden führen für jedes Element dieselbe Operation aus.  Wenn Sie mit der Erfassungsmethode <code>parallelStream()</code> mehrere Kerne haben, können Sie <em>datengesteuert</em> in <em>datenparallel umwandeln</em> .  Aber wann lohnt es sich? </p><a name="habracut"></a><br><p>  <code>S.parallelStream().operation(F)</code> Sie die Verwendung von <code>S.parallelStream().operation(F)</code> anstelle von <code>S.stream().operation(F)</code> , vorausgesetzt, die Operationen sind unabhängig voneinander und entweder rechenintensiv oder werden auf eine große Anzahl von Elementen angewendet, die effektiv aufgeteilt werden (teilbare) Datenstrukturen oder beides.  Genauer gesagt: </p><br><ul><li>  <code>F</code> : Eine Funktion zum Arbeiten mit einem einzelnen Element, normalerweise einem Lambda, ist unabhängig, d.h.  Die Operation für eines der Elemente ist unabhängig und wirkt sich nicht auf Operationen für andere Elemente aus (Empfehlungen zur Verwendung nicht störender zustandsloser Funktionen finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation zum <em>Stream-</em> Paket</a> ). </li><li>  <code>S</code> : Die ursprüngliche Sammlung wird effektiv aufgeteilt.  Neben Sammlungen gibt es andere, die für die Parallelisierung geeignet sind und Datenquellen streamen, z. B. <code>java.util.SplittableRandom</code> (für deren Parallelisierung Sie die <code>stream.parallel()</code> -Methode verwenden können).  Die meisten Quellen mit E / A im Kern sind jedoch hauptsächlich für den sequentiellen Betrieb ausgelegt. </li><li>  Die Gesamtlaufzeit im sequentiellen Modus überschreitet die minimal zulässige Grenze.  Heutzutage liegt das Limit für die meisten Plattformen ungefähr gleich (innerhalb von x10) bei 100 Mikrosekunden.  Genaue Messungen sind in diesem Fall nicht erforderlich.  Für praktische Zwecke reicht es aus, <code>N</code> (die Anzahl der Elemente) einfach mit <code>Q</code> (der Betriebszeit eines <code>F</code> ) zu multiplizieren, und <code>Q</code> kann ungefähr durch die Anzahl der Operationen oder die Anzahl der Codezeilen geschätzt werden.  Danach müssen Sie überprüfen, ob <code>N * Q</code> mindestens <code>10000</code> beträgt (wenn Sie schüchtern sind, fügen Sie eine oder mehrere Nullen hinzu).  Wenn also <code>F</code> eine kleine Funktion wie <code>x -&gt; x + 1</code> , ist eine parallele Ausführung sinnvoll, wenn <code>N &gt;= 10000</code> .  Wenn umgekehrt <code>F</code> eine gewichtige Berechnung ist, ähnlich wie beim Finden des nächstbesten Zuges in einer Schachpartie, dann ist der Wert von <code>Q</code> so groß, dass <code>N</code> vernachlässigt werden kann, aber bis die Sammlung vollständig aufgeteilt ist. </li></ul><br><p>  Das Streaming-Verarbeitungs-Framework wird (und kann) auf keinem der oben genannten Punkte bestehen.  Wenn die Berechnungen voneinander abhängig sind, ist ihre parallele Ausführung nicht sinnvoll oder überhaupt schädlich und führt zu Fehlern.  Weitere Kriterien, die sich aus den oben genannten technischen Problemen und Kompromissen ergeben, sind: </p><br><ul><li>  <em>Inbetriebnahme</em> <br>  Das Auftreten zusätzlicher Kerne in Prozessoren ging in den meisten Fällen mit der Hinzufügung eines Energieverwaltungsmechanismus einher, der zu einer Verlangsamung des Kernelstarts führen kann, manchmal mit zusätzlichen Überlagerungen von JVM, Betriebssystem und Hypervisor.  In diesem Fall entspricht die Grenze, bei der der Parallelmodus sinnvoll ist, in etwa der Zeit, die erforderlich ist, um die Verarbeitung der Unteraufgaben mit einer ausreichenden Anzahl von Kernen zu starten.  Danach kann paralleles Rechnen energieeffizienter als sequentielles sein (abhängig von den Details der Prozessoren und Systeme. Ein Beispiel finden Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> ). </li><li>  <em>Detaillierung (Granularität)</em> <br>  Es ist selten sinnvoll, kleine Berechnungen aufzuteilen.  Das Framework teilt die Aufgabe normalerweise so auf, dass die einzelnen Teile auf allen verfügbaren Systemkernen arbeiten können.  Wenn nach dem Start praktisch keine Arbeit für jeden Kern vorhanden ist, werden (normalerweise sequentielle) Anstrengungen zur Organisation des parallelen Rechnens verschwendet.  Da in der Praxis die Anzahl der Kerne zwischen 2 und 256 Schwellenwerten liegt, wird auch der unerwünschte Effekt einer übermäßigen Aufteilung der Aufgabe verhindert. </li><li>  <em>Teilbarkeit</em> <br>  Zu den am effizientesten aufgeteilten Sammlungen gehören <code>ArrayList</code> und <code>{Concurrent}HashMap</code> sowie reguläre Arrays ( <code>T[]</code> , die mithilfe statischer <code>java.util.Arrays</code> Methoden in Teile aufgeteilt werden).  Die am wenigsten effizienten Splitter sind <code>LinkedList</code> , <code>BlockingQueue</code> und die meisten Quellen mit E / A-Basis.  Der Rest befindet sich irgendwo in der Mitte (Datenstrukturen, die Direktzugriff und / oder effiziente Suche unterstützen, werden normalerweise effizient aufgeteilt).  Wenn das Aufteilen von Daten länger dauert als die Verarbeitung, ist der Aufwand vergeblich.  Wenn <code>Q</code> groß genug ist, können Sie aufgrund der Parallelisierung auch für <code>LinkedList</code> einen Anstieg <code>LinkedList</code> . Dies ist jedoch ein eher seltener Fall.  Darüber hinaus können einige Quellen nicht in ein einzelnes Element aufgeteilt werden, und daher kann der Zersetzungsgrad des Problems eingeschränkt sein. </li></ul><br><p>  Es kann schwierig sein, die genauen Eigenschaften dieser Effekte zu ermitteln (wenn Sie dies jedoch versuchen, können Sie Tools wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JMH verwenden</a> ).  Der kumulative Effekt ist jedoch leicht zu bemerken.  Um es selbst zu fühlen - machen Sie ein Experiment.  Wenn Sie beispielsweise auf einem 32-Core-Testcomputer kleine Funktionen wie <code>max()</code> oder <code>sum()</code> über der <code>ArrayList</code> beträgt <code>ArrayList</code> Break-Even-Punkt ungefähr 10.000.  Für mehr Elemente wird eine bis zu 20-fache Beschleunigung angegeben.  Die Öffnungszeiten für Sammlungen mit weniger als 10.000 Artikeln sind nicht viel geringer als für 10.000 und daher langsamer als die sequentielle Verarbeitung.  Das schlechteste Ergebnis tritt bei weniger als 100 Elementen auf - in diesem Fall werden die beteiligten Threads gestoppt, ohne etwas Nützliches zu tun, weil  Berechnungen werden abgeschlossen, bevor sie beginnen.  Wenn Operationen an Elementen zeitaufwändig sind und effizient und vollständig aufteilbare Sammlungen wie <code>ArrayList</code> , sind die Vorteile sofort sichtbar. </p><br><p>  Um all das zu paraphrasieren: Die Verwendung von <code>parallel()</code> im Fall einer unangemessen kleinen Rechenmenge kann etwa <code>100</code> Mikrosekunden kosten. Andernfalls sollte die Verwendung mindestens diese Zeit selbst (oder möglicherweise Stunden für sehr große Aufgaben) sparen.  Die spezifischen Kosten und Nutzen variieren im Laufe der Zeit für verschiedene Plattformen und auch je nach Kontext.  Wenn Sie beispielsweise kleine Berechnungen innerhalb eines sequentiellen Zyklus parallel ausführen, wird der Effekt von Höhen und Tiefen verstärkt (Leistungsmikrotests, bei denen dies auftritt, spiegeln möglicherweise nicht die tatsächliche Situation wider). </p><br><h2 id="voprosy-i-otvety">  Fragen und Antworten </h2><br><ul><li>  Warum kann die JVM nicht verstehen, wann Operationen parallel ausgeführt werden müssen? </li></ul><br><p>  Sie könnte es versuchen, aber zu oft war die Entscheidung falsch.  Die Suche nach vollautomatischer Multi-Core-Parallelität hat in den letzten dreißig Jahren nicht zu einer universellen Lösung geführt. Daher verwendet das Framework einen zuverlässigeren Ansatz, bei dem der Benutzer nur zwischen <em>Ja und Nein</em> wählen muss.  Diese Wahl basiert auf technischen Problemen, die bei der sequentiellen Programmierung ständig auftreten und die wahrscheinlich nie vollständig verschwinden werden.  Beispielsweise kann es zu einer hundertfachen Verlangsamung kommen, wenn Sie nach dem Maximalwert in einer Sammlung suchen, die ein einzelnes Element enthält, und diesen Wert direkt (ohne Sammlung) verwenden.  Manchmal kann die JVM solche Fälle für Sie optimieren.  Dies geschieht jedoch selten in aufeinanderfolgenden Fällen und niemals im Parallelmodus.  Auf der anderen Seite können wir erwarten, dass die Tools den Benutzern bei ihrer Entwicklung helfen, bessere Entscheidungen zu treffen. </p><br><ul><li>  Was ist, wenn ich für eine gute Entscheidung nicht genügend Kenntnisse über die Parameter ( <code>F</code> , <code>N</code> , <code>Q</code> , <code>S</code> ) habe? </li></ul><br><p>  Auch dies ähnelt Problemen, die bei der sequentiellen Programmierung auftreten.  Beispielsweise wird die <code>S.contains(x)</code> -Methode der <code>Collection</code> Klasse normalerweise schnell ausgeführt, wenn <code>S</code> ein <code>HashSet</code> , langsam, wenn <code>LinkedList</code> , und in anderen Fällen durchschnittlich.  Für den Autor einer Komponente, die die Sammlung verwendet, besteht der beste Ausweg aus dieser Situation normalerweise darin, sie zu kapseln und nur einen bestimmten Vorgang darauf zu veröffentlichen.  Dann werden Benutzer von der Notwendigkeit der Auswahl isoliert.  Gleiches gilt für Paralleloperationen.  Beispielsweise kann eine Komponente mit einer internen <em>Preiserfassung</em> eine Methode bestimmen, die ihre Größe bis zum Limit überprüft. Dies ist sinnvoll, bis die bitweise Berechnung zu teuer ist.  Ein Beispiel: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMaxPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> priceStream().max(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Stream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">priceStream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (prices.size() &lt; MIN_PAR) ? prices.stream() : prices.parallelStream(); }</code> </pre> <br><p>  Diese Idee kann auf andere Überlegungen zum Zeitpunkt und zur Verwendung der Parallelität erweitert werden. </p><br><ul><li>  Was ist, wenn meine Funktion wahrscheinlich E / A- oder synchronisierte Vorgänge ausführt? </li></ul><br><p>  Ein Extrem sind Funktionen, die die Unabhängigkeitskriterien nicht erfüllen, einschließlich sequentieller E / A-Operationen, Zugriff auf das Blockieren synchronisierter Ressourcen und Fälle, in denen ein Fehler in einer parallelen Unteraufgabe, die E / A ausführt, andere betrifft.  Ihre Parallelisierung macht wenig Sinn.  Andererseits gibt es Berechnungen, die gelegentlich E / A durchführen oder die Synchronisation selten blockieren (z. B. die meisten Fälle der Protokollierung und die Verwendung wettbewerbsfähiger Sammlungen wie <code>ConcurrentHashMap</code> ).  Sie sind harmlos.  Was zwischen ihnen ist, erfordert mehr Forschung.  Wenn jede Unteraufgabe für eine beträchtliche Zeit blockiert werden kann und auf E / A oder Zugriff wartet, sind die CPU-Ressourcen ohne die Möglichkeit ihrer Verwendung durch das Programm oder die JVM inaktiv.  Davon ist schlecht für alle.  In diesen Fällen ist die parallele Streaming-Verarbeitung nicht immer die richtige Wahl.  Es gibt jedoch gute Alternativen - zum Beispiel asynchrone E / A und den <code>CompletableFuture</code> Ansatz. </p><br><ul><li>  Was ist, wenn meine Quelle auf E / A basiert? </li></ul><br><p>  Derzeit werden sie mithilfe der JDK- <code>Stream</code> / I / O-Generatoren (z. B. <code>BufferedReader.lines()</code> ) hauptsächlich für die Verwendung im sequentiellen Modus angepasst und verarbeiten Elemente nacheinander, <code>BufferedReader.lines()</code> sie verfügbar sind.  Die Unterstützung der Hochleistungs-Massenverarbeitung von gepufferten E / A ist möglich, erfordert jedoch derzeit die Entwicklung spezieller Generatoren <code>Stream</code> , <code>Spliterator</code> und <code>Collector</code> .  Unterstützung für einige häufige Fälle wird möglicherweise in zukünftigen Versionen des JDK hinzugefügt. </p><br><ul><li>  Was ist, wenn mein Programm auf einem ausgelasteten Computer ausgeführt wird und alle Kernel ausgelastet sind? </li></ul><br><p>  Maschinen haben normalerweise eine feste Anzahl von Kernen und können bei parallelen Operationen keine magischen neuen erstellen.  Solange jedoch die Kriterien für die Wahl eines Parallelmodus eindeutig sprechen, besteht kein Zweifel.  Ihre parallelen Aufgaben konkurrieren mit anderen um die CPU und Sie werden weniger Beschleunigung bemerken.  In den meisten Fällen ist dies immer noch effektiver als andere Alternativen.  Der zugrunde liegende Mechanismus ist so konzipiert, dass Sie, wenn keine Kerne verfügbar sind, im Vergleich zur sequentiellen Version nur eine geringfügige Verlangsamung bemerken, es sei denn, das System ist so überlastet, dass es seine gesamte Zeit damit verbringt, Kontexte zu wechseln, anstatt echte Arbeit zu leisten, oder konfiguriert in der Erwartung, dass die gesamte Verarbeitung nacheinander ausgeführt wird.  Wenn Sie über ein solches System verfügen, hat der Administrator möglicherweise die Verwendung von Multithreading / Nuklearität in den JVM-Einstellungen bereits deaktiviert.  Und wenn Sie der Systemadministrator sind, ist es sinnvoll, dies zu tun. </p><br><ul><li>  Sind alle Operationen im Parallelmodus parallelisiert? </li></ul><br><p>  Ja  Zumindest bis zu einem gewissen Grad.  Es ist jedoch zu berücksichtigen, dass das Stream-Framework die Einschränkungen von Quellen und Methoden bei der Auswahl berücksichtigt.  Im Allgemeinen ist das Potenzial für Parallelität umso größer, je weniger Einschränkungen bestehen.  Andererseits gibt es keine Garantie dafür, dass das Framework alle verfügbaren Möglichkeiten für Parallelität identifiziert und anwendet.  In einigen Fällen kann Ihre eigene Lösung, wenn Sie Zeit und Kompetenz haben, die Möglichkeiten der Parallelität viel besser nutzen. </p><br><ul><li>  Welche Beschleunigung bekomme ich durch Parallelität? </li></ul><br><p>  Wenn Sie sich an diese Tipps halten, reicht dies normalerweise aus, um einen Sinn zu ergeben.  Vorhersagbarkeit ist keine Stärke moderner Hardware und Systeme, und daher gibt es keine universelle Antwort.  Die Cache-Lokalität, GC-Eigenschaften, JIT-Kompilierung, Speicherzugriffskonflikte, Datenspeicherort, Planungsrichtlinien für das Betriebssystem und das Vorhandensein eines Hypervisors sind einige der Faktoren, die einen erheblichen Einfluss haben.  Die Leistung des sequentiellen Modus unterliegt auch ihrem Einfluss, der bei Verwendung der Parallelität häufig verstärkt wird: Das Problem, das bei der sequentiellen Ausführung einen Unterschied von 10 Prozent verursacht, kann zu einem 10-fachen Unterschied bei der parallelen Verarbeitung führen. </p><br><p>  Das Stream-Framework enthält einige Funktionen, mit denen sich die Beschleunigungschancen erhöhen lassen.  Beispielsweise hat die Verwendung der Spezialisierung für <code>IntStream</code> wie <code>IntStream</code> im <code>IntStream</code> normalerweise einen größeren Effekt als im sequentiellen Modus.  Der Grund dafür ist, dass in diesem Fall nicht nur der Ressourcen- (und Speicher-) Verbrauch abnimmt, sondern auch die Cache-Lokalität verbessert wird.  Die Verwendung von <code>ConcurrentHashMap</code> anstelle von <code>HashMap</code> reduziert im Fall des Parallelbetriebs des <code>collect</code> die internen Kosten.  Neue Tipps und Tricks werden als Erfahrungen mit dem Framework angezeigt. </p><br><ul><li>  Das alles ist zu beängstigend!  Können wir nicht einfach Regeln für die Verwendung von JVM-Eigenschaften zum Deaktivieren der Parallelität entwickeln? </li></ul><br><p>  Wir möchten Ihnen nicht sagen, was Sie tun sollen.  Die Entstehung neuer Möglichkeiten für Programmierer, etwas falsch zu machen, kann beängstigend sein.  Fehler in Code, Architektur und Auswertungen werden sicherlich auftreten.  Vor Jahrzehnten sagten einige Leute voraus, dass Parallelität auf Anwendungsebene zu großen Katastrophen führen würde.  Aber es wurde nie wahr. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420805/">https://habr.com/ru/post/de420805/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420793/index.html">Debuggen als Prozess</a></li>
<li><a href="../de420795/index.html">Missverständnisse des Analytikers</a></li>
<li><a href="../de420797/index.html">Lernen kann nicht verschoben werden</a></li>
<li><a href="../de420799/index.html">MPS 2018.2: Generatortests, GitHub-Plugin, VCS-Aspekt, Migrationsbenachrichtigungen und mehr</a></li>
<li><a href="../de420803/index.html">3D-Druckunterricht. Speichern von Kunststoff beim Drucken nicht funktionsfähiger Modelle aus 3Dtool</a></li>
<li><a href="../de420809/index.html">Sicherheitswoche 31: Fünfzig Schattierungen von Unsicherheit unter Android</a></li>
<li><a href="../de420811/index.html">Dezentrales Messenger- und Telefonnetz der neuen Generation</a></li>
<li><a href="../de420813/index.html">Backstage-Netzwerke bei Kubernetes</a></li>
<li><a href="../de420815/index.html">Wie "die digitale Welt entschlüsseln" die Halle in die Luft jagte: Top 10 Berichte von DotNext 2018 Piter</a></li>
<li><a href="../de420819/index.html">Top 10 Python-Tools für maschinelles Lernen und Datenwissenschaft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>