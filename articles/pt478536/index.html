<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🤝‍👨🏼 🏇🏿 👊🏾 WebRTC através do Kurento: Experiência de Teste e Implementação 🗣️ 👨🏼‍🎨 🤸🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Neste artigo, compartilharei minha experiência com a tecnologia WebRTC e o servidor de mídia Kurento durante a fase de teste e implementação. Vou lhe ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WebRTC através do Kurento: Experiência de Teste e Implementação</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/inobitec/blog/478536/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/gp/n6/4m/gpn64m3nht-yuv6pzbeye6d8zv0.png"></div><br>  Neste artigo, compartilharei minha experiência com a tecnologia WebRTC e o servidor de mídia Kurento durante a fase de teste e implementação.  Vou lhe contar quais os problemas que encontrei e como os resolvi.  Não falarei sobre como desenvolver um aplicativo do zero, mas darei muitos links úteis.  Estou certo de que minha história será útil para quem vai trabalhar com o WebRTC. <br><a name="habracut"></a><br><h3>  1. Introdução </h3><br>  O Sistema de Informações Médicas (MIS), que está sendo desenvolvido por nossa empresa, já se tornou um grande projeto corporativo com muitos microsserviços, barramentos de mensagens, clientes móveis e assim por diante.  Algumas partes do sistema devem ser concedidas para desenvolvimento e suporte a organizações de terceiros, uma vez que não são o nosso perfil. <br><br>  O serviço de telemedicina é um desses módulos MIS.  Não havia experiência no desenvolvimento de videoconferência e no uso do WebRTC, e o pedido foi delegado.  Mas, após algum tempo, devido a várias circunstâncias, essa empresa parou de oferecer suporte à videoconferência.  Sem suporte, este serviço foi desativado e "acumulando poeira" no repositório. <br><br>  E agora é hora de reviver esse micro serviço.  Foi decidido tentar reiniciar a telemedicina por conta própria.  Nossa empresa cresceu, surgiram mais especialistas - é possível e necessário dominar novos tópicos para o desenvolvimento.  Eu não havia participado da transmissão de vídeo antes, mas era muito interessante entender e estudar uma tecnologia tão promissora como o WebRTC. <br><br>  Aqui estão alguns links muito úteis sobre a tecnologia WebRTC e o servidor Kurento que me ajudaram desde o início: <br><br><ul><li>  <a href="https://habr.com/ru/post/435580/">Serviços Java, Spring, Kurento e Mídia</a> </li><li>  <a href="https://habr.com/ru/company/Voximplant/blog/344794/">WebRTC: como dois navegadores concordam com chamadas de voz e vídeo</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/324914/">Desenvolvemos um bate-papo por vídeo entre o navegador e o aplicativo móvel</a> </li></ul><br><h3>  Introdução </h3><br>  A tarefa era simples: restaurar o sistema de videoconferência existente, fazer um inventário do que já havia sido feito antes e, se necessário, modificá-lo de acordo com os desejos dos usuários.  Os primeiros testes em máquinas virtuais e computadores reais foram bem-sucedidos.  Mas a implantação do sistema no cliente trouxe muitos problemas. <br><br>  Deixe-me lembrá-lo de que o cliente já possui um sistema de informações médicas (MIS) que abrange um grande número de tarefas: da fila eletrônica, local de trabalho do médico, gerenciamento de documentos e PACS ao subsistema de gerenciamento de equipamentos médicos. <br><br>  Quando se tornou necessário desenvolver a funcionalidade de videoconferência para conectar a equipe médica dos centros de diagnóstico (doravante denominada CD) a pacientes remotos, dois pré-requisitos foram estabelecidos: <br><br>  Todas as conferências devem ser gravadas e armazenadas no servidor. <br><br>  Os pacientes não devem instalar nenhum programa adicional em seus dispositivos, exceto o navegador, que na maioria dos casos já está pré-instalado. <br><br>  O WebRTC funciona a partir de um navegador sem programas ou plug-ins adicionais.  E o Kurento pode gravar tudo o que passa por ele.  Além disso, este servidor de mídia possui um bom conjunto de bibliotecas prontas para trabalhar com sua API através de Java e JavaScript, o que simplifica bastante o desenvolvimento. <br><br>  O desenvolvimento da parte do servidor, ou melhor, sua base, mesmo antes de iniciar a tarefa, foi transferido pelo cliente para uma empresa de terceirização para uma empresa de terceiros.  Portanto, havia um "Managing Server" (CSS) - uma base de servidores pronta para uso, que eu obtive para implementação. <br><br><h4>  A ideia geral de interação inicialmente era assim: </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ue/y-/qt/uey-qt4cvt81f4clyn6e0kdp4s4.png"></div><br>  Mas, no processo de trabalho adicional, todo o sistema mudou e se tornou mais complicado. <br><br><h3>  Primeira experiência de ressuscitação </h3><br>  Após a implantação em uma rede de teste em máquinas virtuais e em vários computadores "ativos", muitos testes e experimentos foram realizados - tudo funcionou perfeitamente.  Assim, chegou a hora de introduzir uma rede de trabalho real. <br><br>  Para o teste, uma vítima responsável na forma de um médico e seu local de trabalho foi designada para me ajudar.  E a segunda chamada através do microsserviço de telemedicina caiu! <br><br>  É bom que isso tenha acontecido durante o teste beta e, além de mim e um médico que estava satisfeito com as aventuras, ninguém viu isso. <br><br>  O que está acontecendo e por que a conexão não está sendo estabelecida foi muito difícil de entender.  O WebRTC não mostra falhas - apenas espera que um sinal apareça.  Inconscientemente, foi muito difícil depurar de alguma forma: a parte do servidor está funcionando bem, o Kurento está silencioso nos logs, os clientes estão aguardando o fluxo, mas nada acontece. <br><br>  Habr ajudou (louvado seja ele): <br><br><ul><li>  <a href="https://habr.com/ru/company/Voximplant/blog/417869/">Como depurar o WebRTC.</a> </li><li>  <a href="https://habr.com/ru/company/Voximplant/blog/351234/">5 erros ao desenvolver chamadas WebRTC a partir do navegador</a> </li><li>  <a href="https://habr.com/ru/company/yandex/blog/419951/">Experiência usando o WebRTC.</a>  <a href="https://habr.com/ru/company/yandex/blog/419951/">Palestra Yandex</a> </li></ul><br>  É uma pena que eu não conhecia essas ferramentas antes. <br><br>  Após analisar os dados do log e observar o status das conexões, ficou claro que os scripts do lado do servidor e do cliente não têm reação aos eventos no sistema WebRTC.  E onde conseguir esses eventos? <br><br>  Os desenvolvedores do servidor kurento fornecem uma biblioteca JavaScript muito conveniente para trabalhar com o WebRTC: kurento-utils.js. <br><br>  Para iniciar rapidamente, basta criar um objeto: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> kurentoUtils.WebRtcPeer.WebRtcPeerRecvonly(options, callback());</code> </pre> <br>  E, para acessar eventos, é necessário redefinir os métodos internos da biblioteca.  Simplifiquei o código o máximo possível para torná-lo mais claro: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    WebRtcPeerRecvonly var options = { //      peerConnection: getRTCPeerConnection(videoId), remoteVideo: videoElement, // //  ICE  onicecandidate: function (candidate) { onIceCandidate(candidate, videoId, true); }, onerror: onError, //   mediaConstraints: { //  video: true, audio: true} }; //  WebRTC incomeWebRtc[videoId] = new kurentoUtils.WebRtcPeer.WebRtcPeerRecvonly( options, function (error) { if (error) { return console.error(error); } this.generateOffer( function (error, sdpOffer) { //  }); }); //      function getRTCPeerConnection( videoId ){ var configuration = { "iceServers": [ {"url": "stun:" + stunServer}, {"url": "turn:" + turnServer, credential: turnCredential, username: turnUsername} ] }; var mypc = new RTCPeerConnection(configuration); //      mypc.oniceconnectionstatechange = function(){ state = this.iceConnectionState; console.info("### iceConnectionState " + videoId + " &gt; " + this.iceConnectionState); }; mypc.onsignalingstatechange = function(){ state = this.signalingState || this.readyState; console.info("### SignalingState " + videoId + " &gt; " + state); }; mypc.onconnectionstatechange = function(){ console.info("### ConnectionState " + videoId + " &gt; " + this.connectionState); }; return mypc; }</span></span></code> </pre><br><h3>  Falando de certificados </h3><br>  Como o artigo é sobre minha experiência, compartilharei informações de que os navegadores modernos se tornaram muito rígidos em relação à segurança.  Se o recurso tiver um certificado autoassinado, mesmo com permissão especial, o navegador proíbe o acesso aos periféricos do computador. <br><br>  Você pode criar um certificado com recursos gratuitos na Internet e configurar uma rede local para seu uso, ou baixar o Firefox versão 65 ou superior.Nesta versão, basta clicar no botão, que concordo com os riscos de certificados autoassinados e acessar câmeras e microfones. <br><br>  Dessa forma, parecia mais fácil para mim. <br><br><h3>  Segundo teste (já cuidadoso) </h3><br>  Pareceu-me que o médico iria concorrer a pipoca quando me visse no próximo teste.  Ele claramente gostava de me ver lutando com a tecnologia moderna. <br><br>  De fato, essa atualização do sistema não foi uma versão, porque eu não consertei nada, nem sabia a causa dos problemas.  Repito que tudo funcionou perfeitamente no escritório.  O código adicionou reações a todos os eventos que geraram o WebRTC e o Kurento, aos quais eu cheguei, e tudo isso foi escrito em grandes detalhes nos logs.  Até coloquei meus logs em arquivos separados para que não fossem confundidos com os principais do IIA. <br><br>  Juntamente com um médico especialista e um administrador de sistemas clientes, tentamos o sistema.  Eles nem testaram, a saber, "torturados".  Criamos videoconferências em todos os modos possíveis e em todos os dispositivos disponíveis.  Outros médicos e parte da equipe do escritório remoto estavam envolvidos neste jogo. <br><br>  O principal era não verificar o sistema (não funcionava), mas coletar o máximo de dados possível.  Como resultado, verificou-se que: <br><br><ol><li>  Aproximadamente 80% das tentativas de criar uma videoconferência são bem-sucedidas. </li><li>  Algumas conexões que usam candidatos ICE para IPv6 não funcionam. </li><li>  Dos 5 operadores móveis, apenas 2 funcionaram. </li></ol><br><h3>  Tudo ficou simples: você não pode ir muito longe apenas no Google </h3><br>  A análise das informações coletadas mostrou que a conexão através do servidor TURN do Google é instável.  Ou a carga neles é grande ou é apenas um servidor de demonstração para quem está começando a aprender a tecnologia.  Mas como um fato: falhas muito frequentes.  Precisa do seu próprio servidor TURN / STUN! <br><br>  O segundo motivo para as falhas são os endereços IPv6.local.  O servidor kurento não aceita candidatos a ICE com esses endereços.  É bom que antes de enviar todos os candidatos a ICE passem pelo código em minhas mãos e acabei de filtrar o IPv6.local. <br><br>  O problema das operadoras móveis é resolvido, novamente, com seu servidor TURN / STUN. <br>  Em três de cada cinco operadoras móveis, o NAT é simétrico e o WebRTC não pode avançar.  Mais detalhes podem ser encontrados aqui: <a href="https://habr.com/ru/post/150298/">O NAT simétrico é terrível?</a> <br><br>  É uma pena que meu celular pessoal funcione no cartão SIM de uma operadora que não se incomodou com a proteção simétrica.  Portanto, meu teste inicial não revelou esse problema. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9b/g4/ie/9bg4ieg5oblnd8f24osrtmwetws.png"></div><br><h3>  Servidor TURN / STUN </h3><br>  O pacote resiprocate-turn-server foi escolhido como servidor. <br><br>  Eles não escolheram por um longo tempo - está no repositório padrão do ubuntu - instalação fácil e atualizações automáticas.  Mas não é muito conveniente trabalhar com contas para conectar-se: logins e senhas são retirados apenas do arquivo, e é por isso que você precisa criar um utilitário ou script adicional para exportar do banco de dados do servidor principal. <br><br>  No momento, esse arquivo é gerado manualmente e as contas são distribuídas por um simples conjunto de senhas.  A autorização é implementada através do servidor principal do MIS, para que a segurança não seja comprometida.  Mas a estrutura geral de todo o sistema parece feia.  Os planos para refazer esse momento. <br><br><h3>  Terceira viagem ao cliente </h3><br>  Corrigi o código, instalei e configurei meu servidor TURN / STUN, desenvolvi um pool de senhas e as distribuí para os clientes no início de uma videoconferência e, após atualizar os servidores de produção, fui a um médico que eu já conhecia. <br><br>  Isso funciona!  Viva!  Todas as conferências iniciadas são bem-sucedidas em todos os dispositivos e em todos os modos: o paciente da conta pessoal pode ligar para o médico, o terapeuta durante a recepção pode ligar para o diagnóstico funcional para consultas adicionais, e os próprios médicos podem organizar uma videoconferência para vários usuários de diferentes ramos da cidade. <br><br>  Já ensinados por uma experiência amarga, nos envolvemos em testes meticulosos com a criação artificial de situações de emergência.  No tópico deste artigo, enfatizo a necessidade de definir um limite no tempo de espera da conexão.  O WebRTC, junto com o Kurento, estão esperando a transmissão começar infinitamente e esperam que os bytes de vídeo estejam prestes a ir.  Eu tive que definir um timer para 10 segundos, o que gera um erro no servidor de gerenciamento se os bytes nunca chegarem. <br><br><h3>  Depois de todas as melhorias </h3><br>  Finalmente, o sistema está funcionando e funcionando bem.  As primeiras críticas foram enviadas por usuários em campo.  E imediatamente um grande número de desejos e sugestões de design, funções adicionais e outros planos para desenvolvimento adicional apareceram.  O trabalho começou a ferver com vigor renovado! <br><br>  Agora, a topologia completa do sistema fica assim: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mr/ev/kn/mrevknsr8bnuhpmsnaowtthxd6m.png"></div><br><h3>  RESULTADOS: </h3><br>  Em conclusão, quero dizer o seguinte: <br><br>  Em primeiro lugar, o WebRTC é uma excelente tecnologia com grandes perspectivas, mas é muito difícil testá-lo e depurá-lo.  Antes de iniciar o desenvolvimento, é imperativo implantar uma rede com todos os tipos de conexões que o cliente possa ter.  E a depuração pela janela de informações do navegador não é uma ferramenta muito conveniente. <br><br>  Em segundo lugar, elogios a Habru!  Enquanto trabalhava neste projeto, encontrei muitas informações sobre este recurso.  Todos os links deste artigo levam a ele. <br><br>  Foi decidido deixar o projeto de videoconferência de telemedicina para suporte e desenvolvimento em nossa organização; não o terceirizaremos.  No futuro, ainda há muito trabalho: <br><br><ul><li>  Há uma finalização da colagem de vídeos gravados.  Voltarei a Habr, já encontrei um artigo para começar: <a href="https://habr.com/ru/post/277179/">combinando fragmentos de vídeo de várias câmeras e sincronizando-os com o tempo.</a> </li><li>  É necessário redesenhar o sistema de registro do usuário no servidor de gerenciamento, no servidor MIS principal e no servidor turn. </li><li>  E a questão está aberta com a taxa de transferência de todo o sistema como um todo.  Os testes de estresse ainda não foram realizados.  Prepare, leia novamente Habr: <a href="https://habr.com/ru/company/Voximplant/blog/346924/">Quantos participantes podem estar em uma chamada WebRTC?</a> </li></ul><br><h3>  TUDO </h3><br>  Estou certo de que minha experiência será útil não apenas para desenvolvedores sob WebRTC + Kurento, mas também para aqueles que começarão a implementar projetos igualmente complexos.  Preste mais atenção ao teste em condições o mais próximo possível da realidade. <br><br>  E leve em consideração os riscos que as equipes de suporte de seus microsserviços podem "desaparecer" repentinamente - essa é uma tarefa muito inesperada e desagradável. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt478536/">https://habr.com/ru/post/pt478536/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt478526/index.html">Um monte de OpenVPN no Windows Server e Mikrotik com a migração dessas coisas para o Linux</a></li>
<li><a href="../pt478528/index.html">Pet (uma história fantástica)</a></li>
<li><a href="../pt478530/index.html">TechnoText-2019: quem venceu no final e para que serve</a></li>
<li><a href="../pt478532/index.html">Como a Apple ganha: As 5 áreas de negócios mais lucrativas da empresa e quanto elas trazem para ela</a></li>
<li><a href="../pt478534/index.html">DevFest Siberia 2019: um olhar sobre as tendências do interior</a></li>
<li><a href="../pt478538/index.html">Como verificar a validade do seu passaporte</a></li>
<li><a href="../pt478540/index.html">Preparativos para o décimo fórum “Dias Positivos de Hack 10: Primeiros Passos”</a></li>
<li><a href="../pt478544/index.html">Vue Storefront: Importar diretório do Magento 2</a></li>
<li><a href="../pt478546/index.html">Websockets Alguma experiência em desenvolvimento e operação. Nós modificamos o cliente</a></li>
<li><a href="../pt478550/index.html">Como gerenciar um relógio? Análise da pista front-end do segundo campeonato de programação</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>