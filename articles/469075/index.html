<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôèüèº ü¶Ç üßëüèø Grokay DLR üí• ‚ö™Ô∏è üëÅ‚Äçüó®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prefacio del traductor 

 Esto es m√°s un recuento gratuito, no una traducci√≥n. Inclu√≠ en este art√≠culo solo aquellas partes del original que est√°n dir...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Grokay DLR</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469075/"> <i><b>Prefacio del traductor</b></i> <i><br><br></i>  <i>Esto es m√°s un recuento gratuito, no una traducci√≥n.</i>  <i>Inclu√≠ en este art√≠culo solo aquellas partes del original que est√°n directamente relacionadas con los mecanismos internos de DLR o explican ideas importantes.</i>  <i>Las notas se incluir√°n entre corchetes.</i> <br><br>  Muchos desarrolladores de .NET han escuchado sobre Dynamic Language Runtime (DLR), pero no saben casi nada al respecto.  Los desarrolladores que escriben en lenguajes como C # o Visual Basic evitan los lenguajes de tipeo din√°mico por temor a problemas de escalabilidad hist√≥ricamente relacionados.  Tambi√©n est√°n preocupados por el hecho de que lenguajes como Python o Ruby no realizan verificaciones de tipo en tiempo de compilaci√≥n, lo que puede conducir a errores de tiempo de ejecuci√≥n que son dif√≠ciles de encontrar y corregir.  Estos son temores bien fundados que pueden explicar por qu√© DLR no es popular entre la mayor√≠a de los desarrolladores de .NET incluso dos a√±os despu√©s del lanzamiento oficial <i>[el art√≠culo es bastante antiguo, pero desde entonces nada ha cambiado]</i> .  Despu√©s de todo, cualquier .NET <i>Runtime</i> que contenga las palabras <i>Din√°mico</i> e <i>Idioma</i> en su nombre debe dise√±arse estrictamente para admitir lenguajes como Python, ¬øverdad? <br><br>  M√°s despacio  Si bien DLR fue realmente dise√±ado para admitir la implementaci√≥n Iron de Python y Ruby en .NET Framework, su arquitectura proporciona abstracciones mucho m√°s profundas. <br><br><img src="https://habrastorage.org/webt/9p/co/0r/9pco0rjy7-sqeqb0hzgdngobjky.png"><br><a name="habracut"></a><br>  Bajo el cap√≥, DLR ofrece un rico conjunto de interfaces para la comunicaci√≥n entre procesos [Comunicaci√≥n entre procesos (IPC)].  Con los a√±os, los desarrolladores han visto muchas herramientas de Microsoft para la interacci√≥n entre aplicaciones: DDE, DCOM, ActiveX, .Net Remoting, WCF, OData.  Esta lista puede continuar por mucho tiempo.  Este es un desfile de acr√≥nimos casi interminable, cada uno de los cuales representa una tecnolog√≠a que promete que este a√±o ser√° a√∫n m√°s f√°cil intercambiar datos o llamar a c√≥digo remoto que antes. <br><br><h2>  Lengua de lenguas </h2><br>  La primera vez que escuch√© a Jim Hugunin hablar sobre DLR, su discurso me sorprendi√≥.  Jim cre√≥ una implementaci√≥n de Python para la m√°quina virtual Java (JVM) conocida como Jython.  Poco antes del espect√°culo, se uni√≥ a Microsoft para crear IronPython para .NET.  Seg√∫n sus antecedentes, esperaba que se concentrara en el lenguaje, pero en cambio, Jim hablaba casi todo el tiempo sobre cosas abstrusas como √°rboles de expresi√≥n, despacho din√°mico de llamadas y mecanismos de almacenamiento en cach√© de llamadas.  Jim describi√≥ un conjunto de servicios de compilaci√≥n en tiempo de ejecuci√≥n que permit√≠an que dos idiomas interactuaran entre s√≠ pr√°cticamente sin p√©rdida de rendimiento. <br><br>  Durante este discurso, escrib√≠ un t√©rmino que surgi√≥ en mi cabeza cuando escuch√© a Jim volver a contar la arquitectura DLR: el lenguaje de los idiomas.  Cuatro a√±os despu√©s, este apodo todav√≠a caracteriza a DLR con mucha precisi√≥n.  Sin embargo, habiendo adquirido experiencia de uso en el mundo real, me di cuenta de que DLR no se trata solo de compatibilidad de idiomas.  Gracias al soporte de tipos din√°micos en C # y Visual Basic, DLR puede actuar como una puerta de enlace desde nuestros lenguajes .NET favoritos a datos y c√≥digos en cualquier sistema remoto, independientemente del tipo de equipo o software que use este √∫ltimo. <br><br><img src="https://habrastorage.org/webt/sp/l2/k3/spl2k3kcuitbvqg151r1wfx_zzc.png"><br><br>  Para comprender la idea detr√°s de DLR, que es un mecanismo integrado en el lenguaje IPC, comencemos con un ejemplo que no tiene nada que ver con la programaci√≥n din√°mica.  Imagine dos sistemas inform√°ticos: uno llamado iniciador y el segundo, el sistema de destino.  El iniciador necesita ejecutar la funci√≥n <b>foo</b> en el sistema de destino, pasar all√≠ un cierto conjunto de par√°metros y obtener los resultados.  Una vez que se descubre el sistema de destino, el iniciador debe proporcionar toda la informaci√≥n necesaria para la ejecuci√≥n de la funci√≥n en un formato que le sea comprensible.  Como m√≠nimo, esta informaci√≥n incluir√° el nombre de la funci√≥n y los par√°metros pasados.  Despu√©s de desempaquetar la solicitud y validar los par√°metros, el sistema objetivo ejecutar√° la funci√≥n foo.  Despu√©s de eso, debe empaquetar el resultado, incluidos los errores que ocurrieron durante la ejecuci√≥n, y enviarlos de vuelta al iniciador.  Finalmente, el iniciador deber√≠a poder desempaquetar los resultados y notificar el objetivo.  Este patr√≥n de solicitud-respuesta es bastante com√∫n y en un alto nivel describe el funcionamiento de casi cualquier mecanismo de IPC. <br><br><h3>  Dynamicmetaobject </h3><br>  Para comprender c√≥mo DLR implementa el patr√≥n presentado, veamos una de las clases centrales de DLR: <b>DynamicMetaObject</b> .  Comenzamos explorando tres de los doce m√©todos clave de este tipo: <br><br><ol><li>  BindCreateInstance: crea o activa un objeto </li><li>  BindInvokeMember: llame al m√©todo encapsulado </li><li>  BindInvoke - ejecuci√≥n de objetos (como una funci√≥n) </li></ol><br>  Cuando necesite ejecutar un m√©todo en un sistema remoto, primero debe crear una instancia del tipo.  Por supuesto, no todos los sistemas est√°n orientados a objetos, por lo que el t√©rmino "instancia" puede ser una met√°fora.  De hecho, el servicio que necesitamos puede implementarse como un conjunto de objetos o como un singleton, de modo que los t√©rminos "activaci√≥n" o "conexi√≥n" puedan usarse con el mismo derecho que "instancia". <br><br>  Otros marcos siguen el mismo patr√≥n.  Por ejemplo, COM proporciona una funci√≥n <b>CoCreateInstance</b> para crear objetos.  En .NET Remoting, puede usar el m√©todo <b>CreateInstance</b> de la clase <b>System.Activator</b> .  DLR <b>DynamicMetaObject</b> proporciona una <b>BindCreateInstance</b> para fines similares. <br><br>  Despu√©s de usar el m√©todo <b>BindCreateInstance</b> , <i>algo</i> creado puede ser un tipo que expone varios m√©todos.  El <b>m√©todo de metaobjeto</b> BindInvokeMember <b>se</b> usa para vincular una operaci√≥n que puede llamar a una funci√≥n.  En la imagen de arriba, la cadena foo se puede pasar como un par√°metro para indicar al archivador que se debe llamar a un m√©todo con ese nombre.  Adem√°s, se incluye informaci√≥n sobre el n√∫mero de argumentos, sus nombres y un indicador especial que indica al archivador si es posible ignorar may√∫sculas y min√∫sculas cuando se busca un elemento con nombre adecuado.  Despu√©s de todo, no todos los idiomas distinguen entre may√∫sculas y min√∫sculas. <br><br>  Cuando <i>algo</i> devuelto por <b>BindCreateInstance</b> es solo una funci√≥n (o delegado), se utiliza el m√©todo BindInvoke.  Para aclarar la imagen, veamos el siguiente fragmento peque√±o de c√≥digo din√°mico: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntWriter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> Write = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IntWriter(Console.WriteLine); Write(<span class="hljs-number"><span class="hljs-number">5</span></span>); }</code> </pre> <br>  Este c√≥digo no es la mejor manera de imprimir el n√∫mero 5 en la consola.  Un buen desarrollador nunca usar√° nada tan derrochador.  Sin embargo, este c√≥digo ilustra el uso de una variable din√°mica cuyo valor es un delegado que se puede usar como una funci√≥n.  Si el tipo delegado implementa la interfaz <b>IDynamicMetaObjectProvider</b> , entonces el m√©todo <b>BindInvoke</b> de <b>DynamicMetaObject</b> se usar√° para vincular la operaci√≥n al trabajo real.  Esto se debe a que el compilador reconoce que el objeto de <b>escritura</b> din√°mica se usa <i>sint√°cticamente</i> como una funci√≥n.  Ahora considere otra pieza de c√≥digo para entender cu√°ndo el compilador generar√° <b>BindInvokeMember</b> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Writer</span></span> : <span class="hljs-title"><span class="hljs-title">IDynamicMetaObjectProvider</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Write</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n</span></span></span><span class="hljs-function">)</span></span> { Console.WriteLine(n); } <span class="hljs-comment"><span class="hljs-comment">//    } void Main() { dynamic Writer = new Writer(); Writer.Write(7); }</span></span></code> </pre><br>  Omitir√© la implementaci√≥n de la interfaz en este peque√±o ejemplo, porque tomar√° mucho c√≥digo para demostrar esto correctamente.  En este ejemplo abreviado, implementamos un metaobjeto din√°mico con solo unas pocas l√≠neas de c√≥digo. <br><br>  Una cosa importante a entender es que el compilador reconoce que <b>Writer.Write (7)</b> es una operaci√≥n de acceso a elementos.  Lo que generalmente llamamos el "operador de punto" en C # se llama formalmente el "operador de acceso de miembro de tipo".  El c√≥digo DLR generado por el compilador en este caso eventualmente llamar√° a <b>BindInvokeMember</b> , al cual pasar√° la cadena Escribir y el n√∫mero de par√°metro 7 a la operaci√≥n que es capaz de realizar la llamada.  En resumen, <b>BindInvoke se</b> usa para llamar a un objeto din√°mico como una funci√≥n, mientras que <b>BindInvokeMember se</b> usa para llamar a un m√©todo como un elemento de un objeto din√°mico. <br><br><h3>  Acceda a propiedades a trav√©s de DynamicMetaObject </h3><br>  Se puede ver en los ejemplos anteriores que el compilador usa la sintaxis del lenguaje para determinar qu√© operaciones de enlace DLR deben realizarse.  Si usa Visual Basic para trabajar con objetos din√°micos, se utilizar√° su sem√°ntica.  El operador de acceso (punto), por supuesto, es necesario no solo para acceder a los m√©todos.  Puede usarlo para acceder a las propiedades.  El metaobjeto DLR proporciona tres m√©todos para acceder a las propiedades de los objetos din√°micos: <br><br><ol><li>  BindGetMember - obtiene el valor de la propiedad </li><li>  BindSetMember - establece el valor de la propiedad </li><li>  BindDeleteMember - eliminar un elemento </li></ol><br>  El prop√≥sito de <b>BindGetMember</b> y <b>BindSetMember</b> deber√≠a ser obvio.  Especialmente ahora que sabe c√≥mo se relacionan con c√≥mo funciona .NET con las propiedades.  Cuando el compilador calcula las propiedades <i>get</i> ("lectura") de un objeto din√°mico, utiliza una llamada a <b>BindGetMember</b> .  Cuando el compilador calcula el conjunto ("registro"), utiliza <b>BindSetMember</b> . <br><br><h3>  Representaci√≥n de un objeto como una matriz. </h3><br>  Algunas clases son contenedores para instancias de otros tipos.  DLR sabe c√≥mo manejar tales casos.  Cada m√©todo de metaobjeto "orientado a la matriz" tiene un postfix "√çndice": <br><br><ol><li>  BindGetIndex - obtener valor por √≠ndice </li><li>  BindSetIndex - establece el valor por √≠ndice </li><li>  BindDeleteIndex: elimina un valor por √≠ndice </li></ol><br>  Para comprender c√≥mo se <b>usan BindGetIndex</b> y <b>BindSetIndex</b> , imagine una <b>clase de</b> contenedor <b>JavaBridge</b> que pueda cargar archivos con clases Java y le permita usarlos desde el c√≥digo .NET sin ninguna dificultad.  Tal contenedor puede usarse para cargar la clase Java del <b>Cliente</b> , que contiene alg√∫n c√≥digo ORM.  El metaobjeto DLR se puede usar para llamar a este c√≥digo ORM desde .NET en el estilo cl√°sico de C #.  A continuaci√≥n se muestra un c√≥digo de muestra que muestra c√≥mo <b>JavaBridge</b> puede funcionar en la pr√°ctica: <br><br><pre> <code class="cs hljs">JavaBridge java = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JavaBridge(); <span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> customers = java.Load(<span class="hljs-string"><span class="hljs-string">"Customer.class"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> Jason = customers[<span class="hljs-string"><span class="hljs-string">"Bock"</span></span>]; Jason.Balance = <span class="hljs-number"><span class="hljs-number">17.34</span></span>; customers[<span class="hljs-string"><span class="hljs-string">"Wagner"</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Customer(<span class="hljs-string"><span class="hljs-string">"Bill"</span></span>);</code> </pre> <br>  Como las l√≠neas tercera y quinta usan el operador de acceso por √≠ndice ([]), el compilador reconoce esto y usa los <b>m√©todos</b> <b>BindGetIndex</b> y <b>BindSetIndex</b> cuando trabaja con el metaobjeto devuelto por <b>JavaBridge</b> .  Se entiende que la implementaci√≥n de estos m√©todos en el objeto devuelto solicitar√° la ejecuci√≥n del m√©todo de la JVM a trav√©s de la Invocaci√≥n remota de m√©todos (RMI) de Java.  En este escenario, DLR act√∫a como un puente entre C # y otro lenguaje con tipeo est√°tico.  Espero que esto aclare por qu√© llam√© DLR "lenguaje de idiomas". <br><br>  El m√©todo <b>BindDeleteMember</b> , al igual que <b>BindDeleteIndex</b> , no est√° dise√±ado para su uso desde lenguajes con escritura est√°tica como C # y Visual Basic, ya que no admiten el concepto en s√≠.  Sin embargo, puede aceptar considerar "eliminar" alguna operaci√≥n expresada por los medios del lenguaje, si eso es √∫til para usted.  Por ejemplo, puede implementar BindDeleteMember como anulaci√≥n de un elemento por √≠ndice. <br><br><h3>  Transformaciones y Operadores </h3><br>  El √∫ltimo grupo de m√©todos de metaobjetos de DLR trata sobre el manejo de operadores y transformaciones. <br><br><ol><li>  BindConvert - convierte un objeto a otro tipo </li><li>  BindBinaryOperation: uso de un operador binario en dos operandos </li><li>  BindUnaryOperation: uso de un operador unario en un operando </li></ol><br>  El m√©todo <b>BindConvert se</b> usa cuando el compilador se da cuenta de que el objeto debe convertirse a otro tipo conocido.  La conversi√≥n impl√≠cita se produce cuando el resultado de una llamada din√°mica se asigna a una variable con un tipo est√°tico.  Por ejemplo, en el siguiente ejemplo de C #, la asignaci√≥n de la variable <b>y</b> conduce a una llamada impl√≠cita a <b>BindConvert</b> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> x = <span class="hljs-number"><span class="hljs-number">13</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = x + <span class="hljs-number"><span class="hljs-number">11</span></span>;</code> </pre> <br>  Los <b>m√©todos</b> <b>BindBinaryOperation</b> y <b>BindUnaryOperation</b> siempre se usan cuando se encuentran operaciones aritm√©ticas ("+") o incrementos ("++").  En el ejemplo anterior, agregar la variable din√°mica <b>x</b> a la constante 11 llamar√° al m√©todo <b>BindBinaryOperation</b> .  Recuerde este peque√±o ejemplo, lo usamos en la siguiente secci√≥n para golpear otra clase DLR clave llamada CallSite. <br><br><h2>  Despacho din√°mico con CallSite </h2><br>  Si su introducci√≥n a DLR no fue m√°s all√° del uso de la palabra clave <b>din√°mica</b> , entonces probablemente nunca habr√≠a sabido sobre la existencia de CallSite en .NET Framework.  Este tipo modesto, conocido formalmente como <b>CallSite</b> <b>&lt;</b> <b>T</b> <b>&gt;</b> , reside en el <b>espacio de nombres System.Runtime.CompilerServices</b> .  Esta es la "fuente de energ√≠a" de la metaprogramaci√≥n: est√° llena de todo tipo de m√©todos de optimizaci√≥n que hacen que el c√≥digo din√°mico .NET sea r√°pido y eficiente.  Mencionar√© los aspectos de rendimiento de <b>CallSite</b> <b>&lt;</b> <b>T</b> <b>&gt;</b> al final del art√≠culo. <br><br>  La mayor parte de lo que CallSite hace en c√≥digo .NET din√°mico implica generar y compilar c√≥digo en tiempo de ejecuci√≥n.  Es importante tener en cuenta que la <b>clase CallSite</b> <b>&lt;</b> <b>T</b> <b>&gt; se</b> encuentra en el espacio de nombres que contiene las palabras " <b>Runtime</b> " y " <b>CompilerServices</b> ".  Si DLR es un "lenguaje de idiomas", <b>CallSite</b> <b>&lt;</b> <b>T</b> <b>&gt;</b> es una de sus construcciones gramaticales m√°s importantes.  Miremos nuestro ejemplo de la secci√≥n anterior nuevamente para conocer CallSite y c√≥mo el compilador los integra en su c√≥digo. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> x = <span class="hljs-number"><span class="hljs-number">13</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = x + <span class="hljs-number"><span class="hljs-number">11</span></span>;</code> </pre> <br>  Como ya sabe, se <b>invocar√°n los</b> m√©todos <b>BindBinaryOperaion</b> y <b>BindConvert</b> para ejecutar este c√≥digo.  En lugar de mostrarle una larga lista del c√≥digo MSIL desmontado generado por el compilador, hice un diagrama: <br><br><img src="https://habrastorage.org/webt/c8/pw/0o/c8pw0osalzvckhg3w6b3eddlik4.png"><br><br>  Recuerde que el compilador usa la sintaxis del lenguaje para determinar qu√© m√©todos de tipo din√°mico ejecutar.  En nuestro ejemplo, se realizan dos operaciones: agregar la variable <b>x</b> al n√∫mero ( <b>Sitio2</b> ) y <b>transmitir</b> el resultado a int ( <b>Sitio1</b> ).  Cada una de estas acciones se convierte en CallSite, que se almacena en un contenedor especial.  Como puede ver en el diagrama, los CallSites se crean en el orden inverso, pero se llaman de la manera correcta. <br><br>  En la figura puede ver que los m√©todos de <b>metaobjetos BindConvert</b> y <b>BindBinaryOperation</b> se llaman inmediatamente antes de las operaciones "create CallSite1" y "create CallSite2".  Sin embargo, las operaciones enlazadas solo se realizan al final.  Espero que la visualizaci√≥n le ayude a comprender que los m√©todos vinculantes y llamarlos son operaciones diferentes en el contexto de DLR.  Adem√°s, el enlace ocurre solo una vez, mientras que una llamada ocurre tantas veces como sea necesario, reutilizando CallSites ya inicializados para optimizar el rendimiento. <br><br><h2>  Sigue el camino f√°cil </h2><br>  En el coraz√≥n mismo de DLR, los √°rboles de expresi√≥n se utilizan para generar funciones vinculadas a los doce m√©todos de enlace presentados anteriormente.  Muchos desarrolladores se enfrentan constantemente a √°rboles de expresi√≥n que utilizan LINQ, pero solo unos pocos tienen la experiencia lo suficientemente profunda como para implementar completamente el contrato <b>IDynamicMetaObjectProvider</b> .  Afortunadamente, .NET Framework contiene una clase base llamada <b>DynamicObject</b> que se encarga de la mayor parte del trabajo. <br><br>  Para crear su propia clase din√°mica, todo lo que tiene que hacer es heredar de <b>DynamicObject</b> e implementar los siguientes doce m√©todos: <br><br><ol><li>  TryCreateInstance </li><li>  TryInvokeMember </li><li>  Tryinvoke </li><li>  TryGetMember </li><li>  TrySetMember </li><li>  TryDeleteMember </li><li>  TryGetIndex </li><li>  TrySetIndex </li><li>  TryDeleteIndex </li><li>  Tryconvert </li><li>  TryBinaryOperation </li><li>  TryUnaryOperation </li></ol><br>  ¬øLos nombres de los m√©todos parecen familiares?  Debe hacerlo, porque acaba de terminar de estudiar los elementos de la clase Abstract <b>DynamicMetaObject</b> , que incluye m√©todos como <b>BindCreateInstance</b> y <b>BindInvoke</b> .  La clase <b>DynamicMetaObject</b> proporciona una implementaci√≥n para <b>IDynamicMetaObjectProvider</b> , que devuelve <b>DynamicMetaObject</b> desde su √∫nico m√©todo.  Las operaciones asociadas con la implementaci√≥n base del metaobjeto simplemente delegan sus llamadas a m√©todos que comienzan con "Probar" en la instancia de <b>DynamicObject</b> .  Todo lo que necesita hacer es sobrecargar m√©todos como <b>TryGetMember</b> y <b>TrySetMember</b> en una clase heredada de <b>DynamicObject</b> , mientras que el metaobjeto asumir√° todo el trabajo sucio con √°rboles de expresi√≥n. <br><br><h2>  Almacenamiento en cach√© </h2><br>  <i>[Puede leer m√°s sobre el almacenamiento en cach√© en mi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo anterior sobre DLR</a> ]</i> <br><br>  La mayor preocupaci√≥n al trabajar con lenguajes din√°micos para desarrolladores es el rendimiento.  DLR toma medidas extraordinarias para disipar estas experiencias.  Mencion√© brevemente el hecho de que <b>CallSite</b> <b>&lt;</b> <b>T</b> <b>&gt;</b> reside en un espacio de nombres llamado <b>System.Runtime.CompilerServices</b> .  En el mismo espacio de nombres se encuentran varias otras clases que proporcionan almacenamiento en cach√© multinivel.  Con estos tipos, DLR implementa tres niveles principales de almacenamiento en cach√© para acelerar las operaciones din√°micas: <br><br><ol><li>  Cach√© global </li><li>  Cach√© local </li><li>  Cach√© de delegado polim√≥rfico </li></ol><br>  El cach√© se usa para evitar el desperdicio innecesario de recursos para crear enlaces para un CallSite espec√≠fico.  Si <i>se</i> pasan dos objetos de tipo <i>cadena</i> a un m√©todo din√°mico que devuelve <i>int</i> , entonces el cach√© global o local guardar√° el enlace resultante.  Esto simplificar√° enormemente las llamadas posteriores. <br><br>  El cach√© de delegados, que se encuentra dentro de CallSite, se llama polim√≥rfico, porque estos delegados pueden tomar diferentes formas dependiendo de qu√© c√≥digo din√°mico se ejecute y qu√© reglas de otros cach√©s se usaron para generarlos.  El cach√© delegado tambi√©n se denomina a veces cach√© en l√≠nea.  La raz√≥n para usar este t√©rmino es que las expresiones generadas por el DLR y sus carpetas se convierten en c√≥digo MSIL que pasa a trav√©s de la compilaci√≥n JIT, como cualquier otro c√≥digo .NET.  La compilaci√≥n en tiempo de ejecuci√≥n ocurre simult√°neamente con la ejecuci√≥n "normal" de su programa.  Est√° claro que convertir el c√≥digo din√°mico sobre la marcha en c√≥digo MSIL compilado durante la ejecuci√≥n del programa puede afectar en gran medida el rendimiento de la aplicaci√≥n, por lo que los mecanismos de almacenamiento en cach√© son vitales. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/469075/">https://habr.com/ru/post/469075/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../469055/index.html">Practica zen en espacios abiertos</a></li>
<li><a href="../469059/index.html">¬øQu√© hay de nuevo en ML.NET y Model Builder?</a></li>
<li><a href="../469061/index.html">Versi√≥n Rust 1.38.0: compilaci√≥n canalizada, # [en desuso] para macros y std :: any :: type_name</a></li>
<li><a href="../469071/index.html">Inteligencia artificial Microsoft domin√≥ el mahjong</a></li>
<li><a href="../469073/index.html">Derivado discreto o resumen de c√≥mo sumar series</a></li>
<li><a href="../469077/index.html">Nuevo curso de Python de Microsoft [en ingl√©s]</a></li>
<li><a href="../469079/index.html">Python en Visual Studio Code: actualizaci√≥n de extensi√≥n de septiembre</a></li>
<li><a href="../469085/index.html">Sacamos el software del microcontrolador protegido con contrase√±a Renesas M16C</a></li>
<li><a href="../469087/index.html">MVCC en PostgreSQL-2. Tenedores, archivos, p√°ginas.</a></li>
<li><a href="../469093/index.html">Comparaci√≥n de bibliotecas de CLI menos populares y no muy cliff: cliff, plac, plumbum y otras (parte 2)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>