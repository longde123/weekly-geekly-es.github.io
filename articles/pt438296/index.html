<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôíÔ∏è üå∂Ô∏è üòù OpenSceneGraph: Sistema de plugins üöµ üõï üî¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introdu√ß√£o 
 Em algum lugar das li√ß√µes anteriores, j√° foi dito que o OSG suporta o carregamento de v√°rios tipos de recursos, como imagens raster, m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: Sistema de plugins</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438296/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="imagem"><br><h1>  1. Introdu√ß√£o </h1><br>  Em algum lugar das li√ß√µes anteriores, j√° foi dito que o OSG suporta o carregamento de v√°rios tipos de recursos, como imagens raster, modelos 3D de v√°rios formatos ou, por exemplo, fontes atrav√©s de seu pr√≥prio sistema de plug-in.  O plug-in OSG √© um componente separado que estende a funcionalidade do mecanismo e possui uma interface padronizada no OSG.  O plug-in √© implementado como uma biblioteca compartilhada din√¢mica (DLL no Windows, Linux, etc.).  Os nomes das bibliotecas de plug-ins correspondem a uma conven√ß√£o espec√≠fica <br><br><pre><code class="plaintext hljs">osgdb_&lt; &gt;.dll</code> </pre> <br>  isto √©, o nome do plug-in sempre cont√©m o prefixo osgdb_.  Uma extens√£o de arquivo informa ao mecanismo qual plug-in deve ser usado para baixar um arquivo com essa extens√£o.  Por exemplo, quando escrevemos uma fun√ß√£o no c√≥digo <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"cessna.osg"</span></span>);</code> </pre><br>  o mecanismo v√™ a extens√£o osg e carrega um plugin chamado osgdb_osg.dll (ou osgdb_osg.so no caso do Linux).  O c√≥digo do plug-in faz todo o trabalho sujo, retornando um ponteiro para um n√≥ que descreve o modelo de cessna.  Da mesma forma, tentando carregar uma imagem PNG <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg:Image&gt; image = osgDB::readImageFile(<span class="hljs-string"><span class="hljs-string">"picture.png"</span></span>);</code> </pre><br>  far√° com que o plug-in osgdb_png.dll seja carregado, o que implementa um algoritmo para ler dados de uma imagem PNG e coloc√°-los em um objeto do tipo osg :: Image. <br><a name="habracut"></a><br>  Todas as opera√ß√µes de trabalho com recursos externos s√£o implementadas pelas fun√ß√µes da biblioteca osgDB, com as quais invariavelmente vinculamos os programas de exemplo para exemplo.  Esta biblioteca conta com o sistema de plug-in OSG.  At√© o momento, o pacote OSG inclui muitos plug-ins que funcionam com a maioria dos formatos de imagem, modelos 3D e fontes usados ‚Äã‚Äãna pr√°tica.  Os plug-ins fornecem dados de leitura (importa√ß√£o) de um formato espec√≠fico e, na maioria dos casos, grava√ß√£o de dados em um arquivo do formato necess√°rio (exporta√ß√£o).  O utilit√°rio osgconv, em particular, permite converter dados de um formato para outro, por exemplo, o sistema de plug-in. <br><br><pre> <code class="plaintext hljs">$ osgconv cessna.osg cessna.3ds</code> </pre><br>  ele converte f√°cil e naturalmente o modelo cessna osg para o formato 3DS, que pode ser importado para um editor 3D, por exemplo, no Blender (a prop√≥sito, h√° uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">extens√£o para trabalhar com o osg diretamente</a> no Blender) <br><br><img src="https://habrastorage.org/webt/vy/dm/qm/vydmqm2a3evtdqxu2vtf_kknmrw.png"><br><br>  H√° uma lista oficial de plug-ins OSG padr√£o com uma descri√ß√£o de seu objetivo, mas √© longo e tenho pregui√ßa de traz√™-lo aqui.  √â mais f√°cil observar o caminho da instala√ß√£o da biblioteca na pasta bin / ospPlugins-xyz, em que x, y, z √© o n√∫mero da vers√£o do OSG.  A partir do nome do arquivo do plug-in, √© f√°cil entender qual formato ele processa. <br><br>  Se o OSG for compilado pelo compilador MinGW, um prefixo adicional mingw_ ser√° adicionado ao nome padr√£o do plug-in, ou seja, o nome ser√° semelhante a este <br><br><pre> <code class="plaintext hljs">mingw_osgdb_&lt; &gt;.dll</code> </pre><br>  A vers√£o do plug-in compilado na configura√ß√£o DEBUG est√° adicionalmente equipada com o sufixo d no final do nome, ou seja, o formato ser√° <br><br><pre> <code class="plaintext hljs">osgdb_&lt; &gt;d.dll</code> </pre><br>  ou <br><br><pre> <code class="plaintext hljs">mingw_osgdb_&lt; &gt;d.dll</code> </pre><br>  ao montar o MinGW. <br><br><h1>  1. Pseudo-carregadores de plugins </h1><br>  Alguns plug-ins OSG atuam como pseudo-carregadores - isso significa que eles n√£o est√£o vinculados a uma extens√£o de arquivo espec√≠fica, mas adicionando um sufixo ao final do nome do arquivo, voc√™ pode especificar qual plug-in deve ser usado para baixar este arquivo, por exemplo <br><br><pre> <code class="plaintext hljs">$ osgviewer worldmap.shp.ogr</code> </pre><br>  Nesse caso, o nome real do arquivo no disco √© worldmap.shp - esse arquivo armazena um mapa do mundo no formato de arquivo de forma ESRI.  O sufixo .ogr diz √† biblioteca osgDB para usar o plug-in osgdb_ogr para carregar este arquivo;  caso contr√°rio, o plugin osgdb_shp ser√° usado. <br><br>  Outro bom exemplo √© o plug-in osgdb_ffmpeg.  A biblioteca FFmpeg suporta mais de 100 codecs diferentes.  Para ler qualquer um deles, podemos simplesmente adicionar o sufixo .ffmpeg ap√≥s o nome do arquivo de m√≠dia. <br><br>  Al√©m disso, alguns pseudo-carregadores nos permitem passar por um sufixo v√°rios par√¢metros que afetam o estado do objeto carregado, e j√° o encontramos em um exemplo com anima√ß√£o <br><br><pre> <code class="cpp hljs">node = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"cessna.osg.0,0,90.rot"</span></span>);</code> </pre><br>  A linha 0,90 indica para o plug-in osgdb_osg os par√¢metros da orienta√ß√£o inicial do modelo carregado.  Alguns pseudo-carregadores exigem par√¢metros completamente espec√≠ficos para funcionar. <br><br><h1>  2. API para desenvolver plugins de terceiros </h1><br>  √â completamente l√≥gico se, depois de toda a leitura, voc√™ tiver a ideia de que provavelmente n√£o seria dif√≠cil escrever seu pr√≥prio plug-in para OSG, o que permitiria importar um formato n√£o padr√£o de modelos ou imagens 3D.  E este √© um pensamento verdadeiro!  O mecanismo de plug-in foi projetado apenas para expandir a funcionalidade do mecanismo sem alterar o pr√≥prio OSG.  Para entender os princ√≠pios b√°sicos de escrever um plugin, vamos tentar implementar um exemplo simples. <br><br>  O desenvolvimento do plug-in √© expandir a interface virtual de leitura / grava√ß√£o fornecida pelo OSG.  Essa funcionalidade √© fornecida pela classe virtual osgDB :: ReaderWriter.  Esta classe fornece v√°rios m√©todos virtuais redefinidos pelo desenvolvedor do plugin. <br><table><thead><tr><th>  M√©todo </th><th>  Descri√ß√£o do produto </th></tr></thead><tbody><tr><td>  supportExtensions () </td><td>  Ele aceita dois par√¢metros de string: extens√£o e descri√ß√£o do arquivo.  O m√©todo √© sempre chamado no construtor da subclasse. </td></tr><tr><td>  acceptExtension () </td><td>  Retorna true se a extens√£o passada como argumento for suportada pelo plugin </td></tr><tr><td>  fileExists () </td><td>  Permite determinar se um determinado arquivo existe (o caminho √© passado como par√¢metro) no disco (retorna verdadeiro se for bem-sucedido) </td></tr><tr><td>  readNode () </td><td>  Aceita o nome do arquivo e as op√ß√µes como um objeto osgDB :: Option.  Fun√ß√µes para ler dados de um arquivo s√£o implementadas pelo desenvolvedor </td></tr><tr><td>  writeNode () </td><td>  Aceita o nome do n√≥, o nome do arquivo desejado e as op√ß√µes.  As fun√ß√µes de grava√ß√£o de dados no disco s√£o implementadas pelo desenvolvedor </td></tr><tr><td>  readImage () </td><td>  Lendo dados de bitmap do disco </td></tr><tr><td>  writeImage () </td><td>  Gravando um bitmap no disco </td></tr></tbody></table><br>  A implementa√ß√£o do m√©todo readNode () pode ser descrita pelo seguinte c√≥digo <br><br><pre> <code class="cpp hljs">osgDB::ReaderWriter::<span class="hljs-function"><span class="hljs-function">ReadResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgDB::Options *options)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//         bool recognizableExtension = ...; bool fileExists = ...; if (!recognizableExtension) return ReadResult::FILE_NOT_HANDLED; if (!fileExists) return ReadResult::FILE_NOT_FOUND; //          osg::Node *root = ...; //       -     . //    -      bool errorInParsing = ...; if (errorInParsing) return ReadResult::ERROR_IN_READING_FILE; return root; }</span></span></code> </pre><br>  √â um pouco surpreendente que, em vez de um ponteiro para o n√≥ do gr√°fico de cena, o m√©todo retorne o tipo osgDB :: ReaderWriter :: ReadResult.  Esse tipo √© um objeto de resultado de leitura e pode ser usado como um cont√™iner de n√≥, imagem, enumerador de estado (por exemplo, FILE_NOT_FOUND), outro objeto especial ou mesmo como uma sequ√™ncia de mensagens de erro.  Possui muitos construtores impl√≠citos para implementar as fun√ß√µes descritas. <br><br>  Outra classe √∫til √© osgDB :: Options.  Ele permite que voc√™ defina ou obtenha uma s√©rie de op√ß√µes de carregamento usando os m√©todos setOptionString () e getOptionString ().  Passar essa string para o construtor dessa classe como argumento tamb√©m √© permitido. <br><br>  O desenvolvedor pode controlar o comportamento do plug-in definindo as configura√ß√µes na sequ√™ncia de par√¢metros transmitida ao carregar o objeto, por exemplo, desta maneira <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    osg::Node* node1 = osgDB::readNodeFile("cow.osg"); //     string osg::Node* node2 = osgDB::readNodeFile("cow.osg", new osgDB::Options(string));</span></span></code> </pre><br><h1>  3. Processamento de fluxo de dados no plugin OSG </h1><br>  A classe base osgDB :: ReaderWriter inclui um conjunto de m√©todos que processam os dados dos fluxos de entrada / sa√≠da fornecidos pela biblioteca C ++ padr√£o.  A √∫nica diferen√ßa entre esses m√©todos de leitura / grava√ß√£o e os discutidos acima √© que, em vez do nome do arquivo, eles aceitam fluxos std :: istream &amp; input ou std :: ostream &amp; stream de sa√≠da.  Usar um fluxo de E / S de arquivo √© sempre prefer√≠vel a usar um nome de arquivo.  Para executar opera√ß√µes de leitura de arquivos, podemos usar o seguinte design de interface: <br><br><pre> <code class="cpp hljs">osgDB::ReaderWriter::<span class="hljs-function"><span class="hljs-function">ReadResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgDB::Options *options)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ ... osgDB::<span class="hljs-function"><span class="hljs-function">ifstream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(file.c_str(), </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ios::binary)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!stream) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ReadResult::ERROR_IN_READING_FILE; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> readNode(stream, options); } ... osgDB::ReaderWriter::<span class="hljs-function"><span class="hljs-function">ReadResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::istream &amp;stream, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgDB::Options *options)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//         osg::Node *root = ...; return root; }</span></span></code> </pre><br>  Ap√≥s implementar o plug-in, podemos usar as fun√ß√µes padr√£o osgDB :: readNodeFile () e osgDB :: readImageFile () para carregar modelos e imagens, simplesmente especificando o caminho do arquivo.  O OSG encontrar√° e far√° o download do plug-in que escrevemos. <br><br><h1>  4. N√≥s escrevemos nosso pr√≥prio plugin </h1><br><br>  Portanto, ningu√©m nos incomoda em criar nosso pr√≥prio formato para armazenar dados em geometria tridimensional, e n√≥s iremos faz√™-lo <br><br>  <strong>piramide.pmd</strong> <br><br><pre> <code class="plaintext hljs">vertex: 1.0 1.0 0.0 vertex: 1.0 -1.0 0.0 vertex: -1.0 -1.0 0.0 vertex: -1.0 1.0 0.0 vertex: 0.0 0.0 2.0 face: 0 1 2 3 face: 0 3 4 face: 1 0 4 face: 2 1 4 face: 3 2 4</code> </pre><br>  Aqui, no in√≠cio do arquivo, h√° uma lista de v√©rtices com suas coordenadas.  Os √≠ndices de v√©rtices est√£o em ordem, come√ßando do zero.  Ap√≥s a lista de v√©rtices, aparece uma lista de faces.  Cada face √© definida por uma lista de √≠ndices de v√©rtices a partir da qual √© formada.  Aparentemente, nada complicado.  A tarefa √© ler esse arquivo do disco e formar uma geometria tridimensional com base. <br><br><h1>  5. Configura√ß√£o do projeto de plug-in: criar recursos de script </h1><br>  Se antes de criarmos aplicativos, agora precisamos escrever uma biblioteca din√¢mica, e n√£o apenas uma biblioteca, mas um plug-in OSG que atenda a certos requisitos.  Come√ßaremos a cumprir esses requisitos com um script de constru√ß√£o do projeto que ser√° parecido com este <br><br>  <strong>plugin.pro</strong> <br><br><pre> <code class="cmake hljs">TEMPLATE = lib CONFIG += plugin CONFIG += no_plugin_name_prefix <span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = osgdb_pmd win32-g++: <span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = $$join(<span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span>,,mingw_,) win32 { OSG_LIB_DIRECTORY = $$(OSG_BIN_PATH) OSG_INCLUDE_DIRECTORY = $$(OSG_INCLUDE_PATH) DESTDIR = $$(OSG_PLUGINS_PATH) CONFIG(debug, debug|release) { <span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = $$join(<span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span>,,,d) LIBS += -L$$OSG_LIB_DIRECTORY -losgd LIBS += -L$$OSG_LIB_DIRECTORY -losgViewerd LIBS += -L$$OSG_LIB_DIRECTORY -losgDBd LIBS += -L$$OSG_LIB_DIRECTORY -lOpenThreadsd LIBS += -L$$OSG_LIB_DIRECTORY -losgUtild } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { LIBS += -L$$OSG_LIB_DIRECTORY -losg LIBS += -L$$OSG_LIB_DIRECTORY -losgViewer LIBS += -L$$OSG_LIB_DIRECTORY -losgDB LIBS += -L$$OSG_LIB_DIRECTORY -lOpenThreads LIBS += -L$$OSG_LIB_DIRECTORY -losgUtil } INCLUDEPATH += $$OSG_INCLUDE_DIRECTORY } unix { DESTDIR = /usr/lib/osgPlugins-<span class="hljs-number"><span class="hljs-number">3.7</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> CONFIG(debug, debug|release) { <span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = $$join(<span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span>,,,d) LIBS += -losgd LIBS += -losgViewerd LIBS += -losgDBd LIBS += -lOpenThreadsd LIBS += -losgUtild } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { LIBS += -losg LIBS += -losgViewer LIBS += -losgDB LIBS += -lOpenThreads LIBS += -losgUtil } } INCLUDEPATH += ./<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> HEADERS += $$files(./<span class="hljs-keyword"><span class="hljs-keyword">include</span></span>/*.h) SOURCES += $$files(./src/*.cpp)</code> </pre><br>  Analisaremos as nuances individuais com mais detalhes <br><br><pre> <code class="cmake hljs">TEMPLATE = lib</code> </pre><br>  significa que vamos construir a biblioteca.  Para impedir a gera√ß√£o de links simb√≥licos com a ajuda de quais problemas dos conflitos de vers√£o da biblioteca s√£o resolvidos nos sistemas * nix, indicamos ao sistema de compila√ß√£o que essa biblioteca ser√° um plug-in, ou seja, ser√° carregada na mem√≥ria "on the fly" <br><br><pre> <code class="cmake hljs">CONFIG += plugin</code> </pre><br>  Em seguida, exclu√≠mos a gera√ß√£o do prefixo da lib, que √© adicionado ao usar os compiladores da fam√≠lia gcc e √© levado em considera√ß√£o pelo ambiente de tempo de execu√ß√£o ao carregar a biblioteca <br><br><pre> <code class="cmake hljs">CONFIG += no_plugin_name_prefix</code> </pre><br>  Defina o nome do arquivo da biblioteca <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = osgdb_pmd</code> </pre><br>  onde pmd √© a extens√£o de arquivo do formato de modelo 3D que inventamos.  Al√©m disso, devemos indicar que, no caso da montagem MinGW, o prefixo mingw_ <br><br><pre> <code class="cmake hljs">win32-g++: <span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = $$join(<span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span>,,mingw_,)</code> </pre><br>  Especifique o caminho de constru√ß√£o da biblioteca: para Windows <br><br><pre> <code class="cmake hljs">DESTDIR = $$(OSG_PLUGINS_PATH)</code> </pre><br>  para linux <br><br><pre> <code class="cmake hljs">DESTDIR = /usr/lib/osgPlugins-<span class="hljs-number"><span class="hljs-number">3.7</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br>  Para o Linux, com essa indica√ß√£o do caminho (que sem d√∫vida √© uma muleta, mas ainda n√£o encontrei outra solu√ß√£o), damos o direito de gravar na pasta especificada com plugins OSG de um usu√°rio comum <br><br><pre> <code class="plaintext hljs"># chmod 666 /usr/lib/osgPlugins-3.7.0</code> </pre><br>  Todas as outras configura√ß√µes de constru√ß√£o s√£o semelhantes √†s usadas na montagem de aplicativos de amostra anteriormente. <br><br><h1>  6. Configura√ß√£o do projeto de plug-in: recursos do modo de depura√ß√£o </h1><br>  Como este projeto √© uma biblioteca din√¢mica, deve haver um programa que carrega essa biblioteca no processo de sua execu√ß√£o.  Pode ser qualquer aplicativo que use OSG e no qual a fun√ß√£o ser√° chamada <br><br><pre> <code class="cpp hljs">node = osdDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"piramide.pmd"</span></span>);</code> </pre><br>  Nesse caso, nosso plugin ser√° carregado.  Para n√£o escrever esse programa por conta pr√≥pria, usaremos uma solu√ß√£o pronta - o visualizador padr√£o do osgviewer inclu√≠do no pacote de entrega do mecanismo.  Se no console, execute <br><br><pre> <code class="plaintext hljs">$ osgviewer piramide.pmd</code> </pre><br>  ent√£o tamb√©m acionar√° o plugin.  Nas configura√ß√µes de inicializa√ß√£o do projeto, especifique o caminho para osgviewerd, como o diret√≥rio de trabalho, especifique o diret√≥rio em que o arquivo piramide.pmd est√° localizado e especifique o mesmo arquivo nas op√ß√µes da linha de comandos do osgviewer <br><br><img src="https://habrastorage.org/webt/v8/9y/xa/v89yxafvygysowtw7aeihf9mgcs.png"><br><br>  Agora podemos executar o plug-in e depur√°-lo diretamente do QtCreator IDE. <br><br><h1>  6. Implementamos a estrutura do plugin </h1><br>  Este exemplo generaliza em certa medida o conhecimento que j√° recebemos sobre OSG de li√ß√µes anteriores.  Ao escrever um plugin, temos que <br><br><ol><li>  Selecione uma estrutura de dados para armazenar as informa√ß√µes da geometria do modelo lidas em um arquivo de modelo <br></li><li>  Leia e analise (analise) o arquivo de dados do modelo <br></li><li>  Configure corretamente o objeto geom√©trico osg :: Drawable com base nos dados lidos no arquivo <br></li><li>  Construir um subgr√°fico de cena para um modelo carregado <br></li></ol><br>  Ent√£o, por tradi√ß√£o, darei todo o c√≥digo fonte do plugin <br><br><div class="spoiler">  <b class="spoiler_title">Plug-in Osgdb_pmd</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geometry&gt; #include &lt;osg/Geode&gt; #include &lt;osgDB/FileNameUtils&gt; #include &lt;osgDB/FileUtils&gt; #include &lt;osgDB/Registry&gt; #include &lt;osgUtil/SmoothingVisitor&gt; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ struct face_t { std::vector&lt;unsigned int&gt; indices; }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ struct pmd_mesh_t { osg::ref_ptr&lt;osg::Vec3Array&gt; vertices; osg::ref_ptr&lt;osg::Vec3Array&gt; normals; std::vector&lt;face_t&gt; faces; pmd_mesh_t() : vertices(new osg::Vec3Array) , normals(new osg::Vec3Array) { } osg::Vec3 calcFaceNormal(const face_t &amp;face) const { osg::Vec3 v0 = (*vertices)[face.indices[0]]; osg::Vec3 v1 = (*vertices)[face.indices[1]]; osg::Vec3 v2 = (*vertices)[face.indices[2]]; osg::Vec3 n = (v1 - v0) ^ (v2 - v0); return n * (1 / n.length()); } }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class ReaderWriterPMD : public osgDB::ReaderWriter { public: ReaderWriterPMD(); virtual ReadResult readNode(const std::string &amp;filename, const osgDB::Options *options) const; virtual ReadResult readNode(std::istream &amp;stream, const osgDB::Options *options) const; private: pmd_mesh_t parsePMD(std::istream &amp;stream) const; std::vector&lt;std::string&gt; parseLine(const std::string &amp;line) const; }; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ ReaderWriterPMD::ReaderWriterPMD() { supportsExtension("pmd", "PMD model file"); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osgDB::ReaderWriter::ReadResult ReaderWriterPMD::readNode( const std::string &amp;filename, const osgDB::Options *options) const { std::string ext = osgDB::getLowerCaseFileExtension(filename); if (!acceptsExtension(ext)) return ReadResult::FILE_NOT_HANDLED; std::string fileName = osgDB::findDataFile(filename, options); if (fileName.empty()) return ReadResult::FILE_NOT_FOUND; std::ifstream stream(fileName.c_str(), std::ios::in); if (!stream) return ReadResult::ERROR_IN_READING_FILE; return readNode(stream, options); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osgDB::ReaderWriter::ReadResult ReaderWriterPMD::readNode( std::istream &amp;stream, const osgDB::Options *options) const { (void) options; pmd_mesh_t mesh = parsePMD(stream); osg::ref_ptr&lt;osg::Geometry&gt; geom = new osg::Geometry; geom-&gt;setVertexArray(mesh.vertices.get()); for (size_t i = 0; i &lt; mesh.faces.size(); ++i) { osg::ref_ptr&lt;osg::DrawElementsUInt&gt; polygon = new osg::DrawElementsUInt(osg::PrimitiveSet::POLYGON, 0); for (size_t j = 0; j &lt; mesh.faces[i].indices.size(); ++j) polygon-&gt;push_back(mesh.faces[i].indices[j]); geom-&gt;addPrimitiveSet(polygon.get()); } geom-&gt;setNormalArray(mesh.normals.get()); geom-&gt;setNormalBinding(osg::Geometry::BIND_PER_PRIMITIVE_SET); osg::ref_ptr&lt;osg::Geode&gt; geode = new osg::Geode; geode-&gt;addDrawable(geom.get()); return geode.release(); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ pmd_mesh_t ReaderWriterPMD::parsePMD(std::istream &amp;stream) const { pmd_mesh_t mesh; while (!stream.eof()) { std::string line; std::getline(stream, line); std::vector&lt;std::string&gt; tokens = parseLine(line); if (tokens[0] == "vertex") { osg::Vec3 point; std::istringstream iss(tokens[1]); iss &gt;&gt; point.x() &gt;&gt; point.y() &gt;&gt; point.z(); mesh.vertices-&gt;push_back(point); } if (tokens[0] == "face") { unsigned int idx = 0; std::istringstream iss(tokens[1]); face_t face; while (!iss.eof()) { iss &gt;&gt; idx; face.indices.push_back(idx); } mesh.faces.push_back(face); mesh.normals-&gt;push_back(mesh.calcFaceNormal(face)); } } return mesh; } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ std::string delete_symbol(const std::string &amp;str, char symbol) { std::string tmp = str; tmp.erase(std::remove(tmp.begin(), tmp.end(), symbol), tmp.end()); return tmp; } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ std::vector&lt;std::string&gt; ReaderWriterPMD::parseLine(const std::string &amp;line) const { std::vector&lt;std::string&gt; tokens; std::string tmp = delete_symbol(line, '\r'); size_t pos = 0; std::string token; while ( (pos = tmp.find(':')) != std::string::npos ) { token = tmp.substr(0, pos); tmp.erase(0, pos + 1); if (!token.empty()) tokens.push_back(token); } tokens.push_back(tmp); return tokens; } REGISTER_OSGPLUGIN( pmd, ReaderWriterPMD )</span></span></span></span></code> </pre><br></div></div><br>  Primeiro, vamos cuidar das estruturas para armazenar dados de geometria. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">face_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; indices; };</code> </pre><br>  - descreve a face definida pela lista de √≠ndices dos v√©rtices pertencentes a essa face.  O modelo como um todo ser√° descrito por essa estrutura <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pmd_mesh_t</span></span></span><span class="hljs-class"> {</span></span> osg::ref_ptr&lt;osg::Vec3Array&gt; vertices; osg::ref_ptr&lt;osg::Vec3Array&gt; normals; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">face_t</span></span>&gt; faces; <span class="hljs-keyword"><span class="hljs-keyword">pmd_mesh_t</span></span>() : vertices(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array) , normals(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array) { } osg::<span class="hljs-function"><span class="hljs-function">Vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calcFaceNormal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">face_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;face)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ osg::Vec3 v0 = (*vertices)[face.indices[<span class="hljs-number"><span class="hljs-number">0</span></span>]]; osg::Vec3 v1 = (*vertices)[face.indices[<span class="hljs-number"><span class="hljs-number">1</span></span>]]; osg::Vec3 v2 = (*vertices)[face.indices[<span class="hljs-number"><span class="hljs-number">2</span></span>]]; osg::Vec3 n = (v1 - v0) ^ (v2 - v0); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n * (<span class="hljs-number"><span class="hljs-number">1</span></span> / n.length()); } };</code> </pre><br>  A estrutura consiste em vari√°veis-membro para armazenar dados: v√©rtices - para armazenar uma matriz de v√©rtices de um objeto geom√©trico;  normais - uma matriz de normais para as faces do objeto;  faces - uma lista de faces do objeto.  O construtor de estrutura inicializa imediatamente ponteiros inteligentes <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pmd_mesh_t</span></span>() : vertices(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array) , normals(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array) { }</code> </pre><br>  Al√©m disso, a estrutura cont√©m um m√©todo que permite calcular o vetor normal para a face calcFaceNormal () como um par√¢metro que utiliza uma estrutura que descreve a face.  Ainda n√£o entraremos em detalhes da implementa√ß√£o desse m√©todo, mas os analisaremos um pouco mais tarde. <br><br>  Assim, decidimos sobre as estruturas nas quais armazenaremos os dados da geometria.  Agora vamos escrever a estrutura do nosso plugin, a saber, implementamos a classe herdada osgDB :: ReaderWriter <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReaderWriterPMD</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osgDB::ReaderWriter { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ReaderWriterPMD(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> ReadResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgDB::Options *options)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> ReadResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::istream &amp;stream, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgDB::Options *options)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pmd_mesh_t</span></span> parsePMD(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream &amp;stream) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; parseLine(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;line) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; };</code> </pre><br>  Conforme recomendado na descri√ß√£o da API para o desenvolvimento de plug-ins, nesta classe redefinimos os m√©todos de leitura de dados de um arquivo e os convertemos em um subgrafo da cena.  O m√©todo readNode () realiza duas sobrecargas - uma aceita o nome do arquivo como entrada e a outra recebe a entrada padr√£o.  O construtor da classe define as extens√µes de arquivo suportadas pelo plug-in <br><br><pre> <code class="cpp hljs">ReaderWriterPMD::ReaderWriterPMD() { supportsExtension(<span class="hljs-string"><span class="hljs-string">"pmd"</span></span>, <span class="hljs-string"><span class="hljs-string">"PMD model file"</span></span>); }</code> </pre><br>  A primeira sobrecarga do m√©todo readNode () analisa a corre√ß√£o do nome e do caminho do arquivo, associa um fluxo de entrada padr√£o ao arquivo e chama a segunda sobrecarga, que faz o trabalho principal <br><br><pre> <code class="cpp hljs">osgDB::ReaderWriter::ReadResult ReaderWriterPMD::readNode( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;filename, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> osgDB::Options *options) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-comment"><span class="hljs-comment">//       std::string ext = osgDB::getLowerCaseFileExtension(filename); // ,      if (!acceptsExtension(ext)) return ReadResult::FILE_NOT_HANDLED; // ,       std::string fileName = osgDB::findDataFile(filename, options); if (fileName.empty()) return ReadResult::FILE_NOT_FOUND; //      std::ifstream stream(fileName.c_str(), std::ios::in); if (!stream) return ReadResult::ERROR_IN_READING_FILE; //      readNode() return readNode(stream, options); }</span></span></code> </pre><br>  Na segunda sobrecarga, implementamos o algoritmo de gera√ß√£o de objetos para OSG <br><br><pre> <code class="cpp hljs">osgDB::ReaderWriter::ReadResult ReaderWriterPMD::readNode( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream &amp;stream, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> osgDB::Options *options) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) options; <span class="hljs-comment"><span class="hljs-comment">//   *.pmd       pmd_mesh_t mesh = parsePMD(stream); //    osg::ref_ptr&lt;osg::Geometry&gt; geom = new osg::Geometry; //    geom-&gt;setVertexArray(mesh.vertices.get()); //    for (size_t i = 0; i &lt; mesh.faces.size(); ++i) { //    GL_POLYGON      (  - 0) osg::ref_ptr&lt;osg::DrawElementsUInt&gt; polygon = new osg::DrawElementsUInt(osg::PrimitiveSet::POLYGON, 0); //       for (size_t j = 0; j &lt; mesh.faces[i].indices.size(); ++j) polygon-&gt;push_back(mesh.faces[i].indices[j]); //     geom-&gt;addPrimitiveSet(polygon.get()); } //    geom-&gt;setNormalArray(mesh.normals.get()); //  OpenGL,       geom-&gt;setNormalBinding(osg::Geometry::BIND_PER_PRIMITIVE_SET); //             osg::ref_ptr&lt;osg::Geode&gt; geode = new osg::Geode; geode-&gt;addDrawable(geom.get()); //     return geode.release(); }</span></span></code> </pre><br>  No final do arquivo main.cpp, chame a macro REGISTER_OSGPLUGIN (). <br><br><pre> <code class="cpp hljs">REGISTER_OSGPLUGIN( pmd, ReaderWriterPMD )</code> </pre><br>  Essa macro gera c√≥digo adicional que permite ao OSG, na forma da biblioteca osgDB, construir um objeto do tipo ReaderWriterPMD e chamar seus m√©todos para carregar arquivos do tipo pmd.  Assim, a estrutura do plugin est√° pronta, o que resta √© pequeno - para implementar o carregamento e a an√°lise do arquivo pmd. <br><br><h1>  7. Arquivo de modelo 3D Parsim </h1><br>  Agora toda a funcionalidade do plugin se baseia na implementa√ß√£o do m√©todo parsePMD () <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pmd_mesh_t</span></span> ReaderWriterPMD::parsePMD(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream &amp;stream) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">pmd_mesh_t</span></span> mesh; <span class="hljs-comment"><span class="hljs-comment">//    while (!stream.eof()) { //      std::string line; std::getline(stream, line); //     -     std::vector&lt;std::string&gt; tokens = parseLine(line); //    -  if (tokens[0] == "vertex") { //       osg::Vec3 point; std::istringstream iss(tokens[1]); iss &gt;&gt; point.x() &gt;&gt; point.y() &gt;&gt; point.z(); //      mesh.vertices-&gt;push_back(point); } //    -  if (tokens[0] == "face") { //         unsigned int idx = 0; std::istringstream iss(tokens[1]); face_t face; while (!iss.eof()) { iss &gt;&gt; idx; face.indices.push_back(idx); } //      mesh.faces.push_back(face); //     mesh.normals-&gt;push_back(mesh.calcFaceNormal(face)); } } return mesh; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O m√©todo ParseLine () analisa a linha do arquivo pmd </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; ReaderWriterPMD::parseLine(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;line) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; tokens; <span class="hljs-comment"><span class="hljs-comment">//   ,        ( Windows) std::string tmp = delete_symbol(line, '\r'); size_t pos = 0; std::string token; //      ,     : //      while ( (pos = tmp.find(':')) != std::string::npos ) { //     (vertex  face   ) token = tmp.substr(0, pos); //         tmp.erase(0, pos + 1); if (!token.empty()) tokens.push_back(token); } //        tokens.push_back(tmp); return tokens; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este m√©todo transformar√° a cadeia "v√©rtice: 1,0 -1,0 0,0" em uma lista das duas linhas "v√©rtice" e "1,0 -1,0 0,0". </font><font style="vertical-align: inherit;">Na primeira linha, identificamos o tipo de dados - o v√©rtice ou a face, a partir da segunda extra√≠mos os dados nas coordenadas do v√©rtice. </font><font style="vertical-align: inherit;">Para garantir a opera√ß√£o desse m√©todo, precisamos da fun√ß√£o auxiliar delete_symbol (), que remove o caractere fornecido da string e retorna uma string que n√£o cont√©m esse caractere</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete_symbol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;str, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> symbol)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> tmp = str; tmp.erase(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::remove(tmp.begin(), tmp.end(), symbol), tmp.end()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tmp; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ou seja, agora implementamos todas as funcionalidades do nosso plugin e podemos test√°-lo. </font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8. Testando o Plug-in </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compilamos o plug-in e executamos a depura√ß√£o (F5). </font><font style="vertical-align: inherit;">Ser√° lan√ßada uma vers√£o de depura√ß√£o do visualizador osgviewerd padr√£o, que analisar√° o arquivo piramide.pmd passado para ele, carregue nosso plug-in e chame seu m√©todo readNode (). </font><font style="vertical-align: inherit;">Se fizermos tudo certo, obteremos esse resultado: </font></font><br><br><img src="https://habrastorage.org/webt/s3/5g/-y/s35g-ykmmlet5z8jisj7efkz7je.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a lista de v√©rtices e faces em nosso arquivo inventado do modelo 3D escondeu uma pir√¢mide quadrangular. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que n√≥s mesmos calculamos as normais? </font><font style="vertical-align: inherit;">Em uma das li√ß√µes, nos foi oferecido o seguinte m√©todo de c√°lculo autom√°tico de normais suavizadas</font></font><br><br><pre> <code class="cpp hljs">osgUtil::SmoothingVisitor::smooth(*geom);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aplicamos essa fun√ß√£o em nosso exemplo, em vez de atribuir nossos pr√≥prios normais </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//geom-&gt;setNormalArray(mesh.normals.get()); //geom-&gt;setNormalBinding(osg::Geometry::BIND_PER_PRIMITIVE_SET); osgUtil::SmoothingVisitor::smooth(*geom);</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e obtemos o seguinte resultado: As </font></font><br><br><img src="https://habrastorage.org/webt/eb/gd/kt/ebgdktxsplxyqatprxunnwd8r2o.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">normais afetam o c√°lculo da ilumina√ß√£o do modelo e vemos que, nessa situa√ß√£o, as normais suavizadas levam a resultados incorretos do c√°lculo da ilumina√ß√£o da pir√¢mide. </font><font style="vertical-align: inherit;">√â por esse motivo que aplicamos nossa bicicleta no c√°lculo das normais. </font><font style="vertical-align: inherit;">Mas acho que explicar as nuances disso est√° al√©m do escopo desta li√ß√£o.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt438296/">https://habr.com/ru/post/pt438296/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt438286/index.html">Trabalhando com fusos hor√°rios em JavaScript</a></li>
<li><a href="../pt438288/index.html">Prote√ß√£o sem medo. Seguran√ßa de mem√≥ria em ferrugem</a></li>
<li><a href="../pt438290/index.html">Post-mortem com GGJ-2019: como obter solavancos, mas ainda assim fazer o jogo</a></li>
<li><a href="../pt438292/index.html">Automa√ß√£o de apartamentos com HomePod, Raspberry Pi e Node.js</a></li>
<li><a href="../pt438294/index.html">Localizando Twitch Streamers em uma partida do PUBG</a></li>
<li><a href="../pt438298/index.html">Por que ensinar se o desenvolvimento √© mais rent√°vel? Conversa com GeekBrains</a></li>
<li><a href="../pt438302/index.html">A incr√≠vel criatividade da evolu√ß√£o digital</a></li>
<li><a href="../pt438304/index.html">Subcontrata√ß√£o? Legal, voc√™ bate</a></li>
<li><a href="../pt438306/index.html">Radia√ß√£o: Laborat√≥rio radioqu√≠mico durante a semana</a></li>
<li><a href="../pt438310/index.html">Instagram usa aprendizado de m√°quina para remover seguidores falsos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>