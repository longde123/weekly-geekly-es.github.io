<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≤üèº üë©üèº‚Äçü§ù‚Äçüë®üèø ‚úåÔ∏è Memoization Vergissmeinnicht ü•É üìá üëßüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hast du schon von memoization ? Es ist √ºbrigens eine super einfache Sache - merken Sie sich einfach, welches Ergebnis Sie von einem ersten Funktionsau...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memoization Vergissmeinnicht</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446390/"><p><img src="https://habrastorage.org/webt/ym/ok/d7/ymokd7njz99ry_9knpxx9iaz1ja.jpeg"></p><br><p> Hast du schon von <code>memoization</code> ?  Es ist √ºbrigens eine super einfache Sache - merken Sie sich einfach, welches Ergebnis Sie von einem ersten Funktionsaufruf erhalten haben, und verwenden Sie es, anstatt es das zweite Mal aufzurufen - rufen Sie keine echten Dinge ohne Grund auf, verschwenden Sie keine Zeit . </p><br><p>  Das √úberspringen einiger intensiver Operationen ist eine sehr verbreitete Optimierungstechnik.  Jedes Mal, wenn Sie etwas nicht tun - tun Sie es nicht.  Versuchen Sie, den Cache zu verwenden - <code>memcache</code> , <code>file cache</code> , <code>local cache</code> - jeden Cache!  Ein Muss f√ºr Backend-Systeme und ein wesentlicher Bestandteil jedes Backend-Systems von Vergangenheit und Gegenwart. </p><a name="habracut"></a><br><p><img src="https://habrastorage.org/webt/j8/4x/u4/j84xu4vrhrsgqu6fc5qdbahwhig.jpeg"></p><br><h1 id="memoization-vscaching">  Memoization vs Caching </h1><br><blockquote>  Das Auswendiglernen ist wie das Zwischenspeichern.  Nur ein bisschen anders.  Kein Cache, nennen wir es Kashe. </blockquote><p>  Lange Rede, kurzer Sinn, aber das Auswendiglernen ist kein Cache, kein dauerhafter Cache.  Es kann auf einer Serverseite sein, kann es aber nicht und sollte kein Cache auf einer Clientseite sein.  Es geht mehr um verf√ºgbare Ressourcen, Nutzungsmuster und die Gr√ºnde f√ºr die Verwendung. </p><br><h2 id="problem-cache-need-a-cachekey">  Problem - Cache ben√∂tigt einen "Cache-Schl√ºssel" </h2><br><p>  Der Cache speichert und ruft Daten mithilfe eines <strong>String-</strong> Cache- <code>key</code> .  Es ist bereits ein Problem, einen eindeutigen und verwendbaren Schl√ºssel zu erstellen, aber dann m√ºssen Sie Daten serialisieren und de-serialisieren, um sie erneut auf einem stringbasierten Medium zu speichern ... kurz gesagt - der Cache ist m√∂glicherweise nicht so schnell, wie Sie vielleicht denken.  Besonders verteilter Cache. </p><br><h2 id="memoization-does-not-need-any-cachekey">  Memoization ben√∂tigt keinen Cache-Schl√ºssel </h2><br><p>  Gleichzeitig wird kein Schl√ºssel zum Auswendiglernen ben√∂tigt.  <em>Normalerweise *</em> verwendet es Argumente wie sie sind, versucht nicht, einen einzelnen Schl√ºssel daraus zu erstellen, und verwendet kein global verf√ºgbares freigegebenes Objekt zum Speichern von Ergebnissen, wie dies normalerweise im Cache der Fall ist. </p><br><blockquote>  Der Unterschied zwischen Memoization und Cache liegt in <strong>API INTERFACE</strong> ! </blockquote><p>  <em>Normalerweise bedeutet *</em> nicht immer.  <a href="">Lodash.memoize verwendet</a> standardm√§√üig <code>JSON.stringify</code> , um √ºbergebene Argumente in einen String-Cache zu konvertieren (gibt es eine andere M√∂glichkeit? Nein!).  Nur weil sie diesen Schl√ºssel verwenden, um auf ein internes Objekt zuzugreifen, das einen zwischengespeicherten Wert enth√§lt.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fast-Memoize</a> , "die schnellstm√∂gliche Memo-Bibliothek", macht dasselbe.  Beide benannten Bibliotheken sind keine Memoization-Bibliotheken, sondern Cache-Bibliotheken. </p><br><blockquote>  Es ist erw√§hnenswert, dass JSON.stringify m√∂glicherweise zehnmal langsamer ist als eine Funktion. </blockquote><p>  Offensichtlich besteht die einfache L√∂sung f√ºr das Problem darin, KEINEN Cache-Schl√ºssel zu verwenden und NICHT mit diesem Schl√ºssel auf einen internen Cache zuzugreifen.  Denken Sie also an die letzten Argumente, mit denen Sie aufgerufen wurden.  Wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">memoizerific</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">reselect</a> tun. </p><br><blockquote>  Memoizerific ist wahrscheinlich die einzige allgemeine Caching-Bibliothek, die Sie verwenden m√∂chten. </blockquote><br><h1 id="the-cachesize">  Die Cache-Gr√∂√üe </h1><br><p>  Der zweite gro√üe Unterschied zwischen allen Bibliotheken besteht in der Cache-Gr√∂√üe und der Cache-Struktur. </p><br><p>  Haben Sie jemals dar√ºber nachgedacht - warum erneut <code>reselect</code> oder <code>memoize-one</code> enth√§lt nur ein letztes Ergebnis?  Nicht <em>"nicht den Cache-Schl√ºssel verwenden, um mehr als ein Ergebnis speichern zu k√∂nnen"</em> , sondern weil es <strong>keinen Grund gibt, mehr als nur ein letztes Ergebnis zu speichern</strong> . </p><br><p>  ... Es geht mehr um: </p><br><ul><li>  verf√ºgbare Ressourcen - Eine einzelne Cache-Zeile ist sehr ressourcenschonend </li><li>  Nutzungsmuster - sich an etwas "an Ort und Stelle" zu erinnern, ist ein gutes Muster.  "An Ort und Stelle" ben√∂tigen Sie normalerweise nur ein letztes Ergebnis. </li><li>  Der Grund f√ºr die Verwendung von Modularit√§t, Isolation und Speichersicherheit sind gute Gr√ºnde.  Wenn Sie den Cache nicht mit dem Rest Ihrer Anwendung teilen, ist dies in Bezug auf Cache-Kollisionen nur sicherer. </li></ul><br><h1 id="a-singleresult">  Ein einziges Ergebnis ?! </h1><br><p>  Ja - das einzige Ergebnis.  Mit einem Ergebnis, das einige <strong>klassische Dinge</strong> auswendig gelernt hat, wie die Erzeugung von auswendig gelernten Fibonacci-Zahlen (die <em>Sie m√∂glicherweise in jedem Artikel √ºber das</em> Auswendiglernen <em>als Beispiel finden</em> ), w√§re dies <strong>nicht m√∂glich</strong> .  Aber normalerweise machen Sie etwas anderes - wer braucht einen Fibonacci am Frontend?  Im Backend?  Beispiele aus der <em>Praxis</em> sind weit entfernt von abstrakten <em>IT-Tests</em> . </p><br><p>  Dennoch gibt es zwei <strong>GROSSE</strong> Probleme bei einer einwertigen Memoisierungsart. </p><br><h2 id="problem-1-its-fragile">  Problem 1 - es ist "zerbrechlich" </h2><br><p>  Standardm√§√üig sollten alle Argumente √ºbereinstimmen, genau das "===" sein.  Wenn ein Argument nicht √ºbereinstimmt, ist das Spiel beendet.  Auch wenn dies von der Idee des Auswendiglernen herr√ºhrt - das ist heutzutage vielleicht nicht mehr das, was Sie wollen.  Ich meine - Sie m√∂chten so viel wie m√∂glich und so oft wie m√∂glich auswendig lernen. </p><br><blockquote>  Sogar ein Cache-Miss ist ein Cache-L√∂sch-Headshot. </blockquote><p>  Es gibt einen kleinen Unterschied zwischen "heutzutage" und "gestern" - unver√§nderlichen Datenstrukturen, die beispielsweise in Redux verwendet werden. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getSomeDataFromState = memoize(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function"> =&gt;</span></span> compute(state.tasks));</code> </pre> <br><p>  Sieht gut aus?  Siehst du richtig aus?  Der Status kann sich jedoch √§ndern, wenn Aufgaben nicht ausgef√ºhrt wurden und Sie nur √ºbereinstimmende Aufgaben ben√∂tigen. </p><br><p>  <strong>Strukturelle Selektoren</strong> sind hier, um den Tag mit ihrem st√§rksten Krieger - <strong>Reselect</strong> - zu retten.  Reselect ist nicht nur eine Memoisierungsbibliothek, sondern die Leistung kommt auch von Memoisierungskaskaden oder Objektiven (was sie nicht sind, aber Selektoren als optische Objektive betrachten). </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// every time `state` changes, cached value would be rejected const getTasksFromState = createSelector(state =&gt; state.tasks); const getSomeDataFromState = createSelector( // `tasks` "without" `state` getTasksFromState, // &lt;---------- // and this operation would be memoized "more often" tasks =&gt; compute(state.tasks) );</span></span></code> </pre> <br><p>  Infolgedessen m√ºssen Sie bei unver√§nderlichen Daten immer zuerst auf das Datenelement <strong>"fokussieren",</strong> das Sie wirklich ben√∂tigen, und dann Berechnungen durchf√ºhren, da sonst der Cache abgelehnt wird und alle Ideen hinter dem Auswendiglernen verschwinden. </p><br><p>  Dies ist tats√§chlich ein gro√ües Problem, insbesondere f√ºr Neulinge, aber es hat als Idee hinter unver√§nderlichen Datenstrukturen einen erheblichen Vorteil - <strong>wenn etwas nicht ge√§ndert wird, wird es nicht ge√§ndert.</strong>  <strong>Wenn etwas ge√§ndert wird, wird es wahrscheinlich ge√§ndert</strong> .  Das gibt uns einen superschnellen Vergleich, aber mit einigen falschen Negativen, wie im ersten Beispiel. </p><br><blockquote>  Bei der Idee geht es darum, sich auf die Daten zu "konzentrieren", von denen Sie abh√§ngig sind </blockquote><p>  Es gibt zwei Momente, die ich h√§tte erw√§hnen sollen: </p><br><ul><li>  <code>lodash.memoize</code> und <code>fast-memoize</code> konvertieren Ihre Daten in eine Zeichenfolge, die als Schl√ºssel verwendet werden soll.  Das bedeutet, dass sie 1) nicht schnell sind 2) nicht sicher sind 3) falsch positive Ergebnisse erzeugen k√∂nnen - einige <strong>unterschiedliche Daten</strong> k√∂nnen <strong>dieselbe Zeichenfolgendarstellung haben</strong> .  Dies k√∂nnte die "Cache-Hot-Rate" verbessern, ist aber tats√§chlich eine SEHR SCHLECHTE Sache. </li><li>  Es gibt einen ES6-Proxy-Ansatz, bei dem alle verwendeten Variablen verfolgt und nur wichtige Schl√ºssel √ºberpr√ºft werden.  Ich pers√∂nlich m√∂chte zwar unz√§hlige Daten-Selektoren erstellen - Sie m√∂gen den Prozess m√∂glicherweise nicht oder verstehen ihn nicht, m√∂chten aber m√∂glicherweise sofort eine ordnungsgem√§√üe Memoisierung - und verwenden dann den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Memoize-Status</a> . </li></ul><br><h2 id="problem-2--its-one-cacheline">  Problem 2: Es ist "eine Cache-Zeile". </h2><br><p>  Unendliche Cache-Gr√∂√üe ist ein Killer.  Jeder unkontrollierte Cache ist ein Killer, solange der Speicher ziemlich begrenzt ist.  Also - alle besten Bibliotheken sind "One-Cache-Line-Long".  Das ist ein Merkmal und eine starke Designentscheidung.  Ich habe gerade geschrieben, wie richtig es ist, und glauben Sie mir - es ist <strong>wirklich richtig</strong> , aber es ist immer noch ein Problem.  Ein gro√ües Problem. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tasks = getTasks(state); <span class="hljs-comment"><span class="hljs-comment">// let's get some data from state1 (function was defined above) getDataFromTask(tasks[0]); // Yep! equal(getDataFromTask(tasks[0]), getDataFromTask(tasks[0])) // Ok! getDataFromTask(tasks[1]); // a different task? What the heck? // oh! That's another argument? How dare you!? // TLDR -&gt; task[0] in the cache got replaced by task[1] you cannot use getDataFromTask to get data from different tasks</span></span></code> </pre> <br><p>  Sobald derselbe Selektor mit verschiedenen Quelldaten arbeiten muss, mit mehr als einem - ist alles kaputt.  Und es ist leicht, auf das Problem zu sto√üen: </p><br><ul><li>  Solange wir Selektoren verwenden, um Aufgaben aus einem Status abzurufen, k√∂nnen wir dieselben Selektoren verwenden, um etwas aus einer Aufgabe abzurufen.  Intensiv kommt von der API selbst.  Aber es funktioniert nicht, dann k√∂nnen Sie sich nur den letzten Anruf merken, m√ºssen aber mit mehreren Datenquellen arbeiten. </li><li>  Das gleiche Problem besteht bei mehreren Reaktionskomponenten - sie sind alle gleich und alle etwas unterschiedlich, rufen unterschiedliche Aufgaben ab und l√∂schen die Ergebnisse voneinander. </li></ul><br><p>  Es gibt 3 m√∂gliche L√∂sungen: </p><br><ul><li>  Im Falle von Redux verwenden Sie die mapStateToProps-Factory.  Es w√ºrde eine Memoisierung pro Instanz erstellen. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mapStateToProps = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> selector = createSelector(...); <span class="hljs-comment"><span class="hljs-comment">// ^ you have to define per-instance selectors here // usually that's not possible :) return state =&gt; ({ data: selector(data), // a usual mapStateToProps }); }</span></span></code> </pre> </li><li>  Die zweite Variante ist fast dieselbe (und auch f√ºr Redux) - es geht um die Verwendung der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erneuten Auswahl</a> .  Es ist eine komplexe Bibliothek, die durch die Unterscheidung von Komponenten den Tag retten k√∂nnte.  Es konnte nur verstehen, dass der neue Aufruf f√ºr "eine andere" Komponente erfolgte und der Cache f√ºr die "vorherige" Komponente beibehalten wurde. </li></ul><br><p><img src="https://habrastorage.org/webt/rd/mz/gq/rdmzgqgrj_mjin5jjmsalnxmljm.png"></p><br><p>  Diese Bibliothek w√ºrde Ihnen helfen, den Memo-Cache zu "behalten", aber nicht zu l√∂schen.  Vor allem, weil es 5 (F√úNF!) Verschiedene Cache-Strategien implementiert, die auf jeden Fall passen.  Das ist ein schlechter Geruch.  Was ist, wenn Sie die falsche w√§hlen? <br>  Alle Daten, die Sie gespeichert haben - Sie m√ºssen sie fr√ºher oder sp√§ter vergessen.  Es geht nicht darum, sich an den letzten Funktionsaufruf zu erinnern - es geht darum, ihn zum richtigen Zeitpunkt zu VERGESSEN.  Nicht zu fr√ºh und das Auswendiglernen ruinieren und nicht zu sp√§t. </p><br><blockquote>  Hast du die Idee?  Jetzt vergiss es!  Und wo ist die 3. Variante? </blockquote><br><h1 id="let-take-apause">  Lass uns eine Pause machen </h1><br><p>  H√∂r auf  Entspannen Sie sich  Atme tief ein.  Und beantworten Sie eine einfache Frage: Was ist das Ziel?  Was m√ºssen wir tun, um das Ziel zu erreichen?  Was w√ºrde den Tag retten? </p><br><blockquote>  TIPP: Wo befindet sich dieser verdammte "Cache"? </blockquote><p><img src="https://habrastorage.org/webt/7m/r1/iz/7mr1izrzb89femvq5h-suxxkfnm.jpeg"></p><br><p>  Wo befindet sich dieser "Cache"?  Ja - das ist die richtige Frage.  Danke, dass du es gefragt hast.  Und die Antwort ist einfach - sie befindet sich in einem Verschluss.  An einer versteckten Stelle in * einer gespeicherten Funktion.  Zum Beispiel - hier ist <code>memoize-one</code> Code: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lastArgs; <span class="hljs-comment"><span class="hljs-comment">// the last arguments let lastResult;// the last result &lt;--- THIS IS THE CACHE // the memoized function const memoizedCall = function(...newArgs) { if (isEqual(newArgs, lastArgs)) { return lastResult; } lastResult = resultFn.apply(this, newArgs); lastArgs = newArgs; return lastResult; }; return memoizedCall; }</span></span></code> </pre> <br><p>  Sie erhalten einen <code>memoizedCall</code> , in dem das letzte Ergebnis in der N√§he des lokalen Verschlusses gespeichert ist, auf den nur memoizedCall zugreifen kann.  Ein sicherer Ort.  "das" ist ein sicherer Ort. </p><br><p>  <code>Reselect</code> macht dasselbe und die einzige M√∂glichkeit, einen "Fork" mit einem anderen Cache zu erstellen - erstellen Sie einen neuen Memoization-Abschluss. </p><br><p>  Aber die (andere) Hauptfrage - wann w√§re es (weg) "weg"? </p><br><blockquote>  TLDR: Es w√§re mit einer Funktion "weg", wenn die Funktionsinstanz von Garbage Collector gegessen w√ºrde. </blockquote><p>  Instanz?  Instanz!  Also - was ist mit Memoisierung pro Instanz?  Es gibt einen ganzen Artikel dar√ºber in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">React-Dokumentation</a> </p><br><p>  Kurz gesagt - wenn Sie klassenbasierte Reaktionskomponenten verwenden, k√∂nnen Sie Folgendes tun: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> memoize <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"memoize-one"</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Example</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ filter = memoize( <span class="hljs-comment"><span class="hljs-comment">// &lt;-- bound to the instance (list, filterText) =&gt; list.filter(...); // ^ that is "per instance" memoization // we are creating "own" memoization function // with the "own" lastResult render() { // Calculate the latest filtered list. // If these arguments haven't changed since the last render, // `memoize-one` will reuse the last return value. const filteredList = this.filter(something, somehow); return &lt;ul&gt;{filteredList.map(item =&gt; ...}&lt;/ul&gt; } }</span></span></code> </pre> <br><p>  Also - wo ist <strong>"lastResult"</strong> gespeichert?  Innerhalb eines lokalen Bereichs von gespeicherten <strong>Filtern</strong> innerhalb dieser Klasseninstanz.  Und wann w√§re es "weg"? </p><br><p>  Diesmal w√§re es mit einer Klasseninstanz "weg".  Sobald die Komponente abmontiert wurde, ist sie spurlos verschwunden.  Es ist eine echte "pro Instanz", und Sie k√∂nnen <code>this.lastResult</code> , um ein zeitliches Ergebnis mit genau dem gleichen "Memoization" -Effekt zu <code>this.lastResult</code> . </p><br><h2 id="whats-about-reacthooks">  Was ist mit React.Hooks? </h2><br><p>  Wir kommen n√§her.  Redux-Hooks haben einige verd√§chtige Befehle, bei denen es wahrscheinlich um das Auswendiglernen geht.  Like - <code>useMemo</code> , <code>useCallback</code> , <code>useRef</code> </p><br><p><img src="https://habrastorage.org/webt/wx/2k/kf/wx2kkfpti6kecbdj4zoohpslkqk.png"></p><br><blockquote>  Aber die Frage - WO speichert es diesmal einen gespeicherten Wert? </blockquote><p>  Kurz gesagt - es speichert es in "Hooks" in einem speziellen Teil eines VDOM-Elements, das als Faser bekannt ist und einem aktuellen Element zugeordnet ist.  Innerhalb einer parallelen Datenstruktur. </p><br><p>  Nicht so kurze Hooks ver√§ndern die Funktionsweise Ihres Programms und verschieben Ihre Funktion in eine andere. Einige Variablen befinden sich an einer <em>versteckten Stelle in einem √ºbergeordneten Abschluss</em> .  Solche Funktionen sind als <em>suspendierbare</em> oder <em>wiederaufnehmbare</em> Funktionen bekannt - Coroutinen.  In JavaScript werden sie normalerweise als <code>generators</code> oder <code>async functions</code> . </p><br><p>  Aber das ist ein bisschen extrem.  In k√ºrzester Zeit speichert useMemo darin gespeicherte Werte.  Es ist nur ein bisschen anders "dies". </p><br><blockquote>  Wenn wir eine bessere Memo-Bibliothek erstellen wollen, sollten wir ein besseres "dies" finden. </blockquote><p>  Zing! </p><br><h1 id="weakmaps">  WeakMaps! </h1><br><p>  Ja!  WeakMaps!  Zum Speichern des Schl√ºsselwerts, wo der Schl√ºssel dies w√§re, solange WeakMap nichts anderes als dies akzeptiert, dh "Objekte". </p><br><p>  Lassen Sie uns ein einfaches Beispiel erstellen: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> createHiddenSpot = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> map = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">WeakMap</span></span>(); <span class="hljs-comment"><span class="hljs-comment">// a hidden "closure" const set = (key, value) =&gt; (map.set(key, value), value); return (key) =&gt; { return map.get(key) || set(key, fn(key)) } } const weakSelect = createHiddenSpot(selector); weakSelect(todos); // create a new entry weakSelect(todos); // return an existing entry weakSelect(todos[0]); // create a new entry weakSelect(todos[1]); // create a new entry weakSelect(todos[0]); // return an existing entry! weakSelect(todos[1]); // return an existing entry!! weakSelect(todos); // return an existing entry!!!</span></span></code> </pre> <br><p>  Es ist dumm einfach und ganz "richtig".  Also "wann w√§re es weg"? </p><br><ul><li>  Vergiss schwache Auswahl und eine ganze "Karte" w√§re weg </li><li>  Vergiss todos [0] und ihr schwacher Eintrag w√§re weg </li><li>  vergiss todos - und gespeicherte Daten w√§ren weg! </li></ul><br><blockquote>  Es ist klar, wann etwas "weg" sein w√ºrde - nur wenn es sollte! </blockquote><p>  Magisch - alle Probleme bei der erneuten Auswahl sind verschwunden.  Probleme mit aggressiven Memoisierung - auch ein Goner. </p><br><p>  Dieser Ansatz <strong>Erinnern Sie sich an</strong> die Daten, bis es Zeit ist, zu <strong>vergessen</strong> .  Es ist unglaublich, aber um sich besser an etwas zu erinnern, muss man es besser vergessen k√∂nnen. </p><br><p>  Das einzige, was dauert, ist, eine robustere API f√ºr diesen Fall zu erstellen </p><br><h1 id="kashe-is-acache">  Kashe - ist ein Cache </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kashe</a> ist eine WeakMap-basierte Memoization-Bibliothek, die Ihren Tag retten k√∂nnte. </p><br><p>  Diese Bibliothek bietet 4 Funktionen </p><br><ul><li>  <code>kashe</code> - zum <code>kashe</code> . </li><li>  <code>box</code> - f√ºr die vorangestellte Memoisierung, um <em>die</em> Wahrscheinlichkeit der Memoisierung zu <em>erh√∂hen</em> . </li><li>  <code>inbox</code> - verschachtelte vorangestellte Memoisierung, um <em>die</em> √Ñnderung der Memoisierung zu <em>verringern</em> </li><li>  <code>fork</code> - (offensichtlich) Memoisierung. </li></ul><br><h2 id="kashefn--memoizedfnargs">  kashe (fn) =&gt; memoizedFn (... args) </h2><br><p>  Es ist eigentlich ein createHiddenSpot aus einem vorherigen Beispiel.  Es wird ein erstes Argument als Schl√ºssel f√ºr eine interne WeakMap verwendet. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> selector = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state, prop</span></span></span><span class="hljs-function">) =&gt;</span></span> ({<span class="hljs-attr"><span class="hljs-attr">result</span></span>: state[prop]}); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoized = kashe(selector); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> old = memoized(state, <span class="hljs-string"><span class="hljs-string">'x'</span></span>) memoized(state, <span class="hljs-string"><span class="hljs-string">'x'</span></span>) === old memoized(state, <span class="hljs-string"><span class="hljs-string">'y'</span></span>) === memoized(state, <span class="hljs-string"><span class="hljs-string">'y'</span></span>) <span class="hljs-comment"><span class="hljs-comment">// ^^ another argument // but old !== memoized(state, 'x') // 'y' wiped 'x' cache in `state`</span></span></code> </pre> <br><p>  Das erste Argument ist ein Schl√ºssel. Wenn Sie die Funktion erneut mit demselben Schl√ºssel aufgerufen haben, aber unterschiedliche Argumente - der Cache w√ºrde ersetzt, ist es immer noch eine Cachezeile lange Memoisierung.  Damit es funktioniert, m√ºssen Sie verschiedene Schl√ºssel f√ºr verschiedene F√§lle bereitstellen, wie ich es bei einem Beispiel f√ºr eine schwache Auswahl getan habe, um unterschiedliche Ergebnisse bereitzustellen, um die Ergebnisse zu speichern.  Kaskaden erneut ausw√§hlen A ist immer noch das Richtige. <br>  Nicht alle Funktionen sind kashe-memoizable.  Das erste Argument <em>muss</em> ein Objekt, ein Array oder eine Funktion sein.  Es sollte als Schl√ºssel f√ºr WeakMap verwendet werden k√∂nnen. </p><br><h2 id="boxfn--memoizedfn2boxargs">  box (fn) =&gt; memoizedFn2 (box, ... args) </h2><br><p>  Dies ist dieselbe Funktion, die nur zweimal angewendet wird.  Einmal f√ºr fn, einmal f√ºr memoizedFn, wobei den Argumenten ein f√ºhrender Schl√ºssel hinzugef√ºgt wird.  Es k√∂nnte jede Funktion kashe-memoizable machen. </p><br><blockquote>  Es ist ziemlich deklarativ - hey Funktion!  Ich werde die Ergebnisse in dieser Box speichern. </blockquote><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// could not be "kashe" memoized const addTwo = (a,b) =&gt; ({ result: a+b }); const bAddTwo = boxed(addTwo); const cacheKey = {}; // any object bAddTwo(cacheKey, 1, 2) === bAddTwo(cacheKey, 1, 2) === { result: 3}</span></span></code> </pre> <br><p>  Wenn Sie die bereits gespeicherte Funktion aktivieren - Sie erh√∂hen die Memoisierungschance, wie z. B. die Memoisierung pro Instanz -, k√∂nnen Sie eine Memoisierungskaskade erstellen. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> selectSomethingFromTodo = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state, prop</span></span></span><span class="hljs-function">) =&gt;</span></span> ... const selector = kashe(selectSomethingFromTodo); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> boxedSelector = kashe(selector); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render () { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = boxedSelector(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, todos, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.todoId); <span class="hljs-comment"><span class="hljs-comment">// 1. try to find result in `this` // 2. try to find result in `todos` // 3. store in `todos` // 4. store in `this` // if multiple `this`(components) are reading from `todos` - // selector is not working (they are wiping each other) // but data stored in `this` - exists. ... } }</span></span></code> </pre> <br><h2 id="inboxfn--memoizedfn2boxargs">  Posteingang (fn) =&gt; memoizedFn2 (box, ... args) </h2><br><p>  Dieser ist der Box entgegengesetzt, macht aber fast dasselbe und befiehlt dem verschachtelten Cache, Daten in der bereitgestellten Box zu speichern.  Unter einem Gesichtspunkt - es verringert die Memoisierungswahrscheinlichkeit (es gibt keine Memoisierungskaskade), aber unter einem anderen Gesichtspunkt - werden die Cache-Kollisionen entfernt und Prozesse isoliert, wenn sie sich aus irgendeinem Grund nicht gegenseitig st√∂ren sollten. </p><br><blockquote>  Es ist ziemlich deklarativ - hey!  Alle drinnen!  Hier ist eine Box zur Verwendung </blockquote><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getAndSet = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">task, number</span></span></span><span class="hljs-function">) =&gt;</span></span> task.value + number; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoized = kashe(getAndSet); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> inboxed = inbox(getAndSet); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doubleBoxed = inbox(memoized); memoized(task, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// ok memoized(task, 2) // previous result wiped inboxed(key1, task, 1) // ok inboxed(key2, task, 2) // ok // inbox also override the cache for any underlaying kashe calls doubleBoxed(key1, task, 1) // ok doubleBoxed(key2, task, 2) // ok</span></span></code> </pre> <br><h2 id="forkkashe-memoized--kashe-memoized">  Gabel (kashe-memoized) =&gt; kashe-memoized </h2><br><p>  Fork ist eine echte Fork - sie erh√§lt jede kashe-gespeicherte Funktion und gibt dieselbe zur√ºck, jedoch mit einem anderen internen Cache-Eintrag.  Erinnern Sie sich an die Factory-Methode von redux mapStateToProps? </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mapStateToProps = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// const selector = createSelector(...); // const selector = fork(realSelector); // just fork existing selector. Or box it, or don't do anything // kashe is more "stable" than reselect. return state =&gt; ({ data: selector(data), }); }</span></span></code> </pre> <br><h2 id="reselect">  Neu ausw√§hlen </h2><br><p>  Und noch etwas sollten Sie wissen - Kashe k√∂nnte Reselect ersetzen.  Im wahrsten Sinne des Wortes. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { createSelector } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'kashe/reselect'</span></span>;</code> </pre> <br><p>  Es ist eigentlich die gleiche Neuauswahl, die nur mit Kashe als Memo-Funktion erstellt wurde. </p><br><h1 id="codesandbox">  Codesandbox </h1><br><p>  Hier ist ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kleines Beispiel</a> zum Spielen.  Sie k√∂nnen auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tests √ºberpr√ºfen</a> - sie sind kompakt und solide. <br>  Wenn Sie mehr √ºber Caching und Memoisierung erfahren m√∂chten, lesen Sie, wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ich vor</a> einem Jahr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die schnellste Memoisierungsbibliothek geschrieben</a> habe. </p><br><blockquote>  PS: Es ist erw√§hnenswert, dass die einfachere Version dieses Ansatzes - schwaches Auswendiglernen - f√ºr eine Weile in Emotionen verwendet wird.  Keine Beschwerden.  nano-memoize verwendet WeakMaps auch f√ºr einen einzelnen Argumentationsfall. </blockquote><p>  Verstanden?  Ein "schw√§cher" Ansatz w√ºrde Ihnen helfen, sich besser an etwas zu erinnern und es besser zu vergessen. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/theKashey/kashe</a> </p><br><p>  Ja, um etwas zu vergessen - k√∂nnten Sie bitte hier schauen? </p><br><p><img src="https://habrastorage.org/webt/60/d6/9y/60d69ysm9v5hy9dnm1siokafjhu.jpeg"></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446390/">https://habr.com/ru/post/de446390/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446376/index.html">Wie schreibe ich die Heimatadresse richtig?</a></li>
<li><a href="../de446378/index.html">Das Problem der Umstellung auf Winter- und Sommerzeit f√ºr eine einzelne Skype-Schule</a></li>
<li><a href="../de446380/index.html">H2 Evolution - Fensterfunktionen, CTE, JSON / XML in einer eingebetteten Datenbank</a></li>
<li><a href="../de446384/index.html">Tipps zum Entwickeln sehr gro√üer Projekte in Revit</a></li>
<li><a href="../de446388/index.html">√ñl- und Gasindustrie als Beispiel f√ºr periphere Cloud-Systeme</a></li>
<li><a href="../de446394/index.html">5. Check Point Erste Schritte R80.20. Gaia & CLI</a></li>
<li><a href="../de446396/index.html">GPS-Wochenz√§hler zur√ºckgesetzt</a></li>
<li><a href="../de446400/index.html">Dmitry Dumik, Chatfuel: √úber Y Combinator, Technologie-Unternehmertum, Verhaltens√§nderung und Bewusstsein</a></li>
<li><a href="../de446402/index.html">Mehrsprachige Apps in Angular</a></li>
<li><a href="../de446404/index.html">Moderne Alternativen zu PGP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>