<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤲🏼 👩🏼‍🤝‍👨🏿 ✌️ Memoization Vergissmeinnicht 🥃 📇 👧🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hast du schon von memoization ? Es ist übrigens eine super einfache Sache - merken Sie sich einfach, welches Ergebnis Sie von einem ersten Funktionsau...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memoization Vergissmeinnicht</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446390/"><p><img src="https://habrastorage.org/webt/ym/ok/d7/ymokd7njz99ry_9knpxx9iaz1ja.jpeg"></p><br><p> Hast du schon von <code>memoization</code> ?  Es ist übrigens eine super einfache Sache - merken Sie sich einfach, welches Ergebnis Sie von einem ersten Funktionsaufruf erhalten haben, und verwenden Sie es, anstatt es das zweite Mal aufzurufen - rufen Sie keine echten Dinge ohne Grund auf, verschwenden Sie keine Zeit . </p><br><p>  Das Überspringen einiger intensiver Operationen ist eine sehr verbreitete Optimierungstechnik.  Jedes Mal, wenn Sie etwas nicht tun - tun Sie es nicht.  Versuchen Sie, den Cache zu verwenden - <code>memcache</code> , <code>file cache</code> , <code>local cache</code> - jeden Cache!  Ein Muss für Backend-Systeme und ein wesentlicher Bestandteil jedes Backend-Systems von Vergangenheit und Gegenwart. </p><a name="habracut"></a><br><p><img src="https://habrastorage.org/webt/j8/4x/u4/j84xu4vrhrsgqu6fc5qdbahwhig.jpeg"></p><br><h1 id="memoization-vscaching">  Memoization vs Caching </h1><br><blockquote>  Das Auswendiglernen ist wie das Zwischenspeichern.  Nur ein bisschen anders.  Kein Cache, nennen wir es Kashe. </blockquote><p>  Lange Rede, kurzer Sinn, aber das Auswendiglernen ist kein Cache, kein dauerhafter Cache.  Es kann auf einer Serverseite sein, kann es aber nicht und sollte kein Cache auf einer Clientseite sein.  Es geht mehr um verfügbare Ressourcen, Nutzungsmuster und die Gründe für die Verwendung. </p><br><h2 id="problem-cache-need-a-cachekey">  Problem - Cache benötigt einen "Cache-Schlüssel" </h2><br><p>  Der Cache speichert und ruft Daten mithilfe eines <strong>String-</strong> Cache- <code>key</code> .  Es ist bereits ein Problem, einen eindeutigen und verwendbaren Schlüssel zu erstellen, aber dann müssen Sie Daten serialisieren und de-serialisieren, um sie erneut auf einem stringbasierten Medium zu speichern ... kurz gesagt - der Cache ist möglicherweise nicht so schnell, wie Sie vielleicht denken.  Besonders verteilter Cache. </p><br><h2 id="memoization-does-not-need-any-cachekey">  Memoization benötigt keinen Cache-Schlüssel </h2><br><p>  Gleichzeitig wird kein Schlüssel zum Auswendiglernen benötigt.  <em>Normalerweise *</em> verwendet es Argumente wie sie sind, versucht nicht, einen einzelnen Schlüssel daraus zu erstellen, und verwendet kein global verfügbares freigegebenes Objekt zum Speichern von Ergebnissen, wie dies normalerweise im Cache der Fall ist. </p><br><blockquote>  Der Unterschied zwischen Memoization und Cache liegt in <strong>API INTERFACE</strong> ! </blockquote><p>  <em>Normalerweise bedeutet *</em> nicht immer.  <a href="">Lodash.memoize verwendet</a> standardmäßig <code>JSON.stringify</code> , um übergebene Argumente in einen String-Cache zu konvertieren (gibt es eine andere Möglichkeit? Nein!).  Nur weil sie diesen Schlüssel verwenden, um auf ein internes Objekt zuzugreifen, das einen zwischengespeicherten Wert enthält.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fast-Memoize</a> , "die schnellstmögliche Memo-Bibliothek", macht dasselbe.  Beide benannten Bibliotheken sind keine Memoization-Bibliotheken, sondern Cache-Bibliotheken. </p><br><blockquote>  Es ist erwähnenswert, dass JSON.stringify möglicherweise zehnmal langsamer ist als eine Funktion. </blockquote><p>  Offensichtlich besteht die einfache Lösung für das Problem darin, KEINEN Cache-Schlüssel zu verwenden und NICHT mit diesem Schlüssel auf einen internen Cache zuzugreifen.  Denken Sie also an die letzten Argumente, mit denen Sie aufgerufen wurden.  Wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">memoizerific</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">reselect</a> tun. </p><br><blockquote>  Memoizerific ist wahrscheinlich die einzige allgemeine Caching-Bibliothek, die Sie verwenden möchten. </blockquote><br><h1 id="the-cachesize">  Die Cache-Größe </h1><br><p>  Der zweite große Unterschied zwischen allen Bibliotheken besteht in der Cache-Größe und der Cache-Struktur. </p><br><p>  Haben Sie jemals darüber nachgedacht - warum erneut <code>reselect</code> oder <code>memoize-one</code> enthält nur ein letztes Ergebnis?  Nicht <em>"nicht den Cache-Schlüssel verwenden, um mehr als ein Ergebnis speichern zu können"</em> , sondern weil es <strong>keinen Grund gibt, mehr als nur ein letztes Ergebnis zu speichern</strong> . </p><br><p>  ... Es geht mehr um: </p><br><ul><li>  verfügbare Ressourcen - Eine einzelne Cache-Zeile ist sehr ressourcenschonend </li><li>  Nutzungsmuster - sich an etwas "an Ort und Stelle" zu erinnern, ist ein gutes Muster.  "An Ort und Stelle" benötigen Sie normalerweise nur ein letztes Ergebnis. </li><li>  Der Grund für die Verwendung von Modularität, Isolation und Speichersicherheit sind gute Gründe.  Wenn Sie den Cache nicht mit dem Rest Ihrer Anwendung teilen, ist dies in Bezug auf Cache-Kollisionen nur sicherer. </li></ul><br><h1 id="a-singleresult">  Ein einziges Ergebnis ?! </h1><br><p>  Ja - das einzige Ergebnis.  Mit einem Ergebnis, das einige <strong>klassische Dinge</strong> auswendig gelernt hat, wie die Erzeugung von auswendig gelernten Fibonacci-Zahlen (die <em>Sie möglicherweise in jedem Artikel über das</em> Auswendiglernen <em>als Beispiel finden</em> ), wäre dies <strong>nicht möglich</strong> .  Aber normalerweise machen Sie etwas anderes - wer braucht einen Fibonacci am Frontend?  Im Backend?  Beispiele aus der <em>Praxis</em> sind weit entfernt von abstrakten <em>IT-Tests</em> . </p><br><p>  Dennoch gibt es zwei <strong>GROSSE</strong> Probleme bei einer einwertigen Memoisierungsart. </p><br><h2 id="problem-1-its-fragile">  Problem 1 - es ist "zerbrechlich" </h2><br><p>  Standardmäßig sollten alle Argumente übereinstimmen, genau das "===" sein.  Wenn ein Argument nicht übereinstimmt, ist das Spiel beendet.  Auch wenn dies von der Idee des Auswendiglernen herrührt - das ist heutzutage vielleicht nicht mehr das, was Sie wollen.  Ich meine - Sie möchten so viel wie möglich und so oft wie möglich auswendig lernen. </p><br><blockquote>  Sogar ein Cache-Miss ist ein Cache-Lösch-Headshot. </blockquote><p>  Es gibt einen kleinen Unterschied zwischen "heutzutage" und "gestern" - unveränderlichen Datenstrukturen, die beispielsweise in Redux verwendet werden. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getSomeDataFromState = memoize(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function"> =&gt;</span></span> compute(state.tasks));</code> </pre> <br><p>  Sieht gut aus?  Siehst du richtig aus?  Der Status kann sich jedoch ändern, wenn Aufgaben nicht ausgeführt wurden und Sie nur übereinstimmende Aufgaben benötigen. </p><br><p>  <strong>Strukturelle Selektoren</strong> sind hier, um den Tag mit ihrem stärksten Krieger - <strong>Reselect</strong> - zu retten.  Reselect ist nicht nur eine Memoisierungsbibliothek, sondern die Leistung kommt auch von Memoisierungskaskaden oder Objektiven (was sie nicht sind, aber Selektoren als optische Objektive betrachten). </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// every time `state` changes, cached value would be rejected const getTasksFromState = createSelector(state =&gt; state.tasks); const getSomeDataFromState = createSelector( // `tasks` "without" `state` getTasksFromState, // &lt;---------- // and this operation would be memoized "more often" tasks =&gt; compute(state.tasks) );</span></span></code> </pre> <br><p>  Infolgedessen müssen Sie bei unveränderlichen Daten immer zuerst auf das Datenelement <strong>"fokussieren",</strong> das Sie wirklich benötigen, und dann Berechnungen durchführen, da sonst der Cache abgelehnt wird und alle Ideen hinter dem Auswendiglernen verschwinden. </p><br><p>  Dies ist tatsächlich ein großes Problem, insbesondere für Neulinge, aber es hat als Idee hinter unveränderlichen Datenstrukturen einen erheblichen Vorteil - <strong>wenn etwas nicht geändert wird, wird es nicht geändert.</strong>  <strong>Wenn etwas geändert wird, wird es wahrscheinlich geändert</strong> .  Das gibt uns einen superschnellen Vergleich, aber mit einigen falschen Negativen, wie im ersten Beispiel. </p><br><blockquote>  Bei der Idee geht es darum, sich auf die Daten zu "konzentrieren", von denen Sie abhängig sind </blockquote><p>  Es gibt zwei Momente, die ich hätte erwähnen sollen: </p><br><ul><li>  <code>lodash.memoize</code> und <code>fast-memoize</code> konvertieren Ihre Daten in eine Zeichenfolge, die als Schlüssel verwendet werden soll.  Das bedeutet, dass sie 1) nicht schnell sind 2) nicht sicher sind 3) falsch positive Ergebnisse erzeugen können - einige <strong>unterschiedliche Daten</strong> können <strong>dieselbe Zeichenfolgendarstellung haben</strong> .  Dies könnte die "Cache-Hot-Rate" verbessern, ist aber tatsächlich eine SEHR SCHLECHTE Sache. </li><li>  Es gibt einen ES6-Proxy-Ansatz, bei dem alle verwendeten Variablen verfolgt und nur wichtige Schlüssel überprüft werden.  Ich persönlich möchte zwar unzählige Daten-Selektoren erstellen - Sie mögen den Prozess möglicherweise nicht oder verstehen ihn nicht, möchten aber möglicherweise sofort eine ordnungsgemäße Memoisierung - und verwenden dann den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Memoize-Status</a> . </li></ul><br><h2 id="problem-2--its-one-cacheline">  Problem 2: Es ist "eine Cache-Zeile". </h2><br><p>  Unendliche Cache-Größe ist ein Killer.  Jeder unkontrollierte Cache ist ein Killer, solange der Speicher ziemlich begrenzt ist.  Also - alle besten Bibliotheken sind "One-Cache-Line-Long".  Das ist ein Merkmal und eine starke Designentscheidung.  Ich habe gerade geschrieben, wie richtig es ist, und glauben Sie mir - es ist <strong>wirklich richtig</strong> , aber es ist immer noch ein Problem.  Ein großes Problem. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tasks = getTasks(state); <span class="hljs-comment"><span class="hljs-comment">// let's get some data from state1 (function was defined above) getDataFromTask(tasks[0]); // Yep! equal(getDataFromTask(tasks[0]), getDataFromTask(tasks[0])) // Ok! getDataFromTask(tasks[1]); // a different task? What the heck? // oh! That's another argument? How dare you!? // TLDR -&gt; task[0] in the cache got replaced by task[1] you cannot use getDataFromTask to get data from different tasks</span></span></code> </pre> <br><p>  Sobald derselbe Selektor mit verschiedenen Quelldaten arbeiten muss, mit mehr als einem - ist alles kaputt.  Und es ist leicht, auf das Problem zu stoßen: </p><br><ul><li>  Solange wir Selektoren verwenden, um Aufgaben aus einem Status abzurufen, können wir dieselben Selektoren verwenden, um etwas aus einer Aufgabe abzurufen.  Intensiv kommt von der API selbst.  Aber es funktioniert nicht, dann können Sie sich nur den letzten Anruf merken, müssen aber mit mehreren Datenquellen arbeiten. </li><li>  Das gleiche Problem besteht bei mehreren Reaktionskomponenten - sie sind alle gleich und alle etwas unterschiedlich, rufen unterschiedliche Aufgaben ab und löschen die Ergebnisse voneinander. </li></ul><br><p>  Es gibt 3 mögliche Lösungen: </p><br><ul><li>  Im Falle von Redux verwenden Sie die mapStateToProps-Factory.  Es würde eine Memoisierung pro Instanz erstellen. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mapStateToProps = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> selector = createSelector(...); <span class="hljs-comment"><span class="hljs-comment">// ^ you have to define per-instance selectors here // usually that's not possible :) return state =&gt; ({ data: selector(data), // a usual mapStateToProps }); }</span></span></code> </pre> </li><li>  Die zweite Variante ist fast dieselbe (und auch für Redux) - es geht um die Verwendung der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erneuten Auswahl</a> .  Es ist eine komplexe Bibliothek, die durch die Unterscheidung von Komponenten den Tag retten könnte.  Es konnte nur verstehen, dass der neue Aufruf für "eine andere" Komponente erfolgte und der Cache für die "vorherige" Komponente beibehalten wurde. </li></ul><br><p><img src="https://habrastorage.org/webt/rd/mz/gq/rdmzgqgrj_mjin5jjmsalnxmljm.png"></p><br><p>  Diese Bibliothek würde Ihnen helfen, den Memo-Cache zu "behalten", aber nicht zu löschen.  Vor allem, weil es 5 (FÜNF!) Verschiedene Cache-Strategien implementiert, die auf jeden Fall passen.  Das ist ein schlechter Geruch.  Was ist, wenn Sie die falsche wählen? <br>  Alle Daten, die Sie gespeichert haben - Sie müssen sie früher oder später vergessen.  Es geht nicht darum, sich an den letzten Funktionsaufruf zu erinnern - es geht darum, ihn zum richtigen Zeitpunkt zu VERGESSEN.  Nicht zu früh und das Auswendiglernen ruinieren und nicht zu spät. </p><br><blockquote>  Hast du die Idee?  Jetzt vergiss es!  Und wo ist die 3. Variante? </blockquote><br><h1 id="let-take-apause">  Lass uns eine Pause machen </h1><br><p>  Hör auf  Entspannen Sie sich  Atme tief ein.  Und beantworten Sie eine einfache Frage: Was ist das Ziel?  Was müssen wir tun, um das Ziel zu erreichen?  Was würde den Tag retten? </p><br><blockquote>  TIPP: Wo befindet sich dieser verdammte "Cache"? </blockquote><p><img src="https://habrastorage.org/webt/7m/r1/iz/7mr1izrzb89femvq5h-suxxkfnm.jpeg"></p><br><p>  Wo befindet sich dieser "Cache"?  Ja - das ist die richtige Frage.  Danke, dass du es gefragt hast.  Und die Antwort ist einfach - sie befindet sich in einem Verschluss.  An einer versteckten Stelle in * einer gespeicherten Funktion.  Zum Beispiel - hier ist <code>memoize-one</code> Code: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lastArgs; <span class="hljs-comment"><span class="hljs-comment">// the last arguments let lastResult;// the last result &lt;--- THIS IS THE CACHE // the memoized function const memoizedCall = function(...newArgs) { if (isEqual(newArgs, lastArgs)) { return lastResult; } lastResult = resultFn.apply(this, newArgs); lastArgs = newArgs; return lastResult; }; return memoizedCall; }</span></span></code> </pre> <br><p>  Sie erhalten einen <code>memoizedCall</code> , in dem das letzte Ergebnis in der Nähe des lokalen Verschlusses gespeichert ist, auf den nur memoizedCall zugreifen kann.  Ein sicherer Ort.  "das" ist ein sicherer Ort. </p><br><p>  <code>Reselect</code> macht dasselbe und die einzige Möglichkeit, einen "Fork" mit einem anderen Cache zu erstellen - erstellen Sie einen neuen Memoization-Abschluss. </p><br><p>  Aber die (andere) Hauptfrage - wann wäre es (weg) "weg"? </p><br><blockquote>  TLDR: Es wäre mit einer Funktion "weg", wenn die Funktionsinstanz von Garbage Collector gegessen würde. </blockquote><p>  Instanz?  Instanz!  Also - was ist mit Memoisierung pro Instanz?  Es gibt einen ganzen Artikel darüber in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">React-Dokumentation</a> </p><br><p>  Kurz gesagt - wenn Sie klassenbasierte Reaktionskomponenten verwenden, können Sie Folgendes tun: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> memoize <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"memoize-one"</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Example</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ filter = memoize( <span class="hljs-comment"><span class="hljs-comment">// &lt;-- bound to the instance (list, filterText) =&gt; list.filter(...); // ^ that is "per instance" memoization // we are creating "own" memoization function // with the "own" lastResult render() { // Calculate the latest filtered list. // If these arguments haven't changed since the last render, // `memoize-one` will reuse the last return value. const filteredList = this.filter(something, somehow); return &lt;ul&gt;{filteredList.map(item =&gt; ...}&lt;/ul&gt; } }</span></span></code> </pre> <br><p>  Also - wo ist <strong>"lastResult"</strong> gespeichert?  Innerhalb eines lokalen Bereichs von gespeicherten <strong>Filtern</strong> innerhalb dieser Klasseninstanz.  Und wann wäre es "weg"? </p><br><p>  Diesmal wäre es mit einer Klasseninstanz "weg".  Sobald die Komponente abmontiert wurde, ist sie spurlos verschwunden.  Es ist eine echte "pro Instanz", und Sie können <code>this.lastResult</code> , um ein zeitliches Ergebnis mit genau dem gleichen "Memoization" -Effekt zu <code>this.lastResult</code> . </p><br><h2 id="whats-about-reacthooks">  Was ist mit React.Hooks? </h2><br><p>  Wir kommen näher.  Redux-Hooks haben einige verdächtige Befehle, bei denen es wahrscheinlich um das Auswendiglernen geht.  Like - <code>useMemo</code> , <code>useCallback</code> , <code>useRef</code> </p><br><p><img src="https://habrastorage.org/webt/wx/2k/kf/wx2kkfpti6kecbdj4zoohpslkqk.png"></p><br><blockquote>  Aber die Frage - WO speichert es diesmal einen gespeicherten Wert? </blockquote><p>  Kurz gesagt - es speichert es in "Hooks" in einem speziellen Teil eines VDOM-Elements, das als Faser bekannt ist und einem aktuellen Element zugeordnet ist.  Innerhalb einer parallelen Datenstruktur. </p><br><p>  Nicht so kurze Hooks verändern die Funktionsweise Ihres Programms und verschieben Ihre Funktion in eine andere. Einige Variablen befinden sich an einer <em>versteckten Stelle in einem übergeordneten Abschluss</em> .  Solche Funktionen sind als <em>suspendierbare</em> oder <em>wiederaufnehmbare</em> Funktionen bekannt - Coroutinen.  In JavaScript werden sie normalerweise als <code>generators</code> oder <code>async functions</code> . </p><br><p>  Aber das ist ein bisschen extrem.  In kürzester Zeit speichert useMemo darin gespeicherte Werte.  Es ist nur ein bisschen anders "dies". </p><br><blockquote>  Wenn wir eine bessere Memo-Bibliothek erstellen wollen, sollten wir ein besseres "dies" finden. </blockquote><p>  Zing! </p><br><h1 id="weakmaps">  WeakMaps! </h1><br><p>  Ja!  WeakMaps!  Zum Speichern des Schlüsselwerts, wo der Schlüssel dies wäre, solange WeakMap nichts anderes als dies akzeptiert, dh "Objekte". </p><br><p>  Lassen Sie uns ein einfaches Beispiel erstellen: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> createHiddenSpot = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> map = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">WeakMap</span></span>(); <span class="hljs-comment"><span class="hljs-comment">// a hidden "closure" const set = (key, value) =&gt; (map.set(key, value), value); return (key) =&gt; { return map.get(key) || set(key, fn(key)) } } const weakSelect = createHiddenSpot(selector); weakSelect(todos); // create a new entry weakSelect(todos); // return an existing entry weakSelect(todos[0]); // create a new entry weakSelect(todos[1]); // create a new entry weakSelect(todos[0]); // return an existing entry! weakSelect(todos[1]); // return an existing entry!! weakSelect(todos); // return an existing entry!!!</span></span></code> </pre> <br><p>  Es ist dumm einfach und ganz "richtig".  Also "wann wäre es weg"? </p><br><ul><li>  Vergiss schwache Auswahl und eine ganze "Karte" wäre weg </li><li>  Vergiss todos [0] und ihr schwacher Eintrag wäre weg </li><li>  vergiss todos - und gespeicherte Daten wären weg! </li></ul><br><blockquote>  Es ist klar, wann etwas "weg" sein würde - nur wenn es sollte! </blockquote><p>  Magisch - alle Probleme bei der erneuten Auswahl sind verschwunden.  Probleme mit aggressiven Memoisierung - auch ein Goner. </p><br><p>  Dieser Ansatz <strong>Erinnern Sie sich an</strong> die Daten, bis es Zeit ist, zu <strong>vergessen</strong> .  Es ist unglaublich, aber um sich besser an etwas zu erinnern, muss man es besser vergessen können. </p><br><p>  Das einzige, was dauert, ist, eine robustere API für diesen Fall zu erstellen </p><br><h1 id="kashe-is-acache">  Kashe - ist ein Cache </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kashe</a> ist eine WeakMap-basierte Memoization-Bibliothek, die Ihren Tag retten könnte. </p><br><p>  Diese Bibliothek bietet 4 Funktionen </p><br><ul><li>  <code>kashe</code> - zum <code>kashe</code> . </li><li>  <code>box</code> - für die vorangestellte Memoisierung, um <em>die</em> Wahrscheinlichkeit der Memoisierung zu <em>erhöhen</em> . </li><li>  <code>inbox</code> - verschachtelte vorangestellte Memoisierung, um <em>die</em> Änderung der Memoisierung zu <em>verringern</em> </li><li>  <code>fork</code> - (offensichtlich) Memoisierung. </li></ul><br><h2 id="kashefn--memoizedfnargs">  kashe (fn) =&gt; memoizedFn (... args) </h2><br><p>  Es ist eigentlich ein createHiddenSpot aus einem vorherigen Beispiel.  Es wird ein erstes Argument als Schlüssel für eine interne WeakMap verwendet. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> selector = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state, prop</span></span></span><span class="hljs-function">) =&gt;</span></span> ({<span class="hljs-attr"><span class="hljs-attr">result</span></span>: state[prop]}); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoized = kashe(selector); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> old = memoized(state, <span class="hljs-string"><span class="hljs-string">'x'</span></span>) memoized(state, <span class="hljs-string"><span class="hljs-string">'x'</span></span>) === old memoized(state, <span class="hljs-string"><span class="hljs-string">'y'</span></span>) === memoized(state, <span class="hljs-string"><span class="hljs-string">'y'</span></span>) <span class="hljs-comment"><span class="hljs-comment">// ^^ another argument // but old !== memoized(state, 'x') // 'y' wiped 'x' cache in `state`</span></span></code> </pre> <br><p>  Das erste Argument ist ein Schlüssel. Wenn Sie die Funktion erneut mit demselben Schlüssel aufgerufen haben, aber unterschiedliche Argumente - der Cache würde ersetzt, ist es immer noch eine Cachezeile lange Memoisierung.  Damit es funktioniert, müssen Sie verschiedene Schlüssel für verschiedene Fälle bereitstellen, wie ich es bei einem Beispiel für eine schwache Auswahl getan habe, um unterschiedliche Ergebnisse bereitzustellen, um die Ergebnisse zu speichern.  Kaskaden erneut auswählen A ist immer noch das Richtige. <br>  Nicht alle Funktionen sind kashe-memoizable.  Das erste Argument <em>muss</em> ein Objekt, ein Array oder eine Funktion sein.  Es sollte als Schlüssel für WeakMap verwendet werden können. </p><br><h2 id="boxfn--memoizedfn2boxargs">  box (fn) =&gt; memoizedFn2 (box, ... args) </h2><br><p>  Dies ist dieselbe Funktion, die nur zweimal angewendet wird.  Einmal für fn, einmal für memoizedFn, wobei den Argumenten ein führender Schlüssel hinzugefügt wird.  Es könnte jede Funktion kashe-memoizable machen. </p><br><blockquote>  Es ist ziemlich deklarativ - hey Funktion!  Ich werde die Ergebnisse in dieser Box speichern. </blockquote><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// could not be "kashe" memoized const addTwo = (a,b) =&gt; ({ result: a+b }); const bAddTwo = boxed(addTwo); const cacheKey = {}; // any object bAddTwo(cacheKey, 1, 2) === bAddTwo(cacheKey, 1, 2) === { result: 3}</span></span></code> </pre> <br><p>  Wenn Sie die bereits gespeicherte Funktion aktivieren - Sie erhöhen die Memoisierungschance, wie z. B. die Memoisierung pro Instanz -, können Sie eine Memoisierungskaskade erstellen. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> selectSomethingFromTodo = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state, prop</span></span></span><span class="hljs-function">) =&gt;</span></span> ... const selector = kashe(selectSomethingFromTodo); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> boxedSelector = kashe(selector); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render () { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = boxedSelector(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, todos, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.todoId); <span class="hljs-comment"><span class="hljs-comment">// 1. try to find result in `this` // 2. try to find result in `todos` // 3. store in `todos` // 4. store in `this` // if multiple `this`(components) are reading from `todos` - // selector is not working (they are wiping each other) // but data stored in `this` - exists. ... } }</span></span></code> </pre> <br><h2 id="inboxfn--memoizedfn2boxargs">  Posteingang (fn) =&gt; memoizedFn2 (box, ... args) </h2><br><p>  Dieser ist der Box entgegengesetzt, macht aber fast dasselbe und befiehlt dem verschachtelten Cache, Daten in der bereitgestellten Box zu speichern.  Unter einem Gesichtspunkt - es verringert die Memoisierungswahrscheinlichkeit (es gibt keine Memoisierungskaskade), aber unter einem anderen Gesichtspunkt - werden die Cache-Kollisionen entfernt und Prozesse isoliert, wenn sie sich aus irgendeinem Grund nicht gegenseitig stören sollten. </p><br><blockquote>  Es ist ziemlich deklarativ - hey!  Alle drinnen!  Hier ist eine Box zur Verwendung </blockquote><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getAndSet = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">task, number</span></span></span><span class="hljs-function">) =&gt;</span></span> task.value + number; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoized = kashe(getAndSet); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> inboxed = inbox(getAndSet); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doubleBoxed = inbox(memoized); memoized(task, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// ok memoized(task, 2) // previous result wiped inboxed(key1, task, 1) // ok inboxed(key2, task, 2) // ok // inbox also override the cache for any underlaying kashe calls doubleBoxed(key1, task, 1) // ok doubleBoxed(key2, task, 2) // ok</span></span></code> </pre> <br><h2 id="forkkashe-memoized--kashe-memoized">  Gabel (kashe-memoized) =&gt; kashe-memoized </h2><br><p>  Fork ist eine echte Fork - sie erhält jede kashe-gespeicherte Funktion und gibt dieselbe zurück, jedoch mit einem anderen internen Cache-Eintrag.  Erinnern Sie sich an die Factory-Methode von redux mapStateToProps? </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mapStateToProps = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// const selector = createSelector(...); // const selector = fork(realSelector); // just fork existing selector. Or box it, or don't do anything // kashe is more "stable" than reselect. return state =&gt; ({ data: selector(data), }); }</span></span></code> </pre> <br><h2 id="reselect">  Neu auswählen </h2><br><p>  Und noch etwas sollten Sie wissen - Kashe könnte Reselect ersetzen.  Im wahrsten Sinne des Wortes. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { createSelector } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'kashe/reselect'</span></span>;</code> </pre> <br><p>  Es ist eigentlich die gleiche Neuauswahl, die nur mit Kashe als Memo-Funktion erstellt wurde. </p><br><h1 id="codesandbox">  Codesandbox </h1><br><p>  Hier ist ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kleines Beispiel</a> zum Spielen.  Sie können auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tests überprüfen</a> - sie sind kompakt und solide. <br>  Wenn Sie mehr über Caching und Memoisierung erfahren möchten, lesen Sie, wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ich vor</a> einem Jahr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die schnellste Memoisierungsbibliothek geschrieben</a> habe. </p><br><blockquote>  PS: Es ist erwähnenswert, dass die einfachere Version dieses Ansatzes - schwaches Auswendiglernen - für eine Weile in Emotionen verwendet wird.  Keine Beschwerden.  nano-memoize verwendet WeakMaps auch für einen einzelnen Argumentationsfall. </blockquote><p>  Verstanden?  Ein "schwächer" Ansatz würde Ihnen helfen, sich besser an etwas zu erinnern und es besser zu vergessen. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/theKashey/kashe</a> </p><br><p>  Ja, um etwas zu vergessen - könnten Sie bitte hier schauen? </p><br><p><img src="https://habrastorage.org/webt/60/d6/9y/60d69ysm9v5hy9dnm1siokafjhu.jpeg"></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446390/">https://habr.com/ru/post/de446390/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446376/index.html">Wie schreibe ich die Heimatadresse richtig?</a></li>
<li><a href="../de446378/index.html">Das Problem der Umstellung auf Winter- und Sommerzeit für eine einzelne Skype-Schule</a></li>
<li><a href="../de446380/index.html">H2 Evolution - Fensterfunktionen, CTE, JSON / XML in einer eingebetteten Datenbank</a></li>
<li><a href="../de446384/index.html">Tipps zum Entwickeln sehr großer Projekte in Revit</a></li>
<li><a href="../de446388/index.html">Öl- und Gasindustrie als Beispiel für periphere Cloud-Systeme</a></li>
<li><a href="../de446394/index.html">5. Check Point Erste Schritte R80.20. Gaia & CLI</a></li>
<li><a href="../de446396/index.html">GPS-Wochenzähler zurückgesetzt</a></li>
<li><a href="../de446400/index.html">Dmitry Dumik, Chatfuel: Über Y Combinator, Technologie-Unternehmertum, Verhaltensänderung und Bewusstsein</a></li>
<li><a href="../de446402/index.html">Mehrsprachige Apps in Angular</a></li>
<li><a href="../de446404/index.html">Moderne Alternativen zu PGP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>