<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ ğŸ‘©ğŸ¿â€ğŸ­ ğŸ‘©ğŸ¿ Ringkasan Cepat: Arsitektur Bersih, Robert C. Martin ğŸ§— ğŸ¿ ğŸ’Š</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ini akan menjadi cerita tentang kesan buku itu, dan juga beberapa konsep dan pengetahuan yang, berkat buku ini, dipelajari 

 Arsitektur 
 Bisakah And...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ringkasan Cepat: Arsitektur Bersih, Robert C. Martin</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464185/">  Ini akan menjadi cerita tentang kesan buku itu, dan juga beberapa konsep dan pengetahuan yang, berkat buku ini, dipelajari <br><br><h3>  Arsitektur </h3><br>  Bisakah Anda, membaca publikasi ini, memberikan jawaban yang jelas untuk pertanyaan, apa itu arsitektur?  Apa itu arsitektur dalam konteks pemrograman dan desain?  Peran apa yang dia mainkan?  Ada banyak ambiguitas dalam istilah ini.  Dan semuanya tampak jelas, tetapi entah bagaimana abstrak, dan tanpa akurasi.  Martin percaya, dan saya setuju dengannya, bahwa aplikasi memiliki dua komponen: <br><br><ol><li>  Behavior (behaviour) - fungsi dan tugas yang dijalankan oleh program (komponen, layanan). </li><li>  Arsitektur - istilah ini lebih tentang mengubah aplikasi. </li></ol><br>  Tetapi bahkan jika aplikasi melakukan dengan sangat baik tugas yang harus dilakukan, ini tidak berarti sama sekali bahwa ia memiliki arsitektur yang baik.  Arsitektur bukan tentang perilaku aplikasi.  Arsitektur adalah tentang kemudahan perubahan, arsitektur adalah tentang kemudahan penyebaran, arsitektur adalah tentang kemandirian pembangunan.  Arsitektur adalah tentang kecepatan di mana pemahaman datang ke orang baru dalam tim <br><br>  Dan inilah cara membangun arsitektur ini, cara menghilangkan sakit kepala dengan perubahan kecil dalam persyaratan dari PM, atau dari pemangku kepentingan: inilah yang akan diceritakan buku ini <br><a name="habracut"></a><br><h3>  Tentang Penulis </h3><br>  Sebelum saya mengatakan sesuatu tentang buku ini, saya ingin mengatakan sedikit tentang diri saya. <br>  Saat ini, saya adalah Pengembang Junior yang Kuat yang berspesialisasi dalam mengembangkan layanan melalui ASP .NET CORE. <br><br>  Saya sudah mengerjakan satu "galeri" selama satu tahun sekarang, dan sepertinya saya melakukan sedikit <br><br>  Saya sudah membaca buku ini 2 kali, dan saya merekomendasikannya kepada semua orang untuk membaca: <br><br><ul><li>  pengembang sistem sematan; </li><li>  endchikers depan; </li><li>  pendukung belakang; </li><li>  dan bahkan devopsam. </li></ul><br>  Secara umum, untuk siapa saja yang setidaknya entah bagaimana terhubung dengan pengembangan PP, maksud saya pengembangan langsung dari Saylov dan PM'ov yang berbeda di sini kita tidak mempertimbangkan di sini (meskipun juga akan berguna untuk mengetahui mengapa seorang pelayan terkadang menghabiskan 2 kali lebih banyak waktu untuk suatu tugas), saya menyarankan Anda untuk membaca buku ini. <br>  Dan sekarang saya akan mencoba untuk berdebat mengapa saya berpikir begitu <br><br>  Sedikit tentang penulis buku ini (karena bagi saya otoritas penulis memainkan peran besar).  Saya pikir Anda akan mengerti saya, meskipun ini tidak selalu benar, tetapi jika orang yang berwibawa di bola mengatakan sesuatu kepada Anda, Anda menunjukkan lebih percaya diri pada apa yang dia katakan.  Sebagai contoh, saya pikir Anda lebih suka percaya pada diagnosis yang diberikan dokter kepada Anda daripada dari beberapa orang dari kerumunan (lihat gejalanya) <br><br>  Robert Martin - alias Ankle Bob (Paman Bob) - telah bekerja di bidang pemrograman, dan dari berbagai sistem (dari layanan web ke sistem embed), sejak 1970.  Dia adalah konsultan teknis dan arsitek, dia menulis di berbagai jurnal teknis, dia adalah programmer yang sangat berpengalaman, dan seseorang yang memainkan salah satu peran kunci dalam menciptakan prinsip-prinsip SOLID yang terkenal (bisa dibilang pencipta).  Juga, saya ingin menambahkan bahwa pemimpin tim saya dengan 15+ pengalaman menyarankan saya pada buku ini <br><br><h2>  Tentang buku itu </h2><br><h3>  Ketergantungan </h3><br>  Sebelum membaca buku itu, saya membaca cukup banyak artikel tentang HabrÃ© yang sama, di mana kata "ketergantungan" muncul.  Apa itu, siapa yang bergantung pada siapa, apa sebenarnya "bergantung pada" artinya, dan bagaimana beberapa kelas dapat bergantung pada seseorang? <br><br>  Dan ketika saya membaca buku itu, saya belajar dua hal: <br><br>  Ketergantungan adalah istilah yang berarti bahwa beberapa kelas (komponen, layanan) tahu tentang beberapa kelas lain (komponen, layanan), dan pengetahuan ini pada tingkat kode ditentukan (sekarang javists, penajam, orang akan mengerti saya) oleh impor namespace tertentu .  Dengan kata lain: Anda memiliki kelas A dengan namespace Default.Classes dan kelas B Another.Classes.  Jadi, jika kode kelas A muncul menggunakan Another.Classes;  - ini berarti bahwa kelas A tergantung pada kelas B. <br>  Untuk memahami sesuai dengan skema di mana kelas dependen berada dan di mana tidak - lihatlah arah panah: 1) panah akan menunjuk dari kelas A ke arah kelas B. Ini berarti bahwa kelas B lebih mandiri daripada kelas A. Dan perubahan di kelas A , tidak ada "kerusakan" pada kelas B <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ec5/489/50e/ec548950ee84909391ca2918040683d0.png" alt="gambar"><br><br><h3>  PADAT </h3><br>  Salah satu alasan utama untuk membaca buku ini adalah penjelasan tentang prinsip-prinsip SOLID dari sumber aslinya, karena Paman Rob mengembangkan prinsip-prinsip ini, dan kita dapat mengucapkan terima kasih kepadanya bahwa kita mendengar nama ini - SOLID. <br>  Bagi mereka yang tidak tahu - prinsip-prinsip ini dikatakan dan disarankan untuk merancang aplikasi mereka sesuai dengan 5 aturan: <br><br>  S - SRP (Prinsip tanggung jawab tunggal) <br>  O - OCP (Prinsip buka-tutup) <br>  L - LSP (Prinsip substitusi Liskov) <br>  I - ISP (Prinsip pemisahan antarmuka) <br>  D - DIP (Prinsip Ketergantungan Pembalikan) <br><br>  Semua prinsip ini dapat diterapkan di tingkat kelas dan objek, di tingkat modul dan komponen, dan di tingkat rel (layanan). <br><br>  Jika Anda berpikir bahwa prinsip tanggung jawab tunggal adalah tentang fakta bahwa kelas, atau modul hanya melakukan satu hal, maka Anda harus membaca setidaknya bab tentang Solid.  Karena definisi yang diberikan di atas adalah konsekuensi, tetapi bukan definisi dari prinsip itu sendiri <br><br><h3>  Tentang Ketergantungan Inversi </h3><br>  Saya ingin memberikan perhatian khusus pada penjelasan Prinsip Ketergantungan Inversi (yang D adalah dari SOLID).  Dalam membaca buku ini, saya mengerti bahwa ini bukan hanya prinsip, tetapi juga mekanisme dan alat yang dengannya Anda dapat mengubah arah dependensi Anda dan membuat, misalnya, logika bisnis (DOMAIN) terlepas dari rincian penerapan lapisan akses Data (DAL'a) <br><br><img src="https://habrastorage.org/getpro/habr/post_images/357/6b4/943/3576b49437ab0e36cbd10c3496ec5aa1.png" alt="gambar"><br><br>  Meskipun prinsip itu sendiri bersama dengan yang lain dalam SOLID berarti sedikit sesuatu selain mekanisme, mekanisme itu sendiri digunakan di seluruh buku ini, dan ini adalah salah satu metode utama untuk membalikkan dan mengubah arah ketergantungan Anda, yang dengan cara digunakan dengan DDD <br><br><h3>  Tentang membuat keputusan arsitektur </h3><br>  Sangat sering, buku ini akan menyebutkan prinsip pengambilan keputusan arsitektur yang penting: basis data mana yang digunakan, kerangka mana yang digunakan, perpustakaan mana yang akan dihubungkan, apa yang harus digunakan sebagai mesin pencari, dll. <br><br>  Jadi, penulis percaya: Anda harus ASAP membuat keputusan semacam ini.  Karena persyaratan dapat berubah, pembatasan kinerja juga, komponen perilaku itu sendiri cenderung berubah.  Selama proses pengembangan, beberapa solusi mungkin tampak kurang efektif daripada yang lain, kurang nyaman daripada yang lain.  Dan kekuatan arsitektur Anda akan menentukan seberapa cepat dan tanpa rasa sakit Anda dapat mengganti satu teknologi dengan yang lainnya (OCP mengatakannya). <br><br>  Misalnya, tiba-tiba, Anda memutuskan untuk menggunakan MongoDb alih-alih Postgresql, atau file secara umum, atau menggunakan data tiruan, operasi yang akan dilakukan dalam memori.  Dan dalam kondisi tertentu - ini memungkinkan untuk menulis ulang hampir semua logika. <br><br>  Untuk mencegah situasi seperti itu, kita dapat menggunakan beberapa mekanisme yang akan mendorong waktu pengambilan keputusan sejauh mungkin.  Salah satu mekanisme ini adalah abstraksi. <br><br><h3>  Referensi DDD </h3><br>  DDD - Desain Didorong Domain - pendekatan untuk mengembangkan layanan dengan logika bisnis yang kompleks, penting untuk perubahan, yang bertujuan memaksimalkan pemahaman posisi manajemen proyek (PM, manajer Penjualan dll), dengan pendayung.  Artinya, bahwa akan ada bahasa di mana-mana di antara semua anggota proyek, dan semua orang dapat memahami yang lain, dan bahwa setiap orang berpikir dalam domain yang sama dengan aturan bisnis yang sama. <br><br>  Jika Anda adalah pendukung DDD, atau ingin menjadi DDD, atau Anda tidak memahami sesuatu tentang ini, tetapi ingin memahami, buku ini harus dibaca, terutama bagian kedua dari buku ini. <br><br>  Di sini penulis menjelaskan keberadaan Aturan Ketergantungan, dan mengapa, mengikutinya, Anda akan membangun arsitektur aplikasi yang benar.  Mengapa ketergantungan harus mengikuti komponen Kebijakan Tinggi, mengapa domain (komponen Kebijakan Tinggi) harus independen dari infrastruktur dan bagaimana hal itu akan menyederhanakan penyebaran dan pengembangan untuk Anda <br><br><img src="https://habrastorage.org/getpro/habr/post_images/275/8bc/635/2758bc635f1453903ab947b72c2d66cc.png" alt="gambar"><br><br><h3>  Abstraksi </h3><br>  Paman Rob juga berbicara tentang bagaimana detail implementasi dapat membahayakan sistem Anda dan mencegahnya berkembang tanpa rasa sakit di masa depan. <br><br>  Ingat! <br>  DB adalah detail implementasi <br>  Klien (Web, Ponsel, dll) - detail implementasi <br>  Kerangka kerja adalah detail implementasi. <br><br>  Diperlukan untuk mengabstraksi sebanyak mungkin dan tidak bergantung padanya, menggunakan Dependency Inversion yang dijelaskan di atas dengan antarmuka dan abstraksi, Aturan Ketergantungan dan mekanisme lainnya. <br><br><h3>  Metode untuk membangun modul </h3><br>  Saya terutama menyukai bagian ini sebagai pengembang layanan di ASP .NET CORE.  Untuk itu menjelaskan metodologi untuk membangun arsitektur layanan terpadu dari komponen yang sudah jadi. <br><br>  Robert menggambarkan 4 kemungkinan skema pemisahan lapisan. <br><br>  Dia menjelaskan mengapa mekanisme arsitektur 3-layer yang sering digunakan: UI (pengontrol), Layanan (Domain), DAL (Database) - cukup buruk dibandingkan dengan yang lain.  Saya belum melihat banyak proyek, tetapi di masing-masing, misalnya, layanan mikro, di bagian belakang, ia menggunakan arsitektur tiga lapis. <br><br>  Juga, cukup sering, arsitektur satu komponen satu layanan digunakan.  Secara umum, keduanya baik, tetapi memiliki banyak kelemahan, sebagai perbandingan, misalnya, bagaimana arsitektur dibangun menggunakan DDD, terutama ketika sangat penting untuk berubah, dan layanan yang kompleks. <br><br>  Secara umum, ulasan buku ini telah berakhir.  Saya sangat menyukai buku itu sendiri, saya tidak menyesali apa yang saya baca, terima kasih kepada penulis.  Terima kasih atas perhatian Anda, pembaca yang budiman, jangan menilai dengan ketat - publikasi ini didasarkan pada kesan buku dan antusiasme pribadi saya <br><br>  PEMBARUAN 1.0 <br><br>  Selama diskusi, dapat dipahami bahwa perubahan penyimpanan SUDDEN dan MUDAH tidak akan mudah, dengan satu atau lain cara.  Dalam beberapa kasus, bahkan abstraksi yang sangat menyakitkan, namun enkapsulasi akses ke toko, diragukan apa yang akan membuat situasi lebih buruk, tetapi sedikit lebih baik, setidaknya karena independensi komponen variabel dari yang lain. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id464185/">https://habr.com/ru/post/id464185/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id464171/index.html">Keamanan Pembaruan Perangkat Lunak</a></li>
<li><a href="../id464173/index.html">"Galai terkutuk", atau tempat kaki tumbuh dari rengekan kantor</a></li>
<li><a href="../id464177/index.html">Buku "Kotlin. Pemrograman untuk para profesional "</a></li>
<li><a href="../id464179/index.html">Satu standup di Yandex.Taxi, atau Apa yang Anda butuhkan untuk mengajar pengembang backend</a></li>
<li><a href="../id464181/index.html">Poco - Automation UI berbasis Python untuk Game Mobile sebagai bagian dari AirTest IDE</a></li>
<li><a href="../id464189/index.html">Cara membuat proyek open source</a></li>
<li><a href="../id464191/index.html">Cara mengatasi masalah situs agregator menggunakan proxy penduduk</a></li>
<li><a href="../id464193/index.html">Mikrofon terbuka dari DevOps Deflope, cerita tentang infrastruktur Skyeng dan Nvidia dan tidak hanya</a></li>
<li><a href="../id464195/index.html">Kisah sukses permainan Hari Terakhir di Bumi dari studio Volgograd Kefir</a></li>
<li><a href="../id464197/index.html">Apa yang akan terjadi pada TechTrain, dan mengapa saya harus pergi ke sana?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>