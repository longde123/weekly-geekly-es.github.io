<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👈🏻 🎂 ◽️ Verwenden von let-Deklarationen von Variablen und Features der resultierenden Abschlüsse in JavaScript 💽 🖖🏾 🧜🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich wurde inspiriert, diese Notiz zu schreiben, indem ich den Artikel über das Habré "Var, let or const? Die Probleme des Umfangs der Variablen und vo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verwenden von let-Deklarationen von Variablen und Features der resultierenden Abschlüsse in JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462971/"> Ich wurde inspiriert, diese Notiz zu schreiben, indem ich den Artikel über das Habré <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Var, let or const?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Probleme des Umfangs der Variablen und von ES6 “</a> und die Kommentare dazu sowie der entsprechende Teil von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Zakas Ns</a> Buch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">„ Understanding of ECMAScript 6 “</a> .  Aufgrund meiner Lektüre bin ich zu dem Schluss gekommen, dass nicht alles so einfach ist, um die Verwendung von <i>var</i> oder <i>let zu</i> beurteilen.  Autoren und Kommentatoren neigen dazu zu glauben, dass es sinnvoll ist, die Verwendung von <i>var</i> vollständig aufzugeben und standardmäßig einige vereinfachte Konstruktionen anstelle der alten zu verwenden, da ältere Versionen von Browsern nicht unterstützt werden müssen. <br><br>  Über den Umfang dieser Anzeigen, einschließlich der oben genannten Materialien, wurde bereits genug gesagt, daher möchte ich mich nur auf einige nicht offensichtliche Punkte konzentrieren. <br><a name="habracut"></a><br>  Zunächst möchte ich <b>Ausdrücke von sofort aufgerufenen Funktionen (sofort aufgerufene Funktionsausdrücke, IIFE)</b> in Schleifen betrachten. <br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> func1 = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) { func1.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); } }(i)); } func1.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ func(); }); <span class="hljs-comment"><span class="hljs-comment">/*    0 newECMA6add.js:4:59 1 newECMA6add.js:4:59 2 newECMA6add.js:4:59 */</span></span></code> </pre> <br>  oder Sie können mit <i>let auf sie verzichten</i> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> func1 = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) { func1.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); }); } func1.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ func(); }); <span class="hljs-comment"><span class="hljs-comment">/*     0 newECMA6add.js:4:37 1 newECMA6add.js:4:37 2 newECMA6add.js:4:37 */</span></span></code> </pre><br>  <i>Zakas N.</i> behauptet, dass beide ähnlichen Beispiele, die das gleiche Ergebnis <i>liefern</i> , auch genau gleich funktionieren: <blockquote>  "Diese Schleife funktioniert genau wie die Schleife, die var und ein IIFE verwendet hat, ist aber wohl sauberer." </blockquote>  was er selbst jedoch etwas weiter indirekt widerlegt. <br><br>  Tatsache ist, dass jede Iteration der Schleife bei Verwendung von <i>let</i> eine separate lokale Variable <i>i erstellt</i> , während die Bindung in den an das Array gesendeten Funktionen auch zu separaten Variablen von jeder Iteration geht. <br><br>  In diesem speziellen Fall ist das Ergebnis wirklich nicht anders, aber was ist, wenn wir den Code etwas komplizieren? <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> func1 = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) { func1.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); } }(i)); ++i; } func1.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ func(); }); <span class="hljs-comment"><span class="hljs-comment">/*    0 newECMA6add.js:4:59 2 newECMA6add.js:4:59 */</span></span></code> </pre> <br>  Beim Hinzufügen von <i>++ i</i> erwies sich unser Ergebnis als ziemlich vorhersehbar, da wir die Funktion mit <i>i-</i> Werten aufgerufen haben, die zum Zeitpunkt des Aufrufs relevant waren, selbst wenn die Schleife selbst übergeben wurde. Daher hatte die nachfolgende Operation <i>++ i</i> keinen Einfluss auf den Wert, der an die Funktion im Array übergeben wurde, da dies bereits der Fall war wurde in <i>Funktion (i)</i> mit einem bestimmten Wert von <i>i geschlossen</i> . <br><br>  Vergleichen Sie nun mit der <i>Let-</i> Version ohne <b>IIFE</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> func1 = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) { func1.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); }); ++i; } func1.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ func(); }); <span class="hljs-comment"><span class="hljs-comment">/*    1 newECMA6add.js:4:37 3 newECMA6add.js:4:37 */</span></span></code> </pre> <br>  Das Ergebnis hat sich anscheinend geändert, und die Art dieser Änderung ist, dass wir die Funktion nicht sofort mit dem Wert aufgerufen haben, sondern dass die Funktion die in den Abschlüssen verfügbaren Werte bei bestimmten Iterationen des Zyklus übernommen hat. <br><br>  Betrachten Sie Beispiele mit zwei Arrays, um die Essenz des Geschehens besser zu verstehen.  Und für den Anfang nehmen wir var ohne <b>IIFE</b> : <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> func1 = [], func2 = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) { func2.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(++i); }); func1.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(++i); }); ++i; } func1.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ func(); }); func2.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ func(); }); <span class="hljs-comment"><span class="hljs-comment">/*    5 newECMA6add.js:6:37 6 newECMA6add.js:6:37 7 newECMA6add.js:5:37 8 newECMA6add.js:5:37 */</span></span></code> </pre> <br>  Bisher ist alles offensichtlich - es gibt keine Schließung (obwohl wir sagen können, dass dies der Fall ist, aber für den globalen Bereich, obwohl dies nicht ganz richtig ist, da der Zugang zu <i>i</i> im Wesentlichen überall ist), d. H. Ähnlich, aber mit einem lokalen Bereich anscheinend wird die Variable <i>i</i> einen ähnlichen Eintrag haben: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> func1 = [], func2 = []; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) { func2.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(++i); }); func1.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(++i); }); ++i; } } test(); func1.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ func(); }); func2.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ func(); }); <span class="hljs-comment"><span class="hljs-comment">/*     5 newECMA6add.js:7:41 6 newECMA6add.js:7:41 7 newECMA6add.js:6:41 8 newECMA6add.js:6:41 */</span></span></code> </pre> <br>  In beiden Beispielen tritt Folgendes auf: <br><br>  1. Zu Beginn der letzten Iteration des Zyklus <i>i == 2</i> , dann inkrementiert um <i>1 (++ i)</i> , und am Ende wird <i>1</i> weitere aus <i>i ++</i> hinzugefügt. Infolgedessen wird am Ende des gesamten Zyklus <i>i == 4</i> . <br><br>  2. Die Funktionen in den Arrays <i>func1</i> und <i>func2</i> werden <i>einzeln</i> <i>aufgerufen</i> , und in jedem von ihnen wird dieselbe Variable <i>i</i> nacheinander inkrementiert, was sich relativ zu ihrem Umfang <i>abschließt.</i> <i>Dies</i> macht sich insbesondere dann bemerkbar, wenn es sich nicht um eine globale, sondern um eine lokale Variable handelt. <br><br>  <b>IIFE hinzufügen</b> . <br>  Die erste Option: <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> func1 = [], func2 = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) { func2.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(++i); } }(i)); func1.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(++i); } }(i)); ++i; } func1.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ func(); }); func2.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ func(); }); <span class="hljs-comment"><span class="hljs-comment">/*    1 newECMA6add.js:6:56 3 newECMA6add.js:6:56 1 newECMA6add.js:5:56 3 newECMA6add.js:5:56 */</span></span></code> </pre>  Die zweite Option: <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> func1 = [], func2 = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) { func2.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); } }(++i)); func1.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); } }(++i)); ++i; } func1.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ func(); }); func2.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ func(); }); <span class="hljs-comment"><span class="hljs-comment">/*    2 newECMA6add.js:6:56 1 newECMA6add.js:5:56 */</span></span></code> </pre> <br>  Beim Hinzufügen von <b>IIFE</b> im ersten Fall haben wir einfach die festen Werte von <i>i</i> in <i>Funktion (i)</i> ( <i>0</i> und <i>2</i> während des ersten bzw. zweiten Durchlaufs des Zyklus) aufgerufen und um 1 erhöht, wobei jede Funktion von der anderen getrennt ist, da hier der Abschluss einer gemeinsamen Variablen erfolgt Es gibt keine Schleife, da der Wert <i>i</i> sofort während der Durchläufe der Schleife übertragen wurde.  Im zweiten Fall gibt es auch keinen Abschluss für die Schleifenvariable, aber dort wurde der Wert mit gleichzeitigem Inkrement übertragen, so dass am Ende des ersten Durchgangs <i>i == 4</i> war und die Schleife nicht weiter ging.  Ich mache jedoch darauf aufmerksam, dass die Verschlüsse von Variablen aus externen Funktionen in internen Funktionen für jede Funktion separat sowohl in der ersten als auch in der zweiten Variante vorhanden sind.  Zum Beispiel: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> func1 = [], func2 = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) { func2.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(++i); } }(i)); func1.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(++i); } }(i)); ++i; } func1.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ func(); }); func2.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ func(); }); func1.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ func(); }); func2.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ func(); }); <span class="hljs-comment"><span class="hljs-comment">/*    1 newECMA6add.js:6:56 3 newECMA6add.js:6:56 1 newECMA6add.js:5:56 3 newECMA6add.js:5:56 2 newECMA6add.js:6:56 4 newECMA6add.js:6:56 2 newECMA6add.js:5:56 4 newECMA6add.js:5:56 */</span></span></code> </pre>  <i>Hinweis: Selbst wenn Sie den Zyklus mit einer Funktion versehen, werden übliche Verschlüsse dies natürlich nicht tun.</i> <br><br>  Betrachten Sie nun die <i>let-</i> Anweisung ohne IIFE. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> func1 = [], func2 = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) { func2.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(++i); }); func1.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(++i); }); ++i; } func1.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ func(); }); func2.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ func(); }); <span class="hljs-comment"><span class="hljs-comment">/*    2 newECMA6add.js:6:41 4 newECMA6add.js:6:41 3 newECMA6add.js:5:41 5 newECMA6add.js:5:41 */</span></span></code> </pre> <br>  Und hier haben wir wieder einen Kurzschluss zur Schleifenvariablen gebildet, und zwar nicht eine, sondern zwei und nicht getrennt, sondern gemeinsam, was angesichts des bekannten Prinzips der <i>eingelassenen</i> Zyklen logisch ist. <br><br>  Als Ergebnis haben wir, dass im ersten Abschluss vor dem Aufrufen der Funktionen in den Arrays der Wert <i>i == 1</i> und im zweiten <i>i == 3 ist</i> .  Dies sind die Werte, die die Variable <i>i</i> vor <i>i ++</i> und der Schleifeniteration erhalten hat, aber nach allen Anweisungen im Schleifenblock, und sie werden für jede bestimmte Iteration geschlossen. <br><br>  Dann werden die im <i>func1-</i> Array befindlichen Funktionen <i>aufgerufen</i> und inkrementieren die entsprechenden Variablen in beiden Abschlüssen und als Ergebnis im ersten <i>i == 2</i> und im zweiten <i>i == 4</i> . <br><br>  Der nachfolgende Aufruf von <i>func2</i> erhöht sich weiter und erhält <i>i == 3</i> bzw. <i>5</i> . <br><br>  Ich habe <i>func2</i> und <i>func1</i> absichtlich <i>so</i> in den Block <i>eingefügt</i> , dass die Unabhängigkeit von ihrem Standort deutlicher sichtbar wurde, und um die Aufmerksamkeit des Lesers auf die Tatsache zu lenken, dass Schleifenvariablen geschlossen werden. <br><br>  Abschließend werde ich ein triviales Beispiel geben, das darauf abzielt, das Verständnis von Schließungen und den Umfang von <i>let zu verbessern</i> : <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> func1 = []; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; func1.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); }); ++i; } func1.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ func(); }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); <span class="hljs-comment"><span class="hljs-comment">/* 1 newECMA6add.js:5:34 ReferenceError: i is not definednewECMA6add.js:10:1 */</span></span></code> </pre> <br><h3>  Was haben wir insgesamt? </h3><br>  1. Das Aufrufen von Ausdrücken sofort aufgerufener Funktionen entspricht nicht der Verwendung iterierbarer <i>let-</i> Variablen in Funktionen in Schleifen und führt in einigen Fällen zu unterschiedlichen Ergebnissen. <br><br>  2. Aufgrund der Tatsache, dass bei Verwendung einer <i>let-</i> Deklaration für einen Iterator in jeder Iteration eine separate lokale Variable erstellt wird, stellt sich die Frage nach der Entsorgung unnötiger Daten durch den Garbage Collector.  Zu diesem Zeitpunkt wollte ich zugeben, dass ich zunächst die Aufmerksamkeit auf mich ziehen wollte, da ich vermutete, dass das Erstellen einer großen Anzahl von Variablen in großen Schleifen den Compiler verlangsamen würde. Beim Sortieren eines Testarrays mit nur <i>let-</i> Variablendeklarationen zeigte sich jedoch ein Gewinn an Ausführungszeit von fast zweimal für ein Array von 100.000 Zellen: <br><div class="spoiler">  <b class="spoiler_title">Option mit var:</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> start = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr = [], func1 = [], func2 = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">100000</span></span>; i++) { arr.push(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random()); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">99999</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> min, minind = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">100000</span></span>; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[minind] &gt; arr[j]) minind = j; } min = arr[minind]; arr[minind] = arr[i]; arr[i] = min; func1.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; } }(arr[i])); } func1.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; } }(arr[<span class="hljs-number"><span class="hljs-number">99999</span></span>])); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">100000</span></span>; i++) { func2.push(func1[i]()); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> end = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log((end - start)/<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 9.847</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Und die Option mit let:</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> start = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [], func1 = [], func2 = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">100000</span></span>; i++) { arr.push(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random()); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">99999</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> min, minind = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">100000</span></span>; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[minind] &gt; arr[j]) minind = j; } min = arr[minind]; arr[minind] = arr[i]; arr[i] = min; func1.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arr[i]; }); } func1.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arr[<span class="hljs-number"><span class="hljs-number">99999</span></span>]; }); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">100000</span></span>; i++) { func2.push(func1[i]()); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> end = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log((end - start)/<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 5.3</span></span></code> </pre> <br></div></div><br>  Gleichzeitig war die Ausführungszeit praktisch unabhängig vom Vorhandensein / Fehlen von Anweisungen: <br><br><div class="spoiler">  <b class="spoiler_title">mit IIFE</b> <div class="spoiler_text"><pre> <code class="javascript hljs">func1.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; } }(arr[i]));</code> </pre> <br></div></div>  entweder <div class="spoiler">  <b class="spoiler_title">ohne IIFE</b> <div class="spoiler_text"><pre> <code class="javascript hljs">func1.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arr[i]; });</code> </pre> <br></div></div>  und <div class="spoiler">  <b class="spoiler_title">Funktionsaufruf</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">100000</span></span>; i++) { func2.push(func1[i]()); }</code> </pre> <br></div></div><br>  <i>Hinweis: Ich verstehe, dass die Informationen zur Geschwindigkeit nicht neu sind, aber der Vollständigkeit halber denke ich, dass diese beiden Beispiele es wert waren, angegeben zu werden.</i> <br><br>  Aus all dem können wir schließen, dass die Verwendung von <i>let-</i> Deklarationen anstelle von <i>var</i> in Anwendungen, die keine Abwärtskompatibilität mit früheren Standards erfordern, mehr als gerechtfertigt ist, insbesondere in Fällen mit Schleifen.  Gleichzeitig lohnt es sich jedoch, sich an die Verhaltensmerkmale in Situationen mit Schließungen zu erinnern und gegebenenfalls weiterhin Ausdrücke von sofort aufgerufenen Funktionen zu verwenden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462971/">https://habr.com/ru/post/de462971/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462961/index.html">Data Science Digest (August 2019)</a></li>
<li><a href="../de462963/index.html">Verwenden der Kontext-API in React zum Erstellen eines globalen Anwendungsthemas</a></li>
<li><a href="../de462965/index.html">Erhöhen Sie den Server 1c mit der Veröffentlichung der Datenbank und der Webdienste unter Linux</a></li>
<li><a href="../de462967/index.html">Hacks beim Arbeiten mit einer großen Anzahl kleiner Dateien</a></li>
<li><a href="../de462969/index.html">Wie die kasachischen Behörden versuchen, ihr Versagen mit der Einführung des Zertifikats zu vertuschen</a></li>
<li><a href="../de462977/index.html">Beschleunigen Sie routinemäßige HR-Prozesse mit RPA und BluePrism</a></li>
<li><a href="../de462979/index.html">Spickzettel für Auszubildende: Schritt für Schritt Google Interviewing</a></li>
<li><a href="../de462983/index.html">Voice for Game Dev: Wie wir die Voice Quest "Lovecraft World" entwickelt haben</a></li>
<li><a href="../de462989/index.html">Conversational BERT - Lernen Sie neuronale Netze in der Sprache der sozialen Medien</a></li>
<li><a href="../de462991/index.html">Auf der Web 3.0 Welle reiten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>