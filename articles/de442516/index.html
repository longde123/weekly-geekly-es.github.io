<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîÑ üòâ üë®üèª‚Äçüíº Pandas Leitfaden zur Big Data-Analyse üõå üßôüèø ‚ù£Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Sie die Pandas-Bibliothek zum Analysieren kleiner Datens√§tze verwenden, deren Gr√∂√üe 100 Megabyte nicht √ºberschreitet, wird die Leistung selten zu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pandas Leitfaden zur Big Data-Analyse</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/442516/"> Wenn Sie die Pandas-Bibliothek zum Analysieren kleiner Datens√§tze verwenden, deren Gr√∂√üe 100 Megabyte nicht √ºberschreitet, wird die Leistung selten zum Problem.  Wenn es jedoch um die Untersuchung von Datens√§tzen geht, deren Gr√∂√üe mehrere Gigabyte erreichen kann, k√∂nnen Leistungsprobleme zu einer signifikanten Verl√§ngerung der Datenanalysedauer f√ºhren und sogar dazu, dass aufgrund von Speichermangel keine Analyse durchgef√ºhrt werden kann. <br><br>  W√§hrend Tools wie Spark gro√üe Datenmengen (von Hunderten von Gigabyte bis zu mehreren Terabyte) effizient verarbeiten k√∂nnen, ben√∂tigen Sie normalerweise recht leistungsstarke und teure Hardware, um ihre Funktionen voll auszusch√∂pfen.  Und im Vergleich zu Pandas unterscheiden sie sich nicht in umfangreichen Werkzeugen f√ºr eine qualitativ hochwertige Reinigung, Forschung und Datenanalyse.  Bei mittelgro√üen Datens√§tzen ist es am besten, Pandas effizienter einzusetzen, anstatt zu anderen Tools zu wechseln. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/gd/jg/60/gdjg60abxgti2otxocpd0ct2uci.jpeg"></a> <br><br>  In dem Material, das wir heute √ºbersetzen, werden wir √ºber die Funktionen der Arbeit mit Speicher bei der Verwendung von Pandas sprechen und dar√ºber, wie der Speicherverbrauch einfach um fast 90% reduziert werden kann, indem einfach die entsprechenden Datentypen ausgew√§hlt werden, die in den Spalten der Tabellendatenstrukturen des <code>DataFrame</code> . <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Arbeiten mit Daten zu Baseballspielen</font> </h2><br>  Wir werden mit Daten zu Baseballspielen der Major League arbeiten, die √ºber 130 Jahre gesammelt und aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Retrosheet</a> entnommen wurden. <br><br>  Urspr√ºnglich wurden diese Daten als 127 CSV-Dateien dargestellt, aber wir haben sie mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">csvkit</a> zu einem Datensatz <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zusammengefasst</a> und als erste Zeile der resultierenden Tabelle eine Zeile mit Spaltennamen hinzugef√ºgt.  Wenn Sie m√∂chten, k√∂nnen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unsere Version</a> dieser Daten herunterladen und damit experimentieren, indem Sie den Artikel lesen. <br><br>  Beginnen wir mit dem Importieren eines Datensatzes und werfen einen Blick auf die ersten f√ºnf Zeilen.  Sie finden sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser</a> Tabelle im <code>   </code> . <br><br><pre> <code class="plaintext hljs">import pandas as pd gl = pd.read_csv('game_logs.csv') gl.head()</code> </pre> <br>  Nachfolgend finden Sie Informationen zu den wichtigsten Spalten der Tabelle mit diesen Daten.  Wenn Sie die Erkl√§rungen f√ºr alle Spalten lesen m√∂chten, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">finden</a> Sie hier ein Datenw√∂rterbuch f√ºr den gesamten Datensatz. <br><br><ul><li>  <code>date</code> - Datum des Spiels. </li><li>  <code>v_name</code> - Der Name des Gastteams. </li><li>  <code>v_league</code> - Liga der Gastmannschaft. </li><li>  <code>h_name</code> - Der Name der Heimmannschaft. </li><li>  <code>h_league</code> - Die Liga der Heimmannschaft. </li><li>  <code>v_score</code> - Punkte von der Ausw√§rtsmannschaft. </li><li>  <code>h_score</code> - Punkte der Heimmannschaft. </li><li>  <code>v_line_score</code> - Eine Zusammenfassung der Punkte des Gastteams, zum Beispiel - <code>010000(10)00</code> . </li><li>  <code>h_line_score</code> - Eine Zusammenfassung der Punkte der Heimmannschaft, zum Beispiel - <code>010000(10)0X</code> . </li><li>  <code>park_id</code> - Die Kennung des Feldes, auf dem das Spiel gespielt wurde. </li><li>  <code>attendance</code> - Die Anzahl der Zuschauer. </li></ul><br>  Um allgemeine Informationen zum <code>DataFrame</code> Objekt zu erhalten, k√∂nnen Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DataFrame.info ()</a> -Methode verwenden.  Dank dieser Methode k√∂nnen Sie Informationen zur Gr√∂√üe eines Objekts, zu Datentypen und zur Speichernutzung erhalten. <br><br>  Standardm√§√üig <code>DataFrame</code> ungef√§hre Informationen zur Speichernutzung durch den <code>DataFrame</code> .  Wir sind an genauen Informationen interessiert, daher setzen wir den Parameter <code>memory_usage</code> auf <code>'deep'</code> . <br><br><pre> <code class="plaintext hljs">gl.info(memory_usage='deep')</code> </pre> <br>  Hier sind die Informationen, die wir erhalten haben: <br><br><pre> <code class="plaintext hljs">&lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 171907 entries, 0 to 171906 Columns: 161 entries, date to acquisition_info dtypes: float64(77), int64(6), object(78) memory usage: 861.6 MB</code> </pre> <br>  Wie sich herausstellte, haben wir 171.907 Zeilen und 161 Spalten.  Die Pandas-Bibliothek hat Datentypen automatisch erkannt.  Es gibt 83 Spalten mit numerischen Daten und 78 Spalten mit Objekten.  Objektspalten werden zum Speichern von Zeichenfolgendaten verwendet, und in F√§llen, in denen die Spalte Daten unterschiedlichen Typs enth√§lt. <br><br>  Um besser zu verstehen, wie Sie die Speichernutzung mit diesem <code>DataFrame</code> optimieren <code>DataFrame</code> , sprechen wir nun dar√ºber, wie Pandas Daten im Speicher speichert. <br><br><h2>  <font color="#3AC1EF">Interne Ansicht eines DataFrame</font> </h2><br>  Innerhalb von Pandas werden Datenspalten in Bl√∂cken mit Werten des gleichen Typs gruppiert.  Hier ist ein Beispiel daf√ºr, wie die ersten 12 Spalten eines <code>DataFrame</code> in Pandas gespeichert werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d35/c70/c63/d35c70c635289a5cecc520c58e662e9a.png"></div><br>  <i><font color="#999999">Interne Darstellung verschiedener Datentypen in Pandas</font></i> <br><br>  M√∂glicherweise stellen Sie fest, dass Bl√∂cke keine Spaltennameninformationen speichern.  Dies liegt daran, dass die Bl√∂cke zum Speichern der in den Tabellenzellen des <code>DataFrame</code> Objekts verf√ºgbaren Werte optimiert sind.  Die <code>BlockManager</code> Klasse ist daf√ºr verantwortlich, Informationen √ºber die Entsprechung zwischen den Zeilen- und Spaltenindizes des Datensatzes und dar√ºber zu speichern, was in Bl√∂cken desselben Datentyps gespeichert ist.  Es spielt die Rolle einer API, die den Zugriff auf Basisdaten erm√∂glicht.  Wenn wir Werte lesen, bearbeiten oder l√∂schen, interagiert die <code>BlockManager</code> Klasse mit der <code>BlockManager</code> Klasse, um unsere Anforderungen in Funktions- und Methodenaufrufe zu konvertieren. <br><br>  Jeder Datentyp verf√ºgt √ºber eine spezielle Klasse im Modul <code>pandas.core.internals</code> .  Pandas verwendet beispielsweise die <code>ObjectBlock</code> Klasse, um Bl√∂cke mit Zeichenfolgenspalten <code>FloatBlock</code> , und die <code>FloatBlock</code> Klasse, um Bl√∂cke mit Spalten darzustellen, <code>FloatBlock</code> Gleitkommazahlen enthalten.  Bei Bl√∂cken, die numerische Werte darstellen, die wie Ganzzahlen oder Gleitkommazahlen aussehen, kombiniert pandas die Spalten und speichert sie als <code>ndarray</code> Datenstruktur der NumPy-Bibliothek.  Diese Datenstruktur basiert auf dem Array C, die Werte werden in einem kontinuierlichen Speicherblock gespeichert.  Dank dieses Datenspeicherungsschemas ist der Zugriff auf Datenfragmente sehr schnell. <br><br>  Da Daten unterschiedlicher Typen separat gespeichert werden, untersuchen wir die Speichernutzung verschiedener Datentypen.  Beginnen wir mit der durchschnittlichen Speichernutzung f√ºr verschiedene Datentypen. <br><br><pre> <code class="plaintext hljs">for dtype in ['float','int','object']:   selected_dtype = gl.select_dtypes(include=[dtype])   mean_usage_b = selected_dtype.memory_usage(deep=True).mean()   mean_usage_mb = mean_usage_b / 1024 ** 2   print("Average memory usage for {} columns: {:03.2f} MB".format(dtype,mean_usage_mb))</code> </pre> <br>  Infolgedessen stellt sich heraus, dass die durchschnittlichen Indikatoren f√ºr die Speichernutzung f√ºr Daten verschiedener Typen folgenderma√üen aussehen: <br><br><pre> <code class="plaintext hljs">Average memory usage for float columns: 1.29 MB Average memory usage for int columns: 1.12 MB Average memory usage for object columns: 9.53 MB</code> </pre> <br>  Diese Informationen machen uns verst√§ndlich, dass der gr√∂√üte Teil des Speichers f√ºr 78 Spalten zum Speichern von Objektwerten verwendet wird.  Wir werden sp√§ter mehr dar√ºber sprechen, aber jetzt √ºberlegen wir, ob wir die Speichernutzung mit Spalten verbessern k√∂nnen, in denen numerische Daten gespeichert sind. <br><br><h2>  <font color="#3AC1EF">Untertypen</font> </h2><br>  Wie bereits erw√§hnt, stellen Pandas numerische Werte als <code>ndarray</code> NumPy-Datenstrukturen dar und speichern sie in zusammenh√§ngenden Speicherbl√∂cken.  Mit diesem Datenspeichermodell k√∂nnen Sie Speicherplatz sparen und schnell auf Werte zugreifen.  Da Pandas jeden Wert desselben Typs mit derselben Anzahl von Bytes darstellen und <code>ndarray</code> Strukturen Informationen √ºber die Anzahl der Werte speichern, k√∂nnen Pandas schnell und genau Informationen √ºber den Speicherbedarf von Spalten anzeigen, in denen numerische Werte gespeichert sind. <br><br>  Viele Datentypen in Pandas haben viele Untertypen, die weniger Bytes verwenden k√∂nnen, um jeden Wert darzustellen.  Der <code>float</code> Typ hat beispielsweise die Untertypen <code>float16</code> , <code>float32</code> und <code>float64</code> .  Die Zahl im Typnamen gibt die Anzahl der Bits an, die der Subtyp zur Darstellung der Werte verwendet.  Beispielsweise werden in den gerade aufgelisteten Untertypen 2, 4, 8 und 16 Bytes jeweils zur Datenspeicherung verwendet.  Die folgende Tabelle zeigt die Untertypen der am h√§ufigsten verwendeten Datentypen in Pandas. <br><table><tbody><tr><td>  <sup>Speichernutzung, Bytes</sup> <sup><br></sup> </td><td>  <sup>Gleitkommazahl</sup> <sup><br></sup> </td><td>  <sup>Ganze Zahl</sup> <sup><br></sup> </td><td>  <sup>Ganzzahl ohne Vorzeichen</sup> <sup><br></sup> </td><td>  <sup>Datum und Uhrzeit</sup> <sup><br></sup> </td><td>  <sup>Boolescher Wert</sup> <sup><br></sup> </td><td width="75">  <sup>Objekt</sup> <sup><br></sup> </td></tr><tr><td>  <sup>1</sup> <sup><br></sup> </td><td></td><td>  <sup>int8</sup> <sup><br></sup> </td><td>  <sup>uint8</sup> <sup><br></sup> </td><td></td><td>  <sup>Bool</sup> <sup><br></sup> </td><td></td></tr><tr><td>  <sup>2</sup> <sup><br></sup> </td><td>  <sup>float16</sup> <sup><br></sup> </td><td>  <sup>int16</sup> <sup><br></sup> </td><td>  <sup>uint16</sup> <sup><br></sup> </td><td></td><td></td><td></td></tr><tr><td>  <sup>4</sup> <sup><br></sup> </td><td>  <sup>float32</sup> <sup><br></sup> </td><td>  <sup>int32</sup> <sup><br></sup> </td><td>  <sup>uint32</sup> <sup><br></sup> </td><td></td><td></td><td></td></tr><tr><td>  <sup>8</sup> <sup><br></sup> </td><td>  <sup>float64</sup> <sup><br></sup> </td><td>  <sup>int64</sup> <sup><br></sup> </td><td>  <sup>uint64</sup> <sup><br></sup> </td><td>  <sup>datetime64</sup> <sup><br></sup> </td><td></td><td></td></tr><tr><td>  <sup>Variable Speicherkapazit√§t</sup> <sup><br></sup> </td><td></td><td></td><td></td><td></td><td></td><td>  <sup>Objekt</sup> <sup><br></sup> </td></tr></tbody></table><br>  Ein Wert vom Typ <code>int8</code> verwendet 1 Byte (8 Bit) zum Speichern einer Zahl und kann 256 Bin√§rwerte (2 bis 8 Potenzen) darstellen.  Dies bedeutet, dass dieser Subtyp zum Speichern von Werten im Bereich von -128 bis 127 (einschlie√ülich 0) verwendet werden kann. <br><br>  Mit der Methode <code>numpy.iinfo()</code> k√∂nnen Sie die f√ºr die Speicherung geeigneten Mindest- und H√∂chstwerte f√ºr jeden Ganzzahl-Subtyp <code>numpy.iinfo()</code> .  Betrachten Sie ein Beispiel: <br><br><pre> <code class="plaintext hljs">import numpy as np int_types = ["uint8", "int8", "int16"] for it in int_types:   print(np.iinfo(it))</code> </pre> <br>  Durch Ausf√ºhren dieses Codes erhalten wir die folgenden Daten: <br><br><pre> <code class="plaintext hljs">Machine parameters for uint8 --------------------------------------------------------------- min = 0 max = 255 --------------------------------------------------------------- Machine parameters for int8 --------------------------------------------------------------- min = -128 max = 127 --------------------------------------------------------------- Machine parameters for int16 --------------------------------------------------------------- min = -32768 max = 32767 ---------------------------------------------------------------</code> </pre> <br>  Hier k√∂nnen Sie auf den Unterschied zwischen den Typen <code>uint</code> (vorzeichenlose Ganzzahl) und <code>int</code> (vorzeichenbehaftete Ganzzahl) <code>uint</code> .  Beide Typen haben die gleiche Kapazit√§t, aber wenn nur positive Werte in Spalten gespeichert werden, erm√∂glichen vorzeichenlose Typen eine effizientere Speichernutzung. <br><br><h2>  <font color="#3AC1EF">Optimierung der Speicherung numerischer Daten mithilfe von Untertypen</font> </h2><br>  Mit der Funktion <code>pd.to_numeric()</code> k√∂nnen numerische Typen <code>pd.to_numeric()</code> werden.  Um ganzzahlige Spalten auszuw√§hlen, verwenden wir die Methode <code>DataFrame.select_dtypes()</code> . Anschlie√üend optimieren wir sie und vergleichen die Speichernutzung vor und nach der Optimierung. <br><br><pre> <code class="plaintext hljs">#     ,   , #   ,      . def mem_usage(pandas_obj):   if isinstance(pandas_obj,pd.DataFrame):       usage_b = pandas_obj.memory_usage(deep=True).sum()   else: #     ,     DataFrame,   Series       usage_b = pandas_obj.memory_usage(deep=True)   usage_mb = usage_b / 1024 ** 2 #       return "{:03.2f} MB".format(usage_mb) gl_int = gl.select_dtypes(include=['int']) converted_int = gl_int.apply(pd.to_numeric,downcast='unsigned') print(mem_usage(gl_int)) print(mem_usage(converted_int)) compare_ints = pd.concat([gl_int.dtypes,converted_int.dtypes],axis=1) compare_ints.columns = ['before','after'] compare_ints.apply(pd.Series.value_counts)</code> </pre> <br>  Hier ist das Ergebnis einer Studie zum Speicherverbrauch: <br><br> <code>7.87 MB <br> 1.48 MB</code> <br> <table><tbody><tr><td></td><td>  Zu <br></td><td>  Nachher <br></td></tr><tr><td>  uint8 <br></td><td>  NaN <br></td><td>  5.0 <br></td></tr><tr><td>  uint32 <br></td><td>  NaN <br></td><td>  1.0 <br></td></tr><tr><td>  int64 <br></td><td>  6.0 <br></td><td>  NaN <br></td></tr></tbody></table><br>  Infolgedessen ist ein R√ºckgang der Speichernutzung von 7,9 auf 1,5 Megabyte zu verzeichnen, dh wir haben den Speicherverbrauch um mehr als 80% reduziert.  Die Gesamtauswirkung dieser Optimierung auf den urspr√ºnglichen <code>DataFrame</code> ist jedoch nicht besonders stark, da nur sehr wenige ganzzahlige Spalten vorhanden sind. <br><br>  Machen wir dasselbe mit Spalten, die Gleitkommazahlen enthalten. <br><br><pre> <code class="plaintext hljs">gl_float = gl.select_dtypes(include=['float']) converted_float = gl_float.apply(pd.to_numeric,downcast='float') print(mem_usage(gl_float)) print(mem_usage(converted_float)) compare_floats = pd.concat([gl_float.dtypes,converted_float.dtypes],axis=1) compare_floats.columns = ['before','after'] compare_floats.apply(pd.Series.value_counts)</code> </pre> <br>  Das Ergebnis ist folgendes: <br><br> <code>100.99 MB <br> 50.49 MB</code> <br> <table><tbody><tr><td></td><td>  Zu <br></td><td>  Nachher <br></td></tr><tr><td>  float32 <br></td><td>  NaN <br></td><td>  77,0 <br></td></tr><tr><td>  float64 <br></td><td>  77,0 <br></td><td>  NaN <br></td></tr></tbody></table><br>  Infolgedessen speichern alle Spalten, in denen Gleitkommazahlen mit dem Datentyp <code>float64</code> jetzt Nummern vom Typ <code>float32</code> , wodurch die Speichernutzung um 50% reduziert wurde. <br><br>  Erstellen Sie eine Kopie des urspr√ºnglichen <code>DataFrame</code> , verwenden Sie diese optimierten numerischen Spalten anstelle der urspr√ºnglich darin enthaltenen und <code>DataFrame</code> Sie die gesamte Speichernutzung nach der Optimierung. <br><br><pre> <code class="plaintext hljs">optimized_gl = gl.copy() optimized_gl[converted_int.columns] = converted_int optimized_gl[converted_float.columns] = converted_float print(mem_usage(gl)) print(mem_usage(optimized_gl))</code> </pre> <br>  Folgendes haben wir: <br><br> <code>861.57 MB <br> 804.69 MB</code> <br> <br>  Obwohl wir den Speicherverbrauch durch Spalten, in denen numerische Daten gespeichert sind, im gesamten <code>DataFrame</code> erheblich reduziert haben, verringerte sich der Speicherverbrauch im Allgemeinen nur um 7%.  Die Optimierung der Speicherung von Objekttypen kann zu einer viel ernsthafteren Verbesserung einer Situation f√ºhren. <br><br>  Bevor wir diese Optimierung durchf√ºhren, werden wir uns genauer ansehen, wie Zeichenfolgen in Pandas gespeichert werden, und dies mit der Art und Weise vergleichen, wie Zahlen hier gespeichert werden. <br><br><h2>  <font color="#3AC1EF">Vergleich der Mechanismen zum Speichern von Zahlen und Zeichenfolgen</font> </h2><br>  Der <code>object</code> repr√§sentiert Werte unter Verwendung von Python-String-Objekten.  Dies liegt teilweise daran, dass NumPy die Darstellung fehlender Zeichenfolgenwerte nicht unterst√ºtzt.  Da Python eine hochinterpretierte Sprache ist, bietet es dem Programmierer keine Tools zur Feinabstimmung der Speicherung von Daten im Speicher. <br><br>  Diese Einschr√§nkung f√ºhrt dazu, dass Zeichenfolgen nicht in zusammenh√§ngenden Speicherfragmenten gespeichert werden, sondern dass ihre Darstellung im Speicher fragmentiert ist.  Dies f√ºhrt zu einer Erh√∂hung des Speicherverbrauchs und zu einer Verlangsamung der Arbeitsgeschwindigkeit mit Zeichenfolgenwerten.  Tats√§chlich ist jedes Element in der Spalte, in dem der Objektdatentyp gespeichert ist, ein Zeiger, der die ‚ÄûAdresse‚Äú enth√§lt, an der sich der tats√§chliche Wert im Speicher befindet. <br><br>  Das folgende Diagramm basiert auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem</a> Material und vergleicht das Speichern numerischer Daten mit NumPy-Datentypen und das Speichern von Zeichenfolgen mit den in Python integrierten Datentypen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d80/66f/54b/d8066f54b091531c120b94c90f698236.png"></div><br>  <i><font color="#999999">Speichern von numerischen Daten und Zeichenfolgendaten</font></i> <br><br>  Hier k√∂nnen Sie sich daran erinnern, dass in einer der obigen Tabellen gezeigt wurde, dass eine variable Speichermenge zum Speichern von Daten von Objekttypen verwendet wird.  Obwohl jeder Zeiger 1 Byte Speicher belegt, belegt jeder bestimmte Zeichenfolgenwert dieselbe Speichermenge, die zum Speichern einer einzelnen Zeichenfolge in Python verwendet werden w√ºrde.  Um dies zu best√§tigen, verwenden wir die Methode <code>sys.getsizeof()</code> .  Schauen Sie sich zuerst die einzelnen Zeilen und dann das <code>Series</code> pandas-Objekt an, in dem die Zeichenfolgendaten gespeichert sind. <br><br>  Also untersuchen wir zuerst die √ºblichen Zeilen: <br><br><pre> <code class="plaintext hljs">from sys import getsizeof s1 = 'working out' s2 = 'memory usage for' s3 = 'strings in python is fun!' s4 = 'strings in python is fun!' for s in [s1, s2, s3, s4]:   print(getsizeof(s))</code> </pre> <br>  Hier sehen die Speichernutzungsdaten folgenderma√üen aus: <br><br> <code>60 <br> 65 <br> 74 <br> 74</code> <br> <br>  Schauen wir uns nun an, wie die Verwendung von Zeichenfolgen im <code>Series</code> Objekt aussieht: <br><br><pre> <code class="plaintext hljs">obj_series = pd.Series(['working out',                         'memory usage for',                         'strings in python is fun!',                         'strings in python is fun!']) obj_series.apply(getsizeof)</code> </pre> <br>  Hier bekommen wir folgendes: <br><br><pre> <code class="plaintext hljs">0    60 1    65 2    74 3    74 dtype: int64</code> </pre> <br>  Hier k√∂nnen Sie sehen, dass die Gr√∂√üen der in <code>Series</code> Pandas-Objekten gespeicherten Linien ihren Gr√∂√üen √§hnlich sind, wenn Sie mit ihnen in Python arbeiten und sie als separate Entit√§ten darstellen. <br><br><h2>  <font color="#3AC1EF">Optimierung der Speicherung von Objekttypdaten unter Verwendung kategorialer Variablen</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kategoriale Variablen</a> erschienen in Pandas Version 0.15.  Der entsprechende Typ, <code>category</code> , verwendet in seinen internen Mechanismen ganzzahlige Werte anstelle der urspr√ºnglichen Werte, die in den Tabellenspalten gespeichert sind.  Pandas verwendet ein separates W√∂rterbuch, das die Entsprechung von Ganzzahl- und Anfangswerten festlegt.  Dieser Ansatz ist n√ºtzlich, wenn die Spalten Werte aus einer begrenzten Menge enthalten.  Wenn die in einer Spalte gespeicherten Daten in den <code>category</code> konvertiert werden, verwendet pandas den Untertyp <code>int</code> , der die effizienteste Speichernutzung erm√∂glicht und alle in der Spalte gefundenen eindeutigen Werte darstellen kann. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f5/48d/59c/1f548d59c9b41fd906d038c19d3a2da2.png"></div><br>  <i><font color="#999999">Quelldaten und kategoriale Daten unter Verwendung des Untertyps int8</font></i> <br><br>  Um genau zu verstehen, wo wir kategoriale Daten verwenden k√∂nnen, um den Speicherverbrauch zu reduzieren, ermitteln wir die Anzahl der eindeutigen Werte in den Spalten, in denen die Werte der Objekttypen gespeichert sind: <br><br><pre> <code class="plaintext hljs">gl_obj = gl.select_dtypes(include=['object']).copy() gl_obj.describe()</code> </pre> <br>  Was wir in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser</a> Tabelle haben, finden Sie auf dem Blatt <code>    </code> . <br><br>  In der Spalte <code>day_of_week</code> , dem Wochentag, an dem das Spiel gespielt wurde, befinden sich beispielsweise 171907 Werte.  Unter ihnen sind nur 7 einzigartig.  Insgesamt reicht ein Blick auf diesen Bericht aus, um zu verstehen, dass in vielen Spalten einige eindeutige Werte verwendet werden, um die Daten von ungef√§hr 172.000 Spielen darzustellen. <br><br>  Bevor wir eine vollst√§ndige Optimierung durchf√ºhren, w√§hlen wir eine Spalte aus, in der Objektdaten gespeichert sind, mindestens <code>day_of_week</code> , und sehen, was im Programm passiert, wenn es in einen kategorialen Typ konvertiert wird. <br><br>  Wie bereits erw√§hnt, enth√§lt diese Spalte nur 7 eindeutige Werte.  Um es in einen kategorialen Typ zu konvertieren, verwenden wir die Methode <code>.astype()</code> . <br><br><pre> <code class="plaintext hljs">dow = gl_obj.day_of_week print(dow.head()) dow_cat = dow.astype('category') print(dow_cat.head())</code> </pre> <br>  Folgendes haben wir: <br><br><pre> <code class="plaintext hljs">0    Thu 1    Fri 2    Sat 3    Mon 4    Tue Name: day_of_week, dtype: object 0    Thu 1    Fri 2    Sat 3    Mon 4    Tue Name: day_of_week, dtype: category Categories (7, object): [Fri, Mon, Sat, Sun, Thu, Tue, Wed]</code> </pre> <br>  Wie Sie sehen k√∂nnen, sehen die darin gespeicherten Daten wie zuvor aus, obwohl sich der Typ der Spalte ge√§ndert hat.  Schauen wir uns nun an, was im Programm passiert. <br><br>  Im folgenden Code verwenden wir das Attribut <code>Series.cat.codes</code> , um herauszufinden, welche ganzzahligen Werte der <code>category</code> f√ºr jeden Wochentag verwendet: <br><br><pre> <code class="plaintext hljs">dow_cat.head().cat.codes</code> </pre> <br>  Es gelingt uns Folgendes herauszufinden: <br><br><pre> <code class="plaintext hljs">0    4 1    0 2    2 3    1 4    5 dtype: int8</code> </pre> <br>  Hier k√∂nnen Sie sehen, dass jedem eindeutigen Wert ein ganzzahliger Wert zugewiesen ist und dass die Spalte jetzt vom Typ <code>int8</code> .  Es fehlen keine Werte, aber wenn dies der Fall w√§re, w√ºrde -1 verwendet, um solche Werte anzuzeigen. <br><br>  Vergleichen wir nun den Speicherverbrauch vor und nach der Konvertierung der Spalte <code>day_of_week</code> in den <code>category</code> . <br><br><pre> <code class="plaintext hljs">print(mem_usage(dow)) print(mem_usage(dow_cat))</code> </pre> <br>  Hier ist das Ergebnis: <br><br> <code>9.84 MB <br> 0.16 MB</code> <br> <br>  Wie Sie sehen, wurden zun√§chst 9,84 Megabyte Speicher verbraucht und nach der Optimierung nur 0,16 Megabyte, was einer 98% igen Verbesserung dieses Indikators entspricht.  Bitte beachten Sie, dass die Arbeit mit dieser Spalte wahrscheinlich eines der rentabelsten Optimierungsszenarien darstellt, wenn in einer Spalte mit ungef√§hr 172.000 Elementen nur 7 eindeutige Werte verwendet werden. <br><br>  Obwohl die Idee, alle Spalten in diesen Datentyp zu konvertieren, attraktiv erscheint, sollten Sie zuvor die negativen Nebenwirkungen einer solchen Konvertierung ber√ºcksichtigen.  Das schwerwiegendste Minus dieser Transformation ist also die Unm√∂glichkeit, arithmetische Operationen an kategorialen Daten durchzuf√ºhren.  Dies gilt auch f√ºr gew√∂hnliche arithmetische Operationen und die Verwendung von Methoden wie <code>Series.min()</code> und <code>Series.max()</code> ohne zuvor die Daten in einen reellen <code>Series.max()</code> zu konvertieren. <br><br>  Wir sollten die Verwendung des <code>category</code> auf haupts√§chlich Spalten beschr√§nken, in denen Daten vom Typ <code>object</code> gespeichert sind, in denen weniger als 50% der Werte eindeutig sind.  Wenn alle Werte in einer Spalte eindeutig sind, erh√∂ht die Verwendung des <code>category</code> die Speichernutzung.  Dies liegt daran, dass Sie im Speicher zus√§tzlich zu den numerischen Kategoriecodes die urspr√ºnglichen Zeichenfolgenwerte speichern m√ºssen.  Details zu Einschr√§nkungen des <code>category</code> finden Sie in der Pandas- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> . <br><br>  Erstellen Sie eine Schleife, die alle Spalten durchl√§uft, in denen Daten vom Typ <code>object</code> gespeichert sind, ermittelt, ob die Anzahl der eindeutigen Werte in den Spalten 50% √ºberschreitet, und konvertiert sie in die <code>category</code> . <br><br><pre> <code class="plaintext hljs">converted_obj = pd.DataFrame() for col in gl_obj.columns:   num_unique_values = len(gl_obj[col].unique())   num_total_values = len(gl_obj[col])   if num_unique_values / num_total_values &lt; 0.5:       converted_obj.loc[:,col] = gl_obj[col].astype('category')   else:       converted_obj.loc[:,col] = gl_obj[col]</code> </pre> <br>  Vergleichen Sie nun, was nach der Optimierung passiert ist, mit dem, was vorher passiert ist: <br><br><pre> <code class="plaintext hljs">print(mem_usage(gl_obj)) print(mem_usage(converted_obj)) compare_obj = pd.concat([gl_obj.dtypes,converted_obj.dtypes],axis=1) compare_obj.columns = ['before','after'] compare_obj.apply(pd.Series.value_counts)</code> </pre> <br>  Wir bekommen folgendes: <br><br> <code>752.72 MB <br> 51.67 MB</code> <br> <table><tbody><tr><td></td><td>  Zu <br></td><td>  Nachher <br></td></tr><tr><td>  Objekt <br></td><td>  78,0 <br></td><td>  NaN <br></td></tr><tr><td>  Kategorie <br></td><td>  NaN <br></td><td>  78,0 <br></td></tr></tbody></table><br>           <code>category</code> ,     ,          , ,      ,     ,    ,  ,     . <br><br>  ,  ,     ,    <code>object</code> ,   752   52 ,    93%.     ,          .  ,       ,   ,  ,     891 . <br><br><pre> <code class="plaintext hljs">optimized_gl[converted_obj.columns] = converted_obj mem_usage(optimized_gl)</code> </pre> <br>     : <br><br> <code>'103.64 MB'</code> <br> <br>  .     - .    ,       <code>datetime</code> , ,  ,        . <br><br><pre> <code class="plaintext hljs">date = optimized_gl.date print(mem_usage(date)) date.head()</code> </pre> <br>       : <br><br> <code>0.66 MB</code> <br> <br>    : <br><br><pre> <code class="plaintext hljs">0    18710504 1    18710505 2    18710506 3    18710508 4    18710509 Name: date, dtype: uint32</code> </pre> <br>  ,               <code>uint32</code> . -       <code>datetime</code>     ,         64 .       <code>datetime</code> ,  ,  ,          . <br><br>      <code>to_datetime()</code> ,  <code>format</code>    ,      <code>YYYY-MM-DD</code> . <br><br><pre> <code class="plaintext hljs">optimized_gl['date'] = pd.to_datetime(date,format='%Y%m%d') print(mem_usage(optimized_gl)) optimized_gl.date.head()</code> </pre> <br>    : <br><br> <code>104.29 MB</code> <br> <br>    : <br><br><pre> <code class="plaintext hljs">0   1871-05-04 1   1871-05-05 2   1871-05-06 3   1871-05-08 4   1871-05-09 Name: date, dtype: datetime64[ns]</code> </pre> <br><h2> <font color="#3AC1EF">    </font> </h2><br>            <code>DataFrame</code> .        , , ,   ,  ,  ,  ,  .       ,        .    ,     ,     ,     .        ,        ,      <code>DataFrame</code> ,   . <br><br>  ,             .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pandas.read_csv()</a>   ,   . ,  <code>dtype</code>  ,   ,   ,   ,     ‚Äî  NumPy. <br><br>      ,          ,   .         ,      . <br><br><pre> <code class="plaintext hljs">dtypes = optimized_gl.drop('date',axis=1).dtypes dtypes_col = dtypes.index dtypes_type = [i.name for i in dtypes.values] column_types = dict(zip(dtypes_col, dtypes_type)) #    161 ,  #  10  /   #     preview = first2pairs = {key:value for key,value in list(column_types.items())[:10]} import pprint pp = pp = pprint.PrettyPrinter(indent=4) pp.pprint(preview)     : {   'acquisition_info': 'category',   'h_caught_stealing': 'float32',   'h_player_1_name': 'category',   'h_player_9_name': 'category',   'v_assists': 'float32',   'v_first_catcher_interference': 'float32',   'v_grounded_into_double': 'float32',   'v_player_1_id': 'category',   'v_player_3_id': 'category',   'v_player_5_id': 'category'}</code> </pre> <br>          ,      ,    . <br><br>    - : <br><br><pre> <code class="plaintext hljs">read_and_optimized = pd.read_csv('game_logs.csv',dtype=column_types,parse_dates=['date'],infer_datetime_format=True) print(mem_usage(read_and_optimized)) read_and_optimized.head()</code> </pre> <br>       : <br><br> <code>104.28 MB</code> <br> <br>    ,     <code>   </code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . <br><br>  ,    <code>   </code>  <code>   </code> ,     ,  ,       .      pandas       861.6   104.28 ,     88% . <br><br><h2> <font color="#3AC1EF">  </font> </h2><br> ,  ,    ,     .     . <br><br><pre> <code class="plaintext hljs">optimized_gl['year'] = optimized_gl.date.dt.year games_per_day = optimized_gl.pivot_table(index='year',columns='day_of_week',values='date',aggfunc=len) games_per_day = games_per_day.divide(games_per_day.sum(axis=1),axis=0) ax = games_per_day.plot(kind='area',stacked='true') ax.legend(loc='upper right') ax.set_ylim(0,1) plt.show()</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b2/699/6a2/3b26996a26b73e9a3ce87f3ff22dcf34.png"></div><br> <i><font color="#999999">,    </font></i> <br><br>  ,  1920-      ,  ,    50 ,        . <br><br>  ,  ,    ,      50 ,   . <br><br>    ,      . <br><br><pre> <code class="plaintext hljs">game_lengths = optimized_gl.pivot_table(index='year', values='length_minutes') game_lengths.reset_index().plot.scatter('year','length_minutes') plt.show()</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a6d/6db/5d2/a6d6db5d2e6bdb7330ac8a0ff2a6febd.png"></div><br> <i><font color="#999999"> </font></i> <br><br>   ,   1940-         . <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>            pandas,         ,     <code>DataFrame</code> ,   90%.       : <br><br><ul><li>       ,   ,   ,    , . </li><li>        . </li></ul><br>  ,            , ,         ,    ,  ,       pandas,    ,    . <br><br>  <b>Liebe Leser!</b>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">eugene_bb</a> .    -  ,    ‚Äî    . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442516/">https://habr.com/ru/post/de442516/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de442504/index.html">PHP Xdebug-Proxy: Wenn die Standardfunktionen von Xdebug nicht ausreichen</a></li>
<li><a href="../de442506/index.html">Wird Russland f√ºr den illegalen Handel mit personenbezogenen Daten bestraft?</a></li>
<li><a href="../de442508/index.html">Wie udalenka die Innovation auf GitLab beschleunigt</a></li>
<li><a href="../de442512/index.html">Anpassung von Django ORM am Beispiel von ZomboDB</a></li>
<li><a href="../de442514/index.html">Verteilte Systeme. Entwurfsmuster. Buchbesprechung</a></li>
<li><a href="../de442518/index.html">Top 10 Web-Hacking-Techniken 2018</a></li>
<li><a href="../de442520/index.html">Fall. Einsparung von 300 000 p. pro Monat auf kontextbezogene Werbung</a></li>
<li><a href="../de442522/index.html">Intuitives RL (Reinforcement Learning): Einf√ºhrung in Advantage-Actor-Critic (A2C)</a></li>
<li><a href="../de442524/index.html">So erh√∂hen Sie die Sicherheit von Personalidentifikations- und Zugangskontrollsystemen</a></li>
<li><a href="../de442526/index.html">Die Geschichte der sowjetischen Kassettenrekorder (Teil 2): ‚Äã‚Äãder Boom von Walkmen, ein Ger√§t f√ºr den KGB und Tonbandger√§te</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>