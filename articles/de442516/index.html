<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔄 😉 👨🏻‍💼 Pandas Leitfaden zur Big Data-Analyse 🛌 🧙🏿 ❣️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Sie die Pandas-Bibliothek zum Analysieren kleiner Datensätze verwenden, deren Größe 100 Megabyte nicht überschreitet, wird die Leistung selten zu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pandas Leitfaden zur Big Data-Analyse</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/442516/"> Wenn Sie die Pandas-Bibliothek zum Analysieren kleiner Datensätze verwenden, deren Größe 100 Megabyte nicht überschreitet, wird die Leistung selten zum Problem.  Wenn es jedoch um die Untersuchung von Datensätzen geht, deren Größe mehrere Gigabyte erreichen kann, können Leistungsprobleme zu einer signifikanten Verlängerung der Datenanalysedauer führen und sogar dazu, dass aufgrund von Speichermangel keine Analyse durchgeführt werden kann. <br><br>  Während Tools wie Spark große Datenmengen (von Hunderten von Gigabyte bis zu mehreren Terabyte) effizient verarbeiten können, benötigen Sie normalerweise recht leistungsstarke und teure Hardware, um ihre Funktionen voll auszuschöpfen.  Und im Vergleich zu Pandas unterscheiden sie sich nicht in umfangreichen Werkzeugen für eine qualitativ hochwertige Reinigung, Forschung und Datenanalyse.  Bei mittelgroßen Datensätzen ist es am besten, Pandas effizienter einzusetzen, anstatt zu anderen Tools zu wechseln. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/gd/jg/60/gdjg60abxgti2otxocpd0ct2uci.jpeg"></a> <br><br>  In dem Material, das wir heute übersetzen, werden wir über die Funktionen der Arbeit mit Speicher bei der Verwendung von Pandas sprechen und darüber, wie der Speicherverbrauch einfach um fast 90% reduziert werden kann, indem einfach die entsprechenden Datentypen ausgewählt werden, die in den Spalten der Tabellendatenstrukturen des <code>DataFrame</code> . <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Arbeiten mit Daten zu Baseballspielen</font> </h2><br>  Wir werden mit Daten zu Baseballspielen der Major League arbeiten, die über 130 Jahre gesammelt und aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Retrosheet</a> entnommen wurden. <br><br>  Ursprünglich wurden diese Daten als 127 CSV-Dateien dargestellt, aber wir haben sie mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">csvkit</a> zu einem Datensatz <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zusammengefasst</a> und als erste Zeile der resultierenden Tabelle eine Zeile mit Spaltennamen hinzugefügt.  Wenn Sie möchten, können Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unsere Version</a> dieser Daten herunterladen und damit experimentieren, indem Sie den Artikel lesen. <br><br>  Beginnen wir mit dem Importieren eines Datensatzes und werfen einen Blick auf die ersten fünf Zeilen.  Sie finden sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser</a> Tabelle im <code>   </code> . <br><br><pre> <code class="plaintext hljs">import pandas as pd gl = pd.read_csv('game_logs.csv') gl.head()</code> </pre> <br>  Nachfolgend finden Sie Informationen zu den wichtigsten Spalten der Tabelle mit diesen Daten.  Wenn Sie die Erklärungen für alle Spalten lesen möchten, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">finden</a> Sie hier ein Datenwörterbuch für den gesamten Datensatz. <br><br><ul><li>  <code>date</code> - Datum des Spiels. </li><li>  <code>v_name</code> - Der Name des Gastteams. </li><li>  <code>v_league</code> - Liga der Gastmannschaft. </li><li>  <code>h_name</code> - Der Name der Heimmannschaft. </li><li>  <code>h_league</code> - Die Liga der Heimmannschaft. </li><li>  <code>v_score</code> - Punkte von der Auswärtsmannschaft. </li><li>  <code>h_score</code> - Punkte der Heimmannschaft. </li><li>  <code>v_line_score</code> - Eine Zusammenfassung der Punkte des Gastteams, zum Beispiel - <code>010000(10)00</code> . </li><li>  <code>h_line_score</code> - Eine Zusammenfassung der Punkte der Heimmannschaft, zum Beispiel - <code>010000(10)0X</code> . </li><li>  <code>park_id</code> - Die Kennung des Feldes, auf dem das Spiel gespielt wurde. </li><li>  <code>attendance</code> - Die Anzahl der Zuschauer. </li></ul><br>  Um allgemeine Informationen zum <code>DataFrame</code> Objekt zu erhalten, können Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DataFrame.info ()</a> -Methode verwenden.  Dank dieser Methode können Sie Informationen zur Größe eines Objekts, zu Datentypen und zur Speichernutzung erhalten. <br><br>  Standardmäßig <code>DataFrame</code> ungefähre Informationen zur Speichernutzung durch den <code>DataFrame</code> .  Wir sind an genauen Informationen interessiert, daher setzen wir den Parameter <code>memory_usage</code> auf <code>'deep'</code> . <br><br><pre> <code class="plaintext hljs">gl.info(memory_usage='deep')</code> </pre> <br>  Hier sind die Informationen, die wir erhalten haben: <br><br><pre> <code class="plaintext hljs">&lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 171907 entries, 0 to 171906 Columns: 161 entries, date to acquisition_info dtypes: float64(77), int64(6), object(78) memory usage: 861.6 MB</code> </pre> <br>  Wie sich herausstellte, haben wir 171.907 Zeilen und 161 Spalten.  Die Pandas-Bibliothek hat Datentypen automatisch erkannt.  Es gibt 83 Spalten mit numerischen Daten und 78 Spalten mit Objekten.  Objektspalten werden zum Speichern von Zeichenfolgendaten verwendet, und in Fällen, in denen die Spalte Daten unterschiedlichen Typs enthält. <br><br>  Um besser zu verstehen, wie Sie die Speichernutzung mit diesem <code>DataFrame</code> optimieren <code>DataFrame</code> , sprechen wir nun darüber, wie Pandas Daten im Speicher speichert. <br><br><h2>  <font color="#3AC1EF">Interne Ansicht eines DataFrame</font> </h2><br>  Innerhalb von Pandas werden Datenspalten in Blöcken mit Werten des gleichen Typs gruppiert.  Hier ist ein Beispiel dafür, wie die ersten 12 Spalten eines <code>DataFrame</code> in Pandas gespeichert werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d35/c70/c63/d35c70c635289a5cecc520c58e662e9a.png"></div><br>  <i><font color="#999999">Interne Darstellung verschiedener Datentypen in Pandas</font></i> <br><br>  Möglicherweise stellen Sie fest, dass Blöcke keine Spaltennameninformationen speichern.  Dies liegt daran, dass die Blöcke zum Speichern der in den Tabellenzellen des <code>DataFrame</code> Objekts verfügbaren Werte optimiert sind.  Die <code>BlockManager</code> Klasse ist dafür verantwortlich, Informationen über die Entsprechung zwischen den Zeilen- und Spaltenindizes des Datensatzes und darüber zu speichern, was in Blöcken desselben Datentyps gespeichert ist.  Es spielt die Rolle einer API, die den Zugriff auf Basisdaten ermöglicht.  Wenn wir Werte lesen, bearbeiten oder löschen, interagiert die <code>BlockManager</code> Klasse mit der <code>BlockManager</code> Klasse, um unsere Anforderungen in Funktions- und Methodenaufrufe zu konvertieren. <br><br>  Jeder Datentyp verfügt über eine spezielle Klasse im Modul <code>pandas.core.internals</code> .  Pandas verwendet beispielsweise die <code>ObjectBlock</code> Klasse, um Blöcke mit Zeichenfolgenspalten <code>FloatBlock</code> , und die <code>FloatBlock</code> Klasse, um Blöcke mit Spalten darzustellen, <code>FloatBlock</code> Gleitkommazahlen enthalten.  Bei Blöcken, die numerische Werte darstellen, die wie Ganzzahlen oder Gleitkommazahlen aussehen, kombiniert pandas die Spalten und speichert sie als <code>ndarray</code> Datenstruktur der NumPy-Bibliothek.  Diese Datenstruktur basiert auf dem Array C, die Werte werden in einem kontinuierlichen Speicherblock gespeichert.  Dank dieses Datenspeicherungsschemas ist der Zugriff auf Datenfragmente sehr schnell. <br><br>  Da Daten unterschiedlicher Typen separat gespeichert werden, untersuchen wir die Speichernutzung verschiedener Datentypen.  Beginnen wir mit der durchschnittlichen Speichernutzung für verschiedene Datentypen. <br><br><pre> <code class="plaintext hljs">for dtype in ['float','int','object']:   selected_dtype = gl.select_dtypes(include=[dtype])   mean_usage_b = selected_dtype.memory_usage(deep=True).mean()   mean_usage_mb = mean_usage_b / 1024 ** 2   print("Average memory usage for {} columns: {:03.2f} MB".format(dtype,mean_usage_mb))</code> </pre> <br>  Infolgedessen stellt sich heraus, dass die durchschnittlichen Indikatoren für die Speichernutzung für Daten verschiedener Typen folgendermaßen aussehen: <br><br><pre> <code class="plaintext hljs">Average memory usage for float columns: 1.29 MB Average memory usage for int columns: 1.12 MB Average memory usage for object columns: 9.53 MB</code> </pre> <br>  Diese Informationen machen uns verständlich, dass der größte Teil des Speichers für 78 Spalten zum Speichern von Objektwerten verwendet wird.  Wir werden später mehr darüber sprechen, aber jetzt überlegen wir, ob wir die Speichernutzung mit Spalten verbessern können, in denen numerische Daten gespeichert sind. <br><br><h2>  <font color="#3AC1EF">Untertypen</font> </h2><br>  Wie bereits erwähnt, stellen Pandas numerische Werte als <code>ndarray</code> NumPy-Datenstrukturen dar und speichern sie in zusammenhängenden Speicherblöcken.  Mit diesem Datenspeichermodell können Sie Speicherplatz sparen und schnell auf Werte zugreifen.  Da Pandas jeden Wert desselben Typs mit derselben Anzahl von Bytes darstellen und <code>ndarray</code> Strukturen Informationen über die Anzahl der Werte speichern, können Pandas schnell und genau Informationen über den Speicherbedarf von Spalten anzeigen, in denen numerische Werte gespeichert sind. <br><br>  Viele Datentypen in Pandas haben viele Untertypen, die weniger Bytes verwenden können, um jeden Wert darzustellen.  Der <code>float</code> Typ hat beispielsweise die Untertypen <code>float16</code> , <code>float32</code> und <code>float64</code> .  Die Zahl im Typnamen gibt die Anzahl der Bits an, die der Subtyp zur Darstellung der Werte verwendet.  Beispielsweise werden in den gerade aufgelisteten Untertypen 2, 4, 8 und 16 Bytes jeweils zur Datenspeicherung verwendet.  Die folgende Tabelle zeigt die Untertypen der am häufigsten verwendeten Datentypen in Pandas. <br><table><tbody><tr><td>  <sup>Speichernutzung, Bytes</sup> <sup><br></sup> </td><td>  <sup>Gleitkommazahl</sup> <sup><br></sup> </td><td>  <sup>Ganze Zahl</sup> <sup><br></sup> </td><td>  <sup>Ganzzahl ohne Vorzeichen</sup> <sup><br></sup> </td><td>  <sup>Datum und Uhrzeit</sup> <sup><br></sup> </td><td>  <sup>Boolescher Wert</sup> <sup><br></sup> </td><td width="75">  <sup>Objekt</sup> <sup><br></sup> </td></tr><tr><td>  <sup>1</sup> <sup><br></sup> </td><td></td><td>  <sup>int8</sup> <sup><br></sup> </td><td>  <sup>uint8</sup> <sup><br></sup> </td><td></td><td>  <sup>Bool</sup> <sup><br></sup> </td><td></td></tr><tr><td>  <sup>2</sup> <sup><br></sup> </td><td>  <sup>float16</sup> <sup><br></sup> </td><td>  <sup>int16</sup> <sup><br></sup> </td><td>  <sup>uint16</sup> <sup><br></sup> </td><td></td><td></td><td></td></tr><tr><td>  <sup>4</sup> <sup><br></sup> </td><td>  <sup>float32</sup> <sup><br></sup> </td><td>  <sup>int32</sup> <sup><br></sup> </td><td>  <sup>uint32</sup> <sup><br></sup> </td><td></td><td></td><td></td></tr><tr><td>  <sup>8</sup> <sup><br></sup> </td><td>  <sup>float64</sup> <sup><br></sup> </td><td>  <sup>int64</sup> <sup><br></sup> </td><td>  <sup>uint64</sup> <sup><br></sup> </td><td>  <sup>datetime64</sup> <sup><br></sup> </td><td></td><td></td></tr><tr><td>  <sup>Variable Speicherkapazität</sup> <sup><br></sup> </td><td></td><td></td><td></td><td></td><td></td><td>  <sup>Objekt</sup> <sup><br></sup> </td></tr></tbody></table><br>  Ein Wert vom Typ <code>int8</code> verwendet 1 Byte (8 Bit) zum Speichern einer Zahl und kann 256 Binärwerte (2 bis 8 Potenzen) darstellen.  Dies bedeutet, dass dieser Subtyp zum Speichern von Werten im Bereich von -128 bis 127 (einschließlich 0) verwendet werden kann. <br><br>  Mit der Methode <code>numpy.iinfo()</code> können Sie die für die Speicherung geeigneten Mindest- und Höchstwerte für jeden Ganzzahl-Subtyp <code>numpy.iinfo()</code> .  Betrachten Sie ein Beispiel: <br><br><pre> <code class="plaintext hljs">import numpy as np int_types = ["uint8", "int8", "int16"] for it in int_types:   print(np.iinfo(it))</code> </pre> <br>  Durch Ausführen dieses Codes erhalten wir die folgenden Daten: <br><br><pre> <code class="plaintext hljs">Machine parameters for uint8 --------------------------------------------------------------- min = 0 max = 255 --------------------------------------------------------------- Machine parameters for int8 --------------------------------------------------------------- min = -128 max = 127 --------------------------------------------------------------- Machine parameters for int16 --------------------------------------------------------------- min = -32768 max = 32767 ---------------------------------------------------------------</code> </pre> <br>  Hier können Sie auf den Unterschied zwischen den Typen <code>uint</code> (vorzeichenlose Ganzzahl) und <code>int</code> (vorzeichenbehaftete Ganzzahl) <code>uint</code> .  Beide Typen haben die gleiche Kapazität, aber wenn nur positive Werte in Spalten gespeichert werden, ermöglichen vorzeichenlose Typen eine effizientere Speichernutzung. <br><br><h2>  <font color="#3AC1EF">Optimierung der Speicherung numerischer Daten mithilfe von Untertypen</font> </h2><br>  Mit der Funktion <code>pd.to_numeric()</code> können numerische Typen <code>pd.to_numeric()</code> werden.  Um ganzzahlige Spalten auszuwählen, verwenden wir die Methode <code>DataFrame.select_dtypes()</code> . Anschließend optimieren wir sie und vergleichen die Speichernutzung vor und nach der Optimierung. <br><br><pre> <code class="plaintext hljs">#     ,   , #   ,      . def mem_usage(pandas_obj):   if isinstance(pandas_obj,pd.DataFrame):       usage_b = pandas_obj.memory_usage(deep=True).sum()   else: #     ,     DataFrame,   Series       usage_b = pandas_obj.memory_usage(deep=True)   usage_mb = usage_b / 1024 ** 2 #       return "{:03.2f} MB".format(usage_mb) gl_int = gl.select_dtypes(include=['int']) converted_int = gl_int.apply(pd.to_numeric,downcast='unsigned') print(mem_usage(gl_int)) print(mem_usage(converted_int)) compare_ints = pd.concat([gl_int.dtypes,converted_int.dtypes],axis=1) compare_ints.columns = ['before','after'] compare_ints.apply(pd.Series.value_counts)</code> </pre> <br>  Hier ist das Ergebnis einer Studie zum Speicherverbrauch: <br><br> <code>7.87 MB <br> 1.48 MB</code> <br> <table><tbody><tr><td></td><td>  Zu <br></td><td>  Nachher <br></td></tr><tr><td>  uint8 <br></td><td>  NaN <br></td><td>  5.0 <br></td></tr><tr><td>  uint32 <br></td><td>  NaN <br></td><td>  1.0 <br></td></tr><tr><td>  int64 <br></td><td>  6.0 <br></td><td>  NaN <br></td></tr></tbody></table><br>  Infolgedessen ist ein Rückgang der Speichernutzung von 7,9 auf 1,5 Megabyte zu verzeichnen, dh wir haben den Speicherverbrauch um mehr als 80% reduziert.  Die Gesamtauswirkung dieser Optimierung auf den ursprünglichen <code>DataFrame</code> ist jedoch nicht besonders stark, da nur sehr wenige ganzzahlige Spalten vorhanden sind. <br><br>  Machen wir dasselbe mit Spalten, die Gleitkommazahlen enthalten. <br><br><pre> <code class="plaintext hljs">gl_float = gl.select_dtypes(include=['float']) converted_float = gl_float.apply(pd.to_numeric,downcast='float') print(mem_usage(gl_float)) print(mem_usage(converted_float)) compare_floats = pd.concat([gl_float.dtypes,converted_float.dtypes],axis=1) compare_floats.columns = ['before','after'] compare_floats.apply(pd.Series.value_counts)</code> </pre> <br>  Das Ergebnis ist folgendes: <br><br> <code>100.99 MB <br> 50.49 MB</code> <br> <table><tbody><tr><td></td><td>  Zu <br></td><td>  Nachher <br></td></tr><tr><td>  float32 <br></td><td>  NaN <br></td><td>  77,0 <br></td></tr><tr><td>  float64 <br></td><td>  77,0 <br></td><td>  NaN <br></td></tr></tbody></table><br>  Infolgedessen speichern alle Spalten, in denen Gleitkommazahlen mit dem Datentyp <code>float64</code> jetzt Nummern vom Typ <code>float32</code> , wodurch die Speichernutzung um 50% reduziert wurde. <br><br>  Erstellen Sie eine Kopie des ursprünglichen <code>DataFrame</code> , verwenden Sie diese optimierten numerischen Spalten anstelle der ursprünglich darin enthaltenen und <code>DataFrame</code> Sie die gesamte Speichernutzung nach der Optimierung. <br><br><pre> <code class="plaintext hljs">optimized_gl = gl.copy() optimized_gl[converted_int.columns] = converted_int optimized_gl[converted_float.columns] = converted_float print(mem_usage(gl)) print(mem_usage(optimized_gl))</code> </pre> <br>  Folgendes haben wir: <br><br> <code>861.57 MB <br> 804.69 MB</code> <br> <br>  Obwohl wir den Speicherverbrauch durch Spalten, in denen numerische Daten gespeichert sind, im gesamten <code>DataFrame</code> erheblich reduziert haben, verringerte sich der Speicherverbrauch im Allgemeinen nur um 7%.  Die Optimierung der Speicherung von Objekttypen kann zu einer viel ernsthafteren Verbesserung einer Situation führen. <br><br>  Bevor wir diese Optimierung durchführen, werden wir uns genauer ansehen, wie Zeichenfolgen in Pandas gespeichert werden, und dies mit der Art und Weise vergleichen, wie Zahlen hier gespeichert werden. <br><br><h2>  <font color="#3AC1EF">Vergleich der Mechanismen zum Speichern von Zahlen und Zeichenfolgen</font> </h2><br>  Der <code>object</code> repräsentiert Werte unter Verwendung von Python-String-Objekten.  Dies liegt teilweise daran, dass NumPy die Darstellung fehlender Zeichenfolgenwerte nicht unterstützt.  Da Python eine hochinterpretierte Sprache ist, bietet es dem Programmierer keine Tools zur Feinabstimmung der Speicherung von Daten im Speicher. <br><br>  Diese Einschränkung führt dazu, dass Zeichenfolgen nicht in zusammenhängenden Speicherfragmenten gespeichert werden, sondern dass ihre Darstellung im Speicher fragmentiert ist.  Dies führt zu einer Erhöhung des Speicherverbrauchs und zu einer Verlangsamung der Arbeitsgeschwindigkeit mit Zeichenfolgenwerten.  Tatsächlich ist jedes Element in der Spalte, in dem der Objektdatentyp gespeichert ist, ein Zeiger, der die „Adresse“ enthält, an der sich der tatsächliche Wert im Speicher befindet. <br><br>  Das folgende Diagramm basiert auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem</a> Material und vergleicht das Speichern numerischer Daten mit NumPy-Datentypen und das Speichern von Zeichenfolgen mit den in Python integrierten Datentypen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d80/66f/54b/d8066f54b091531c120b94c90f698236.png"></div><br>  <i><font color="#999999">Speichern von numerischen Daten und Zeichenfolgendaten</font></i> <br><br>  Hier können Sie sich daran erinnern, dass in einer der obigen Tabellen gezeigt wurde, dass eine variable Speichermenge zum Speichern von Daten von Objekttypen verwendet wird.  Obwohl jeder Zeiger 1 Byte Speicher belegt, belegt jeder bestimmte Zeichenfolgenwert dieselbe Speichermenge, die zum Speichern einer einzelnen Zeichenfolge in Python verwendet werden würde.  Um dies zu bestätigen, verwenden wir die Methode <code>sys.getsizeof()</code> .  Schauen Sie sich zuerst die einzelnen Zeilen und dann das <code>Series</code> pandas-Objekt an, in dem die Zeichenfolgendaten gespeichert sind. <br><br>  Also untersuchen wir zuerst die üblichen Zeilen: <br><br><pre> <code class="plaintext hljs">from sys import getsizeof s1 = 'working out' s2 = 'memory usage for' s3 = 'strings in python is fun!' s4 = 'strings in python is fun!' for s in [s1, s2, s3, s4]:   print(getsizeof(s))</code> </pre> <br>  Hier sehen die Speichernutzungsdaten folgendermaßen aus: <br><br> <code>60 <br> 65 <br> 74 <br> 74</code> <br> <br>  Schauen wir uns nun an, wie die Verwendung von Zeichenfolgen im <code>Series</code> Objekt aussieht: <br><br><pre> <code class="plaintext hljs">obj_series = pd.Series(['working out',                         'memory usage for',                         'strings in python is fun!',                         'strings in python is fun!']) obj_series.apply(getsizeof)</code> </pre> <br>  Hier bekommen wir folgendes: <br><br><pre> <code class="plaintext hljs">0    60 1    65 2    74 3    74 dtype: int64</code> </pre> <br>  Hier können Sie sehen, dass die Größen der in <code>Series</code> Pandas-Objekten gespeicherten Linien ihren Größen ähnlich sind, wenn Sie mit ihnen in Python arbeiten und sie als separate Entitäten darstellen. <br><br><h2>  <font color="#3AC1EF">Optimierung der Speicherung von Objekttypdaten unter Verwendung kategorialer Variablen</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kategoriale Variablen</a> erschienen in Pandas Version 0.15.  Der entsprechende Typ, <code>category</code> , verwendet in seinen internen Mechanismen ganzzahlige Werte anstelle der ursprünglichen Werte, die in den Tabellenspalten gespeichert sind.  Pandas verwendet ein separates Wörterbuch, das die Entsprechung von Ganzzahl- und Anfangswerten festlegt.  Dieser Ansatz ist nützlich, wenn die Spalten Werte aus einer begrenzten Menge enthalten.  Wenn die in einer Spalte gespeicherten Daten in den <code>category</code> konvertiert werden, verwendet pandas den Untertyp <code>int</code> , der die effizienteste Speichernutzung ermöglicht und alle in der Spalte gefundenen eindeutigen Werte darstellen kann. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f5/48d/59c/1f548d59c9b41fd906d038c19d3a2da2.png"></div><br>  <i><font color="#999999">Quelldaten und kategoriale Daten unter Verwendung des Untertyps int8</font></i> <br><br>  Um genau zu verstehen, wo wir kategoriale Daten verwenden können, um den Speicherverbrauch zu reduzieren, ermitteln wir die Anzahl der eindeutigen Werte in den Spalten, in denen die Werte der Objekttypen gespeichert sind: <br><br><pre> <code class="plaintext hljs">gl_obj = gl.select_dtypes(include=['object']).copy() gl_obj.describe()</code> </pre> <br>  Was wir in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser</a> Tabelle haben, finden Sie auf dem Blatt <code>    </code> . <br><br>  In der Spalte <code>day_of_week</code> , dem Wochentag, an dem das Spiel gespielt wurde, befinden sich beispielsweise 171907 Werte.  Unter ihnen sind nur 7 einzigartig.  Insgesamt reicht ein Blick auf diesen Bericht aus, um zu verstehen, dass in vielen Spalten einige eindeutige Werte verwendet werden, um die Daten von ungefähr 172.000 Spielen darzustellen. <br><br>  Bevor wir eine vollständige Optimierung durchführen, wählen wir eine Spalte aus, in der Objektdaten gespeichert sind, mindestens <code>day_of_week</code> , und sehen, was im Programm passiert, wenn es in einen kategorialen Typ konvertiert wird. <br><br>  Wie bereits erwähnt, enthält diese Spalte nur 7 eindeutige Werte.  Um es in einen kategorialen Typ zu konvertieren, verwenden wir die Methode <code>.astype()</code> . <br><br><pre> <code class="plaintext hljs">dow = gl_obj.day_of_week print(dow.head()) dow_cat = dow.astype('category') print(dow_cat.head())</code> </pre> <br>  Folgendes haben wir: <br><br><pre> <code class="plaintext hljs">0    Thu 1    Fri 2    Sat 3    Mon 4    Tue Name: day_of_week, dtype: object 0    Thu 1    Fri 2    Sat 3    Mon 4    Tue Name: day_of_week, dtype: category Categories (7, object): [Fri, Mon, Sat, Sun, Thu, Tue, Wed]</code> </pre> <br>  Wie Sie sehen können, sehen die darin gespeicherten Daten wie zuvor aus, obwohl sich der Typ der Spalte geändert hat.  Schauen wir uns nun an, was im Programm passiert. <br><br>  Im folgenden Code verwenden wir das Attribut <code>Series.cat.codes</code> , um herauszufinden, welche ganzzahligen Werte der <code>category</code> für jeden Wochentag verwendet: <br><br><pre> <code class="plaintext hljs">dow_cat.head().cat.codes</code> </pre> <br>  Es gelingt uns Folgendes herauszufinden: <br><br><pre> <code class="plaintext hljs">0    4 1    0 2    2 3    1 4    5 dtype: int8</code> </pre> <br>  Hier können Sie sehen, dass jedem eindeutigen Wert ein ganzzahliger Wert zugewiesen ist und dass die Spalte jetzt vom Typ <code>int8</code> .  Es fehlen keine Werte, aber wenn dies der Fall wäre, würde -1 verwendet, um solche Werte anzuzeigen. <br><br>  Vergleichen wir nun den Speicherverbrauch vor und nach der Konvertierung der Spalte <code>day_of_week</code> in den <code>category</code> . <br><br><pre> <code class="plaintext hljs">print(mem_usage(dow)) print(mem_usage(dow_cat))</code> </pre> <br>  Hier ist das Ergebnis: <br><br> <code>9.84 MB <br> 0.16 MB</code> <br> <br>  Wie Sie sehen, wurden zunächst 9,84 Megabyte Speicher verbraucht und nach der Optimierung nur 0,16 Megabyte, was einer 98% igen Verbesserung dieses Indikators entspricht.  Bitte beachten Sie, dass die Arbeit mit dieser Spalte wahrscheinlich eines der rentabelsten Optimierungsszenarien darstellt, wenn in einer Spalte mit ungefähr 172.000 Elementen nur 7 eindeutige Werte verwendet werden. <br><br>  Obwohl die Idee, alle Spalten in diesen Datentyp zu konvertieren, attraktiv erscheint, sollten Sie zuvor die negativen Nebenwirkungen einer solchen Konvertierung berücksichtigen.  Das schwerwiegendste Minus dieser Transformation ist also die Unmöglichkeit, arithmetische Operationen an kategorialen Daten durchzuführen.  Dies gilt auch für gewöhnliche arithmetische Operationen und die Verwendung von Methoden wie <code>Series.min()</code> und <code>Series.max()</code> ohne zuvor die Daten in einen reellen <code>Series.max()</code> zu konvertieren. <br><br>  Wir sollten die Verwendung des <code>category</code> auf hauptsächlich Spalten beschränken, in denen Daten vom Typ <code>object</code> gespeichert sind, in denen weniger als 50% der Werte eindeutig sind.  Wenn alle Werte in einer Spalte eindeutig sind, erhöht die Verwendung des <code>category</code> die Speichernutzung.  Dies liegt daran, dass Sie im Speicher zusätzlich zu den numerischen Kategoriecodes die ursprünglichen Zeichenfolgenwerte speichern müssen.  Details zu Einschränkungen des <code>category</code> finden Sie in der Pandas- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> . <br><br>  Erstellen Sie eine Schleife, die alle Spalten durchläuft, in denen Daten vom Typ <code>object</code> gespeichert sind, ermittelt, ob die Anzahl der eindeutigen Werte in den Spalten 50% überschreitet, und konvertiert sie in die <code>category</code> . <br><br><pre> <code class="plaintext hljs">converted_obj = pd.DataFrame() for col in gl_obj.columns:   num_unique_values = len(gl_obj[col].unique())   num_total_values = len(gl_obj[col])   if num_unique_values / num_total_values &lt; 0.5:       converted_obj.loc[:,col] = gl_obj[col].astype('category')   else:       converted_obj.loc[:,col] = gl_obj[col]</code> </pre> <br>  Vergleichen Sie nun, was nach der Optimierung passiert ist, mit dem, was vorher passiert ist: <br><br><pre> <code class="plaintext hljs">print(mem_usage(gl_obj)) print(mem_usage(converted_obj)) compare_obj = pd.concat([gl_obj.dtypes,converted_obj.dtypes],axis=1) compare_obj.columns = ['before','after'] compare_obj.apply(pd.Series.value_counts)</code> </pre> <br>  Wir bekommen folgendes: <br><br> <code>752.72 MB <br> 51.67 MB</code> <br> <table><tbody><tr><td></td><td>  Zu <br></td><td>  Nachher <br></td></tr><tr><td>  Objekt <br></td><td>  78,0 <br></td><td>  NaN <br></td></tr><tr><td>  Kategorie <br></td><td>  NaN <br></td><td>  78,0 <br></td></tr></tbody></table><br>           <code>category</code> ,     ,          , ,      ,     ,    ,  ,     . <br><br>  ,  ,     ,    <code>object</code> ,   752   52 ,    93%.     ,          .  ,       ,   ,  ,     891 . <br><br><pre> <code class="plaintext hljs">optimized_gl[converted_obj.columns] = converted_obj mem_usage(optimized_gl)</code> </pre> <br>     : <br><br> <code>'103.64 MB'</code> <br> <br>  .     - .    ,       <code>datetime</code> , ,  ,        . <br><br><pre> <code class="plaintext hljs">date = optimized_gl.date print(mem_usage(date)) date.head()</code> </pre> <br>       : <br><br> <code>0.66 MB</code> <br> <br>    : <br><br><pre> <code class="plaintext hljs">0    18710504 1    18710505 2    18710506 3    18710508 4    18710509 Name: date, dtype: uint32</code> </pre> <br>  ,               <code>uint32</code> . -       <code>datetime</code>     ,         64 .       <code>datetime</code> ,  ,  ,          . <br><br>      <code>to_datetime()</code> ,  <code>format</code>    ,      <code>YYYY-MM-DD</code> . <br><br><pre> <code class="plaintext hljs">optimized_gl['date'] = pd.to_datetime(date,format='%Y%m%d') print(mem_usage(optimized_gl)) optimized_gl.date.head()</code> </pre> <br>    : <br><br> <code>104.29 MB</code> <br> <br>    : <br><br><pre> <code class="plaintext hljs">0   1871-05-04 1   1871-05-05 2   1871-05-06 3   1871-05-08 4   1871-05-09 Name: date, dtype: datetime64[ns]</code> </pre> <br><h2> <font color="#3AC1EF">    </font> </h2><br>            <code>DataFrame</code> .        , , ,   ,  ,  ,  ,  .       ,        .    ,     ,     ,     .        ,        ,      <code>DataFrame</code> ,   . <br><br>  ,             .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pandas.read_csv()</a>   ,   . ,  <code>dtype</code>  ,   ,   ,   ,     —  NumPy. <br><br>      ,          ,   .         ,      . <br><br><pre> <code class="plaintext hljs">dtypes = optimized_gl.drop('date',axis=1).dtypes dtypes_col = dtypes.index dtypes_type = [i.name for i in dtypes.values] column_types = dict(zip(dtypes_col, dtypes_type)) #    161 ,  #  10  /   #     preview = first2pairs = {key:value for key,value in list(column_types.items())[:10]} import pprint pp = pp = pprint.PrettyPrinter(indent=4) pp.pprint(preview)     : {   'acquisition_info': 'category',   'h_caught_stealing': 'float32',   'h_player_1_name': 'category',   'h_player_9_name': 'category',   'v_assists': 'float32',   'v_first_catcher_interference': 'float32',   'v_grounded_into_double': 'float32',   'v_player_1_id': 'category',   'v_player_3_id': 'category',   'v_player_5_id': 'category'}</code> </pre> <br>          ,      ,    . <br><br>    - : <br><br><pre> <code class="plaintext hljs">read_and_optimized = pd.read_csv('game_logs.csv',dtype=column_types,parse_dates=['date'],infer_datetime_format=True) print(mem_usage(read_and_optimized)) read_and_optimized.head()</code> </pre> <br>       : <br><br> <code>104.28 MB</code> <br> <br>    ,     <code>   </code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . <br><br>  ,    <code>   </code>  <code>   </code> ,     ,  ,       .      pandas       861.6   104.28 ,     88% . <br><br><h2> <font color="#3AC1EF">  </font> </h2><br> ,  ,    ,     .     . <br><br><pre> <code class="plaintext hljs">optimized_gl['year'] = optimized_gl.date.dt.year games_per_day = optimized_gl.pivot_table(index='year',columns='day_of_week',values='date',aggfunc=len) games_per_day = games_per_day.divide(games_per_day.sum(axis=1),axis=0) ax = games_per_day.plot(kind='area',stacked='true') ax.legend(loc='upper right') ax.set_ylim(0,1) plt.show()</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b2/699/6a2/3b26996a26b73e9a3ce87f3ff22dcf34.png"></div><br> <i><font color="#999999">,    </font></i> <br><br>  ,  1920-      ,  ,    50 ,        . <br><br>  ,  ,    ,      50 ,   . <br><br>    ,      . <br><br><pre> <code class="plaintext hljs">game_lengths = optimized_gl.pivot_table(index='year', values='length_minutes') game_lengths.reset_index().plot.scatter('year','length_minutes') plt.show()</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a6d/6db/5d2/a6d6db5d2e6bdb7330ac8a0ff2a6febd.png"></div><br> <i><font color="#999999"> </font></i> <br><br>   ,   1940-         . <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>            pandas,         ,     <code>DataFrame</code> ,   90%.       : <br><br><ul><li>       ,   ,   ,    , . </li><li>        . </li></ul><br>  ,            , ,         ,    ,  ,       pandas,    ,    . <br><br>  <b>Liebe Leser!</b>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">eugene_bb</a> .    -  ,    —    . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442516/">https://habr.com/ru/post/de442516/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de442504/index.html">PHP Xdebug-Proxy: Wenn die Standardfunktionen von Xdebug nicht ausreichen</a></li>
<li><a href="../de442506/index.html">Wird Russland für den illegalen Handel mit personenbezogenen Daten bestraft?</a></li>
<li><a href="../de442508/index.html">Wie udalenka die Innovation auf GitLab beschleunigt</a></li>
<li><a href="../de442512/index.html">Anpassung von Django ORM am Beispiel von ZomboDB</a></li>
<li><a href="../de442514/index.html">Verteilte Systeme. Entwurfsmuster. Buchbesprechung</a></li>
<li><a href="../de442518/index.html">Top 10 Web-Hacking-Techniken 2018</a></li>
<li><a href="../de442520/index.html">Fall. Einsparung von 300 000 p. pro Monat auf kontextbezogene Werbung</a></li>
<li><a href="../de442522/index.html">Intuitives RL (Reinforcement Learning): Einführung in Advantage-Actor-Critic (A2C)</a></li>
<li><a href="../de442524/index.html">So erhöhen Sie die Sicherheit von Personalidentifikations- und Zugangskontrollsystemen</a></li>
<li><a href="../de442526/index.html">Die Geschichte der sowjetischen Kassettenrekorder (Teil 2): ​​der Boom von Walkmen, ein Gerät für den KGB und Tonbandgeräte</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>