<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÇ üö• üöµüèø Fun√ß√£o n√£o reconhecida retarda o programa 5 vezes ü§≥üèΩ ‚úäüèº üç∂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Abrandando o Windows Parte 3: Encerramento do processo 



 O autor est√° empenhado em otimizar o desempenho do Chrome no Google - aprox. trans. 

 No ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fun√ß√£o n√£o reconhecida retarda o programa 5 vezes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432076/"> <b>Abrandando o Windows Parte 3: Encerramento do processo</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b55/8f1/93c/b558f193cbc015bf35b2b068ff1c8e65.jpg"><br><br>  <font color="gray">O autor est√° empenhado em otimizar o desempenho do Chrome no Google - aprox.</font>  <font color="gray">trans.</font> <br><br>  No ver√£o de 2017, lutei com um problema de desempenho do Windows.  O encerramento do processo foi lento, serializado e bloqueou a fila de entrada do sistema, o que levou a v√°rios congelamentos do cursor do mouse durante a montagem do Chrome.  O principal motivo foi que, no final dos processos, o Windows passou muito tempo pesquisando objetos GDI, mantendo a se√ß√£o cr√≠tica do usu√°rio global do sistema32.  Eu falei sobre isso no artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Processador de 24 n√∫cleos, mas n√£o consigo mover o cursor"</a> . <br><br>  A Microsoft corrigiu o erro e eu voltei para os meus neg√≥cios, mas acabou que o bug estava de volta.  Houve queixas sobre a opera√ß√£o lenta dos testes LLVM, com trocas frequentes de entrada. <br><br>  Mas, de fato, o bug n√£o retornou.  O motivo foi uma altera√ß√£o no nosso c√≥digo. <br><a name="habracut"></a><br><h1>  2017 issue </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/dcd/5f4/417/dcd5f4417f6d878a47d7d3c292a9304a.png" align="left">  Cada processo do Windows cont√©m v√°rios descritores de objetos GDI padr√£o.  Para processos que n√£o fazem nada com gr√°ficos, esses descritores geralmente s√£o NULL.  No final do processo, o Windows chama algumas fun√ß√µes para esses descritores, mesmo que sejam NULL.  N√£o importava - os recursos funcionavam rapidamente - at√© o lan√ßamento do Windows 10 Anniversary Edition, no qual <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">algumas altera√ß√µes de seguran√ßa tornavam esses recursos lentos</a> .  Durante a opera√ß√£o, eles mantiveram o mesmo bloqueio usado para eventos de entrada.  Quando um grande n√∫mero de processos √© finalizado ao mesmo tempo, cada um faz v√°rias chamadas para a fun√ß√£o lenta que cont√©m esse bloqueio cr√≠tico, o que leva a que a entrada do usu√°rio seja bloqueada e o cursor congela. <br><br>  O patch da Microsoft n√£o era para chamar essas fun√ß√µes para processos sem objetos GDI.  N√£o conhe√ßo os detalhes, mas acho que o patch da Microsoft era algo assim: <br><br> <code>+ if (IsGUIProcess()) <br> + NtGdiCloseProcess(); <br> ‚Äì NtGdiCloseProcess();</code> <br> <br>  Ou seja, pule a limpeza da GDI se o processo n√£o for um GUI / GDI. <br><br>  Como os compiladores e outros processos que criamos e finalizamos rapidamente n√£o usavam objetos GDI, esse patch acabou sendo suficiente para corrigir o congelamento da interface do usu√°rio. <br><br><h1>  Edi√ß√£o de 2018 </h1><br>  Aconteceu que os processos s√£o muito facilmente alocados a alguns objetos GDI padr√£o.  Se o seu processo carregar o gdi32.dll, voc√™ receber√° automaticamente objetos GDI (DC, superf√≠cies, regi√µes, pinc√©is, fontes etc.), independentemente de precisar ou n√£o deles (observe que esses objetos GDI padr√£o n√£o s√£o exibidos no Gerenciador de tarefas entre os objetos GDI para o processo). <br><br>  Mas isso n√£o deve ser um problema.  Quero dizer, por que o compilador carregaria o gdi32.dll?  Bem, descobriu-se que se voc√™ carregar user32.dll, shell32.dll, ole32.dll ou muitas outras DLLs, receber√° automaticamente o gdi32.dll (com os objetos GDI padr√£o acima mencionados).  E √© muito f√°cil baixar acidentalmente uma dessas bibliotecas. <br><br>  O LLVM testa ao carregar cada processo chamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CommandLineToArgvW</a> (shell32.dll) e, √†s vezes, chamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SHGetKnownFolderPath</a> (tamb√©m shell32.dll) Essas chamadas foram suficientes para retirar o gdi32.dll e gerar esses objetos GDI padr√£o assustadores.  Como o conjunto de testes do LLVM gera tantos processos, ele acaba sendo serializado na conclus√£o dos processos, causando enormes atrasos e congelamentos de entrada, muito piores do que os de 2017. <br><br>  Mas desta vez soubemos do principal problema do bloqueio e, imediatamente, soubemos o que fazer. <br><br>  Primeiro, nos livramos de chamar <i>CommandLineToArgvW</i> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">analisando manualmente a linha de comando</a> .  Depois disso, o conjunto de testes LLVM raramente chamava qualquer fun√ß√£o de qualquer DLL problem√°tica.  Mas sab√≠amos antecipadamente que isso n√£o afetaria o desempenho de nenhuma maneira.  O motivo foi que mesmo a chamada <i>condicional</i> restante era suficiente para sempre puxar shell32.dll, que por sua vez puxava gdi32.dll, que cria objetos GDI padr√£o. <br><br>  A segunda corre√ß√£o foi o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">atraso no carregamento do shell32.dll</a> .  Carregamento atrasado significa que a biblioteca carrega sob demanda - quando a fun√ß√£o √© chamada - em vez de carregar quando o processo √© iniciado.  Isso significava que o shell32.dll e o gdi32.dll seriam carregados raramente, e nem sempre. <br><br>  Depois disso, o conjunto de testes LLVM come√ßou a rodar <i>cinco vezes</i> mais r√°pido - em um minuto, em vez de cinco.  E o mouse n√£o congela mais nas m√°quinas de desenvolvimento, para que os funcion√°rios possam trabalhar normalmente durante a execu√ß√£o dos testes.  √â uma acelera√ß√£o louca por uma mudan√ßa t√£o modesta, e o autor dos patches ficou t√£o agradecido pela minha investiga√ß√£o que me indicou para um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">b√¥nus corporativo</a> . <br><br>  √Äs vezes, as menores mudan√ßas t√™m as maiores consequ√™ncias.  Voc√™ s√≥ precisa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">saber onde discar "zero"</a> . <br><br><h1>  Caminho de execu√ß√£o n√£o aceito </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/83d/1a9/e86/83d1a9e868d112a30dd4c37ea0caa9cb.jpg" align="left" width="350">  Vale repetir que prestamos aten√ß√£o ao c√≥digo que <i>n√£o foi executado</i> - e essa foi uma mudan√ßa fundamental.  Se voc√™ possui uma ferramenta de linha de comando que n√£o acessa o gdi32.dll, a adi√ß√£o de c√≥digo com uma chamada de fun√ß√£o <i>condicional</i> desacelerar√° o processo v√°rias vezes se o gdi32.dll estiver carregado.  No exemplo abaixo, <i>CommandLineToArgvW</i> nunca <i>√©</i> chamado, mas mesmo uma simples presen√ßa no c√≥digo (sem atraso de chamada) afeta adversamente o desempenho: <br><br><pre> <code class="plaintext hljs">int main(int argc, char* argv[]) { if (argc &lt; 0) { CommandLineToArgvW(nullptr, nullptr); // shell32.dll, pulls in gdi32.dll } }</code> </pre> <br>  Portanto, sim, remover uma chamada de fun√ß√£o, mesmo que o c√≥digo nunca seja executado, pode ser suficiente para melhorar significativamente o desempenho em alguns casos. <br><br><h1>  Reprodu√ß√£o patol√≥gica </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/8ab/f3f/4aa/8abf3f4aac933be4fe7cdb400727b049.png" align="left">  Quando investiguei o erro inicial, escrevi um programa ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ProcessCreateTests</a> ) que criou 1000 processos e depois os matou todos em paralelo.  Isso reproduziu o congelamento e, quando a Microsoft corrigiu o erro, usei um programa de teste para verificar o patch: veja o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">v√≠deo</a> .  Ap√≥s a reencarna√ß√£o do bug, alterei meu programa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">adicionando a op√ß√£o -user32</a> , que carrega o user32.dll para cada um dos milhares de processos de teste.  Como esperado, o tempo de conclus√£o de todos os processos de teste aumenta drasticamente com essa op√ß√£o e √© f√°cil detectar o congelamento do cursor do mouse.  O tempo de cria√ß√£o do processo tamb√©m aumenta com a op√ß√£o -user32, mas n√£o h√° suspens√µes do cursor durante a cria√ß√£o do processo.  Voc√™ pode usar este programa e ver o qu√£o terr√≠vel o problema pode ser.  Aqui est√£o alguns resultados t√≠picos do meu notebook de quatro n√∫cleos / oito threads ap√≥s uma semana de atividade.  A op√ß√£o -user32 aumenta o tempo para tudo, mas o bloqueio do <i>UserCrit</i> nos processos √© encerrado de maneira especialmente dram√°tica: <br><br> <code>&gt; ProcessCreatetests.exe <br> Process creation took 2.448 s (2.448 ms per process). <br> Lock blocked for 0.008 s total, maximum was 0.001 s. <br> <br> Process destruction took 0.801 s (0.801 ms per process). <br> Lock blocked for 0.004 s total, maximum was 0.001 s. <br> <br> &gt; ProcessCreatetests.exe -user32 <br> Testing with 1000 descendant processes with user32.dll loaded. <br> Process creation took 3.154 s (3.154 ms per process). <br> Lock blocked for 0.032 s total, maximum was 0.007 s. <br> <br> Process destruction took 2.240 s (2.240 ms per process). <br> Lock blocked for 1.991 s total, maximum was 0.864 s.</code> <br> <br><h1>  Indo mais fundo s√≥ por divers√£o </h1><br>  Pensei em alguns m√©todos ETW que podem ser usados ‚Äã‚Äãpara estudar o problema com mais detalhes e j√° comecei a escrev√™-los.  Mas me deparei com um comportamento inexplic√°vel, que decidi dedicar um artigo separado.  Basta dizer que, nesse caso, o Windows se comporta ainda mais estranhamente. <br><br>  Outros artigos da s√©rie: <br><br><ul><li>  Abrandando o Windows, parte 0: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">desacelera√ß√£o arbitr√°ria do VirtualAlloc</a> </li><li>  Abrandando o Windows, parte 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">acesso a arquivos</a> </li><li>  Abrandando o Windows Parte 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Criando processos</a> </li><li>  Abrandando o Windows, parte 3: isso </li></ul><br><h1>  Literatura </h1><br><ul><li>  Primeiro relat√≥rio de suspens√£o da interface do usu√°rio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Processador de 24 n√∫cleos, mas n√£o consigo mover o cursor"</a> </li><li>  O artigo a seguir, que leva ao entendimento do problema: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"O que * o * Windows faz enquanto mant√©m esse bloqueio"</a> </li><li>  Um artigo sobre <i>outro</i> bloco de interface do usu√°rio devido √† intera√ß√£o entre o Gmail, os funcion√°rios do ASLR v8, a pol√≠tica de aloca√ß√£o de mem√≥ria CFG e a verifica√ß√£o lenta da WMI: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"CPU de 24 n√∫cleos, mas n√£o consigo digitar um email"</a> </li><li>  O compilador que carrega o gdi32.dll parece estranho, mas √© ainda mais estranho que o compilador carregue o mshtml.dll, que o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">VC ++ costumava fazer em alguns casos</a> </li><li>  √Äs vezes, semanas de pesquisa levam a mudan√ßas pequenas, por√©m cr√≠ticas, conforme discutido no artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Saber onde discar zero"</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V√≠deo</a> demonstrando o uso de ProcessCreateTests e ETW para verificar uma corre√ß√£o de bug </li><li>  Primeira altera√ß√£o para o LLVM pela <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">an√°lise manual da linha de comandos</a> </li><li>  Segunda corre√ß√£o para o LLVM usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o atraso de carregamento do shell32.dll</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt432076/">https://habr.com/ru/post/pt432076/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt432064/index.html">Como escapar das lebres. Instru√ß√£o UV</a></li>
<li><a href="../pt432068/index.html">Como facilitar o estudo do ingl√™s: 5 servi√ßos √∫teis</a></li>
<li><a href="../pt432070/index.html">Brevemente sobre canais redux-saga</a></li>
<li><a href="../pt432072/index.html">Tr√™s tipos de vazamentos de mem√≥ria</a></li>
<li><a href="../pt432074/index.html">Como os jogadores rasgam o pano de realidade Spelunky com espingardas</a></li>
<li><a href="../pt432078/index.html">Tr√°fego no final do t√∫nel ou DNS no pentest</a></li>
<li><a href="../pt432080/index.html">Conceitos equivocados dos jogadores ao avaliar riscos. Controle do gerador de n√∫meros aleat√≥rios em desenvolvimento</a></li>
<li><a href="../pt432082/index.html">Microsoft AI Chatbot lan√ßa cole√ß√£o de roupas na China</a></li>
<li><a href="../pt432084/index.html">Como organizamos uma competi√ß√£o por turnos entre trabalhadores da produ√ß√£o (como na URSS)</a></li>
<li><a href="../pt432086/index.html">Impress√£o 3D na escola internacional com o nome de M.V. Lomonosov</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>