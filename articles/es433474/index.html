<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßöüèø ü§† ‚ôâÔ∏è Pylint de adentro hacia afuera. Como lo hace üç° ‚ô¶Ô∏è üë™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Varios ayudantes en la escritura de c√≥digo genial simplemente nos rodean, linter, typekchera, utilidad para encontrar vulnerabilidades, todo con nosot...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pylint de adentro hacia afuera. Como lo hace</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/433474/">  Varios ayudantes en la escritura de c√≥digo genial simplemente nos rodean, linter, typekchera, utilidad para encontrar vulnerabilidades, todo con nosotros.  Estamos acostumbrados y lo usamos sin entrar en detalles como una "caja negra".  Por ejemplo, pocas personas entienden los principios de Pylint, una de esas herramientas indispensables para optimizar y mejorar el c√≥digo Python. <br><br>  Pero <strong>Maxim Mazaev</strong> sabe lo importante que es comprender sus herramientas, y nos lo dijo en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Moscow Python Conf ++</a> .  Utilizando ejemplos de la vida real, mostr√≥ c√≥mo el conocimiento del dispositivo interno de Pylint y sus complementos ayud√≥ a reducir el tiempo de revisi√≥n del c√≥digo, mejorar la calidad del c√≥digo y, en general, mejorar la eficiencia del desarrollo.  A continuaci√≥n se muestra una instrucci√≥n de descifrado. <br><br><img src="https://habrastorage.org/webt/4d/mv/i7/4dmvi7slkt32taha4ec14e8kdfg.jpeg"><br><a name="habracut"></a><br><h2>  ¬øPor qu√© necesitamos Pylint? <br></h2><br>  Si ya lo usa, puede surgir la pregunta: "¬øPor qu√© saber qu√© hay dentro de Pylint, c√≥mo puede ayudar este conocimiento?" <br><br>  Por lo general, los desarrolladores escriben c√≥digo, inician la interfaz, reciben mensajes sobre qu√© mejorar, c√≥mo hacer que el c√≥digo sea m√°s hermoso y hacer los cambios propuestos.  Ahora el c√≥digo es m√°s f√°cil de leer y no se averg√ºenza de mostrar a sus colegas. <br><br>  Durante mucho tiempo, trabajaron exactamente de la misma manera con Pylint en el Instituto Cyan, con peque√±as adiciones: cambiaron las configuraciones, eliminaron reglas innecesarias y aumentaron la longitud m√°xima de la cadena. <br><br>  Pero en alg√∫n momento se encontraron con un problema, por lo que tuve que profundizar en Pylint y descubrir c√≥mo funciona.  ¬øCu√°l es este problema y c√≥mo resolverlo? Siga leyendo. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ZKoBZkdYLiM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Sobre el orador:</strong> Maxim Mazaev ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">barra invertida</a> ), 5 a√±os en desarrollo, trabaja en CIAN.  Aprende profundamente Python, asincron√≠a y programaci√≥n funcional. <br><br><h2>  Acerca de cian <br></h2><br>  La mayor√≠a cree que CIAN es una agencia de bienes ra√≠ces con agentes inmobiliarios y se sorprenden mucho cuando descubren que en lugar de agentes inmobiliarios tenemos programadores. <br><br>  Somos una empresa t√©cnica en la que no hay agentes inmobiliarios, pero hay muchos programadores. <br><br><ul><li>  1 mill√≥n de usuarios √∫nicos por d√≠a. </li><li>  El mayor tabl√≥n de anuncios para la venta y alquiler de bienes inmuebles en Mosc√∫ y San Petersburgo.  En 2018, ingresaron al nivel federal y trabajaron en toda Rusia. </li><li>  Casi 100 personas en el equipo de desarrollo, de las cuales 30 escriben c√≥digo Python diariamente. </li></ul><br>  Todos los d√≠as, cientos y miles de l√≠neas de c√≥digo nuevo entran en producci√≥n.  Los requisitos para el c√≥digo son bastante simples: <br><br><ul><li>  C√≥digo de calidad decente. </li><li>  Homogeneidad estil√≠stica.  Todos los desarrolladores deben escribir un c√≥digo similar, sin "vinagreta" en los repositorios. </li></ul><br>  Para lograr esto, por supuesto, necesita una revisi√≥n de c√≥digo. <br><br><h2>  Revisi√≥n de c√≥digo <br></h2><br>  La revisi√≥n del c√≥digo en CIAN se lleva a cabo en dos etapas: <br><br><ol><li>  La primera etapa es <strong>automatizada</strong> .  El robot Jenkins ejecuta las pruebas, ejecuta Pylint y verifica la consistencia de la API entre microservicios, ya que usamos microservicios.  Si en esta etapa las pruebas fallan o el linter muestra algo extra√±o, entonces esta es una ocasi√≥n para rechazar la solicitud de extracci√≥n y enviar el c√≥digo para su revisi√≥n. <br></li><li>  Si la primera etapa fue exitosa, entonces viene la segunda: aprobaci√≥n de <strong>dos</strong> <strong>desarrolladores</strong> .  Pueden evaluar qu√© tan bueno es el c√≥digo en t√©rminos de l√≥gica empresarial, aprobar una solicitud de extracci√≥n o devolver el c√≥digo para su revisi√≥n. <br></li></ol><br><h3><br>  Problemas de revisi√≥n de c√≥digo <br></h3><br>  La solicitud de extracci√≥n no puede pasar la revisi√≥n del c√≥digo debido a: <br><br><ul><li>  errores en la l√≥gica empresarial cuando un desarrollador ha resuelto un problema de manera ineficaz o incorrecta; </li><li>  problemas de estilo de c√≥digo. </li></ul><br>  ¬øCu√°les podr√≠an ser los problemas de estilo si la interfaz comprueba el c√≥digo? <br><br>  Todos los que escriben en Python saben que hay una gu√≠a para escribir c√≥digo <strong>PEP-8</strong> .  Como cualquier est√°ndar, PEP-8 es bastante general y para nosotros, como desarrolladores, esto no es suficiente.  Quiero especificar el est√°ndar en algunos lugares y expandirlo en otros. <br><br>  Por lo tanto, se nos ocurrieron nuestros arreglos internos sobre c√≥mo deber√≠a verse y funcionar el c√≥digo, y los llamamos <strong>"Rechazar propuestas cian"</strong> . <br><br><img src="https://habrastorage.org/webt/u8/rk/tw/u8rktwmht5bmkqktwuoof_kbohs.png"><br><br>  ‚ÄúRechazar propuestas de Cian‚Äù: un conjunto de reglas, ahora hay alrededor de 15. Cada una de estas reglas es la base para que la solicitud de extracci√≥n sea rechazada y enviada para su revisi√≥n. <br><br><h3>  ¬øQu√© dificulta una revisi√≥n productiva del c√≥digo? <br></h3><br><blockquote>  Hay un problema con nuestras reglas internas: el linter no las conoce y ser√≠a extra√±o que lo supiera, son internas. <br></blockquote>  El desarrollador que realiza la tarea siempre debe recordar y tener en cuenta las reglas.  Si olvida una de las reglas, en el proceso de revisi√≥n del c√≥digo, los revisores se√±alar√°n el problema, la tarea ir√° a revisi√≥n y el tiempo de liberaci√≥n de la tarea aumentar√°.  Despu√©s del refinamiento y correcci√≥n de errores, los evaluadores deben recordar lo que estaba en la tarea, para cambiar el contexto. <br><br>  Esto crea un problema tanto para el desarrollador como para los revisores.  Como resultado, la velocidad de revisi√≥n de c√≥digo se reduce cr√≠ticamente.  En lugar de analizar la l√≥gica del c√≥digo, los evaluadores comienzan a analizar el estilo visual, es decir, realizan el trabajo de la interfaz: escanean el c√≥digo l√≠nea por l√≠nea y buscan inconsistencias en la sangr√≠a en el formato de importaci√≥n. <br><br>  Nos gustar√≠a deshacernos de este problema. <br><br><h2>  Pero no nos escribas tu linter? <br></h2><br>  Parece que el problema se resolver√° con una herramienta que conocer√° todos los acuerdos internos y podr√° verificar el c√≥digo para su implementaci√≥n.  Entonces, ¬ønecesitamos nuestro propio linter? <br><br>  En realidad no  La idea es est√∫pida, porque ya usamos Pylint.  Este es un enlace conveniente, que le gusta a los desarrolladores y est√° integrado en todos los procesos: se ejecuta en Jenkins, genera informes hermosos que est√°n completamente satisfechos y en forma de comentarios llegan a la solicitud de extracci√≥n.  Todo est√° bien, <strong>no se necesita</strong> un <strong>segundo linter</strong> . <br><br>  Entonces, ¬øc√≥mo resolver el problema si no queremos escribir nuestro propio linter? <br><br><h2>  Escribir un complemento de Pylint <br></h2><br>  Puede escribir complementos para Pylint, se llaman correctores.  Bajo cada regla interna, puede escribir su propio corrector, que lo revisar√°. <br><br>  Considere dos ejemplos de tales damas. <br><br><h3>  Ejemplo no 1 <br></h3><br>  En alg√∫n momento, result√≥ que el c√≥digo contiene muchos comentarios de la forma "TODO": promete refactorizar, eliminar c√≥digo innecesario o reescribirlo maravillosamente, pero no ahora, sino m√°s tarde.  Hay un problema con tales comentarios: no te obligan a nada. <br><br><h4>  El problema <br></h4><br>  El desarrollador escribi√≥ una promesa, exhal√≥ y fue con tranquilidad para hacer la siguiente tarea. <br><img src="https://habrastorage.org/webt/ji/fk/js/jifkjskaly04vj5ljo74qrb0ys8.png"><br><br>  En resumen: <br><br><ul><li>  los comentarios con promesas se ciernen a lo largo de los a√±os y no se siguen; </li><li>  el c√≥digo est√° lleno de basura; </li><li>  La deuda t√©cnica se ha ido acumulando durante a√±os. </li></ul><br>  Por ejemplo, un desarrollador hace 3 a√±os prometi√≥ eliminar algo despu√©s de un lanzamiento exitoso, pero ¬øocurri√≥ el lanzamiento en 3 a√±os?  Quiz√°s si.  ¬øDebo eliminar el c√≥digo en este caso?  Esta es una gran pregunta, pero muy probablemente no. <br><br><h4>  Soluci√≥n: escriba su corrector para Pylint <br></h4><br>  No puede prohibir a los desarrolladores que escriban tales comentarios, pero puede hacer que hagan un trabajo adicional: cree una tarea en el rastreador para finalizar la promesa.  Entonces definitivamente no nos olvidaremos de ella. <br><br>  Necesitamos encontrar todos los comentarios del formulario TODO y asegurarnos de que cada uno de ellos tenga un enlace a una tarea en Jira.  Vamos a escribir <br><br>  ¬øQu√© es un corrector en t√©rminos de Pylint?  Esta es una clase que hereda de la clase base del verificador e implementa una determinada interfaz. <br><br><pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TodoIssueChecker</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(BaseChecker)</span></span></span><span class="hljs-class">:</span></span> _ _implements_ _ = IRawChecker</code> </pre> <br>  En nuestro caso, se trata de <strong>IRawChecker</strong> , el llamado verificador "sin procesar". <br><br>  Un verificador sin procesar itera sobre las l√≠neas de un archivo y puede realizar una determinada acci√≥n en una l√≠nea.  En nuestro caso, en cada l√≠nea, el verificador buscar√° algo similar a un comentario y un enlace a una tarea. <br><br>  Para el verificador, debe determinar la lista de mensajes que emitir√°: <br><br><pre> <code class="python hljs">msgs = { <span class="hljs-string"><span class="hljs-string">'9999'</span></span>: (<span class="hljs-string"><span class="hljs-string">'  TODO    '</span></span>, issue-code-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>-todo<span class="hljs-string"><span class="hljs-string">', '</span></span> <span class="hljs-string"><span class="hljs-string">')}</span></span></code> </pre><br>  El mensaje tiene: <br><br><ul><li>  la descripci√≥n es corta y larga; </li><li>  c√≥digo corrector y un nombre mnemot√©cnico corto que determina qu√© tipo de mensaje es. </li></ul><br>  El c√≥digo del mensaje tiene la forma "C1234", en la cual: <br><br><ul><li>  La primera letra est√° claramente estandarizada para diferentes tipos de mensajes: <strong>[C]</strong> invenci√≥n;  <strong>[W]</strong> arning;  <strong>[E]</strong> yog;  <strong>[F]</strong> atal;  <strong>[R]</strong> efactorizaci√≥n.  Gracias a la carta, el informe muestra de inmediato lo que est√° sucediendo: un recordatorio de los acuerdos o problemas fatales que deben abordarse con urgencia. </li><li>  4 n√∫meros aleatorios √∫nicos de Pylint. </li></ul><br>  El c√≥digo es necesario para deshabilitar la verificaci√≥n si se vuelve innecesario.  Puede escribir Pylint: deshabilitar y un c√≥digo alfanum√©rico corto o nombre mnemot√©cnico: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Pylint: disable=C9999 # Pylint: disable=issue-code-in-todo</span></span></code> </pre><br>  Los autores de Pylint recomiendan abandonar el c√≥digo alfanum√©rico y usar el mnemot√©cnico, es m√°s visual. <br><br>  El siguiente paso es definir un m√©todo llamado <strong>process_module</strong> . <br><br><img src="https://habrastorage.org/webt/25/cg/lc/25cglcdvsxu5qwgwv6fwhmhuvyu.jpeg"><br><br>  El nombre es muy importante.  El m√©todo deber√≠a llamarse as√≠, porque Pylint lo llamar√°. <br><br>  El par√°metro del <strong>nodo</strong> se pasa al m√≥dulo.  En este caso, no importa qu√© sea o de qu√© tipo sea, solo es importante recordar que el nodo tiene un m√©todo de <strong>flujo</strong> que devuelve un archivo l√≠nea por l√≠nea. <br><br>  Puede revisar el archivo y, para cada l√≠nea, verifique si hay comentarios y enlaces a la tarea.  Si hay un comentario, pero no hay un enlace, arroje una advertencia del formulario <strong>'issue-code-in-todo'</strong> con el c√≥digo del verificador y el n√∫mero de l√≠nea.  El algoritmo es bastante simple. <br><br>  Registre el corrector para que Pylint lo sepa.  Esto se hace mediante la funci√≥n de <strong>registro</strong> : <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">register</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(linter: Pylinter)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> linter. register_checker ( TodoIssueChecker(linter) )</code> </pre><br><ul><li>  Una instancia de Pylint entra en la funci√≥n. </li><li>  Llama al m√©todo register_checker. </li><li>  Pasamos el corrector al m√©todo. </li></ul><br>  <strong>Un punto importante: el</strong> m√≥dulo de verificaci√≥n debe estar en PYTHONPATH para que Pylint pueda importarlo m√°s tarde. <br><br>  Un verificador registrado es verificado por un archivo de prueba con comentarios sin enlaces a tareas. <br><br><pre> <code class="python hljs">$ cat work. <span class="hljs-comment"><span class="hljs-comment"># T0D0:   , -! $ pylint work. --load-plugins todo_checker ‚Ä¶</span></span></code> </pre><br>  Para la prueba, ejecute Pylint, pase el m√≥dulo, use el par√°metro <strong>load-plugins</strong> para pasar el verificador y, dentro de la interfaz, ejecute dos fases. <br><br><h4>  Fase 1. Inicializaci√≥n del complemento <br></h4><br><ul><li>  Todos los m√≥dulos con complementos son importados.  Pylint tiene inspectores internos y externos.  Todos se unen y son importados. </li><li>  Nos registramos - <strong>module.register (self)</strong> .  Para cada verificador, se llama a la funci√≥n de registro, donde se pasa la instancia de Pylint. </li><li>  Se realizan verificaciones: por la validez de los par√°metros, por la presencia de mensajes, opciones e informes en el formato correcto. </li></ul><br><h4>  Fase 2. Analiza el grupo de damas <br></h4><br>  Despu√©s de la fase 1, queda una lista completa de diferentes tipos de fichas: <br><br><ul><li>  Corrector AST; </li><li>  Corrector sin procesar; </li><li>  Comprobador de tokens. </li></ul><br><img src="https://habrastorage.org/webt/iy/o-/e9/iyo-e93tezy3y4iczp5d8regoog.jpeg"><br><br>  De la lista seleccionamos aquellos que se relacionan con la interfaz del verificador sin procesar: observamos qu√© verificadores implementan la interfaz IRawChecker y los tomamos para nosotros mismos. <br><br>  Para cada verificador seleccionado, llame al <strong>m√©todo checker.process_module (m√≥dulo)</strong> y ejecute el cheque. <br><br><h4>  Resultado <br></h4><br>  Ejecute el verificador en el archivo de prueba nuevamente: <br><br><pre> <code class="python hljs">$ cat work. <span class="hljs-comment"><span class="hljs-comment"># T0D0:   , -! $ pylint work,  --load-plugins todo_checker : 0,0:   T0D0     (issue-code-in-todo)</span></span></code> </pre><br>  Aparecer√° un mensaje que indica que hay un comentario con TODO y ning√∫n enlace a la tarea. <br><br>  El problema est√° resuelto y ahora, en el proceso de revisi√≥n del c√≥digo, los desarrolladores no necesitan escanear el c√≥digo con los ojos, buscar comentarios, escribir un recordatorio al autor del c√≥digo de que hay un acuerdo y es aconsejable dejar un enlace.  Todo sucede autom√°ticamente y la revisi√≥n de c√≥digo es un poco m√°s r√°pida. <br><br><h3>  Ejemplo No. 2. argumentos de palabras clave <br></h3><br>  Hay funciones que toman argumentos posicionales.  Si hay muchos argumentos, cuando llaman a la funci√≥n, no est√° muy claro d√≥nde est√° el argumento y por qu√© es necesario. <br><br><h4>  El problema <br></h4><br>  Por ejemplo, tenemos una funci√≥n: <br><br><pre> <code class="python hljs">get_offer_by_cian_id( <span class="hljs-string"><span class="hljs-string">"sale"</span></span>, rue, <span class="hljs-number"><span class="hljs-number">859483</span></span>, )</code> </pre><br>  El c√≥digo tiene <strong>venta</strong> y <strong>True,</strong> y no est√° claro lo que significan.  Es mucho m√°s conveniente cuando las funciones en las que hay muchos argumentos se llamar√≠an solo con argumentos con nombre: <br><br><pre> <code class="python hljs">get_offer_by_cian_id( deal_type=<span class="hljs-string"><span class="hljs-string">"sale"</span></span>, truncate=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, cian_id=<span class="hljs-number"><span class="hljs-number">859483</span></span>, )</code> </pre><br>  Este es un buen c√≥digo, en el que queda claro de inmediato d√≥nde est√° el par√°metro y no confundiremos su secuencia.  Intentemos escribir un corrector que verifique tales casos. <br><br>  El verificador "en bruto" utilizado en el ejemplo anterior es muy dif√≠cil de escribir para tal caso.  Puede agregar expresiones regulares s√∫per complejas, pero dicho c√≥digo es dif√≠cil de leer.  Es bueno que Pylint permita escribir otro tipo de corrector basado en el √°rbol de sintaxis abstracta <strong>AST</strong> , y lo usaremos. <br><br><h4>  Letras sobre AST <br></h4><br>  Un √°rbol de sintaxis abstracta o AST es una representaci√≥n en √°rbol del c√≥digo, donde el v√©rtice son los operandos y las hojas son operadores. <br><br>  Por ejemplo, una llamada de funci√≥n, donde hay un argumento posicional y dos argumentos nombrados, se transforma en un √°rbol abstracto: <br><img src="https://habrastorage.org/webt/k3/zi/hu/k3zihuknbk9txzbwffdwcwr5gf4.jpeg"><br><br>  Hay un v√©rtice con tipo <strong>Call</strong> y tiene: <br><br><ul><li>  atributos de funci√≥n llamados func; </li><li>  una lista de argumentos posicionales args, donde hay un nodo con tipo Const y un valor de 112; </li><li>  lista de argumentos nombrados Palabras clave. </li></ul><br>  La tarea en este caso: <br><br><ul><li>  Encuentre en el m√≥dulo todos los nodos con tipo Call (llamada a funci√≥n). </li><li>  Calcule el n√∫mero total de argumentos que toma la funci√≥n. </li><li>  Si hay m√°s de 2 argumentos, aseg√∫rese de que no haya argumentos posicionales en el nodo. </li><li>  Si hay argumentos posicionales, muestre una advertencia. </li></ul><br><br><pre> <code class="python hljs">ll( func=Name(name=<span class="hljs-string"><span class="hljs-string">'get_offer'</span></span>), args=[Const(value=<span class="hljs-number"><span class="hljs-number">1298880</span></span>)], keywords=[ ‚Ä¶ ]))]</code> </pre><br>  Desde el punto de vista de Pylint, un corrector basado en AST es una clase que hereda de la clase de corrector base e implementa la interfaz <strong>IAstroidChecker</strong> : <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NonKeywordArgsChecker</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(BaseChecker)</span></span></span><span class="hljs-class">:</span></span> -_ _implements_ _ = IAstroidChecker</code> </pre><br>  Como en el primer ejemplo, la descripci√≥n del verificador, el c√≥digo del mensaje, el nombre mnemot√©cnico corto se indican en la lista de mensajes: <br><br><pre> <code class="python hljs">msgs = { <span class="hljs-string"><span class="hljs-string">'9191'</span></span>: (<span class="hljs-string"><span class="hljs-string">' '</span></span>, keyword-only-args<span class="hljs-string"><span class="hljs-string">', '</span></span> <span class="hljs-string"><span class="hljs-string">')}</span></span></code> </pre><br>  El siguiente paso es definir el m√©todo <strong>visit_call</strong> : <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visit_call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, node: Call)</span></span></span><span class="hljs-function"> ‚Ä¶</span></span></code> </pre><br>  El m√©todo no tiene que llamarse as√≠.  Lo m√°s importante es el prefijo visit_, y luego viene el nombre del v√©rtice que nos interesa, con una letra min√∫scula. <br><br><ul><li>  El analizador AST recorre el √°rbol y, para cada v√©rtice, busca si el verificador tiene definida la interfaz visit_ &lt;Nombre&gt;. </li><li>  Si es as√≠, entonces ll√°malo. </li><li>  Recursivamente pasa por todos sus hijos. </li><li>  Al salir de un nodo, llama al m√©todo leave_ &lt;Nombre&gt;. </li></ul><br>  En este ejemplo, el m√©todo visit_call recibir√° un nodo de tipo Llamada como entrada y ver√° si tiene m√°s de dos argumentos y si existen argumentos posicionales para lanzar una advertencia y pasar el c√≥digo al propio nodo. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visit_call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, n)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node.args <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> len(node.args + node.keywords) &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>: self.add_message( <span class="hljs-string"><span class="hljs-string">'keyword-only-args'</span></span>, node=node )</code> </pre><br>  Registramos el verificador, como en el ejemplo anterior: transferimos la instancia de Pylint, llamamos a register_checker, pasamos el verificador y lo iniciamos. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">register</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(linter: Pylinter)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> linter.register_checker( TodoIssueChecker(linter) )</code> </pre><br>  Este es un ejemplo de una llamada de funci√≥n de prueba donde hay 3 argumentos y solo se nombra uno de ellos: <br><br><pre> <code class="python hljs">$ cat work. get_offers(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, deal_type=<span class="hljs-string"><span class="hljs-string">"sale"</span></span>) $ Pylint work.py --load-plugins non_kwargs_checker ‚Ä¶</code> </pre><br>  Esta es una funci√≥n que potencialmente se llama incorrectamente desde nuestro punto de vista.  Lanzamiento de Pylint. <br><br>  La fase 1 de inicializaci√≥n del complemento se repite completamente, como en el ejemplo anterior. <br><br><h4>  Fase 2. An√°lisis del m√≥dulo en AST <br></h4><br>  El c√≥digo se analiza en un √°rbol AST.  El an√°lisis lo realiza <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la biblioteca Astroid</a> . <br><br><h4>  Por qu√© Astroid, no AST (stdlib) <br></h4><br>  Astroid no utiliza internamente el m√≥dulo AST Python est√°ndar, sino el <strong>analizador AST typed_ast</strong> , caracterizado porque es compatible con las <strong>sugerencias de tipo</strong> PEP <strong>484. Typed_ast</strong> es una rama de AST, una bifurcaci√≥n que se desarrolla en paralelo.  Curiosamente, hay los mismos errores que est√°n en AST y se reparan en paralelo. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> module <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Entity <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bar)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># type: (Entity) -&gt; None return</span></span></code> </pre><br>  Anteriormente, Astroid usaba el m√≥dulo AST est√°ndar, en el cual uno pod√≠a encontrar el problema de usar los taiphints definidos en los comentarios usados ‚Äã‚Äãen el segundo Python.  Si verifica este c√≥digo a trav√©s de Pylint, hasta cierto punto jurar√≠a una importaci√≥n no utilizada, porque la clase de entidad importada solo est√° presente en el comentario. <br><br><blockquote>  En alg√∫n momento en GitHub, Guido Van Rossum lleg√≥ a Astroid y dijo: ‚ÄúChicos, tienen a Pylint que jura en tales casos, y tenemos un analizador AST mecanografiado que respalda todo esto.  ¬°Seamos amigos! <br></blockquote><br>  ¬°El trabajo ha comenzado a hervir!  Pasaron 2 a√±os, esta primavera Pylint cambi√≥ a un analizador AST mecanografiado y dej√≥ de maldecir por esas cosas.  Las importaciones de taiphints ya no se marcan como no utilizadas. <br><br>  Astroid usa un analizador AST para analizar el c√≥digo en un √°rbol, y luego hace algunas cosas interesantes al construirlo.  Por ejemplo, si usa <strong>import *</strong> , importa todo con un asterisco y lo agrega a los locales para evitar errores con las importaciones no utilizadas. <br><br>  <strong>Los complementos de transformaci√≥n</strong> se usan en casos en los que hay algunos modelos complejos basados ‚Äã‚Äãen metaclases, cuando todos los atributos se generan din√°micamente.  En este caso, Astroid es muy dif√≠cil de entender lo que significa.  Al verificar, Pylint jurar√° que los modelos no tienen dicho atributo cuando se accede, y usando los complementos Transformar puede resolver el problema: <br><br><ul><li>  Ayuda a Astroid a modificar el √°rbol abstracto y comprender la naturaleza din√°mica de Python. </li><li>  Suplemento AST con informaci√≥n √∫til. </li></ul><br>  Un ejemplo t√≠pico es <strong>pylint-django</strong> .  Cuando se trabaja con modelos django complejos, el linter a menudo jura atributos desconocidos.  Pylint-django simplemente resuelve este problema. <br><br><h4>  Fase 3. Analiza el grupo de damas <br></h4><br>  Regresamos al verificador.  Nuevamente tenemos una lista de verificadores, de los cuales encontramos aquellos que implementan la interfaz del verificador AST. <br><br><h4>  Fase 4. Analizar los verificadores por tipos de nodos <br></h4><br>  A continuaci√≥n, encontramos m√©todos para cada verificador, pueden ser de dos tipos: <br><br><ul><li>  visita_ &lt;Nombre de nodo&gt; </li><li>  leev_ &lt;nombre de nodo&gt;. </li></ul><br>  Ser√≠a bueno saber qu√© nodos necesita llamar para un nodo mientras camina en un √°rbol.  Por lo tanto, entienden el diccionario, donde la clave es el nombre del nodo, el valor es una lista de los verificadores que est√°n interesados ‚Äã‚Äãen el hecho de acceder a este nodo. <br><br><pre> <code class="python hljs">_visit_methods = dict( &lt; &gt; : [checker1, checker2 ... checkerN] )</code> </pre><br>  Lo mismo con los m√©todos de licencia: una clave en forma de nombre de nodo, una lista de verificadores que est√°n interesados ‚Äã‚Äãen el hecho de salir de este nodo. <br><br><pre> <code class="python hljs">_leave_methods = dict( &lt; &gt;: [checker1, checker2 ... checkerN] )</code> </pre><br>  Lanzamiento de Pylint.  Muestra una advertencia de que tenemos una funci√≥n donde hay m√°s de dos argumentos y hay un argumento posicional en ella: <br><br><pre> <code class="python hljs">$ cat work. get_offers(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, deal_type=<span class="hljs-string"><span class="hljs-string">"sale"</span></span>) $ Pylint work.py --load-plugins non_kwargs_checker C: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>:  c &gt;<span class="hljs-number"><span class="hljs-number">2</span></span>      (keyword-only-args)</code> </pre><br>  El problema est√° resuelto.  Ahora, los programadores de revisi√≥n de c√≥digo no necesitan leer los argumentos de la funci√≥n; el linter lo har√° por ellos.  <strong>Ahorramos nuestro tiempo</strong> , tiempo para la revisi√≥n del c√≥digo y las tareas van m√°s r√°pido en la producci√≥n. <br><br><h2>  ¬øY para escribir pruebas? <br></h2><br>  Pylint le permite realizar pruebas unitarias de las fichas y es muy simple.  Desde el punto de vista del linter, el verificador de prueba parece una clase que hereda del <strong>CheckerTestCase</strong> abstracto.  Es necesario indicar el verificador que se est√° verificando en √©l. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestNonKwArgsChecker</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(CheckerTestCase)</span></span></span><span class="hljs-class">:</span></span> CHECKER_CLASS = NonKeywordArgsChecker</code> </pre><br>  Paso 1. Creamos un nodo AST de prueba a partir de la parte del c√≥digo que estamos verificando. <br><br><pre> <code class="python hljs">node = astroid.extract_node( <span class="hljs-string"><span class="hljs-string">"get_offers(3, 'magic', 'args')"</span></span> )</code> </pre><br>  Paso 2. Verifique que el verificador, al ingresar al nodo, arroje o no arroje el mensaje correspondiente: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> self.assertAddsMessages(message): self.checker.visit_call(node)</code> </pre><br><h2>  Tokenchecker <br></h2><br>  Hay otro tipo de corrector llamado <strong>TokenChecker</strong> .  Funciona seg√∫n el principio de un analizador l√©xico.  Python tiene un m√≥dulo de <strong>tokenize</strong> que hace el trabajo de un esc√°ner l√©xico y divide el c√≥digo en una lista de tokens.  Puede verse m√°s o menos as√≠: <br><img src="https://habrastorage.org/webt/ul/vj/bl/ulvjblhatvsted81sc1drmjn2io.png"><br><br>  Los nombres de variables, los nombres de funciones y las palabras clave se convierten en tokens de tipo NAME, y los delimitadores, corchetes y dos puntos se convierten en tokens de tipo OP.  Adem√°s, hay tokens separados para sangr√≠a, avance de l√≠nea y traducci√≥n inversa. <br><br>  C√≥mo funciona Pylint con TokenChecker: <br><br><ul><li>  El m√≥dulo bajo prueba est√° tokenizado. </li><li>  Se pasa una gran lista de tokens a todos los verificadores que implementan ITokenChecker y se <strong>llama al</strong> m√©todo <strong>process_tokens</strong> (tokens). </li></ul><br>  No hemos encontrado el uso de TokenChecker, pero hay algunos ejemplos que utiliza Pylint: <br><br><ul><li>  <strong>Corrector ortogr√°fico</strong> .  Por ejemplo, puede tomar todos los tokens con texto de tipo y ver alfabetizaci√≥n l√©xica, verificar palabras de listas de palabras vac√≠as, etc. </li><li>  <strong>Comprobar sangr√≠as</strong> , espacios. </li><li>  <strong>Trabajar con cuerdas</strong> .  Por ejemplo, puede verificar que Python 3 no use literales Unicode, o verificar que solo los caracteres ASCI est√©n presentes en la cadena de bytes. </li></ul><br><h2>  Conclusiones <br></h2><br>  Tuvimos un problema con la revisi√≥n del c√≥digo.  Los desarrolladores realizaron el trabajo de la interfaz, dedicaron su tiempo a escanear c√≥digos sin sentido e informaron al autor sobre los errores.  Con Pylint nosotros: <br><br><ul><li>  Comprobaciones rutinarias transferidas al linter, implementado acuerdos internos en √©l. </li><li>  Mayor velocidad y revisi√≥n de c√≥digo de calidad. </li><li>  Se redujo el n√∫mero de solicitudes de extracci√≥n rechazadas, y el tiempo para pasar tareas en producci√≥n se ha reducido. </li></ul><br>  Un corrector simple se escribe en media hora y uno complejo en pocas horas.  El verificador ahorra mucho m√°s tiempo del que toma para escribir y lucha por varias solicitudes de extracci√≥n no rechazadas. <br><br>  Puede obtener m√°s informaci√≥n sobre Pylint y c√≥mo escribir fichas en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n oficial</a> , pero en t√©rminos de escribir fichas es bastante pobre.  Por ejemplo, sobre TokenChecker solo hay una menci√≥n all√≠, pero no sobre c√≥mo escribir el corrector en s√≠.  Hay m√°s informaci√≥n disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en las fuentes de Pylint en GitHub</a> .  Puedes ver qu√© fichas est√°n en el paquete est√°ndar e inspirarte para escribir el tuyo. <br><br>  <em>El conocimiento del dise√±o interno de Pylint ahorra horas hombre, simplifica</em> <em><br></em>  <em>rendimiento y mejora el c√≥digo.</em>  <em>Ahorre tiempo, escriba un buen c√≥digo y</em> <em><br></em>  <em>use linter.</em> <br><blockquote>  La pr√≥xima conferencia de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mosc√∫ Python Conf ++</a> se llevar√° a cabo <b>el 5 de abril de 2019</b> y ya puede reservar un boleto anticipado de birf ahora.  Es a√∫n mejor reunir sus pensamientos y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">solicitar</a> un informe, luego la visita ser√° gratuita y se ofrecer√°n bonitos panecillos como bonificaci√≥n, incluido el asesoramiento sobre la preparaci√≥n del informe. <br><br>  Nuestra conferencia es una plataforma para reunirse con personas de ideas afines, motores de la industria, para comunicar y discutir cosas que los desarrolladores de Python adoran: backend y web, recopilaci√≥n y procesamiento de datos, AI / ML, pruebas, IoT.  C√≥mo fue en el oto√±o, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mire el informe de video</a> en nuestro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">canal de Python</a> y suscr√≠base al canal; pronto publicaremos los mejores informes de la conferencia para acceso gratuito. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es433474/">https://habr.com/ru/post/es433474/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es433456/index.html">C√≥mo convencer a un cliente o empresa para que use Flutter</a></li>
<li><a href="../es433460/index.html">Simplifique las construcciones de edificios en Unity3D</a></li>
<li><a href="../es433466/index.html">Compara p√°ginas. Complemento simple para Atlassian Confluence</a></li>
<li><a href="../es433468/index.html">Inyecci√≥n de fallas: su sistema no es confiable si no ha intentado romperlo</a></li>
<li><a href="../es433472/index.html">Lanzamiento de Unity 2018.3</a></li>
<li><a href="../es433476/index.html">50 tonos de apio</a></li>
<li><a href="../es433478/index.html">Por qu√© Django es elegido en la revista Tinkoff</a></li>
<li><a href="../es433480/index.html">Holivarny historia sobre linter</a></li>
<li><a href="../es433482/index.html">Django bajo microscopio</a></li>
<li><a href="../es433486/index.html">Que otra vez La reactivaci√≥n de las tarjetas de d√©bito no bancarias</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>