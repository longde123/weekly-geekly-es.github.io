<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêÅ ‚öïÔ∏è üïπÔ∏è C #: Abw√§rtskompatibilit√§t und √úberlastung üç´ üåã üîπ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Kollegen! 

 Wir erinnern alle daran, dass wir ein gro√üartiges Mark Price-Buch haben: " C # 7 und .NET Core. Plattform√ºbergreifende Entwicklung ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C #: Abw√§rtskompatibilit√§t und √úberlastung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/414223/">  Hallo Kollegen! <br><br>  Wir erinnern alle daran, dass wir ein gro√üartiges Mark Price-Buch haben: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C # 7 und .NET Core. Plattform√ºbergreifende Entwicklung f√ºr Profis</a> ".  Bitte beachten Sie: Dies ist die dritte Ausgabe, die erste Ausgabe wurde in Version 6.0 geschrieben und erschien nicht in russischer Sprache. Die dritte Ausgabe wurde im November 2017 im Original ver√∂ffentlicht und umfasst Version 7.1. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qu/3r/yz/qu3ryzosqkh7hbufbfvfjcukuf8.jpeg"></div><br>  Nach der Ver√∂ffentlichung eines solchen Kompendiums, das einer separaten wissenschaftlichen Bearbeitung unterzogen wurde, um die Abw√§rtskompatibilit√§t und andere Korrektheit des vorgestellten Materials zu √ºberpr√ºfen, beschlossen wir, einen interessanten Artikel von John Skeet dar√ºber zu √ºbersetzen, welche bekannten und wenig bekannten Schwierigkeiten mit der Abw√§rtskompatibilit√§t in C # auftreten k√∂nnen.  Viel Spa√ü beim Lesen. <br><a name="habracut"></a><br>  Bereits im Juli 2017 habe ich begonnen, einen Artikel √ºber die Versionierung zu schreiben.  Bald gab es auf, weil das Thema zu umfangreich war, um es in nur einem Beitrag zu behandeln.  Bei einem solchen Thema ist es sinnvoller, eine ganze Site / ein Wiki / ein Repository hervorzuheben.  Ich hoffe, dass ich eines Tages auf dieses Thema zur√ºckkommen kann, da ich es f√ºr √§u√üerst wichtig halte und denke, dass es viel weniger Aufmerksamkeit erh√§lt, als es verdient. <br><br>  Im .NET-√ñkosystem wird die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">semantische Versionierung</a> normalerweise begr√º√üt - es klingt gro√üartig, erfordert jedoch, dass jeder gleicherma√üen versteht, was als ‚Äûgrundlegende √Ñnderung‚Äú angesehen wird.  Das habe ich mir schon lange gedacht.  Einer der Aspekte, die mich zuletzt beeindruckt haben, ist, wie schwierig es ist, grundlegende √Ñnderungen bei √úberladungsmethoden zu vermeiden.  Es geht (haupts√§chlich) darum, dass wir den Beitrag diskutieren, den Sie lesen;  Immerhin ist dieses Thema sehr interessant. <br>  Um loszulegen - eine kurze Definition ... <br><br>  <b>Quellen und Bin√§rkompatibilit√§t</b> <br><br>  Wenn ich meinen Clientcode mit der neuen Version der Bibliothek neu kompilieren kann und alles einwandfrei funktioniert, ist dies Kompatibilit√§t auf Quellcodeebene.  Wenn ich meine Client-Bin√§rdatei mit der neuen Version der Bibliothek erneut bereitstellen kann, ohne sie neu zu kompilieren, ist sie bin√§rkompatibel.  Nichts davon ist eine Obermenge des anderen: <br><br><ul><li>  Einige √Ñnderungen sind m√∂glicherweise nicht gleichzeitig mit dem Quellcode und dem Bin√§rcode kompatibel. Sie k√∂nnen beispielsweise nicht einen gesamten √∂ffentlichen Typ l√∂schen, von dem Sie vollst√§ndig abh√§ngig sind. </li><li>  Einige √Ñnderungen sind mit dem Quellcode kompatibel, jedoch nicht mit Bin√§rcode kompatibel. Wenn Sie beispielsweise ein √∂ffentliches schreibgesch√ºtztes statisches Feld in eine Eigenschaft konvertieren. </li><li>  Einige √Ñnderungen sind mit Bin√§rdateien kompatibel, jedoch nicht mit der Quelle. Sie k√∂nnen beispielsweise eine √úberladung hinzuf√ºgen, die beim Kompilieren zu Mehrdeutigkeiten f√ºhren kann. </li><li>  Einige √Ñnderungen sind sowohl mit dem Quell- als auch mit dem Bin√§rcode kompatibel - beispielsweise eine neue Implementierung des Methodenk√∂rpers. </li></ul><br>  <b>Wor√ºber reden wir also?</b> <br><br>  Angenommen, wir haben eine √∂ffentliche Bibliothek der Version 1.0 und m√∂chten dieser mehrere √úberladungen hinzuf√ºgen, um die Version 1.1 fertigzustellen.  Wir bleiben bei der semantischen Versionierung, daher ben√∂tigen wir Abw√§rtskompatibilit√§t.  Was bedeutet das, was wir k√∂nnen und was nicht, und k√∂nnen alle Fragen hier mit ‚ÄûJa‚Äú oder ‚ÄûNein‚Äú beantwortet werden? <br><br>  In verschiedenen Beispielen werde ich den Code in den Versionen 1.0 und 1.1 und dann den "Client" -Code (dh den Code, der die Bibliothek verwendet) zeigen, der aufgrund von √Ñnderungen besch√§digt werden kann.  Es wird weder Methodenk√∂rper noch Klassendeklarationen geben, da diese im Wesentlichen nicht wichtig sind - wir achten haupts√§chlich auf Signaturen.  Wenn Sie jedoch interessiert sind, k√∂nnen alle diese Klassen und Methoden leicht reproduziert werden.  Angenommen, alle hier beschriebenen Methoden befinden sich in der <code>Library</code> Klasse. <br><br>  Die einfachste denkbare √Ñnderung, geschm√ºckt mit der Umwandlung einer Gruppe von Methoden in einen Delegierten <br>  Das einfachste Beispiel, das mir in den Sinn kommt, ist das Hinzuf√ºgen einer parametrisierten Methode, bei der es bereits eine nicht parametrisierte gibt: <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//   1.0 public void Foo() //   1.1 public void Foo() public void Foo(int x)</span></span></code> </pre> <br><br>  Auch hier ist die Kompatibilit√§t unvollst√§ndig.  Betrachten Sie den folgenden Client-Code: <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//  static void Method() { var library = new Library(); HandleAction(library.Foo); } static void HandleAction(Action action) {} static void HandleAction(Action&lt;int&gt; action) {}</span></span></code> </pre> <br>  In der ersten Version der Bibliothek ist alles in Ordnung.  Durch Aufrufen der <code>HandleAction</code> Methode wird die Gruppe von Methoden in den <code>library.Foo</code> Delegaten konvertiert und als Ergebnis eine <code>Action</code> .  In Version 1.1 wird die Situation mehrdeutig: Eine Gruppe von Methoden kann in Aktion oder Aktion konvertiert werden.  Das hei√üt, genau genommen ist eine solche √Ñnderung nicht mit dem Quellcode kompatibel. <br><br>  In diesem Stadium ist es verlockend, einfach aufzugeben und sich zu versprechen, nie wieder √úberlastungen hinzuzuf√ºgen.  Oder wir k√∂nnen sagen, dass ein solcher Fall wahrscheinlich nicht genug Angst vor einem solchen Versagen hat.  Nennen wir die Transformationen einer Gruppe von Methoden vorerst au√üerhalb des Geltungsbereichs. <br><br>  <b>Nicht verwandte Referenztypen</b> <br><br>  Stellen Sie sich einen anderen Kontext vor, in dem Sie √úberladungen mit der gleichen Anzahl von Parametern verwenden m√ºssen.  Es ist davon auszugehen, dass eine solche √Ñnderung der Bibliothek zerst√∂rungsfrei ist: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  1.0 public void Foo(string x) //  1.1 public void Foo(string x) public void Foo(FileStream x)</span></span></code> </pre> <br>  Auf den ersten Blick ist alles logisch.  Wir behalten die urspr√ºngliche Methode bei, damit die Bin√§rkompatibilit√§t nicht beeintr√§chtigt wird.  Der einfachste Weg, dies zu unterbrechen, besteht darin, einen Aufruf zu schreiben, der in Version 1.0 funktioniert, jedoch nicht in Version 1.1 oder in beiden Versionen, jedoch auf unterschiedliche Weise. <br>  Welche Inkompatibilit√§t zwischen v1.0 und v1.1 kann ein solcher Aufruf verursachen?  Wir m√ºssen ein Argument haben, das sowohl mit <code>string</code> als auch mit <code>FileStream</code> kompatibel ist.  Dies sind jedoch Referenztypen, die nicht miteinander verwandt sind ... <br><br>  Der erste Fehler ist m√∂glich, wenn wir eine benutzerdefinierte implizite Konvertierung in <code>string</code> und <code>FileStream</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  class OddlyConvertible { public static implicit operator string(OddlyConvertible c) =&gt; null; public static implicit operator FileStream(OddlyConvertible c) =&gt; null; } static void Method() { var library = new Library(); var convertible = new OddlyConvertible(); library.Foo(convertible); }</span></span></code> </pre> <br>  Ich hoffe, das Problem liegt auf der Hand: Der Code, der zuvor eindeutig war und mit <code>string</code> ist jetzt mehrdeutig, da der Typ <code>OddlyConvertible</code> implizit in <code>string</code> und <code>FileStream</code> konvertiert werden <code>FileStream</code> (beide √úberladungen sind anwendbar, keine von ihnen ist besser als die andere). <br><br>  Vielleicht ist es in diesem Fall vern√ºnftig, benutzerdefinierte Konvertierungen zu verbieten ... aber dieser Code kann heruntergefahren werden und ist viel einfacher: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  static void Method() { var library = new Library(); library.Foo(null); }</span></span></code> </pre> <br>  Wir k√∂nnen ein Nullliteral implizit in einen beliebigen Referenztyp oder in einen nullwertf√§higen signifikanten Typ konvertieren. Daher ist die Situation in Version 1.1 wiederum nicht eindeutig.  Versuchen wir es noch einmal ... <br><br>  <b>Parameter von Referenztypen und nicht nullbaren signifikanten Typen</b> <br><br>  Angenommen, wir interessieren uns nicht f√ºr benutzerdefinierte Transformationen, aber wir m√∂gen keine problematischen Nullliterale.  Wie kann in diesem Fall eine √úberladung mit einem nicht nullbaren signifikanten Typ hinzugef√ºgt werden? <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//  1.0 public void Foo(string x) //  1.1 public void Foo(string x) public void Foo(int x)</span></span></code> </pre> <br>  Auf den ersten Blick ist es gut - <code>library.Foo(null)</code> funktioniert in Version <code>library.Foo(null)</code> einwandfrei.  Also ist er sicher?  Nein, nur nicht in C # 7.1 ... <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//  static void Method() { var library = new Library(); library.Foo(default); }</span></span></code> </pre> <br>  Das Standardliteral ist genau null, gilt jedoch f√ºr jeden Typ.  Dies ist sehr praktisch - und ein echtes Problem, wenn es um √úberlastung und Kompatibilit√§t geht :( <br><br>  <b>Optionale Parameter</b> <br><br>  Optionale Parameter sind ein weiteres Problem.  Angenommen, wir haben einen optionalen Parameter und m√∂chten einen zweiten hinzuf√ºgen.  Wir haben drei Optionen, die im Folgenden als 1.1a, 1.1b und 1.1c bezeichnet werden. <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//  1.0 public void Foo(string x = "") //  1.1a //   ,         public void Foo(string x = "") public void Foo(string x = "", string y = "") //  1.1b //          public void Foo(string x = "", string y = "") //  1.1c //   ,    ,   //  ,     . public void Foo(string x) public void Foo(string x = "", string y = "")</span></span></code> </pre> <br><br>  Was aber, wenn der Client zwei Anrufe t√§tigt: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  static void Method() { var library = new Library(); library.Foo(); library.Foo("xyz"); }</span></span></code> </pre><br>  Bibliothek 1.1a beh√§lt die Kompatibilit√§t auf Bin√§rebene bei, verst√∂√üt jedoch auf Quellcodeebene: Jetzt ist <code>library.Foo()</code> eindeutig.  Gem√§√ü den √úberladungsregeln in C # werden Methoden bevorzugt, bei denen der Compiler nicht alle verf√ºgbaren optionalen Parameter ‚Äûausf√ºllen‚Äú muss, jedoch nicht regelt, wie viele optionale Parameter gef√ºllt werden k√∂nnen. <br><br>  Bibliothek 1.1b beh√§lt die Kompatibilit√§t auf Quellenebene bei, verletzt jedoch die Bin√§rkompatibilit√§t.  Vorhandener kompilierter Code dient zum Aufrufen einer Methode mit einem einzelnen Parameter - und eine solche Methode existiert nicht mehr. <br><br>  Die 1.1c-Bibliothek beh√§lt die Bin√§rkompatibilit√§t bei, ist jedoch auf Quellcodeebene mit m√∂glichen √úberraschungen behaftet.  Jetzt wird der Aufruf <code>library.Foo()</code> in eine Methode mit zwei Parametern aufgel√∂st, w√§hrend <code>library.Foo("xyz")</code> in eine Methode mit einem Parameter aufgel√∂st wird (aus Sicht des Compilers ist dies einer Methode mit zwei Parametern vorzuziehen, haupts√§chlich weil keine optionalen Parameter vorhanden sind keine F√ºllung erforderlich).  Dies kann akzeptabel sein, wenn eine Version mit einem Parameter einfach Versionen mit zwei Parametern delegiert und in beiden F√§llen der gleiche Standardwert verwendet wird.  Es scheint jedoch seltsam, dass sich der Wert des ersten Aufrufs √§ndert, wenn die Methode, in die er zuvor aufgel√∂st wurde, noch vorhanden ist. <br><br>  Die Situation mit optionalen Parametern wird noch verwirrender, wenn Sie einen neuen Parameter nicht am Ende, sondern in der Mitte hinzuf√ºgen m√∂chten. Versuchen Sie beispielsweise, die Vereinbarung einzuhalten und den optionalen Parameter CancellationToken ganz am Ende beizubehalten.  Ich werde nicht darauf eingehen ... <br><br>  <b>Verallgemeinerte Methoden</b> <br><br>  Das Abschlie√üen von Typen in den besten Zeiten war keine leichte Aufgabe.  Wenn es darum geht, √úberlastungen zu beheben, wird diese Arbeit zu einem einheitlichen Albtraum. <br><br>  Angenommen, wir haben in Version 1.0 nur eine nicht verallgemeinerte Methode, und in Version 1.1 f√ºgen wir eine weitere verallgemeinerte Methode hinzu. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  1.0 public void Foo(object x) //  1.1 public void Foo(object x) public void Foo&lt;T&gt;(T x)</span></span></code> </pre> <br>  Auf den ersten Blick ist es nicht so be√§ngstigend ... aber mal sehen, was im Client-Code passiert: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  static void Method() { var library = new Library(); library.Foo(new object()); library.Foo("xyz"); }</span></span></code> </pre> <br>  In der Bibliothek v1.0 werden beide Aufrufe in <code>Foo(object)</code> - der einzigen verf√ºgbaren Methode. <br><br>  Die v1.1-Bibliothek ist abw√§rtskompatibel: Wenn Sie die f√ºr v1.1 kompilierte ausf√ºhrbare Client-Datei verwenden, verwenden beide Aufrufe weiterhin <code>Foo(object)</code> .  Im Falle einer Neukompilierung wechselt der zweite Aufruf (und nur der zweite) zur Arbeit mit der verallgemeinerten Methode.  Beide Methoden gelten f√ºr beide Aufrufe. <br><br>  Beim ersten Aufruf zeigt die Typinferenz, dass <code>T</code> ein <code>object</code> , sodass die Konvertierung des Arguments in den Parametertyp in beiden F√§llen auf <code>object</code> im <code>object</code> reduziert <code>object</code> .  Gro√üartig.  Der Compiler wendet die Regel an, dass nicht generische Methoden generischen Methoden immer vorzuziehen sind. <br><br>  Beim zweiten Aufruf zeigt die Typinferenz, dass <code>T</code> immer eine <code>string</code> ist. Wenn Sie also ein Argument in einen Typparameter konvertieren, erhalten Sie f√ºr die urspr√ºngliche Methode eine <code>string</code> f√ºr ein <code>object</code> oder f√ºr die verallgemeinerte Methode eine <code>string</code> f√ºr eine <code>string</code> .  Die zweite Transformation ist ‚Äûbesser‚Äú, daher wird die zweite Methode gew√§hlt. <br><br>  Wenn die beiden Methoden auf die gleiche Weise funktionieren, ist das in Ordnung.  Wenn nicht, wird die Kompatibilit√§t auf eine nicht offensichtliche Weise unterbrochen. <br><br>  <b>Vererbung und dynamische Eingabe</b> <br><br>  Entschuldigung, ich bin schon au√üer Atem.  Sowohl die Vererbung als auch die dynamische Typisierung beim Aufl√∂sen von √úberlastungen k√∂nnen sich auf die ‚Äûcoolste‚Äú und mysteri√∂seste Weise manifestieren. <br>  Wenn wir eine solche Methode auf einer Ebene der Vererbungshierarchie hinzuf√ºgen, die die Methode der Basisklasse √ºberlastet, wird die neue Methode zuerst verarbeitet und der Methode der Basisklasse vorgezogen, auch wenn die Methode der Basisklasse beim Konvertieren eines Arguments in einen Typparameter genauer ist.  Es gibt genug Platz, um alles durcheinander zu bringen. <br><br>  Gleiches gilt f√ºr die dynamische Eingabe (im Client-Code).  Bis zu einem gewissen Grad wird die Situation unvorhersehbar.  Sie haben die Sicherheit beim Kompilieren bereits ernsthaft geopfert. Seien Sie also nicht √ºberrascht, wenn etwas kaputt geht. <br><br>  <b>Zusammenfassung</b> <br><br>  Ich habe versucht, die Beispiele in diesem Artikel einfach genug zu gestalten.  Alles wird sehr kompliziert und sehr schnell, wenn Sie viele optionale Parameter haben.  Die Versionierung ist eine komplizierte Angelegenheit, mein Kopf schwillt an. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de414223/">https://habr.com/ru/post/de414223/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de414213/index.html">Eins zwei drei! Chatbot von Google Sheets am Beispiel eines PvP-Spiels f√ºr Alice</a></li>
<li><a href="../de414215/index.html">Benutzerdefinierte Bl√∂cke in Chips (Silicon IP): So funktioniert es</a></li>
<li><a href="../de414217/index.html">Lokale Vertex-Smartphones: zuerst in der Qualit√§t, zuerst in den Chips, zuerst im Design</a></li>
<li><a href="../de414219/index.html">Die Erfahrung mit der Nutzung von Solarenergie in der Region Moskau: f√ºr, gegen und wer sie braucht</a></li>
<li><a href="../de414221/index.html">Analysieren und Arbeiten mit Codable in Swift 4</a></li>
<li><a href="../de414225/index.html">Erstellen eines eigenen Netzwerks von hausgemachten Ger√§ten basierend auf Arduino (Teil 1)</a></li>
<li><a href="../de414227/index.html">Eine neue Studie zu Telegrammindikatoren nach dem Blockieren: Abonnenten wachsen, Abdeckung sinkt</a></li>
<li><a href="../de414229/index.html">Analyse verschiedener IT-Schulungsmethoden</a></li>
<li><a href="../de414231/index.html">Wie ich einen v√∂llig leisen Computer gemacht habe</a></li>
<li><a href="../de414233/index.html">1. Basierend auf Meyers "Effektives und modernes c ++" - Inferenz des Vorlagentyps</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>