<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌞 👨🏻‍💻 🏂🏾 Anda akan membenci ini atau dongeng tentang bagaimana kode yang baik seharusnya terlihat 🥛 🦉 🦃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari baik untuk semua Beberapa waktu lalu saya berbicara kepada siswa tentang topik “Apa yang kita harapkan dari kode yang baik” dan memutuskan untuk ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Anda akan membenci ini atau dongeng tentang bagaimana kode yang baik seharusnya terlihat</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429732/"><p><img src="https://habrastorage.org/webt/rt/m5/sc/rtm5scrsf_9nwof5hhonc3jslx0.jpeg" alt="Berapa banyak yang rusak dan masih akan rusak mencari kode yang sempurna.  Rupanya tiba telah tiba dan saya harus mengambil bagian dalam hal ini :)"></p><br><p>  Hari baik untuk semua  Beberapa waktu lalu saya berbicara kepada siswa tentang topik “Apa yang kita harapkan dari kode yang baik” dan memutuskan untuk menduplikasinya di sini.  Dalam proses penerjemahan, teksnya agak berubah, tetapi esensinya tetap sama.  Artikel itu ternyata sederhana (dan tentu saja tidak lengkap), tetapi ada butir rasional di sini. </p><a name="habracut"></a><br><h2 id="kod-dolzhen-rabotat">  Kode harus berfungsi </h2><br><p><img src="https://habrastorage.org/webt/fm/zg/gh/fmzgghanlo02sc7wjcgw1qx0hdk.jpeg" alt="Hal-hal yang jelas tidak mengurangi masalah dari fakta bahwa mereka jelas. Banyak proyek yang runtuh hanya karena pengembangannya berubah sepenuhnya dari penyelesaian masalah pengguna nyata"></p><br><p>  Mari kita bicara tentang apa yang kita harapkan dari kode.  Yah, sebagai permulaan, itu harus bekerja. </p><br><p>  Kedengarannya jelas, tentu saja, tetapi masing-masing dari kita pernah mencoba atau berhasil meluncurkan kode yang bahkan tidak akan, jadi jangan tertawa.  Poin kedua - kode harus bekerja dengan benar dengan situasi yang salah.  Itu untuk menangkap kesalahan.  Tapi mari kita kembali ke poin pertama dan membicarakannya sedikit. </p><br><p>  Secara berkala, saya mendapatkan tugas yang saya tidak tahu caranya.  Artinya, secara umum (saya mencoba melihat-lihat dan terus-menerus mencoba sesuatu yang baru).  Dan di sini saya langsung tertarik untuk menulis beberapa abstraksi, semacam infrastruktur, untuk menunda momen pekerjaan nyata.  Jadi ini salah.  Kode harus bekerja.  Saya tahu bahwa saya mengulangi sendiri, tetapi ini adalah poin penting.  Jika Anda tidak tahu cara menyelesaikan masalah, jangan buru-buru membuat antarmuka, modul, dan itu saja.  Ini adalah ide yang buruk, yang akan berakhir di akhir waktu Anda, dan Anda tidak akan pergi ke mana pun.  Ingat, kode yang berfungsi buruk berkali-kali lebih baik daripada baik, tetapi bukan kode yang berfungsi. </p><br><p>  Ada perumpamaan lama tentang dua perusahaan perangkat lunak yang membuat produk yang sama.  Yang pertama melakukan apa pun, tetapi yang pertama masuk pasar, dan yang kedua melakukan semuanya dengan sempurna dan sudah terlambat.  Akibatnya, kampanye pertama berhasil menaklukkan pasar dan membeli perusahaan kedua.  Ini sedikit tentang yang lain, tetapi gagasan utamanya masih sama.  Pertama kita memecahkan masalah, lalu kita membuat kodenya indah. </p><br><p>  Secara umum, pertama-tama buat prototipe yang berfungsi.  Biarkan itu lumpuh, bengkok dan tidak bahagia, tetapi ketika ditanya, Anda dapat mengatakan bahwa solusinya sudah ada, ia tetap mengintegrasikannya.  Dan menulis ulang sebagaimana mestinya.  Anda dapat mencoba untuk mengekspresikan ini dengan pepatah seperti itu - jika Anda tahu bagaimana melakukan tugas - lakukan dengan baik.  Jika Anda tidak tahu, pertama-tama atasi saja. </p><br><p>  Dan ada poin penting.  Saya ingin Anda mengerti.  Ini bukan panggilan untuk menulis kode yang buruk.  Kode harus bagus.  Ini adalah panggilan ke First Thing First - pertama kodenya berfungsi, kemudian ia menjadi refactor. </p><br><p>  Sekarang mari kita bicara tentang Sial Terjadi.  Jadi, kita punya kodenya, bahkan berfungsi.  Sebaliknya, itu "bekerja."  Mari kita lihat contoh sederhana: </p><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Do</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (WebClient xx = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebClient()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xx.DownloadString(<span class="hljs-string"><span class="hljs-string">"https://some.super.url"</span></span>); } }</code> </pre> <br><p>  Ini adalah contoh yang bagus untuk kode "berfungsi".  Mengapa  Karena itu tidak memperhitungkan bahwa cepat atau lambat, titik akhir kami akan jatuh.  Contoh ini tidak memperhitungkan yang disebut tepi kasus - batas, "kasus buruk".  Ketika Anda mulai menulis kode, pikirkan apa yang salah.  Sebenarnya, saya tidak hanya berbicara tentang panggilan jarak jauh, tetapi tentang semua sumber daya yang berada di luar kendali Anda - input pengguna, file, koneksi jaringan, bahkan database.  Semua yang dapat dipatahkan akan pecah pada saat yang paling tidak tepat dan satu-satunya hal yang dapat Anda lakukan dengannya adalah bersiaplah untuk itu sebanyak mungkin. </p><br><p>  Sayangnya, tidak semua masalah begitu jelas.  Ada sejumlah bidang masalah yang hampir pasti menghasilkan bug.  Misalnya, bekerja dengan lokal, dengan zona waktu.  Menyedihkan dan berteriak "semuanya berfungsi di mesin saya."  Mereka hanya perlu tahu dan bekerja dengan mereka dengan cermat. </p><br><p>  Omong-omong tentang input pengguna.  Ada prinsip yang sangat baik, yang mengatakan bahwa input pengguna apa pun dianggap salah hingga dibuktikan sebaliknya.  Dengan kata lain, selalu validasikan apa yang dimasukkan pengguna.  Dan ya, di server juga. </p><br><p>  Total: </p><br><ul><li>  Pertama buat kode berfungsi, </li><li>  Lalu buat dia baik-baik saja </li><li>  Jangan lupa tentang kasus tepi dan penanganan kesalahan. </li></ul><br><h2 id="teper-pogovorim-o-podderzhke-koda">  Sekarang mari kita bicara tentang dukungan kode </h2><br><p>  Dukungan adalah konsep yang kompleks, tetapi saya akan memasukkan tiga komponen di sini - kode harus mudah dibaca, mudah diubah, dan konsisten. </p><br><p>  Siapa yang menulis komentar dalam bahasa Rusia?  Tidak ada yang menulis?  Bagus  Secara umum, salah satu masalahnya adalah kode non-Inggris.  Jangan lakukan itu.  Saya memiliki sepotong kode dengan kelas-kelas di Norwegia, dan saya tidak bisa mengucapkan nama mereka.  Menyedihkan.  Jelas, mendukung kode semacam itu (untuk non-Norwegia) tidak akan menjadi tugas yang sepele.  Tapi ini jarang terjadi. </p><br><p>  Secara umum, kemudahan membaca adalah tentang penamaan dan struktur.  Nama-nama entitas - kelas, metode, variabel, harus sederhana, mudah dibaca dan membawa makna.  Ambil contoh kami sebelumnya. </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Do</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (WebClient xx = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebClient()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xx.DownloadString(<span class="hljs-string"><span class="hljs-string">"https://some.super.url"</span></span>); } }</code> </pre> <br><p>  Bisakah Anda memahami apa yang dilakukan metode Do meskipun penerapannya?  Hampir tidak.  Begitu pula dengan nama variabel.  Untuk memahami objek xx apa yang Anda butuhkan untuk mencari deklarasi.  Ini membutuhkan waktu kita, mencegah kita dari memahami apa, secara umum, yang terjadi dalam kode.  Oleh karena itu, nama harus mencerminkan esensi dari tindakan atau makna.  Misalnya, jika Anda mengganti nama metode Do ke ​​GetUserName, kode menjadi sedikit lebih jelas dan dalam beberapa kasus kami tidak lagi harus melihat implementasinya.  Demikian pula dengan nama variabel dalam bentuk x dan xx.  Benar, ada pengecualian yang diterima secara umum dalam bentuk e untuk kesalahan, i, k untuk penghitung siklus, n untuk dimensi, dan beberapa lainnya. </p><br><p>  Sekali lagi, sebagai contoh, ambil kode Anda yang Anda tulis sebulan yang lalu dan cobalah untuk membacanya dengan lancar.  Apakah Anda mengerti apa yang sedang terjadi di sana?  Jika demikian, saya ucapkan selamat kepada Anda.  Jika tidak, maka Anda memiliki masalah dengan keterbacaan kode. </p><br><p>  Secara umum, ada kutipan yang menarik: </p><br><blockquote>  "Hanya ada dua hal yang sulit dalam Ilmu Komputer: pembatalan cache dan penamaan hal-hal."  © Phil Karlton </blockquote><p>  <em>Hanya ada dua hal kompleks dalam Ilmu Komputer: pembatalan dan penamaan cache.</em> </p><br><p>  Ingat dia ketika Anda memberi nama pada entitas Anda. </p><br><p>  Komponen kedua dari kode yang dapat dibaca adalah kompleksitas atau strukturnya.  Saya berbicara tentang mereka yang suka menulis enam ifas bersarang, atau menulis panggilan balik ke panggilan balik di dalam panggilan balik.  JavaScript bahkan memiliki istilah yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Callback Hell</a> . </p><br><p><img src="https://habrastorage.org/webt/za/z9/s-/zaz9s-rf8qxjd81dcprgtck1iti.jpeg" alt="Berbicara tentang kode sempurna itu mudah, tetapi menulisnya sedikit lebih sulit. Hal terpenting di sini adalah setidaknya untuk tidak membohongi diri sendiri. Jika kode Anda buruk - jangan menyebutnya permen, tetapi ambil dan selesaikan"></p><br><p>  Kasihanilah kolega Anda dan diri Anda sendiri.  Setelah satu minggu, Anda harus benar-benar mengarungi kode ini untuk memperbaiki atau menambahkan sesuatu di dalamnya.  Menghindari ini tidak begitu sulit: </p><br><ul><li>  Tulis fungsi singkat, </li><li>  Hindari banyak bercabang atau bersarang, </li><li>  Pisahkan blok kode logis menjadi fungsi-fungsi terpisah bahkan jika Anda tidak akan menggunakannya kembali, </li><li>  Gunakan polimorfisme alih-alih jika </li></ul><br><p>  Sekarang mari kita bicara tentang satu hal yang lebih rumit - kode yang baik itu mudah diubah.  Siapa yang tahu istilah Big ball of mud?  Jika seseorang tidak terbiasa - lihat gambar. </p><br><p><img src="https://habrastorage.org/webt/f7/im/z8/f7imz8vdygpsaphm_5xjnpqfs5w.png" alt="Secara umum, dalam hal ini, saya sangat suka open source. Ketika kode Anda terbuka untuk seluruh dunia, saya ingin membuatnya setidaknya normal."></p><br><p>  Setiap modul tergantung pada masing-masing modul dan perubahan kontrak di satu tempat cenderung menyebabkan munculnya rubah kutub atau, setidaknya, untuk debug yang sangat lama.  Secara teoritis, berurusan dengan ini cukup sederhana - kurangi ketergantungan kode Anda pada kode Anda sendiri.  Semakin sedikit kode Anda yang tahu tentang detail implementasi, semakin baik untuk itu.  Namun dalam praktiknya, ini jauh lebih rumit, dan mengarah pada komplikasi ulang kode. </p><br><p>  Dalam bentuk tips, saya akan begini: </p><br><ul><li>  Sembunyikan kode Anda sedalam mungkin.  Bayangkan besok Anda harus menghapusnya secara manual dari proyek.  Berapa banyak tempat yang harus Anda perbaiki dan seberapa sulitnya?  Cobalah untuk meminimalkan jumlah ini. </li><li>  Hindari ketergantungan melingkar.  Pisahkan kode menjadi beberapa lapisan (logika, antarmuka, akses data) dan pastikan bahwa lapisan pada level "bawah" tidak bergantung pada lapisan pada level "atas".  Misalnya, akses ke data tidak harus bergantung pada antarmuka pengguna. </li><li>  Kelompokkan fungsi ke dalam modul (proyek, folder) dan sembunyikan kelas di dalamnya, hanya menyisakan fasad dan antarmuka. </li></ul><br><p>  Dan menggambar.  Cukup gambarkan di selembar kertas bagaimana data Anda diproses oleh aplikasi dan kelas apa yang digunakan untuk ini.  Ini akan membantu Anda memahami tempat-tempat yang terlalu rumit sebelum semuanya menjadi tidak dapat diperbaiki. </p><br><p>  Dan akhirnya tentang keseragaman.  Selalu berusaha untuk mematuhi gaya seragam yang diadopsi oleh tim, bahkan jika itu tampak salah bagi Anda.  Ini berlaku untuk pemformatan, dan pendekatan untuk memecahkan masalah.  Jangan gunakan ~~ untuk pembulatan, bahkan jika itu lebih cepat.  Tim tidak akan menghargainya.  Dan ketika mulai menulis kode baru, selalu perhatikan proyeknya, mungkin sesuatu yang Anda butuhkan telah diimplementasikan dan Anda dapat menggunakannya kembali. </p><br><p>  Total: </p><br><ul><li>  Penamaan yang tepat </li><li>  Struktur yang baik </li><li>  Keseragaman. </li></ul><br><h2 id="kod-dolzhen-byt-dostatochno-proizvoditelnym">  Kode harus cukup produktif </h2><br><p>  Mari kita sedikit kedinginan.  Persyaratan selanjutnya yang akan kita pertimbangkan adalah bahwa kodenya harus cukup produktif. </p><br><p>  Apa yang saya maksud dengan kata "cukup"?  Mungkin setiap orang telah mendengar bahwa optimasi prematur itu jahat, mereka membunuh keterbacaan dan menyulitkan kode.  Ini benar  Tetapi juga benar bahwa Anda harus tahu alat Anda dan tidak menulis di atasnya sehingga klien web mail memuat Core I7 sebesar 60%.  Anda harus mengetahui masalah khas yang menyebabkan masalah kinerja dan menghindarinya bahkan pada tahap penulisan kode. </p><br><p>  Mari kita kembali ke contoh kita: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetUserName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (WebClient http = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebClient()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.DownloadString(<span class="hljs-string"><span class="hljs-string">"https://some.super.url"</span></span>); } }</code> </pre> <br><p>  Kode ini memiliki satu masalah - unduhan sinkron melalui jaringan.  Ini adalah operasi I / O yang membekukan aliran kami sampai dijalankan.  Dalam aplikasi desktop, ini akan menyebabkan antarmuka yang menggantung, dan dalam aplikasi server, untuk reservasi memori yang tidak berguna dan kelelahan jumlah permintaan ke server.  Hanya dengan mengetahui masalah seperti itu, Anda sudah dapat menulis kode yang lebih optimal.  Dan dalam kebanyakan kasus ini sudah cukup. </p><br><p>  Tapi terkadang, tidak.  Karena itu, sebelum menulis kode, Anda harus tahu terlebih dahulu persyaratan apa yang ditetapkan untuknya dalam hal kinerja. </p><br><h2 id="a-teper-pogovorim-za-testy">  Sekarang mari kita bicara tentang tes. </h2><br><p>  Ini tidak kurang topik holivny dari yang sebelumnya, dan mungkin bahkan lebih.  Semuanya rumit dengan tes.  Mari kita mulai dengan pernyataan - Saya percaya bahwa kode harus dicakup oleh sejumlah tes yang masuk akal. </p><br><p>  Mengapa kita membutuhkan Kode Cakupan dan tes?  Di dunia yang ideal, mereka tidak dibutuhkan.  Di dunia yang ideal, kode ditulis tanpa bug, dan persyaratan tidak pernah berubah.  Tapi kita hidup di dunia yang jauh dari ideal, jadi kita perlu tes untuk memastikan bahwa kodenya berfungsi dengan benar (tidak ada bug) dan kodenya bekerja dengan benar setelah mengubah sesuatu.  Inilah manfaat yang diberikan tes kepada kami.  Di sisi lain, bahkan 100% (karena spesifikasi penghitungan metrik) yang dicakup oleh tes tidak menjamin bahwa Anda benar-benar mencakup semuanya.  Selain itu, setiap tes tambahan memperlambat pengembangan karena setelah mengubah fungsional Anda juga harus memperbarui tes.  Oleh karena itu, jumlah tes harus masuk akal dan kesulitan utama terdiri dalam menemukan kompromi antara jumlah kode dan stabilitas sistem.  Menemukan aspek ini cukup sulit dan tidak ada resep universal untuk melakukan hal ini.  Tetapi ada beberapa tips yang dapat membantu Anda melakukan ini. </p><br><ul><li>  Tutupi logika aplikasi bisnis.  Logika bisnis adalah tujuan dari aplikasi yang dibuat, dan itu harus se-stabil mungkin. </li><li>  Meliputi hal-hal yang rumit dan dihitung.  Perhitungan, transformasi, penggabungan data yang kompleks.  Di tempat yang mudah membuat kesalahan. </li><li>  Tutupi bug.  Bug adalah bendera yang memberi tahu kita bahwa kodenya rentan di sini.  Dan ini adalah tempat yang bagus untuk menulis ujian di sini. </li><li>  Tutup kode yang sering digunakan kembali.  Sangat mungkin bahwa itu akan sering diperbarui dan kita perlu memastikan bahwa menambahkan satu hal tidak akan merusak yang lain. </li></ul><br><p>  Jangan tutup tanpa banyak kebutuhan </p><br><ul><li>  Perpustakaan asing - cari perpustakaan yang kodenya sudah dicakup oleh tes. </li><li>  Infrastruktur - DI, pemetaan otomatis (jika tidak ada pemetaan rumit) dan sebagainya.  Ada tes e2e atau integrasi untuk ini. </li><li>  Hal-hal sepele - menugaskan data ke bidang, meneruskan panggilan, dan sebagainya.  Anda hampir pasti akan menemukan tempat yang jauh lebih berguna untuk meliput mereka dengan tes. </li></ul><br><p>  Yah, pada dasarnya itu. </p><br><h2 id="podvedem-itogi-horoshiy-kod-eto--">  Untuk meringkas.  Kode yang bagus </h2><br><ul><li>  Kode kerja </li><li>  Mudah dibaca </li><li>  Mudah diubah </li><li>  Cukup cepat </li><li>  Dan tercakup dalam tes dalam jumlah yang tepat. </li></ul><br><p>  Semoga beruntung dengan cara yang sulit ini.  Dan kemungkinan besar, Anda akan membenci ini.  Jika masih belum, selamat datang. </p><br><p><img src="https://habrastorage.org/webt/pi/qa/wv/piqawvohoaf7t1llilibt5hayzo.jpeg" alt="Sebenarnya, ini adalah dunia penemuan, peluang, dan kreativitas yang menakjubkan.  Di sini hanya di Lingkungan ada kebosanan yang mengubah bentuk, kesuraman kode warisan 20+ tahun, dan bidang kruk untuk jangka waktu yang lama.  Jadi saya lebih suka memilih jembatan garis rambut (C).  Cari proyek yang akan Anda bakar.  Cobalah melakukan sesuatu yang baik.  Sederhananya, buat dunia menjadi tempat yang lebih baik dan semuanya akan baik-baik saja."></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id429732/">https://habr.com/ru/post/id429732/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id429718/index.html">Saya ingin semuanya sekaligus! Kami mempelajari RAM HyperX Predator DDR4 RGB, dengan frekuensi 4000 MHz</a></li>
<li><a href="../id429720/index.html">Bagaimana cara pengembang pemula untuk bertahan dalam sebuah wawancara dan tidak menjadi gila di tempat kerja</a></li>
<li><a href="../id429722/index.html">Bagaimana kami melakukan pembayaran melalui Google Pay di Yandex.Cash [diperbarui]</a></li>
<li><a href="../id429724/index.html">Ulasan yang bermanfaat. 28 buku yang memengaruhi pemikiran saya, mengilhami, atau menjadi lebih baik</a></li>
<li><a href="../id429728/index.html">Arsitektur MVI modern berdasarkan pada Kotlin</a></li>
<li><a href="../id429734/index.html">Mimpi terbang dengan bias listrik</a></li>
<li><a href="../id429736/index.html">Hogweed dari Sosnowski. Di MO diperkenalkan denda untuk distribusi</a></li>
<li><a href="../id429738/index.html">Pengaturan Shard Optimal dalam Elasticsearch Petabyte Cluster: Linear Programming</a></li>
<li><a href="../id429744/index.html">Pelajari OpenGL. Pelajaran 6.4 - IBL. Paparan specular</a></li>
<li><a href="../id429750/index.html">Buku Masakan Pengembang: Resep DDD (Bagian 3, Arsitektur Aplikasi)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>