<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëäüèΩ üèµÔ∏è ü§æüèΩ IBM System i (auch bekannt als AS / 400) - Wie wir automatische Tests f√ºr Green-Screen-Anwendungen durchgef√ºhrt haben üôÜüèø üë©üèø‚Äç‚úàÔ∏è üë©üèª‚Äçüíº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo! Mein Name ist Anton Vorobyov, ich bin bei der Alfa Bank f√ºr die Entwicklung von Anwendungen f√ºr ein zentrales Bankensystem verantwortlich. 

 I...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>IBM System i (auch bekannt als AS / 400) - Wie wir automatische Tests f√ºr Green-Screen-Anwendungen durchgef√ºhrt haben</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/alfa/blog/446332/">  Hallo!  Mein Name ist Anton Vorobyov, ich bin bei der Alfa Bank f√ºr die Entwicklung von Anwendungen f√ºr ein zentrales Bankensystem verantwortlich. <br><br>  In diesem Beitrag werde ich Ihnen erkl√§ren, was Green-Screen-Anwendungen sind, warum sie ben√∂tigt werden und wie wir Autotests f√ºr sie durchgef√ºhrt haben, indem wir eine eigene L√∂sung daf√ºr schreiben, mit der wir Autotests um das 11-fache beschleunigen konnten. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ui/j8/z2/uij8z2alj0kcdqv2wtd_uo4yghq.jpeg"></a> <br><br>  Die AS / 400-Plattform (Application System / 400) wurde 1988 geboren.  Das erste Betriebssystem f√ºr diese Plattform ist OS / 400, das sp√§ter in i5 / OS und sp√§ter in IBM i umbenannt wurde.  Vor nicht allzu langer Zeit feierte sie ihren drei√üigsten Geburtstag. <br><br>  Wenn Sie unter dem IBM i-Betriebssystem in die Welt der Entwicklung eintauchen, verstehen Sie, dass dies im klassischen Sinne des Wortes kein ‚ÄûVerm√§chtnis‚Äú ist.  Dies ist eine andere, v√∂llig andere Umgebung, die den √ºblichen Windows- oder Unix-Systemen wenig √§hnlich ist.  Die Hauptaufgabe dieses Betriebssystems besteht darin, auf den Ger√§ten, mit denen es arbeitet, so produktiv wie m√∂glich zu sein und f√ºr den Benutzer nicht bequem zu sein. <br><br>  Meiner Meinung nach kann dieses Betriebssystem Sie verr√ºckt machen, wie unwirksam die √ºblichen Ans√§tze zum Schreiben von C ++ - Code sind (bis zu zehnmal CPU-Verlust), dass einige in Lehrb√ºchern gezeigte Antimuster die beste Vorgehensweise f√ºr effektiven Code sind und die Quelle mit dem Datum des Schreibens f√ºr 1978 nicht nur problemlos montieren, sondern auch wie geplant arbeiten!  All dies l√§sst uns einen neuen Blick auf moderne Ans√§tze der Softwareentwicklung werfen. <br><a name="habracut"></a><br><h2>  Einf√ºhrung </h2><br>  Das Problem der Verbesserung der Qualit√§t der in der Entwicklung befindlichen Software erregt die K√∂pfe jedes Entwicklungsteams.  Eines unserer Kredit-Teams, dessen Aufgabe es ist, den Back-Teil des Moduls f√ºr das automatisierte Bankensystem Misys Equation zu entwickeln, hat diesen Moment ebenfalls nicht umgangen.  Die Besonderheit dieses ABS ist, dass: <br><br><ul><li>  Die ersten Versionen des ABS arbeiteten unter dem Vorg√§nger AS / 400 - der IBM System / 38-Plattform (erschienen 1978) unter dem CPF-Betriebssystem ‚ÄûControl Program Facility‚Äú. </li><li>  Es wurde seit den 70er Jahren des 20. Jahrhunderts entwickelt, und Sie k√∂nnen auf Code sto√üen, der vor Ihrer Geburt geschrieben wurde (viel alter Code). </li><li>  Die Merkmale der Arbeit mit ABS beruhen auf der engen Integration mit IBM i, und aufgrund der kolossalen Abw√§rtskompatibilit√§t mit letzterem scheinen Sie als Arch√§ologe an den Ausgrabungen der Gro√üen Pyramide zu arbeiten. </li></ul><br><br><img src="https://habrastorage.org/webt/wu/va/gc/wuvagcwh4kmqi-fgc1sz_faezp0.jpeg"><br>  <i>IBM i (Logo)</i> <br><br>  Die Entwicklung von Anwendungen f√ºr dieses ABS (ABS-Optionen) erfolgt gem√§√ü dem Standard des technischen Pakets des Misys ITP Integrator, der vorsieht, dass die Option aus einem interaktiven Programm f√ºr die Terminalinteraktion mit dem Endbenutzer bestehen und die API √ºber die installierte Schnittstelle f√ºr die Hintergrundausf√ºhrung implementieren soll . <br><br>  Solche interaktiven Programme, die unter dem Betriebssystem IBM i entwickelt wurden, werden in der Vergangenheit als Green-Screen-Anwendungen bezeichnet und sind die einzige Benutzeroberfl√§che, mit der der Benutzer dieses ABS interagiert. <br><br><h2>  Was ist eine Green Screen-Anwendung? </h2><br>  Die einfache Antwort ist eine Anwendung, die so aussieht: <br><br><img src="https://habrastorage.org/webt/6m/gq/gy/6mgqgy4eklp7fvboyyeunnnazgy.jpeg"><br><br>  Oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">so</a> : <br><br><img src="https://habrastorage.org/webt/cu/d2/km/cud2kmgmxlpe_9eqgxyymmqp9iy.png"><br><br><h2>  Warum Green Screen Apps? </h2><br>  In der Vergangenheit waren Greenscreen-Anwendungen die einzigen interaktiven Anwendungen, die auf Systemen mit niedriger und mittlerer Reichweite der AS / 400-Familie und anderen IBM-Mainframes ausgef√ºhrt wurden, mit denen Sie Benutzereingaben anfordern konnten.  Installation, Administration, Konfiguration und Entwicklung auf dem IBM i-Betriebssystem (und seinen Vorg√§ngern i5 / OS und AS400) wurden (und werden noch irgendwo durchgef√ºhrt) ausschlie√ülich mit Green-Screen-Anwendungen durchgef√ºhrt. <br><br>  Das Green-Screen-Anwendungsbild hat zwei Gr√∂√üen - 24 x 80 und 27 x 132 Zeichen und 16 m√∂gliche Farben.  Innerhalb dieser Skala wird der gr√∂√üte Teil der Arbeit von Entwicklern und Benutzern dieses Betriebssystems ausgef√ºhrt. <br><br>  Solche Bildschirmgr√∂√üen sind das Ergebnis der Entwicklung von ‚ÄûWorkstations‚Äú, die mit den AS400-Vorl√§ufern aus den unteren und mittleren Segmenten der Gesch√§ftscomputer IBM System / 32, System / 34, System / 36 und System / 38 verbunden waren.  Diese Workstations wurden als Terminals bezeichnet und bestanden aus einem Bildschirm in einem Metallgeh√§use mit Tastatur und zus√§tzlicher Ausr√ºstung in Form eines Lichtstifts.  Anfangs wurden nur zwei Bildschirmfarben unterst√ºtzt - Gr√ºn und Hellgr√ºn, weshalb der etablierte Ausdruck ‚ÄûGreen-Screen-Anwendung‚Äú (Green-Screen-Anwendung in der englischen Literatur) verwendet wurde.  In den 1970er Jahren stieg die Anzahl der unterst√ºtzten Farben auf 16. <br><br><img src="https://habrastorage.org/webt/i-/is/u6/i-isu68vczilipq75gx8jnq8xzs.png"><br>  <i>5251 Anzeigestation Modell 11</i> <br><br>  Die gebr√§uchlichsten Terminaloptionen waren 5251 Display Station Modell 1 (960 Zeichen auf dem Bildschirm) und Modell 11 (1920 Zeichen auf dem Bildschirm) mit den Abmessungen Breite / Tiefe / H√∂he von 530/400/400 mm und einem Gewicht von 34 kg.  Die Bildschirmaufl√∂sung von Modell 1 betrug 12 x 80, Modell 11 - 24 x 80.  Das Terminal wurde direkt mit dem Hostsystem verbunden. <br><br>  Die Terminals 5251 Display Station Modell 2 (960 Zeichen auf dem Bildschirm) und Modell 12 (1920 Zeichen auf dem Bildschirm) mit gro√üen Abmessungen und einem Gewicht von 45 kg waren ebenfalls weit verbreitet.  Sie unterscheiden sich von Modell 1 und Modell 11 durch die M√∂glichkeit, die Upstream-Verbindung von billigeren Clients in Form von Terminals Modell 1 (oder 11) mit Desktop-Druckern oder einem separaten Bodendrucker √ºber sich selbst an den Host-Computer weiterzuleiten.  Somit fungierten die Modelle 2 und 12 als Hub, der die Verbindung zum Host von Ger√§ten herstellte, die eine direkte Verbindung zum Host-Computer erfordern, und kosteten erheblich mehr. <br><br>  Die Terminals der 5252 Dual Display Station-Serie werden dem modernen Laien ebenfalls ungew√∂hnlich erscheinen. <br><br><img src="https://habrastorage.org/webt/qq/nf/qx/qqnfqxfkc_sddfyxg1nq6i-v154.png"><br>  <i>Werbebild aus der IBM System / 38-Brosch√ºre zu Ger√§ten und Programmen (5252 Dual Display Station)</i> <br><br>  Der Preis f√ºr ein Terminal-Kit mit angeschlossenem Drucker k√∂nnte mehrere tausend US-Dollar erreichen. <br><br>  Die Terminals wurden √ºber ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Twinaxialkabel</a> mit einer Bustopologie im Halbduplexmodus mit einer √úbertragungsgeschwindigkeit von bis zu 1 Mbit / s an die Host-Maschine angeschlossen.  Die maximale Anzahl von Terminals, die von Twinaxial unterst√ºtzt werden, betr√§gt bis zu 6 Terminals. Das vom Host am weitesten entfernte Terminal sollte sich in einer Entfernung von nicht mehr als 1500 Metern befinden. <br><br>  Die Nummer jedes Terminals wird w√§hrend der Installation √ºber drei Switches festgelegt, sodass innerhalb des Busses eine eindeutige Adresse ermittelt wird.  Bei Vorhandensein eines vorhandenen Koaxialnetzes k√∂nnen Adapter von einem Twinaxialkabel zu einem Koaxialkabel und ein geeigneter Satz von Kabelanschl√ºssen zum Crimpen verwendet werden.  Mit diesem Schema konnten nur zwei Ger√§te am Bus mit einer maximalen Segmentl√§nge von bis zu 30 Metern angeschlossen werden.  Die Gesamtzahl der angeschlossenen Ger√§te variierte je nach Modell zwischen einem Dutzend und mehreren Dutzend. <br><br>  Mit der Entwicklung von Desktop-Systemen und Zugangsnetzwerken wurden sperrige Terminals durch Workstations ersetzt, auf denen verschiedene Erweiterungskarten von Drittunternehmen als Mittel f√ºr den Zugriff auf den Host-Computer verwendet wurden, um die direkte Verbindung √ºber Twinaxial zu unterst√ºtzen.  Nachdem IBM 1984 die Token Ring-Technologie entwickelt hatte, erschienen Softwarel√∂sungen f√ºr den Zugriff auf die Maschine, auch √ºber diese Schnittstelle. <br><br><img src="https://habrastorage.org/webt/5d/ek/m2/5dekm2mgcz43rgjiaxyjje3lyas.jpeg"><br>  <i>5250 Adapter an ISA Bus (Hersteller unbekannt)</i> <br><br><img src="https://habrastorage.org/webt/mm/sr/0a/mmsr0av497ergmgdj4hjtd4a-84.png"><br>  <i>Blackbox 5250-Adapterkarten (PC470C, PC471C, PC472C, PC473C, PC478C)</i> <br><br>  Emulatoren f√ºr MS-DOS und MS Windows erscheinen sowohl von IBM als auch von Drittherstellern, einschlie√ülich OpenSource-Implementierungen (z. B. tn5250j.sourceforge.net). Mitte der 90er Jahre kam der TCP / IP-Stack in die Mittelwelt -range und Low-End-Business-Maschinen.  Um den Hostzugriff √ºber das neue Protokoll zu unterst√ºtzen, entwickelt IBM Terminalemulatoren der Serie 5250. <br><br>  Um ein Host-Protokoll zu erstellen, entwickelt IBM <br>  Telnet-Protokollerweiterungen (RFC 854, RFC 855, RFC 856, RFC 860, RFC 885, RFC 1091, RFC 1205, RFC 1572, RFC 2877), zusammenfassend als Telnet5250 (TN5250) bezeichnet, beschreiben den Prozess des Empfangens und Sendens von Streams 5250 Datenstr√∂me (5250 Datenstr√∂me) √ºber das Standard-Telnet-Protokoll. <br><br><img src="https://habrastorage.org/webt/8w/gg/_i/8wgg_idu8zojbdf5_1u-gweewkm.gif"><br>  <i>IBM Client Access / 400 f√ºr Windows 3.1 Installer</i> <br><br><h2>  Was ist das Besondere am IBM 5250? </h2><br>  Ein Merkmal der IBM 5250-Terminals (und dementsprechend des TN5250-Protokolls) ist ihre Blockorientierung im Gegensatz zu den √ºblichen * nix-Terminals, die symbolorientiert sind.  Dies bedeutet, dass die 5250-Datenfl√ºsse, √ºber die der Host mit dem Terminal kommuniziert, von Datenbl√∂cken √ºbertragen werden und ein separates Symbol darin ohne den Kontext des √ºbertragenen Blocks keinen Sinn ergibt. <br><br>  Beispielsweise √ºbertr√§gt der Host-Computer einen Datenblock an das Terminal, der die auf dem Bildschirm angezeigten statischen Informationen zusammen mit den Attributen und Koordinaten der Eingabefelder und eine Angabe des Versatzes in diesem Block enth√§lt, wo das Ergebnis der Benutzereingaben in die Felder geschrieben werden soll.  Danach erwartet der Host-Computer Nachrichten vom Terminal und nimmt nicht am Benutzereingabeprozess teil. <br><br><img src="https://habrastorage.org/webt/kg/ld/ha/kgldha8aef46matytdr3ugjm7ce.png"><br>  <i>Anmeldebildschirm f√ºr IBM i host RZKH.de (pub400.com)</i> <br><br>  Ferner besteht die Aufgabe des Terminalemulators darin, den Datenblock von der Maschine zu interpretieren und den Eingabebildschirm f√ºr den Benutzer zu bilden, wo er die M√∂glichkeit erh√§lt, irgendwelche Informationen in die zul√§ssigen Felder einzugeben.  Zu den Aufgaben des Terminalemulators geh√∂rt auch eine Reaktion auf Benutzeraktionen.  Die Tasten F1-F24 (F13-F24 werden √ºber UMSCHALT + Fx simuliert), Enter, Home, End, PageUp, PageDn und einige andere Sondertasten, die auf modernen Tastaturen nicht verf√ºgbar sind, gelten als Host-Tasten.  Dies bedeutet, dass durch Dr√ºcken dieser Taste ein Stream-Puffer mit Informationen aus den Eingabefeldern und der Cursorposition auf dem Bildschirm, der zuvor mit dem Terminalemulator gef√ºllt war, zur Verarbeitung an den Host gesendet wird. <br><br><img src="https://habrastorage.org/webt/nf/oe/vx/nfoevxx5yvr-kbzcnejytv9hk4q.png"><br>  <i>Anmeldeversuch f√ºr WIreshark 5250 Data Stream bei pub400.com</i> <br><br>  Der Host empf√§ngt den Puffer, analysiert ihn und das Eingabeergebnis wird an das Programm √ºbergeben, das die Antwort des Benutzers zur weiteren Daten√ºberpr√ºfung angefordert hat, und die Anwendung arbeitet weiter, w√§hrend die Anwendung den Code der gedr√ºckten Host-Taste empf√§ngt. <br><br><h2>  Warum wird hier √ºberhaupt autotestet? </h2><br>  Wir haben dar√ºber nachgedacht, das manuelle Testen von Green-Screen-Anwendungen zu automatisieren, als wir Hunderte von Bildschirmen eines entwickelten Moduls testen mussten, bei denen bis zu achtzig verschiedene Gesch√§ftspr√ºfungen (Validierungen) auf einem Bildschirm durchgef√ºhrt werden konnten. <br><br>  Das besondere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Problem</a> des Teams war das fast vollst√§ndige Fehlen von Green-Screen- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auto-Test-</a> Tools f√ºr 2017, mit Ausnahme der propriet√§ren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UIPath-</a> L√∂sung.  Selbst heute gibt es nicht viele √§hnliche L√∂sungen. Dem Autor sind Automate von HelpSystems und die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JMeter-</a> Erweiterung f√ºr BlazeMeter bekannt (ich werde mich √ºber andere √§hnliche Produkte freuen). <br><br><h2>  Die erste Untersuchung des Problems </h2><br>  Der Standardemulator des TN5250-Terminals, das an Arbeitspl√§tzen in der Bank installiert ist, ist IBM <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Personal Communications</a> f√ºr Windows 6.0 (PCOMM 6.0).  Kollegen stellten fest, dass dieses Produkt regelm√§√üig √ºber Mittel zur Automatisierung seiner Verwaltung in Form einer vielf√§ltigen API verf√ºgt, n√§mlich: <br><br><ol><li>  HLLAPI (High-Level Language Application Program Interface); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verbessertes HLLAPI;</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Windows HLLAPI</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Host Access Client Library (HACL).</a> </li></ol><br>  Die ersten drei Schnittstellen sind die √§ltesten und werden seit DOS- und 16-Bit-Versionen von Windows unterst√ºtzt.  Die Arbeit an der EHLLAPI-Schnittstelle wird implementiert, indem eine einzelne Funktion gem√§√ü dem folgenden Prototyp aufgerufen wird: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hllapi</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LPWORD, LPSTR, LPWORD, LPWORD)</span></span></span></span>;</code> </pre> <br>  Dabei ist der erste Parameter ein Zeiger auf die numerische Nummer der ausgef√ºhrten Funktion, die anderen beiden sind die kontextsensitiven Argumente f√ºr die aufgerufene Funktion, und der letzte ist das Ergebnis der Funktion.  Das hei√üt, um den Verbindungsstatus 'A' anzufordern (Sitzungen im Emulator sind mit einem lateinischen Buchstaben im Bereich von 'A' bis 'Z' nummeriert), m√ºssen Sie den folgenden Code ausf√ºhren (entnommen aus der IBM Dokumentation): <br><br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"hapi_c.h"</span></span></span><span class="hljs-meta"> struct HLDQuerySessionStatus QueryData; int Func, Len, Rc; long Rc; memset(QueryData, 0, sizeof(QueryData)); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Init buffer QueryData.qsst_shortname = 'A'; // Session to query Func = HA_QUERY_SESSION_STATUS; // Function number Len = sizeof(QueryData); // Len of buffer Rc = 0; // Unused on input hllapi(&amp;Func, (char *)&amp;QueryData, &amp;Len, &amp;Rc); // Call EHLLAPI if (Rc != 0) { // Check return code // ...Error handling }</span></span></span></span></code> </pre><br>  Die Anzahl der Funktionen, die auf diese Weise aufgerufen werden k√∂nnen, betr√§gt ca. 60. <br><br>  Die WinHLLAPI-Schnittstelle erweitert diese Funktionalit√§t geringf√ºgig um mehrere zus√§tzliche Funktionen, mit denen R√ºckruffunktionen f√ºr asynchrone Anrufe registriert werden k√∂nnen, um √ºber Ereignisse beim Herstellen einer Verbindung mit dem Host, Trennen der Verbindung zum Host, √Ñndern von Daten auf dem Terminalbildschirm usw. zu benachrichtigen. <br><br>  Die HACL-Schnittstelle (Host Access Client Library) schien benutzerfreundlicher zu sein, da im Gegensatz zum Aufrufen der "gleichnamigen Funktion" eine Variante der objektorientierten Hierarchie von Klassen bereitgestellt wurde, die jede Benutzeraktion vollst√§ndig imitierte. <br><br><img src="https://habrastorage.org/webt/bv/km/nx/bvkmnxfp3dcskk9uiw9kzbtyffo.gif"><br>  <i>Klassenhierarchie der HACL-Emulator-Klassenbibliothek (C ++)</i> <br><br>  Es gibt HACL-Implementierungen f√ºr C ++, Java, LotusScript und einen COM-Automatisierungsserver f√ºr Windows (praktisch f√ºr Visual Basic und .NET). <br><br><h2>  Erster Prototyp </h2><br>  Aufgrund der enormen Komplexit√§t des 5250-Datenflussprotokolls und der √§u√üerst knappen Informationen zu seinem internen Ger√§t mit Links zu geschlossener bezahlter Literatur von IBM wurde deutlich, dass die Entwicklung eines eigenen Emulators √§u√üerst trivial und zeitaufw√§ndig ist.  In diesem Zusammenhang kam die Idee auf, eine Middleware-Schicht zu verwenden, mit der Sie den Terminalemulator innerhalb der minimal erforderlichen Funktionalit√§t steuern k√∂nnen, insbesondere "Geben Sie einen Wert in das Feld ein", "Vergleichen Sie einen Teil des Bildschirms mit dem Standard" oder "Dr√ºcken Sie die Host-Taste F22". <br><br>  Kollegen, die zuvor HACL-Schnittstellen verwendet hatten, behaupteten (und eine Suche in StackOverflow best√§tigte dies), dass das COM-Objekt Stabilit√§tsprobleme hatte und nach Ausf√ºhrung einer bestimmten Anzahl von Befehlen h√§ngen bleiben k√∂nnte.  Nur ein Neustart des Automatisierungsserverprozesses hat geholfen.  Eine schnelle Analyse der Java-Version ergab, dass Wrapper √ºber die C ++ - Schnittstelle √ºber JNI verwendet wird.  Daher fiel die Wahl auf die C ++ - Schnittstelle.  Die entsprechenden Header- und LIB-Dateien waren im Installationsverzeichnis von Personal Communications For Windows selbst verf√ºgbar. <br><br>  Der erste Prototyp basierte auf Qt5, wo es m√∂glich war, JavaScript-Code √ºber QtScript auszuf√ºhren.  In der Umgebung des ausf√ºhrbaren Skripts wurde ein Objekt mit einer kleinen Anzahl von Methoden registriert, mit denen Befehle im Terminalemulator so ausgef√ºhrt werden konnten, als w√ºrden sie von einer Person ausgef√ºhrt (Eingabe eines Feldes, Dr√ºcken der Hosttasten, Warten auf eine Zeile auf dem Bildschirm).  Wir haben eine Live-Demo demonstriert, in der wir einen Benutzerfall zum Starten einer Green-Screen-Anwendung aus ABS Equation mit einem Test der Reaktion der Anwendung auf falsche Eingaben in die Felder erstellt haben.  Die Demonstration zeigte, dass der Prototyp erfolgreich war und wir weitermachen k√∂nnen. <br><br><h2>  Das Aussehen eines Nachbarn </h2><br>  Zusammen mit der Demonstration des ersten Prototyps haben Kollegen aus einer anderen Abteilung eine Reihe von Ruby + Cucumber + <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quick3270</a> + Ruby-Modulen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">cheeze / te3270</a> ) zusammengestellt.  Die vorgeschlagene Version verwendet ein Ruby-Modul, das √ºber seine speziellen COM-Objekte (nicht kompatibel mit HACL-Schnittstellen) mit dem DN32 Computing Quick3270-Terminalemulator interagiert.  Es war eine Komplettl√∂sung f√ºr automatische Green-Screen-Testanwendungen im BDD-Stil mit einigen zuvor beschriebenen Schritten.  In der vorgeschlagenen L√∂sung wurden wir jedoch durch Folgendes alarmiert: <br><br><ol><li>  Wir haben einen kostenpflichtigen Emulator eines Drittanbieters verwendet, der nicht von IBM stammt (alle Emulatoren funktionieren etwas anders, aber wir m√ºssen die Arbeit an den in der Bank verwendeten Standardemulatoren √ºberpr√ºfen, da der Preis f√ºr den Fehler unglaublich hoch ist). </li><li>  Bei der Implementierung der Cucumber-Schritte f√ºr Quick3270 wurde eine gro√üe Anzahl von Ruhezust√§nden verwendet, um auf eine Antwort von der Maschine zu warten. </li><li>  Sehr schlechte Leistung von Quick3270 √ºber die Automatisierungsschnittstelle (die Arbeit mit HACL im Prototyp √ºber die C ++ - Schnittstelle sah viel dynamischer aus). </li></ol><br><img src="https://habrastorage.org/webt/wy/j3/2u/wyj32ub0tvoxzbh-va3yxajiqfs.jpeg"><br>  <i>Quick3270 Terminal Emulator</i> <br><br>  Basierend auf dem Prototyp haben wir uns entschlossen, einen eigenen Automatisierungsserver zu implementieren, um Cucumber mit Personal Communications f√ºr Windows zu verbinden und die Schritte so zu gestalten, dass die Ausfallzeit zwischen den Aktionen auf dem Emulatorbildschirm minimal ist. <br><br>  <i><b>Lyrischer Exkurs</b> .</i>  <i>Trotz der Tatsache, dass es eine gro√üe Anzahl technischer Probleme im Zusammenhang mit dem vermeintlich "alten" IBM gibt, die anscheinend bereits f√ºr Systeme der mittleren und unternehmerischen Ebene gel√∂st worden sein sollten, ist die Relevanz der Anpassung und √úbertragung vorhandener technischer L√∂sungen einfach deshalb sehr hoch ihre Abwesenheit auf der Plattform.</i>  <i>Oft h√§ngt die Abwesenheit mit den Funktionen dieses Betriebssystems zusammen, die sich grundlegend von modernen * nix-, Windows- oder MacOS X-Versionen unterscheiden, f√ºr die eine erhebliche Optimierung der Software f√ºr diesen Stapel erforderlich ist.</i> <br><br><h2>  Eigene Entscheidung </h2><br>  Als unsere eigene L√∂sung haben wir einen Automatisierungsserver als Entwicklung des zuvor demonstrierten Prototyps erstellt.  Dieser Server f√ºhrt Befehle aus, um die Interaktion von Verbrauchern √ºber einen RPC-Server (Qt5 WebSocket) zu automatisieren.  Es interagiert mit Personal Communications f√ºr Windows, das Teil des Windows-Betriebssystemimages des Unternehmens ist, und erm√∂glicht Ihnen Folgendes: <br><br><ul><li>  Terminal-Emulator-Sitzungen starten / stoppen; </li><li>  Screen Scraping Green Screen durchf√ºhren; </li><li>  Suche nach Eingabefeldern auf dem Bildschirm; </li><li>  Steuern Sie den Cursor und simulieren Sie Tastenanschl√§ge (einschlie√ülich Host). </li><li>  usw. </li></ul><br><img src="https://habrastorage.org/webt/ub/qf/xp/ubqfxpqwu5q9pz3ievcpkfb0_sm.png"><br>  <i>Starten Sie Automation Server</i> <br><br>  Trotz aller Vorteile der HACL-API hat sie einen Nachteil: Sie wei√ü nicht, wie sie mit dem im Betriebssystem integrierten DB2 for i-DBMS arbeiten soll, und erlaubt nicht die Ausf√ºhrung von Befehlen, die f√ºr die Erstellung einer Scheinumgebung wichtig sind, in der ein Testskript ausgef√ºhrt werden w√ºrde.  Wenn der DB2-Client f√ºr Ruby von IBM vorhanden ist, ist der Client f√ºr den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Remotebefehls-</a> und den verteilten Programmaufrufserver nur f√ºr Java in Form der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JTOpen-</a> Bibliothek: Die Open Source-Version der IBM Toolbox f√ºr Java (auch als jt400 bezeichnet) )  Wir haben die L√∂sung f√ºr dieses Problem bei IBM selbst ‚Äûdurchgesehen‚Äú, indem wir das Verhalten seiner Produkte mit √§hnlichen Funktionen analysiert haben (insbesondere Personal Communications f√ºr die Windows-Daten√ºbertragung, iSeries zu PC / PC zu iSeries Transfer usw.).  Es stellte sich heraus, dass diese Produkte bei ihrer Implementierung je nach Version der Anwendung IBM JRE 6 oder 8 ausf√ºhren und die jt400-Bibliothek verwenden. <br><br>  F√ºr den Automatisierungsserver haben wir uns dazu entschlossen.  Das JNI startet die IBM JVM, die im Lieferumfang von Personal Communications f√ºr Windows enthalten ist.  Mit speziellen Wrapper-Methoden werden Befehle vom RPC-Server, die von au√üen kommen, ausgef√ºhrt, indem sie in Aufrufe der erforderlichen jt400-Funktionalit√§t √ºbertragen werden.  Da letzterer auch einen JDBC-Treiber f√ºr DB2 enth√§lt, wurde beschlossen, diesen f√ºr den Zugriff auf das DBMS unter IBM i zu verwenden. <br><br>  Es ist wichtig zu beachten, dass Sie Oracle JVM bei Verwendung von HACL nicht verwenden k√∂nnen.  Wenn Sie eine Terminalemulatorsitzung ausf√ºhren, st√ºrzt der Versuch, eine Instanz der virtuellen Maschine zu erstellen, ab.  Wenn Sie die Oracle-JVM im Adressraum eines Prozesses ausf√ºhren, der mit der HACL interagiert, bleibt diese ebenfalls ohne Erkl√§rung h√§ngen. <br><br>  Im Laufe der Zeit wurde die L√∂sung f√ºr immer mehr Jobs implementiert.  Es funktionierte schneller als die L√∂sung mit Quick3270.  Die Popularit√§t wuchs ebenso wie die Anzahl der Autotests.  W√§hrend des Betriebs traten jedoch zus√§tzliche Schwierigkeiten auf: <br><br><ol><li>  Gelegentliches Einfrieren des Terminals; </li><li>  Unf√§higkeit, an einem Regressionsstand zu arbeiten, da der Terminalemulator den Start verweigert, wenn der Desktop des Benutzers, unter dem der Emulator gestartet wird, blockiert ist oder seine RDP-Sitzung blockiert ist. </li><li>  Nur Windows; </li><li>  Ein komplexes Verfahren zum Installieren, Konfigurieren und Aktualisieren von Tools (√ºber ein MSI-Paket). </li><li>  Unser Regressionszyklus f√ºr 130 Autotests (ca. 4000 Schritte) begann 7-8 Stunden. </li></ol><br><h2>  Es muss etwas getan werden ... </h2><br>  Durch die Analyse der Ablaufverfolgungsprotokolle zahlreicher Autotest-Starts und das Auffinden von Engp√§ssen bei der Leistung h√§ufig verwendeter Schritte wurde die Gesamtausf√ºhrungszeit f√ºr die Regression auf 4 bis 5 Stunden reduziert.  Es war jedoch klar, dass die Verwendung der Middleware-Schicht in Form eines Automatisierungs-RPC-Servers in Verbindung mit der HACL-Schnittstelle, die auch ‚Äûschwebende‚Äú Fehler aufweist, die sich √ºber die Dauer des gesamten Systems ansammeln, nicht zur Verbesserung der Leistung der L√∂sung beitr√§gt. <br><br>  Andererseits bietet der Anbieter als Alternative zu IBM Personal Communications f√ºr Windows eine plattform√ºbergreifende L√∂sung mit dem Namen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IBM i Access - Client Solutions an.</a> <br><br><img src="https://habrastorage.org/webt/et/8d/kr/et8dkrlouhhuuqe3ew3krvyjq6u.png"><br>  <i>IBM i Access - Client-L√∂sungen</i> <br><br>  Die Analyse der internen Struktur am Samstag- und Sonntagmorgen bei einer Tasse Kaffee ergab, dass die Codebasis auf einem anderen Produkt von IBM basiert, IBM <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Host on-Demand</a> (IBM HOD).  Dies ist eine vollwertige L√∂sung f√ºr den Zugriff auf IBM i, die in Java 6 entwickelt wurde und nicht nur die vollst√§ndige Implementierung verschiedener Kommunikationsprotokolle bietet, die in IBM-Maschinen (TN3270, TN5250, VTxxx usw.) verwendet werden, sondern auch Java-Swing-UI-Komponenten auf hoher Ebene. wird verwendet, um eigene Terminalemulatoren in Form eines Konstruktors zu erstellen, der aus der sp√§rlichen IBM <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation zusammengestellt werden kann</a>  Eine detailliertere Untersuchung des IBM HOD hat gezeigt, dass die UI-Komponenten auf der Java-Implementierung der HACL-Schnittstelle basieren, deren Dokumentation offen ist.  Ihr Verhalten stimmt nur geringf√ºgig mit der C ++ HACL-Dokumentation √ºberein. <br><br><img src="https://habrastorage.org/webt/8u/fx/7-/8ufx7-3eikew1kjwcr0h-3uuw40.png"><br>  <i>IBM Host On-Demand (Logo)</i> <br><br>  Als N√§chstes haben wir eine Java-Bibliothek f√ºr den internen Gebrauch erstellt, die dieselbe Schnittstelle wie der C ++ RPC-Automatisierungsserver implementiert, jedoch intern IBM HOD verwendet.  Um den Overhead w√§hrend der Ausf√ºhrung der Autotest-Schritte zu verringern, haben wir von Ruby Cucumber auf cucumber-jvm migriert und alle Schritte √§hnlich den Ruby-Optionen neu implementiert.  Bei einer dem RPC-Server √§hnlichen Softwareschnittstelle war dies keine gro√üe Sache, insbesondere angesichts der Tatsache, dass wir versucht haben, das unkontrollierte Wachstum der Anzahl der Schritte selbst einzud√§mmen, und diesen Wert in der Region von 30 Einheiten hatten. <br><br><h2>  Was ist das Ergebnis? </h2><br>  Infolgedessen haben wir die Funktionsf√§higkeit aller Autotests erreicht, ohne sie zu √§ndern, und die Arbeitsgeschwindigkeit wurde so hoch, dass wir eine k√ºnstliche Verz√∂gerung zwischen den Schritten einf√ºhren mussten, damit Sie bei der Entwicklung eines Autotests dessen Arbeit beobachten konnten, da die Benutzeroberfl√§che sonst keine Zeit hatte, den Bildschirm bis zum Ende zu zeichnen. <br><br>  Bereits vorhandene 180 Autotests mit mehr als 16.000 Schritten mit einer festgelegten Verz√∂gerung von 60 ms zwischen den Schritten begannen etwa 30 Minuten gegen√ºber 5 Stunden 30 Minuten zu laufen, was einer elffachen Steigerung der Leistung des Regressionsstandes entspricht. <br><br>  Die Ergebnisse √ºbertrafen alle Erwartungen.  Wir befinden uns nahe an den physikalischen Grenzen des TN5250-Protokolls. <br><br>  Bisher wurde die Entscheidung der gesamten Bank ver√∂ffentlicht, und Kollegen aus anderen St√§dten haben sich der Verbesserung angeschlossen.  Von den j√ºngsten √Ñnderungen integrieren Kollegen die L√∂sung in Jenkins. In der Testversion wurde der Test des Starts auf einem Linux-Server mit Xvfb abgeschlossen und die Phase des Pilotbetriebs f√ºr die Ausf√ºhrung von Autotests gestartet. <br><br>  Vielen Dank f√ºr das Lesen bis zum Ende! <br>  Alles Erfolg! <br><br>  PS Im Dezember 2018 fand die n√§chste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IBMi Developer Conference statt,</a> auf der ein Bericht zum Thema dieses Artikels erstellt wurde. <br><br>  Bisher haben wir die Konferenz j√§hrlich nur f√ºr Bankangestellte abgehalten.  Ab 2019 werden wir Teilnehmer aus anderen Unternehmen einladen.  Es ist sehr interessant, den Kreis der beruflichen und pers√∂nlichen Kommunikation zu erweitern, Emotionen, Wissen und Erfahrungen auszutauschen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446332/">https://habr.com/ru/post/de446332/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446322/index.html">Kryptographie in Java. Keytool-Dienstprogramm</a></li>
<li><a href="../de446324/index.html">Navigation in DataGrip mit Yandex.Navigator</a></li>
<li><a href="../de446326/index.html">Verkehrsprobleme l√∂sen</a></li>
<li><a href="../de446328/index.html">Warum brauchen wir SMS-Empfangsdienste und womit essen sie?</a></li>
<li><a href="../de446330/index.html">Automatische Maschinen gegen Spaghetti-Code</a></li>
<li><a href="../de446334/index.html">√úberlegungen zu einer Karriere in der IT und Tipps f√ºr Anf√§nger</a></li>
<li><a href="../de446336/index.html">Wie man Standardkennw√∂rter verbietet und alle dazu bringt, dich zu hassen</a></li>
<li><a href="../de446338/index.html">SVG 3D: Erstellen, Drehen und Animieren</a></li>
<li><a href="../de446340/index.html">Betriebssysteme: Drei einfache Teile. Teil 1: Intro (√úbersetzung)</a></li>
<li><a href="../de446342/index.html">Der Einfluss transparenter gro√üer Seiten auf die Systemleistung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>