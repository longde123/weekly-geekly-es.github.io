<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏪ ⛅️ 🔴 Funktionsparadigma on Go: Grundtechniken 🎋 🏚️ 👨🏽‍🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits, wir erinnern euch daran, dass in diesem Monat in OTUS ein neues Set im Golang-Entwicklerkurs startet . Trotz des Hasses gegenüber de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Funktionsparadigma on Go: Grundtechniken</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/476346/"><img src="https://habrastorage.org/webt/-h/r5/d3/-hr5d3as4yvxom9gzi-jsdmgyo0.png"><br><br>  <i>Hallo allerseits, wir erinnern euch daran, dass in diesem Monat in OTUS ein neues Set im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Golang-Entwicklerkurs startet</a> .</i>  <i>Trotz des Hasses gegenüber dem vorherigen Artikel über Golang hat sich unser freiberuflicher Autor entschlossen, die Fortsetzung einer Reihe von Artikeln zu riskieren, die dieser Sprache gewidmet sind.</i>  <i>Wir werden versuchen, wieder durch dieses dünne Eis zu gehen und uns dabei auf das zu verlassen, worauf Golang sich zu verlassen scheint - das funktionale Paradigma.</i> <br><br><hr><br>  <b>Wir erinnern Sie daran, dass dieser Artikel eine Art Material für "außerschulisches Lesen" ist und nicht mit dem Kursprogramm zusammenhängt, das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">finden ist</a> .</b> <br><a name="habracut"></a><br>  Es ist klar, dass professionelle Programmierer in anderen Sprachen Golang anrufen <br>  Irritation ist wie eine von Erwachsenen kompilierte Sprache, aber das Konzept von Klassen und Vererbung fehlt im Prinzip (obwohl OOP in einer Sprache implementiert ist, wenn auch auf ungewöhnliche Weise, durch ein System von Strukturen und Schnittstellen).  Heute betrachten wir jedoch die Hauptimplementierungen bekannter Konstruktionen im Funktionsparadigma und versuchen, sowohl diese als auch die Sprachsyntax selbst zu erklären. <br><br><img src="https://habrastorage.org/webt/qo/pi/9g/qopi9go4eio9pxj5d_5izmegyn0.jpeg"><br><br>  Jetzt gibt es viel Hype um das Funktionsparadigma (FP).  Es ist aber auch kein Allheilmittel für alle Probleme und hat auch Vor- und Nachteile. <br><br><h3>  Kurz darüber, was ein Funktionsparadigma ist </h3><br>  Das Funktionsparadigma kam zur Programmierung aus der Mathematik.  Es bildet folgende Voraussetzungen für das Programm: <br><br><ul><li>  Keine Änderung vorhandener Daten. </li><li>  Es gibt keinen versteckten Zustand. </li></ul><br>  <b>Was gibt uns das?</b> <br><br>  Unsere Funktionen arbeiten ohne Effekte von Drittanbietern.  Mit anderen Worten, die Funktion sollte nur einen Wert zurückgeben und keine externen Daten beeinflussen. <br><br>  Reine Funktionen nutzen.  Sie erhöhen die Zuverlässigkeit von Funktionstests unabhängig von eingehenden Daten - mit anderen Worten, Programme werden zuverlässiger für Tests und ihre Ergebnisse werden vorhersehbarer. <br><br>  Welche Möglichkeiten hat Golang, um das Funktionsparadigma umzusetzen: <br><br><h4>  Erstklassige Funktionen </h4><br>  Erstklassige Funktionen stehen in vielen Programmiersprachen zur Verfügung.  Der Leser dieses Artikels kennt sein Konzept höchstwahrscheinlich bereits von so weit verbreitetem JavaScript, aber ich werde es noch einmal wiederholen.  Die Funktionen der ersten Klasse (Funktion höherer Ordnung) sind Funktionen, die eine andere Funktion als Wissen zurückgeben, eine Funktion als Argument nehmen und den Wert der Funktion an eine andere Variable übergeben können. <br><blockquote>  <b>Lassen Sie uns von Anfang</b> an <b>zustimmen</b> : Um Platz zu sparen, habe ich die ersten beiden Zeilen des Codes, der hier vorgestellt wird, weggelassen: 'package main' und 'import' "fmt" "importieren.  Um den Code auf Ihrem Computer auszuführen, müssen Sie ihn jedoch hinzufügen. </blockquote><br><br><pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> list = []<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">45</span></span>, <span class="hljs-number"><span class="hljs-number">34</span></span>} <span class="hljs-comment"><span class="hljs-comment">//      var out = forEach(list, func(it int) int { //      //forEach   ""  return (it * it) //      }) fmt.Println(out) // [225, 256, 2025, 1156] fmt.Println(list) //      } func forEach(arr []int, fn func(it int) int) []int { //      ,   ,     var newArray = []int{} //     ""   for _, it := range arr { newArray = append(newArray, fn(it)) //      for } return newArray }</span></span></code> </pre> <br><br>  In der Tat ist es überhaupt nicht notwendig, eine eigene <code>map</code> zu erfinden oder von Grund auf neu zu <code>foreach</code> .  Es gibt viele Bibliotheken, die dies implementieren, es bleibt nur, um sie zu verbinden.  Zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses</a> . <br><br><h4>  Verschlüsse und Currying-Funktionen </h4><br>  In vielen modernen Programmiersprachen gibt es Kurzschlüsse.  Closures sind eine Funktion, die sich auf die freien Scope-Variablen der übergeordneten Funktion bezieht.  Funktionscurrying ist ein Funktionswechsel von der Formularfunktion <code>func(a,b,c)</code> zur Formularfunktion <code>func(a)(b)(c)</code> . <br><br>  Hier ist ein Beispiel für Schließungen und Currys in Go: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//  func multiply(x int) func(y int) int { //    return func(y int) int { //   ,       JS return x * y } } func main() { //     var mult10 = multiply(10) var mult15 = multiply(15) fmt.Println(mult10(5)) //50 fmt.Println(mult15(15))//225 }</span></span></code> </pre><br><br><h4>  Reine Funktionen </h4><br>  Wie bereits erwähnt, sind reine Funktionen diejenigen, die Werte zurückgeben, die nur mit eingehenden Argumenten verknüpft sind und den globalen Status nicht beeinflussen. <br><br>  Hier ist ein Beispiel für eine fehlerhafte, fehlerhafte Funktion: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arrToSave = <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{} <span class="hljs-comment"><span class="hljs-comment">//map -    -   Golang func dirtySum(a, b int) int { c := a + b arrToSave[fmt.Sprintf("%d", a, b)] = c //   ,  "%d" -       return c }</span></span></code> </pre><br>  Hier sollte unsere Funktion akzeptieren, so vorhersehbar wie möglich zu arbeiten: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">simpleSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%v"</span></span>, dirtySum(<span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//      //   ""      fmt.Printf("%v", simpleSum(13, 12)) }</span></span></code> </pre><br>  <i>"Irgendwie kommt Rekursion in die Bar und niemand sonst kommt in die Bar"</i> <i><br></i>  <i>Aus der Sammlung von witzlosen Witzen.</i> <br><br><h4>  Rekursion </h4><br>  In einem funktionalen Paradigma ist es üblich, der Rekursion den Vorzug zu geben - für Reinheit und Transparenz, anstatt eine einfache Iteration durch <code>for</code> . <br><br>  Hier ist ein Beispiel für die Berechnung von Fakultäten unter Verwendung des imperativen und deklarativen Paradigmas: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">funcFactorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> num == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num * funcFactorial(num<span class="hljs-number"><span class="hljs-number">-1</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">imperativeFactorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ; num &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; num-- { <span class="hljs-comment"><span class="hljs-comment">//    for result *= num } return result } func main() { fmt.Println(funcFactorial(20)) //        fmt.Println(imperativeFactorial(20)) //      }</span></span></code> </pre><br><br>  Jetzt arbeitet die Rekursionsfunktion ziemlich ineffizient.  Versuchen wir es ein wenig umzuschreiben, um die Geschwindigkeit der Berechnung zu optimieren: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factTailRec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> factorial(<span class="hljs-number"><span class="hljs-number">1</span></span>, num) <span class="hljs-comment"><span class="hljs-comment">//    ""  } func factorial(accumulator, val int) int { if val == 1 { return accumulator } return factorial(accumulator*val, val-1) } func main() { fmt.Println(factTailRec(20)) // 2432902008176640000 }</span></span></code> </pre><br><br>  Unsere faktorielle Rechengeschwindigkeit hat sich leicht erhöht.  Ich werde keine Benchmarks geben). <br><br>  Leider implementiert Go keine sofort einsatzbereite Rekursionsoptimierung, sodass Sie das Rekursionsende selbst optimieren müssen.  Obwohl ohne Zweifel eine nützliche Bibliothek zu diesem Thema gefunden werden kann.  Zu diesem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Thema</a> gibt es zum Beispiel so einen „Loadash for Golang“. <br><br><h3>  Lazy Computing </h3><br>  In der Programmiertheorie ist Lazy Computing (auch als "Deferred Computing" bezeichnet) der Prozess, bei dem das Computing so lange verzögert wird, bis es benötigt wird.  Golang bietet keine Unterstützung für Lazy Computing, daher können wir nur Folgendes simulieren: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">" "</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * x. } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">" "</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x / y <span class="hljs-comment"><span class="hljs-comment">//    -  } func main() { fmt.Println(multOrDivide(true, mult, divide, 17, 3)) //   ""   ,   1  , //         fmt.Println(multOrDivide(false, mult, divide, 17, 3)) } //  if - else    ""  func multOrDivide(add bool, onMult, onDivide func(t, z int) int, t, z int) int { if add { return onMult(t, z) } return onDivide(t, z) }</span></span></code> </pre><br><br>  In den meisten Fällen lohnen sich "emulierte" langsame Ausdrücke nicht, da sie den Code übermäßig komplizieren. Wenn Ihre Funktionen jedoch schwierig zu verwalten sind, sollten Sie diese Methode verwenden.  Sie können sich aber auch anderen Lösungen zuwenden, beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen</a> . <br><br><img src="https://habrastorage.org/webt/46/5p/dj/465pdjhggnzmembzrdashxwhlkc.jpeg"><br><br>  Das ist alles.  Wir haben nur eine Einführung in das Funktionsparadigma von Golang bekommen.  Leider musste ein Teil der Möglichkeiten simuliert werden.  Teilweise vollständig entwickelte Funktionstechniken, wie Monaden, wurden hier nicht berücksichtigt, da in Go on the hub eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vielzahl von</a> Artikeln zu diesen Themen enthalten ist  Vieles kann noch in der Sprache selbst verbessert werden, zum Beispiel wird erwartet, dass die Generika der nächsten großen Version (GO 2) in der Sprache erscheinen.  Nun, wir werden warten und hoffen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de476346/">https://habr.com/ru/post/de476346/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de476330/index.html">Warum bin ich aus St. Petersburg nach Pensa gefahren?</a></li>
<li><a href="../de476332/index.html">Verbesserung des Quantencomputers durch klassisches maschinelles Lernen</a></li>
<li><a href="../de476334/index.html">Ein paar Gedanken über die Jones / Middle / Senioren</a></li>
<li><a href="../de476336/index.html">Computer Vision für nichts</a></li>
<li><a href="../de476342/index.html">Gutes öffentliches Sprechen: 11 einfache Tipps</a></li>
<li><a href="../de476348/index.html">Wie Chemiker einer staatlichen Universität IT-Prinzipien in ihre Arbeit einführten und Teamleiter wurden</a></li>
<li><a href="../de476352/index.html">Field Service Management und Außendienst. Hat Russland es geschafft, Außendiensttechniker zu managen?</a></li>
<li><a href="../de476354/index.html">Drei praktische Schritte zum Speichern der Ressourcen Ihres Startups</a></li>
<li><a href="../de476358/index.html">Servicegitter für Microservices. Teil I</a></li>
<li><a href="../de476366/index.html">Das Dach ging: wie man versteht, dass es Zeit für einen Therapeuten ist und wie man ihn findet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>