<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçüé§ üë©üèø‚Äçü§ù‚Äçüë©üèΩ üéí Le livre "T√¢ches classiques en informatique en Python" üì¥ ‚ôèÔ∏è üë©üèª‚Äçüåæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De nombreuses t√¢ches dans le domaine de l'informatique, qui √† premi√®re vue semblent nouvelles ou uniques, sont en fait ancr√©es dans des algorithmes cl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Le livre "T√¢ches classiques en informatique en Python"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/471520/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/op/8x/zc/op8xzcjsvwkjzgse183iwfc_sdw.jpeg" align="left" alt="image"></a>  De nombreuses t√¢ches dans le domaine de l'informatique, qui √† premi√®re vue semblent nouvelles ou uniques, sont en fait ancr√©es dans des algorithmes classiques, des m√©thodes de codage et des principes de d√©veloppement.  Et les techniques √©tablies sont toujours le meilleur moyen de r√©soudre de tels probl√®mes! <br><br>  Le livre vous donnera l'occasion d'approfondir le langage Python, de vous tester sur des t√¢ches, des exercices et des algorithmes √©prouv√©s par le temps.  Vous devez r√©soudre des dizaines de t√¢ches de programmation: des plus simples (par exemple, rechercher des √©l√©ments de liste √† l'aide du tri binaire) aux plus complexes (regrouper les donn√©es √† l'aide de la m√©thode k-means).  En vous servant d'exemples consacr√©s √† la recherche, au regroupement, aux graphiques, etc., vous vous souviendrez de ce que vous aviez oubli√© et ma√Ætriserez les techniques classiques de r√©solution des probl√®mes quotidiens. <br><a name="habracut"></a><br><h3>  √Ä qui s'adresse ce livre? </h3><br>  Ce livre est destin√© aux programmeurs de niveau moyen et √©lev√©.  Les professionnels exp√©riment√©s qui souhaitent approfondir leurs connaissances de Python trouveront ici des t√¢ches qui leur sont famili√®res √† partir du moment o√π ils ont enseign√© l'informatique ou la programmation.  Les programmeurs de niveau interm√©diaire se familiariseront avec ces t√¢ches classiques dans leur langue choisie - Python.  Pour les d√©veloppeurs qui se pr√©parent pour une interview de programmation, la publication est susceptible de devenir un pr√©cieux mat√©riel pr√©paratoire. <br><br>  En plus des programmeurs professionnels, ce livre peut √™tre consid√©r√© comme utile par les √©tudiants qui √©tudient pour les programmes de premier cycle en informatique et qui s'int√©ressent √† Python.  Il ne pr√©tend pas √™tre une introduction rigoureuse aux structures de donn√©es et aux algorithmes.  Ce n'est pas un tutoriel sur les structures de donn√©es et les algorithmes.  Vous ne trouverez aucune preuve de th√©or√®mes ou l‚Äôutilisation abondante d‚ÄôO grandes notations sur ses pages.  Au contraire, ce livre se positionne comme un guide pratique accessible des m√©thodes de r√©solution de probl√®mes qui devraient devenir le produit final de l'√©tude de la structure des donn√©es, des algorithmes et des classes d'intelligence artificielle. <br><br>  J'insiste √† nouveau: on suppose que les lecteurs connaissent la syntaxe et la s√©mantique de Python.  Il est peu probable qu'un lecteur sans exp√©rience de programmation puisse b√©n√©ficier de ce livre, et un programmeur sans exp√©rience en Python sera probablement difficile.  En d'autres termes, ¬´T√¢ches classiques en informatique en Python¬ª est un livre pour les programmeurs Python et les √©tudiants en informatique. <br><br><h3>  Extrait.  1.5.  Tours de Hanoi </h3><br>  Il y a trois hautes colonnes verticales (ci-apr√®s - tours).  Nous les d√©signerons A, B et C. Des disques avec des trous au centre sont enfil√©s sur la tour A. Le disque le plus large - nous l'appellerons disque 1 - est situ√© en dessous.  Les disques restants situ√©s au-dessus sont indiqu√©s par des nombres croissants et diminuent progressivement.  Par exemple, si nous avions trois disques, le plus large d'entre eux, celui ci-dessous, aurait le num√©ro 1. Le prochain disque le plus large, au num√©ro 2, serait situ√© au-dessus du disque 1. Enfin, le disque le plus √©troit, au num√©ro 3 se trouverait sur le disque 2. <br><br>  Notre objectif est de d√©placer tous les disques de la tour A vers la tour C, en tenant compte des restrictions suivantes. <br><br><ul><li>  Les disques ne peuvent √™tre d√©plac√©s qu'un par un. </li><li>  Le seul lecteur disponible pour le d√©placement est celui situ√© en haut de n'importe quelle tour. </li><li>  Un disque plus large ne peut jamais √™tre plac√© au-dessus d'un disque plus √©troit. <br>  Sch√©matiquement, la t√¢che est illustr√©e √† la Fig.  1.7. </li></ul><br><h3>  1.5.1.  Mod√©lisation de tour </h3><br>  Une pile est une structure de donn√©es mod√©lis√©e selon le principe du dernier entr√©, premier sorti (LIFO).  La derni√®re chose qui arrive sur la pile devient la premi√®re qui est r√©cup√©r√©e √† partir de l√†.  Les deux op√©rations principales de la pile sont push (put) et pop (extract).  L'op√©ration push pousse un nouvel √©l√©ment sur la pile, et pop le supprime de la pile et renvoie le dernier √©l√©ment ins√©r√©.  Vous pouvez facilement mod√©liser la pile en Python en utilisant la liste comme stockage de sauvegarde (Listing 1.20). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pz/a2/gs/pza2gsaqiqas4khvhhwc6hdnfwi.png" alt="image"></div><br>  Listing 1.20.  hanoi.py <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> typing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> TypeVar, Generic, List T = TypeVar(<span class="hljs-string"><span class="hljs-string">'T'</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stack</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Generic[T])</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> self._container: List[T] = [] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, item: T)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> self._container.append(item) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function"> -&gt; T:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._container.pop() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__repr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function"> -&gt; str:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> repr(self._container)</code> </pre> <br><blockquote>  La classe Stack pr√©sent√©e impl√©mente la m√©thode __repr __ (), qui facilite l'examen du contenu de la tour.  __repr __ () correspond √† la sortie lorsque la fonction print () est appliqu√©e √† la pile. </blockquote><br><blockquote>  Comme indiqu√© dans l'introduction, les annotations de type sont utilis√©es dans le livre.  L'importation de Generic √† partir d'un module d'entr√©e permet √† Stack d'√™tre une classe param√©trique pour un type sp√©cifique dans les annotations de type.  Un type arbitraire T est d√©fini dans T = TypeVar ('T').  T peut √™tre de tout type.  Lorsque l'annotation de type est ensuite utilis√©e pour Stack dans la r√©solution du probl√®me de la tour de Hanoi, l'invite sera Stack [int], c'est-√†-dire que le type int sera utilis√© √† la place de T.  En d'autres termes, ici la pile est une pile d'entiers.  Si vous rencontrez des difficult√©s avec les annotations de type, consultez l'annexe B. </blockquote><br>  Les piles sont parfaites pour le d√©fi de la tour de Hanoi.  Afin de d√©placer le disque vers la tour, nous pouvons utiliser l'op√©ration push.  Afin de d√©placer le disque d'une tour √† l'autre, nous pouvons le pousser du premier (pop) et le placer sur le second (push). <br><br>  D√©finissez les tours en tant qu'objets de pile et remplissez la premi√®re de disques (extrait 1.21). <br><br>  Listing 1.21.  hanoi.py (suite) <br><br><pre> <code class="python hljs">num_discs: int = <span class="hljs-number"><span class="hljs-number">3</span></span> tower_a: Stack[int] = Stack() tower_b: Stack[int] = Stack() tower_c: Stack[int] = Stack() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, num_discs + <span class="hljs-number"><span class="hljs-number">1</span></span>): tower_a.push(i)</code> </pre> <br><h3>  1.5.2.  R√©soudre le probl√®me des tours de Hanoi </h3><br>  Comment puis-je r√©soudre le probl√®me des tours de Hanoi?  Supposons que nous essayons de d√©placer un seul lecteur.  Ensuite, nous saurions comment faire cela, non?  En fait, le d√©placement d'un disque est un cas de base pour une solution r√©cursive √† ce probl√®me.  Le d√©placement de plusieurs disques est un cas r√©cursif.  Le point cl√© est que nous avons, en fait, deux sc√©narios qui doivent √™tre encod√©s: d√©placer un disque (cas de base) et d√©placer plusieurs disques (cas r√©cursif). <br><br>  Pour comprendre le cas r√©cursif, consid√©rons un exemple sp√©cifique.  Supposons que nous ayons trois disques - le haut, le milieu et le bas, situ√©s sur la tour A, et que nous voulons les d√©placer vers la tour C. (Par la suite, cela aidera √† d√©crire sch√©matiquement le probl√®me.) Premi√®rement, nous pourrions d√©placer le disque sup√©rieur vers la tour C. Ensuite - d√©placer le disque du milieu vers la tour B, puis le disque sup√©rieur de la tour C vers la tour B. Nous avons maintenant le disque inf√©rieur toujours situ√© sur la tour A et les deux disques sup√©rieurs sur la tour B. Essentiellement, nous avons d√©j√† r√©ussi √† d√©placer deux conduire d'une tour (A) √† une autre (B).  Le d√©placement du disque inf√©rieur de A vers C est le cas de base (d√©placement d'un disque).  Maintenant, nous pouvons d√©placer les deux disques sup√©rieurs de B vers C en utilisant la m√™me proc√©dure que de A vers B. Nous d√©pla√ßons le disque sup√©rieur vers A, le disque du milieu vers C et enfin le disque sup√©rieur de A vers C. <br><br><blockquote>  Dans les cours d'informatique, on trouve souvent de petits mod√®les de ces tours, construits √† partir de broches et de disques en plastique.  Vous pouvez cr√©er votre propre mod√®le avec trois crayons et trois feuilles de papier.  Cela vous aidera peut-√™tre √† visualiser la solution. </blockquote><br>  Dans l'exemple avec trois disques, il y avait un cas de base simple de d√©placement d'un disque et un cas r√©cursif de d√©placement des disques restants (dans ce cas deux) en utilisant une troisi√®me tour temporaire.  Nous pouvons diviser le cas r√©cursif en plusieurs √©tapes. <br><br><ol><li>  D√©placez les n - 1 lecteurs sup√©rieurs de la tour A vers la tour B (temporaire), en utilisant C comme tour interm√©diaire. </li><li>  D√©placez le lecteur inf√©rieur de A √† C. </li><li>  D√©placez n - 1 disques de la tour B vers la tour C, la tour A est interm√©diaire. </li></ol><br>  √âtonnamment, cet algorithme r√©cursif fonctionne non seulement pour trois, mais pour n'importe quel nombre de disques.  Encodez-le comme une fonction hanoi (), qui est responsable du d√©placement des disques d'une tour √† l'autre √† l'aide d'une troisi√®me tour temporaire (Listing 1.22). <br><br>  Listing 1.22.  hanoi.py (suite) <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hanoi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(begin: Stack[int], end: Stack[int], temp: Stack[int], n: int)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n == <span class="hljs-number"><span class="hljs-number">1</span></span>: end.push(begin.pop()) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: hanoi(begin, temp, end, n ‚Äî <span class="hljs-number"><span class="hljs-number">1</span></span>) hanoi(begin, end, temp, <span class="hljs-number"><span class="hljs-number">1</span></span>) hanoi(temp, end, begin, n - <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Apr√®s avoir appel√© hanoi (), vous devez v√©rifier les tours A, B et C pour vous assurer que les disques ont √©t√© d√©plac√©s avec succ√®s (extrait 1.23). <br><br>  Listing 1.23.  hanoi.py (suite) <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: hanoi(tower_a, tower_c, tower_b, num_discs) print(tower_a) print(tower_b) print(tower_c)</code> </pre> <br>  Vous constaterez que les disques ont bien √©t√© d√©plac√©s.  Lors du codage de la solution au probl√®me de la tour de Hanoi, il n'est pas n√©cessaire de comprendre toutes les √©tapes n√©cessaires pour d√©placer plusieurs disques de la tour A vers la tour C. Nous sommes arriv√©s √† comprendre l'algorithme g√©n√©ral r√©cursif pour d√©placer n'importe quel nombre de disques et le syst√©matiser, permettant √† l'ordinateur de faire le reste.  C'est le pouvoir de formuler des solutions r√©cursives aux probl√®mes: on peut souvent imaginer des solutions de mani√®re abstraite, sans gaspiller d'√©nergie sur la repr√©sentation mentale de chaque action individuelle. <br><br>  Soit dit en passant, la fonction hanoi () sera ex√©cut√©e de fa√ßon exponentielle en fonction du nombre de disques, ce qui rend la solution au probl√®me m√™me pour 64 disques inadapt√©e.  Vous pouvez essayer de l'ex√©cuter avec un nombre diff√©rent de disques en modifiant la variable num_discs.  √Ä mesure que le nombre de disques augmente, le nombre d'√©tapes pour terminer la t√¢che de la tour de Hanoi augmente de fa√ßon exponentielle; plus de d√©tails peuvent √™tre trouv√©s dans de nombreuses sources.  Si vous souhaitez en savoir plus sur les math√©matiques derri√®re la solution r√©cursive de ce probl√®me, voir l'explication de Karl Birch dans l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Sur les tours de Hanoi"</a> . <br><br><h3>  1.6.  De vraies applications </h3><br>  Les diff√©rentes m√©thodes pr√©sent√©es dans ce chapitre (r√©cursivit√©, m√©morisation, compression et manipulation au niveau du bit) sont tellement r√©pandues dans le d√©veloppement de logiciels modernes que sans elles, il est impossible d'imaginer le monde de l'informatique.  Malgr√© le fait que les t√¢ches peuvent √™tre r√©solues sans elles, il est souvent plus logique ou plus opportun de les r√©soudre en utilisant ces m√©thodes. <br><br>  En particulier, la r√©cursivit√© sous-tend non seulement de nombreux algorithmes, mais m√™me des langages de programmation entiers.  Dans certains langages de programmation fonctionnels, tels que Scheme et Haskell, la r√©cursion remplace les boucles utilis√©es dans les langages imp√©ratifs.  Cependant, il ne faut pas oublier que tout ce qui peut √™tre r√©alis√© en utilisant la m√©thode r√©cursive peut √©galement √™tre effectu√© de mani√®re it√©rative. <br><br>  La m√©morisation a √©t√© utilis√©e avec succ√®s pour acc√©l√©rer le travail des analyseurs - programmes qui interpr√®tent les langues.  Ceci est utile dans toutes les t√¢ches o√π le r√©sultat d'un calcul r√©cent est susceptible d'√™tre demand√© √† nouveau.  Un autre domaine d'action pour la m√©morisation est le runtime du langage de programmation.  Certains de ces environnements d'ex√©cution, par exemple, pour la version Prolog, enregistrent automatiquement les r√©sultats des appels de fonction (auto-mash), de sorte que la fonction n'a pas √† √™tre ex√©cut√©e la prochaine fois avec le m√™me appel.  Ceci est similaire au d√©corateur @lru_cache () dans fib6 (). <br><br>  La compression a rendu le monde d'Internet, avec sa bande passante limit√©e, plus supportable.  La m√©thode des cha√Ænes de bits discut√©e dans la section 1.2 est applicable aux types de donn√©es simples dans le monde r√©el qui ont un nombre limit√© de valeurs possibles, pour lesquelles m√™me 1 octet est redondant.  Cependant, la plupart des algorithmes de compression fonctionnent en recherchant des mod√®les ou des structures dans un ensemble de donn√©es qui √©liminent les informations en double.  Ils sont beaucoup plus compliqu√©s que ceux d√©crits dans la section 1.2. <br><br>  Les chiffres jetables ne conviennent pas aux cas de chiffrement g√©n√©ral.  Ils n√©cessitent que l'encodeur et le d√©codeur aient une des cl√©s (donn√©es factices dans notre exemple) pour restaurer les donn√©es d'origine, ce qui est trop lourd et dans la plupart des sch√©mas de cryptage ne permet pas d'atteindre l'objectif de garder les cl√©s secr√®tes.  Mais vous pourriez √™tre int√©ress√© de savoir que le nom ¬´chiffrement jetable¬ª a √©t√© invent√© par des espions qui, pendant la guerre froide, ont utilis√© de vrais cahiers en papier avec des donn√©es fictives enregistr√©es pour cr√©er des messages crypt√©s. <br><br>  Ces m√©thodes sont les √©l√©ments constitutifs des programmes; d'autres algorithmes sont bas√©s sur eux.  Dans les chapitres suivants, vous verrez √† quel point ils sont appliqu√©s. <br><br><h3>  √Ä propos de l'auteur </h3><br>  <b>David Kopec</b> est ma√Ætre de conf√©rences en informatique et innovation au Champlain College de Burlington, au Vermont.  Il est un d√©veloppeur de logiciels exp√©riment√© et auteur de Classic Computer Science Problems in Swift (Manning, 2018) et Dart for Absolute Beginners (Apress, 2014).  David a obtenu un baccalaur√©at en √©conomie et une ma√Ætrise en informatique du Dartmouth College.  Vous pouvez le contacter sur Twitter par @davekopec. <br><br>  ¬ªPlus d'informations sur le livre sont disponibles sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le site Web de l'√©diteur</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Contenu</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Extrait</a> <br><br>  25% de r√©duction sur les colporteurs - <b>Python</b> <br><br>  Lors du paiement de la version papier du livre, un livre √©lectronique est envoy√© par e-mail. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr471520/">https://habr.com/ru/post/fr471520/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr471508/index.html">Administrateur sans bras = hyperconvergence?</a></li>
<li><a href="../fr471512/index.html">28 octobre, Iekaterinbourg - Communication de qualit√©</a></li>
<li><a href="../fr471514/index.html">La rubrique ¬´Lisez des articles pour vous¬ª. Janvier - juin 2019</a></li>
<li><a href="../fr471516/index.html">Intel 665p - SSD avec NAND QLC √† 96 couches</a></li>
<li><a href="../fr471518/index.html">Apple en 2019 est Linux en 2000</a></li>
<li><a href="../fr471522/index.html">Askozia. Fonctionnement de l'autoprovisioning Plug & Play</a></li>
<li><a href="../fr471524/index.html">Traduction compl√®te des instructions pour les √©valuateurs Google</a></li>
<li><a href="../fr471528/index.html">D√©ployer des applications √† l'aide de Docker Swarm</a></li>
<li><a href="../fr471530/index.html">GitLab a parcouru un chemin inhabituel vers CI / CD et Kubernetes</a></li>
<li><a href="../fr471532/index.html">Au revoir PCB; bonjour interconnexion silicium</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>