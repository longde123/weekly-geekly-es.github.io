<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🎤 👩🏿‍🤝‍👩🏽 🎒 Le livre "Tâches classiques en informatique en Python" 📴 ♏️ 👩🏻‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De nombreuses tâches dans le domaine de l'informatique, qui à première vue semblent nouvelles ou uniques, sont en fait ancrées dans des algorithmes cl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Le livre "Tâches classiques en informatique en Python"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/471520/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/op/8x/zc/op8xzcjsvwkjzgse183iwfc_sdw.jpeg" align="left" alt="image"></a>  De nombreuses tâches dans le domaine de l'informatique, qui à première vue semblent nouvelles ou uniques, sont en fait ancrées dans des algorithmes classiques, des méthodes de codage et des principes de développement.  Et les techniques établies sont toujours le meilleur moyen de résoudre de tels problèmes! <br><br>  Le livre vous donnera l'occasion d'approfondir le langage Python, de vous tester sur des tâches, des exercices et des algorithmes éprouvés par le temps.  Vous devez résoudre des dizaines de tâches de programmation: des plus simples (par exemple, rechercher des éléments de liste à l'aide du tri binaire) aux plus complexes (regrouper les données à l'aide de la méthode k-means).  En vous servant d'exemples consacrés à la recherche, au regroupement, aux graphiques, etc., vous vous souviendrez de ce que vous aviez oublié et maîtriserez les techniques classiques de résolution des problèmes quotidiens. <br><a name="habracut"></a><br><h3>  À qui s'adresse ce livre? </h3><br>  Ce livre est destiné aux programmeurs de niveau moyen et élevé.  Les professionnels expérimentés qui souhaitent approfondir leurs connaissances de Python trouveront ici des tâches qui leur sont familières à partir du moment où ils ont enseigné l'informatique ou la programmation.  Les programmeurs de niveau intermédiaire se familiariseront avec ces tâches classiques dans leur langue choisie - Python.  Pour les développeurs qui se préparent pour une interview de programmation, la publication est susceptible de devenir un précieux matériel préparatoire. <br><br>  En plus des programmeurs professionnels, ce livre peut être considéré comme utile par les étudiants qui étudient pour les programmes de premier cycle en informatique et qui s'intéressent à Python.  Il ne prétend pas être une introduction rigoureuse aux structures de données et aux algorithmes.  Ce n'est pas un tutoriel sur les structures de données et les algorithmes.  Vous ne trouverez aucune preuve de théorèmes ou l’utilisation abondante d’O grandes notations sur ses pages.  Au contraire, ce livre se positionne comme un guide pratique accessible des méthodes de résolution de problèmes qui devraient devenir le produit final de l'étude de la structure des données, des algorithmes et des classes d'intelligence artificielle. <br><br>  J'insiste à nouveau: on suppose que les lecteurs connaissent la syntaxe et la sémantique de Python.  Il est peu probable qu'un lecteur sans expérience de programmation puisse bénéficier de ce livre, et un programmeur sans expérience en Python sera probablement difficile.  En d'autres termes, «Tâches classiques en informatique en Python» est un livre pour les programmeurs Python et les étudiants en informatique. <br><br><h3>  Extrait.  1.5.  Tours de Hanoi </h3><br>  Il y a trois hautes colonnes verticales (ci-après - tours).  Nous les désignerons A, B et C. Des disques avec des trous au centre sont enfilés sur la tour A. Le disque le plus large - nous l'appellerons disque 1 - est situé en dessous.  Les disques restants situés au-dessus sont indiqués par des nombres croissants et diminuent progressivement.  Par exemple, si nous avions trois disques, le plus large d'entre eux, celui ci-dessous, aurait le numéro 1. Le prochain disque le plus large, au numéro 2, serait situé au-dessus du disque 1. Enfin, le disque le plus étroit, au numéro 3 se trouverait sur le disque 2. <br><br>  Notre objectif est de déplacer tous les disques de la tour A vers la tour C, en tenant compte des restrictions suivantes. <br><br><ul><li>  Les disques ne peuvent être déplacés qu'un par un. </li><li>  Le seul lecteur disponible pour le déplacement est celui situé en haut de n'importe quelle tour. </li><li>  Un disque plus large ne peut jamais être placé au-dessus d'un disque plus étroit. <br>  Schématiquement, la tâche est illustrée à la Fig.  1.7. </li></ul><br><h3>  1.5.1.  Modélisation de tour </h3><br>  Une pile est une structure de données modélisée selon le principe du dernier entré, premier sorti (LIFO).  La dernière chose qui arrive sur la pile devient la première qui est récupérée à partir de là.  Les deux opérations principales de la pile sont push (put) et pop (extract).  L'opération push pousse un nouvel élément sur la pile, et pop le supprime de la pile et renvoie le dernier élément inséré.  Vous pouvez facilement modéliser la pile en Python en utilisant la liste comme stockage de sauvegarde (Listing 1.20). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pz/a2/gs/pza2gsaqiqas4khvhhwc6hdnfwi.png" alt="image"></div><br>  Listing 1.20.  hanoi.py <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> typing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> TypeVar, Generic, List T = TypeVar(<span class="hljs-string"><span class="hljs-string">'T'</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stack</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Generic[T])</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> self._container: List[T] = [] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, item: T)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> self._container.append(item) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function"> -&gt; T:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._container.pop() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__repr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function"> -&gt; str:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> repr(self._container)</code> </pre> <br><blockquote>  La classe Stack présentée implémente la méthode __repr __ (), qui facilite l'examen du contenu de la tour.  __repr __ () correspond à la sortie lorsque la fonction print () est appliquée à la pile. </blockquote><br><blockquote>  Comme indiqué dans l'introduction, les annotations de type sont utilisées dans le livre.  L'importation de Generic à partir d'un module d'entrée permet à Stack d'être une classe paramétrique pour un type spécifique dans les annotations de type.  Un type arbitraire T est défini dans T = TypeVar ('T').  T peut être de tout type.  Lorsque l'annotation de type est ensuite utilisée pour Stack dans la résolution du problème de la tour de Hanoi, l'invite sera Stack [int], c'est-à-dire que le type int sera utilisé à la place de T.  En d'autres termes, ici la pile est une pile d'entiers.  Si vous rencontrez des difficultés avec les annotations de type, consultez l'annexe B. </blockquote><br>  Les piles sont parfaites pour le défi de la tour de Hanoi.  Afin de déplacer le disque vers la tour, nous pouvons utiliser l'opération push.  Afin de déplacer le disque d'une tour à l'autre, nous pouvons le pousser du premier (pop) et le placer sur le second (push). <br><br>  Définissez les tours en tant qu'objets de pile et remplissez la première de disques (extrait 1.21). <br><br>  Listing 1.21.  hanoi.py (suite) <br><br><pre> <code class="python hljs">num_discs: int = <span class="hljs-number"><span class="hljs-number">3</span></span> tower_a: Stack[int] = Stack() tower_b: Stack[int] = Stack() tower_c: Stack[int] = Stack() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, num_discs + <span class="hljs-number"><span class="hljs-number">1</span></span>): tower_a.push(i)</code> </pre> <br><h3>  1.5.2.  Résoudre le problème des tours de Hanoi </h3><br>  Comment puis-je résoudre le problème des tours de Hanoi?  Supposons que nous essayons de déplacer un seul lecteur.  Ensuite, nous saurions comment faire cela, non?  En fait, le déplacement d'un disque est un cas de base pour une solution récursive à ce problème.  Le déplacement de plusieurs disques est un cas récursif.  Le point clé est que nous avons, en fait, deux scénarios qui doivent être encodés: déplacer un disque (cas de base) et déplacer plusieurs disques (cas récursif). <br><br>  Pour comprendre le cas récursif, considérons un exemple spécifique.  Supposons que nous ayons trois disques - le haut, le milieu et le bas, situés sur la tour A, et que nous voulons les déplacer vers la tour C. (Par la suite, cela aidera à décrire schématiquement le problème.) Premièrement, nous pourrions déplacer le disque supérieur vers la tour C. Ensuite - déplacer le disque du milieu vers la tour B, puis le disque supérieur de la tour C vers la tour B. Nous avons maintenant le disque inférieur toujours situé sur la tour A et les deux disques supérieurs sur la tour B. Essentiellement, nous avons déjà réussi à déplacer deux conduire d'une tour (A) à une autre (B).  Le déplacement du disque inférieur de A vers C est le cas de base (déplacement d'un disque).  Maintenant, nous pouvons déplacer les deux disques supérieurs de B vers C en utilisant la même procédure que de A vers B. Nous déplaçons le disque supérieur vers A, le disque du milieu vers C et enfin le disque supérieur de A vers C. <br><br><blockquote>  Dans les cours d'informatique, on trouve souvent de petits modèles de ces tours, construits à partir de broches et de disques en plastique.  Vous pouvez créer votre propre modèle avec trois crayons et trois feuilles de papier.  Cela vous aidera peut-être à visualiser la solution. </blockquote><br>  Dans l'exemple avec trois disques, il y avait un cas de base simple de déplacement d'un disque et un cas récursif de déplacement des disques restants (dans ce cas deux) en utilisant une troisième tour temporaire.  Nous pouvons diviser le cas récursif en plusieurs étapes. <br><br><ol><li>  Déplacez les n - 1 lecteurs supérieurs de la tour A vers la tour B (temporaire), en utilisant C comme tour intermédiaire. </li><li>  Déplacez le lecteur inférieur de A à C. </li><li>  Déplacez n - 1 disques de la tour B vers la tour C, la tour A est intermédiaire. </li></ol><br>  Étonnamment, cet algorithme récursif fonctionne non seulement pour trois, mais pour n'importe quel nombre de disques.  Encodez-le comme une fonction hanoi (), qui est responsable du déplacement des disques d'une tour à l'autre à l'aide d'une troisième tour temporaire (Listing 1.22). <br><br>  Listing 1.22.  hanoi.py (suite) <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hanoi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(begin: Stack[int], end: Stack[int], temp: Stack[int], n: int)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n == <span class="hljs-number"><span class="hljs-number">1</span></span>: end.push(begin.pop()) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: hanoi(begin, temp, end, n — <span class="hljs-number"><span class="hljs-number">1</span></span>) hanoi(begin, end, temp, <span class="hljs-number"><span class="hljs-number">1</span></span>) hanoi(temp, end, begin, n - <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Après avoir appelé hanoi (), vous devez vérifier les tours A, B et C pour vous assurer que les disques ont été déplacés avec succès (extrait 1.23). <br><br>  Listing 1.23.  hanoi.py (suite) <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: hanoi(tower_a, tower_c, tower_b, num_discs) print(tower_a) print(tower_b) print(tower_c)</code> </pre> <br>  Vous constaterez que les disques ont bien été déplacés.  Lors du codage de la solution au problème de la tour de Hanoi, il n'est pas nécessaire de comprendre toutes les étapes nécessaires pour déplacer plusieurs disques de la tour A vers la tour C. Nous sommes arrivés à comprendre l'algorithme général récursif pour déplacer n'importe quel nombre de disques et le systématiser, permettant à l'ordinateur de faire le reste.  C'est le pouvoir de formuler des solutions récursives aux problèmes: on peut souvent imaginer des solutions de manière abstraite, sans gaspiller d'énergie sur la représentation mentale de chaque action individuelle. <br><br>  Soit dit en passant, la fonction hanoi () sera exécutée de façon exponentielle en fonction du nombre de disques, ce qui rend la solution au problème même pour 64 disques inadaptée.  Vous pouvez essayer de l'exécuter avec un nombre différent de disques en modifiant la variable num_discs.  À mesure que le nombre de disques augmente, le nombre d'étapes pour terminer la tâche de la tour de Hanoi augmente de façon exponentielle; plus de détails peuvent être trouvés dans de nombreuses sources.  Si vous souhaitez en savoir plus sur les mathématiques derrière la solution récursive de ce problème, voir l'explication de Karl Birch dans l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Sur les tours de Hanoi"</a> . <br><br><h3>  1.6.  De vraies applications </h3><br>  Les différentes méthodes présentées dans ce chapitre (récursivité, mémorisation, compression et manipulation au niveau du bit) sont tellement répandues dans le développement de logiciels modernes que sans elles, il est impossible d'imaginer le monde de l'informatique.  Malgré le fait que les tâches peuvent être résolues sans elles, il est souvent plus logique ou plus opportun de les résoudre en utilisant ces méthodes. <br><br>  En particulier, la récursivité sous-tend non seulement de nombreux algorithmes, mais même des langages de programmation entiers.  Dans certains langages de programmation fonctionnels, tels que Scheme et Haskell, la récursion remplace les boucles utilisées dans les langages impératifs.  Cependant, il ne faut pas oublier que tout ce qui peut être réalisé en utilisant la méthode récursive peut également être effectué de manière itérative. <br><br>  La mémorisation a été utilisée avec succès pour accélérer le travail des analyseurs - programmes qui interprètent les langues.  Ceci est utile dans toutes les tâches où le résultat d'un calcul récent est susceptible d'être demandé à nouveau.  Un autre domaine d'action pour la mémorisation est le runtime du langage de programmation.  Certains de ces environnements d'exécution, par exemple, pour la version Prolog, enregistrent automatiquement les résultats des appels de fonction (auto-mash), de sorte que la fonction n'a pas à être exécutée la prochaine fois avec le même appel.  Ceci est similaire au décorateur @lru_cache () dans fib6 (). <br><br>  La compression a rendu le monde d'Internet, avec sa bande passante limitée, plus supportable.  La méthode des chaînes de bits discutée dans la section 1.2 est applicable aux types de données simples dans le monde réel qui ont un nombre limité de valeurs possibles, pour lesquelles même 1 octet est redondant.  Cependant, la plupart des algorithmes de compression fonctionnent en recherchant des modèles ou des structures dans un ensemble de données qui éliminent les informations en double.  Ils sont beaucoup plus compliqués que ceux décrits dans la section 1.2. <br><br>  Les chiffres jetables ne conviennent pas aux cas de chiffrement général.  Ils nécessitent que l'encodeur et le décodeur aient une des clés (données factices dans notre exemple) pour restaurer les données d'origine, ce qui est trop lourd et dans la plupart des schémas de cryptage ne permet pas d'atteindre l'objectif de garder les clés secrètes.  Mais vous pourriez être intéressé de savoir que le nom «chiffrement jetable» a été inventé par des espions qui, pendant la guerre froide, ont utilisé de vrais cahiers en papier avec des données fictives enregistrées pour créer des messages cryptés. <br><br>  Ces méthodes sont les éléments constitutifs des programmes; d'autres algorithmes sont basés sur eux.  Dans les chapitres suivants, vous verrez à quel point ils sont appliqués. <br><br><h3>  À propos de l'auteur </h3><br>  <b>David Kopec</b> est maître de conférences en informatique et innovation au Champlain College de Burlington, au Vermont.  Il est un développeur de logiciels expérimenté et auteur de Classic Computer Science Problems in Swift (Manning, 2018) et Dart for Absolute Beginners (Apress, 2014).  David a obtenu un baccalauréat en économie et une maîtrise en informatique du Dartmouth College.  Vous pouvez le contacter sur Twitter par @davekopec. <br><br>  »Plus d'informations sur le livre sont disponibles sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le site Web de l'éditeur</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Contenu</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Extrait</a> <br><br>  25% de réduction sur les colporteurs - <b>Python</b> <br><br>  Lors du paiement de la version papier du livre, un livre électronique est envoyé par e-mail. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr471520/">https://habr.com/ru/post/fr471520/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr471508/index.html">Administrateur sans bras = hyperconvergence?</a></li>
<li><a href="../fr471512/index.html">28 octobre, Iekaterinbourg - Communication de qualité</a></li>
<li><a href="../fr471514/index.html">La rubrique «Lisez des articles pour vous». Janvier - juin 2019</a></li>
<li><a href="../fr471516/index.html">Intel 665p - SSD avec NAND QLC à 96 couches</a></li>
<li><a href="../fr471518/index.html">Apple en 2019 est Linux en 2000</a></li>
<li><a href="../fr471522/index.html">Askozia. Fonctionnement de l'autoprovisioning Plug & Play</a></li>
<li><a href="../fr471524/index.html">Traduction complète des instructions pour les évaluateurs Google</a></li>
<li><a href="../fr471528/index.html">Déployer des applications à l'aide de Docker Swarm</a></li>
<li><a href="../fr471530/index.html">GitLab a parcouru un chemin inhabituel vers CI / CD et Kubernetes</a></li>
<li><a href="../fr471532/index.html">Au revoir PCB; bonjour interconnexion silicium</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>