<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🤝‍👩🏻 ♌️ 🎇 Erstellen von Tracks im Schnee in Unreal Engine 4 🎒 🥗 💪🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Sie moderne AAA-Spiele spielen, haben Sie möglicherweise eine Tendenz zur Verwendung schneebedeckter Landschaften bemerkt. Zum Beispiel sind sie ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen von Tracks im Schnee in Unreal Engine 4</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416703/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ox/49/ct/ox49ctzii2nk6gryoeuvbcxf96a.gif"></div><br>  Wenn Sie moderne AAA-Spiele spielen, haben Sie möglicherweise eine Tendenz zur Verwendung schneebedeckter Landschaften bemerkt.  Zum Beispiel sind sie in <i>Horizon Zero Dawn</i> , <i>Rise of the Tomb Raider</i> und <i>God of War</i> .  In all diesen Spielen hat der Schnee eine wichtige Eigenschaft: Sie können Spuren hinterlassen! <br><br>  Dank dieser Interaktion mit der Umgebung wird das Eintauchen des Spielers in das Spiel verbessert.  Es macht die Umgebung realistischer und seien wir ehrlich - es ist einfach interessant.  Warum lange Stunden damit verbringen, einen neugierigen Mechaniker zu erschaffen, wenn Sie den Spieler einfach zu Boden fallen lassen und Schneeengel machen können? <br><br>  In diesem Tutorial lernen Sie Folgendes: <br><br><ul><li>  Erstellen Sie mithilfe der Szenenaufnahme Fußabdrücke, um Objekte in Bodennähe zu maskieren </li><li>  Verwenden Sie eine Maske mit Geländematerial, um verformbaren Schnee zu erzeugen </li><li>  Zeigen Sie zur Optimierung Fußabdrücke im Schnee nur neben dem Spieler an </li></ul><a name="habracut"></a><br><blockquote>  <em>Hinweis:</em> Es versteht sich, dass Sie bereits mit den Grundlagen der Arbeit mit Unreal Engine vertraut sind.  Wenn Sie neu sind, lesen Sie unsere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unreal Engine-</a> Lernserie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">für Anfänger</a> . </blockquote><br><h2>  An die Arbeit gehen </h2><br>  Laden Sie <a href="">Materialien</a> für dieses Tutorial herunter.  Entpacke sie, gehe zu <em>SnowDeformationStarter</em> und öffne <em>SnowDeformation.uproject</em> .  In diesem Tutorial erstellen wir Spuren mit Hilfe eines Charakters und mehrerer Kästchen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1f/8c7/b72/a1f8c7b7279319c558685c1b09858726.gif"></div><br>  Bevor wir beginnen, müssen Sie wissen, dass die Methode aus diesem Lernprogramm nur Spuren in einem bestimmten Bereich und nicht auf der ganzen Welt speichert, da die Geschwindigkeit von der Auflösung des Ziel-Renderings abhängt. <br><br>  Wenn wir beispielsweise Spuren für einen großen Bereich speichern möchten, müssen wir die Auflösung erhöhen.  Es erhöht aber auch den Einfluss der Szenenaufnahme auf die Spielgeschwindigkeit und die Speichergröße für das Ziel-Rendering.  Zur Optimierung müssen Sie den Umfang und die Auflösung einschränken. <br><br>  Nachdem wir uns damit befasst haben, wollen wir herausfinden, was nötig ist, um die Fußabdrücke im Schnee zu erkennen. <br><br><h2>  Umsetzung von Fußabdrücken im Schnee </h2><br>  Das erste, was Sie zum Erstellen von Traces benötigen, ist das <em>Ziel-Rendering</em> .  Das Rendering-Ziel ist eine Maske in Graustufen, in der Weiß das Vorhandensein einer Spur und Schwarz das Fehlen einer Spur anzeigt.  Dann können wir das Ziel-Rendering auf den Boden projizieren und damit die Texturen mischen und die Eckpunkte verschieben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea7/f0c/7f4/ea7f0c7f4eee82e34ebf74afeab25a72.gif"></div><br>  Das zweite, was wir brauchen, ist eine Möglichkeit, nur Objekte zu maskieren, die den Schnee beeinflussen.  Dies kann implementiert werden, indem zuerst die Objekte in der <em>benutzerdefinierten Tiefe</em> gerendert werden.  Anschließend können Sie die <em>Szenenaufnahme</em> mit dem <em>Nachbearbeitungsmaterial verwenden</em> , um alle in der benutzerdefinierten Tiefe gerenderten Objekte zu maskieren.  Anschließend können Sie die Maske im Zielrender anzeigen. <br><br><blockquote>  <em>Hinweis: Bei der</em> Szenenaufnahme handelt es sich im Wesentlichen um eine Kamera mit der Fähigkeit, ein Ziel-Rendering auszugeben. </blockquote><br>  Der wichtigste Teil bei der Aufnahme einer Szene ist ihre Position.  Das folgende Beispiel zeigt ein Ziel-Rendering, das in einer <em>Draufsicht</em> erfasst wurde.  Hier werden ein Charakter und Kästchen einer dritten Person maskiert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/886/2e0/4cf/8862e04cfeb3f6ce26918d4ffa8b00a0.jpg"></div><br>  Auf den ersten Blick passt eine Aufnahme mit Draufsicht zu uns.  Formulare sehen für Netze angemessen aus, daher sollte es keine Probleme geben, oder? <br><br>  Nicht wirklich.  Das Problem bei der Erfassung aus der Draufsicht besteht darin, dass unter der breitesten Stelle nichts erfasst wird.  Hier ist ein Beispiel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ae/952/8b1/6ae9528b111143c408aab2642fe4c781.gif"></div><br>  Stellen Sie sich vor, die gelben Pfeile gehen bis zum Boden.  Bei einem Würfel und einem Kegel bleibt die Pfeilspitze immer im Objekt.  Bei einer Kugel entsteht jedoch der Punkt, wenn sie sich der Erde nähert.  Laut Kamera befindet sich die Spitze jedoch immer innerhalb der Kugel.  So sieht die Kugel für die Kamera aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35f/580/cab/35f580cab1df39d4707c344f9e902e9d.jpg"></div><br>  Daher ist die Kugelmaske größer als sie sollte, selbst wenn die Kontaktfläche mit der Erde klein ist. <br><br>  Darüber hinaus wird dieses Problem durch die Tatsache ergänzt, dass es für uns schwierig ist festzustellen, ob das Objekt das Land betrifft. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e3/df9/a48/9e3df9a4804b5c317f40f57389fc1a8c.gif"></div><br>  Um diese beiden Probleme zu lösen, können Sie die Erfassung <em>von unten verwenden</em> . <br><br><h3>  Unterer Griff </h3><br>  Die Aufnahme von unten ist wie folgt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c3f/348/aad/c3f348aad117b479acf5fd9505f9c860.gif"></div><br>  Wie Sie sehen können, erfasst die Kamera jetzt die untere Seite, dh diejenige, die den Boden berührt.  Dies beseitigt das Problem des "breitesten Bereichs", der bei der Aufnahme von oben auftritt. <br><br>  Um festzustellen, ob ein Objekt den Boden berührt, können Sie mit Nachbearbeitungsmaterial eine Tiefenprüfung durchführen.  Es wird geprüft, ob die Tiefe des Objekts größer als die Tiefe der Erde ist <i>und</i> ob sie unter einem vorgegebenen Versatz liegt.  Wenn beide Bedingungen erfüllt sind, können wir dieses Pixel maskieren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a6b/83f/e87/a6b83fe8713950c52f917314de9d7c88.jpg"></div><br>  Unten sehen Sie ein Beispiel in einem Motor mit einer Erfassungszone von 20 Einheiten über dem Boden.  Beachten Sie, dass die Maske nur angezeigt wird, wenn das Objekt einen bestimmten Punkt passiert.  Beachten Sie auch, dass die Maske weißer wird, wenn sich das Objekt dem Boden nähert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/949/1bb/d76/9491bbd768781cbca7c07a652172ba2c.gif"></div><br>  Erstellen Sie zunächst ein Nachbearbeitungsmaterial, um eine Tiefenprüfung durchzuführen. <br><br><h2>  Erstellen von Tiefenprüfmaterial </h2><br>  Um eine Tiefenprüfung durchzuführen, müssen Sie zwei Tiefenpuffer verwenden - einen für den Boden und einen für Objekte, die den Schnee beeinflussen.  Da beim Erfassen der Szene nur die Erde gesehen wird, leitet die Szenentiefe die Tiefe für die Erde ab.  Um die Tiefe für Objekte zu erhalten, rendern wir sie einfach in die <em>benutzerdefinierte Tiefe</em> . <br><br><blockquote>  <em>Hinweis:</em> Um Zeit zu sparen, habe ich die Zeichen und Felder bereits in Benutzerdefinierte Tiefe gerendert.  Wenn Sie andere Objekte hinzufügen möchten, die sich auf den Schnee auswirken, müssen Sie den <em>Render CustomDepth Pass</em> für diese <em>aktivieren</em> . </blockquote><br>  Zunächst müssen Sie den Abstand jedes Pixels zum Boden berechnen.  Öffnen Sie <em>Materials \ PP_DepthCheck</em> und erstellen Sie Folgendes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f32/7bb/226/f327bb226d1764c3f848d1c43a6304ca.jpg"></div><br>  Als Nächstes müssen Sie eine Erfassungszone erstellen.  Fügen Sie dazu die markierten Knoten hinzu: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/908/37d/0eb/90837d0eb07af42121b2a113b1229230.jpg"></div><br>  Befindet sich das Pixel nun innerhalb von <em>25</em> Einheiten von der Erde, wird es in der Maske angezeigt.  Die Maskierungshelligkeit hängt davon ab, wie nahe das Pixel am Boden liegt.  Klicken Sie auf <em>Übernehmen</em> und kehren Sie zum <em>Haupteditor</em> zurück. <br><br>  Als nächstes müssen Sie eine Szenenaufnahme erstellen. <br><br><h2>  Szenenaufnahme erstellen </h2><br>  Zunächst benötigen wir ein Ziel-Rendering, in dem eine Szenenaufnahme erfasst werden kann.  <em>Wechseln Sie zum</em> Ordner <em>RenderTargets</em> und erstellen Sie ein neues <em>Renderziel mit dem</em> Namen <em>RT_Capture</em> . <br><br>  Jetzt erstellen wir eine Szenenaufnahme.  In diesem Tutorial fügen wir dem Entwurf eine Szenenaufnahme hinzu, da wir später ein Skript dafür benötigen.  Öffnen Sie <em>Blueprints \ BP_Capture</em> und fügen Sie die <em>Scene Capture-Komponente 2D hinzu</em> .  <em>Nennen Sie</em> es <em>SceneCapture</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d0/df9/915/3d0df9915e8aa04d9577193a53bcfc05.jpg"></div><br>  Zuerst müssen wir die Fangkurve so einstellen, dass sie auf den Boden schaut.  Gehen Sie zum Detailfenster und stellen Sie die <em>Drehung auf</em> <em>(0, 90, 90)</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e2/c35/407/6e2c354070055e1f427d626b1c0df408.jpg"></div><br>  Als nächstes kommt die Art der Projektion.  Da die Maske eine 2D-Darstellung der Szene ist, müssen wir die perspektivische Verzerrung beseitigen.  Setzen Sie dazu <em>Projektion \ Projektionstyp</em> auf <em>Orthographisch</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/78b/e54/adf/78be54adf3666b52564582f07153f8df.jpg"></div><br>  Als nächstes müssen wir der Szenenaufnahme mitteilen, auf welches Ziel-Rendering aufgenommen werden soll.  <em>Wählen</em> Sie dazu den Wert von <em>RT_Capture</em> für <em>Scene Capture \ Texture Target</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c6/a76/2c5/5c6a762c53867499e5f3ace3de1b1eee.jpg"></div><br>  Schließlich müssen wir Material zur Tiefenprüfung verwenden.  Fügen Sie PP_DepthCheck zu den <em>Rendering-Funktionen \</em> Nachbearbeitungsmaterialien hinzu.  Damit die Nachbearbeitung funktioniert, müssen wir auch die <em>Szenenaufnahme \ Aufnahmequelle</em> <em>in RGB</em> in <em>Final Color (LDR)</em> ändern. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ec/1f1/26f/3ec1f126fce6ccea0625ae5d33193fdd.jpg"></div><br>  Nachdem die Szenenaufnahme konfiguriert ist, müssen wir die Größe des Aufnahmebereichs angeben. <br><br><h3>  Festlegen der Größe des Erfassungsbereichs </h3><br>  Da es besser ist, niedrige Auflösungen für das Ziel-Rendering zu verwenden, müssen wir den Speicherplatz effizient nutzen.  Das heißt, wir müssen auswählen, welchen Bereich ein Pixel abdecken soll.  Wenn beispielsweise die Auflösungen des Erfassungsbereichs und des Ziel-Renderings gleich sind, erhalten wir ein Verhältnis von 1: 1.  Jedes Pixel deckt einen 1 × 1-Bereich ab (in Einheiten der Welt). <br><br>  Für Strecken im Schnee ist kein Verhältnis von 1: 1 erforderlich, da wir solche Details höchstwahrscheinlich nicht benötigen.  Ich empfehle die Verwendung größerer Verhältnisse, da Sie so den Aufnahmebereich bei niedriger Auflösung vergrößern können.  Aber machen Sie das Verhältnis nicht zu groß, sonst gehen die Details verloren.  In diesem Tutorial verwenden wir ein Verhältnis von 8: 1, dh die Größe jedes Pixels beträgt 8 × 8 Einheiten der Welt. <br><br>  Sie können die Größe des Erfassungsbereichs ändern, indem Sie die Eigenschaft <em>Szenenerfassung \ Orthobreite</em> ändern.  Wenn Sie beispielsweise einen Bereich von 1024 × 1024 erfassen möchten, setzen Sie den Wert auf 1024. Da wir ein Verhältnis von 8: 1 verwenden, setzen Sie den Wert auf <em>2048</em> (die Standardauflösung des Ziel-Renderings beträgt 256 × 256). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/411/c60/994/411c60994d4b52dc80553a375496363b.jpg"></div><br>  Dies bedeutet, dass die Szenenaufnahme den Bereich von <em>2048 × 2048</em> erfasst.  Es ist ungefähr 20 × 20 Meter. <br><br>  Das Grundmaterial benötigt auch Zugriff auf die Erfassungsgröße, um das Ziel-Rendering ordnungsgemäß zu projizieren.  Der einfachste Weg, dies zu tun, besteht darin, die Erfassungsgröße in der <em>Materialparametersammlung zu</em> speichern.  Dies ist im Wesentlichen eine Sammlung von Variablen, auf die <i>jedes</i> Material zugreifen kann. <br><br><h3>  Speichergröße speichern </h3><br>  Kehren Sie zum Haupteditor zurück und wechseln Sie zum Ordner <em>Materialien</em> .  Erstellen Sie eine <em>Materialparametersammlung</em> , die sich in <em>Materialien und Texturen befindet</em> .  Benennen Sie es in <em>MPC_Capture um</em> und öffnen Sie es. <br><br>  Erstellen Sie dann einen neuen <em>Skalarparameter</em> und nennen Sie ihn <em>CaptureSize</em> .  Mach dir keine Sorgen über die Einstellung seines Wertes - wir werden es in Blunts tun. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3bd/e83/fd4/3bde83fd4df9a960ef4ebde57830b749.jpg"></div><br>  Gehen Sie zurück zu <em>BP_Capture</em> und fügen Sie die markierten Knoten zum <em>Event BeginPlay hinzu</em> .  Setzen Sie <em>Collection</em> auf <em>MPC_Capture</em> und <em>Parametername</em> auf <em>CaptureSize</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eed/843/d3d/eed843d3d5ddc063f9e1c7664b514286.jpg"></div><br>  Jetzt kann jedes Material den Wert von <em>Ortho Width erhalten,</em> indem es ihn aus dem <em>CaptureSize-</em> Parameter liest.  Bisher sind wir mit der Erfassung der Szene fertig.  Klicken Sie auf <em>Kompilieren</em> und kehren Sie zum <em>Haupteditor</em> zurück.  Der nächste Schritt besteht darin, den Zielputz auf den Boden zu projizieren und damit die Landschaft zu verformen. <br><br><h2>  Landschaftsverformung </h2><br>  Öffnen Sie <em>M_Landscape</em> und gehen Sie zum <em>Detailfenster</em> .  Stellen Sie dann die folgenden Eigenschaften ein: <br><br><ul><li>  <em>Wählen Sie</em> für <em>zweiseitig die</em> Option <em>Aktiviert aus</em> .  Da die Erfassung der Szene von unten „aussieht“, werden nur die Rückseiten der Erde angezeigt.  Standardmäßig rendert die Engine die Rückseiten von Netzen nicht.  Dies bedeutet, dass die Tiefe der Erde nicht im Tiefenpuffer gespeichert wird.  Um dies zu beheben, müssen wir die Engine anweisen, beide Seiten des Netzes zu rendern. </li><li>  <em>Wählen Sie</em> für <em>D3D11-Tessellation</em> <em>Flache Tessellation aus</em> (PN-Dreiecke können ebenfalls verwendet werden).  Durch Tessellation werden die Maschendreiecke in kleinere Dreiecke zerlegt.  Dies erhöht im Wesentlichen die Auflösung des Netzes und ermöglicht es uns, beim Verschieben der Eckpunkte feinere Details zu erhalten.  Ohne dies ist die Dichte der Peaks zu gering, um glaubwürdige Spuren zu erzeugen. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc2/99b/a26/dc299ba26cb64d251af3844faf0f5079.jpg"></div><br>  Sobald Tessellationen aktiviert sind, werden <em>World Displacement</em> und <em>Tessellation Multiplier aktiviert</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e8d/675/c53/e8d675c535ce64980597cf10a16ffafe.jpg"></div><br>  <em>Der Tessellationsmultiplikator</em> steuert den Grad der Tessellation.  In diesem Tutorial wird dieser Knoten nicht verbunden, dh wir verwenden den Standardwert ( <em>1</em> ). <br><br>  <em>Die Weltverschiebung</em> erhält einen Vektorwert, der beschreibt, in welche Richtung und um wie viel der Scheitelpunkt bewegt werden soll.  Um den Wert für diesen Kontakt zu berechnen, müssen wir zuerst den Zielrender auf den Boden projizieren. <br><br><h3>  Projektziel rendern </h3><br>  Um das Ziel-Rendering zu projizieren, müssen Sie seine UV-Koordinaten berechnen.  Erstellen Sie dazu das folgende Schema: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cbb/88f/b59/cbb88fb598e75fc8c9bd9991806d5892.jpg"></div><br>  Was ist hier los: <br><br><ol><li>  Zuerst müssen wir die XY-Position des aktuellen Scheitelpunkts ermitteln.  Da wir von unten erfassen, wird die X-Koordinate umgedreht, sodass Sie sie zurückdrehen müssen (wenn wir von oben erfassen würden, würden wir dies nicht benötigen). </li><li>  Dieser Teil führt zwei Aufgaben aus.  Erstens zentriert es das Ziel-Rendering so, dass seine Mitte in den Koordinaten <em>(0, 0) des</em> Weltraums liegt.  Sie konvertiert dann die Koordinaten vom Weltraum in den UV-Raum. </li></ol><br>  Erstellen Sie als Nächstes die ausgewählten Knoten und kombinieren Sie die vorherigen Berechnungen wie unten gezeigt.  <em>Wählen</em> Sie als <em>Texturbeispiel RT_Capture aus</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e95/38d/398/e9538d398f9ba02da2aea238c45651dd.jpg"></div><br>  Dadurch wird der Zielrender auf den Boden projiziert.  Alle Scheitelpunkte außerhalb des Erfassungsbereichs werden jedoch die Kanten des Ziel-Renderings abtasten.  Dies ist tatsächlich ein Problem, da das Ziel-Rendering nur für Scheitelpunkte innerhalb des Erfassungsbereichs verwendet werden sollte.  So sieht es in einem Spiel aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a4/e28/a04/1a4e28a04c7b6356bff76d8e1c4f4ce9.gif"></div><br>  Um dies zu beheben, müssen alle UVs maskiert werden, die außerhalb des Bereichs von 0 bis 1 liegen (d. H. Der Erfassungsbereich).  Dafür habe ich die Funktion <em>MF_MaskUV0-1 angelegt</em> .  Es gibt <em>0 zurück,</em> wenn die durchgelassene UV-Strahlung außerhalb des Bereichs von 0 bis 1 liegt, und <em>1,</em> wenn sie innerhalb des Bereichs liegt.  Multiplizieren Sie das Ergebnis mit dem Ziel-Rendering und führen Sie eine Maskierung durch. <br><br>  Nachdem wir das Ziel-Rendering projiziert haben, können wir damit Farben mischen und Scheitelpunkte verschieben. <br><br><h3>  Verwenden von Target Render </h3><br>  Beginnen wir mit dem Mischen von Farben.  Dazu verbinden wir einfach <em>1-x</em> mit <em>Lerp</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc2/4e2/6fa/bc24e26fab908757ce5a0dded5d9ce21.jpg"></div><br><blockquote>  <em>Hinweis:</em> Wenn Sie nicht verstehen, warum ich <em>1-x verwende</em> , erkläre ich dies. Dies ist erforderlich, um das Ziel-Rendering zu invertieren, damit die Berechnungen etwas einfacher werden. </blockquote><br>  Jetzt, wo wir eine Spur haben, wird die Farbe der Erde braun.  Wenn keine Farbe vorhanden ist, bleibt sie weiß. <br><br>  Der nächste Schritt ist die Verschiebung der Eckpunkte.  Fügen Sie dazu die ausgewählten Knoten hinzu und verbinden Sie alles wie folgt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d7/6b2/6bd/4d76b26bddbf7640fae8032449bea285.jpg"></div><br>  Dadurch bewegen sich alle Schneegebiete um <em>25</em> Einheiten nach oben.  Gebiete ohne Schnee haben einen Nullpunktversatz, wodurch eine Spur entsteht. <br><br><blockquote>  <em>Hinweis: Sie</em> können <em>DisplacementHeight</em> ändern, um die Schneehöhe zu erhöhen oder zu verringern.  Beachten Sie auch, dass DisplacementHeight dem Wert des Erfassungsversatzes entspricht.  Wenn sie die gleiche Bedeutung haben, erhalten wir die genaue Verformung.  Es gibt jedoch Fälle, in denen Sie sie einzeln ändern müssen, sodass ich sie als separate Parameter belassen habe. </blockquote><br>  Klicken Sie auf <em>Übernehmen</em> und kehren Sie zum <em>Haupteditor</em> zurück.  Erstellen Sie eine <em>BP_Capture-</em> Instanz auf der Ebene und geben Sie ihr die Koordinaten <em>(0, 0, -2000)</em> , um sie unter der Erde zu platzieren.  Klicken Sie auf <em>Spielen</em> und wandern Sie mit den Tasten <em>W</em> , <em>A</em> , <em>S</em> und <em>D</em> umher, um den Schnee zu verziehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f6d/a1e/47b/f6da1e47b364e53b0245e53919f4a654.gif"></div><br>  Verformung funktioniert, aber es gibt keine Spuren mehr!  Dies geschah, weil die Erfassung das Ziel-Rendering jedes Mal überschreibt, wenn die Erfassung durchgeführt wird.  Wir brauchen einen Weg, um die Tracks <em>dauerhaft</em> zu machen. <br><br><h2>  Permanente Spuren erstellen </h2><br>  Um Persistenz zu erzeugen, benötigen wir ein weiteres Ziel-Rendering ( <em>konstanter Puffer</em> ), in dem alle Erfassungsinhalte vor dem Überschreiben gespeichert werden.  Dann fügen wir dem Capture einen konstanten Puffer hinzu (nachdem wir ihn überschrieben haben).  Wir erhalten eine Schleife, in der jedes Ziel-Rendering in ein anderes schreibt.  Auf diese Weise schaffen wir die Beständigkeit der Spuren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04e/3bd/a26/04e3bda26fe04e7832163e2e08abdd64.gif"></div><br>  Zuerst müssen wir einen konstanten Puffer erstellen. <br><br><h3>  Erstellen eines dauerhaften Puffers </h3><br>  <em>Wechseln Sie zum</em> Ordner <em>RenderTargets</em> und erstellen Sie ein neues <em>Renderziel mit dem</em> Namen <em>RT_Persistent</em> .  In diesem Tutorial müssen wir die Texturparameter nicht ändern, aber in Ihrem eigenen Projekt müssen Sie sicherstellen, dass beide Zielrender dieselbe Auflösung haben. <br><br>  Als nächstes benötigen wir Material, das die Erfassung in einen permanenten Puffer kopiert.  Öffnen Sie <em>Materials \ M_DrawToPersistent</em> und fügen Sie einen <em>Texture Sample-</em> Knoten hinzu.  Wählen Sie die <em>RT_Capture-</em> Textur aus und verbinden Sie sie wie folgt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/29e/b31/328/29eb3132825b6b7ee68ddd5c45a73454.jpg"></div><br>  Jetzt müssen wir das Zeichenmaterial verwenden.  Klicken <em>Sie</em> auf <em>Übernehmen</em> und öffnen Sie <em>BP_Capture</em> .  Erstellen Sie zunächst eine dynamische Instanz des Materials (später müssen wir Werte an das Material übergeben).  Fügen Sie die markierten Knoten zum <em>Event BeginPlay hinzu</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca2/1d0/6a1/ca21d06a1bfa563eee0df19b4da6e129.jpg"></div><br>  <em>Render</em> löschen <em>Ziel-2D-</em> Knoten löschen jedes Ziel-Rendering vor der Verwendung. <br><br>  Öffnen Sie dann die <em>DrawToPersistent-</em> Funktion und fügen Sie die markierten Knoten hinzu: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c21/88c/051/c2188c0511541f5fcaee1773318653ac.jpg"></div><br>  Als nächstes müssen wir sicherstellen, dass das Zeichnen in den konstanten Puffer in jedem Frame ausgeführt wird, da die Erfassung in jedem Frame erfolgt.  <em>Fügen Sie</em> dazu <em>DrawToPersistent</em> zum <em>Ereignistick hinzu</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a88/47a/e9d/a8847ae9d4bafffbaacf448af86f538d.jpg"></div><br>  Schließlich müssen wir dem Rendering der Zielerfassung einen dauerhaften Puffer hinzufügen. <br><br><h3>  Zum Aufnehmen wieder aufnehmen </h3><br>  Klicken Sie auf <em>Kompilieren</em> und öffnen Sie <em>PP_DepthCheck</em> .  Fügen Sie dann die markierten Knoten hinzu.  Setzen Sie für <em>Texture Sample</em> den Wert auf <em>RT_Persistent</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/afb/ff2/a99/afbff2a99105d523fd44acf437787e06.jpg"></div><br>  Jetzt, da das Ziel sich gegenseitig schreibt, erhalten wir verbleibende Spuren.  Klicken Sie auf <em>Übernehmen</em> und schließen Sie das Material.  Klicken Sie auf <em>Wiedergabe</em> und hinterlassen Sie Titel! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d79/b8a/fd8/d79b8afd898378111e1fc6b62464bf2a.gif"></div><br>  Das Ergebnis sieht gut aus, aber die resultierende Schaltung funktioniert nur für einen Bereich der Karte.  Wenn Sie über den Erfassungsbereich hinausgehen, werden keine Spuren mehr angezeigt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/764/641/1a7/7646411a7886c8c1004a34b2d6f3bda9.gif"></div><br>  Sie können dieses Problem lösen, indem Sie den Erfassungsbereich mit dem Player verschieben.  Dies bedeutet, dass immer Spuren in dem Bereich angezeigt werden, in dem sich der Spieler befindet. <br><br>  <em>Hinweis:</em> Während sich die Erfassung bewegt, werden alle Informationen außerhalb des Erfassungsbereichs entfernt.  Dies bedeutet, dass wenn Sie zu dem Bereich zurückkehren, in dem bereits Spuren vorhanden waren, diese bereits verschwinden.  Im nächsten Tutorial werde ich Ihnen zeigen, wie Sie teilweise beibehaltene Tracks erstellen. <br><br><h2>  Bewegung erfassen </h2><br>  Sie können entscheiden, dass es einfach genug ist, die XY-Erfassungsposition an die XY-Position des Spielers zu binden.  Wenn Sie dies jedoch tun, wird das Ziel-Rendering unscharf.  Dies liegt daran, dass wir das Ziel-Rendering mit einem Schritt verschieben, der kleiner als ein Pixel ist.  In diesem Fall liegt die neue Pixelposition <i>zwischen den</i> Pixeln.  Infolgedessen wird ein Pixel durch mehrere Pixel interpoliert.  So sieht es aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d6f/e29/d8e/d6fe29d8ea33db2479e5e897e6d90344.gif"></div><br>  Um dieses Problem zu beheben, müssen wir die Erfassung in diskreten Schritten verschieben.  Wir berechnen <em>die Pixelgröße in der Welt</em> und verschieben dann die Aufnahme in Schritte, die dieser Größe entsprechen.  Dann wird niemals jedes Pixel zwischen den anderen liegen, so dass die Unschärfe nicht erscheint. <br><br>  Erstellen Sie zunächst einen Parameter, in dem der Erfassungsort gespeichert wird.  Erdmaterial benötigt es, um Projektionsberechnungen durchzuführen.  Öffnen Sie <em>MPC_Capture</em> und fügen Sie einen <em>Vektorparameter</em> namens <em>CaptureLocation hinzu</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e4/0c7/4c3/1e40c74c3c19e6e8a2520d10874b9c13.jpg"></div><br>  Als nächstes müssen Sie das Erdmaterial aktualisieren, um den neuen Parameter zu verwenden.  Schließen Sie <em>MPC_Capture</em> und öffnen Sie <em>M_Landscape</em> .  Ändern Sie den ersten Teil der Projektionsberechnungen wie folgt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d22/8e4/411/d228e4411ac885ec3a29878f7b5d930f.jpg"></div><br>  Jetzt wird das Ziel-Rendering immer auf den Erfassungsort projiziert.  Klicken Sie auf <em>Übernehmen</em> und schließen Sie das Material. <br><br>  Als nächstes werden wir die Erfassung mit einem diskreten Schritt ausführen. <br><br><h3>  Diskrete Schritterfassungsbewegung </h3><br>  Um die Pixelgröße in der Welt zu berechnen, können Sie die folgende Gleichung verwenden: <br><br><pre><code class="cpp hljs">(<span class="hljs-number"><span class="hljs-number">1</span></span> / RenderTargetResolution) * CaptureSize</code> </pre> <br>  Um die neue Position zu berechnen, verwenden wir die unten gezeigte Gleichung für jede Komponente der Position (in unserem Fall für die X- und Y-Koordinaten). <br><br><pre> <code class="cpp hljs">(<span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(Position / PixelWorldSize) + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * PixelWorldSize</code> </pre> <br>  Verwenden Sie sie jetzt für die Blaupausenerfassung.  Um Zeit zu sparen, habe ich das <em>SnapToPixelWorldSize-</em> Makro für die zweite Gleichung erstellt.  Öffnen Sie <em>BP_Capture</em> und öffnen <em>Sie</em> dann die <em>MoveCapture-</em> Funktion.  Erstellen Sie als Nächstes das folgende Diagramm: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c10/e17/55d/c10e1755df187bb3578d1b496402101f.jpg"></div><br>  Es berechnet den neuen Standort und speichert dann die Differenz zwischen dem neuen und dem aktuellen Standort in <em>MoveOffset</em> .  Wenn Sie eine andere Auflösung als 256 × 256 verwenden, ändern Sie den hervorgehobenen Wert. <br><br>  Fügen Sie als Nächstes die ausgewählten Knoten hinzu: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e9/963/879/1e9963879bfe2465f49a71665317db20.jpg"></div><br>  Diese Schaltung verschiebt die Erfassung mit dem berechneten Versatz.  Sie speichert dann den neuen Erfassungsort in <em>MPC_Capture,</em> damit er von <em>Bodenmaterial</em> verwendet werden kann. <br><br>  Schließlich müssen wir in jedem Frame eine Positionsaktualisierung durchführen.  Schließen Sie die Funktion und fügen Sie sie dem <em>Ereignistick</em> vor <em>DrawToPersistent</em> <em>MoveCapture hinzu</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f15/3c6/d54/f153c6d5438ba54a85f2b3749b179bb9.jpg"></div><br>  Das Verschieben eines Captures ist nur die halbe Lösung.  Wir müssen auch den konstanten Puffer verschieben.  Andernfalls sind die Erfassung und der dauerhafte Puffer nicht synchron und führen zu seltsamen Ergebnissen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1f/4fa/008/e1f4fa0086dc9f41412b70856f246149.gif"></div><br><h3>  Permanente Pufferbewegung </h3><br>  Um einen konstanten Puffer zu verschieben, müssen wir den berechneten Verschiebungsversatz übergeben.  Öffnen Sie <em>M_DrawToPersistent</em> und fügen Sie die markierten Knoten hinzu: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e65/d15/16b/e65d1516bc33002a2e2a3bc7e9c96b00.jpg"></div><br>  Aufgrund dessen wird der konstante Puffer um den Wert des übertragenen Offsets verschoben.  Wie im Material der Erde müssen wir die X-Koordinate umdrehen und eine Maskierung durchführen.  Klicken Sie auf <em>Übernehmen</em> und schließen Sie das Material. <br><br>  Dann müssen Sie den Offset übertragen.  Öffnen Sie <em>BP_Capture</em> und öffnen <em>Sie</em> dann die Funktion <em>DrawToPersistent</em> .  Fügen Sie als Nächstes die markierten Knoten hinzu: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/666/621/f22/666621f22bde013dd710991d5adfa7e4.jpg"></div><br>  Auf diese Weise konvertieren wir <em>MoveOffset</em> in den UV-Raum und übergeben es dann an das Zeichenmaterial. <br><br>  Klicken Sie auf <em>Kompilieren</em> und schließen Sie die Blaupause.  Klicken Sie auf <em>Spielen</em> und laufen Sie nach Herzenslust!  Egal wie weit Sie laufen, Spuren bleiben immer um Sie herum. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a94/097/5cb/a940975cb157444251cdb31bf195c8f2.gif"></div><br><h2>  Wohin als nächstes? </h2><br>  Das fertige Projekt kann hier heruntergeladen werden. <br><br>  Es ist nicht erforderlich, die in diesem Tutorial erstellten Tracks nur für Schnee zu verwenden.  Sie können sie sogar für Dinge wie zerkleinertes Gras verwenden (im nächsten Tutorial werde ich zeigen, wie Sie eine erweiterte Version des Systems erstellen). <br><br>  Wenn Sie mit Landschaften und Ziel-Renderings arbeiten möchten, empfehlen wir Ihnen, das Video von Chris Murphy zu sehen, der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">High-End-Gameplay-Effekte mit Blueprint erstellt</a> .  Dieses Tutorial zeigt Ihnen, wie Sie einen riesigen Laser erstellen, der Erde und Gras verbrennt! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416703/">https://habr.com/ru/post/de416703/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416691/index.html">Sicherheit beim maschinellen Lernen: Effektive Verteidigungstechniken oder neue Bedrohungen?</a></li>
<li><a href="../de416693/index.html">D-Link- und Changing Information Technologies-Zertifikate zum Signieren von Malware</a></li>
<li><a href="../de416695/index.html">Unterstützung für vSphere 6.7 und andere Funktionen des neuesten Veeam Backup & Replication 9.5-Updates 3a</a></li>
<li><a href="../de416697/index.html">Zusammenschluss der Telekommunikationsbetreiber im Jahr 2018</a></li>
<li><a href="../de416699/index.html">Geek Sniper oder wie man ein "scharfes Auge" macht</a></li>
<li><a href="../de416707/index.html">Remotedesktop-Verwaltungssoftware - Aspia</a></li>
<li><a href="../de416709/index.html">IoT und natürlicher Fortschritt: die umstrittensten Technologien und Geräte</a></li>
<li><a href="../de416711/index.html">Seiten der Intel-Geschichte. Fabrikfeuer in Penang</a></li>
<li><a href="../de416713/index.html">Bericht des Club of Rome 2018, Kapitel 3.14: „Kein einziges BIP ...“</a></li>
<li><a href="../de416719/index.html">Erweiterung PHP und Kotlin Native. Teil Zwei, bewusst</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>