<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤱🏼 👨🏿‍🎨 Ⓜ️ Kode itu hidup dan mati. Bagian Satu Benda-benda ™️ ☄️ 🧒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kode adalah pemikiran. Sebuah tugas muncul, dan pengembang berpikir bagaimana menyelesaikannya, bagaimana mengekspresikan persyaratan dalam fungsi dan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kode itu hidup dan mati. Bagian Satu Benda-benda</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447404/"><p>  Kode adalah pemikiran.  Sebuah tugas muncul, dan pengembang berpikir bagaimana menyelesaikannya, bagaimana mengekspresikan persyaratan dalam fungsi dan kelas, bagaimana menjadikan mereka teman, bagaimana mencapai ketelitian dan kebenaran, dan bagaimana membuat bisnis dengan benar.  Praktik, teknik, prinsip, pola dan pendekatan - semuanya perlu diperhitungkan dan semuanya perlu diingat. </p><br><p>  Dan seiring dengan ini, kita melihat epidemi yang meluas dari manajer, pembantu, layanan, pengontrol, penyeleksi, adapter, getter, setter dan roh jahat lainnya: semua ini adalah kode mati.  Dia belenggu dan berantakan. </p><br><p>  Saya mengusulkan pertempuran dengan cara ini: Anda perlu menyajikan program sebagai teks dalam bahasa alami dan mengevaluasinya.  Bagaimana ini dan apa yang terjadi - dalam artikel. </p><a name="habracut"></a><br><h2 id="oglavlenie-cikla">  Siklus daftar isi </h2><br><ol><li>  Benda-benda </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tindakan dan properti</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode sebagai teks</a> </li></ol><br><h2 id="prolog">  Prolog </h2><br><p> Pengalaman saya sederhana (sekitar empat tahun), tetapi semakin saya bekerja, semakin saya mengerti: jika program tidak dapat dibaca, tidak ada artinya di dalamnya.  Sudah lama dikenal dan dipukuli untuk mengingatkan - kode tidak hanya memecahkan beberapa masalah <em>sekarang</em> , tetapi juga <em>nanti</em> : didukung, diperluas, diperbaiki.  Selain itu, ia selalu: membaca. </p><br><p>  Bagaimanapun, ini adalah teks. </p><br><p>  Estetika kode sebagai teks adalah tema utama dalam siklus.  Estetika di sini adalah gelas yang melaluinya kita melihat sesuatu dan berkata, ya, itu bagus, ya, itu indah. </p><br><p>  Dalam hal kecantikan dan kelengkapan, kata-kata sangat penting.  Untuk mengatakan: <em>"Saat ini, persepsi saya dalam keadaan kusam karena tingginya kadar etanol dalam darah"</em> sama sekali tidak sama dengan: <em>"Saya mabuk</em> . <em>"</em> </p><br><p>  Kami adalah program yang beruntung hampir seluruhnya terdiri dari kata-kata. </p><br><p>  Katakanlah Anda perlu membuat <em>"karakter yang memiliki kesehatan dan mana, dia berjalan, menyerang, menggunakan mantra,"</em> dan Anda dapat langsung melihat: ada <strong>objek</strong> (karakter, kesehatan, mana, mantra), <strong>tindakan</strong> (berjalan, serang, gunakan) dan <strong>properti</strong> ( karakter memiliki health, mana, speed of casting spell) - semua ini akan menjadi nama: kelas, fungsi, metode, variabel, properti dan bidang, dalam satu kata, semua yang dipecah menjadi bahasa pemrograman. </p><br><p> Tapi saya tidak akan membedakan kelas dari struktur, bidang dari properti, dan metode dari fungsi: karakter sebagai bagian dari narasi tidak tergantung pada detail teknis (bahwa itu dapat direpresentasikan baik sebagai referensi atau tipe signifikan).  Suatu hal yang pada dasarnya berbeda: bahwa ini adalah karakter dan bahwa mereka memanggilnya <code>Hero</code> (atau <code>Character</code> ), dan bukan <code>HeroData</code> atau <code>HeroUtils</code> . </p><br><p>  Sekarang saya akan mengambil segelas estetika dan menunjukkan bagaimana beberapa kode ditulis hari ini dan mengapa itu jauh dari sempurna. </p><br><h2 id="obekty">  Benda-benda </h2><br><p>  Dalam C # (dan tidak hanya), objek - contoh kelas yang ditempatkan di heap, tinggal di sana untuk sementara waktu, dan kemudian pengumpul sampah menghapusnya.  Dapat juga dibuat struktur pada stack atau array asosiatif, atau yang lainnya.  Bagi kami mereka adalah: nama kelas, kata benda. </p><br><p>  Nama dalam kode, seperti nama pada umumnya, dapat membingungkan.  Ya, dan Anda jarang melihat nama yang jelek, tetapi benda yang indah.  Apalagi jika itu adalah <code>Manager</code> . </p><br><h3 id="menedzher-vmesto-obekta">  Manajer, bukan objek </h3><br><p>  <code>UserService</code> , <code>AccountManager</code> , <code>DamageUtils</code> , <code>MathHelper</code> , <code>GraphicsManager</code> , <code>GameManager</code> , <code>VectorUtil</code> . </p><br><p>  Bukan akurasi dan tangibilitas yang mendominasi di sini, tetapi sesuatu yang kabur, meninggalkan suatu tempat dalam kabut.  Untuk nama-nama seperti itu, banyak yang diizinkan. </p><br><p>  Misalnya, di <code>GameManager</code> apa pun Anda dapat menambahkan apa pun yang terkait dengan <em>game</em> dan logika <em>game</em> .  Enam bulan kemudian, akan muncul singularitas teknologi. </p><br><p>  Atau, itu terjadi, Anda harus bekerja dengan facebook.  Mengapa tidak meletakkan semua kode di satu tempat: <code>FacebookManager</code> atau <code>FacebookService</code> ?  Kedengarannya sangat sederhana, tetapi <em>niat yang</em> tidak jelas menciptakan <em>keputusan yang</em> sama tidak <em>jelasnya</em> .  Pada saat yang sama, kita tahu bahwa ada pengguna, teman, pesan, grup, musik, minat, dll. Di Facebook.  Kata-kata yang cukup! </p><br><p>  Tidak hanya ada kata-kata yang cukup: kita masih menggunakannya.  Hanya dalam pidato biasa, bukan di antara program. </p><br><p>  Dan itu bukan <code>GitUtils</code> , tetapi <code>IRepository</code> , <code>ICommit</code> , <code>IBranch</code> ;  bukan <code>ExcelHelper</code> , tetapi <code>ExcelDocument</code> , <code>ExcelSheet</code> ;  bukan <code>GoogleDocsService</code> , tetapi <code>GoogleDocs</code> . </p><br><p>  Setiap area subjek diisi dengan objek.  <em>"Benda-benda itu ditandai oleh kekosongan besar"</em> , <em>"Jantung berdetak kencang"</em> , <em>"Rumah itu berdiri"</em> - benda-benda bertindak, mereka merasa, mereka mudah untuk membayangkan;  mereka ada di suatu tempat di sini, berwujud dan padat. </p><br><p>  Pada saat yang sama, Anda kadang-kadang melihat ini: di repositori <code>Microsoft/calculator</code> - <code>CalculatorManager</code> dengan metode: <code>SetPrimaryDisplay</code> , <code>MaxDigitsReached</code> , <code>SetParentDisplayText</code> , <code>OnHistoryItemAdded</code> ... </p><br><p>  <em>(Tetap saja, saya ingat pernah melihat</em> <code>UtilsManager</code> <em>...)</em> </p><br><p>  Itu terjadi seperti ini: Saya ingin memperluas tipe <code>List&lt;&gt;</code> dengan perilaku baru, dan <code>ListUtils</code> atau <code>ListHelper</code> dilahirkan.  Dalam hal ini, lebih baik dan lebih akurat untuk <em>hanya</em> menggunakan metode ekstensi - <code>ListExtensions</code> : mereka adalah bagian dari konsep, dan bukan dump dari prosedur. </p><br><p>  Salah satu dari beberapa pengecualian adalah <code>OfficeManager</code> sebagai pos. </p><br><p>  Selebihnya ... Program tidak boleh dikompilasi jika mengandung kata-kata seperti itu. </p><br><h3 id="deystvie-vmesto-obekta">  Aksi bukannya objek </h3><br><p>  <code>IProcessor</code> , <code>ILoader</code> , <code>ISelector</code> , <code>IFilter</code> , <code>IProvider</code> , <code>ISetter</code> , <code>ICreator</code> , <code>IOpener</code> , <code>IHandler</code> ;  <code>IEnableable</code> , <code>IInitializable</code> , <code>IUpdatable</code> , <code>ICloneable</code> , <code>IDrawable</code> , <code>ILoadable</code> , <code>IOpenable</code> , <code>ISettable</code> , <code>IConvertible</code> . </p><br><p>  Di sini, esensi esensi adalah prosedur, bukan konsep, dan kode lagi kehilangan citra dan keterbacaannya, dan kata yang biasa digantikan oleh yang buatan. </p><br><p>  Lebih hidup adalah <code>ISequence</code> , bukan <code>IEnumerable</code> ;  <code>IBlueprint</code> , bukan <code>ICreator</code> ;  <code>IButton</code> , bukan <code>IButtonPainter</code> ;  <code>IPredicate</code> , bukan <code>IFilter</code> ;  <code>IOpeneable</code> , bukan <code>IOpeneable</code> ;  <code>IToggle</code> , bukan <code>IEnableable</code> . </p><br><p>  Sebuah cerita yang bagus menceritakan tentang karakter dan perkembangannya, dan bukan tentang bagaimana pencipta menciptakan, pembangun membangun dan menggambar pelukis.  Suatu tindakan tidak dapat sepenuhnya mewakili suatu objek.  <code>ListSorter</code> bukan <code>SortedList</code> . </p><br><p>  Ambil <code>DirectoryCleaner</code> , misalnya, objek yang membersihkan folder pada sistem file.  Apakah itu elegan?  Tetapi kami tidak pernah mengatakan: <em>"Minta pembersih folder untuk membersihkan D: / Test"</em> , selalu: <em>"Clean D: / Test"</em> , sehingga <code>Directory</code> dengan metode <code>Clean</code> terlihat lebih alami dan lebih dekat. </p><br><p>  Kasus yang lebih hidup lebih menarik: <code>FileSystemWatcher</code> dari .NET adalah perubahan pelaporan pengamat sistem file.  Tetapi mengapa seluruh pengamat, jika perubahan itu <em>sendiri</em> dapat melaporkan bahwa mereka terjadi?  Selain itu, mereka harus terkait erat dengan file atau folder, sehingga mereka juga harus ditempatkan di <code>Directory</code> atau <code>File</code> (menggunakan properti <code>Changes</code> dengan kemampuan untuk memanggil <code>file.Changes.OnNext(action)</code> ). </p><br><p>  Nama-nama verbal seperti itu tampaknya membenarkan pola desain <code>Strategy</code> , menginstruksikan untuk <em>"merangkum keluarga algoritma"</em> .  Tetapi jika alih-alih <em>"keluarga algoritma" kita</em> menemukan objek otentik yang ada dalam cerita, kita akan melihat bahwa strategi itu hanyalah generalisasi. </p><br><p>  Untuk menjelaskan ini dan banyak kesalahan lainnya, kita beralih ke filosofi. </p><br><h3 id="suschestvovanie-predshestvuet-suschnosti">  Keberadaan mendahului esensi </h3><br><p>  <code>MethodInfo</code> , <code>ItemData</code> , <code>AttackOutput</code> , <code>CreationStrategy</code> , <code>StringBuilder</code> , <code>SomethingWrapper</code> , <code>LogBehaviour</code> . </p><br><p>  Nama-nama seperti itu disatukan oleh satu hal: keberadaan mereka didasarkan pada keterangan. </p><br><p>  Itu terjadi bahwa sesuatu mengganggu dengan cepat tugas: ada sesuatu yang hilang atau ada, tetapi bukan sesuatu.  Kemudian Anda berpikir: <em>"Suatu hal yang dapat melakukan X sekarang akan membantu saya"</em> - ini adalah bagaimana <em>keberadaan</em> dipahami.  Kemudian, untuk "melakukan" X, <code>XImpl</code> ditulis - ini adalah bagaimana <em>entitas</em> muncul. </p><br><p>  Oleh karena itu, alih-alih <code>IArrayItem</code> , <code>IIndexedItem</code> atau <code>IItemWithIndex</code> lebih umum, atau, katakanlah, di API Refleksi, daripada <em>metode</em> ( <code>Method</code> ), kita hanya melihat <em>informasi</em> tentang itu ( <code>MethodInfo</code> ). </p><br><p>  Cara yang lebih benar: dihadapkan dengan kebutuhan akan keberadaan, <em>temukan</em> entitas yang mengimplementasikannya, dan, karena inilah sifatnya, yang lain. </p><br><p>  Sebagai contoh, mereka ingin mengubah nilai tipe <code>string</code> tanpa membuat instance menengah - itu ternyata menjadi solusi langsung dalam bentuk <code>StringBuilder</code> , sedangkan, menurut saya, itu lebih tepat - <code>MutableString</code> . </p><br><p>  Ingat sistem file: <code>DirectoryRenamer</code> tidak diperlukan untuk mengganti nama folder, karena begitu Anda menyetujui keberadaan objek <code>Directory</code> , tindakan <em>sudah ada</em> di dalamnya, Anda hanya belum <em>menemukan</em> metode yang sesuai dalam kode. </p><br><p>  Jika Anda ingin menjelaskan cara mengambil <em>kunci</em> , maka tidak perlu mengklarifikasi bahwa ini adalah <code>ILockBehaviour</code> atau <code>ILockStrategy</code> , yang jauh lebih mudah - <code>ILock</code> (dengan metode <code>Acquire</code> yang mengembalikan <code>IDisposable</code> ) atau <code>ICriticalSection</code> (dengan <code>Enter</code> ). </p><br><p>  Ini juga mencakup semua jenis <code>Data</code> , <code>Info</code> , <code>Output</code> , <code>Input</code> , <code>Args</code> , <code>Params</code> (lebih jarang <code>State</code> ) - objek yang sama sekali tidak memiliki perilaku, karena mereka dianggap sepihak. </p><br><p>  Di mana keberadaannya adalah primer, hasil bagi dicampur dengan jenderal, dan nama-nama objek membingungkan - Anda harus membaca setiap baris dan mencari tahu ke mana karakter pergi dan mengapa hanya ada <code>Data</code> . </p><br><h3 id="prichudlivaya-taksonomiya">  Taksonomi Aneh </h3><br><p>  <code>CalculatorImpl</code> , <code>AbstractHero</code> , <code>ConcreteThing</code> , <code>CharacterBase</code> . </p><br><p>  Semua untuk alasan yang sama dijelaskan di atas, kita kadang-kadang melihat objek yang tempat dalam hierarki ditunjukkan dengan tepat.  Sekali lagi, keberadaan bergegas ke depan, sekali lagi kita melihat bagaimana kebutuhan mendesak dengan cepat tumpah ke dalam kode, tanpa mempertimbangkan konsekuensinya. </p><br><p>  Lagipula, apakah benar ada seseorang ( <code>Human</code> ) - pewaris dari orang dasar ( <code>HumanBase</code> )?  Tapi bagaimana ketika <code>Item</code> mewarisi <code>AbstractItem</code> ? </p><br><p>  Terkadang mereka ingin menunjukkan bahwa tidak ada <code>Character</code> , tetapi semacam kesamaan "mentah" - <code>CharacterRaw</code> . </p><br><p>  <code>Impl</code> , <code>Abstract</code> , <code>Custom</code> , <code>Base</code> , <code>Concrete</code> , <code>Internal</code> , <code>Raw</code> - tanda ketidakstabilan, ketidakjelasan arsitektur, yang, seperti pistol dari adegan pertama, pasti akan menembak nanti. </p><br><h3 id="povtoreniya">  Pengulangan </h3><br><p>  Dengan tipe bersarang, ini terjadi: <code>RepositoryItem</code> di <code>Repository</code> , <code>WindowState</code> di <code>Window</code> , <code>HeroBuilder</code> in <code>Hero</code> . </p><br><p>  Pengulangan memotong makna, memperburuk kelemahan, dan hanya berkontribusi pada kompleksitas teks. </p><br><h3 id="izbytochnye-detali">  Bagian yang berlebihan </h3><br><p>  Untuk menyinkronkan utas, <code>ManualResetEvent</code> sering digunakan dengan API berikut: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ManualResetEvent</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   —  `EventWaitHandle`. void Set(); void Reset(); bool WaitOne(); }</span></span></code> </pre> <br><p>  Setiap kali, secara pribadi, saya harus ingat bagaimana <code>Set</code> berbeda dari <code>Reset</code> (tata bahasa yang tidak nyaman) dan apa yang dimaksud dengan <em>"acara reset manual" secara</em> umum dalam konteks bekerja dengan stream. </p><br><p>  Dalam kasus seperti itu, lebih mudah untuk menggunakan metafora yang jauh dari pemrograman (tetapi dekat dengan kehidupan sehari-hari): </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ThreadGate</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Close</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WaitForOpen</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; }</code> </pre> <br><p>  Pasti tidak ada yang membingungkan! </p><br><p>  Kadang-kadang muncul ke konyol: tentukan bahwa <em>item</em> bukan hanya <code>Items</code> , tetapi tentu saja <code>ItemsList</code> atau <code>ItemsDictionary</code> ! </p><br><p>  Namun, jika <code>ItemsList</code> tidak lucu, maka <code>AbstractInterceptorDrivenBeanDefinitionDecorator</code> dari <em>Spring</em> <code>ItemsList</code> - <code>ItemsList</code> .  Kata-kata dalam nama ini adalah kain dari mana monster raksasa dijahit.  Meskipun ... Jika ini adalah monster, lalu apa yang terjadi dengan <code>HasThisTypePatternTriedToSneakInSomeGenericOrParameterizedTypePatternMatchingStuffAnywhereVisitor</code> ?  Harapan <em>warisan</em> . </p><br><p>  Selain nama kelas dan antarmuka, orang sering menemukan redundansi dalam variabel atau bidang. </p><br><p>  Misalnya, bidang tipe <code>IOrdersRepository</code> disebut <code>_ordersRepository</code> .  Tetapi seberapa pentingkah melaporkan bahwa pesanan dikirimkan oleh repositori?  Lagi pula, jauh lebih mudah - <code>_orders</code> . </p><br><p>  Itu juga terjadi bahwa dalam kueri LINQ mereka menulis nama argumen penuh ekspresi lambda, misalnya, <code>Player.Items.Where(item =&gt; item.IsWeapon)</code> , meskipun kami sudah memahami item ini dengan melihat <code>Player.Items</code> .  Dalam kasus seperti itu, saya ingin selalu menggunakan karakter yang <em>sama</em> - <code>x</code> : <code>Player.Items.Where(x =&gt; x.IsWeapon)</code> (dengan kelanjutan ke <code>y</code> , <code>z</code> jika ini adalah fungsi di dalam fungsi). </p><br><h2 id="itogo">  Total </h2><br><p>  Saya akui, dengan permulaan seperti itu tidak akan mudah untuk menemukan kebenaran objektif.  Seseorang, misalnya, akan mengatakan: menulis <code>Service</code> atau tidak menulis adalah poin yang diperdebatkan, tidak penting, rasanya enak, dan apa bedanya jika itu berfungsi? </p><br><p>  Tapi Anda bisa minum dari gelas sekali pakai! </p><br><p>  Saya yakin bahwa jalan menuju konten terletak melalui formulir, dan jika seseorang tidak melihat pemikiran itu, tampaknya sudah hilang.  Dalam teks program, semuanya bekerja dengan cara yang sama: gaya, suasana dan ritme membantu untuk mengekspresikan diri mereka tidak bingung, tetapi dimengerti dan luas. </p><br><p>  Nama objek tidak hanya wajahnya, tetapi juga makhluk, diri.  Ini menentukan apakah itu akan halus atau jenuh, abstrak atau nyata, kering atau animasi.  Namanya berubah - konten berubah. </p><br><p>  Pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> selanjutnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kita akan</a> membahas tentang konten ini dan apa yang terjadi. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id447404/">https://habr.com/ru/post/id447404/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id447392/index.html">Tiga masalah layanan untuk memeriksa tata bahasa Inggris, dan apakah itu bisa diselesaikan</a></li>
<li><a href="../id447394/index.html">Wawancara dengan Vladimir Likhachev, ayah Nikolai Likhachev, lebih dikenal sebagai Chris Kaspersky</a></li>
<li><a href="../id447396/index.html">Apakah data perusahaan Anda berharga di era AI?</a></li>
<li><a href="../id447398/index.html">Otomatisasi Proses Robot - Pandangan Baru di Teknologi Lama</a></li>
<li><a href="../id447402/index.html">Splunk Universal Forwarder di docker sebagai logger sistem</a></li>
<li><a href="../id447406/index.html">Cara bekerja dengan ViewPager2</a></li>
<li><a href="../id447408/index.html">Belajar Bahasa Inggris dari Tingkat Dasar hingga Menengah: Sumber Daya dan Motivasi yang Berguna</a></li>
<li><a href="../id447410/index.html">Api unggun provinsi atau kelahiran suatu bangsa</a></li>
<li><a href="../id447412/index.html">Memantau pesan dalam RabbitMQ</a></li>
<li><a href="../id447414/index.html">ML.NET 1.0 RC dirilis. Apa yang baru?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>