<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍔 👩🏾‍✈️ 👨🏿‍🤝‍👨🏽 إغلاق اتصالات ADL 🧙🏼 🧖🏿 🌠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="كيف تكتب اسمك في التاريخ للأبد؟ أول من يطير إلى القمر؟ أول من يلتقي بعقل أجنبي؟ لدينا طريقة أكثر بساطة - يمكنك أن تتناسب مع معيار لغة C ++. 


 يقدم إ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>إغلاق اتصالات ADL</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/447900/" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/zb/i1/7h/zbi17hhfyu9_oqqmwgpzijon0d8.jpeg"></p><br><p style=";text-align:right;direction:rtl">  كيف تكتب اسمك في التاريخ للأبد؟  أول من يطير إلى القمر؟  أول من يلتقي بعقل أجنبي؟  لدينا طريقة أكثر بساطة - يمكنك أن تتناسب مع معيار لغة C ++. </p><br><p style=";text-align:right;direction:rtl">  يقدم إريك نيبلر ، مؤلف كتاب C ++ Ranges ، مثالاً جيدًا.  "تذكر هذا.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">وكتب</a> على تويتر يوم 19 فبراير 2019 وهو اليوم الذي تحدث فيه مصطلح "nibloid" لأول مرة في اجتماع WG21. </p><br><p style=";text-align:right;direction:rtl">  في الواقع ، إذا ذهبت إلى CppReference ، في <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">قسم cpp / algorithm / rangescpp / algorithm / ranges</a> ، ستجد العديد من المراجع هناك (niebloid).  لهذا الغرض ، تم إنشاء قالب ويكي <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">dsc_niebloid</a> منفصل. </p><br><p style=";text-align:right;direction:rtl">  لسوء الحظ ، لم أجد أي مقالة رسمية كاملة حول هذا الموضوع وقررت أن أكتب مقالتي الخاصة.  هذه رحلة صغيرة ولكنها رائعة إلى هاوية رواد الفضاء المعماريين ، حيث يمكننا الغطس في هاوية جنون ADL والتعرف على nibloids. </p><br><p style=";text-align:right;direction:rtl">  هام: أنا لست عامل لحام حقيقيًا ، لكنني javist الذي يصحح الأخطاء في كود C ++ أحيانًا حسب الضرورة.  إذا كنت تأخذ بعض الوقت للمساعدة في العثور على أخطاء في التفكير ، فسيكون ذلك لطيفًا.  "ساعد داشا المسافر في جمع شيء معقول." </p><a name="habracut"></a><br><h2 id="lookup" style=";text-align:right;direction:rtl">  بحث </h2><br><p style=";text-align:right;direction:rtl">  تحتاج أولا إلى اتخاذ قرار بشأن الشروط.  هذه أشياء معروفة ، ولكن "الصريح أفضل من الضمني" ، لذلك سنناقشها بشكل منفصل.  لا أستخدم مصطلحات حقيقية باللغة الروسية ، لكنني أستخدم اللغة الإنجليزية بدلاً من ذلك.  يعد ذلك ضروريًا لأنه حتى كلمة "التقييد" في سياق هذه المقالة يمكن أن ترتبط بثلاثة إصدارات إنجليزية على الأقل ، والفرق بينها مهم للفهم. </p><br><p style=";text-align:right;direction:rtl">  على سبيل المثال ، في C ++ هناك مفهوم <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">البحث عن اسم</a> أو ، بمعنى آخر ، بحث: عندما يظهر <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">اسم</a> في برنامج ما ، يتم تجميعه مع <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">إعلانه</a> أثناء التحويل البرمجي. </p><br><p style=";text-align:right;direction:rtl"> يمكن أن يكون البحث <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مؤهلًا</a> (إذا كان الاسم على يمين عامل إذن النطاق <code>::</code> :) ، وغير <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">ماهر</a> في حالات أخرى.  إذا كان البحث مؤهلاً ، فإننا نتجاوز الأعضاء المطابقين في الفصل أو مساحة الاسم أو التعداد.  يمكن للمرء أن يسمي هذا الإصدار "الكامل" من التسجيل (كما يبدو أنه تم في ترجمة Straustrup) ، ولكن من الأفضل ترك الإملاء الأصلي ، لأن هذا يشير إلى نوع محدد للغاية من الاكتمال. </p><br><h2 id="adl" style=";text-align:right;direction:rtl">  ADL </h2><br><p style=";text-align:right;direction:rtl">  إذا لم يكن البحث مؤهلاً ، فيجب علينا أن نفهم بالضبط مكان البحث عن الاسم.  وهنا يتم تضمين ميزة خاصة تسمى ADL: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">البحث المعتمد على الوسيطة</a> ، وإلا - البحث عن <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Koenig</a> (الشخص الذي صاغ مصطلح "anti-pattern" ، والذي يعتبر رمزيًا قليلاً في ضوء النص التالي).  يصفها نيكولاي جوتيس في كتابه "مكتبة C ++ القياسية: برنامج تعليمي ومرجع" على النحو التالي: "النقطة هي أنك لست بحاجة إلى تأهيل مساحة اسم الوظيفة إذا تم تعريف واحد على الأقل من أنواع الوسيطات في مساحة اسم هذه الوظيفة." </p><br><p style=";text-align:right;direction:rtl">  ما ينبغي أن تبدو؟ </p><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; int main() { //  . //   , operator&lt;&lt;    ,  ADL , //    std    std::operator&lt;&lt;(std::ostream&amp;, const char*) std::cout &lt;&lt; "Test\n"; //    .      -     . operator&lt;&lt;(std::cout, "Test\n"); // same, using function call notation //    : // Error: 'endl' is not declared in this namespace. //      endl(),  ADL  . std::cout &lt;&lt; endl; //  . //    ,       ADL. //     std,   endl      std. endl(std::cout); //    : // Error: 'endl' is not declared in this namespace. //  ,  - (endl) -     . (endl)(std::cout); }</span></span></span></span></code> </pre> <br><h2 id="spuskaemsya-v-ad-s-adl" style=";text-align:right;direction:rtl">  النزول الى الجحيم مع ADL </h2><br><p style=";text-align:right;direction:rtl">  قد يبدو بسيطا.  أم لا؟  أولاً ، اعتمادًا على نوع الوسيطة ، يعمل ADL في <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">تسع طرق مختلفة</a> ، للقتل باستخدام المكنسة. </p><br><p style=";text-align:right;direction:rtl">  ثانيا ، عملي بحت ، تخيل أن لدينا نوع من وظيفة المبادلة.  اتضح أن <code>std::swap(obj1,obj2);</code>  <code>using std::swap; swap(obj1, obj2);</code> <code>using std::swap; swap(obj1, obj2);</code>  يمكن أن تتصرف بشكل مختلف تماما.  إذا تم تمكين ADL ، ثم من عدة مقايضات مختلفة ، يتم تحديد الذي تحتاجه بالفعل بناءً على مساحات أسماء الوسائط!  اعتمادًا على وجهة النظر ، يمكن اعتبار هذا المصطلح مثالًا إيجابيًا وسلبيًا :-) </p><br><p style=";text-align:right;direction:rtl">  إذا بدا لك أن هذا لا يكفي ، يمكنك إسقاط الحطب في فرن القبعة.  وقد <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">كتب</a> هذا مؤخرًا جيدًا <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">بواسطة آرثر أودوير</a> .  آمل ألا يعاقبني على استخدام مثاله. </p><br><p style=";text-align:right;direction:rtl">  تخيل أن لديك برنامج من هذا النوع: </p><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; namespace A { struct A {}; void call(void (*f)()) { f(); } } void f() { puts("Hello world"); } int main() { call(f); }</span></span></span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  بالطبع ، لا يتم تجميعها مع وجود خطأ: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">error: use of undeclared identifier 'call'; did you mean 'A::call'? call(f); ^~~~ A::call</code> </pre> <br><p style=";text-align:right;direction:rtl">  ولكن إذا أضفت <strong>حمولة زائدة غير مستخدمة بالكامل من</strong> الوظيفة <code>f</code> ، فسيعمل كل شيء! </p><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; namespace A { struct A {}; void call(void (*f)()) { f(); } } void f() { puts("Hello world"); } void f(A::A); // UNUSED int main() { call(f); }</span></span></span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  في Visual Studio ، ستظل تتكسر ، لكن هذا هو مصيرها ، لا تعمل. </p><br><p style=";text-align:right;direction:rtl">  كيف حدث هذا؟  دعنا نتطرق <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">إلى المعيار</a> (بدون الترجمة ، لأن مثل هذه الترجمة ستكون عبارة عن mishmash استثنائية من الكلمات الطنانة): </p><br><blockquote style=";text-align:right;direction:rtl">  إذا كانت الوسيطة هي اسم أو عنوان مجموعة من الوظائف الزائدة و / أو قوالب الوظائف ، فإن الكيانات ومساحات الأسماء المرتبطة بها هي اتحاد لتلك المرتبطة بكل من أعضاء المجموعة ، أي الكيانات ومساحات الأسماء المرتبطة بمعلمتها. أنواع ونوع العودة.  [...] بالإضافة إلى ذلك ، إذا تم تسمية المجموعة المذكورة أعلاه من الوظائف التي تم تحميلها بشكل زائد بمعرف قالب ، فإن الكيانات ومساحات الأسماء المرتبطة بها تشمل أيضًا وسيطات قالب النوع الخاصة به ووسائط قالب القالب الخاصة به. </blockquote><p style=";text-align:right;direction:rtl">  الآن تأخذ رمز مثل هذا: </p><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; namespace B { struct B {}; void call(void (*f)()) { f(); } } template&lt;class T&gt; void f() { puts("Hello world"); } int main() { call(f&lt;B::B&gt;); }</span></span></span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  في كلتا الحالتين ، يتم الحصول على الوسائط التي ليس لها نوع.  <code>f</code> و <code>f&lt;B::B&gt;</code> هما اسماء مجموعات الدالات المثقلة (من التعريف أعلاه) ، وليس لهذه المجموعة أي نوع.  لطي التحميل الزائد في وظيفة واحدة ، يجب أن تفهم نوع مؤشر الوظيفة الأنسب لأفضل حمل زائد <code>call</code> .  لذلك ، تحتاج إلى جمع مجموعة من المرشحين <code>call</code> ، مما يعني بدء بحث عن اسم <code>call</code> .  ولهذا ADL سيبدأ! </p><br><p style=";text-align:right;direction:rtl">  لكن عادة بالنسبة ADL يجب أن نعرف أنواع الحجج!  وهنا يقطع Clang و ICC و MSVC عن طريق الخطأ كما يلي (لكن دول مجلس التعاون الخليجي لا تنفجر): </p><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">[build] ..\..\main.cpp(<span class="hljs-number"><span class="hljs-number">15</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>): error: use of undeclared identifier <span class="hljs-string"><span class="hljs-string">'call'</span></span>; did you mean <span class="hljs-string"><span class="hljs-string">'B::call'</span></span>? [build] call(f&lt;B::B&gt;); [build] ^~~~ [build] B::call [build] ..\..\main.cpp(<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>): note: <span class="hljs-string"><span class="hljs-string">'B::call'</span></span> declared here [build] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*f)())</span></span></span><span class="hljs-function"> </span></span>{ [build] ^</code> </pre> <br><p style=";text-align:right;direction:rtl">  حتى المبدعين من المجمعين مع ADL لديهم علاقة متوترة قليلا. </p><br><p style=";text-align:right;direction:rtl">  حسنًا ، هل ما زالت ADL تبدو فكرة جيدة؟  من ناحية ، لم نعد بحاجة إلى كتابة مثل هذا الرمز السلبي بطريقة مهذبة: </p><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>, <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span>), <span class="hljs-string"><span class="hljs-string">"\n"</span></span>);</code> </pre> <br><p style=";text-align:right;direction:rtl">  من ناحية أخرى ، تبادلنا باختصار حقيقة أن هناك الآن نظامًا يعمل بطريقة غير إنسانية تمامًا.  قصة مأساوية ورائعة حول كيف يمكن لسهولة كتابة Halloworld أن تؤثر على اللغة بأكملها على مدى عقود. </p><br><h2 id="renzhi-i-koncepty" style=";text-align:right;direction:rtl">  النطاقات والمفاهيم </h2><br><p style=";text-align:right;direction:rtl">  إذا قمت بفتح وصف <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مكتبة Nibler Rangers</a> ، فحتى قبل ذكر nibloids ، ستتعثر على العديد من العلامات الأخرى المسماة <strong>(concept)</strong> .  هذه بالفعل أشياء جميلة ، ولكن فقط في حالة (لكبار السن و javists) سأذكرك <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">بما هي عليه</a> . </p><br><p style=";text-align:right;direction:rtl">  تسمى المفاهيم مجموعات القيود المسموح بها والتي تنطبق على وسيطات القوالب لتحديد أفضل وظائف التحميل الزائد وتخصصات القوالب الأنسب. </p><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; concept <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasStringFunc = requires(T a) { { to_string(a) } -&gt; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HasStringFunc a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; to_string(a) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br><p style=";text-align:right;direction:rtl">  لقد فرضنا هنا قيودًا على أن الوسيطة يجب أن تتضمن دالة <code>to_string</code> تقوم بإرجاع سلسلة.  إذا حاولنا وضع بعض الألعاب داخل <code>print</code> التي لا تندرج تحت القيود ، فلن يتم تجميع هذا الرمز. </p><br><p style=";text-align:right;direction:rtl">  هذا يبسط إلى حد كبير رمز.  على سبيل المثال ، راجع كيف قام Nibler <a href="">بالفرز في النطاقات v3</a> ، والذي يعمل في <a href="">الإصدار</a> C ++ 11/14/17.  هناك كود رائع مثل هذا: </p><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONCEPT_PP_CAT_(X, Y) X ## Y #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONCEPT_PP_CAT(X, Y) CONCEPT_PP_CAT_(X, Y) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/// \addtogroup group-concepts /// @{ #define CONCEPT_REQUIRES_(...) \ int CONCEPT_PP_CAT(_concept_requires_, __LINE__) = 42, \ typename std::enable_if&lt; \ (CONCEPT_PP_CAT(_concept_requires_, __LINE__) == 43) || (__VA_ARGS__), \ int \ &gt;::type = 0 \ /**/</span></span></span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  بحيث يمكنك لاحقًا القيام بما يلي: </p><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sortable_</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Rng, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> C = ordered_less, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> P = ident, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> I = <span class="hljs-keyword"><span class="hljs-keyword">iterator_t</span></span>&lt;Rng&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> requires_() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>( concepts::valid_expr( concepts::model_of&lt;concepts::ForwardRange, Rng&gt;(), concepts::is_true(ranges::Sortable&lt;I, C, P&gt;()) )); }; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Sortable = concepts::models&lt;Sortable_, Rng, C, P&gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Rng, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> C = ordered_less, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> P = ident, CONCEPT_REQUIRES_(!Sortable&lt;Rng, C, P&gt;())&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>()(Rng &amp;&amp;, C &amp;&amp; = C{}, P &amp;&amp; = P{}) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { ...</code> </pre> <br><p style=";text-align:right;direction:rtl">  آمل أنك تريد بالفعل رؤية كل هذا واستخدام المفاهيم المعدة في برنامج تجميع جديد. </p><br><h2 id="tochki-kastomizacii" style=";text-align:right;direction:rtl">  نقاط التخصيص </h2><br><p style=";text-align:right;direction:rtl">  الشيء المثير للاهتمام التالي الذي يمكن العثور عليه في المعيار هو <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">customization.point.object</a> .  يتم استخدامها بنشاط في مكتبة Nibler Ranges. </p><br><p style=";text-align:right;direction:rtl">  نقطة التخصيص هي وظيفة تستخدمها المكتبة القياسية بحيث يمكن تحميلها بشكل زائد على أنواع المستخدمين في مساحة اسم المستخدم ، ويمكن العثور على هذه الأحمال الزائدة باستخدام ADL. </p><br><p style=";text-align:right;direction:rtl">  تم تصميم نقاط التخصيص مع وضع المبادئ المعمارية التالية في <code>cust</code> (يُعتبر <code>cust</code> اسمًا لبعض نقاط التخصيص الوهمية): </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  تتم كتابة التعليمات البرمجية التي تستدعي <code>cust</code> إما في النموذج المؤهل <code>std::cust(a)</code> أو بشكل غير مؤهل: <code>using std::cust; cust(a);</code> <code>using std::cust; cust(a);</code>  .  كلا الإدخالات يجب أن تتصرف متطابقة.  على وجه الخصوص ، يجب أن يعثروا على أي حمل زائد للمستخدم في مساحة الاسم المرتبطة بالوسائط. </li><li style=";text-align:right;direction:rtl">  رمز يستخدم الحجز في شكل إدخال <code>std::cust; cust(a);</code> <code>std::cust; cust(a);</code>  يجب ألا تكون قادرة على التحايل على القيود المفروضة على <code>std::cust</code> . </li><li style=";text-align:right;direction:rtl">  يجب أن تعمل مكالمات النقطة المخصصة بكفاءة وعلى النحو الأمثل على أي مترجم حديث إلى حد ما. </li><li style=";text-align:right;direction:rtl">  يجب ألا ينشئ القرار أي انتهاكات جديدة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">لقاعدة التعريف الفردي (ODR)</a> . </li></ul><br><p style=";text-align:right;direction:rtl">  لفهم ما هو عليه ، يمكنك إلقاء نظرة على <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">N4381</a> .  للوهلة الأولى ، يبدو أنها طريقة لكتابة إصداراتك الخاصة من <code>begin</code> <code>swap</code> <code>data</code> وما شابهها ، والمكتبة القياسية تلتقطها باستخدام ADL. </p><br><p style=";text-align:right;direction:rtl">  والسؤال هو ، كيف يختلف هذا عن الممارسة القديمة ، عندما يكتب المستخدم عبئا زائدا على البعض <code>begin</code> لنوعه ومساحة الاسم الخاصة به؟  ولماذا هم حتى الأشياء؟ </p><br><p style=";text-align:right;direction:rtl">  في الواقع ، هذه هي مثيلات <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الكائنات الوظيفية</a> في <code>std</code> .  الغرض منها هو سحب الشيكات من النوع الأول (المصممة كمفاهيم) على جميع الوسائط في صف واحد ، ثم إرسال الدعوة إلى الوظيفة الصحيحة في <code>std</code> أو التخلي عنها للبيع في ADL. </p><br><p style=";text-align:right;direction:rtl">  في الواقع ، ليس هذا هو الشيء الذي ستستخدمه في برنامج غير مكتبة عادي.  هذه إحدى ميزات المكتبة القياسية ، والتي ستتيح لك إضافة التحقق من المفاهيم عند نقاط الامتداد المستقبلية ، والتي بدورها ستؤدي إلى عرض أخطاء أكثر جمالا ومفهومة إذا قمت بإفساد شيء ما في القوالب. </p><br><p style=";text-align:right;direction:rtl">  النهج الحالي لنقاط التخصيص لديه اثنين من المشاكل.  أولاً ، من السهل جدًا كسر كل شيء.  تخيل هذا الكود: </p><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t2</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap; swap(t1, t2); }</code> </pre> <br><p style=";text-align:right;direction:rtl">  إذا أجرينا بطريق الخطأ مكالمة مؤهلة إلى <code>std::swap(t1, t2)</code> فلن تبدأ نسخة <code>swap</code> الخاصة بنا أبدًا ، بصرف النظر عما نضعه هناك.  ولكن الأهم من ذلك ، أنه لا توجد طريقة لإرفاق اختبارات المفهوم مركزيًا بتطبيقات الوظائف المخصصة هذه.  في <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">N4381</a> يكتبون: </p><br><p style=";text-align:right;direction:rtl">  "تخيل أنه في يوم من الأيام في المستقبل ، ستتطلب <code>std::begin</code> أن يتم تصميم <code>Range</code> كمفهوم <code>Range</code> .  إضافة مثل هذا التقييد ببساطة لن يكون له أي تأثير على الكود اصطلاحياً باستخدام <code>std::begin</code> : </p><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::begin; begin(a);</code> </pre> <br><p style=";text-align:right;direction:rtl">  بعد كل شيء ، إذا تم إرسال استدعاء <code>begin</code> إلى الإصدار المثقل الذي أنشأه المستخدم ، فسيتم ببساطة تجاهل القيود المفروضة على <code>std::begin</code> . " </p><br><p style=";text-align:right;direction:rtl">  الحل الموصوف في propozal يحل كلتا المشكلتين ، لهذا نستخدم النهج من هذا المضاربة في تنفيذ <code>std::begin</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">start</a> (يمكنك إلقاء نظرة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">على godbolt</a> ): </p><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;utility&gt; namespace my_std { namespace detail { struct begin_fn { /*   ,         begin(arg)  arg.begin().  -   . */ template &lt;class T&gt; auto operator()(T&amp;&amp; arg) const { return impl(arg, 1L); } template &lt;class T&gt; auto impl(T&amp;&amp; arg, int) const requires requires { begin(std::declval&lt;T&gt;()); } { return begin(arg); } // ADL template &lt;class T&gt; auto impl(T&amp;&amp; arg, long) const requires requires { std::declval&lt;T&gt;().begin(); } { return arg.begin(); } // ... }; } //        inline constexpr detail::begin_fn begin{}; }</span></span></span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  يتم إجراء مكالمة مؤهلة من بعض <code>my_std::begin(someObject)</code> دائمًا من خلال <code>my_std::detail::begin_fn</code> - وهذا أمر جيد.  ماذا يحدث لمكالمة غير مؤهلة؟  دعنا نقرأ ورقتنا مرة أخرى: </p><br><p style=";text-align:right;direction:rtl">  "في الحالة التي يتم فيها استدعاء <code>my_std::begin</code> بدون مؤهل فور ظهور <code>my_std::begin</code> داخل النطاق ، يتغير الموقف إلى حد ما.  في المرحلة الأولى من البحث ، <code>begin</code> حل الاسم إلى الكائن العمومي <code>my_std::begin</code> .  نظرًا لأن البحث عثر على كائن ، وليس وظيفة ، لم يتم تنفيذ المرحلة الثانية من البحث.  بمعنى آخر ، إذا كان <code>my_std::begin</code> عبارة عن كائن ، فعندئذٍ استخدام construction <code>my_std::detail::begin_fn begin; begin(a);</code> <code>my_std::detail::begin_fn begin; begin(a);</code>  ما يعادل ببساطة <code>std::begin(a);</code>  "وكما رأينا ، يطلق هذا ADL مخصصًا." </p><br><p style=";text-align:right;direction:rtl">  هذا هو السبب في أن التحقق من صحة المفهوم يمكن القيام به في كائن دالة في <code>std</code> قبل أن تستدعي ADL الوظيفة التي يوفرها المستخدم.  لا توجد وسيلة لخداع هذا السلوك. </p><br><h2 id="kak-kastomiziruyut-tochki-kastomizacii" style=";text-align:right;direction:rtl">  كيف يتم تخصيص نقاط التخصيص؟ </h2><br><p style=";text-align:right;direction:rtl">  في الواقع ، "كائن نقطة التخصيص" (CPO) ليس اسمًا جيدًا.  من الاسم ، ليس من الواضح كيف تتوسع ، وما هي الآليات الموجودة أسفل الغطاء ، وما هي الوظائف التي تفضلها ... </p><br><p style=";text-align:right;direction:rtl">  مما يقودنا إلى مصطلح "nibloid".  إن nibloid هو CPO الذي يستدعي الدالة X إذا تم تعريفها في الفئة ، وإلا فإنه يستدعي الدالة X إذا كانت هناك وظيفة حرة مناسبة ، وإلا فإنه يحاول تنفيذ بعض الاستعاضة عن الوظيفة X. </p><br><p style=";text-align:right;direction:rtl">  على سبيل المثال ، <code>ranges::swap</code> nibloid <code>ranges::swap</code> عند استدعاء <code>ranges::swap(a, b)</code> سيحاول أولاً استدعاء <code>a.swap(b)</code> .  إذا لم يكن هناك مثل هذه الطريقة ، <code>swap(a, b)</code> استدعاء <code>swap(a, b)</code> باستخدام ADL.  إذا لم ينجح هذا ، فحاول <code>auto tmp = std::move(a); a = std::move(b); b = std::move(tmp)</code> <code>auto tmp = std::move(a); a = std::move(b); b = std::move(tmp)</code>  <code>auto tmp = std::move(a); a = std::move(b); b = std::move(tmp)</code> . </p><br><h1 id="itogi" style=";text-align:right;direction:rtl">  النتائج </h1><br><p style=";text-align:right;direction:rtl">  كما مات <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مازحًا</a> على Twitter ، اقترح <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">ديف</a> مرة واحدة جعل الأشياء الوظيفية "تعمل" مع ADL تمامًا مثل الوظائف العادية ، لأسباب الاتساق.  المفارقة هي أن قدرتهم على تعطيل ADL وأن يكونوا غير مرئيين له أصبحت الآن مزاياها الرئيسية. </p><br><p style=";text-align:right;direction:rtl">  كان هذا المقال بأكمله تحضيرا لهذا. </p><br><p style=";text-align:right;direction:rtl">  " <i><b>لقد فهمت كل شيء ، هذا كل شيء. هل <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">تستمع</a> ؟</b></i> </p><br><p style=";text-align:right;direction:rtl">  <i><b>هل سبق لك أن نظرت إلى شيء ما ، وبدا مجنونًا ، ثم في ضوء مختلف</b></i> <i><b><br></b></i>  <i><b>أشياء مجنونة رؤيتهم طبيعية؟</b></i> </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/-f/us/rh/-fusrhpdssngql8nlfx2qn0gdd8.jpeg"></p><br><p style=";text-align:right;direction:rtl">  <i><b>لا تخف.</b></i>  <i><b>لا تخف.</b></i>  <i><b>أشعر أنني بحالة جيدة جدا في القلب.</b></i>  <i><b>كل شيء سيكون على ما يرام.</b></i>  <i><b>لم أشعر أنني بحالة جيدة لسنوات عديدة.</b></i>  <i><b>كل شيء سيكون على ما يرام.</b></i> </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/pe/ca/az/pecaazhixdkr6dsdxv67ewlvte8.jpeg"></p><br><blockquote style=";text-align:right;direction:rtl">  دقيقة من الإعلانات.  بالفعل <b>هذا الأسبوع</b> ، من 19 إلى 20 أبريل ، سيعقد C ++ Russia 2019 - وهو مؤتمر مليء بالعروض التقديمية المتشددة حول اللغة نفسها والقضايا العملية مثل تعدد الإصدارات والأداء.  بالمناسبة ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">افتتح</a> المؤتمر نيكولاي خوسوتيس ، مؤلف مكتبة C ++ القياسية: دروس ومراجع <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">،</a> المذكورة في المقال.  يمكنك التعرف على البرنامج وشراء التذاكر <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">على الموقع الرسمي</a> .  هناك القليل من الوقت المتبقي ، هذه هي الفرصة الأخيرة. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar447900/">https://habr.com/ru/post/ar447900/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar447890/index.html">الحمد لله أنا لست مدير</a></li>
<li><a href="../ar447892/index.html">مسابقات PHDays جديدة: IDS الالتفافية والقرصنة المصنع</a></li>
<li><a href="../ar447894/index.html">ملخص MODX رقم 3 (25 مارس - 8 أبريل ، 2019)</a></li>
<li><a href="../ar447896/index.html">صور من الرسومات التقريبية: بالضبط كيف تعمل الشبكة العصبية NVIDIA GauGAN</a></li>
<li><a href="../ar447898/index.html">الفلاسفة تغذية جيدة أو برمجة .NET تنافسية</a></li>
<li><a href="../ar447902/index.html">GitHub "حذف" تماما مستودع تخزين أداة تأمين وحساب الخالق بأكمله</a></li>
<li><a href="../ar447904/index.html">يحدد خبراء التقنيات الإيجابية محاولات استغلال نقاط الضعف الحرجة في التقاء جماعي</a></li>
<li><a href="../ar447906/index.html">الابتكارات الفعلية: ما يمكن توقعه من سوق مركز البيانات في عام 2019؟</a></li>
<li><a href="../ar447908/index.html">يجب أن تعمل طريقتان لجمع المكافآت للإعلان في ألعاب الجوال أو الروبوتات</a></li>
<li><a href="../ar447910/index.html">"نفط" الاقتصاد الحديث وحرب الأفراد</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>