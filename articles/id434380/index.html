<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✂️ ✉️ ✴️ Dasar-dasar Injeksi Ketergantungan 😗 ⚙️ ⏹️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel ini, saya akan berbicara tentang dasar-dasar injeksi ketergantungan (Eng. Dependency Injection, DI ) dalam bahasa yang sederhana, dan ju...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dasar-dasar Injeksi Ketergantungan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434380/"><p><img src="https://habrastorage.org/getpro/habr/post_images/741/7ce/850/7417ce8508eb0e9c8dbd12b14d37f383.jpg" alt="Dasar-dasar Injeksi Ketergantungan"></p><br><p>  Dalam artikel ini, saya akan berbicara tentang dasar-dasar injeksi ketergantungan (Eng. <em>Dependency Injection, DI</em> ) dalam bahasa yang sederhana, dan juga tentang alasan untuk menggunakan pendekatan ini.  Artikel ini ditujukan bagi mereka yang tidak tahu injeksi ketergantungan apa, atau yang meragukan perlunya menggunakan teknik ini.  Jadi mari kita mulai. </p><a name="habracut"></a><br><h2 id="chto-takoe-zavisimost">  Apa itu kecanduan? </h2><br><p> Mari kita lihat contoh pertama.  Kami memiliki <code>ClassA</code> , <code>ClassB</code> dan <code>ClassC</code> seperti yang ditunjukkan di bawah ini: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classB: ClassB } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classC: ClassC } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassC</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br><p>  Anda dapat melihat bahwa kelas <code>ClassA</code> berisi turunan dari kelas <code>ClassB</code> , jadi kita dapat mengatakan bahwa kelas <code>ClassA</code> bergantung pada kelas <code>ClassB</code> .  Mengapa  Karena <code>ClassA</code> membutuhkan <code>ClassB</code> untuk bekerja dengan benar.  Kita juga dapat mengatakan bahwa kelas <code>ClassB</code> adalah ketergantungan dari kelas <code>ClassA</code> . </p><br><p>  Sebelum melanjutkan, saya ingin menjelaskan bahwa hubungan seperti itu baik, karena kita tidak perlu satu kelas untuk melakukan semua pekerjaan dalam aplikasi.  Kita perlu membagi logika ke dalam kelas yang berbeda, yang masing-masing akan bertanggung jawab untuk fungsi tertentu.  Dan dalam hal ini, kelas-kelas akan dapat berinteraksi secara efektif. </p><br><h2 id="kak-rabotat-s-zavisimostyami">  Bagaimana cara bekerja dengan dependensi? </h2><br><p>  Mari kita lihat tiga metode yang digunakan untuk melakukan tugas injeksi ketergantungan: </p><br><h3 id="pervyy-sposob-sozdavat-zavisimosti-v-zavisimom-klasse">  Cara pertama: buat dependensi di kelas dependen </h3><br><p>  Sederhananya, kita dapat membuat objek kapan pun kita membutuhkannya.  Lihatlah contoh berikut: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classB: ClassB <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someMethodOrConstructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { classB = ClassB() classB.doSomething() } }</code> </pre> <br><p>  Sangat mudah!  Kami membuat kelas saat kami membutuhkannya. </p><br><p>  <strong>Manfaatnya</strong> </p><br><ul><li>  Mudah dan sederhana. </li><li>  Kelas dependen ( <code>ClassA</code> dalam kasus kami) sepenuhnya mengontrol bagaimana dan kapan membuat dependensi. </li></ul><br><p>  <strong>Kekurangan</strong> </p><br><ul><li>  <code>ClassA</code> dan <code>ClassB</code> terkait erat satu sama lain.  Karena itu, setiap kali kita perlu menggunakan <code>ClassA</code> , kita akan dipaksa untuk menggunakan <code>ClassB</code> , dan <strong>tidak mungkin untuk mengganti <code>ClassB</code> dengan yang lain</strong> . </li><li>  Dengan perubahan apa pun dalam inisialisasi kelas <code>ClassB</code> , Anda harus menyesuaikan kode di dalam kelas <code>ClassA</code> (dan semua kelas lainnya bergantung pada <code>ClassB</code> ).  Ini menyulitkan proses mengubah ketergantungan. </li><li>  <strong><code>ClassA</code> tidak dapat diuji.</strong>  Jika Anda perlu menguji suatu kelas, namun ini adalah salah satu aspek terpenting dari pengembangan perangkat lunak, maka Anda harus melakukan pengujian unit masing-masing kelas secara terpisah.  Ini berarti bahwa jika Anda ingin memverifikasi operasi yang benar dari kelas <code>ClassA</code> dan membuat beberapa tes unit untuk memverifikasinya, maka, seperti yang ditunjukkan dalam contoh, Anda akan membuat instance kelas <code>ClassB</code> , bahkan ketika Anda tidak tertarik dengannya.  Jika kesalahan terjadi selama pengujian, maka Anda tidak akan dapat memahami di mana letaknya - di <code>ClassA</code> atau <code>ClassB</code> .  Bagaimanapun, ada kemungkinan bahwa bagian dari kode di <code>ClassB</code> menyebabkan kesalahan, sementara <code>ClassA</code> bekerja dengan benar.  Dengan kata lain, pengujian unit tidak dimungkinkan karena modul (kelas) tidak dapat dipisahkan satu sama lain. </li><li>  <code>ClassA</code> harus dikonfigurasi sehingga dapat menyuntikkan dependensi.  Dalam contoh kita, dia perlu tahu cara membuat <code>ClassC</code> dan menggunakannya untuk membuat <code>ClassB</code> .  Akan lebih baik jika dia tidak tahu apa-apa tentang itu.  Mengapa  Karena <strong>prinsip tanggung jawab tunggal</strong> . </li></ul><br><blockquote>  <em>Setiap kelas seharusnya hanya melakukan tugasnya.</em> </blockquote><p>  Oleh karena itu, kami tidak ingin kelas bertanggung jawab atas apa pun selain tugas mereka sendiri.  Implementasi dependensi adalah tugas tambahan yang kami tetapkan untuk mereka. </p><br><h3 id="vtoroy-sposob-vnedryat-zavisimosti-cherez-polzovatelskiy-klass">  Cara kedua: menyuntikkan dependensi melalui kelas kustom </h3><br><p>  Jadi, memahami bahwa menyuntikkan dependensi dalam kelas dependen bukanlah ide yang baik, mari kita jelajahi cara alternatif.  Di sini, kelas dependen mendefinisikan semua dependensi yang dibutuhkan di dalam konstruktor dan memungkinkan kelas pengguna untuk menyediakannya.  Apakah ini solusi untuk masalah kita?  Kami akan mencari tahu nanti. </p><br><p>  Lihatlah kode contoh di bawah ini: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classB: ClassB <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(classB: ClassB){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.classB = classB } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classC: ClassC <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(classC: ClassC){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.classC = classC } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassC</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserClass</span></span></span></span>(){ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classC = ClassC(); <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classB = ClassB(classC); <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classA = ClassA(classB); classA.someMethod(); } } view rawDI Example In Medium -</code> </pre> <br><p>  Sekarang <code>ClassA</code> mendapatkan semua dependensi di dalam konstruktor dan cukup memanggil metode kelas <code>ClassB</code> tanpa menginisialisasi apa pun. </p><br><p>  <strong>Manfaatnya</strong> </p><br><ul><li>  <code>ClassA</code> dan <code>ClassB</code> sekarang longgar digabungkan, dan kita dapat mengganti <code>ClassB</code> tanpa melanggar kode di dalam <code>ClassA</code> .  Sebagai contoh, alih-alih melewati <code>ClassB</code> kita dapat melewati <code>AssumeClassB</code> , yang merupakan subkelas dari <code>ClassB</code> , dan program kami akan bekerja dengan baik. </li><li>  <code>ClassA</code> sekarang dapat diuji.  Saat menulis unit test, kita dapat membuat versi kita sendiri dari <code>ClassB</code> (objek uji) dan meneruskannya ke <code>ClassA</code> .  Jika kesalahan terjadi saat lulus tes, sekarang kita tahu pasti bahwa ini pasti kesalahan di <code>ClassA</code> . </li><li>  <code>ClassB</code> dibebaskan dari bekerja dengan dependensi dan dapat fokus pada tugasnya. </li></ul><br><p>  <strong>Kekurangan</strong> </p><br><ul><li>  Metode ini menyerupai mekanisme rantai, dan pada titik tertentu rantai harus terputus.  Dengan kata lain, pengguna kelas <code>ClassA</code> harus tahu segalanya tentang inisialisasi <code>ClassB</code> , yang pada gilirannya membutuhkan pengetahuan tentang inisialisasi <code>ClassC</code> , dll.  Jadi, Anda melihat bahwa setiap perubahan dalam konstruktor dari kelas-kelas ini dapat menyebabkan perubahan dalam kelas panggilan, belum lagi bahwa <code>ClassA</code> dapat memiliki lebih dari satu pengguna, sehingga logika membuat objek akan diulang. </li><li>  Terlepas dari kenyataan bahwa dependensi kami jelas dan mudah dipahami, kode pengguna tidak trivial dan sulit dikelola.  Karena itu, semuanya tidak begitu sederhana.  Selain itu, kode melanggar prinsip tanggung jawab tunggal, karena bertanggung jawab tidak hanya untuk pekerjaannya, tetapi juga untuk implementasi dependensi di kelas-kelas dependen. </li></ul><br><p>  Metode kedua jelas bekerja lebih baik daripada yang pertama, tetapi masih memiliki kekurangannya.  Apakah mungkin menemukan solusi yang lebih cocok?  Sebelum mempertimbangkan cara ketiga, mari kita bicara tentang konsep injeksi ketergantungan. </p><br><h3 id="chto-takoe-vnedrenie-zavisimostey">  Apa itu injeksi ketergantungan? </h3><br><blockquote>  Injeksi ketergantungan adalah cara untuk menangani dependensi di luar kelas dependen ketika kelas dependen tidak perlu melakukan apa pun. </blockquote><p>  Berdasarkan definisi ini, solusi pertama kami jelas tidak menggunakan ide injeksi dependensi, dan cara kedua adalah bahwa kelas dependen tidak melakukan apa pun untuk menyediakan dependensi.  Tapi kami masih berpikir solusi kedua itu buruk.  MENGAPA?! </p><br><p>  Karena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">definisi injeksi dependensi</a> tidak mengatakan apa-apa tentang di mana pekerjaan dengan dependensi harus dilakukan (kecuali di luar kelas dependen), pengembang harus memilih tempat yang cocok untuk injeksi dependensi.  Seperti yang Anda lihat dari contoh kedua, kelas pengguna bukan tempat yang tepat. </p><br><p>  Bagaimana melakukan yang lebih baik?  Mari kita lihat cara ketiga untuk menangani dependensi. </p><br><h3 id="tretiy-sposob-pust-kto-nibud-eschyo-obrabatyvaet-zavisimosti-vmesto-nas">  Cara ketiga: biarkan orang lain menangani dependensi daripada kita </h3><br><p>  Menurut pendekatan pertama, kelas dependen bertanggung jawab untuk mendapatkan dependensi mereka sendiri, dan pada pendekatan kedua, kami memindahkan pemrosesan dependensi dari kelas dependen ke kelas pengguna.  Mari kita bayangkan bahwa ada orang lain yang bisa menangani dependensi, sebagai akibatnya baik kelas dependen maupun pengguna tidak akan melakukan pekerjaan.  Metode ini memungkinkan Anda untuk bekerja dengan dependensi dalam aplikasi secara langsung. </p><br><blockquote>  <strong><em>Implementasi injeksi ketergantungan yang “bersih” (menurut pendapat pribadi saya)</em></strong> <br><br>  <em>Tanggung jawab untuk menangani dependensi ada pada pihak ketiga, jadi tidak ada bagian dari aplikasi yang akan berinteraksi dengannya.</em> </blockquote><p>  Ketergantungan injeksi bukanlah teknologi, kerangka kerja, perpustakaan, atau sesuatu seperti itu.  Ini hanya sebuah ide.  Idenya adalah untuk bekerja dengan dependensi di luar kelas dependen (lebih disukai di bagian yang dialokasikan secara khusus).  Anda dapat menerapkan ide ini tanpa menggunakan pustaka atau kerangka kerja apa pun.  Namun, kami biasanya beralih ke kerangka kerja untuk menerapkan dependensi, karena menyederhanakan pekerjaan dan menghindari penulisan kode templat. </p><br><p>  Setiap kerangka kerja injeksi ketergantungan memiliki dua karakteristik yang melekat.  Fungsi tambahan lainnya mungkin tersedia untuk Anda, tetapi dua fungsi ini akan selalu ada: </p><br><p>  Pertama, kerangka kerja ini menawarkan cara untuk menentukan bidang (objek) yang harus diimplementasikan.  Beberapa kerangka kerja melakukan ini dengan <code>@Inject</code> keterangan bidang atau konstruktor menggunakan anotasi <code>@Inject</code> , tetapi ada metode lain.  Misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Koin</a> menggunakan fitur bahasa bawaan Kotlin untuk menentukan implementasi.  <code>Inject</code> berarti bahwa ketergantungan harus ditangani oleh kerangka kerja DI.  Kode akan terlihat seperti ini: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classB: ClassB <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(classB: ClassB){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.classB = classB } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classC: ClassC <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(classC: ClassC){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.classC = classC } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassC</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ } }</code> </pre> <br><p>  Kedua, kerangka kerja memungkinkan Anda untuk menentukan cara menyediakan setiap ketergantungan, dan ini terjadi dalam file terpisah.  Kira-kira terlihat seperti ini (perlu diingat bahwa ini hanyalah contoh, dan mungkin berbeda dari kerangka ke kerangka kerja): </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OurThirdPartyGuy</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideClassC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ClassC() <span class="hljs-comment"><span class="hljs-comment">//just creating an instance of the object and return it. } fun provideClassB(classC: ClassC){ return ClassB(classC) } fun provideClassA(classB: ClassB){ return ClassA(classB) } }</span></span></code> </pre> <br><p>  Jadi, seperti yang Anda lihat, setiap fungsi bertanggung jawab untuk memproses satu ketergantungan.  Oleh karena itu, jika kita perlu menggunakan <code>ClassA</code> di suatu tempat dalam aplikasi, hal berikut akan terjadi: Kerangka kerja DI kita menciptakan satu instance dari kelas <code>ClassC</code> dengan memanggil <code>provideClassC</code> , meneruskannya ke <code>provideClassB</code> dan menerima instance dari <code>ClassB</code> , yang dilewatkan untuk <code>provideClassA</code> , dan sebagai hasilnya, <code>ClassA</code> dibuat.  Ini hampir ajaib.  Sekarang mari kita periksa kelebihan dan kelebihan dari metode ketiga. </p><br><p>  <strong>Manfaatnya</strong> </p><br><ul><li>  Segalanya sesederhana mungkin.  Baik kelas dependen dan kelas yang menyediakan dependensi jelas dan sederhana. </li><li>  Kelas digabungkan secara longgar dan mudah diganti oleh kelas lain.  Misalkan kita ingin mengganti <code>ClassC</code> dengan <code>AssumeClassC</code> , yang merupakan subkelas dari <code>ClassC</code> .  Untuk melakukan ini, Anda hanya perlu mengubah kode penyedia sebagai berikut, dan di mana pun <code>ClassC</code> digunakan, versi baru sekarang akan digunakan secara otomatis: </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideClassC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AssumeClassC() }</code> </pre> <br><p>  Harap dicatat bahwa tidak ada kode di dalam aplikasi yang berubah, hanya metode penyedia.  Tampaknya tidak ada yang lebih sederhana dan lebih fleksibel. </p><br><ul><li>  Testabilitas yang luar biasa.  Anda dapat dengan mudah mengganti dependensi dengan versi uji selama pengujian.  Faktanya, injeksi ketergantungan adalah penolong utama Anda dalam hal pengujian. </li><li>  Memperbaiki struktur kode, seperti  aplikasi memiliki tempat terpisah untuk pemrosesan ketergantungan.  Akibatnya, sisa aplikasi dapat fokus secara eksklusif pada fungsinya dan tidak tumpang tindih dengan dependensi. </li></ul><br><p>  <strong>Kekurangan</strong> </p><br><ul><li>  Kerangka kerja DI memiliki ambang masuk tertentu, sehingga tim proyek perlu menghabiskan waktu dan mempelajarinya sebelum menggunakannya secara efektif. </li></ul><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><ul><li>  Penanganan ketergantungan tanpa DI dimungkinkan, tetapi hal itu dapat menyebabkan crash aplikasi. </li><li>  DI hanyalah ide yang efektif, yang dengannya memungkinkan untuk menangani dependensi di luar kelas dependen. </li><li>  Paling efektif menggunakan DI di bagian-bagian tertentu dari aplikasi.  Banyak kerangka kerja berkontribusi untuk ini. </li><li>  Kerangka kerja dan perpustakaan tidak diperlukan untuk DI, tetapi mereka dapat banyak membantu. </li></ul><br><p>  Dalam artikel ini, saya mencoba menjelaskan dasar-dasar bekerja dengan konsep injeksi ketergantungan, dan juga mencantumkan alasan untuk menggunakan ide ini.  Ada banyak sumber daya yang dapat Anda jelajahi untuk mempelajari lebih lanjut tentang penggunaan DI di aplikasi Anda sendiri.  Sebagai contoh, bagian terpisah di bagian lanjutan dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kursus profesi Android</a> kami didedikasikan untuk topik ini. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id434380/">https://habr.com/ru/post/id434380/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id434362/index.html">BUKAN perkiraan untuk 2019</a></li>
<li><a href="../id434364/index.html">Dukungan Antrian Hangfire</a></li>
<li><a href="../id434368/index.html">Pembelajaran Mesin untuk Menemukan Kesalahan dalam Kode: Bagaimana Saya Magang di JetBrains Research</a></li>
<li><a href="../id434370/index.html">Penakluk bayangan lain di Phaser, atau penggunaan sepeda</a></li>
<li><a href="../id434374/index.html">Memeriksa RBAC di Kubernetes</a></li>
<li><a href="../id434382/index.html">Porting Alpine Linux ke RISC-V</a></li>
<li><a href="../id434384/index.html">Atas tanggung jawab pemain</a></li>
<li><a href="../id434386/index.html">Douglas Engelbart: "Menambah Kecerdasan Manusia: Kerangka Konseptual"</a></li>
<li><a href="../id434394/index.html">Bugatti Automobiles Berhasil Menguji Caliper Rem Cetak 3D</a></li>
<li><a href="../id434398/index.html">Vanivar Bush: "As We May Think". Bagian 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>