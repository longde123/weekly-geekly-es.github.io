<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¦ ğŸƒ ğŸ¤  Cascading cache invalidation. Bagian 2 â™ï¸ ğŸ”½ ğŸ«</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada bagian pertama dari terjemahan materi yang ditujukan untuk cascading invalidation cache, kami membahas sifat masalah dan mempertimbangkan salah s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cascading cache invalidation. Bagian 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/472862/">  Pada bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertama dari</a> terjemahan materi yang ditujukan untuk cascading invalidation cache, kami membahas sifat masalah dan mempertimbangkan salah satu solusi untuk itu, yang terdiri dari penggunaan kartu impor.  Kelebihannya adalah kemudahan implementasi.  Dan minus - dukungan browser yang buruk.  Hari ini kita akan berbicara tentang cara lain untuk menyelesaikan masalah ini. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/ft/lh/jx/ftlhjxkkxoeswh7akykdb6fcfoq.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Pendekatan # 2: Pekerja Layanan</font> </h2><br>  Solusi kedua untuk masalah ini adalah mereproduksi fungsi kartu impor menggunakan pekerja layanan. <br><br>  Misalnya, menggunakan pekerja layanan, Anda dapat mendengarkan untuk <code>fetch</code> acara yang ditujukan untuk memuat materi yang terletak di alamat yang terkait dengan kunci kartu impor.  Dengan menjalankan permintaan ini, Anda dapat mengunggah file yang namanya menyertakan hash dari isinya: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> importMap = {  <span class="hljs-string"><span class="hljs-string">'/main.mjs'</span></span>: <span class="hljs-string"><span class="hljs-string">'/main-1a2b.mjs'</span></span>,  <span class="hljs-string"><span class="hljs-string">'/dep1.mjs'</span></span>: <span class="hljs-string"><span class="hljs-string">'/dep1-b2c3.mjs'</span></span>,  <span class="hljs-string"><span class="hljs-string">'/dep2.mjs'</span></span>: <span class="hljs-string"><span class="hljs-string">'/dep2-3c4d.mjs'</span></span>,  <span class="hljs-string"><span class="hljs-string">'/dep3.mjs'</span></span>: <span class="hljs-string"><span class="hljs-string">'/dep3-d4e5.mjs'</span></span>,  <span class="hljs-string"><span class="hljs-string">'/vendor.mjs'</span></span>: <span class="hljs-string"><span class="hljs-string">'/vendor-5e6f.mjs'</span></span>, }; addEventListener(<span class="hljs-string"><span class="hljs-string">'fetch'</span></span>, (event) =&gt; {  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> oldPath = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> URL(event.request.url, location).pathname;  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (importMap.hasOwnProperty(oldPath)) {    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newPath = importMap[oldPath];    event.respondWith(fetch(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Request(newPath, event.request)));  } });</code> </pre> <br>  Namun, dengan mempertimbangkan fakta bahwa kode pekerja layanan diberikan di atas, Anda perlu memahami bahwa kode ini hanya akan berfungsi setelah pekerja layanan diinstal dan diaktifkan.  Dan ini berarti bahwa ketika Anda pertama kali memuat situs, file akan diminta yang tidak memiliki hash dalam namanya.  File dengan hash dalam nama akan diminta pada unduhan situs berikutnya.  Dengan kata lain, di sini kita berurusan dengan pemuatan ganda dari setiap file. <br><br>  Jika Anda mempertimbangkan hal ini, sepertinya pekerja layanan itu bukan solusi yang cocok untuk masalah cascading cache invalidation. <br><br>  Namun, di sini saya akan meminta Anda untuk mengizinkan saya secara singkat mengkritik pendekatan lama terhadap caching.  Mari kita pikirkan apa yang terjadi jika kita berhenti menggunakan hash konten dalam nama file, alih-alih memasukkan informasi hash dalam kode pekerja layanan. <br><br>  Ini adalah cara alat seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Workbox</a> yang berfungsi sumber daya pra-cache.  Mereka menghasilkan hash dari isi setiap file dari majelis dan menyimpan korespondensi dari nama file di pekerja layanan (ternyata sesuatu seperti kartu impor eksternal).  Selain itu, mereka menyimpan sumber daya selama instalasi pertama pekerja layanan dan menambahkan <code>fetch</code> pendengar acara yang mengembalikan file yang di-cache sebagai tanggapan terhadap permintaan yang alamatnya sesuai dengan yang ada di peta impor. <br><br>  Meskipun gagasan bahwa klien menerima file yang tidak berisi informasi tentang versi kontennya mungkin tampak menakutkan (dan bertentangan dengan semua yang telah diajarkan kepada Anda), permintaan untuk mengunduh sumber daya yang sesuai dijalankan hanya ketika pekerja layanan diinstal.  Permintaan lebih lanjut untuk mengunduh sumber daya seperti itu melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cache Storage API</a> (yang tidak menggunakan header caching), dan permintaan baru ke server dieksekusi hanya ketika versi baru dari pekerja layanan sedang digunakan (dan Anda tetap memerlukan versi baru dari file-file ini). <br><br>  Akibatnya, hingga Anda mulai menggunakan versi modul baru tanpa memperbarui pekerja layanan (dan ini jelas tidak disarankan), Anda tidak akan pernah mengalami konflik atau ketidakcocokan versi. <br><br>  Untuk mengatur caching awal file menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pustaka workbox-precaching,</a> Anda bisa meneruskan alamat file dan string dengan informasi versi file-file ini ke metode pustaka <code>precacheAndRoute()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {preacacheAndRoute} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'workbox-precaching'</span></span>; precacheAndRoute([  {<span class="hljs-attr"><span class="hljs-attr">url</span></span>: <span class="hljs-string"><span class="hljs-string">'/main.mjs'</span></span>, <span class="hljs-attr"><span class="hljs-attr">revision</span></span>: <span class="hljs-string"><span class="hljs-string">'1a2b'</span></span>},  {<span class="hljs-attr"><span class="hljs-attr">url</span></span>: <span class="hljs-string"><span class="hljs-string">'/dep1.mjs'</span></span>, <span class="hljs-attr"><span class="hljs-attr">revision</span></span>: <span class="hljs-string"><span class="hljs-string">'b2c3'</span></span>},  {<span class="hljs-attr"><span class="hljs-attr">url</span></span>: <span class="hljs-string"><span class="hljs-string">'/dep2.mjs'</span></span>, <span class="hljs-attr"><span class="hljs-attr">revision</span></span>: <span class="hljs-string"><span class="hljs-string">'3c4d'</span></span>},  {<span class="hljs-attr"><span class="hljs-attr">url</span></span>: <span class="hljs-string"><span class="hljs-string">'/dep3.mjs'</span></span>, <span class="hljs-attr"><span class="hljs-attr">revision</span></span>: <span class="hljs-string"><span class="hljs-string">'d4e5'</span></span>},  {<span class="hljs-attr"><span class="hljs-attr">url</span></span>: <span class="hljs-string"><span class="hljs-string">'/vendor.mjs'</span></span>, <span class="hljs-attr"><span class="hljs-attr">revision</span></span>: <span class="hljs-string"><span class="hljs-string">'5e6f'</span></span>}, ]);</code> </pre> <br>  Bagaimana tepatnya menghasilkan garis dengan versi tergantung pada pengembang sendiri.  Tetapi jika dia tidak ingin membuatnya sendiri, tugas membuat manifes pre-cache akan membantu menyederhanakan paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">workbox-build</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">workbox-cli</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">workbox-webpack-plugin</a> (mereka bahkan dapat menghasilkan semua kode pekerja layanan). <br><br>  Proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">demo</a> saya memiliki contoh implementasi caching awal menggunakan pekerja layanan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aplikasi Rollup</a> (menggunakan <code>workbox-cli</code> ) dan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aplikasi webpack</a> (menggunakan <code>workbox-webpack-plugin</code> ). <br><br><h2>  <font color="#3AC1EF">Pendekatan # 3: skrip khusus untuk memuat sumber daya</font> </h2><br>  Jika situs Anda tidak memiliki kemampuan untuk menggunakan kartu impor atau pekerja layanan, maka di sini adalah pendekatan ketiga untuk menyelesaikan masalah.  Ini terdiri dalam mengimplementasikan fungsionalitas peta impor menggunakan skrip sendiri untuk memuat sumber daya. <br><br>  Jika Anda terbiasa dengan pemuat modul gaya AMD (seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SystemJS</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RequireJS</a> ), maka Anda mungkin juga tahu bahwa pemuat modul ini biasanya mendukung alias modul.  Bahkan, SystemJS <a href="">mendukung</a> aliasing menggunakan sintaks peta impor.  Akibatnya, masalah kami mudah dipecahkan sedemikian rupa sehingga solusi ini akan berorientasi masa depan (dan, di samping itu, akan bekerja di semua browser yang ada). <br><br>  Jika Anda menggunakan Rollup, maka Anda dapat mengatur opsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">output.format</a> ke <code>system</code> .  Dalam hal ini, membuat peta impor untuk aplikasi akan dilakukan dengan cara yang sama seperti yang dijelaskan dalam deskripsi pendekatan pertama untuk memecahkan masalah pembatalan cache cascading. <br><br>  Aplikasi demo saya memiliki contoh situs tempat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rollup</a> digunakan untuk membangun materi dalam format yang cocok untuk SystemJS, dan untuk membuat peta impor untuk mengunduh versi file hash. <br><br><h3>  <font color="#3AC1EF">â– Paket web dan memuat sumber daya menggunakan skrip</font> </h3><br>  Webpack juga dapat membantu Anda memuat sumber daya menggunakan skrip Anda sendiri, tetapi loader yang dihasilkan oleh webpack, tidak seperti loader AMD klasik, unik untuk setiap bundel tertentu. <br><br>  Keuntungan dari pendekatan ini adalah bahwa runtime webpack dapat (dan sebenarnya berfungsi) termasuk pemetaannya sendiri antara nama / pengidentifikasi fragmen dan alamatnya (ini mirip dengan apa yang saya rekomendasikan di sini).  Ini berarti bahwa bundel webpack yang menggunakan pemecahan kode lebih kecil kemungkinannya menderita cascading cache invalidation. <br><br>  Sebenarnya, kabar baiknya bagi pengguna webpack adalah jika mereka mengkonfigurasi dengan benar perakitan proyek menggunakan webpack (membagi kode menjadi fragmen, seperti yang dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">panduan</a> caching webpack), maka perubahan dalam kode modul individual tidak boleh mengarah pada pembatalan. lebih dari dua fragmen (satu adalah yang berisi modul yang dimodifikasi, yang kedua adalah yang berisi runtime). <br><br>  Tapi saya punya kabar buruk bagi mereka yang menggunakan webpack untuk membangun proyek.  Faktanya adalah bahwa sistem pemetaan internal bundler ini tidak standar.  Ini berarti bahwa itu tidak dapat diintegrasikan dengan alat yang ada, dan bahwa pengguna tidak dapat mengonfigurasinya.  Misalnya, Anda tidak dapat menghasilkan file output secara mandiri (yaitu, lakukan seperti yang dijelaskan dalam cerita tentang pendekatan pertama untuk menyelesaikan masalah) dan masukkan hash Anda sendiri dalam pemetaan.  Dan ini adalah minus dari webpack, karena hash yang digunakan oleh bundler ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak</a> berdasarkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pada isi dari file output</a> , tetapi pada isi dari file sumber dan pada konfigurasi build.  Dan ini dapat menyebabkan kesalahan kecil dan halus (misalnya - di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> - pesan tentang kesalahan tersebut). <br><br>  Jika Anda menggunakan webpack untuk membangun aplikasi yang juga menggunakan pekerja layanan, maka saya akan merekomendasikan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">workbox-webpack-plugin</a> dan strategi caching, yang dijelaskan dalam pendekatan kedua untuk memecahkan masalah.  Plugin akan menghasilkan hash berdasarkan konten output webpack, yang berarti Anda tidak perlu khawatir tentang kesalahan di atas.  Selain itu, bekerja dengan nama file yang tidak memiliki hash biasanya lebih mudah daripada bekerja dengan nama yang memiliki hash. <br><br><h2>  <font color="#3AC1EF">Sumber daya proyek web lainnya</font> </h2><br>  Sebelumnya, saya berbicara tentang bagaimana bekerja dalam program JavaScript dengan nama file "hash" yang berisi kode program dapat menyebabkan cascading invalidation cache.  Tetapi masalah ini berlaku untuk materi proyek web lainnya. <br><br>  Jadi, file CSS dan SVG sering merujuk ke sumber daya lain (gambar, misalnya), yang namanya mungkin berisi informasi tentang versi file yang sesuai dalam bentuk hash.  Seperti dalam kasus file JS, untuk memecahkan masalah cascading invalidation cache yang disebabkan oleh perubahan nama sumber daya yang serupa, Anda dapat menggunakan kartu impor atau pekerja layanan. <br><br>  Untuk sumber daya seperti file gambar dan video, ini tidak masalah.  Semua rekomendasi yang ada berlaku di sini. <br><br>  Hal utama di sini adalah untuk mengingat bahwa selalu, ketika file A mengunduh file B, dan, di samping itu, termasuk informasi tentang versi file B sebagai hash isinya, membatalkan cache untuk file B juga akan menyebabkan pembatalan cache untuk file A. bekerja dengan sumber daya, yang penggunaannya diatur secara berbeda, Anda bisa mengabaikan saran yang diberikan dalam materi ini. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Saya harap artikel ini menginspirasi Anda untuk melihat lebih dekat pada situs Anda dan mencari tahu apakah masalah cascading cache invalidation memengaruhinya.  Cara termudah untuk memeriksa ini adalah dengan merakit situs, mengubah satu baris kode dalam file yang diimpor oleh banyak modul, dan kemudian membangun kembali situs.  Jika dalam direktori di mana hasil perakitan berada, nama-nama telah berubah untuk lebih dari satu file, ini berarti Anda memiliki tanda pembatalan cache cascading.  Dan jika demikian, maka Anda mungkin perlu berpikir tentang menggunakan salah satu pendekatan yang dijelaskan di sini untuk menyelesaikan masalah ini dalam proyek Anda. <br><br>  Jika kita berbicara tentang apa yang lebih baik untuk dipilih, maka, terus terang, itu tergantung banyak hal. <br><br>  Ketika kartu impor akan didukung secara luas oleh peramban, maka kami akan menghadapi cara paling sederhana dan paling sempurna untuk menangani pembatalan cache berjenjang.  Tetapi sampai dukungan tersebut tersedia, mekanisme ini tidak berlaku dalam praktiknya. <br><br>  Jika Anda sudah menggunakan pekerja layanan, terutama jika Anda menggunakan Workbox, maka saya akan merekomendasikan pendekatan kedua untuk menyelesaikan masalah yang dibahas di sini.  Di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs</a> di mana materi asli ini diterbitkan, tugas caching awal sumber daya diselesaikan dengan cara ini. <br><br>  Selain itu, pekerja layanan adalah satu-satunya pilihan bagi mereka yang menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">modul JavaScript</a> dalam produksi.  (Dan mengingat bahwa 98% pengguna saya memiliki browser yang mendukung baik pekerja layanan dan modul JS, tidak sulit bagi saya untuk memilih opsi ini). <br><br>  Jika pekerja layanan tidak cocok untuk Anda, maka saya akan merekomendasikan ketiga pendekatan yang dibahas di sini, yang melibatkan penggunaan SystemJS.  Pendekatan ini lebih baik daripada yang lain, berdasarkan skrip bootloader, berfokus pada masa depan.  Dari sana akan mudah untuk beralih ke mengimpor kartu pada saat dukungan mereka akan muncul di semua browser. <br><br>  Jika kita berbicara tentang produktivitas, maka pilihan arah pengoptimalannya bergantung pada setiap proyek tertentu.  Sebelum mengoptimalkan kinerja, penting untuk mengukurnya, dan kemudian memutuskan apakah ada masalah, dan apakah perlu untuk menanganinya.  Jika Anda jarang melepaskan rilis proyek baru, dan perubahan yang dibuat untuk proyek biasanya berskala cukup besar, maka masalah cascading cache invalidation mungkin tidak relevan bagi Anda. <br><br>  Di sisi lain, jika Anda sering menggunakan perubahan proyek kecil, maka pengguna Anda yang kembali mungkin mengalami masalah memuat kode dalam jumlah besar yang sudah ada dalam cache mereka.  Memecahkan masalah ini akan berarti peningkatan kinerja pemuatan halaman yang signifikan untuk pengguna tersebut. <br><br>  <b>Pembaca yang budiman!</b>  Apakah cascading invalidation cache memengaruhi proyek Anda?  Jika demikian, beri tahu kami bagaimana Anda berencana untuk menyelesaikannya. <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id472862/">https://habr.com/ru/post/id472862/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id472852/index.html">GitLab membuat perubahan untuk pengguna produk cloud dan komersial</a></li>
<li><a href="../id472854/index.html">Profiling Unity UI: Siapa yang merusak Batching Saya?</a></li>
<li><a href="../id472856/index.html">Bagaimana saya membuat layanan kontrol kualitas dari tabel dan stik</a></li>
<li><a href="../id472858/index.html">Python dan klien HTTP cepat</a></li>
<li><a href="../id472860/index.html">Cascading cache invalidation. Bagian 1</a></li>
<li><a href="../id472866/index.html">Jimat untuk komunikasi yang stabil</a></li>
<li><a href="../id472868/index.html">Manajemen server telepon: Klien seluler RUVDS</a></li>
<li><a href="../id472870/index.html">Mengapa Agile terhenti tanpa mengubah arsitektur dan alat pengembangan - presentasi konferensi</a></li>
<li><a href="../id472872/index.html">Bagaimana meningkatkan startup hingga 50 karyawan tanpa kehilangan budaya</a></li>
<li><a href="../id472874/index.html">Cerita kapal luar angkasa: melalui menara air ke bintang-bintang</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>