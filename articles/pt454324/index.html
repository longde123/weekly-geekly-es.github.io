<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛵 💅🏼 🚷 Ponteiros em Python: qual é o objetivo? 👳🏿 🙊 👨🏽‍🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Se você já trabalhou com linguagens de baixo nível como C ou C ++, provavelmente já ouviu falar sobre ponteiros. Eles permitem aumentar significativam...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ponteiros em Python: qual é o objetivo?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/454324/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/_i/vd/cj/_ivdcjv0itamifffxs0i1i-mqh4.jpeg"></div><br>  Se você já trabalhou com linguagens de baixo nível como C ou C ++, provavelmente já ouviu falar sobre ponteiros.  Eles permitem aumentar significativamente a eficácia de diferentes partes do código.  Mas eles também podem confundir iniciantes - e até desenvolvedores experientes - e levar a erros de gerenciamento de memória.  Existem ponteiros no Python, posso de alguma forma imitá-los? <br><br>  Ponteiros são amplamente utilizados em C e C ++.  De fato, são variáveis ​​que contêm os endereços de memória nos quais outras variáveis ​​estão localizadas.  Para atualizar os ponteiros, leia esta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">resenha</a> . <br><br>  Graças a este artigo, você entenderá melhor o modelo de objeto no Python e descobrirá por que os ponteiros não existem realmente nessa linguagem.  Caso você precise simular o comportamento dos ponteiros, aprenderá como imitá-los sem o pesadelo que acompanha o gerenciamento de memória. <br><a name="habracut"></a><br>  Com este artigo, você: <br><br><ul><li>  Saiba por que o Python não tem ponteiros. </li><li>  Aprenda a diferença entre variáveis ​​C e nomes no Python. </li><li>  Aprenda a emular ponteiros em Python. </li><li> Use <code>ctypes</code> experimentar ponteiros reais. </li></ul><br>  <b>Nota</b> : Aqui, o termo “Python” é aplicado à implementação do Python em C, conhecida como CPython.  Todas as discussões sobre o dispositivo de idioma são válidas para o CPython 3.7, mas podem não corresponder às iterações subsequentes. <br><br><h2>  Por que não existem ponteiros no Python? </h2><br>  Eu não sei  Os ponteiros podem existir nativamente no Python?  Provavelmente, mas aparentemente, os indicadores contradizem o conceito de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Zen de Python</a> , porque provocam mudanças implícitas em vez de explícitas.  Os ponteiros geralmente são bastante complexos, especialmente para iniciantes.  Além disso, eles o levam a tomar decisões malsucedidas ou a fazer algo realmente perigoso, como ler de uma área de memória, onde você não deveria ter lido. <br><br>  O Python tenta abstrair os detalhes da implementação do usuário, como um endereço de memória.  Geralmente, nesse idioma, a ênfase está na usabilidade, não na velocidade.  Portanto, os ponteiros no Python não fazem muito sentido.  Mas não se preocupe, o idioma padrão fornece alguns dos benefícios do uso de ponteiros. <br><br>  Para entender os ponteiros no Python, vamos examinar brevemente os recursos da implementação da linguagem.  Em particular, você precisa entender: <br><br><ol><li>  O que são objetos mutáveis ​​e imutáveis. </li><li>  Como as variáveis ​​/ nomes são organizados em Python. </li></ol><br>  Segure seus endereços de memória, vamos lá! <br><br><h2>  Objetos em Python </h2><br>  Tudo em Python é um objeto.  Por exemplo, abra o REPL e veja como <code>isinstance()</code> : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>isinstance(<span class="hljs-number"><span class="hljs-number">1</span></span>, object) <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> &gt;&gt;&gt; isinstance(list(), object) <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> &gt;&gt;&gt; isinstance(<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, object) <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> &gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> ... &gt;&gt;&gt; isinstance(foo, object) <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  Este código demonstra que tudo no Python é realmente um objeto.  Cada objeto contém pelo menos três tipos de dados: <br><br><ul><li>  Contador de referência. <br></li><li>  Tipo <br></li><li>  Valor. <br></li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Um contador de referência é</a> usado para gerenciar a memória.  Detalhes sobre esse gerenciamento estão escritos em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Gerenciamento de memória em Python</a> .  O tipo é usado no nível CPython para fornecer segurança de tipo durante o tempo de execução.  E value é o valor real associado ao objeto. <br><br>  Mas nem todos os objetos são iguais.  Há uma diferença importante: os objetos são mutáveis ​​e imutáveis.  Entender essa distinção entre tipos de objetos o ajudará a entender melhor a primeira camada da cebola chamada "ponteiros em Python". <br><br><h2>  Objetos mutáveis ​​e imutáveis </h2><br>  Existem dois tipos de objetos no Python: <br><br><ol><li>  Objetos imutáveis ​​(não podem ser alterados); <br></li><li>  Objetos modificáveis ​​(sujeitos a alterações). <br></li></ol><br>  Reconhecer essa diferença é a primeira chave para viajar pelo mundo dos ponteiros em Python.  Aqui está uma caracterização da imutabilidade de alguns tipos populares: <br><br><div class="scrollable-table"><table><tbody><tr><th width="400">  Tipo <br></th><th width="400">  Imutável? <br></th></tr><tr><td>  int <br></td><td>  Sim <br></td></tr><tr><td>  flutuar <br></td><td>  Sim <br></td></tr><tr><td>  bool <br></td><td>  Sim <br></td></tr><tr><td>  complexo <br></td><td>  Sim <br></td></tr><tr><td>  tupla <br></td><td>  Sim <br></td></tr><tr><td>  frozenset <br></td><td>  Sim <br></td></tr><tr><td>  str <br></td><td>  Sim <br></td></tr><tr><td>  lista <br></td><td>  Não <br></td></tr><tr><td>  definir <br></td><td>  Não <br></td></tr><tr><td>  ditar <br></td><td>  Não <br></td></tr></tbody></table></div><br>  Como você pode ver, muitos dos tipos primitivos comumente usados ​​são imutáveis.  Você pode verificar isso escrevendo algum código Python.  Você precisará de duas ferramentas da biblioteca padrão: <br><br><ol><li>  <code>id()</code> retorna o endereço de memória do objeto; <br></li><li>  <code>is</code> retorna <code>True</code> se e somente se dois objetos tiverem o mesmo endereço de memória. <br></li></ol><br>  Você pode executar esse código em um ambiente REPL: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">5</span></span> &gt;&gt;&gt; id(x) <span class="hljs-number"><span class="hljs-number">94529957049376</span></span></code> </pre> <br>  Aqui, definimos a variável <code>x</code> como <code>5</code> .  Se você tentar alterar o valor usando adição, você receberá um novo objeto: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x += <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt;&gt; x <span class="hljs-number"><span class="hljs-number">6</span></span> &gt;&gt;&gt; id(x) <span class="hljs-number"><span class="hljs-number">94529957049408</span></span></code> </pre> <br>  Embora possa parecer que esse código simplesmente mude o valor de <code>x</code> , na realidade você está recebendo um <b>novo</b> objeto como resposta. <br><br>  O tipo <code>str</code> também é imutável: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>s = <span class="hljs-string"><span class="hljs-string">"real_python"</span></span> &gt;&gt;&gt; id(s) <span class="hljs-number"><span class="hljs-number">140637819584048</span></span> &gt;&gt;&gt; s += <span class="hljs-string"><span class="hljs-string">"_rocks"</span></span> &gt;&gt;&gt; s <span class="hljs-string"><span class="hljs-string">'real_python_rocks'</span></span> &gt;&gt;&gt; id(s) <span class="hljs-number"><span class="hljs-number">140637819609424</span></span></code> </pre> <br>  E, neste caso, <code>s</code> após a operação <code>+=</code> obtém um endereço de memória <b>diferente</b> . <br><br>  <b>Bônus</b> : o operador <code>+=</code> traduz em várias chamadas de método. <br><br>  Para alguns objetos, como uma lista, <code>+=</code> converte em <code>__iadd__()</code> (anexo local).  Ele será alterado e retornará o mesmo ID.  No entanto, <code>str</code> e <code>int</code> não possuem esses métodos e, como resultado, <code>__add__()</code> será chamado em vez de <code>__iadd__()</code> . <br><br>  Veja a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documentação do modelo de dados</a> Python <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">para mais detalhes</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">.</a> <br><br>  Quando tentamos alterar diretamente o valor da string de <code>s</code> obtemos um erro: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>s[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-string"><span class="hljs-string">"R"</span></span></code> </pre> <br>  Rastreamento de retorno (as últimas chamadas são exibidas por último): <br><br><pre> <code class="python hljs"> File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;mdule&gt; TypeError: <span class="hljs-string"><span class="hljs-string">'str'</span></span> object does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> support item assignment</code> </pre> <br>  O código acima trava e o Python relata que <code>str</code> não suporta essa alteração, o que corresponde à definição de imutabilidade do tipo <code>str</code> . <br><br>  Compare com um objeto mutável, por exemplo, com uma lista: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>my_list = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] &gt;&gt;&gt; id(my_list) <span class="hljs-number"><span class="hljs-number">140637819575368</span></span> &gt;&gt;&gt; my_list.append(<span class="hljs-number"><span class="hljs-number">4</span></span>) &gt;&gt;&gt; my_list [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>] &gt;&gt;&gt; id(my_list) <span class="hljs-number"><span class="hljs-number">140637819575368</span></span></code> </pre> <br>  Este código demonstra a principal diferença entre os dois tipos de objetos.  Inicialmente, <code>my_list</code> tem um ID.  Mesmo depois de adicionar <code>4</code> à lista, <code>my_list</code> ainda tem <b>o mesmo</b> ID.  O motivo é que a <code>list</code> tipos é mutável. <br><br>  Aqui está outra demonstração da mutabilidade da lista usando a atribuição: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>my_list[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span> &gt;&gt;&gt; my_list [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>] &gt;&gt;&gt; id(my_list) <span class="hljs-number"><span class="hljs-number">140637819575368</span></span></code> </pre> <br>  Nesse código, alteramos <code>my_list</code> e o definimos como <code>0</code> como o primeiro elemento.  No entanto, a lista manteve o mesmo ID após esta operação.  O próximo passo no nosso caminho para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aprender Python</a> será explorar seu ecossistema. <br><br><h2>  Lidamos com variáveis </h2><br>  Variáveis ​​em Python são fundamentalmente diferentes das variáveis ​​em C e C ++.  Essencialmente, eles simplesmente não existem no Python.  <b>Em vez de variáveis, existem nomes</b> . <br><br>  Pode parecer pedante, e na maioria das vezes é.  Na maioria das vezes, você pode tomar nomes em Python como variáveis, mas precisa entender a diferença.  Isso é especialmente importante quando você estuda um tópico tão difícil como ponteiros. <br><br>  Para facilitar a compreensão, vamos ver como as variáveis ​​funcionam em C, o que elas representam e depois comparar com o trabalho dos nomes no Python. <br><br><h3>  Variáveis ​​em C </h3><br>  Pegue o código que define a variável <code>x</code> : <br><br><pre> <code class="python hljs">int x = <span class="hljs-number"><span class="hljs-number">2337</span></span>;</code> </pre> <br>  A execução desta linha curta passa por várias etapas diferentes: <br><br><ol><li>  Alocando memória suficiente para um número. <br></li><li>  Atribuição de <code>2337</code> para este local de memória. <br></li><li>  O mapeamento que <code>x</code> indica esse valor. <br></li></ol><br>  Uma memória simplificada pode ser assim: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f13/e62/d71/f13e62d71774b73aecff45931b6db57f.png"><br><br>  Aqui, a variável <code>x</code> tem um endereço falso de <code>0x7f1</code> e um valor de <code>2337</code> .  Se você desejar alterar posteriormente o valor de <code>x</code> , faça o seguinte: <br><br><pre> <code class="python hljs">x = <span class="hljs-number"><span class="hljs-number">2338</span></span>;</code> </pre> <br>  Este código define a variável <code>x</code> novo valor de <code>2338</code> , substituindo assim o valor <b>anterior</b> .  Isso significa que a variável <code>x</code> <b>mutável</b> .  Esquema de memória atualizado para o novo valor: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/347/491/19b/34749119bcba5c4009861aa4e7c40c45.png"><br><br>  Observe que a localização de <code>x</code> não mudou, apenas o valor em si.  Isso é importante.  Isso nos diz que <code>x</code> é <b>um lugar na memória</b> , e não apenas um nome. <br><br>  Você também pode considerar esse problema como parte do conceito de propriedade.  Por um lado, <code>x</code> possui um lugar na memória.  Primeiro, <code>x</code> é uma caixa vazia que pode conter apenas um número inteiro, na qual valores inteiros podem ser armazenados. <br><br>  Ao atribuir <code>x</code> algum valor, você o coloca em uma caixa que pertence a <code>x</code> .  Se você deseja introduzir uma nova variável <code>y</code> , você pode adicionar esta linha: <br><br><pre> <code class="python hljs">int y = x;</code> </pre> <br>  Esse código cria uma nova caixa chamada <code>y</code> e copia o valor de <code>x</code> para ele.  Agora o circuito de memória fica assim: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/caa/74d/ed3/caa74ded301b1f527e1b94516f1b1196.png"><br><br>  Observe o novo local <code>y</code> - <code>0x7f5</code> .  Embora o valor <code>x</code> sido copiado para <code>x</code> , a variável <code>y</code> possui um novo endereço na memória.  Portanto, você pode substituir o valor de <code>y</code> sem afetar <code>x</code> : <br><br><pre> <code class="python hljs">y = <span class="hljs-number"><span class="hljs-number">2339</span></span>;</code> </pre> <br>  Agora o circuito de memória fica assim: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fcf/f8d/ed4/fcff8ded49647ad0053a45f0773cb4bb.png"><br><br>  Repito: você alterou o valor de <code>y</code> , mas não o local.  Além disso, você não afetou a variável original <code>x</code> . <br><br>  Com nomes em Python, a situação é completamente diferente. <br><br><h3>  Nomes em Python </h3><br>  Não há variáveis ​​no Python, nomes.  Você pode usar o termo "variáveis" a seu critério, no entanto, é importante saber a diferença entre variáveis ​​e nomes. <br><br>  Vamos pegar o código equivalente do exemplo C acima e escrever em Python: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">2337</span></span></code> </pre> <br>  Como em C, o código passa por várias etapas separadas durante a execução disso: <br><br><ol><li>  PyObject é criado. <br></li><li>  O número do PyObject recebe um código de tipo. <br></li><li>  <code>2337</code> atribuído um valor para PyObject. <br></li><li>  O nome <code>x</code> é criado. </li><li>  <code>x</code> aponta para o novo PyObject. </li><li>  A contagem de referência do PyObject é incrementada em 1. <br></li></ol><br>  <b>Nota</b> : <a href="">PyObject</a> não é o mesmo que um objeto em Python, esta entidade é específica para CPython e representa a estrutura básica de todos os objetos Python. <br><br>  PyObject é definido como uma estrutura C, portanto, se você se pergunta por que não pode chamar diretamente o tipo de código ou o contador de referência, o motivo é que você não tem acesso direto às estruturas.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Chamar</a> métodos como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sys.getrefcount ()</a> pode ajudar a obter algum tipo de material interno. <br><br>  Se falamos de memória, pode ser assim: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9d9/ad7/932/9d9ad79327405315461e3880fe3db256.png"><br><br>  Aqui, o circuito de memória é muito diferente do circuito em C mostrado acima.  Em vez de ter <code>x</code> um bloco de memória que armazena o valor <code>2337</code> , um objeto Python recém-criado possui a memória em que <code>2337</code> mora.  O nome do Python <code>x</code> não possui diretamente <b>nenhum</b> endereço na memória, assim como uma variável C possui uma célula estática. <br><br>  Se você deseja atribuir <code>x</code> novo valor, tente este código: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">2338</span></span></code> </pre> <br>  O comportamento do sistema será diferente do que acontece em C, mas não será muito diferente do vínculo original no Python. <br><br>  Neste código: <br><br><ul><li>  Um novo PyObject é criado. <br></li><li>  O número do PyObject recebe um código de tipo. <br></li><li>  <code>2</code> atribuído um valor para PyObject. <br></li><li>  <code>x</code> aponta para o novo PyObject. <br></li><li>  A contagem de referência do novo PyObject é incrementada em 1. <br></li><li>  A contagem de referência do antigo PyObject é reduzida em 1. <br></li></ul><br>  Agora o circuito de memória fica assim: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/712/860/996/712860996aa37da34fdb69a466cdf5de.png"><br><br>  Esta ilustração demonstra que <code>x</code> aponta para uma referência a um objeto e não possui a área de memória como antes.  Você também vê que o comando <code>x = 2338</code> não é uma atribuição, mas uma ligação do nome <code>x</code> ao link. <br><br>  Além disso, o objeto anterior (contendo o valor <code>2337</code> ) agora está na memória com uma contagem de referência de 0 e será removido <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pelo coletor de lixo</a> . <br><br>  Você pode inserir um novo nome <code>y</code> , como no exemplo C: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>y = x</code> </pre> <br>  Um novo nome aparecerá na memória, mas não necessariamente um novo objeto: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/958/adc/410/958adc41013bb5483f0526689a48a871.png"><br><br>  Agora você vê que um novo objeto Python <b>não foi</b> criado, apenas um novo nome <b>foi</b> criado que aponta para o mesmo objeto.  Além disso, o contador de referência do objeto aumentou em 1. Você pode verificar a equivalência da identidade dos objetos para confirmar sua identidade: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>y <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  Este código mostra que <code>y</code> são um objeto.  Mas não se engane: <code>y</code> ainda é imutável.  Por exemplo, você pode executar uma operação de adição com <code>y</code> : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>y += <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt;&gt; y <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br>  Após a adição ser chamada, você retornará um novo objeto Python.  Agora a memória fica assim: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8bd/abc/3e7/8bdabc3e7576ab86b00ba9c2b43b57b4.png"><br><br>  Um novo objeto foi criado e <code>y</code> agora aponta para ele.  É curioso que obteríamos exatamente o mesmo estado final se <code>2339</code> <code>y</code> diretamente a <code>2339</code> : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>y = <span class="hljs-number"><span class="hljs-number">2339</span></span></code> </pre> <br>  Após essa expressão, obtemos um estado final de memória, como na operação de adição.  Deixe-me lembrá-lo de que no Python você não atribui variáveis, mas vincula nomes aos links. <br><br><h3>  Sobre estagiários em Python </h3><br>  Agora você entende como novos objetos são criados no Python e como os nomes são anexados a eles.  É hora de falar sobre objetos internados. <br><br>  Temos este código Python: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">1000</span></span> &gt;&gt;&gt; y = <span class="hljs-number"><span class="hljs-number">1000</span></span> &gt;&gt;&gt; x <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  Como antes, <code>x</code> e <code>y</code> são nomes apontando para o mesmo objeto Python.  Mas esse objeto que contém o valor <code>1000</code> nem sempre pode ter o mesmo endereço de memória.  Por exemplo, se você somar dois números e obter 1000, receberá outro endereço: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">1000</span></span> &gt;&gt;&gt; y = <span class="hljs-number"><span class="hljs-number">499</span></span> + <span class="hljs-number"><span class="hljs-number">501</span></span> &gt;&gt;&gt; x <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br>  Desta vez, a cadeia <code>x is y</code> retorna <code>False</code> .  Se você está envergonhado, não se preocupe.  Aqui está o que acontece quando esse código é executado: <br><br><ol><li>  Um objeto Python é criado ( <code>1000</code> ). <br></li><li>  É dado o nome <code>x</code> . <br></li><li>  Um objeto Python é criado ( <code>499</code> ). <br></li><li>  Um objeto Python é criado ( <code>501</code> ). <br></li><li>  Esses dois objetos se somam. <br></li><li>  Um novo objeto Python é criado ( <code>1000</code> ). <br></li><li>  Ele recebe o nome <code>y</code> . <br></li></ol><br>  <b>Explicações técnicas</b> : As etapas descritas ocorrem apenas quando esse código é executado dentro do REPL.  Se você pegar o exemplo acima, cole-o no arquivo e execute-o, então a linha <code>x is y</code> retornará <code>True</code> . <br><br>  O motivo é o raciocínio rápido do compilador CPython, que tenta executar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">otimizações de olho mágico</a> que ajudam a salvar as etapas de execução de código o máximo possível.  Detalhes podem ser encontrados no <a href="">código-fonte do otimizador de peyphole CPython</a> . <br><br>  Mas isso não é um desperdício?  Bem, sim, mas você paga esse preço por todos os grandes benefícios do Python.  Você não precisa pensar em excluir esses objetos intermediários e nem precisa saber sobre a existência deles!  A piada é que essas operações são executadas relativamente rapidamente e você não saberia sobre elas até aquele momento. <br><br>  Os criadores do Python sabiamente perceberam essa sobrecarga e decidiram fazer várias otimizações.  O resultado é um comportamento que pode surpreender os iniciantes: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">20</span></span> &gt;&gt;&gt; y = <span class="hljs-number"><span class="hljs-number">19</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt;&gt; x <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  Neste exemplo, o código é quase o mesmo que acima, exceto que obtemos <code>True</code> .  É tudo sobre objetos internados.  O Python pré-cria um subconjunto específico de objetos na memória e os armazena no espaço de nomes global para uso diário. <br><br>  Quais objetos dependem da implementação do Python?  No CPython 3.7, os internos são: <br><br><ol><li>  Inteiros que variam de <code>-5</code> a <code>256</code> . <br></li><li>  Sequências contendo apenas letras ASCII, números ou sublinhados. <br></li></ol><br>  Isso ocorre porque essas variáveis ​​são frequentemente usadas em muitos programas.  Internando, o Python impede a alocação de memória para objetos persistentes. <br><br>  Linhas com tamanho inferior a 20 caracteres e contendo letras, números ou sublinhados ASCII serão internadas porque devem ser usadas como identificadores: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>s1 = <span class="hljs-string"><span class="hljs-string">"realpython"</span></span> &gt;&gt;&gt; id(s1) <span class="hljs-number"><span class="hljs-number">140696485006960</span></span> &gt;&gt;&gt; s2 = <span class="hljs-string"><span class="hljs-string">"realpython"</span></span> &gt;&gt;&gt; id(s2) <span class="hljs-number"><span class="hljs-number">140696485006960</span></span> &gt;&gt;&gt; s1 <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> s2 <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  Aqui <code>s1</code> e <code>s2</code> apontam para o mesmo endereço na memória.  Se não inserirmos uma letra, número ou sublinhado ASCII, obteremos um resultado diferente: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>s1 = <span class="hljs-string"><span class="hljs-string">"Real Python!"</span></span> &gt;&gt;&gt; s2 = <span class="hljs-string"><span class="hljs-string">"Real Python!"</span></span> &gt;&gt;&gt; s1 <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> s2 <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br>  Este exemplo usa um ponto de exclamação, portanto, as seqüências de caracteres não são internadas e são objetos diferentes na memória. <br><br>  <b>Bônus</b> : se você deseja que esses objetos se refiram ao mesmo objeto interno, você pode usar <code>sys.intern()</code> .  Uma maneira de usar esse recurso é descrita na documentação: <br><br><blockquote>  A internação de strings é útil para um ligeiro aumento no desempenho da pesquisa no dicionário: se as chaves no dicionário e a chave a serem pesquisadas forem internadas, a comparação de chaves (após o hash) pode ser feita comparando ponteiros em vez de strings.  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fonte</a> ) </blockquote><br>  Os internos frequentemente confundem os programadores.  Lembre-se de que, se você começar a duvidar, sempre poderá usar <code>id()</code> e determinar a equivalência dos objetos. <br><br><h2>  Emulação de ponteiro Python </h2><br>  O fato de os ponteiros estarem ausentes nativamente no Python não significa que você não pode tirar proveito dos ponteiros.  Na verdade, existem várias maneiras de emular ponteiros no Python.  Aqui nós olhamos para dois deles: <br><br><ol><li>  Use como ponteiros para tipos mutáveis. <br></li><li>  Usando objetos Python especialmente preparados. <br></li></ol><br><h3>  Use como ponteiros do tipo mutável </h3><br>  Você já sabe o que são tipos mutáveis.  É graças à sua mutabilidade que podemos imitar o comportamento dos ponteiros.  Digamos que você precise replicar este código: <br><br><pre> <code class="python hljs">void add_one(int *x) { *x += <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  Este código leva um ponteiro para um número ( <code>*x</code> ) e incrementa o valor em 1. Aqui está a função principal para executar o código: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdi.h&gt; int main(void) { int y = 2337; printf("y = %d\n", y); add_one(&amp;y); printf("y = %d\n", y); return 0; }</span></span></code> </pre> <br>  No fragmento acima, atribuímos <code>y</code> a <code>2337</code> , <code>2337</code> o valor atual, aumentamos em 1 e depois exibimos um novo valor.  O seguinte aparece na tela: <br><br><pre> <code class="python hljs">y = <span class="hljs-number"><span class="hljs-number">2337</span></span> y = <span class="hljs-number"><span class="hljs-number">2338</span></span></code> </pre> <br>  Uma maneira de replicar esse comportamento no Python é usar um tipo mutável.  Por exemplo, aplique uma lista e altere o primeiro elemento: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_one</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> ... x[<span class="hljs-number"><span class="hljs-number">0</span></span>] += <span class="hljs-number"><span class="hljs-number">1</span></span> ... &gt;&gt;&gt; y = [<span class="hljs-number"><span class="hljs-number">2337</span></span>] &gt;&gt;&gt; add_one(y) &gt;&gt;&gt; y[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-number"><span class="hljs-number">2338</span></span></code> </pre> <br>  Aqui <code>add_one(x)</code> se refere ao primeiro elemento e aumenta seu valor em 1. O uso da lista significa que, como resultado, obtemos o valor alterado.  Então, existem indicadores em Python?  Não.  O comportamento descrito tornou-se possível porque a lista é do tipo mutável.  Se você tentar usar uma tupla, você receberá um erro: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>z = (<span class="hljs-number"><span class="hljs-number">2337</span></span>,) &gt;&gt;&gt; add_one(z)</code> </pre> <br>  Rastreamento de retorno (as chamadas mais recentes duram por último): <br><br><pre> <code class="python hljs"> File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> add_one TypeError: <span class="hljs-string"><span class="hljs-string">'tuple'</span></span> object does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> support item assignment</code> </pre> <br>  Este código demonstra a imutabilidade da tupla, portanto, não suporta a atribuição de elementos. <br><br>  <code>list</code> não <code>list</code> o único tipo mutável; ponteiros de peças também são emulados usando <code>dict</code> . <br><br>  Suponha que você tenha um aplicativo que rastreie a ocorrência de eventos interessantes.  Isso pode ser feito criando um dicionário e usando um de seus elementos como um contador: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>counters = {<span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>} &gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... counters[<span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>] += <span class="hljs-number"><span class="hljs-number">1</span></span> ... &gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... counters[<span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>] += <span class="hljs-number"><span class="hljs-number">1</span></span> ... bar() ... &gt;&gt;&gt; foo() &gt;&gt;&gt; counters[<span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>] <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  Neste exemplo, o dicionário usa contadores para rastrear o número de chamadas de função.  Após chamar <code>foo()</code> contador aumentou 2, conforme o esperado.  E tudo graças à <code>dict</code> . <br><br>  Não se esqueça, isso é apenas uma <b>emulação</b> do comportamento do ponteiro, não tem nada a ver com ponteiros reais em C e C ++.  Podemos dizer que essas operações são mais caras do que se fossem executadas em C ou C ++. <br><br><h3>  Usando objetos Python </h3><br>  <code>dict</code> é uma ótima maneira de emular ponteiros em Python, mas às vezes é entediante lembrar qual nome de chave você usou.  Especialmente se você usar o dicionário em diferentes partes do aplicativo.  Uma classe Python personalizada pode ajudar aqui. <br><br>  Digamos que você precise acompanhar as métricas em um aplicativo.  Uma ótima maneira de ignorar detalhes irritantes é criar uma classe: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Metrics</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self._metrics = { <span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"cat_pictures_served"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, }</code> </pre> <br>  Este código define a classe <code>Metrics</code> .  Ele ainda usa o dicionário para armazenar dados atualizados que estão na <code>_metrics</code> membro <code>_metrics</code> .  Isso lhe dará a mutabilidade necessária.  Agora você só precisa acessar esses valores.  Você pode fazer isso usando as propriedades: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Metrics</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... @property def func_calls(self): return self._metrics["func_calls"] @property def cat_pictures_served(self): return self._metrics["cat_pictures_served"]</span></span></code> </pre> <br>  Aqui usamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">@property</a> .  Se você é iniciante em decoradores, leia o artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Primer on Python Decorators</a> .  Nesse caso, o decorador <code>@property</code> permite acessar <code>func_calls</code> e <code>cat_pictures_served</code> , como se fossem atributos: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>metrics = Metrics() &gt;&gt;&gt; metrics.func_calls <span class="hljs-number"><span class="hljs-number">0</span></span> &gt;&gt;&gt; metrics.cat_pictures_served <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  O fato de você poder se referir a esses nomes como atributos significa que você é abstraído do fato de que esses valores são armazenados no dicionário.  Além disso, você torna os nomes dos atributos mais explícitos.  Obviamente, você deve poder aumentar os valores: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Metrics</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def inc_func_calls(self): self._metrics["func_calls"] += 1 def inc_cat_pics(self): self._metrics["cat_pictures_served"] += 1</span></span></code> </pre> <br>     : <br><br><ol><li> <code>inc_func_calls()</code> </li> <li> <code>inc_cat_pics()</code> </li> </ol><br>      <code>metrics</code> .     ,     ,   : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>metrics = Metrics() &gt;&gt;&gt; metrics.inc_func_calls() &gt;&gt;&gt; metrics.inc_func_calls() &gt;&gt;&gt; metrics.func_calls <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>     <code>func_calls</code>   <code>inc_func_calls()</code>         Python.    ,     -  <code>metrics</code> ,          . <br><br> <b></b> :   ,   <code>inc_func_calls()</code>  <code>inc_cat_pics()</code>   <code>@property.setter</code>        <code>int</code> ,     . <br><br>      <code>Metrics</code> : <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Metrics</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self._metrics = { <span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"cat_pictures_served"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, } @property <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func_calls</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._metrics[<span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>] @property <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cat_pictures_served</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._metrics[<span class="hljs-string"><span class="hljs-string">"cat_pictures_served"</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inc_func_calls</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self._metrics[<span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>] += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inc_cat_pics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self._metrics[<span class="hljs-string"><span class="hljs-string">"cat_pictures_served"</span></span>] += <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><h2>     ctypes </h2><br>  , -    Python,   CPython?     ctypes    ,   C.      ctypes,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Extending Python With C Libraries and the «ctypes» Module</a> . <br><br>       ,     ,   .     - <code>add_one()</code> : <br><br><pre> <code class="python hljs">void add_one(int *x) { *x += <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br> ,      <code>x</code>  1.   ,      (shared) .  ,      <code>add.c</code> ,      gcc: <br><br><pre> <code class="python hljs">$ gcc -c -Wall -Werror -fpic add.c $ gcc -shared -o libadd1.so add.o</code> </pre> <br>      C   <code>add.o</code> .           <code>libadd1.so</code> . <br><br> <code>libadd1.so</code>      .    ctypes    Python: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ctypes &gt;&gt;&gt; add_lib = ctypes.CDLL(<span class="hljs-string"><span class="hljs-string">"./libadd1.so"</span></span>) &gt;&gt;&gt; add_lib.add_one &lt;_FuncPtr object at <span class="hljs-number"><span class="hljs-number">0x7f9f3b8852a0</span></span>&gt;</code> </pre> <br>  ctypes.CDLL  ,     <code>libadd1</code> .      <code>add_one()</code> ,      ,        Python-.     ,    .  Python  ,      . <br><br>         , ctypes       : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>add_one = add_lib.add_one &gt;&gt;&gt; add_one.argtypes = [ctypes.POINTER(ctypes.c_int)]</code> </pre> <br>     ,    C. ,        ,       : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>add_one(<span class="hljs-number"><span class="hljs-number">1</span></span>) Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; ctypes.ArgumentError: argument <span class="hljs-number"><span class="hljs-number">1</span></span>: &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> '</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeError</span></span></span><span class="hljs-class">'&gt;:</span></span> \ expected LP_c_int instance instead of int</code> </pre> <br> Python    ,  <code>add_one()</code>   ,     .  ,  ctypes      .       : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = ctypes.c_int() &gt;&gt;&gt; x c_int(<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>      <code>x</code>   <code>0</code> . ctypes    <code>byref()</code> ,      . <br><br> <b></b> :  <b> </b>     <b> </b> . <br><br>          ,       .         ,        . <br><br>   <code>add_one()</code>    : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>add_one(ctypes.byref(x)) <span class="hljs-number"><span class="hljs-number">998793640</span></span> &gt;&gt;&gt; x c_int(<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Ótimo!     1. ,     Python  . <br><br><h2>  Conclusão </h2><br>        Python  .          ,              Python. <br><br>         Python: <br><br><ul><li>          . <br></li><li>   Python-   . <br></li><li>       ctypes. <br></li></ul><br>       Python       . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt454324/">https://habr.com/ru/post/pt454324/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt454314/index.html">10 princípios da programação orientada a objetos que todo desenvolvedor deve conhecer</a></li>
<li><a href="../pt454316/index.html">Seguindo os passos do ninja industrial: convidamos você a participar da competição on-line de segurança industrial</a></li>
<li><a href="../pt454318/index.html">Soando o passado. Um guia para historiadores sobre a conversão de dados em som</a></li>
<li><a href="../pt454320/index.html">Analistas do mercado de trabalho e cientistas de dados</a></li>
<li><a href="../pt454322/index.html">Alguns dizem que a tecnologia DANE para navegadores falhou</a></li>
<li><a href="../pt454326/index.html">Além de Moore - quem mais formulou as leis de dimensionamento de sistemas de computador</a></li>
<li><a href="../pt454330/index.html">10 destaques do TechTrain 2018: IA para massas, interfaces e muito mais</a></li>
<li><a href="../pt454332/index.html">Como o bot do Telegram superou a procrastinação de designers e ajudou a aumentar a receita das agências digitais</a></li>
<li><a href="../pt454334/index.html">Moto. Weep AWS</a></li>
<li><a href="../pt454336/index.html">Cliente: - Quanto custa uma cópia do Facebook?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>