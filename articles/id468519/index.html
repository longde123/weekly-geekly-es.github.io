<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ˜¸ ğŸ‡ğŸ» ğŸ¤›ğŸ¼ Buat basis kode umum ğŸ“ ğŸ•´ğŸ½ ğŸ‘©ğŸ¾â€ğŸ¤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dari proyek ke proyek, kami melihat bahwa kode kami melakukan fungsi yang sama dan terlihat hampir sama. Ini membuat kita bertanya-tanya - apakah kita...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buat basis kode umum</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468519/"><p><img src="https://habrastorage.org/webt/gl/ke/kt/glkektigl8ivpcm26wxxg-ij9t8.jpeg"></p><br><p> Dari proyek ke proyek, kami melihat bahwa kode kami melakukan fungsi yang sama dan terlihat hampir sama.  Ini membuat kita bertanya-tanya - apakah kita tidak melakukan pekerjaan ekstra dengan menulis ulang hal yang sama?  Kami mulai menyalin kelas dari proyek sebelumnya dan masih memahami bahwa kami melakukan sesuatu yang salah dan benar - hanya menyalin kelas dari suatu proyek ke proyek, kami dapat dengan mudah kehilangan / ganti / hapus sesuatu, dan jika tim kami memimpin beberapa lagi proyek secara bersamaan, maka deteksi kesalahan di kelas yang dipinjam akan membutuhkan perubahan manual di semua proyek.  Bosan menginjak rake ini, kami memutuskan bahwa kami membutuhkan kode umum yang akan dibagikan pada semua proyek kami dan setiap perubahan di dalamnya akan mudah ditarik.  Ya, kami sedang membuat perpustakaan kami dari komponen yang dapat digunakan kembali!  Anda akan belajar tentang berbagai cara untuk mengatur perpustakaan Anda, tentang semua pro dan kontra dari pendekatan di bawah cat :) </p><a name="habracut"></a><br><p>  Ada beberapa cara untuk mengatur basis kode umum kami: </p><br><ol><li>  Perpustakaan Android (aar / jar) </li><li>  Git submodule </li><li>  Git subtree </li></ol><br><h1 id="android-biblioteka-aarjar">  Perpustakaan Android (aar / jar) </h1><br><p>  Pustaka apa pun untuk aplikasi kita hanyalah banyak kelas yang diatur dengan cara tertentu.  Setiap kali kami menghubungkan beberapa Retrofit atau Belati di <strong>build.gradle</strong> , kami memuat perpustakaan sebagai arsip aar / jar dari salah satu platform penerbitan perpustakaan.  Platform penerbitan perpustakaan paling populer adalah JCenter dan MavenCentral.  Para pengembang perpustakaan bekerja di repositori mereka di versi baru, dan ketika versi menjadi siap untuk keluar ke dunia, mereka menerbitkannya di salah satu platform dan berkata "Hei, kami merilis versi baru dari perpustakaan teratas kami!".  Semua yang masih harus dilakukan untuk pengembang yang menggunakan lib ini dalam proyek mereka adalah mengubah versi di build.gradle dan menikmati fitur-fitur baru.  Apakah itu nyaman?  Kata yang salah! </p><br><p>  Tetapi seberapa mudah pendekatan ini jika perpustakaan kami berkembang dan setiap hari diperbarui dengan fitur-fitur baru oleh pengembang yang berbeda dari berbagai proyek tim kami?  Mari kita lihat tampilannya dalam praktik. </p><br><p><img src="https://habrastorage.org/webt/b_/ut/v_/b_utv_ozbackygrup1v9kc-d850.jpeg"></p><br><p>  Kami membuat repositori perpustakaan kami, berkontribusi beberapa fitur di sana, men-debug-nya, dan siap untuk membaginya dengan tim kami.  Kemudian kita akan belajar tentang kata-kata seperti JCenter, MavenCentral, Bintray, Jitpack.io ... semua ini adalah platform untuk penerbitan perpustakaan.  Sekarang platform utama untuk proyek Android adalah JCenter.  Jika Anda membuat proyek, Anda akan melihat bahwa di <strong>build.gradle</strong> (level proyek) di repositori, JCenter ditentukan </p><br><pre><code class="plaintext hljs">repositories { google() jcenter() }</code> </pre> <br><p>  Artinya, jika pengembang ingin menghubungkan perpustakaan Anda, maka itu sudah cukup baginya untuk menghubungkannya ke tingkat modul <strong>build.gradle</strong> . </p><br><p>  <em>Cara termudah untuk menerbitkan perpustakaan bagi saya tampaknya adalah Jitpack.io, beberapa langkah dan perpustakaan Anda siap digunakan.</em> </p><br><h3 id="kak-organizovat-komandnuyu-rabotu-nad-bibliotekoy">  Bagaimana mengatur kerja tim di perpustakaan </h3><br><p>  Jika kami membuat perpustakaan dan mengunggahnya ke repositori, maka sisa tim kami hanya memiliki arsip jar / aar yang diterima.  Agar seluruh tim dapat mengerjakan apa saja - setiap pengembang harus mengempiskan repositori perpustakaan dan membuat perubahan padanya. </p><br><h3 id="versionirovanie">  Versi </h3><br><p>  Ketika mengembangkan dan menggunakan perpustakaan, kita harus berurusan dengan konsep seperti versi.  Yaitu, set perubahan di perpustakaan yang ingin kami terbitkan harus diperbaiki oleh versi.  Ini akan membantu ketika memperbarui perpustakaan ke versi baru untuk memahami seberapa serius / memecah perubahan telah dibuat, berkat skema versi yang diadopsi. </p><br><h3 id="proverka-biblioteki-v-proekte">  Memeriksa perpustakaan di proyek </h3><br><p>  Untuk memverifikasi bahwa perubahan yang dilakukan melakukan apa yang kita maksudkan - perlu untuk memeriksa perilaku kode tertulis dalam proyek.  Kami meningkatkan versi perpustakaan dan ... di sini adalah salah satu hambatan dari pendekatan ini.  Perpustakaan kami dan proyek berada dalam repositori yang berbeda, yang berarti bahwa kami tidak bisa hanya mendapatkan kelas perpustakaan di proyek.  Kami memiliki 2 opsi untuk memeriksa kode perpustakaan baru: </p><br><ol><li>  Buat modul dalam proyek perpustakaan <strong>sampel</strong> di mana kode akan ditulis yang memeriksa fungsionalitas perpustakaan.  Opsi ini sederhana, tetapi ada 2 minus: 1. Kami menulis kode tambahan;  2. Lingkungan modul tes berbeda dari proyek nyata di mana kita akan menggunakan perpustakaan, dan jika kita membuat kesalahan, itu akan muncul ketika kita mendapatkan versi baru dari proyek. </li><li>  <strong>Posting</strong> perubahan ke repositori <strong>mavenLocal</strong> lokal.  Berkat pendekatan ini, Anda bisa mendapatkan kode baru di proyek, tetapi tidak akan dipublikasikan untuk seluruh tim (tetapi Anda perlu sedikit mengotak-atik pengaturannya). </li></ol><br><h1 id="git-submodule">  Git submodule </h1><br><p>  Dalam pendekatan sebelumnya, kami menghadapi kesulitan mendapatkan kode baru pada tahap pengembangan / debugging dalam proyek, karena perpustakaan dan kode proyek berada di berbagai repositori dan proyek studio.  Pendekatan Submodule Git juga melibatkan penggunaan repositori yang terpisah, tetapi memungkinkan proyek utama untuk mendapatkan perpustakaan sebagai modul menggunakan Git.  Ini berarti bahwa kode perpustakaan akan tersedia di proyek dan semua perubahan segera tersedia di proyek! </p><br><h3 id="kak-eto-rabotaet">  Bagaimana cara kerjanya </h3><br><p>  Submodules memungkinkan Anda mengandung satu repositori Git sebagai subdirektori dari repositori Git lainnya.  Ini memungkinkan untuk mengkloning repositori lain di dalam proyek, menyimpan komit untuk repositori ini secara terpisah. </p><br><p><img src="https://habrastorage.org/webt/p4/z-/wh/p4z-whwzw3abnkil06dvmt0uo0w.jpeg"></p><br><p>  Sederhananya, kami memiliki 2 repositori: proyek dan perpustakaan.  Repositori proyek menyimpan kode perpustakaan dan tautan ke status repositori perpustakaan.  Jadi Git mengerti kondisi apa (versi) dari perpustakaan yang dibutuhkan proyek. </p><br><p>  <em>Baca lebih lanjut tentang cara kerja Submodule Git di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini.</a></em> </p><br><h3 id="kak-organizovat-komandnuyu-rabotu">  Bagaimana mengatur kerja tim </h3><br><p>  Dalam pendekatan Submodule Git, kerja tim di perpustakaan diatur sebagai berikut: </p><br><ol><li>  Saat membuat proyek baru atau menghubungkan perpustakaan ke proyek yang ada, cabang Git baru dari master dibuat dengan nama proyek. </li><li>  Ketika tiba saatnya untuk mengisi kembali perpustakaan dengan beberapa fungsi, cabang untuk tugas (dari cabang proyek) dibuat dan perubahan dibuat di sana. </li><li>  Sebuah tinjauan sedang dilakukan, kolam sedang dituangkan ke cabang proyek.  Ketika perubahan yang cukup diketik untuk merilis versi, kumpulan dibuat pada gabungan cabang proyek di cabang utama perpustakaan. </li><li>  Setelah kumpulan melewati ulasan oleh tim yang bertanggung jawab untuk perpustakaan dan dituangkan ke dalam cabang utama, tim proyek yang tersisa akan diberitahu tentang pembaruan perpustakaan yang telah muncul dan akan memutuskan pembaruan. </li></ol><br><h3 id="versionirovanie-1">  Versi </h3><br><p>  Ketika kumpulan dicurahkan ke <strong>master</strong> , dan tim diberitahu tentang pembaruan perpustakaan, mereka tidak menyadari seberapa global perubahan dalam versi baru.  Bagaimanapun, pendekatan dengan Git Submodule tidak memerlukan skema versi apa pun.  Tetapi masalah ini mudah diselesaikan dengan memperkenalkan skema versi.  Yang diperlukan hanyalah menulis versi dan deskripsi tentang apa yang telah diubah dan ditambahkan ke deskripsi permintaan kumpulan di cabang <strong>master</strong> .  Kemudian para pengembang akan mengerti berapa banyak mereka sekarang benar-benar dapat memutakhirkan ke versi baru perpustakaan.  Kedengarannya hebat, tetapi pertanyaannya adalah: </p><br><p><img src="https://habrastorage.org/webt/6o/jx/cv/6ojxcvyb5oyqfevbzbxqojxfori.jpeg"></p><br><p>  Ya, studio tidak tahu bagaimana melakukan secara terpisah ke lib yang terhubung oleh submodule.  Saya menggunakan SourceTree untuk menyelesaikan masalah ini.  Aplikasi ini untuk Windows dan Mac, dan untuk Linux ada GitKraken. </p><br><h1 id="git-subtree">  Git subtree </h1><br><p>  Git Subtree adalah versi yang disempurnakan dari Git Submodule.  Di Git Subtree mereka mencoba untuk memecahkan masalah yang dihadapi pengembang saat bekerja dengan Git Submodule, ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> bagus tentang hub yang menjelaskan perbedaan antara alat.  Meskipun mereka bekerja secara berbeda, mereka memecahkan satu masalah. </p><br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><p>  Alat Git Submodule / Subtree sangat bagus untuk memecahkan masalah menciptakan basis kode umum untuk tim yang terlibat dalam beberapa proyek.  Salah satu keuntungan penting adalah verifikasi instan kode baru pada proyek setelah melakukan perubahan pada perpustakaan.  Dalam hal ini, pendekatan standar penerbitan perpustakaan ke JCenter atau MavenCentral lebih rendah.  Jika Anda memutuskan untuk membawa Submodule / Subtree Git ke tim Anda, pikirkan terlebih dahulu tentang skema versi, dan buat aturan / plugin untuk mengontrol versi. </p><br><p>  Penggunaan kembali yang bagus untuk semua orang! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id468519/">https://habr.com/ru/post/id468519/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id468503/index.html">Mail tidak melangkah lebih jauh 500 mil - FAQ</a></li>
<li><a href="../id468509/index.html">Pengembangan OS seperti Unix - Driver perangkat karakter (8)</a></li>
<li><a href="../id468511/index.html">Menerbitkan server melalui gateway D-Link DFL</a></li>
<li><a href="../id468515/index.html">Kiat berguna untuk integrasi ke dalam proyek baru</a></li>
<li><a href="../id468517/index.html">2. Gambaran Umum tentang Jaringan Ekstrim Beralih Dukungan Teknis dan Garansi</a></li>
<li><a href="../id468521/index.html">Bagaimana kami menggeneralisasi keamanan informasi</a></li>
<li><a href="../id468523/index.html">Dari roket ke robot dan apa hubungannya dengan Python. Kisah Alumni GeekBrains</a></li>
<li><a href="../id468525/index.html">Mainan kayu, bagian satu - 1982-1985</a></li>
<li><a href="../id468527/index.html">Sintesis pengontrol dengan metode masalah dinamika terbalik</a></li>
<li><a href="../id468529/index.html">Menjinakkan Gorynych, atau Mengompilasi eBPF di Ghidra</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>