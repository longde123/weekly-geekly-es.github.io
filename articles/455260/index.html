<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê™ ‚ôªÔ∏è üíÜüèº Merkle Tree: oxidado y r√°pido üïù üòã üåå</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos! Recientemente descubr√≠ el lenguaje Rust. Comparti√≥ sus primeras impresiones en un art√≠culo anterior . Ahora decid√≠ profundizar un poco m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Merkle Tree: oxidado y r√°pido</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455260/"><p><img src="https://habrastorage.org/webt/02/we/l8/02wel89vk_uuxibqbvaiimofkkk.png" alt="imagen"></p><br><p>  Hola a todos!  Recientemente descubr√≠ el lenguaje Rust.  Comparti√≥ sus primeras impresiones en un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo anterior</a> .  Ahora decid√≠ profundizar un poco m√°s, para esto necesitas algo m√°s serio que la lista.  Mi elecci√≥n recay√≥ en el √°rbol Merkle.  En este art√≠culo quiero: </p><br><ul><li>  hablar sobre esta estructura de datos </li><li>  mira lo que Rust ya tiene </li><li>  ofrece tu implementaci√≥n </li><li>  comparar rendimiento </li></ul><a name="habracut"></a><br><h1 id="derevo-merkla">  √Årbol de merkle </h1><br><p> Esta es una estructura de datos relativamente simple, y ya hay mucha informaci√≥n al respecto en Internet, pero creo que mi art√≠culo estar√° incompleto sin una descripci√≥n del √°rbol. </p><br><h2 id="v-chyom-problema">  Cual es el problema </h2><br><p>  El √°rbol Merkle se invent√≥ en 1979, pero gan√≥ popularidad gracias a la cadena de bloques.  La cadena de bloques en la red es muy grande (para bitcoin es m√°s de 200 GB), y no todos los nodos pueden bombearla.  Por ejemplo, tel√©fonos o cajas registradoras.  Sin embargo, necesitan saber sobre el hecho de incluir esta o aquella transacci√≥n en el bloque.  Para esto, se invent√≥ el protocolo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SPV - Verificaci√≥n de pago simplificada</a> . </p><br><h2 id="kak-ustroeno-derevo">  ¬øC√≥mo funciona un √°rbol? </h2><br><p>  Este es un √°rbol binario cuyas hojas son hashes de cualquier objeto.  Para construir el siguiente nivel, los hash de las hojas vecinas se toman en pares, se concatenan y se calcula el hash del resultado de la concatenaci√≥n, que se ilustra en la imagen del encabezado.  Por lo tanto, la ra√≠z del √°rbol es un hash de todas las hojas.  Si elimina o agrega un elemento, la ra√≠z cambiar√°. </p><br><h2 id="kak-rabotaet-derevo">  ¬øC√≥mo funciona un √°rbol? </h2><br><p>  Al tener un √°rbol Merkle, puede generar evidencia de la inclusi√≥n de una transacci√≥n en un bloque como una ruta desde un hash de transacci√≥n a la ra√≠z.  Por ejemplo, estamos interesados ‚Äã‚Äãen la transacci√≥n Tx2, para ello la prueba ser√° (Hash3, Hash01).  Este mecanismo tambi√©n se usa en SPV.  El cliente solo descarga el encabezado del bloque con su hash.  Al tener una transacci√≥n de inter√©s, solicita pruebas de un nodo que contiene toda la cadena.  Luego realiza una comprobaci√≥n, para Tx2 ser√°: </p><br><pre><code class="plaintext hljs">hash(Hash01, hash(Hash2, Hash3)) = Root Hash</code> </pre> <br><p>  El resultado se compara con la ra√≠z del encabezado del bloque.  Este enfoque hace que sea imposible falsificar evidencia, porque en este caso el resultado de la prueba no converge con el contenido del encabezado. </p><br><h1 id="kakie-uzhe-est-realizacii">  Qu√© implementaciones ya existen </h1><br><p>  Rust es un lenguaje joven, pero muchas realizaciones del √°rbol Merkle ya est√°n escritas en √©l.  A juzgar por Github, en este momento 56, esto es m√°s que en C y C ++ combinados.  Aunque Go los pone de pie con 80 implementaciones. </p><br><h2 id="spinresearchmerklershttpsgithubcomspinresearchmerklers">  <a href="">SpinResearch / merkle.rs</a> </h2><br><p>  Para mi comparaci√≥n, eleg√≠ esta implementaci√≥n por el n√∫mero de estrellas en el repositorio. </p><br><p>  Este √°rbol est√° construido de la manera m√°s obvia, es decir, es un gr√°fico de objetos.  Como ya se√±al√©, este enfoque no es completamente amigable con Rust.  Por ejemplo, no es posible hacer una comunicaci√≥n bidireccional de ni√±os a padres. </p><br><p>  La construcci√≥n de evidencia ocurre a trav√©s de una b√∫squeda en profundidad.  Si se encuentra una hoja con el hash correcto, entonces el camino ser√° el resultado. </p><br><h2 id="chto-mozhno-uluchshit">  ¬øQu√© se puede mejorar? </h2><br><p>  No fue interesante para m√≠ hacer una implementaci√≥n simple (n + 1), as√≠ que pens√© en la optimizaci√≥n.  El c√≥digo para mi <em>vector-merkle-tree</em> est√° en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Github</a> . </p><br><h3 id="hranenie-dannyh">  Almacenamiento de datos </h3><br><p>  Lo primero que viene a la mente es cambiar el √°rbol a una matriz.  Esta soluci√≥n ser√° mucho mejor en t√©rminos de localidad de datos: m√°s aciertos de cach√© y mejor precarga.  Caminar alrededor de objetos dispersos de la memoria lleva m√°s tiempo.  Un hecho conveniente es que todos los hashes tienen la misma longitud, porque  calculado por un algoritmo  El √°rbol de Merkle en la matriz se ver√° as√≠: <br><img src="https://habrastorage.org/webt/7_/in/4_/7_in4_ijawhhqj4f9pldunhl2mu.png" alt="imagen"></p><br><h3 id="dokazatelstvo">  Prueba </h3><br><p>  Cuando inicializa el √°rbol, puede crear un HashMap con todos los √≠ndices de hoja.  Por lo tanto, cuando no hay hoja, no es necesario rodear todo el √°rbol, y si la hay, puede ir inmediatamente hacia ella y elevarse hasta la ra√≠z, construyendo una prueba.  En mi implementaci√≥n, hice HashMap opcional. </p><br><h3 id="konkatenaciya-i-heshirovanie">  Concatenaci√≥n y Hash </h3><br><p>  Parece que aqu√≠ se puede mejorar?  Despu√©s de todo, todo est√° claro: toma dos hashes, p√©galos y calcula un nuevo hash.  Pero el hecho es que esta funci√≥n no es conmutativa, es decir  hash (H0, H1) ‚â† hash (H1, H0).  Debido a esto, al construir la prueba, debe recordar de qu√© lado est√° el nodo vecino.  Esto hace que el algoritmo sea m√°s dif√≠cil de implementar y agrega la necesidad de almacenar datos redundantes.  Todo es muy f√°cil de arreglar, solo ordena los dos nodos antes del hash.  Por ejemplo, cit√© Tx2, teniendo en cuenta la conmutatividad, la verificaci√≥n se ver√° as√≠: </p><br><pre> <code class="plaintext hljs">hash(hash(Hash2, Hash3), Hash01) = Root Hash</code> </pre> <br><p>  Cuando no tiene que preocuparse por el orden, el algoritmo de verificaci√≥n parece una simple convoluci√≥n de una matriz: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, proof: &amp;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;&amp;[<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>]&gt;) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { proof[<span class="hljs-number"><span class="hljs-number">2</span></span>..].iter() .fold( get_pair_hash(proof[<span class="hljs-number"><span class="hljs-number">0</span></span>], proof[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.algo), |a, b| get_pair_hash(a.as_ref(), b, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.algo) ).as_ref() == <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.get_root() }</code> </pre> <br><p>  El elemento cero es el hash del objeto deseado, el primero es su vecino. </p><br><h1 id="pognali">  Vamos! </h1><br><p>  La historia estar√≠a incompleta sin una comparaci√≥n de rendimiento, lo que me llev√≥ varias veces m√°s que la implementaci√≥n del √°rbol en s√≠.  Para estos fines, utilic√© el marco de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">criterios</a> .  Las fuentes de las pruebas en s√≠ est√°n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> .  Todas las pruebas se realizan a trav√©s de la interfaz <em>TreeWrapper</em> , que se implement√≥ para ambos temas: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TreeWrapper</span></span></span></span>&lt;V&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, c: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Criterion, counts: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;, data: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;V&gt;&gt;, title: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, c: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Criterion, counts: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;, data: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;V&gt;&gt;, title: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, c: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Criterion, counts: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;, data: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;V&gt;&gt;, title: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>); }</code> </pre> <br><p>  Ambos √°rboles funcionan con la misma criptograf√≠a en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>anillo</em></a> .  Aqu√≠ no voy a comparar diferentes bibliotecas.  Tom√© lo m√°s com√∫n. </p><br><p>  Como objetos hash, se utilizan cadenas generadas aleatoriamente.  Los √°rboles se comparan en matrices de varias longitudes: (500, 1000, 1500, 2000, 2500 3000).  2500 - 3000 es el n√∫mero aproximado de transacciones en el bloque bitcoin en este momento. </p><br><p>  En todos los gr√°ficos, el eje X indica el n√∫mero de elementos de la matriz (o el n√∫mero de transacciones en el bloque), y el eje Y representa el tiempo promedio para completar la operaci√≥n en microsegundos.  Es decir, cuanto m√°s peor. </p><br><h2 id="sozdanie-dereva">  Fabricaci√≥n de √°rboles </h2><br><p>  El almacenamiento de todos los datos del √°rbol en una matriz excede en gran medida el gr√°fico de rendimiento de los objetos.  Para una matriz con 500 elementos, 1.5 veces, y para 3000 elementos ya 3.6 veces.  La naturaleza no lineal de la dependencia de la complejidad del volumen de datos de entrada en la implementaci√≥n est√°ndar es claramente visible. </p><br><p>  Adem√°s, en comparaci√≥n, agregu√© dos variantes del √°rbol de vectores: con y sin <em>HashMap</em> .  Llenar una estructura de datos adicional agrega aproximadamente el 20%, pero le permite buscar objetos mucho m√°s r√°pido al generar evidencia. <br><img src="https://habrastorage.org/webt/xk/nf/kj/xknfkjl5aqy8oqagfzaj05p1qo4.png" alt="imagen"></p><br><h2 id="postroenie-dokazatelstva">  Construyendo evidencia </h2><br><p>  Aqu√≠ puede ver la ineficiencia evidente de la b√∫squeda en profundidad.  Con un aumento en la entrada, solo empeora.  Es importante comprender que los objetos que est√° buscando son hojas, por lo que no puede haber complejidad de <em>log (n)</em> .  Si los datos se procesan previamente, el tiempo de operaci√≥n es pr√°cticamente independiente del n√∫mero de elementos.  Sin hashing, la complejidad crece linealmente y consiste en la b√∫squeda de fuerza bruta. <br><img src="https://habrastorage.org/webt/py/lc/20/pylc206tjr1oraib8eynbeeatym.png" alt="imagen"></p><br><h2 id="validaciya-dokazatelstva">  Validaci√≥n de evidencia </h2><br><p>  Esta es la √∫ltima operaci√≥n.  No depende de la estructura del √°rbol, porque  trabaja con el resultado de construir evidencia.  Creo que la principal dificultad aqu√≠ es el c√°lculo hash. <br><img src="https://habrastorage.org/webt/2h/n6/hk/2hn6hkfzrbhxnejuihg2xx2hpoc.png" alt="imagen"></p><br><h1 id="itog">  Resumen </h1><br><ul><li>  La forma en que se almacenan los datos afecta en gran medida el rendimiento.  Cuando todo en una matriz es mucho m√°s r√°pido.  Y serializar tal estructura ser√° muy simple.  La cantidad total de c√≥digo tambi√©n se reduce. </li><li>  La concatenaci√≥n de nodos con ordenaci√≥n simplifica enormemente el c√≥digo, pero no lo hace m√°s r√°pido. </li></ul><br><h1 id="nemnogo-o-rust">  Un poco sobre el √≥xido </h1><br><ul><li>  Me gust√≥ el marco de <em>criterios</em> .  Da resultados claros con valores promedio y desviaciones equipadas con gr√°ficos.  Capaz de comparar diferentes implementaciones del mismo c√≥digo. </li><li>  La falta de herencia no interfiere en gran medida con la vida. </li><li>  Las macros son un mecanismo poderoso.  Los us√© en <a href="">mis pruebas de √°rbol</a> para la parametrizaci√≥n.  Creo que si se usan mal, puede hacer tal cosa que usted mismo no ser√° feliz m√°s tarde. </li><li>  En algunos lugares, el compilador aburrido con sus comprobaciones de memoria.  Mi suposici√≥n inicial de que comenzar a escribir en Rust tan simplemente no funcion√≥ fue correcta. <br><img src="https://habrastorage.org/webt/1n/uw/mf/1nuwmfwfozbeosqyvhtmbybur7w.png" alt="imagen"></li></ul><br><h1 id="ssylki">  Referencias </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Una descripci√≥n m√°s completa del algoritmo del √°rbol de Merkle.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">criterio - marco de prueba de carga</a> </li><li>  <a href="">merkle.rs - el √°rbol m√°s popular bajo Rust</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">vector-merkle-tree - implementaci√≥n de mi √°rbol</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">merkle-tree-test-rs: un proyecto para comparar el rendimiento de dos bibliotecas</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/455260/">https://habr.com/ru/post/455260/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../455246/index.html">La inscripci√≥n para el D√≠a de la Experiencia del Cliente en San Petersburgo est√° abierta el 20 de junio.</a></li>
<li><a href="../455248/index.html">Principales errores de desarrollo al trabajar con PostgreSQL</a></li>
<li><a href="../455250/index.html">El que resucit√≥ a Duke Nukem: entrevista con Randy Pitchford, mago de Gearbox</a></li>
<li><a href="../455252/index.html">.NET: Herramientas para trabajar con subprocesos m√∫ltiples y asincron√≠a - Parte 1</a></li>
<li><a href="../455258/index.html">Comenz√≥ la votaci√≥n de los informes de la secci√≥n Backend en el aniversario DevConfX, que se realizar√° del 21 al 22 de junio en Mosc√∫</a></li>
<li><a href="../455264/index.html">S√© como Munch, o unas palabras sobre el deber t√©cnico</a></li>
<li><a href="../455268/index.html">C√≥mo comenz√≥ todo: pantallas flexibles y plegables: la historia de la aparici√≥n y salida de "personas"</a></li>
<li><a href="../455272/index.html">TheOutloud - Expresa y comparte tus art√≠culos e historias favoritas.</a></li>
<li><a href="../455274/index.html">Microsoft lanza una iniciativa educativa a gran escala en universidades rusas</a></li>
<li><a href="../455276/index.html">Juegos en la nube: el servicio Google Stadia anuncia precios para los usuarios</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>