<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍧 🤲🏻 🧜 ini dan ScopeChain di EcmaScript 👩‍👧 🦎 🤦🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! 

 Dalam artikel sebelumnya, kami meneliti teori umum OOP sebagaimana diterapkan pada EcmaScript dan kekeliruan populer pengembang pemula ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ini dan ScopeChain di EcmaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468943/"> Halo, Habr! <br><br>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya,</a> kami meneliti teori umum OOP sebagaimana diterapkan pada EcmaScript dan kekeliruan populer pengembang pemula mengenai perbedaan antara OOP di JS dan bahasa klasik. <br><br>  Hari ini kita akan berbicara tentang dua konsep EcmaScript yang sama pentingnya, yaitu, hubungan entitas dengan konteks eksekusi ( <b>ini</b> adalah koneksi ini) dan hubungan entitas dengan konteks menghasilkan ( <b>ScopeChain</b> ). <br><br>  Jadi mari kita mulai! <br><br><h3>  ini </h3><br>  Saat wawancara dalam menanggapi pertanyaan: "Ceritakan lebih banyak tentang <i>ini kepada kami</i> ."  Pengembang pemula, sebagai suatu peraturan, memberikan jawaban yang sangat samar: " <i>ini</i> adalah objek" sebelum titik "yang digunakan untuk memanggil metode," " <i>ini</i> adalah konteks di mana fungsi dipanggil," dll ... <br><br>  Bahkan, situasi dengan konsep ini, yang merupakan pusat untuk EcmaScript, agak lebih rumit.  Mari kita mencari tahu secara berurutan. <br><br>  Katakanlah kita memiliki program JavaScript yang memiliki variabel yang dideklarasikan secara global;  fungsi global;  fungsi lokal (dideklarasikan di dalam fungsi lain), fungsi yang dikembalikan dari fungsi. <br><a name="habracut"></a><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">25</span></span>, } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-number"><span class="hljs-number">30</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fooBaz</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> test(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fooBar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-number"><span class="hljs-number">40</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-number"><span class="hljs-number">50</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b; } } fooBar()();</code> </pre> <br>  Saat mentransfer kontrol ke kode yang dapat dieksekusi, sebuah entri dibuat ke dalam konteks eksekusi.  Kode yang dapat dieksekusi - ini adalah kode apa pun yang kami jalankan pada waktu tertentu, dapat berupa kode global atau kode fungsi apa pun. <br><br>  <b>Konteks eksekusi</b> adalah abstraksi yang melambangkan dan membatasi kode.  Dari sudut pandang abstraksi ini, kode ini dibagi menjadi global (skrip yang terhubung, skrip inline) dan kode fungsi (kode fungsi yang disarangkan tidak termasuk dalam konteks fungsi induk). <br><br>  Ada tipe ketiga - EvalCode.  Dalam artikel ini, kami mengabaikannya. <br><br>  Secara logis, himpunan konteks eksekusi adalah <b>tumpukan</b> yang bekerja berdasarkan prinsip Last-in-First-out (lifo).  Bagian bawah tumpukan selalu merupakan konteks global, dan bagian atas adalah yang dapat dieksekusi saat ini.  Setiap kali suatu fungsi dipanggil, sebuah entri dibuat ke dalam konteksnya.  Ketika suatu fungsi selesai, konteksnya berakhir.  Konteks bekas dihapus dari tumpukan secara berurutan dan dalam urutan terbalik. <br><br>  Lihatlah kode di atas.  Kami memiliki panggilan ke fungsi <b>fooBar</b> dalam kode global.  Dalam fungsi <b>fooBar,</b> kami mengembalikan <b>fungsi anonim</b> yang segera kami panggil.  Perubahan berikut terjadi dengan tumpukan: <b>konteks global</b> masuk ke dalamnya - ketika <b>fooBar</b> dipanggil <b>,</b> konteksnya masuk ke tumpukan - <b>fooBar</b> dihentikan, mengembalikan <b>fungsi anonim</b> dan dihapus dari tumpukan - <b>fungsi anonim</b> dipanggil, konteksnya masuk ke tumpukan - <b>fungsi anonim</b> memenuhi, mengembalikan nilai dan konteksnya dihapus dari tumpukan - di akhir skrip, <b>konteks global</b> dihapus dari tumpukan. <br><cut></cut><br>  Konteks eksekusi dapat direpresentasikan secara kondisional sebagai objek.  Salah satu properti dari objek ini adalah Lingkungan Lexikal (LO). <br><br>  <b>Lingkungan leksikal</b> mengandung: <br><br><ul><li>  semua deklarasi variabel konteks </li><li>  semua deklarasi fungsi </li><li>  semua parameter formal fungsi (jika kita berbicara tentang konteks fungsi) </li></ul><br>  Saat memasuki konteks eksekusi, penerjemah memindai konteks.  Semua deklarasi variabel dan deklarasi fungsi naik ke awal konteks.  Variabel dibuat sama dengan tidak terdefinisi, dan fungsi sepenuhnya siap untuk digunakan. <br><br>  <b>ini</b> juga merupakan properti dari konteks eksekusi, tetapi bukan konteks itu sendiri, karena beberapa pewawancara pemula menjawab!  <b>ini</b> didefinisikan ketika memasuki konteks dan tetap tidak berubah sampai akhir masa konteks (sampai konteks dihapus dari tumpukan). <br><br>  Dalam konteks eksekusi global, <b>ini</b> ditentukan oleh <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mode ketat</a></b> : ketika mode ketat dimatikan, ini berisi objek global (di browser diproksikan ke tingkat atas di objek jendela), dengan 'gunakan ketat' ini tidak ditentukan. <br><cut></cut><br>  <b>ini</b> dalam konteks fungsi - pertanyaannya jauh lebih menarik! <br>  fungsi ini ditentukan oleh pemanggil dan tergantung pada sintaks panggilan.  Misalnya, seperti yang kita ketahui, ada metode yang memungkinkan Anda untuk menyematkan ini saat menelepon ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">panggilan</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terapkan</a> ) dan metode yang memungkinkan Anda membuat pembungkus dengan "memperbaiki ini" ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bind</a> ).  Dalam situasi ini, kami secara eksplisit menyatakan ini dan tidak ada keraguan tentang definisinya. <br><br>  Dengan pemanggilan fungsi normal, situasinya jauh lebih rumit! <br><br>  Salah satu tipe bawaan EcmaScript, <b>ReferenceType</b> , akan membantu kami memahami bagaimana ini ditempelkan dalam fungsi.  Ini adalah salah satu tipe internal yang tersedia di tingkat implementasi.  Secara logis, ini adalah objek dengan dua <b>basis</b> properti (referensi ke objek basis tertentu yang mengembalikan ReferenceType), <b>propertyName</b> (representasi string dari pengidentifikasi objek untuk mana ReferenceType dikembalikan). <br><br>  <b>ReferenceType</b> dikembalikan untuk semua deklarasi variabel, deklarasi fungsi, dan referensi properti (ini adalah kasus yang menarik bagi kami dari sudut pandang memahami hal ini). <br><br>  Aturan untuk mendefinisikan <b>ini</b> untuk fungsi yang dipanggil dengan cara biasa: <br>  <i>Jika <b>ReferenceType</b> berada di sebelah kiri kurung aktivasi fungsi, maka <b>dasar</b> <b>ReferenceType ini</b> dimasukkan ke dalam fungsi <code>this</code> .</i>  <i>Jika ada tipe lain di sebelah kiri tanda kurung, maka <code>this</code> adalah objek global atau <code>undefined</code> (sebenarnya <code>null</code> , tetapi karena nol tidak memiliki nilai spesifik dari sudut pandang ecmascript, maka itu dilemparkan ke objek global, referensi yang mungkin sama dengan <code>undefined</code> tergantung pada mode ketat).</i> <br><br>  Mari kita lihat sebuah contoh: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } obj.foo();<span class="hljs-comment"><span class="hljs-comment">//  10 ..    ReferenceType  base     obj const test = obj.foo;//       test();//  0 ..  test()   .test(),..  base    ,       0.</span></span></code> </pre><br>  Saya pikir metode definisi diilustrasikan dengan jelas.  Sekarang pertimbangkan beberapa kasus yang kurang jelas. <br><br><h4>  Ekspresi Fungsional </h4><br>  Mari kita kembali ke ReferenceType kami sebentar.  Tipe ini memiliki metode <b>GetValue bawaan</b> yang mengembalikan tipe sebenarnya dari objek yang diterima melalui ReferenceType.  Di zona ekspresi, GetValue selalu menyala. <br><br>  Contoh: <br><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;<span class="hljs-comment"><span class="hljs-comment">// this     undefined    strict mode })()</span></span></code> </pre><br>  Ini disebabkan oleh fakta bahwa GetValue selalu memicu di zona ekspresi.  GetValue mengembalikan tipe Fungsi, dan di sebelah kiri tanda kurasi aktivasi bukan ReferenceType.  Ingat aturan kami untuk menentukan <b>ini</b> : <i>Jika ada tipe lain di sebelah kiri tanda kurung, maka objek global dimasukkan ke dalam <code>this</code> atau <code>undefined</code> (sebenarnya <code>null</code> , tetapi karena nol tidak memiliki nilai tertentu dari sudut pandang ecmascript, maka itu dikonversi ke objek global , tautan yang dapat sama dengan tidak terdefinisi tergantung pada mode ketat)</i> . <br><br>  Zona ekspresi adalah: penugasan (=), operator ||  atau operator logis lainnya, operator ternary, penginisialisasi array, daftar yang dipisahkan koma. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } obj.foo(); <span class="hljs-comment"><span class="hljs-comment">//        //  ? (obj.foo)(); // ,    , GetValue   // ? (obj.foo = obj.foo)(); //        GetValue,     Fuction,   ReferenceType,   0   (   this) //  ||    ,    ..? (obj.foo || obj.foo)();// 0    ,     //  [obj.foo][0]();// 0    ,     // ..</span></span></code> </pre><br>  Situasi identik dalam ekspresi fungsional bernama.  Bahkan dengan panggilan rekursif ke objek global ini atau <code>undefined</code> <br><br><h4>  fungsi bersarang ini disebut di induk </h4><br>  Juga situasi yang penting! <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar(); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = {<span class="hljs-attr"><span class="hljs-attr">x</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>}; obj.test = foo; obj.test();<span class="hljs-comment"><span class="hljs-comment">// undefined</span></span></code> </pre><br>  Ini karena panggilan ke <code>bar()</code> sama dengan panggilan ke <code>LE_foo.bar</code> , dan objek lingkungan leksikal tidak ditentukan seperti ini. <br><br><h4>  Fungsi konstruktor </h4><br>  Seperti yang saya tulis di atas: <blockquote>  fungsi ini ditentukan oleh pemanggil dan tergantung pada sintaks panggilan. </blockquote><br>  Kami memohon fungsi konstruktor menggunakan kata kunci baru.  Keunikan metode aktivasi fungsi ini adalah metode fungsi internal <i><b>[[konstruk]]</b></i> dipanggil, yang melakukan operasi tertentu (mekanisme untuk membuat entitas oleh desainer akan dibahas dalam artikel kedua atau ketiga pada OOP!) Dan memanggil metode internal <i><b>[[panggil]]</b></i> , yang meletakkan dalam <b>hal ini</b> dibuat fungsi konstruktor. <br><br><h3>  Rantai Lingkup </h3><br>  Rantai lingkup juga merupakan properti dari konteks eksekusi seperti ini.  Ini adalah daftar objek lingkungan leksikal dari konteks saat ini dan semua konteks yang menghasilkan.  Dalam rantai inilah pencarian variabel terjadi ketika menyelesaikan nama pengenal. <br><br>  Catatan: ini mengaitkan fungsi dengan konteks eksekusi, dan ScopeChain dengan konteks anak. <br><br>  Spesifikasi menyatakan bahwa ScopeChain adalah array: <br><br><pre> <code class="javascript hljs"> SC = [LO, LO1, LO2,..., LOglobal];</code> </pre><br>  Namun, dalam beberapa implementasi, seperti JS, rantai lingkup diimplementasikan melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">daftar tertaut</a> . <br><br>  Untuk lebih memahami ScopeChain, kita akan membahas siklus hidup berbagai fungsi.  Ini dibagi menjadi fase pembuatan dan fase eksekusi. <br><br>  Ketika suatu fungsi dibuat, fungsi tersebut diberikan properti <i><b>[[RUANG LINGKUP]]</b></i> internal. <br>  Dalam <i><b>[[RUANG LINGKUP]]</b></i> , rantai hirarki objek lingkungan leksikal dari konteks yang lebih tinggi (menghasilkan) dicatat.  Properti ini tetap tidak berubah hingga fungsinya dihancurkan oleh pemulung. <br><br>  Perhatikan!  <i><b>[[RUANG LINGKUP]]</b></i> , tidak seperti ScopeChain, adalah properti dari fungsi itu sendiri, bukan konteksnya. <br><br>  Ketika suatu fungsi dipanggil, konteks pelaksanaannya diinisialisasi dan diisi.  Konteksnya ditempelkan dengan ScopeChain = LO (dari fungsi itu sendiri) + [[RUANG LINGKUP]] (rantai hierarkis LO mempengaruhi konteks). <br><br>  <b>Resolusi nama pengidentifikasi</b> - polling berurutan objek <b>LO</b> dalam rantai <b>ScopeChain dari</b> kiri ke kanan.  Outputnya adalah ReferenceType yang properti dasarnya menunjuk ke objek LO di mana pengenal ditemukan, dan PropertyName akan menjadi representasi string dari nama pengenal. <br><br>  Beginilah cara penutupan diatur di bawah tenda!  Penutupan pada dasarnya adalah hasil dari pencarian di ScopeChain untuk semua variabel yang pengidentifikasinya ada dalam fungsi. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; } (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">20</span></span>; foo();<span class="hljs-comment"><span class="hljs-comment">// 10 ..     &lt;b&gt;&lt;i&gt;[[SCOPE]]&lt;/i&gt;&lt;/b&gt; foo          })()</span></span></code> </pre><br>  Contoh berikut menggambarkan siklus hidup <b><i>[[RUANG LINGKUP]]</i></b> . <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> y = <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [x,y]; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">30</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bar = foo();<span class="hljs-comment"><span class="hljs-comment">//   ,   foo    bar();// [10,20] .. [[SCOPE]]    foo         </span></span></code> </pre><br>  Pengecualian penting adalah <b>fungsi konstruktor</b> .  Untuk jenis fungsi ini, [[RUANG LINGKUP]] selalu menunjuk ke objek global. <br><br>  Juga, jangan lupa bahwa jika salah satu tautan dalam rantai ScopeChain memiliki prototipe, maka pencarian akan dilakukan dalam prototipe juga. <br><br><h3>  Kesimpulan </h3><br>  Kami akan mengeluarkan ide-ide kunci secara tesis: <br><br><ul><li>  ini adalah hubungan entitas dengan konteks eksekusi </li><li>  ScopeChain adalah hubungan entitas dengan semua konteks pemijahan </li><li>  this dan ScopeChain adalah properti konteks eksekusi </li><li>  fungsi ini ditentukan oleh pemanggil dan tergantung pada sintaks panggilan </li><li>  ScopeChain adalah lingkungan leksikal dari konteks saat ini + [[Cakupan]] </li><li>  [[Cakupan]] - ini adalah properti dari fungsi itu sendiri, berisi rantai hirarkis dari lingkungan leksikal dari menghasilkan konteks </li></ul><br>  Semoga artikel ini bermanfaat.  Sampai artikel selanjutnya, teman-teman! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id468943/">https://habr.com/ru/post/id468943/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id468929/index.html">Mini-manual cara mengatur hackintosh sesederhana dan sesakit mungkin</a></li>
<li><a href="../id468931/index.html">Jalankan systemd dalam wadah</a></li>
<li><a href="../id468933/index.html">Runcing dan tajam, ke mana pun Anda melihat: mekanisme penajaman sendiri gigi bulu babi</a></li>
<li><a href="../id468935/index.html">Intisari acara untuk profesional SDM di bidang TI pada Oktober 2019</a></li>
<li><a href="../id468937/index.html">Serangan Kartu Bank tanpa kontak</a></li>
<li><a href="../id468945/index.html">ITIL dan ITSM adalah kisah penipuan besar. Apakah ada manfaatnya? Berapa biayanya dan siapa yang sebenarnya TIDAK “mengimplementasikan ITIL”?</a></li>
<li><a href="../id468951/index.html">Masalah konfigurasi besar untuk perangkat kecil</a></li>
<li><a href="../id468953/index.html">Gaya kode sebagai standar pengembangan</a></li>
<li><a href="../id468955/index.html">Komunikasi adalah opsi jarak jauh yang dapat dikonfigurasi lainnya</a></li>
<li><a href="../id468957/index.html">Generasi penjara bawah tanah menggunakan contoh Unexplored</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>