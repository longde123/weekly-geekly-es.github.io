<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìõ üßî ‚ôãÔ∏è Implementierung der Spring Framework-API von Grund auf neu. Komplettl√∂sung f√ºr Anf√§nger. Teil 1 ü§õüèø ü¶ó üôãüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Spring Framework ist eines der kompliziertesten Frameworks zum Verstehen und Lernen. Die meisten Entwickler lernen es langsam, durch praktische Aufgab...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementierung der Spring Framework-API von Grund auf neu. Komplettl√∂sung f√ºr Anf√§nger. Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419679/"><img src="https://habrastorage.org/webt/iw/mz/82/iwmz824_ptetkxwvc6sqtwjmbjw.png"><br><br>  Spring Framework ist eines der kompliziertesten Frameworks zum Verstehen und Lernen.  Die meisten Entwickler lernen es langsam, durch praktische Aufgaben und Google.  Dieser Ansatz ist nicht effektiv, da er kein vollst√§ndiges Bild liefert und gleichzeitig teuer ist. <br><br>  Ich m√∂chte Ihnen einen grundlegend neuen Ansatz f√ºr das Studium des Fr√ºhlings anbieten.  Es besteht in der Tatsache, dass eine Person eine Reihe von speziell vorbereiteten Tutorials durchl√§uft und die Funktion des Fr√ºhlings unabh√§ngig implementiert.  Die Besonderheit dieses Ansatzes besteht darin, dass er nicht nur die untersuchten Aspekte von Spring zu 100% versteht, sondern auch den Java-Kern (Anmerkungen, Reflexion, Dateien, Generika) erheblich steigert. <br><br>  Der Artikel gibt Ihnen ein unvergessliches Erlebnis und Sie f√ºhlen sich wie ein Pivotal-Entwickler.  Schritt f√ºr Schritt werden Sie Ihre Klassen zu Bohnen machen und ihren Lebenszyklus organisieren (wie in einem echten Fr√ºhling).  Die Klassen, die Sie implementieren, sind <b>BeanFactory</b> , <b>Component</b> , <b>Service</b> , <b>BeanPostProcessor</b> , <b>BeanNameAware</b> , <b>BeanFactoryAware</b> , <b>InitializingBean</b> , <b>PostConstruct</b> , <b>PreDestroy</b> , <b>DisposableBean</b> , <b>ApplicationContext</b> , <b>ApplicationListener</b> , <b>ContextClosedEvent</b> . <br><a name="habracut"></a><br><h2>  Ein bisschen √ºber mich </h2><br>  Mein Name ist Jaroslawisch und ich bin ein Java-Entwickler mit 4 Jahren Erfahrung.  Im Moment arbeite ich f√ºr EPAM Systems (SPB) und besch√§ftige mich intensiv mit den Technologien, die wir verwenden.  Sehr oft muss ich mich mit dem Fr√ºhling auseinandersetzen, und ich sehe darin einen Mittelweg, auf dem man wachsen kann (jeder kennt Java gut, aber zu spezifische Tools und Technologien k√∂nnen kommen und gehen). <br><br>  Vor ein paar Monaten habe ich die Spring Professional v5.0-Zertifizierung bestanden (ohne Kurse zu belegen).  Danach dachte ich dar√ºber nach, wie ich anderen Menschen das Springen beibringen k√∂nnte.  Leider gibt es derzeit keine effektive Lehrmethode.  Die meisten Entwickler haben eine sehr oberfl√§chliche Vorstellung vom Framework und seinen Funktionen.  Das Debuggen der Quellquellen ist aus Sicht des Trainings zu schwierig und absolut nicht effektiv (das hat mir irgendwie gefallen).  10 Projekte machen?  Ja, irgendwo k√∂nnen Sie Ihr Wissen vertiefen und viel praktische Erfahrung sammeln, aber vieles, was sich ‚Äûunter der Haube‚Äú befindet, wird sich niemals vor Ihnen √∂ffnen.  Fr√ºhling in Aktion lesen?  Cool, aber teuer im Aufwand.  Ich habe es zu 40% bearbeitet (w√§hrend der Vorbereitung auf die Zertifizierung), aber es war nicht einfach. <br><br>  Der einzige Weg, etwas bis zum Ende zu verstehen, besteht darin, es selbst zu entwickeln.  Vor kurzem hatte ich die Idee, dass Sie eine Person durch ein interessantes Tutorial f√ºhren k√∂nnen, das die Entwicklung ihres DI-Frameworks √ºberwacht.  Das Hauptmerkmal wird sein, dass die API mit der untersuchten API √ºbereinstimmt.  Das Besondere an diesem Ansatz ist, dass eine Person zus√§tzlich zu einem tiefen (ohne Leerzeichen) Verst√§ndnis des Fr√ºhlings eine RIESIGE Erfahrung in Java Core erh√§lt.  Ehrlich gesagt habe ich selbst w√§hrend der Vorbereitung des Artikels viele neue Dinge gelernt, sowohl √ºber Spring als auch √ºber Java Core.  Beginnen wir mit der Entwicklung! <br><br><h2>  Projekt von Grund auf neu </h2><br>  √ñffnen Sie zun√§chst Ihre Lieblings-IDE und erstellen Sie ein Projekt von Grund auf neu.  Wir werden keine Maven-Bibliotheken oder Bibliotheken von Drittanbietern verbinden.  Wir werden nicht einmal Spring-Abh√§ngigkeiten verbinden.  Unser Ziel ist es, eine API zu entwickeln, die der Spring-API am √§hnlichsten ist, und sie selbst zu implementieren. <br><br>  Erstellen Sie in einem sauberen Projekt zwei Hauptpakete.  Das erste Paket ist Ihre Anwendung ( <code>com.kciray</code> ) und die darin enthaltene <code>Main.java</code> Klasse.  Das zweite Paket ist org.springframework.  Ja, wir werden die Paketstruktur der urspr√ºnglichen Feder, den Namen ihrer Klassen und ihre Methoden duplizieren.  Es gibt einen so interessanten Effekt: Wenn Sie etwas Eigenes erschaffen, erscheint das Eigene einfach und verst√§ndlich.  Wenn Sie dann in gro√üen Projekten arbeiten, scheint es Ihnen, dass alles dort basierend auf Ihrem Werkst√ºck erstellt wird.  Dieser Ansatz kann sich sehr positiv auf das Verst√§ndnis des gesamten Systems, dessen Verbesserung, Behebung von Fehlern, L√∂sen von Problemen usw. auswirken. <br><br>  Wenn Sie Probleme haben, k√∂nnen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier ein</a> Arbeitsprojekt durchf√ºhren. <br><br><h2>  Erstellen Sie einen Container </h2><br>  Legen Sie zun√§chst die Aufgabe fest.  Angenommen, wir haben zwei Klassen - <code>ProductFacade</code> und <code>PromotionService</code> .  Stellen Sie sich nun vor, Sie m√∂chten diese Klassen miteinander verbinden, damit die Klassen selbst nichts voneinander wissen (Muster DI).  Wir ben√∂tigen eine separate Klasse, die alle diese Klassen verwaltet und die Abh√§ngigkeiten zwischen ihnen ermittelt.  Nennen wir es einen Container.  Lassen Sie uns die <code>Container</code> Klasse erstellen ... Obwohl nein, warten Sie!  Spring hat keine einzige Containerklasse.  Wir haben viele Container-Implementierungen, und alle diese Implementierungen k√∂nnen in zwei Typen unterteilt werden - Bin-Fabriken und Kontexte.  Die Bin-Factory erstellt Beans und verkn√ºpft sie miteinander (Dependency Injection, DI). Der Kontext funktioniert √§hnlich und f√ºgt einige zus√§tzliche Funktionen hinzu (z. B. Internationalisierung von Nachrichten).  Da wir diese zus√§tzlichen Funktionen jetzt jedoch nicht ben√∂tigen, werden wir mit der Beh√§lterfabrik zusammenarbeiten. <br><br>  Erstellen Sie eine neue <code>BeanFactory</code> Klasse und <code>BeanFactory</code> sie in das Paket <code>org.springframework.beans.factory</code> .  Lassen Sie <code>Map&lt;String, Object&gt; singletons</code> in dieser Klasse gespeichert werden, in der die <code>id</code> Bin dem Bin selbst zugeordnet ist.  F√ºgen Sie die <code>Object getBean(String beanName)</code> -Methode hinzu, mit der die Beans nach Bezeichner <code>Object getBean(String beanName)</code> werden. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Map&lt;String, Object&gt; singletons = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBean</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String beanName)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> singletons.get(beanName); } }</code> </pre> <br>  Bitte beachten Sie, dass <code>BeanFactory</code> und <code>FactoryBean</code> zwei verschiedene Dinge sind.  Die erste ist die Beh√§lterfabrik (Container), und die zweite ist die Beh√§lterfabrik, die sich im Beh√§lter befindet und auch Beh√§lter produziert.  Fabrik in der Fabrik.  Wenn Sie zwischen diesen Definitionen verwechselt werden, k√∂nnen Sie sich daran erinnern, dass im Englischen das zweite Substantiv das f√ºhrende ist und das erste so etwas wie ein Adjektiv.  In Bean <b>Factory ist das</b> Hauptwort die Fabrik und in Factory <b>Bean</b> die Bohne. <br><br>  Erstellen Sie <code>ProductService</code> Klassen <code>ProductService</code> und <code>PromotionsService</code> .  <code>ProductService</code> gibt das Produkt aus der Datenbank zur√ºck. <code>ProductService</code> m√ºssen Sie jedoch pr√ºfen, ob f√ºr dieses Produkt Rabatte (Sonderangebote) gelten.  Im E-Commerce wird reduzierte Arbeit h√§ufig einer separaten Serviceklasse (und manchmal einem Webdienst eines Drittanbieters) zugeordnet. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PromotionsService</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> PromotionsService promotionsService; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> PromotionsService </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPromotionsService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> promotionsService; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setPromotionsService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PromotionsService promotionsService)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.promotionsService = promotionsService; } }</code> </pre><br>  Jetzt m√ºssen wir unseren Container ( <code>BeanFactory</code> ) dazu bringen, unsere Klassen zu erkennen, sie f√ºr uns zu erstellen und ineinander zu injizieren.  Vorg√§nge wie <code>new ProductService()</code> sollten sich im Container befinden und f√ºr den Entwickler ausgef√ºhrt werden.  Verwenden wir den modernsten Ansatz (Klassenscannen und Anmerkungen).  Dazu m√ºssen wir mit den <code>@Component</code> eine <code>@Component</code> Annotation erstellen ( <code> org.springframework.beans.factory.stereotype</code> ). <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.RUNTIME) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> Component { }</code> </pre><br>  Standardm√§√üig werden Anmerkungen nicht in den Speicher geladen, w√§hrend das Programm ausgef√ºhrt wird ( <code>RetentionPolicy.CLASS</code> ).  Wir haben dieses Verhalten durch eine neue Aufbewahrungsrichtlinie ( <code>RetentionPolicy.RUNTIME</code> ) ge√§ndert. <br><br>  <code>@Component</code> nun <code>@Component</code> vor den <code>ProductService</code> Klassen und vor dem <code>PromotionService</code> . <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... } @Component public class PromotionService { //... }</span></span></code> </pre> <br><br>  Wir ben√∂tigen <code>BeanFactory</code> um unser Paket ( <code>com.kciray</code> ) <code>BeanFactory</code> scannen und darin Klassen zu finden, die von <code>@Component</code> Anmerkungen <code>@Component</code> .  Diese Aufgabe ist alles andere als trivial.  In Java Core gibt es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">keine vorgefertigte L√∂sung</a> , und wir m√ºssen selbst eine Kr√ºcke bauen.  Tausende Federanwendungen verwenden das Scannen von Komponenten durch diese Kr√ºcke.  Du hast die schreckliche Wahrheit erfahren.  Sie m√ºssen die <code>ClassLoader</code> aus <code>ClassLoader</code> und pr√ºfen, <code>ClassLoader</code> sie mit ".class" enden oder nicht. Anschlie√üend m√ºssen Sie ihren vollst√§ndigen Namen erstellen und Klassenobjekte daraus ziehen! <br><br>  Ich m√∂chte Sie sofort warnen, dass es viele gepr√ºfte Ausnahmen geben wird. Seien Sie also bereit, diese zu verpacken.  Aber zuerst entscheiden wir, was wir wollen.  Wir m√∂chten <code>BeanFactory</code> eine spezielle Methode <code>BeanFactory</code> und sie in <code>Main</code> aufrufen: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//BeanFactory.java public class BeanFactory{ public void instantiate(String basePackage) { } } //Main.java BeanFactory beanFactory = new BeanFactory(); beanFactory.instantiate("com.kciray");</span></span></code> </pre><br>  Als n√§chstes m√ºssen wir <code>ClassLoader</code> bekommen.  Es ist f√ºr das Laden von Klassen verantwortlich und wird ganz einfach extrahiert: <br><br><pre> <code class="java hljs">ClassLoader classLoader = ClassLoader.getSystemClassLoader();</code> </pre> <br>  Sie haben wahrscheinlich bereits bemerkt, dass die Pakete durch einen Punkt und die Dateien durch einen Schr√§gstrich getrennt sind.  Wir m√ºssen den Stapelpfad in den Ordnerpfad konvertieren und so etwas wie <code>List&lt;URL&gt;</code> (die Pfade in Ihrem Dateisystem, in denen Sie nach Klassendateien suchen k√∂nnen). <br><br><pre> <code class="java hljs">String path = basePackage.replace(<span class="hljs-string"><span class="hljs-string">'.'</span></span>, <span class="hljs-string"><span class="hljs-string">'/'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//"com.kciray" -&gt; "com/kciray" Enumeration&lt;URL&gt; resources = classLoader.getResources(path);</span></span></code> </pre> <br>  Also warte einen Moment!  <code>Enumeration&lt;URL&gt;</code> ist keine <code>List&lt;URL&gt;</code> .  Worum geht es hier?  Oh, Horror, dies ist der alte Vorl√§ufer von <code>Iterator</code> , der seit Java 1.0 verf√ºgbar ist.  Dies ist das Erbe, mit dem wir uns befassen m√ºssen.  Wenn es m√∂glich ist, <code>Iterable</code> mit for zu durchlaufen (alle Sammlungen implementieren es), m√ºssen Sie im Fall von <code>Enumeration</code> einen Handle-Bypass durch <code>while(resources.hasMoreElements())</code> und <code>nextElement()</code> .  Es gibt jedoch keine M√∂glichkeit, Elemente aus der Sammlung zu entfernen.  Nur 1996, nur Hardcore.  Oh ja, in Java 9 haben sie die <code>Enumeration.asIterator()</code> -Methode hinzugef√ºgt, damit Sie sie <code>Enumeration.asIterator()</code> k√∂nnen. <br><br>  Gehen wir weiter.  Wir m√ºssen die Ordner extrahieren und den Inhalt jedes einzelnen von ihnen durcharbeiten.  Konvertieren Sie die URL in eine Datei und erhalten Sie den Namen.  Hierbei ist zu beachten, dass verschachtelte Pakete nicht gescannt werden, um den Code nicht zu komplizieren.  Sie k√∂nnen Ihre Aufgabe komplizieren und eine Rekursion durchf√ºhren, wenn Sie dies w√ºnschen. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (resources.hasMoreElements()) { URL resource = resources.nextElement(); File file = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(resource.toURI()); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(File classFile : file.listFiles()){ String fileName = classFile.getName();<span class="hljs-comment"><span class="hljs-comment">//ProductService.class } }</span></span></code> </pre><br>  Als n√§chstes m√ºssen wir den Dateinamen ohne die Erweiterung erhalten.  Auf dem Hof ‚Äã‚Äãim Jahr 2018 hat Java seit vielen Jahren File I / O (NIO 2) entwickelt, kann die Erweiterung jedoch immer noch nicht vom Dateinamen trennen.  Ich muss mein eigenes Fahrrad bauen, weil  Wir haben uns entschieden, keine Bibliotheken von Drittanbietern wie Apache Commons zu verwenden.  Verwenden wir den alten Gro√üvater-Weg <code>lastIndexOf(".")</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(fileName.endsWith(<span class="hljs-string"><span class="hljs-string">".class"</span></span>)){ String className = fileName.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, fileName.lastIndexOf(<span class="hljs-string"><span class="hljs-string">"."</span></span>)); }</code> </pre> <br>  Als n√§chstes k√∂nnen wir das Klassenobjekt unter Verwendung des vollst√§ndigen Klassennamens erhalten (dazu nennen wir die Klasse der Klassenklasse): <br><br><pre> <code class="java hljs">Class classObject = Class.forName(basePackage + <span class="hljs-string"><span class="hljs-string">"."</span></span> + className);</code> </pre> <br>  Okay, jetzt sind unsere Klassen in unseren H√§nden.  Au√üerdem m√ºssen nur diejenigen hervorgehoben werden, die die Annotation <code>@Component</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(classObject.isAnnotationPresent(Component.class)){ System.out.println(<span class="hljs-string"><span class="hljs-string">"Component: "</span></span> + classObject); }</code> </pre> <br>  Ausf√ºhren und √ºberpr√ºfen.  Die Konsole sollte ungef√§hr so ‚Äã‚Äãaussehen: <br><br><pre> <code class="bash hljs">Component: class com.kciray.ProductService Component: class com.kciray.PromotionsService</code> </pre> <br>  Jetzt m√ºssen wir unsere Bohne erstellen.  Sie m√ºssen so etwas wie <code>new ProductService()</code> , aber f√ºr jede Bean haben wir unsere eigene Klasse.  Die Reflexion in Java bietet uns eine universelle L√∂sung (der Standardkonstruktor hei√üt): <br><br><pre> <code class="java hljs">Object instance = classObject.newInstance();<span class="hljs-comment"><span class="hljs-comment">//=new CustomClass()</span></span></code> </pre> <br>  Als n√§chstes m√ºssen wir diese Bean in <code>Map&lt;String, Object&gt; singletons</code> .  W√§hlen Sie dazu den Bean-Namen (seine ID).  In Java rufen wir Variablen wie Klassen auf (nur der erste Buchstabe ist klein geschrieben).  Dieser Ansatz kann auch auf Beans angewendet werden, da Spring ein Java-Framework ist!  Konvertieren Sie den Bin-Namen so, dass der erste Buchstabe klein ist, und f√ºgen Sie ihn der Karte hinzu: <br><br><pre> <code class="java hljs">String beanName = className.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>).toLowerCase() + className.substring(<span class="hljs-number"><span class="hljs-number">1</span></span>); singletons.put(beanName, instance);</code> </pre> <br>  Stellen Sie jetzt sicher, dass alles funktioniert.  Der Container muss Beans erstellen und diese m√ºssen namentlich abgerufen werden.  Bitte beachten Sie, dass der Name Ihrer <code>instantiate()</code> Methode und der Name der <code>classObject.newInstance();</code> -Methode <code>classObject.newInstance();</code>  habe eine gemeinsame Wurzel.  Dar√ºber hinaus ist <code>instantiate()</code> Teil des Lebenszyklus der Bohne.  In Java ist alles miteinander verbunden! <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Main.java BeanFactory beanFactory = new BeanFactory(); beanFactory.instantiate("com.kciray"); ProductService productService = (ProductService) beanFactory.getBean("productService"); System.out.println(productService);//ProductService@612</span></span></code> </pre> <br><br>  Versuchen Sie auch, die Annotation <code>org.springframework.beans.factory.stereotype.Service</code> implementieren.  Es hat genau die gleiche Funktion wie <code>@Component</code> , wird jedoch anders aufgerufen.  Der springende Punkt liegt im Namen - Sie zeigen, dass die Klasse ein Dienst ist, nicht nur eine Komponente.  Dies ist so etwas wie konzeptionelles Tippen.  In der Fr√ºhjahrszertifizierung gab es die Frage "Welche Anmerkungen sind stereotyp?"  (von den aufgelisteten). ‚Äù  Stereotype Annotationen sind also diejenigen, die im <code>stereotype</code> Paket enthalten sind. <br><br><h2>  F√ºllen Sie die Eigenschaften </h2><br>  Schauen Sie sich das Diagramm unten an, es zeigt den Beginn des Lebenszyklus der Bohne.  Was wir vorher gemacht haben, ist Instantiate (Erstellen von Beans durch <code>newInstance()</code> ).  Der n√§chste Schritt ist die Kreuzinjektion von Bohnen (Abh√§ngigkeitsinjektion, es ist auch die Inversion der Kontrolle (IoC)).  Sie m√ºssen die Eigenschaften der Bohnen durchgehen und verstehen, welche Eigenschaften Sie injizieren m√ºssen.  Wenn Sie <code>productService.getPromotionsService()</code> aufrufen, erhalten Sie <code>null</code> , weil  Abh√§ngigkeit noch nicht hinzugef√ºgt. <br><br><img src="https://habrastorage.org/webt/2i/4v/4c/2i4v4cbsb-bdpdrgb0grh_swclu.png"><br><br>  Erstellen Sie zun√§chst das Paket <code>org.springframework.beans.factory.annotation</code> und f√ºgen Sie die Annotation <code>@Autowired</code> .  Die Idee ist, Felder, die Abh√§ngigkeiten sind, mit dieser Anmerkung zu kennzeichnen. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.RUNTIME) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> Autowired { }</code> </pre> <br>  F√ºgen Sie es als N√§chstes der Eigenschaft hinzu: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> PromotionsService promotionsService; <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Jetzt m√ºssen wir unserer <code>BeanFactory</code> beibringen, diese Anmerkungen <code>BeanFactory</code> finden und Abh√§ngigkeiten von ihnen <code>BeanFactory</code> .  F√ºgen Sie hierf√ºr eine separate Methode hinzu und rufen Sie sie von <code>Main</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... public void populateProperties(){ System.out.println("==populateProperties=="); } }</span></span></code> </pre> <br>  Als N√§chstes m√ºssen wir nur alle unsere Beans in der <code>singletons</code> Map durchgehen und f√ºr jede Bean alle ihre Felder <code>object.getClass().getDeclaredFields()</code> Methode <code>object.getClass().getDeclaredFields()</code> gibt alle Felder zur√ºck, einschlie√ülich privater Felder).  √úberpr√ºfen Sie, ob das Feld eine <code>@Autowired</code> Anmerkung enth√§lt: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Object object : singletons.values()) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Field field : object.getClass().getDeclaredFields()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (field.isAnnotationPresent(Autowired.class)) { } } }</code> </pre> <br>  Als n√§chstes m√ºssen wir noch einmal alle Beh√§lter durchgehen und ihren Typ sehen - pl√∂tzlich ist dies der Typ, den unser Beh√§lter f√ºr sich nehmen m√∂chte.  Ja, wir bekommen einen dreidimensionalen Zyklus! <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Object dependency : singletons.values()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dependency.getClass().equals(field.getType())) { } }</code> </pre> <br>  Wenn wir die Sucht gefunden haben, m√ºssen wir sie injizieren.  Das erste, woran Sie denken k√∂nnten, ist, das Feld " <code>promotionsService</code> direkt mit Reflektion zu schreiben.  Aber so funktioniert der Fr√ºhling nicht.  Wenn das Feld einen <code>private</code> Modifikator hat, m√ºssen wir ihn zuerst als <code>public</code> festlegen, dann unseren Wert schreiben und dann wieder auf <code>private</code> (um die Integrit√§t aufrechtzuerhalten).  Klingt nach einer gro√üen Kr√ºcke.  Anstelle einer gro√üen Kr√ºcke machen wir eine kleine Kr√ºcke (wir bilden den Namen des Setzers und nennen ihn): <br><br><pre> <code class="java hljs">String setterName = <span class="hljs-string"><span class="hljs-string">"set"</span></span> + field.getName().substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>).toUpperCase() + field.getName().substring(<span class="hljs-number"><span class="hljs-number">1</span></span>);<span class="hljs-comment"><span class="hljs-comment">//setPromotionsService System.out.println("Setter name = " + setterName); Method setter = object.getClass().getMethod(setterName, dependency.getClass()); setter.invoke(object, dependency);</span></span></code> </pre> <br>  F√ºhren Sie nun Ihr Projekt aus und stellen Sie sicher, dass beim Aufrufen von <code>productService.getPromotionsService()</code> anstelle von <code>null</code> unsere Bean zur√ºckgegeben wird. <br><br>  Was wir implementiert haben, ist die Injektion nach Typ.  Es gibt auch eine Injektion nach Namen ( <code>javax.annotation.Resource</code> annotation).  Es unterscheidet sich darin, dass anstelle des Feldtyps sein Name extrahiert wird und dementsprechend die Abh√§ngigkeit von der Karte.  Hier ist alles √§hnlich, auch in etwas Einfacherem.  Ich empfehle, dass Sie experimentieren und Ihre eigene Bean erstellen, diese dann mit <code>@Resource</code> injizieren und die Methode <code>populateProperties()</code> . <br><br><h2>  Wir unterst√ºtzen Bohnen, die √ºber ihren Namen Bescheid wissen </h2><br><img src="https://habrastorage.org/webt/ds/ge/nn/dsgennl2rvz-spa6h51l_yox81o.png"><br><br>  Es gibt Zeiten, in denen Sie seinen Namen in den Papierkorb bekommen m√ºssen.  Ein solches Bed√ºrfnis entsteht nicht oft, weil  Beh√§lter sollten im Wesentlichen nicht voneinander wissen und dass sie Beh√§lter sind.  In den ersten Versionen des Fr√ºhlings wurde angenommen, dass die Bean ein POJO (Plain Old Java Objec, das gute alte Java-Objekt) ist und die gesamte Konfiguration in XML-Dateien gerendert und von der Implementierung getrennt wird.  Wir implementieren diese Funktionalit√§t jedoch, da die Namensinjektion Teil des Lebenszyklus des Beh√§lters ist. <br><br>  Woher wissen wir, welche Bohne wissen will, wie er hei√üt und was er nicht will?  Das erste, was mir in den Sinn kommt, ist, eine neue Annotation vom Typ <code>@InjectName</code> und sie in Felder vom Typ String zu formen.  Diese L√∂sung ist jedoch zu allgemein und erm√∂glicht es Ihnen, sich viele Male in den Fu√ü zu schie√üen (platzieren Sie diese Anmerkung auf Feldern unangemessenen Typs (nicht auf Zeichenfolge) oder versuchen Sie, einen Namen in mehrere Felder derselben Klasse einzuf√ºgen).  Es gibt eine andere L√∂sung, genauer - eine spezielle Schnittstelle mit einer Setter-Methode zu erstellen.  Alle Bins, die es implementieren, erhalten ihren Namen.  Erstellen Sie die <code>BeanNameAware</code> Klasse im Paket <code>org.springframework.beans.factory</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanNameAware</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setBeanName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span></span>; }</code> </pre> <br>  Lassen Sie es als n√§chstes von unserem <code>PromotionsService</code> implementieren: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PromotionsService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanNameAware</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String beanName; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setBeanName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ beanName = name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBeanName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> beanName; } }</code> </pre> <br>  Und schlie√ülich f√ºgen Sie der Bohnenfabrik eine neue Methode hinzu.  Hier ist alles einfach - wir gehen unseren Bin-Singleton durch, pr√ºfen, ob der Bin unsere Schnittstelle implementiert, und rufen den Setter auf: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">injectBeanNames</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String name : singletons.keySet()) { Object bean = singletons.get(name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(bean <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> BeanNameAware){ ((BeanNameAware) bean).setBeanName(name); } } }</code> </pre> <br>  F√ºhren Sie aus und stellen Sie sicher, dass alles funktioniert: <br><br><pre> <code class="java hljs">BeanFactory beanFactory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BeanFactory(); beanFactory.instantiate(<span class="hljs-string"><span class="hljs-string">"com.kciray"</span></span>); beanFactory.populateProperties(); beanFactory.injectBeanNames(); <span class="hljs-comment"><span class="hljs-comment">//... System.out.println("Bean name = " + promotionsService.getBeanName());</span></span></code> </pre><br>  Es ist zu beachten, dass es im Fr√ºhjahr andere √§hnliche Schnittstellen gibt.  Ich empfehle, dass Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BeanFactoryAware-</a> Schnittstelle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">selbst</a> implementieren, damit Beans einen Link zur Bean Factory erhalten.  Es wird auf √§hnliche Weise implementiert. <br><br><h2>  Bohnen initialisieren </h2><br><img src="https://habrastorage.org/webt/yq/0w/5t/yq0w5t8x0kqrgqwllfuxsi77xug.png"><br><br>  Stellen Sie sich vor, Sie m√ºssen nach dem Einf√ºgen der Abh√§ngigkeiten Code ausf√ºhren (bin-Eigenschaften sind festgelegt).  In einfachen Worten, wir m√ºssen dem Bin die M√∂glichkeit geben, sich selbst zu initialisieren.  Alternativ k√∂nnen wir eine <code>InitializingBean</code> Schnittstelle erstellen und die Signatur der <code>void afterPropertiesSet()</code> -Methode darin <code>void afterPropertiesSet()</code> .  Die Implementierung dieses Mechanismus ist genau die gleiche wie f√ºr die <code>BeanNameAware</code> Schnittstelle, sodass sich die L√∂sung unter dem Spoiler befindet.  √úbe und mache es in einer Minute selbst: <br><br><div class="spoiler">  <b class="spoiler_title">Bean-Initialisierungsl√∂sung</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//InitializingBean.java package org.springframework.beans.factory; public interface InitializingBean { void afterPropertiesSet(); } //BeanFactory.java public void initializeBeans(){ for (Object bean : singletons.values()) { if(bean instanceof InitializingBean){ ((InitializingBean) bean).afterPropertiesSet(); } } } //Main.java beanFactory.initializeBeans();</span></span></code> </pre> <br></div></div><br><br><h2>  Hinzuf√ºgen von Postprozessoren </h2><br>  Stellen Sie sich an die Stelle der ersten Fr√ºhlingsentwickler.  Ihr Framework w√§chst und ist bei Entwicklern sehr beliebt. T√§glich werden Briefe an die E-Mail gesendet, in denen Sie aufgefordert werden, die eine oder andere n√ºtzliche Funktion hinzuzuf√ºgen.  Wenn Sie f√ºr jede dieser Funktionen eine eigene Schnittstelle hinzuf√ºgen und diese im Lebenszyklus der Bean √ºberpr√ºfen, wird sie (der Lebenszyklus) mit unn√∂tigen Informationen verstopft.  Stattdessen k√∂nnen wir eine universelle Schnittstelle erstellen, √ºber die Sie eine Logik hinzuf√ºgen k√∂nnen (absolut jede, unabh√§ngig davon, ob nach Anmerkungen gesucht wird, der Beh√§lter durch einen anderen Beh√§lter ersetzt wird, einige spezielle Eigenschaften festgelegt werden usw.). <br><br>  Lassen Sie uns dar√ºber nachdenken, wof√ºr diese Schnittstelle gedacht ist.  Es muss eine Nachbearbeitung der Beans durchgef√ºhrt werden, daher kann es BeanPostProcessor genannt werden.  Wir stehen jedoch vor einer schwierigen Frage: Wann sollte die Logik befolgt werden?  Schlie√ülich k√∂nnen wir es vor der Initialisierung ausf√ºhren, aber wir k√∂nnen es danach ausf√ºhren.  F√ºr einige Aufgaben ist die erste Option besser, f√ºr andere - die zweite ... Wie soll man sein? <br><br>  Wir k√∂nnen beide Optionen gleichzeitig aktivieren.  Lassen Sie einen Postprozessor zwei Logiken, zwei Methoden tragen.  Eine wird vor der Initialisierung (vor der <code>afterPropertiesSet()</code> -Methode) und die andere nach der Initialisierung ausgef√ºhrt.  Lassen Sie uns nun √ºber die Methoden selbst nachdenken - welche Parameter sollten sie haben?  Offensichtlich muss die <code>Object bean</code> selbst ( <code>Object bean</code> ) vorhanden sein.  Der Einfachheit halber k√∂nnen Sie zus√§tzlich zur Bohne den Namen dieser Bohne √ºbergeben.  Sie erinnern sich, dass der Beh√§lter selbst seinen Namen nicht kennt.  Und wir m√∂chten nicht alle Beans zwingen, die BeanNameAware-Schnittstelle zu implementieren.  Auf Postprozessorebene kann der Bean-Name jedoch sehr n√ºtzlich sein.  Daher f√ºgen wir es als zweiten Parameter hinzu. <br><br>  Und was sollte die Methode bei der Nachbearbeitung der Bean zur√ºckgeben?  Lassen Sie es den Papierkorb selbst zur√ºckgeben.  Dies gibt uns Superflexibilit√§t, da Sie anstelle eines Bin ein Proxy-Objekt verschieben k√∂nnen, das seine Aufrufe umschlie√üt (und die Sicherheit erh√∂ht).  Oder Sie k√∂nnen ein anderes Objekt vollst√§ndig zur√ºckgeben, indem Sie den Bin erneut erstellen.  Entwicklern wird eine sehr gro√üe Handlungsfreiheit einger√§umt.  Unten finden Sie die endg√ºltige Version der gestalteten Benutzeroberfl√§che: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.springframework.beans.factory.config; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanPostProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postProcessBeforeInitialization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object bean, String beanName)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postProcessAfterInitialization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object bean, String beanName)</span></span></span></span>; }</code> </pre> <br>  Als n√§chstes m√ºssen wir unserer Bohnenfabrik eine Liste einfacher Prozessoren hinzuf√ºgen und neue hinzuf√ºgen.  Ja, dies ist eine regul√§re ArrayList. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//BeanFactory.java private List&lt;BeanPostProcessor&gt; postProcessors = new ArrayList&lt;&gt;(); public void addPostProcessor(BeanPostProcessor postProcessor){ postProcessors.add(postProcessor); }</span></span></code> </pre> <br>  √Ñndern Sie nun die Methode <code>initializeBeans</code> so, dass Postprozessoren ber√ºcksichtigt werden: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initializeBeans</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String name : singletons.keySet()) { Object bean = singletons.get(name); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (BeanPostProcessor postProcessor : postProcessors) { postProcessor.postProcessBeforeInitialization(bean, name); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bean <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> InitializingBean) { ((InitializingBean) bean).afterPropertiesSet(); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (BeanPostProcessor postProcessor : postProcessors) { postProcessor.postProcessAfterInitialization(bean, name); } } }</code> </pre> <br>  Erstellen wir einen kleinen Postprozessor, der Anrufe einfach an die Konsole zur√ºckverfolgt und zu unserer Bean Factory hinzuf√ºgt: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomPostProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanPostProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postProcessBeforeInitialization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object bean, String beanName)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"---CustomPostProcessor Before "</span></span> + beanName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bean; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postProcessAfterInitialization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object bean, String beanName)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"---CustomPostProcessor After "</span></span> + beanName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bean; } }</code> </pre> <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Main.java BeanFactory beanFactory = new BeanFactory(); beanFactory.addPostProcessor(new CustomPostProcessor());</span></span></code> </pre> <br><br>  F√ºhren Sie nun aus und stellen Sie sicher, dass alles funktioniert.  Erstellen Sie als Schulungsaufgabe einen <code>@PostConstruct (javax.annotation.PostConstruct)</code> Annotation <code>@PostConstruct (javax.annotation.PostConstruct)</code> .  Es bietet eine alternative M√∂glichkeit zum Initialisieren (verwurzelt in Java, nicht im Fr√ºhjahr).  Das Wesentliche ist, dass Sie die Annotation auf eine Methode setzen. Diese Methode wird VOR der Standard-Federinitialisierung (InitializingBean) aufgerufen. <br><br>  Stellen Sie sicher, dass Sie alle Anmerkungen und Pakete (auch javax.annotation) manuell erstellen. Verbinden Sie die Abh√§ngigkeiten nicht!  Auf diese Weise k√∂nnen Sie den Unterschied zwischen dem Federkern und seinen Verl√§ngerungen (Javax-Unterst√ºtzung) erkennen und sich daran erinnern.  Dies wird auch in Zukunft einen Stil beibehalten. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie werden daran interessiert sein, dass in einem echten Fr√ºhjahr die Annotation </font></font><code>@PostConstruct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf diese Weise √ºber den Postprozessor CommonAnnotationBeanPostProcessor implementiert wird. </font><font style="vertical-align: inherit;">Aber schauen Sie nicht dorthin, schreiben Sie Ihre Implementierung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuletzt empfehle ich Ihnen </font></font><code>void close()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, der Klasse </font><font style="vertical-align: inherit;">eine Methode hinzuzuf√ºgen </font></font><code>BeanFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und zwei weitere Mechanismen auszuarbeiten. </font><font style="vertical-align: inherit;">Die erste ist eine Anmerkung </font></font><code>@PreDestroy (javax.annotation.PreDestroy)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die f√ºr Methoden gedacht ist, die aufgerufen werden sollen, wenn der Container geschlossen wird. </font><font style="vertical-align: inherit;">Die zweite ist die Schnittstelle </font></font><code>org.springframework.beans.factory.DisposableBean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die die Methode enth√§lt </font></font><code>void destroy()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Alle Bins, die diese Schnittstelle ausf√ºhren, k√∂nnen sich selbst zerst√∂ren (z. B. Ressourcen freisetzen).</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@PreDestroy + DisposableBean</font></font></b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//DisposableBean.java package org.springframework.beans.factory; public interface DisposableBean { void destroy(); } //PreDestroy.java package javax.annotation; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; @Retention(RetentionPolicy.RUNTIME) public @interface PreDestroy { } //DisposableBean.java public void close() { for (Object bean : singletons.values()) { for (Method method : bean.getClass().getMethods()) { if (method.isAnnotationPresent(PreDestroy.class)) { try { method.invoke(bean); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } } } if (bean instanceof DisposableBean) { ((DisposableBean) bean).destroy(); } } }</span></span></code> </pre> <br></div></div><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Voller Bohnen-Lebenszyklus </font></font></h2><img src="https://habrastorage.org/webt/ns/uh/lk/nsuhlk9ko9d9gxtzmcytopfruim.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deshalb haben wir den gesamten Lebenszyklus des Beh√§lters in seiner modernen Form implementiert. </font><font style="vertical-align: inherit;">Ich hoffe, dieser Ansatz hilft Ihnen, sich daran zu erinnern.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unser Lieblingskontext </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Programmierer verwenden sehr oft den Begriff Kontext, aber nicht jeder versteht, was er wirklich bedeutet. </font><font style="vertical-align: inherit;">Jetzt werden wir alles in Ordnung bringen. </font><font style="vertical-align: inherit;">Wie ich am Anfang des Artikels bemerkt habe, ist der Kontext auch die Implementierung des Containers </font></font><code>BeanFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Zus√§tzlich zu den Grundfunktionen (DI) werden noch einige coole Funktionen hinzugef√ºgt. </font><font style="vertical-align: inherit;">Eine dieser Funktionen ist das Senden und Verarbeiten von Ereignissen zwischen Bins. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Artikel erwies sich als zu gro√ü und der Inhalt wurde abgeschnitten, sodass ich die Kontextinformationen unter den Spoiler stellte.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir erkennen den Kontext</font></font></b> <div class="spoiler_text">    .   <code>org.springframework.context</code> ,   <code>ApplicationContext</code>  .        <code>BeanFactory</code> .      ,      <code>close()</code> . <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationContext</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> BeanFactory beanFactory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BeanFactory(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ApplicationContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String basePackage)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> ReflectiveOperationException</span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"******Context is under construction******"</span></span>); beanFactory.instantiate(basePackage); beanFactory.populateProperties(); beanFactory.injectBeanNames(); beanFactory.initializeBeans(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ beanFactory.close(); } }</code> </pre> <br><br>     <code>Main</code> ,   ,   : <br><br><pre> <code class="java hljs">ApplicationContext applicationContext = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ApplicationContext(<span class="hljs-string"><span class="hljs-string">"com.kciray"</span></span>); applicationContext.close();</code> </pre> <br>   ,   .       <code>close()</code> ,     ¬´ ¬ª     - .   ,   : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.springframework.context.event; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContextClosedEvent</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br>      <code>ApplicationListener</code> ,      .        ,          ( <code>ApplicationListener&lt;E&gt;</code> ). ,    Java-,         . ,      ,    : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.springframework.context; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListener</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt;</span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onApplicationEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(E event)</span></span></span></span>; }</code> </pre> <br>     <code>ApplicationContext</code> .     <code>close()</code>     ,  ,      .    <code>ApplicationListener&lt;ContextClosedEvent&gt;</code> ,     <code>onApplicationEvent(ContextClosedEvent)</code> .    ,   ? <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ beanFactory.close(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(Object bean : beanFactory.getSingletons().values()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bean <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ApplicationListener) { } } }</code> </pre> <br>  Aber nein.   .       <code>bean instanceof ApplicationListener&lt;ContextClosedEvent&gt;</code> .      Java.      <i>  (type erasure)</i> ,    &lt;T&gt;   &lt;Object&gt;.   ,   ?    ,    <code>ApplicationListener&lt;ContextClosedEvent&gt;</code> ,     ? <br><br>   ,       ,       .  ,      ,    ,     ,   : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Type type: bean.getClass().getGenericInterfaces()){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(type <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ParameterizedType){ ParameterizedType parameterizedType = (ParameterizedType) type; } }</code> </pre> <br> ,       ,  ,   ‚Äî   .   ,         : <br><br><pre> <code class="java hljs">Type firstParameter = parameterizedType.getActualTypeArguments()[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(firstParameter.equals(ContextClosedEvent.class)){ Method method = bean.getClass().getMethod(<span class="hljs-string"><span class="hljs-string">"onApplicationEvent"</span></span>, ContextClosedEvent.class); method.invoke(bean, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ContextClosedEvent()); }</code> </pre> <br>        ApplicationListener: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PromotionsService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanNameAware</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListener</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContextClosedEvent</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... @Override public void onApplicationEvent(ContextClosedEvent event) { System.out.println("&gt;&gt; ContextClosed EVENT"); } }</span></span></code> </pre> <br> ,     Main  ,    ,   : <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Main.java void testContext() throws ReflectiveOperationException{ ApplicationContext applicationContext = new ApplicationContext("com.kciray"); applicationContext.close(); }</span></span></code> </pre> <br></div></div><br><h2>  Fazit </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anfangs plante ich diesen Artikel f√ºr Baeldung auf Englisch, aber dann dachte ich, dass das Publikum des Habr√© diesen Trainingsansatz positiv bewerten k√∂nnte. </font><font style="vertical-align: inherit;">Wenn Ihnen meine Ideen gefallen haben, sollten Sie den Artikel unbedingt unterst√ºtzen. </font><font style="vertical-align: inherit;">Wenn sie eine Bewertung von mehr als 30 erh√§lt, verspreche ich, fortzufahren. </font><font style="vertical-align: inherit;">Beim Schreiben des Artikels habe ich versucht, genau das Wissen √ºber Spring Core zu zeigen, das am h√§ufigsten verwendet wird und auch auf dem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Core Spring 5.0 Certification Study Guide</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> basiert </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mit Hilfe solcher Tutorials k√∂nnen Sie in Zukunft die gesamte Zertifizierung abdecken und den Fr√ºhling f√ºr Java-Entwickler zug√§nglicher machen.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Update 05/10/2018 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Briefe kommen st√§ndig mit Fragen zu mir "und wenn die Fortsetzung, warten wir auf ihn." </font><font style="vertical-align: inherit;">Aber es gibt √ºberhaupt keine Zeit und andere pers√∂nliche Projekte haben Priorit√§t. </font><font style="vertical-align: inherit;">Wenn einem von Ihnen die Idee jedoch wirklich gefallen hat, k√∂nnen Sie den engen Abschnitt des Fr√ºhlings studieren und einen Folgeartikel schreiben. </font><font style="vertical-align: inherit;">Wenn Sie kein habr-Konto haben, kann ich einen Artikel aus meinem Konto ver√∂ffentlichen oder Ihnen helfen, eine Einladung zu erhalten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Themenverteilung: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spring Container - [Benutzername] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spring AOP - [Benutzername] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spring Web - [Benutzername] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spring Cloud - [Benutzername]</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de419679/">https://habr.com/ru/post/de419679/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de419665/index.html">Die Erfahrung mit LoRaWAN im ASKUE-System unter realen Stadtbedingungen</a></li>
<li><a href="../de419667/index.html">Eine Auswahl n√ºtzlicher Materialien zu Azure. Teil 1 - B√ºcher</a></li>
<li><a href="../de419669/index.html">Zehn beste Gaming-M√§use f√ºr jeden Geldbeutel</a></li>
<li><a href="../de419671/index.html">Einschr√§nkungen, gegen die versto√üen werden muss, oder wie wir Funktionstests dreimal beschleunigt haben</a></li>
<li><a href="../de419677/index.html">So schn√ºffeln Sie den HTTPS-Verkehr eines iOS-Ger√§ts</a></li>
<li><a href="../de419683/index.html">Was bedeuten Metriken f√ºr agile Teams?</a></li>
<li><a href="../de419685/index.html">Die wichtigsten Datenstrukturen, die Sie √ºber Ihr Programmierinterview wissen sollten</a></li>
<li><a href="../de419687/index.html">Geheime Tastatur Stufe 3 oder wie man einen langen Strich druckt</a></li>
<li><a href="../de419689/index.html">I. Disadaptation. II. ADHS oder ein fauler Idiot?</a></li>
<li><a href="../de419693/index.html">Mikrotik: Reset, Backups und DualBoot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>