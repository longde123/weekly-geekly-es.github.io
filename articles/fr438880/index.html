<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚟 🙎🏾 👸🏿 Quand utiliser var, let et const en Javascript [traduction de l'article de Tyler McGinnis] 🧑🏻‍🤝‍🧑🏻 🤰🏽 🍡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Je vous présente la traduction de l'article «var vs let vs const en JavaScript» par Tyler McGinnis. 



 Dans cet article, vous apprend...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Quand utiliser var, let et const en Javascript [traduction de l'article de Tyler McGinnis]</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438880/"> Bonjour, Habr!  Je vous présente la traduction de l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«var vs let vs const en JavaScript»</a> par Tyler McGinnis. <br><br><img src="https://cdn-images-1.medium.com/max/2600/1*bPIf2_HXNUG4O_tSvWKYsg.png" alt="image"><br><br>  Dans cet article, vous apprendrez 2 nouvelles façons de créer des variables en Javascript (ES6), let et const.  Tout au long de cet article, nous examinerons les différences entre <i>var</i> , <i>let</i> et <i>const</i> , ainsi que des sujets connexes tels que: «portée de la fonction contre portée du bloc», «augmentation» des variables et immunité. <br><a name="habracut"></a><br>  Si vous préférez une vidéo, regardez-la (originale en anglais): <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/6vBYfLCE9-Q" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  ES2015 (ou ES6) nous a présenté 2 nouvelles façons de créer des variables, <i>let</i> et <i>const</i> .  Mais avant de nous plonger dans les différences entre <i>var</i> , <i>let</i> et <i>const</i> , il y a quelques sujets que vous devez d'abord connaître.  Ce sont la déclaration des variables et leur initialisation, la portée (une portée spéciale de la fonction) et la «montée». <br><br><h3>  Déclaration et initialisation de variables </h3><br>  Une déclaration de variable introduit un nouvel identifiant. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> declaration</code> </pre> <br>  Ci-dessus, nous créons un nouvel identifiant que nous avons nommé «déclaration».  En Javascript, lors de leur création, les variables sont initialisées avec une valeur <i>indéfinie</i> .  Cela signifie que si nous essayons de sortir notre variable de <i>déclaration</i> , nous obtenons <i>undefined</i> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> declaration <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(declaration)</code> </pre> <br>  Et donc, nous avons déduit la variable de <i>déclaration</i> et nous sommes <i>devenus indéfinis</i> . <br><br>  Par rapport à la déclaration d'une variable, l'initialisation d'une variable est la première fois que vous définissez la valeur de cette variable. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> declaration <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(declaration) <span class="hljs-comment"><span class="hljs-comment">// undefined declaration = '  '</span></span></code> </pre> <br>  Et donc, ici, nous avons initialisé la variable de <i>déclaration</i> en y écrivant une chaîne. <br><br>  Cela nous amène au concept suivant, la portée. <br><cut><br><h3>  Portée </h3><br>  Une portée décrit où la variable et les fonctions sont accessibles dans notre programme.  En Javascript, il existe 2 types d'étendues - l' <b>étendue globale</b> et <b>l'étendue d'une fonction</b> .  Selon les spécifications officielles, <br><blockquote>  "Si une déclaration de variable se produit à l'intérieur d'une déclaration de fonction, la variable est définie dans la portée locale de cette fonction ..." </blockquote>  Cela signifie que si vous créez une variable à l'aide de <i>var</i> , la portée de cette variable sera la fonction dans laquelle elle a été créée et sera disponible uniquement à l'intérieur de cette fonction ou de toute autre fonction imbriquée. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> date = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> date } getDate() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(date) <span class="hljs-comment"><span class="hljs-comment">// NOT OK: Reference Error</span></span></code> </pre> <br>  Ci-dessus, nous avons essayé d'accéder à la variable depuis l'extérieur de la fonction dans laquelle elle a été déclarée.  Étant donné que la portée de la variable <i>date</i> est la fonction <i>getDate</i> , elle n'est disponible qu'à l'intérieur de cette fonction ou dans toute autre fonction imbriquée dans <i>getDate</i> (comme indiqué ci-dessous). <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> date = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">formatDate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> date.toDateString().slice(<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-comment"><span class="hljs-comment">// OK } return formatDate() } getDate() console.log(date) // NOT OK: Reference Error</span></span></code> </pre> <br>  Voyons maintenant un exemple plus avancé.  Disons que nous avons un tableau de prix et que nous avons besoin d'une fonction qui accepte ce tableau, ainsi qu'une <i>remise</i> variable, et nous renvoie un nouveau tableau de prix avec des remises.  L'objectif final peut ressembler à ceci: <br><br><pre> <code class="javascript hljs">discountPrices([<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">300</span></span>], <span class="hljs-number"><span class="hljs-number">.5</span></span>)</code> </pre> <br>  Et l'implémentation pourrait ressembler à ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">discountPrices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prices, discount</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> discounted = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; prices.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> discountedPrice = prices[i] * (<span class="hljs-number"><span class="hljs-number">1</span></span> - discount) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> finalPrice = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(discountedPrice * <span class="hljs-number"><span class="hljs-number">100</span></span>) / <span class="hljs-number"><span class="hljs-number">100</span></span> discounted.push(finalPrice) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> discounted }</code> </pre> <br>  Cela semble assez simple, mais qu'est-ce que cela a à voir avec la portée du bloc?  Jetez un œil à cette boucle.  Les variables déclarées à l'intérieur sont-elles accessibles à l'extérieur?  Il s'avère disponible. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">discountPrices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prices, discount</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> discounted = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; prices.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> discountedPrice = prices[i] * (<span class="hljs-number"><span class="hljs-number">1</span></span> - discount) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> finalPrice = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(discountedPrice * <span class="hljs-number"><span class="hljs-number">100</span></span>) / <span class="hljs-number"><span class="hljs-number">100</span></span> discounted.push(finalPrice) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i) <span class="hljs-comment"><span class="hljs-comment">// 3 console.log(discountedPrice) // 150 console.log(finalPrice) // 150 return discounted }</span></span></code> </pre> <br>  Si JavaScript est le seul langage de programmation que vous connaissez, vous n'aurez peut-être pas à vous en soucier autant.  Cependant, si vous êtes arrivé à JavaScript à partir d'un autre langage de programmation, en particulier un langage de programmation qui bloque la portée, vous êtes probablement un peu inquiet de ce qui se passe ici. <br><br>  Ce n'est pas cassé, ça marche juste un peu bizarre.  Il n'y a vraiment aucune raison d'avoir accès à <i>i</i> , <i>discountPrice</i> et <i>finalPrice en</i> dehors de la boucle <i>for</i> .  Cela ne nous fait aucun bien et peut même nous faire du mal dans certaines situations.  Cependant, comme les variables sont déclarées à l'aide de <i>var</i> , elles entrent dans le champ d'application de la fonction et vous pouvez y accéder. <br><br>  Maintenant, nous avons discuté de la déclaration et de l'initialisation des variables, ainsi que de la portée, une autre chose que nous devons traiter avant de plonger dans les différences entre <i>let</i> et <i>const</i> , c'est «augmenter». <br><br><h3>  "Lift" </h3><br>  Rappelez-vous, il a été dit plus tôt "En Javascript, lors de leur création, les variables sont initialisées avec la valeur non définie".  Il s'avère que cela signifie «soulèvement».  L'interpréteur JavaScript définit les variables déclarées sur <i>indéfinies</i> lors d'une phase appelée «Création». <br><br>  Pour une étude plus approfondie de la phase de création, «Augmenter» et les étendues, lisez cet article: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Le guide ultime pour le levage, les étendues et les fermetures en JavaScript»</a> . <br><br>  Jetons un coup d'œil à l'exemple précédent et voyons comment le «soulèvement» l'affecte. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">discountPrices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prices, discount</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> discounted = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> discountedPrice = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> finalPrice = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> discounted = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; prices.length; i++) { discountedPrice = prices[i] * (<span class="hljs-number"><span class="hljs-number">1</span></span> - discount) finalPrice = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(discountedPrice * <span class="hljs-number"><span class="hljs-number">100</span></span>) / <span class="hljs-number"><span class="hljs-number">100</span></span> discounted.push(finalPrice) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i) <span class="hljs-comment"><span class="hljs-comment">// 3 console.log(discountedPrice) // 150 console.log(finalPrice) // 150 return discounted }</span></span></code> </pre> <br>  Notez que toutes les variables déclarées ont été définies sur <i>undefined</i> .  C'est pourquoi si vous essayez d'accéder à l'un d'eux avant qu'il ne soit réellement annoncé, vous obtenez simplement <i>undefined</i> . <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">discountPrices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prices, discount</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(discounted) <span class="hljs-comment"><span class="hljs-comment">// undefined var discounted = [] for (var i = 0; i &lt; prices.length; i++) { var discountedPrice = prices[i] * (1 - discount) var finalPrice = Math.round(discountedPrice * 100) / 100 discounted.push(finalPrice) } console.log(i) // 3 console.log(discountedPrice) // 150 console.log(finalPrice) // 150 return discounted }</span></span></code> </pre> <br>  Maintenant que vous savez tout ce dont vous avez besoin sur <i>var</i> , parlons maintenant du but principal pour lequel nous sommes ici: quelle est la différence entre <i>var</i> , <i>let</i> et <i>const</i> ? <br><br><h3>  var, let ou const </h3><br>  Pour commencer, comparons <i>var</i> et <i>let</i> .  La principale différence entre <i>var</i> et <i>let</i> est que, indépendamment de la portée globale et de la portée de la fonction, vous pouvez définir des variables dans la portée du bloc.  Cela signifie que la variable créée avec le mot clé <i>let</i> est disponible à l'intérieur du «bloc» où elle a été créée, ainsi qu'à l'intérieur des blocs imbriqués.  Quand j'ai dit «bloquer», je voulais dire quelque chose entouré d'accolades {}, comme une boucle for ou une <i>instruction if</i> . <br><br>  Et donc, revenons à notre fonction <i>discountPrices</i> pour la dernière fois. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">discountPrices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prices, discount</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> discounted = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; prices.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> discountedPrice = prices[i] * (<span class="hljs-number"><span class="hljs-number">1</span></span> - discount) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> finalPrice = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(discountedPrice * <span class="hljs-number"><span class="hljs-number">100</span></span>) / <span class="hljs-number"><span class="hljs-number">100</span></span> discounted.push(finalPrice) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i) <span class="hljs-comment"><span class="hljs-comment">// 3 console.log(discountedPrice) // 150 console.log(finalPrice) // 150 return discounted }</span></span></code> </pre> <br>  Rappelons que nous avons le droit de sortir <i>i</i> , <i>discountPrice</i> et <i>finalPrice en</i> dehors de la boucle <i>for</i> , car ils ont été déclarés en utilisant <i>var</i> et les variables déclarées en utilisant le mot-clé <i>var</i> sont limitées à la portée de la fonction.  Mais que se passe-t-il maintenant si nous changeons <i>var</i> pour <i>laisser</i> et essayer d'exécuter notre code? <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">discountPrices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prices, discount</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> discounted = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; prices.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> discountedPrice = prices[i] * (<span class="hljs-number"><span class="hljs-number">1</span></span> - discount) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> finalPrice = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(discountedPrice * <span class="hljs-number"><span class="hljs-number">100</span></span>) / <span class="hljs-number"><span class="hljs-number">100</span></span> discounted.push(finalPrice) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i) <span class="hljs-comment"><span class="hljs-comment">// 3 console.log(discountedPrice) // 150 console.log(finalPrice) // 150 return discounted } discountPrices([100, 200, 300], .5) // NOT OK: ReferenceError: i is not defined</span></span></code> </pre> <br>  Nous avons eu <i>ReferenceError: i n'est pas défini</i> .  Ce qui nous dit que la variable déclarée avec <i>let</i> est limitée à la portée du bloc, pas à la fonction.  Essayez d'appeler <i>i</i> (ou <i>discountedPrice</i> ou <i>finalPrice</i> ) en dehors du «bloc» où ils ont été déclarés, et cela nous donnera une erreur d'appel, comme nous venons de le voir. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> VS <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>:     <span class="hljs-keyword"><span class="hljs-keyword">let</span></span>:    </code> </pre> <br>  Les différences suivantes sont liées au «soulèvement».  Nous avons dit plus tôt que la définition de «uplift» est: «L'interpréteur JavaScript définit les variables déclarées sur <i>indéfinies</i> pendant la phase appelée« Création ».« Nous l'avons également vu en action en appelant la variable avant qu'elle ne soit déclarée (vous avez obtenu <i>undefined</i> ). <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">discountPrices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prices, discount</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(discounted) <span class="hljs-comment"><span class="hljs-comment">// undefined var discounted = [] for (var i = 0; i &lt; prices.length; i++) { var discountedPrice = prices[i] * (1 - discount) var finalPrice = Math.round(discountedPrice * 100) / 100 discounted.push(finalPrice) } console.log(i) // 3 console.log(discountedPrice) // 150 console.log(finalPrice) // 150 return discounted }</span></span></code> </pre> <br>  Je ne me souviens pas d'un cas d'utilisation unique lorsque vous souhaitez vraiment accéder à une variable avant de la déclarer.  Il semble qu'obtenir une <i>ReferenceError</i> serait mieux que de ne <i>pas</i> être <i>défini</i> . <br><br>  En fait, c'est ce que <i>laisse</i> faire.  Si vous essayez d'accéder à une variable avant sa déclaration avec <i>let</i> , au lieu d'être <i>indéfini</i> (comme lors de la déclaration avec <i>var</i> ), vous obtiendrez une <i>ReferenceError</i> . <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">discountPrices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prices, discount</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(discounted) <span class="hljs-comment"><span class="hljs-comment">// NOT OK: ReferenceError let discounted = [] for (let i = 0; i &lt; prices.length; i++) { let discountedPrice = prices[i] * (1 - discount) let finalPrice = Math.round(discountedPrice * 100) / 100 discounted.push(finalPrice) } console.log(i) // 3 console.log(discountedPrice) // 150 console.log(finalPrice) // 150 return discounted }</span></span></code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> VS <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>:        <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>         . let:       <span class="hljs-built_in"><span class="hljs-built_in">ReferenceError</span></span>        .</code> </pre> <br><h3>  let or const </h3><br>  Vous comprenez maintenant la différence entre var et let, qu'en est-il de const?  Il s'avère que const est presque identique à let.  Cependant, il y a une différence: si vous avez attribué une valeur à l'aide de const, vous ne pouvez pas la changer en une autre. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = <span class="hljs-string"><span class="hljs-string">'Tyler'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handle = <span class="hljs-string"><span class="hljs-string">'tylermcginnis'</span></span> name = <span class="hljs-string"><span class="hljs-string">'Tyler McGinnis'</span></span> <span class="hljs-comment"><span class="hljs-comment">// OK handle = '@tylermcginnis' // NOT OK: TypeError: Assignment to constant variable.</span></span></code> </pre> <br>  La conclusion de ce qui précède est que les variables déclarées avec <i>let</i> peuvent être écrasées, et les variables déclarées avec <i>const</i> ne le peuvent pas. <br><br>  Génial, maintenant que vous voulez que votre variable soit immuable, vous pouvez la déclarer avec <i>const</i> .  Ou pas vraiment.  Ce n'est pas parce qu'une variable a été déclarée à l'aide de <i>const</i> qu'elle est immuable, cela signifie qu'elle ne peut pas être écrasée.  Voici un bon exemple. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Kim Kardashian'</span></span> } person.name = <span class="hljs-string"><span class="hljs-string">'Kim Kardashian West'</span></span> <span class="hljs-comment"><span class="hljs-comment">// OK person = {} // NOT OK: Assignment to constant variable.</span></span></code> </pre> <br>  Notez que la modification de la propriété d'un objet n'est pas un remplacement, donc même si l'objet est déclaré à l'aide de <i>const</i> , cela ne signifie pas que vous ne pouvez modifier aucune de ses propriétés.  Cela signifie seulement que vous ne pouvez pas remplacer cet objet. <br><br>  Maintenant, la question la plus importante à laquelle on n'a pas encore répondu: que dois-je utiliser <i>var</i> , <i>let</i> ou <i>const</i> ?  L'opinion la plus populaire, à laquelle j'adhère, est de toujours utiliser <i>const</i> jusqu'à ce que vous sachiez si la variable va changer.  La raison en est que l'utilisation de <i>const</i> vous <i>indique</i> clairement à vous-même et aux futurs développeurs qui devraient lire votre code que cette variable ne doit pas être modifiée.  Si vous devez le changer (par exemple dans une boucle <i>for</i> ), utilisez simplement <i>let</i> . <br><br>  Il ne reste pas beaucoup de cas entre les variables qui changent et les variables qui ne changent pas.  Cela signifie que vous n'aurez plus jamais à utiliser <i>var</i> . <br><br>  Maintenant, l'opinion impopulaire, bien qu'elle ait encore une justification, est que vous ne devriez jamais utiliser <i>const</i> , bien que vous essayiez de montrer que cette variable est immuable, comme nous l'avons vu ci-dessus, ce n'est pas entièrement vrai.  Les développeurs qui partagent cette opinion utilisent toujours <i>let</i> tant qu'il n'y a pas de variables qui sont réellement des constantes, telles que _LOCATION_ = .... <br><br>  Faisons un résumé de ce qui précède, <i>var est</i> limité par la portée de la fonction et si vous essayez d'accéder à une telle variable avant sa déclaration, vous obtiendrez <i>undefined</i> .  <i>const</i> et <i>let sont</i> limités par la portée du bloc, et si vous essayez d'accéder à ces variables avant de les déclarer, vous obtenez une <i>ReferenceError</i> .  Et la différence entre <i>const</i> et <i>let</i> est que la valeur qui a été affectée à <i>const</i> ne peut pas être écrasée, contrairement à <i>let</i> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> VS <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> VS <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>:        <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>         . let:       <span class="hljs-built_in"><span class="hljs-built_in">ReferenceError</span></span>        . const:       <span class="hljs-built_in"><span class="hljs-built_in">ReferenceError</span></span>        .    </code> </pre> <br>  Cet article a été initialement publié sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tylermcginnis.com</a> dans le cadre du cours <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JavaScript moderne</a> . <br><br>  <i>Merci d'avoir lu cette traduction, j'espère que vous avez rencontré quelque chose de nouveau et d'utile pour vous.</i>  <i>Je serai heureux de voir les commentaires!</i> </cut></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr438880/">https://habr.com/ru/post/fr438880/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr438868/index.html">Semaine de la sécurité 06: en direct sur FaceTime</a></li>
<li><a href="../fr438870/index.html">Lombok rend la grandeur de Java</a></li>
<li><a href="../fr438874/index.html">Commencer une amitié avec VkNet</a></li>
<li><a href="../fr438876/index.html">Comment raccourcir le time-to-market: une histoire sur l'automatisation des tests dans M. Video</a></li>
<li><a href="../fr438878/index.html">L'apparition du film en torrents après la première augmente le box-office de 3%</a></li>
<li><a href="../fr438882/index.html">La probabilité de gagner un match avec une probabilité connue de gagner un point</a></li>
<li><a href="../fr438884/index.html">Histoire vraie d'une agence de publicité de l'outback: hauts, bas et implémentation CRM</a></li>
<li><a href="../fr438886/index.html">Morty, nous sommes à UltraHD! Comment regarder n'importe quel film en 4K, en le complétant via un réseau neuronal peu connu</a></li>
<li><a href="../fr438890/index.html">Postgres rétrospectivement</a></li>
<li><a href="../fr438892/index.html">Qu'est-ce qu'une blockchain d'entreprise?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>