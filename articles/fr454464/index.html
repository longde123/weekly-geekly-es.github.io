<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍✈️ 👩🏾‍🏭 🔙 Développement de tests visuels basés sur Gemini et Storybook 👩‍🍳 🏐 🧑🏿‍🤝‍🧑🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Dans cet article, je veux partager l'expérience du développement de tests visuels dans notre équipe. 

 Il se trouve que nous n'avons p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Développement de tests visuels basés sur Gemini et Storybook</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454464/">  Bonjour, Habr!  Dans cet article, je veux partager l'expérience du développement de tests visuels dans notre équipe. <br><br>  Il se trouve que nous n'avons pas immédiatement pensé aux tests de mise en page.  Eh bien, une partie du cadre se déplacera sur quelques pixels, enfin, corrigez-la.  En fin de compte, il y a des testeurs - la mouche ne passera pas devant eux.  Mais le facteur humain ne peut toujours pas être dupe - détecter des changements mineurs dans l'interface utilisateur est loin d'être toujours physiquement possible même pour un testeur.  La question s'est posée quand une optimisation sérieuse de la mise en page et de la transition vers BEM a commencé.  Ici, cela n'aurait certainement pas été sans perte, et nous avions désespérément besoin d'un moyen automatisé pour détecter les situations où, à la suite de modifications, quelque chose dans l'interface utilisateur commence à changer pas comme prévu, ou pas là où il était prévu. <br><a name="habracut"></a><br>  Tout développeur connaît les tests de code unitaire.  Les tests unitaires donnent l'assurance que les changements dans le code n'ont rien cassé.  Eh bien, au moins, ils n'ont pas cassé la partie pour laquelle il y a des tests.  Le même principe peut être appliqué à l'interface utilisateur.  Tout comme les tests unitaires testent les classes, les tests visuels testent les composants visuels qui composent l'interface utilisateur d'une application. <br><br>  Pour les composants visuels, vous pouvez écrire des tests unitaires «classiques» qui, par exemple, lancent le rendu des composants avec différentes valeurs de paramètres d'entrée et vérifient l'état attendu de l'arborescence DOM à l'aide des instructions assert, en comparant des éléments individuels ou un instantané de l'arborescence DOM du composant avec la référence en général.  Les tests visuels sont également basés sur des instantanés, mais déjà sur des instantanés de l'affichage visuel du composant (captures d'écran).  L'essence du test visuel est de comparer l'image prise pendant le test avec celle de référence et, si des différences sont trouvées, d'accepter la nouvelle image comme référence ou de corriger le bogue à l'origine de ces différences. <br><br>  Bien sûr, le «filtrage» des composants visuels individuels n'est pas très efficace.  Les composants ne vivent pas dans le vide et leur affichage peut dépendre soit des composants de niveau supérieur, soit des composants voisins.  Peu importe la façon dont nous testons les composants individuels, l'image dans son ensemble peut présenter des défauts.  D'un autre côté, si vous prenez des photos de toute la fenêtre de l'application, alors la plupart des images contiendront les mêmes composants, ce qui signifie que si vous changez un composant, nous serons obligés de mettre à jour toutes les images dans lesquelles ce composant est présent. <br><br>  La vérité, comme d'habitude, se situe quelque part au milieu - vous pouvez dessiner la page entière de l'application, mais prenez une photo d'une seule zone sous laquelle le test est créé, dans le cas particulier, cette zone peut coïncider avec la zone d'un composant spécifique, mais ce ne sera pas un composant vide, mais dans un environnement très réel.  Et cela sera déjà similaire à un test visuel unitaire, bien que l'on puisse difficilement en dire autant sur la modularité si «l'unité» sait quelque chose sur l'environnement.  Bon, d'accord, ce n'est pas si important que la catégorie de tests inclue des tests visuels - modulaires ou d'intégration.  Comme le dit le proverbe, "vous vérifiez ou partez?" <br><br><h2>  Sélection d'outils </h2><br>  Pour accélérer l'exécution des tests, le rendu des pages peut être effectué dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">navigateur sans tête</a> qui fait tout le travail en mémoire sans être affiché à l'écran et garantit des performances maximales.  Mais dans notre cas, il était essentiel de s'assurer que l'application fonctionne dans Internet Explorer (IE), qui n'a pas de mode sans tête, et nous avions besoin d'un outil de gestion de navigateur programmatique.  Heureusement, tout a déjà été inventé avant nous et il existe un tel instrument - il s'appelle le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sélénium</a> .  Dans le cadre du projet Selenium, des pilotes sont en cours de développement pour gérer différents navigateurs, dont un pilote pour IE.  Le serveur Selenium peut gérer les navigateurs non seulement localement, mais également à distance, formant un cluster de serveurs sélénium, la soi-disant grille de sélénium. <br><br>  Le sélénium est un outil puissant, mais le seuil pour y entrer est assez élevé.  Nous avons décidé de chercher des outils prêts à l'emploi pour les tests visuels basés sur le sélénium et sommes tombés sur un merveilleux produit de Yandex appelé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Gemini</a> .  Les Gémeaux peuvent prendre des photos, y compris des photos d'une certaine zone de la page, comparer des photos avec des références, visualiser la différence et prendre en compte des moments tels que l'anticrénelage ou un curseur clignotant.  De plus, Gemini peut effectuer des réexécutions de tests supprimés, paralléliser l'exécution de tests et de nombreux autres goodies.  En général, nous avons décidé d'essayer. <br><br>  Les tests Gemini sont faciles à écrire.  Vous devez d'abord préparer l'infrastructure - installez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">selenium-standalone</a> et démarrez le serveur selenium.  Configurez ensuite gemini, en spécifiant l'adresse de l'application en cours de test (rootUrl), l'adresse du serveur sélénium (gridUrl), la composition et la configuration des navigateurs, ainsi que les plugins nécessaires pour générer des rapports, optimiser la compression d'image.  Exemple de configuration: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//.gemini.js module.exports = { rootUrl: 'http://my-app.ru', gridUrl: 'http://127.0.0.1:4444/wd/hub', browsers: { chrome: { windowSize: '1920x1080', screenshotsDir:'gemini/screens/1920x1080' desiredCapabilities: { browserName: 'chrome' } } }, system: { projectRoot: '', plugins: { 'html-reporter/gemini': { enabled: true, path: './report' }, 'gemini-optipng': true }, exclude: [ '**/report/*' ], diffColor: '#EC041E' } };</span></span></code> </pre> <br>  Les tests eux-mêmes sont une collection de suites, dans chacune desquelles une ou plusieurs photos (états) sont prises.  Avant de prendre un instantané (méthode capture ()), vous pouvez définir la zone de la page à photographier à l'aide de la méthode setCaptureElements (), et également effectuer des actions préparatoires si nécessaire dans le contexte du navigateur en utilisant les méthodes de l'objet actions ou en utilisant du code JavaScript arbitraire - pour ceci dans les actions a une méthode executeJS (). <br><br>  Un exemple: <br><br><pre> <code class="javascript hljs">gemini.suite(<span class="hljs-string"><span class="hljs-string">'login-dialog'</span></span>, suite =&gt; { suite.setUrl(<span class="hljs-string"><span class="hljs-string">'/'</span></span>) .setCaptureElements(<span class="hljs-string"><span class="hljs-string">'.login__form'</span></span>) .capture(<span class="hljs-string"><span class="hljs-string">'default'</span></span>); .capture(<span class="hljs-string"><span class="hljs-string">'focused'</span></span>, actions =&gt; actions.focus(<span class="hljs-string"><span class="hljs-string">'.login__editor'</span></span>)); });</code> </pre> <br><h2>  Données de test </h2><br>  Un outil de test a été choisi, mais c'était encore loin de la solution finale.  Il était nécessaire de comprendre quoi faire avec les données affichées dans les images.  Permettez-moi de vous rappeler que dans les tests, nous avons décidé de dessiner non pas des composants individuels, mais la page entière de l'application afin de tester les composants visuels non pas dans le vide, mais dans l'environnement réel d'autres composants.  Si vous devez transférer les données de test nécessaires aux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">accessoires</a> ee (je parle de composants React) pour rendre un composant individuel, beaucoup plus est nécessaire pour rendre la page entière de l'application, et préparer l'environnement pour un tel test peut être un casse-tête. <br><br>  Bien sûr, vous pouvez laisser l'application elle-même pour recevoir les données, de sorte qu'au cours du test, elle exécutera des requêtes vers le backend, qui, à son tour, recevrait les données d'une sorte de base de données de référence, mais qu'en est-il du versioning?  Vous ne pouvez pas placer une base de données dans un référentiel git.  Non, bien sûr que vous pouvez, mais il y a des décences. <br><br>  Alternativement, pour exécuter des tests, vous pouvez remplacer le vrai serveur principal par un faux, ce qui donnerait à l'application Web non pas des données de la base de données, mais des données statiques stockées, par exemple, au format json, déjà avec les sources.  Cependant, la préparation de ces données n'est pas non plus trop triviale.  Nous avons décidé d'aller plus facilement - non pas pour extraire les données du serveur, mais simplement pour restaurer l'état de l'application (dans notre cas, l'état du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">stockage redux</a> ), qui était dans l'application au moment où l'image de référence a été prise, avant d'exécuter le test. <br><br>  Pour sérialiser l'état actuel du magasin redux, la méthode snapshot () a été ajoutée à l'objet window: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> snapshotStore = (store: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>, <span class="hljs-attr"><span class="hljs-attr">fileName</span></span>: string): <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">string</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = store.getState(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> file = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Blob( [ <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(state, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) ], { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span> } ); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'a'</span></span>); a.href = URL.createObjectURL(file); a.download = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${fileName}</span></span></span><span class="hljs-string">.testdata.json`</span></span>; a.click(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`State downloaded to </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${a.download}</span></span></span><span class="hljs-string">`</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> store = createStore(reducer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (process.env.NODE_ENV !== <span class="hljs-string"><span class="hljs-string">'production'</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.snapshot = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fileName</span></span></span><span class="hljs-function"> =&gt;</span></span> snapshotStore(store, fileName); };</code> </pre><br>  En utilisant cette méthode, en utilisant la ligne de commande de la console du navigateur, vous pouvez enregistrer l'état actuel du stockage redux dans un fichier: <br><br><img src="https://habrastorage.org/webt/qf/t0/yq/qft0yqppzfe_issnjy74jon-vbs.png" alt="image"><br><br>  En tant qu'infrastructure pour les tests visuels, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Storybook a</a> été choisi - un outil pour le développement interactif de bibliothèques de composants visuels.  L'idée principale était qu'au lieu des différents états des composants dans l'arbre des histoires, corrigez les différents états de notre application et utilisez ces états pour prendre des captures d'écran.  Au final, il n'y a pas de différence fondamentale entre les composants simples et complexes, sauf dans la préparation de l'environnement. <br><br>  Ainsi, chaque test visuel est une histoire, avant le rendu dont l'état du stockage redux précédemment enregistré dans le fichier est restauré.  Cela se fait à l'aide du composant Provider de la bibliothèque react-redux, à la propriété store dont l'état désérialisé restauré à partir du fichier précédemment enregistré est transmis: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> preloadedState <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./incoming-letter.testdata'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> store = createStore(rootReducer, preloadedState); storiesOf(<span class="hljs-string"><span class="hljs-string">'regression/Cards'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>) .add(<span class="hljs-string"><span class="hljs-string">'IncomingLetter'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Provider</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">store</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{store}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MemoryRouter</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ContextContainer</span></span></span></span><span class="xml"><span class="hljs-tag"> {</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">...dummyProps</span></span></span></span><span class="xml"><span class="hljs-tag">}/&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MemoryRouter</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Provider</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ); });</span></span></code> </pre><br>  Dans l'exemple ci-dessus, ContextContainer est un composant qui inclut le "squelette" de l'application - l'arborescence de navigation, l'en-tête et la zone de contenu.  Dans la zone de contenu, différents composants peuvent être rendus (liste, carte, boîte de dialogue, etc.) en fonction de l'état actuel du stockage redux.  Pour que le composant ne réponde pas aux demandes d'entrée inutiles du backend, les propriétés de stub correspondantes lui sont transmises. <br><br>  Dans le contexte d'un livre de contes, cela ressemble à ceci: <br><br><img src="https://habrastorage.org/webt/jx/0m/ux/jx0muxytucrqrwzpvtnskjuqs1a.png" alt="image"><br><br><h2>  Gemini + storybook </h2><br>  Nous avons donc trouvé les données pour les tests.  La prochaine tâche consiste à se faire des amis Gemini et Storybook.  À première vue, tout est simple - dans la configuration Gemini, nous spécifions l'adresse de l'application testée.  Dans notre cas, il s'agit de l'adresse du serveur Storybook.  Il vous suffit d'augmenter le serveur du livre d'histoires avant de commencer les tests gemini.  Vous pouvez le faire directement à partir du code en utilisant l'abonnement à l'événement Gemini START_RUNNER et END_RUNNER: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> port = <span class="hljs-number"><span class="hljs-number">6006</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cofiguration = { <span class="hljs-attr"><span class="hljs-attr">rootUrl</span></span>:<span class="hljs-string"><span class="hljs-string">`localhost:</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${port}</span></span></span><span class="hljs-string">`</span></span>, <span class="hljs-attr"><span class="hljs-attr">gridUrl</span></span>: seleniumGridHubUrl, <span class="hljs-attr"><span class="hljs-attr">browsers</span></span>: { <span class="hljs-string"><span class="hljs-string">'chrome'</span></span>: { <span class="hljs-attr"><span class="hljs-attr">screenshotsDir</span></span>:<span class="hljs-string"><span class="hljs-string">'gemini/screens'</span></span>, <span class="hljs-attr"><span class="hljs-attr">desiredCapabilities</span></span>: chromeCapabilities } } }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Gemini = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'gemini'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> HttpServer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http-server'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> runner = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Gemini(cofiguration); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = HttpServer.createServer({ <span class="hljs-attr"><span class="hljs-attr">root</span></span>: <span class="hljs-string"><span class="hljs-string">'./storybook-static'</span></span>}); runner.on(runner.events.START_RUNNER, () =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`storybook server is listening on </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${port}</span></span></span><span class="hljs-string">...`</span></span>); server.listen(port); }); runner.on(runner.events.END_RUNNER, () =&gt; { server.close(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'storybook server is closed'</span></span>); }); runner .readTests(path) .done(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tests</span></span></span><span class="hljs-function"> =&gt;</span></span> runner.test(tests));</code> </pre> <br>  En tant que serveur pour les tests, nous avons utilisé http-server, qui renvoie le contenu du dossier avec le livre de contes statique (pour construire le livre de contes statique, utilisez la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">commande build-storybook</a> ). <br><br>  Jusqu'à présent, tout s'est bien passé, mais les problèmes ne se sont pas fait attendre.  Le fait est que le livre de contes affiche l'histoire à l'intérieur du cadre.  Initialement, nous voulions pouvoir définir la région sélective de l'image à l'aide de setCaptureElements (), mais cela ne peut être fait que si vous spécifiez l'adresse du cadre comme adresse pour la suite, quelque chose comme ceci: <br><br><pre> <code class="javascript hljs">gemini.suite(<span class="hljs-string"><span class="hljs-string">'VisualRegression'</span></span>, suite =&gt; suite.setUrl(<span class="hljs-string"><span class="hljs-string">'http://localhost:6006/iframe.html?selectedKind=regression%2Fcards&amp;selectedStory=IncomingLetter'</span></span>) .setCaptureElements(<span class="hljs-string"><span class="hljs-string">'.some-component'</span></span>) .capture(<span class="hljs-string"><span class="hljs-string">'IncomingLetter'</span></span>) );</code> </pre><br>  Mais il s'avère que pour chaque plan, nous devons créer notre propre suite, car  L'URL peut être définie pour la suite dans son ensemble, mais pas pour un instantané unique dans la suite.  Il faut comprendre que chaque suite s'exécute dans une session de navigateur distincte.  Ceci, en principe, est correct - les tests ne devraient pas dépendre les uns des autres, mais l'ouverture d'une session de navigateur distincte et le chargement subséquent du livre d'histoires prennent beaucoup de temps, bien plus que de simplement parcourir les histoires dans le cadre du livre d'histoires déjà ouvert.  Par conséquent, avec un grand nombre de suites, le temps d'exécution du test est très lent.  Une partie du problème peut être résolue en parallélisant l'exécution des tests, mais la parallélisation consomme beaucoup de ressources (mémoire, processeur).  Par conséquent, ayant décidé d'économiser sur les ressources et en même temps de ne pas trop perdre dans la durée du test, nous avons refusé d'ouvrir le cadre dans une fenêtre de navigateur distincte.  Les tests sont effectués dans une seule session de navigateur, mais avant chaque prise de vue, l'histoire suivante est chargée dans le cadre comme si nous ouvrions simplement le livre d'histoires et cliquions sur des nœuds individuels dans l'arborescence des histoires.  Zone d'image - cadre entier: <br><br><pre> <code class="javascript hljs">gemini.suite(<span class="hljs-string"><span class="hljs-string">'VisualRegression'</span></span>, suite =&gt; suite.setUrl(<span class="hljs-string"><span class="hljs-string">'/'</span></span>) .setCaptureElements(<span class="hljs-string"><span class="hljs-string">'#storybook-preview-iframe'</span></span>) .capture(<span class="hljs-string"><span class="hljs-string">'IncomingLetter'</span></span>, actions =&gt; openStory(actions, <span class="hljs-string"><span class="hljs-string">'IncomingLetter'</span></span>)) .capture(<span class="hljs-string"><span class="hljs-string">'ProjectDocument'</span></span>, actions =&gt; openStory(actions, <span class="hljs-string"><span class="hljs-string">'ProjectDocumentAccess'</span></span>)) .capture(<span class="hljs-string"><span class="hljs-string">'RelatedDocuments'</span></span>, actions =&gt; { openStory(actions, <span class="hljs-string"><span class="hljs-string">'RelatedDocuments'</span></span>); hover(actions, <span class="hljs-string"><span class="hljs-string">'.related-documents-tree-item__title'</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); }) );</code> </pre> <br>  Malheureusement, dans cette option, en plus de la possibilité de sélectionner la zone d'image, nous avons également perdu la possibilité d'utiliser des actions standard du moteur Gemini pour travailler avec des éléments de l'arborescence DOM (mouseDown (), mouseMove (), focus (), etc.), etc. à.  Les éléments du cadre Gemini ne «voient» pas.  Mais nous avons toujours la possibilité d'utiliser la fonction executeJS (), avec laquelle vous pouvez exécuter du code JavaScript dans un contexte de navigateur.  Sur la base de cette fonction, nous avons implémenté les analogues d'actions standard dont nous avons besoin, qui fonctionnent déjà dans le contexte du cadre Storybook.  Ici, nous avons dû «conjurer» un peu afin de transférer les valeurs des paramètres du contexte de test au contexte du navigateur - executeJS (), malheureusement, ne fournit pas une telle opportunité.  Par conséquent, à première vue, le code semble un peu étrange - la fonction est traduite en chaîne, une partie du code est remplacée par des valeurs de paramètre, et dans ExecuteJs () la fonction est restaurée à partir de la chaîne en utilisant eval (): <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">openStory</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">actions, storyName</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> storyNameLowered = storyName.toLowerCase(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> clickTo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">window</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.from(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.document.querySelectorAll(<span class="hljs-string"><span class="hljs-string">'a'</span></span>)).filter( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> el.textContent.toLowerCase() === <span class="hljs-string"><span class="hljs-string">'storyNameLowered'</span></span>; })[<span class="hljs-number"><span class="hljs-number">0</span></span>].click(); }; actions.executeJS(<span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(<span class="hljs-string"><span class="hljs-string">`(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${clickTo.toString().replace(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'storyNameLowered'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">, storyNameLowered)}</span></span></span><span class="hljs-string">)`</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispatchEvents</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">actions, targets, index, events</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dispatch = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">window</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">document</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.document.querySelector(<span class="hljs-string"><span class="hljs-string">'#storybook-preview-iframe'</span></span>).contentWindow.document; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> target = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelectorAll(<span class="hljs-string"><span class="hljs-string">'targets'</span></span>)[index || <span class="hljs-number"><span class="hljs-number">0</span></span>]; events.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> clickEvent = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createEvent(<span class="hljs-string"><span class="hljs-string">'MouseEvents'</span></span>); clickEvent.initEvent(event, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); target.dispatchEvent(clickEvent); }); }; actions.executeJS(<span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(<span class="hljs-string"><span class="hljs-string">`(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${dispatch.toString() .replace(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'targets'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">, targets) .replace(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'index'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">, index) .replace(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'events'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">, </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">`["</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${events.join(</span></span></span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'","'</span></span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">)}</span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">"]`</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">)`</span></span> )); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hover</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">actions, selectors, index</span></span></span><span class="hljs-function">) </span></span>{ dispatchEvents(actions, selectors, index, [ <span class="hljs-string"><span class="hljs-string">'mouseenter'</span></span>, <span class="hljs-string"><span class="hljs-string">'mouseover'</span></span> ]); } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { <span class="hljs-attr"><span class="hljs-attr">openStory</span></span>: openStory, <span class="hljs-attr"><span class="hljs-attr">hover</span></span>: hover };</code> </pre><br><h2>  Répétitions d'exécution </h2><br>  Après que les tests visuels ont été écrits et ont commencé à fonctionner, il s'est avéré que certains des tests n'étaient pas très stables.  Quelque part, l'icône n'aura pas le temps de dessiner, quelque part la sélection ne sera pas supprimée et nous obtenons un décalage avec l'image de référence.  Par conséquent, il a été décidé d'inclure de nouveaux tests d'exécution des tests.  Cependant, dans Gemini, les tentatives fonctionnent pour toute la suite, et comme mentionné ci-dessus, nous avons essayé d'éviter les situations où une suite est faite pour chaque prise de vue - cela ralentit trop l'exécution des tests.  En revanche, plus il y a de prises de vue dans le cadre d'une suite, plus il y a de chances que l'exécution répétée de la suite tombe ainsi que la précédente.  Par conséquent, il était nécessaire d'implémenter de nouvelles tentatives.  Dans notre schéma, la répétition de l'exécution n'est pas effectuée pour l'ensemble de la suite, mais uniquement pour les images qui n'ont pas été transmises lors de l'exécution précédente.  Pour ce faire, dans le gestionnaire d'événements TEST_RESULT, nous analysons le résultat de la comparaison de l'instantané avec la norme, et pour les instantanés qui n'ont pas réussi la comparaison, et seulement pour eux, nous créons une nouvelle suite: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SuiteCollection = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'gemini/lib/suite-collection'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Suite = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'gemini/lib/suite'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> retrySuiteCollection; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> retryCount = <span class="hljs-number"><span class="hljs-number">2</span></span>; runner.on(runner.events.BEGIN, () =&gt; { retrySuiteCollection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SuiteCollection(); }); runner.on(runner.events.TEST_RESULT, args =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testId = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${args.state.name}</span></span></span><span class="hljs-string">/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${args.suite.name}</span></span></span><span class="hljs-string">/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${args.browserId}</span></span></span><span class="hljs-string">`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!args.equal) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (retryCount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chalk.yellow(<span class="hljs-string"><span class="hljs-string">`failed </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${testId}</span></span></span><span class="hljs-string">`</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chalk.red(<span class="hljs-string"><span class="hljs-string">`failed </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${testId}</span></span></span><span class="hljs-string">`</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> suite = retrySuiteCollection.topLevelSuites().find(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> s.name === args.suite.name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!suite) { suite = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Suite(args.suite.name); suite.url = args.suite.url; suite.file = args.suite.file; suite.path = args.suite.path; suite.captureSelectors = [ ...args.suite.captureSelectors ]; suite.browsers = [ ...args.suite.browsers ]; suite.skipped = [ ...args.suite.skipped ]; suite.beforeActions = [ ...args.suite.beforeActions ]; retrySuiteCollection.add(suite); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!suite.states.find(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> s.name === args.state.name)) { suite.addState(args.state.clone()); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chalk.green(<span class="hljs-string"><span class="hljs-string">`passed </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${testId}</span></span></span><span class="hljs-string">`</span></span>)); });</code> </pre> <br>  Soit dit en passant, l'événement TEST_RESULT a également été utile pour visualiser la progression des tests au fur et à mesure de leur réussite.  Maintenant, le développeur n'a pas besoin d'attendre que tous les tests soient terminés, il peut interrompre l'exécution s'il voit que quelque chose s'est mal passé.  Si l'exécution du test est interrompue, Gemini fermera correctement les sessions du navigateur ouvertes par le serveur sélénium. <br><br>  Une fois le test terminé, si la nouvelle suite n'est pas vide, exécutez-la jusqu'à ce que le nombre maximal de répétitions soit épuisé: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onComplete</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((retryCount--) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; result.failed &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; retrySuiteCollection.topLevelSuites().length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { runner.test(retrySuiteCollection, {}).done(onComplete); } } runner.readTests(path).done(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tests</span></span></span><span class="hljs-function"> =&gt;</span></span> runner.test(tests).done(onComplete));</code> </pre> <br><h2>  Résumé </h2><br>  Nous avons aujourd'hui une cinquantaine de tests visuels couvrant les principaux états visuels de notre application.  Bien sûr, il n'est pas nécessaire de parler de la couverture complète des tests d'interface utilisateur, mais nous n'avons pas encore fixé un tel objectif.  Les tests fonctionnent avec succès à la fois sur les postes de travail des développeurs et sur les agents de build.  Bien que les tests soient effectués uniquement dans le contexte de Chrome et d'Internet Explorer, mais à l'avenir, il est possible de connecter d'autres navigateurs.  Toute cette économie dessert le réseau Selemium avec deux nœuds déployés sur des machines virtuelles. <br><br>  De temps en temps, nous sommes confrontés au fait qu'après la sortie de la nouvelle version de Chrome il est nécessaire de mettre à jour les images de référence car certains éléments ont commencé à apparaître un peu différemment (par exemple, les scrollers), mais il n'y a rien à faire.  C'est rare, mais il arrive que lorsque vous modifiez la structure d'un magasin de redux, vous devez récupérer à nouveau les états enregistrés pour les tests.  Il n'est bien sûr pas facile de restaurer exactement le même état que celui qui était à l'essai au moment de sa création.  En règle générale, personne ne se souvient déjà de la base de données sur laquelle ces photos ont été prises et vous devez prendre une nouvelle photo sur d'autres données.  C'est un problème, mais pas un gros.  Pour le résoudre, vous pouvez prendre des photos sur une base de démonstration, car nous avons des scripts pour sa génération et nous sommes tenus à jour. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr454464/">https://habr.com/ru/post/fr454464/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr454452/index.html">Nous affichons le contenu sur l'image reconnue selon certaines règles</a></li>
<li><a href="../fr454456/index.html">Formation Cisco 200-125 CCNA v3.0. Jour 7. FAQ</a></li>
<li><a href="../fr454458/index.html">Tests métamorphiques: pourquoi presque personne ne connaît cette technique prometteuse</a></li>
<li><a href="../fr454460/index.html">Le condensé de matériaux intéressants pour le développeur mobile # 300 (27 mai - 2 juin)</a></li>
<li><a href="../fr454462/index.html">Photogramme sans papier photo</a></li>
<li><a href="../fr454470/index.html">La vie avant l'exécution. Rapport Yandex</a></li>
<li><a href="../fr454472/index.html">Ce que vous devez savoir sur le dernier correctif de routeur de Cisco</a></li>
<li><a href="../fr454474/index.html">Événements numériques à Moscou du 3 au 9 juin</a></li>
<li><a href="../fr454476/index.html">Meilleures pratiques Node.js - Conseils sur la structure du projet</a></li>
<li><a href="../fr454478/index.html">Annonce de l'extension des outils Azure IoT Edge (préversion)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>