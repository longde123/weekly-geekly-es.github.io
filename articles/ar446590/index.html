<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐵 🥘 🧖🏾 39 ميزات جديدة لتكون متاحة في جافا 12 😠 🧑🏼 🧜🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="من مقابلة رائعة مع هابري: "سيمون ريتر هو شخص عمل على جافا منذ البداية ويستمر في القيام بذلك كنائب المدير التقني لأزول ، وهي شركة تعمل على آلة Zing JVM...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>39 ميزات جديدة لتكون متاحة في جافا 12</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446590/" style=";text-align:right;direction:rtl"><blockquote style=";text-align:right;direction:rtl">  من <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مقابلة رائعة مع</a> هابري: "سيمون ريتر هو شخص عمل على جافا منذ البداية ويستمر في القيام بذلك كنائب المدير التقني لأزول ، وهي شركة تعمل على آلة Zing JVM الافتراضية وأحد أفضل جامعي القمامة ، C4 (Continuously Concurrent Compacting جامع) » <br>  فيما يلي ترجمة لمقالته حول ميزات JDK 12 الجديدة وبعض الصعوبات التي قد تواجهها عند الترحيل إلى بنية جديدة. </blockquote><p style=";text-align:right;direction:rtl"> كتبت العديد من منشورات المدونة التي تسرد جميع التغييرات لكل من أحدث إصدارات Java ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">JDK 10</a> ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">JDK 11</a> ).  سأستكشف الآن الجانب المظلم من JDK 12 ، مع التركيز على بعض المزالق التي يمكن أن تسبب مشاكل إذا كنت ترغب في نقل التطبيق إلى هذا الإصدار. </p><br><img src="https://habrastorage.org/webt/0e/rn/j0/0ernj0wwnqnwdejls6zvzjup5k8.png"><br><p style=";text-align:right;direction:rtl"><a name="habracut"></a>  يحتوي JDK 12 على أقل عدد من الميزات الجديدة من جميع إصدارات Java حتى الآن (لقد عدت 109 في JDK 10 و 90 في JDK 11).  هذا ليس سيئًا - نظرًا لوجود دورات إطلاق ، ستتضمن بعض الإصدارات مزيدًا من التغييرات وبعضها أقل. </p><br><p style=";text-align:right;direction:rtl">  سوف أقسم الوظائف الجديدة إلى مناطق منطقية واضحة: Java والمكتبات و JVM ووظائف JDK الأخرى. </p><br><h2 style=";text-align:right;direction:rtl">  تغييرات اللغة </h2><br><p style=";text-align:right;direction:rtl">  إن الوظيفة التي أراها I (وافترض أن العديد من الأشخاص الآخرين) ستراعي الأكثر وضوحًا في JDK 12 هي بيان التبديل الجديد ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">JEP 325</a> ).  هذا هو أيضًا تغيير اللغة الأول الذي يتم استخدامه كدالة "للمعاينة".  تم تقديم فكرة "المعاينة" في أوائل عام 2018 كجزء من <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">JEP 12</a> .  هذه في الأساس طريقة لتمكين إصدارات بيتا من الميزات الجديدة باستخدام خيارات سطر الأوامر.  باستخدام المعاينة ، لا يزال من الممكن إجراء تغييرات بناءً على ملاحظات المستخدم ، وفي أسوأ الحالات ، قم بإزالة الوظيفة بالكامل إذا لم يتم استلامها بشكل صحيح.  مفتاح معاينة الوظائف هو أنها غير مضمنة في مواصفات Java SE.  حول التبديل الجديد هناك <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">ترجمة جيدة للغاية</a> على حبري. <br>  في JDK 12 ، أصبح المحول تعبيرًا يقيم "محتواه" لإنتاج نتيجة.  سأوضح على الفور أن هذا لا يؤثر على التوافق مع الإصدارات السابقة ، لذلك لن تحتاج إلى تغيير أي رمز يستخدم التبديل كمشغل. </p><br><p style=";text-align:right;direction:rtl">  سأستخدم المثال من JEP ، لأنه بسيط وواضح: </p><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">التبديل القديم</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numLetters; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (day) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MONDAY: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FRIDAY: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SUNDAY: numLetters = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TUESDAY: numLetters = <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> THURSDAY: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SATURDAY: numLetters = <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> WEDNESDAY: numLetters = <span class="hljs-number"><span class="hljs-number">9</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"Huh? "</span></span> + day); }</code> </pre> </div></div><br><p style=";text-align:right;direction:rtl">  كما ترون ، نقوم بتعيين يوم من أيام الأسبوع على اسم <code>day</code> المتغير ، ثم <code>numLetters</code> بتعيين قيمة <code>numLetters</code> .  الآن بعد أن أصبح رمز التبديل عاملًا ، يمكننا أن نقوم بتعيين مرة واحدة (مما يقلل بشكل كبير من احتمال وجود رمز خطأ) باستخدام نتيجة بيان التبديل: </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numLetters = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (day) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MONDAY, FRIDAY, SUNDAY -&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TUESDAY -&gt; <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> THURSDAY, SATURDAY -&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> WEDNESDAY -&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"Huh? "</span></span> + day); };</code> </pre> <br><p style=";text-align:right;direction:rtl">  ستلاحظ بسرعة تغييرين في بناء الجملة.  عثر مطورو OpenJDK على وظيفة بناء جملة غير معروفة تسمى قائمة مفصولة بفواصل.  أيضا عامل التعبير lambda <code>-&gt;</code> يجعل إرجاع القيمة أسهل.  لا يزال بإمكانك استخدام <code>break</code> بقيمة إذا كنت تريد ذلك حقًا.  هناك العديد من التفاصيل الأخرى حول هذه الميزة ، ولكن من المحتمل أن يكون من السهل قراءة JEP. </p><br><h2 style=";text-align:right;direction:rtl">  المكتبات </h2><br><p style=";text-align:right;direction:rtl">  هناك تغيير واحد أجده مفيدًا للغاية.  هناك أيضا عدد من الثانوية. </p><br><h3 style=";text-align:right;direction:rtl">  جامع teeing </h3><br><p style=";text-align:right;direction:rtl">  يحتوي Stream API ، كالمعتاد ، على أداة تجميع جديدة ، يتم توفيرها بواسطة فئة الأداة المساعدة Collectors.  يمكن الحصول على أداة تجميع جديدة باستخدام طريقة <code>teeing()</code> .  يأخذ جامع teeing ثلاث حجج: جامعان و bifunction.  لفهم عمل هذا المجمع ، أوصي <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">بهذا المقال عن حبري</a> . <br>  لفهم كيف يفعل هذا ، قمت برسم مخطط: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/821/2db/503/8212db5034c04db49aed57dd44697b22.jpg" alt="صورة"><br><p style=";text-align:right;direction:rtl">  يتم تمرير جميع القيم من دفق الإدخال إلى كل جامع.  يتم تمرير نتيجة كل جامع كوسيطات إلى BiFunction وتوليد النتيجة النهائية. </p><br><p style=";text-align:right;direction:rtl">  مثال بسيط هو حساب متوسط ​​القيمة (نعم ، أعلم أن هناك بالفعل جامعي لهذا ، مثل <code>averagingInt()</code> ، ولكن هذا مثال بسيط للمساعدة في فهم المفهوم). </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/* Assume Collectors is statically imported */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> average = Stream.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) .collect(teeing( summingDouble(i -&gt; i), counting(), (sum, n) -&gt; sum / n) );</code> </pre> <br><p style=";text-align:right;direction:rtl">  يقوم المجمع الأول بحساب مجموع دفق الإدخال ، والثاني - عدد العناصر.  تقسم BiFunction المجموع على عدد العناصر للحصول على القيمة المتوسطة. </p><br><h3 style=";text-align:right;direction:rtl">  java.io </h3><br><p style=";text-align:right;direction:rtl">  <code>InputStream skipNBytes(long n)</code> - يتخطى ويتجاهل بالضبط بايت n من دفق الإدخال InputStream.  إذا كان n هو صفر أو أقل ، فلن يتم تخطي وحدات البايت. </p><br><h3 style=";text-align:right;direction:rtl">  java.lang </h3><br><p style=";text-align:right;direction:rtl">  ظهرت حزمة جديدة ، java.lang.constant ، والتي تعد <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">جزءًا من واجهة برمجة تطبيقات JVM الثابتة ، JEP 334</a> . </p><br><p style=";text-align:right;direction:rtl">  يحتوي كل ملف فئة Java على تجمع ثابت يخزّن المعاملات للحصول على تعليمات bytecode في الفصل الدراسي.  يصعب على المطورين معالجة ملفات الفصل بسبب مشاكل في تحميل الفئات.  توفر واجهة برمجة تطبيقات JVM الثابتة أنواع مرجعية رمزية لوصف كل شكل من أشكال ثابت (فئة ، ثابت قابل للتحميل ، <code>MethodHandle</code> ، <code>MethodHandle</code> ثابت ، <code>MethodType</code> ثابت). </p><br><p style=";text-align:right;direction:rtl">  كما أثرت في العديد من الطبقات الأخرى.  تحتوي جميع الفئات التالية الآن على <code>describeConstable()</code> طريقة: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  فئة </li><li style=";text-align:right;direction:rtl">  مزدوج </li><li style=";text-align:right;direction:rtl">  التعداد </li><li style=";text-align:right;direction:rtl">  عوامة </li><li style=";text-align:right;direction:rtl">  عدد صحيح </li><li style=";text-align:right;direction:rtl">  طويل </li><li style=";text-align:right;direction:rtl">  سلسلة </li><li style=";text-align:right;direction:rtl">  MethodHandle </li><li style=";text-align:right;direction:rtl">  MethodType </li><li style=";text-align:right;direction:rtl">  VarHandle </li></ul><br><p style=";text-align:right;direction:rtl">  كوني بريطاني ، أجد أنه أمر مضحك للغاية.  مصطلح كونستابل ، <code>describeConstable</code> كونستابل يستخدم منذ القرن الحادي عشر ، وهذه هي الطريقة التي نشير فيها إلى ضباط الشرطة.  وهو أيضًا اسم الفنان الشهير في القرن الثامن عشر ، جون كونستابل.  هذا يجعلني أتساءل عما إذا كانت طريقة <code>describeTurner()</code> ستكون في إصدار مستقبلي.  من الواضح ، أنه في هذه الحالة هو اختصار للطاولة <code>Constant Table</code> ، لا يتعلق بموظف قانوني أو رسام المناظر الطبيعية. </p><br><p style=";text-align:right;direction:rtl">  تتضمن الفئات التالية الآن أسلوب <code>resolveConstantDesc()</code> : </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  مزدوج </li><li style=";text-align:right;direction:rtl">  Enum.EnumDesc </li><li style=";text-align:right;direction:rtl">  عوامة </li><li style=";text-align:right;direction:rtl">  عدد صحيح </li><li style=";text-align:right;direction:rtl">  طويل </li><li style=";text-align:right;direction:rtl">  سلسلة </li></ul><br><h3 style=";text-align:right;direction:rtl">  java.lang.Character </h3><br><p style=";text-align:right;direction:rtl">  تم تحديث الطبقات الداخلية لتشمل كتل يونيكود جديدة.  أرغب دائمًا في رؤية ما وجده الأشخاص لإضافته إلى Unicode ، فيما يلي بعض الأمثلة: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  رموز الشطرنج </li><li style=";text-align:right;direction:rtl">  أرقام المايا </li><li style=";text-align:right;direction:rtl">  اللغة السغدية هي لغة إيرانية شرقية لم تعد تستخدم في القرن الحادي عشر. </li><li style=";text-align:right;direction:rtl">  Sogdian القديم هو إصدار أقدم (وأظن أنه أكثر محدودية) من Sogdian </li></ul><br><h3 style=";text-align:right;direction:rtl">  java.lang.Class </h3><br><p style=";text-align:right;direction:rtl">  <code>arrayType()</code> بإرجاع <code>Class</code> لنوع الصفيف الذي تم وصف نوع المكون الخاص به بواسطة هذه <code>Class</code> .  يمكن التحقق من ذلك باستخدام <code>jshell</code> : </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">jshell&gt; (new String[2]).getClass().getName() <span class="hljs-variable"><span class="hljs-variable">$11</span></span> ==&gt; <span class="hljs-string"><span class="hljs-string">"[Ljava.lang.String;"</span></span> jshell&gt; (new String[2]).getClass().arrayType() <span class="hljs-variable"><span class="hljs-variable">$12</span></span> ==&gt; class [[Ljava.lang.String; jshell&gt; <span class="hljs-string"><span class="hljs-string">"foo"</span></span>.getClass().arrayType() <span class="hljs-variable"><span class="hljs-variable">$15</span></span> ==&gt; class [Ljava.lang.String;</code> </pre> <br><p style=";text-align:right;direction:rtl">  لست متأكدًا تمامًا من معنى هذه الطريقة ، حيث أن كل ما تفعله هو إضافة <code>Class</code> إلى النوع الذي تمثله هذه الفئة. </p><br><p style=";text-align:right;direction:rtl">  <code>componentType()</code> ، مثل <code>getComponentType()</code> .  يطرح السؤال - لماذا تضيف طريقة زائدة عن الحاجة؟ </p><br><p style=";text-align:right;direction:rtl">  <code>descriptorString()</code> - مرة أخرى ، تُرجع نفس النتيجة كـ <code>getName()</code> .  ومع ذلك ، من الضروري أن تقوم <code>Class</code> الآن بتنفيذ واجهة <code>TypeDescriptor</code> المرتبطة بواجهة برمجة تطبيقات JVM الثابتة الجديدة. </p><br><h3 style=";text-align:right;direction:rtl">  lava.lang.String </h3><br><p style=";text-align:right;direction:rtl">  <code>indent()</code> - يضيف سلسلة من المسافات <code>indent()</code> إلى سلسلة.  إذا كانت المعلمة سالبة ، فسيتم إزالة هذا العدد من المسافات البادئة (إن أمكن). </p><br><p style=";text-align:right;direction:rtl">  <code>transform()</code> - يطبق الوظيفة المتوفرة على سلسلة.  قد لا تكون النتيجة سلسلة. </p><br><h3 style=";text-align:right;direction:rtl">  java.lang.invoke </h3><br><p style=";text-align:right;direction:rtl">  <code>VarHandle</code> الآن <code>toString()</code> لإرجاع وصف مضغوط. </p><br><p style=";text-align:right;direction:rtl">  <code>java.net.SecureCacheResponse</code> و <code>java.net.ssl.HttpsConnection</code> لديهم طريقة جديدة ، <code>getSSLSession()</code> والتي ترجع <code>Optional</code> يحتوي على <code>SSLSession</code> المستخدمة في الاتصال. </p><br><h3 style=";text-align:right;direction:rtl">  java.nio.files </h3><br><p style=";text-align:right;direction:rtl">  تحتوي فئة <code>Files</code> على طريقة جديدة ، <code>mismatch()</code> ، والتي تقوم بإيجاد وإرجاع موضع بايت عدم التطابق الأول في محتويات ملفين ، أو -1L إذا لم يكن هناك عدم تطابق. </p><br><h3 style=";text-align:right;direction:rtl">  java.text </h3><br><p style=";text-align:right;direction:rtl">  هناك فئة جديدة <code>CompactNumberFormat</code> .  هذا هو فئة فرعية من <code>NumberFormat</code> رقم عشري في نموذج مضغوط.  مثال على نموذج مضغوط - <code>1M</code> بدلاً من <code>1000000</code> ، وبالتالي - يتطلب حرفين بدلاً من تسعة أحرف.  تم توسيع <code>NumberFormat</code> و <code>getCompactNumberInstance()</code> طريقة <code>getCompactNumberInstance()</code> الجديدة.  يوجد أيضًا تعداد جديد ، <code>NumberFormatStyle</code> والذي له معنيان: LONG و SHORT. </p><br><h3 style=";text-align:right;direction:rtl">  java.util.concurrent </h3><br><p style=";text-align:right;direction:rtl">  يتضمن CompleteStage الآن العديد من النماذج المحملة بثلاث طرق: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  exceptionallyAsync </li><li style=";text-align:right;direction:rtl">  exceptionallyCompose </li><li style=";text-align:right;direction:rtl">  exceptionallyComposeAsync </li></ul><br><p style=";text-align:right;direction:rtl">  تعمل هذه الطرق على توسيع إمكانيات إنشاء " <code>CompletionStage</code> جديد من "موجود" ، " <code>CompletionStage</code> إذا انتهى الحال مع استثناء.  تحقق من وثائق API للحصول على التفاصيل. </p><br><h3 style=";text-align:right;direction:rtl">  javax.crypto </h3><br><p style=";text-align:right;direction:rtl">  تحتوي فئة <code>Cipher</code> على طريقة <code>toString()</code> جديدة تقوم بإرجاع سلسلة تحتوي على تحويل <code>Cipher</code> والوضع والموفر. </p><br><h3 style=";text-align:right;direction:rtl">  javax.naming.ldap.spi </h3><br><p style=";text-align:right;direction:rtl">  هذه حزمة جديدة في JDK 12 وهي تحتوي على فئتين: <code>LdapDnsProvider</code> ، وهي فئة الموفرين لعمليات البحث عن DNS أثناء عمليات LDAP ، و <code>LdapDnsProviderResults</code> التي تغلف نتيجة بحث DNS لعنوان URL LDAP. </p><br><h3 style=";text-align:right;direction:rtl">  أرجوحة </h3><br><p style=";text-align:right;direction:rtl">  لا يزال يجري تحديث سوينغ!  نعم ، <code>getChooserShortcutPanelFiles()</code> لديه الآن طريقة <code>getChooserShortcutPanelFiles()</code> جديدة.  تقوم بإرجاع مجموعة من الملفات التي تمثل القيم المراد عرضها افتراضيًا في شريط اختصار تحديد الملف. </p><br><h2 style=";text-align:right;direction:rtl">  التغييرات JVM </h2><br><h3 style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">JEP 189: شيناندواه</a> : جامع البيانات المهملة في وقت منخفض </h3><br><p style=";text-align:right;direction:rtl">  شيناندواه هو مشروع بحثي أعلنته ريد هات في عام 2014 ويركز على متطلبات تطبيق الكمون المنخفض لإدارة الذاكرة في JVM.  أهدافها هي وقت توقف مؤقت أقصى يبلغ 1..10 مللي ثانية كومة الذاكرة المؤقتة لأكثر من 20 جيجابايت ( <del>  وبالتالي فهو غير مخصص للتطبيقات الصغيرة </del>  - كما <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">أجاب أحد مطوري Shenandoah</a> ، هذا ليس كذلك ويقوم بعمل ممتاز مع التطبيقات الصغيرة).  تم تصميم أداة التجميع هذه لتعمل بالتوازي مع مؤشرات ترابط التطبيق ، لذا تجنب المشكلات التي نراها في معظم أدوات تجميع البيانات المهملة. </p><br><h3 style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">JEP 344: مجموعات G1 المختلطة</a> </h3><br><p style=";text-align:right;direction:rtl">  يهدف هذا التغيير إلى تحسين سلوك جامع G1 عندما يصل إلى هدف التأخير المحدد.  يقسم G1 مساحة الكومة (القديمة والقديمة) إلى مناطق.  والفكرة هي أنه في الجيل القديم لا تحتاج إلى جمع القمامة في عملية واحدة.  عندما تحتاج G1 إلى جمع البيانات المهملة ، فإنها تحدد المناطق التي تحددها.  وهذا ما يسمى مجموعة جمع.  قبل إصدار JDK 12 ، عندما بدأ العمل في المجموعة ، كان لابد من إكمال كل العمل ، في جوهره ، كعملية ذرية.  كانت المشكلة أنه في بعض الأحيان بسبب التغييرات في استخدام التطبيق لمساحة الكومة ، اتضح أن مجموعة المجموعة كانت كبيرة للغاية واستغرقت وقتًا طويلاً في التجميع ، مما أدى إلى حقيقة أنه لم يتم الوصول إلى وقت الإيقاف المؤقت. </p><br><p style=";text-align:right;direction:rtl">  في JDK 12 ، إذا حددت G1 هذا الموقف ، فسوف يقطع جمع البيانات في منتصف الطريق إذا لم يؤثر ذلك على قدرة التطبيق على مواصلة تخصيص مساحة للكائنات الجديدة.  سيكون التأثير الصافي لـ G1 أفضل عند الوصول إلى وقت توقف مؤقت قصير. </p><br><h3 style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">JEP 346: إرجاع بسرعة الذاكرة المخصصة غير المستخدمة من G1</a> </h3><br><p style=";text-align:right;direction:rtl">  هذا تحسين آخر للأداء في G1 ، لكن هناك تحسينًا آخر يتعلق بكيفية تفاعل JVM مع بقية النظام.  من الواضح أن الذاكرة مطلوبة لكومة الذاكرة المؤقتة لـ JVM ، وعند بدء التشغيل ، تطلب الذاكرة من مُخصص الذاكرة الظاهرية لنظام التشغيل.  عند بدء تشغيل التطبيق ، قد تكون هناك أوقات ينخفض ​​فيها مقدار الذاكرة المطلوبة للكومة ، ويمكن إرجاع جزء من الذاكرة المخصصة إلى نظام التشغيل لاستخدامها من قبل التطبيقات الأخرى. </p><br><p style=";text-align:right;direction:rtl">  يقوم G1 بهذا بالفعل ، ولكن لا يمكنه القيام بذلك إلا في أحد المكانين.  أولا ، خلال مجموعة كاملة ، وثانيا ، خلال واحدة من الدورات الموازية.  يحاول G1 عدم القيام بمجموعة كاملة ، ومع انخفاض استخدام الذاكرة ، قد تكون هناك فترات مهمة بين دورات المجموعة.  هذا يؤدي إلى حقيقة أن G1 يمكنه الاحتفاظ بذاكرة ثابتة لفترة طويلة. </p><br><p style=";text-align:right;direction:rtl">  في JDK 12 ، ستحاول G1 بشكل دوري متابعة أو تشغيل حلقة متوازية بينما يكون التطبيق في وضع الخمول لتحديد الاستخدام الكلي لكومة Java.  يمكن إرجاع الذاكرة غير المستخدمة إلى نظام التشغيل في الوقت المناسب وبطريقة يمكن التنبؤ بها. </p><br><p style=";text-align:right;direction:rtl">  علامة سطر الأوامر الجديدة <code>-XX:G1PeriodicGCInterval</code> يمكن استخدامها لتعيين عدد المللي ثانية بين الشيكات. </p><br><p style=";text-align:right;direction:rtl">  ستؤدي هذه الميزة إلى استخدام أكثر تحفظًا لذاكرة JVM للتطبيقات التي ظلت خاملاً لفترات طويلة من الوقت. </p><br><h2 style=";text-align:right;direction:rtl">  ميزات JDK جديدة أخرى </h2><br><h3 style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">JEP 230: مجموعة العلامات الصغيرة</a> </h3><br><p style=";text-align:right;direction:rtl">  تم تطوير Java Microbenchmarking Harness (JMH) بواسطة Alexey Shipilev عندما كان يعمل في Oracle ويوفر منصة شاملة لتطوير اختبارات الأداء لتطبيقات Java.  قام Alexey بعمل رائع لمساعدة الناس على تجنب العديد من الأخطاء البسيطة التي يرتكبونها عند محاولة تحليل أداء التطبيق: الاحماء ، تجنب الاستثناءات ، إلخ. </p><br><p style=";text-align:right;direction:rtl">  يمكن الآن تضمين JMH في OpenJDK.  يمكن لأي شخص مهتم بالعمل على JDK نفسه وتغيير الرمز استخدام هذا لمقارنة الأداء قبل وبعد التغييرات ، وكذلك لمقارنة الأداء في الإصدارات المختلفة.  يتم تضمين عدد من الاختبارات لتمكين الاختبار ؛  تصميم JMH هو أنه من السهل إضافة اختبارات جديدة إلى حيث هناك حاجة إليها. </p><br><h3 style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">JEP 340: منفذ Aarch64 واحد ، وليس اثنين</a> </h3><br><p style=";text-align:right;direction:rtl">  يحتوي OpenJDK على منفذين لهندسة Arm64 ، أحدهما يوفره Oracle والآخر بواسطة Red Hat.  نظرًا لأن هذا لم يكن ضروريًا ، وتوقف Oracle عن دعم Arm لثنائيات JDK الخاصة به ، فقد تقرر استخدام منفذ Red Hat فقط ، الذي لا يزال مدعومًا ومطورًا. </p><br><h3 style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">341 JEP: أرشيف CDS الافتراضي</a> </h3><br><p style=";text-align:right;direction:rtl">  تستخدم فئة مشاركة البيانات (CDS) لتكون ميزة تجارية في Oracle JDK.  مع انتقال حديث تم إجراؤه في JDK 11 لإزالة جميع الاختلافات الوظيفية بين Oracle JDK و OpenJDK ، تم تضمينه في OpenJDK. </p><br><p style=";text-align:right;direction:rtl">  لاستخدام CDS ، تحتاج إلى أرشيف تم إنشاؤه للفئات التي يتم تحميلها عند بدء تشغيل التطبيق.  يحتوي JDK 12 للأنظمة الأساسية 64 بت الآن على ملف <code>classes.jsa</code> في دليل <code>lib/server</code> .  هذا هو أرشيف CDS لـ "الفئات الافتراضية".  أفترض أن هذا يعني جميع الفئات العامة في وحدات JDK ؛  لم أتمكن من إيجاد طريقة لفك ضغطها للتحقق.  منذ تمكين CDS افتراضيًا ، وهو ما يعادل الخيار <code>-Xshare:auto</code> في سطر الأوامر ، سيستفيد المستخدمون من أوقات بدء تشغيل التطبيق المحسنة منه. </p><br><h2 style=";text-align:right;direction:rtl">  النتائج </h2><br><p style=";text-align:right;direction:rtl">  يوفر JDK 12 عددًا صغيرًا من الوظائف وواجهات برمجة التطبيقات ، مع <code>switch</code> الأكثر إثارة للاهتمام للمطورين.  بالتأكيد سيقدر مستخدمو G1 تحسينات الأداء. </p><br><p style=";text-align:right;direction:rtl">  مع الإصدار الجديد من الإصدار ، أنصح جميع المستخدمين باختبار تطبيقاتهم في هذا الإصدار.  سيساعدك تتبع التغييرات الإضافية في تجنب المفاجآت إذا قررت الانتقال إلى الإصدار التالي من الدعم طويل الأجل. </p><br><p style=";text-align:right;direction:rtl">  لدينا <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">إصدارات JDK 12</a> مجانية <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">لـ Zulu Community Edition</a> لمساعدتك في الاختبار.  تأكد من تجربتها. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar446590/">https://habr.com/ru/post/ar446590/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar446576/index.html">استبدال الواردات ، أو كيف فعلت المروحيات الروسية شيء خاطئ</a></li>
<li><a href="../ar446578/index.html">لغة البرمجة القائمة على بطاقة بريدية</a></li>
<li><a href="../ar446582/index.html">تأملات حول الاستضافة الشمسية للنحل</a></li>
<li><a href="../ar446586/index.html">إعدادات الشبكة من FreeRadius عبر DHCP</a></li>
<li><a href="../ar446588/index.html">التحقق من كود المصدر Roslyn</a></li>
<li><a href="../ar446592/index.html">التحقق من شفرة المصدر لروزلين</a></li>
<li><a href="../ar446598/index.html">إعادة خطوط CRT</a></li>
<li><a href="../ar446602/index.html">الحد الأقصى الحالي العاصمة من خلال مجال تأثير الترانزستور</a></li>
<li><a href="../ar446604/index.html">ESET: New OceanLotus Cybergroup Backdoor مخططات التسليم</a></li>
<li><a href="../ar446606/index.html">تحقق من مدى جودتك في التكنولوجيا المضافة</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>