<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚈 😚 🆖 Bagaimana jika tanpa Python? Julia untuk pembelajaran mesin dan umumnya 📒 ↗️ 🚶🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami selalu ingin menulis kode dengan cepat, tetapi Anda harus membayarnya. Dalam bahasa fleksibel tingkat tinggi biasa, program dapat dikembangkan de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana jika tanpa Python? Julia untuk pembelajaran mesin dan umumnya</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/476114/">  Kami selalu ingin menulis kode dengan cepat, tetapi Anda harus membayarnya.  Dalam bahasa fleksibel tingkat tinggi biasa, program dapat dikembangkan dengan cepat, tetapi berjalan lambat setelah diluncurkan.  Sebagai contoh, sangat lambat untuk membaca sesuatu yang berat dengan Python murni.  Bahasa seperti C bekerja lebih cepat, tetapi lebih mudah untuk membuat kesalahan, pencarian yang akan mengurangi semua peningkatan kecepatan menjadi nol. <br><br>  Biasanya dilema ini diselesaikan sebagai berikut: pertama mereka menulis prototipe pada sesuatu yang fleksibel, misalnya, pada Python atau R, dan kemudian menulis ulang pada C / C ++ atau Fortran.  Tetapi siklus ini terlalu lama, dapatkah Anda melakukannya tanpa itu? <br><br><img src="https://habrastorage.org/webt/c0/hu/mw/c0humwwihszecprm5u7-j1ofego.jpeg"><br><br>  Mungkin ada solusinya.  Julia adalah bahasa pemrograman tingkat tinggi dan fleksibel namun cepat.  Julia memiliki banyak pengiriman, kompiler pintar terintegrasi dan alat metaprogramming.  <strong>Gleb Ivashkevich</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">phtRaveller</a> ), pendiri datarythmics, yang mengembangkan sistem pembelajaran mesin untuk industri dan industri lain, mantan fisikawan, akan memberi tahu Anda lebih banyak tentang apa yang dimiliki Julia. <br><br>  Gleb akan menjelaskan mengapa bahasa baru diperlukan dan mengapa terkadang Python tidak ada.  Dia akan memberi tahu Anda apa yang menarik di Julia, tentang kekuatan dan kelemahannya, bandingkan dengan bahasa lain, dan tunjukkan apa yang bahasa tersebut memiliki prospek pembelajaran mesin dan komputasi secara umum. <br><br>  <em>Penafian.</em>  <em>Tidak akan ada parsing sintaksis.</em>  <em>Habrazhiteli mengalami pengembang, jadi tidak masuk akal untuk menunjukkan cara menulis loop, misalnya.</em> <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/REVmhiJ1Zi8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Masalah dua bahasa </h2><blockquote>  Jika Anda menulis kode dengan cepat, program berjalan lambat.  Jika program bekerja dengan cepat, tulislah untuk waktu yang lama. </blockquote> Python klasik termasuk dalam kategori pertama.  Jika Anda menghapus NumPy, pertimbangkan sesuatu dengan Python murni perlahan.  Di sisi lain, ada bahasa seperti C dan C ++.  Sulit untuk menemukan keseimbangan, jadi paling sering mereka pertama kali menulis prototipe pada sesuatu yang fleksibel, dan setelah debugging algoritma, mereka menulis ulang ke bahasa lebih cepat.  Ini adalah contoh <strong>masalah yang jelas dalam dua bahasa</strong> : siklus panjang ketika Anda harus menulis dengan Python, dan menulis ulang dalam C atau dalam Cython, misalnya. <br><br>  Spesialis dalam pembelajaran mesin dan Ilmu Data memiliki NumPy, Sklearn, TensorFlow.  Mereka telah memecahkan masalah mereka selama bertahun-tahun tanpa satu baris dalam C, dan tampaknya masalah kedua bahasa tidak menjadi masalah mereka.  Ini tidak begitu, masalah memanifestasikan dirinya <strong>secara implisit</strong> , karena kode di NumPy atau di TensorFlow sebenarnya tidak benar-benar Python.  Ini digunakan sebagai bahasa logam untuk meluncurkan apa yang ada di dalamnya.  Di dalamnya persis C / Fortran (dalam kasus NumPy) atau C ++ (dalam kasus TensorFlow). <br><br>  "Fitur" ini kurang terlihat, misalnya, di PyTorch, tetapi di Numpy itu terlihat jelas.  Misalnya, jika siklus Python klasik <code>for</code> muncul dalam perhitungan, maka ada yang salah.  Dalam kode produktif, loop tidak diperlukan, Anda harus menulis ulang semuanya sehingga NumPy dapat membuat vektor dan menghitungnya dengan cepat. <br><br>  Pada saat yang sama, tampaknya banyak yang NumPy cepat dan semuanya baik-baik saja dengan itu.  Mari kita lihat apa yang dimiliki NumPy di ​​bawah tenda untuk melihat ini. <br><br><ul><li>  NumPy sedang mencoba untuk memperbaiki masalah fleksibilitas jenis Python, sehingga memiliki <strong>sistem tipe yang</strong> cukup <strong>ketat</strong> .  Jika array memiliki tipe tertentu, maka tidak ada yang lain di dalamnya, jika <code>Float64</code> , tidak ada yang dapat dilakukan tentang hal itu. </li><li>  <strong>Pengiriman.</strong>  Bergantung pada jenis array dan operasi apa yang perlu Anda lakukan, NumPy di ​​dalam dirinya sendiri akan memutuskan fungsi mana yang harus dihubungi untuk membuat perhitungan secepat mungkin.  Perpustakaan akan mencoba membuang Python klasik keluar dari loop perhitungan. </li></ul><br>  Ternyata Numpy tidak secepat yang terlihat.  Itu sebabnya ada proyek seperti <strong>Cython</strong> atau <strong>Numba</strong> .  Yang pertama menghasilkan kode-C dari "hibrida" dari Python dan C, dan yang kedua mengkompilasi kode dalam Python dan biasanya ini lebih cepat. <br><blockquote>  Jika NumPy benar-benar secepat tampaknya bagi banyak orang, maka keberadaan Cython dan Numba tidak masuk akal. </blockquote>  Kami menulis ulang semua yang ada di Cython jika kami ingin cepat menemukan sesuatu yang besar dan kompleks.  Salah satu kriteria untuk kualitas pembungkus dalam Cython adalah ada atau tidak adanya panggilan Python murni dalam kode yang dihasilkan. <br><br>  Contoh sederhana: kami menambahkan jenis (baik) atau tidak menambahkan (buruk), dan kami mendapatkan dua kode yang sama sekali berbeda, meskipun selain jenis opsi awal tidak berbeda. <br><br><img src="https://habrastorage.org/webt/23/nj/e0/23nje0ddwbpf8c9debfufjvg0h8.png"><br><br>  Ketika kita menghasilkan kode C, dalam kasus pertama kita mendapatkan yang berikut: <br><br><pre> <code class="cpp hljs">__pyx_t_4 = __pyx_v_i; __pyx_v_result = (__pyx_v_result + (*((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> *) ( <span class="hljs-comment"><span class="hljs-comment">/* dim=0 */</span></span> (__pyx_v_a.data + __pyx_t_4 * __pyx_v_a.strides[<span class="hljs-number"><span class="hljs-number">0</span></span>]) ))));</code> </pre> <br>  Dan pada <code>result =0.</code> kedua <code>result =0.</code>  akan berubah menjadi ini: <br><br><pre> <code class="cpp hljs">__pyx_t_6 = PyFloat_FromDouble((*((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> *) ( <span class="hljs-comment"><span class="hljs-comment">/* dim=0 */</span></span> (__pyx_v_a.data + __pyx_t_4 * __pyx_v_a.strides[<span class="hljs-number"><span class="hljs-number">0</span></span>]) )))); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(!__pyx_t_6)) __PYX_ERR(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_6); __pyx_t_7 = PyNumber_InPlaceAdd(__pyx_v_result, __pyx_t_6); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(!__pyx_t_7)) __PYX_ERR(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_7); __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = <span class="hljs-number"><span class="hljs-number">0</span></span>; __Pyx_DECREF_SET(__pyx_v_result, __pyx_t_7); __pyx_t_7 = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  Ketika suatu jenis ditentukan, kode C berjalan cepat.  Jika jenisnya tidak ditentukan, kita melihat Python normal, tetapi dari sisi C: panggilan Python standar, di mana karena beberapa alasan <code>float</code> dibuat dari <code>double</code> , tautan dihitung, dan banyak kode sampah lainnya.  Kode ini lambat karena memanggil Python untuk setiap operasi. <br><br><h3>  Apakah mungkin menyelesaikan semua masalah sekaligus </h3><br>  Lucu ketika kita memikirkan sesuatu, kita mencoba untuk menghapus Python murni.  Ada dua opsi untuk bagaimana melakukan ini. <br><br><ul><li>  Menggunakan <strong>Cython</strong> atau alat lain.  Ada banyak cara Anda dapat mengoptimalkan kode Cython Anda agar tidak ada panggilan Python.  Tapi ini bukan kegiatan yang paling menyenangkan: tidak semuanya begitu jelas di Cython, dan hanya sedikit waktu yang dihabiskan daripada jika Anda hanya menulis semuanya dalam C. Modul yang dihasilkan dapat digunakan dalam Python, tetapi masih membutuhkan waktu yang lama, kesalahan terjadi, kode tidak selalu jelas dan tidak selalu jelas cara mengoptimalkannya. </li><li>  Menggunakan Numba, yang melakukan <strong>kompilasi JIT</strong> . </li></ul><br>  Tapi mungkin ada cara yang lebih baik, dan saya pikir ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Julia</a> . <br><br><h2>  Julia </h2><br>  Pembuat menyatakan bahwa ini adalah bahasa <strong>cepat</strong> , <strong>tingkat tinggi</strong> dan <strong>fleksibel</strong> , yang sebanding dengan Python dalam hal kemudahan menulis kode.  Menurut saya, Julia seperti <strong>bahasa scripting:</strong> Anda tidak perlu melakukan apa yang harus Anda lakukan di C, di mana semuanya sangat tingkat rendah, termasuk struktur data.  Pada saat yang sama, Anda dapat bekerja di konsol biasa, seperti dengan Python dan bahasa lainnya. <br><br>  Julia menggunakan <strong>kompilasi Just-In-Time</strong> - ini adalah salah satu elemen yang memberikan kecepatan.  Tapi bahasanya bagus dengan perhitungan, karena dikembangkan untuk mereka.  Julia digunakan untuk tugas-tugas ilmiah dan mendapatkan kinerja yang layak. <br><blockquote>  Meskipun Julia berusaha terlihat seperti bahasa tujuan umum, Julia bagus untuk komputasi dan tidak terlalu bagus untuk layanan web.  Menggunakan Julia sebagai ganti Django, misalnya, bukanlah pilihan terbaik. </blockquote>  Mari kita lihat fitur-fitur bahasa sebagai contoh fungsi primitif. <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> f(x) α = <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>x <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> julia&gt; methods(f) <span class="hljs-comment"><span class="hljs-comment"># 1 method for generic function "f": [1] f(x) in Main at mpconf.jl:2</span></span></code> </pre> <br>  Empat fitur terlihat dalam kode ini. <br><br><ul><li>  <strong>Praktis tidak ada batasan dalam menggunakan Unicode</strong> .  Anda dapat mengambil rumus dari artikel tentang pembelajaran mendalam atau pemodelan numerik, menulis ulang dengan karakter yang sama, dan semuanya akan berfungsi - Unicode dijahit hampir di mana-mana. </li><li>  <strong>Tidak ada tanda multiplikasi.</strong>  Namun, tidak selalu mungkin dilakukan tanpa itu, misalnya, dengan 2.x (angka floating-point kali x) Julia akan bersumpah. </li><li>  <strong>Tidak <code>return</code></strong>  Secara umum, Anda disarankan untuk menulis <code>return</code> sehingga Anda dapat melihat apa yang terjadi, tetapi contohnya akan kembali <code>α</code> , karena tugas adalah ekspresi. </li><li>  <strong>Tanpa tipe</strong> .  Tampaknya jika ada kecepatan, maka di beberapa titik jenis akan muncul?  Ya, mereka akan muncul, tetapi nanti. </li></ul><br>  Julia memiliki tiga fitur yang memberikan fleksibilitas dan kecepatan: <strong>multi-dispatching, metaprogramming, dan parallelism</strong> .  Kami akan berbicara tentang dua yang pertama, dan meninggalkan paralelisasi untuk studi independen untuk pengguna tingkat lanjut. <br><br><h3>  Penjadwalan berganda </h3><br>  Panggilan ke <code>methods(f)</code> dalam contoh di atas terlihat secara tidak terduga - metode apa yang dimiliki fungsi?  Kita terbiasa dengan fakta bahwa kita memiliki objek kelas, kelas memiliki metode.  Tetapi di Julia semuanya terbalik: fungsi memiliki metode, karena bahasa menggunakan banyak pengiriman. <br><blockquote>  Penjadwalan berganda berarti bahwa varian fungsi tertentu yang akan dieksekusi ditentukan oleh seluruh rangkaian tipe parameter dari fungsi ini. </blockquote>  Saya akan menjelaskan secara singkat bagaimana ini bekerja pada contoh yang sudah akrab. <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> f(x) α = <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>x <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> f(x::<span class="hljs-built_in"><span class="hljs-built_in">AbstractFloat</span></span>) α = <span class="hljs-number"><span class="hljs-number">1</span></span> + sin(x) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> julia&gt; methods(f) <span class="hljs-comment"><span class="hljs-comment"># 2 methods for generic function "f": [1] f(x::AbstractFloat) in Main at mpconf.jl:6 [2] f(x) in Main at mpconf.jl:2</span></span></code> </pre> <br>  Varian dengan fungsi yang sama untuk set tipe yang berbeda disebut metode.  Ada dua dalam kode: yang pertama untuk semua angka floating-point, dan yang kedua untuk yang lainnya.  Saat pertama kali memanggil fungsi, Julia akan memutuskan metode mana yang akan digunakan dan apakah akan mengompilasinya.  Jika sudah dipanggil dan dikompilasi, itu akan mengambil salah satunya. <br><br>  Karena di Julia semuanya tidak seperti biasanya, di sini Anda dapat menambahkan fungsi ke tipe yang ditentukan pengguna, tetapi ini tidak akan menjadi metode tipe dalam arti OOP.  Ini hanya akan menjadi bidang di mana fungsi ditulis, karena <strong>fungsi adalah objek penuh yang sama dengan yang</strong> lainnya. <br><br>  Untuk mengetahui apa yang sebenarnya akan dipicu, ada makro khusus.  Mereka mulai dengan <code>@</code> .  Dalam contoh ini, makro yang memungkinkan <code>@which</code> mengetahui metode mana yang dipanggil untuk kasus tertentu. <br><br><img src="https://habrastorage.org/webt/nu/ix/ih/nuixiha2x9r2b148gdqyo81fkri.png"><br><br>  Dalam kasus pertama, Julia memutuskan bahwa karena 2 adalah bilangan bulat, itu tidak cocok dengan <code>AbstractFloat</code> , dan disebut opsi pertama.  Dalam kasus kedua, dia memutuskan bahwa itu adalah <code>Float</code> dan sudah menyerukan versi khusus.  Kira-kira ini akan berfungsi jika Anda menambahkan metode lain untuk beberapa jenis tertentu. <br><br><h3>  LLVM dan JIT </h3><br>  Julia menggunakan kerangka kerja LLVM untuk dikompilasi.  Perpustakaan kompilasi JIT datang dalam paket bahasa.  Pertama kali fungsi dipanggil, Julia melihat apakah fungsi tersebut telah digunakan dengan set tipe ini, dan mengkompilasinya jika perlu.  Peluncuran pertama akan memakan waktu, dan kemudian semuanya akan bekerja dengan cepat. <br><blockquote>  Fungsi akan dikompilasi pada saat panggilan pertama untuk set parameter ini. </blockquote>  Fitur Kompiler <br><br><ul><li>  <strong>Kompiler ini cukup masuk akal</strong> karena LLVM adalah produk yang bagus. </li><li>  Kebanyakan pengembang tingkat lanjut dapat <strong>melihat proses kompilasi</strong> dan melihat apa yang dihasilkannya. </li><li>  <strong>Kompilasi Julia dan Numba serupa</strong> .  Di Numba, Anda juga membuat dekorator JIT, tetapi di Numba Anda tidak bisa "masuk" begitu banyak dan memutuskan apa yang harus dioptimalkan atau diubah. </li></ul><br>  Untuk mengilustrasikan pekerjaan kompiler, saya akan memberikan contoh fungsi sederhana: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> f(x) α = <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span>x <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> julia&gt; <span class="hljs-meta"><span class="hljs-meta">@code_llvm</span></span> f(<span class="hljs-number"><span class="hljs-number">2</span></span>) define i64 <span class="hljs-meta"><span class="hljs-meta">@julia_f_35897</span></span>(i64) { top: %<span class="hljs-number"><span class="hljs-number">1</span></span> = mul i64 %<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> %<span class="hljs-number"><span class="hljs-number">2</span></span> = add i64 %<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> ret i64 %<span class="hljs-number"><span class="hljs-number">2</span></span> }</code> </pre><br>  Makro <code>@code_llvm</code> memungkinkan Anda melihat hasil pembuatan.  <strong>LLVM IR</strong> ini adalah <strong>representasi perantara</strong> , semacam assembler. <br><br>  Dalam kode, argumen fungsi dikalikan dengan 3, 1 ditambahkan ke hasilnya, hasilnya dikembalikan.  Segalanya semudah mungkin.  Jika Anda mendefinisikan fungsi sedikit berbeda, misalnya, ganti 3 dengan 2, maka semuanya akan berubah. <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> f(x) α = <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>x <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> julia&gt; <span class="hljs-meta"><span class="hljs-meta">@code_llvm</span></span> f(<span class="hljs-number"><span class="hljs-number">2</span></span>) define i64 <span class="hljs-meta"><span class="hljs-meta">@julia_f_35894</span></span>(i64) { top: %<span class="hljs-number"><span class="hljs-number">1</span></span> = shl i64 %<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> %<span class="hljs-number"><span class="hljs-number">2</span></span> = or i64 %<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> ret i64 %<span class="hljs-number"><span class="hljs-number">2</span></span> }</code> </pre> <br>  Tampaknya, apa bedanya: 2, 3, 10?  Tetapi Julia dan LLVM melihat bahwa ketika Anda memanggil fungsi untuk integer, Anda bisa melakukan sedikit lebih pintar.  Mengalikan dengan dua bilangan bulat adalah pergeseran kiri dengan satu bit - lebih cepat dari produk.  Tapi, tentu saja, ini hanya berfungsi untuk bilangan bulat, itu tidak akan berhasil menggeser <code>Float</code> kiri sebanyak 1 bit dan mendapatkan hasil dari mengalikan dengan 2. <br><br><h3>  Jenis khusus </h3><br>  Jenis khusus di Julia secepat jenis bawaan.  Penjadwalan multipel dilakukan pada mereka, dan itu akan secepat untuk tipe bawaan.  Dalam hal ini, mekanisme pengiriman banyak tertanam dalam bahasa. <br><br>  Adalah logis untuk mengharapkan bahwa variabel tidak memiliki tipe, hanya nilai yang memilikinya.  Variabel tanpa tipe hanyalah marker, label pada beberapa wadah. <br><br>  <strong>Sistem tipe bersifat hierarkis.</strong>  Kita tidak dapat membuat turunan dari tipe beton, tipe abstrak hanya dapat memilikinya.  Namun, tipe abstrak tidak bisa dipakai.  Nuansa ini tidak akan menarik bagi semua orang. <br><br>  Seperti yang dijelaskan oleh penulis bahasa ketika mereka mengembangkan Julia, mereka ingin mendapatkan hasilnya, dan jika ada sesuatu yang sulit dilakukan, mereka menolaknya.  Sistem tipe hierarkis seperti itu lebih mudah untuk dikembangkan.  Ini bukan masalah katastropik, tetapi jika Anda tidak memalingkan kepala terlebih dahulu, itu akan merepotkan. <br><br>  <strong>Jenis dapat diparameterisasi</strong> , yang agak mirip C / C ++.  Sebagai contoh, kita mungkin memiliki struktur di mana ada bidang, tetapi jenis bidang ini tidak ditentukan - ini adalah parameter.  Kami menentukan jenis tertentu di instantiation. <br><br>  <strong>Dalam kebanyakan kasus, jenis dapat dilewati</strong> .  Biasanya mereka diperlukan ketika tipe membantu kompiler untuk menebak cara terbaik untuk mengkompilasi.  Dalam hal ini, jenisnya lebih baik untuk ditentukan.  Anda juga perlu menentukan jenis jika Anda ingin mencapai kinerja yang lebih baik. <br><br>  Mari kita lihat apa yang mungkin dan apa yang tidak bisa dipakai. <br><br><img src="https://habrastorage.org/webt/0r/xr/bl/0rxrbllszhjk9okl1-3irj1zdns.png"><br><br>  Tipe pertama <code>AbstractPoint</code> tidak dapat dipakaikan.  Sebagai contoh, ini hanyalah induk dari semua orang yang dapat kita tentukan dalam metode.  Baris kedua mengatakan bahwa <code>PlanarPoint{T}</code> adalah turunan dari titik abstrak ini.  Di bawah bidang dimulai - di sini Anda dapat melihat parameterisasi.  Anda dapat meletakkan <code>float</code> , <code>int</code> atau jenis lainnya di sini. <br><br>  Jenis pertama tidak dapat dipakai, dan untuk semua yang lain tidak mungkin untuk membuat keturunan.  Selain itu, secara default mereka tidak <strong>berubah</strong> .  Agar dapat mengubah bidang, ini harus ditentukan secara eksplisit. <br><br>  Ketika semuanya sudah siap, Anda dapat melanjutkan, misalnya, menghitung jarak untuk berbagai jenis titik.  Dalam contoh tersebut, titik pertama pada pesawat adalah <code>PlanarPoint</code> , lalu pada bola dan pada silinder.  Bergantung pada dua titik yang kita hitung jaraknya, kita perlu menggunakan metode yang berbeda.  Secara umum, fungsinya akan terlihat seperti ini: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> describe(p::AbstractPoint) println(<span class="hljs-string"><span class="hljs-string">"Point instance: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$p</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Untuk <code>Float64</code> , <code>Float32</code> , <code>Float16</code> akan menjadi: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> distance(pf::PlanarPoint{T}, ps::PlanarPoint{T}) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T&lt;:<span class="hljs-built_in"><span class="hljs-built_in">AbstractFloat</span></span> sqrt((pf.x-ps.x)^<span class="hljs-number"><span class="hljs-number">2</span></span> + (pf.y-ps.y)^<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Dan untuk bilangan bulat, metode perhitungan jarak akan terlihat seperti ini: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> distance(pf::PlanarPoint{T}, ps::PlanarPoint{T}) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Integer</span></span> abs(pf.x-ps.x) + abs(pf.y-ps.y) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Untuk poin dari setiap jenis, metode yang berbeda akan dipanggil. <br><br><img src="https://habrastorage.org/webt/ya/8n/_d/ya8n_dvihkdqpsmqfkmdl5wm_ro.png"><br><br>  Jika Anda curang dan, misalnya, menerapkan <code>distance(f1, i2)</code> , Julia akan bersumpah: “Saya tidak tahu metode ini!  Anda bertanya kepada saya metode semacam itu, dan mengatakan bahwa keduanya memiliki tipe yang sama.  Anda tidak memberi tahu saya cara menghitung ini ketika satu parameter <code>float</code> dan yang lainnya adalah <code>int</code> . " <br><br><h3>  Kecepatan </h3><br>  Anda mungkin sudah senang: “Ada kompilasi JIT: menulis itu mudah, itu akan bekerja dengan cepat.  Buang Python dan mulai menulis dalam Julia! " <br><br>  Tapi tidak sesederhana itu.  Tidak semua fitur di Julia akan cepat.  Itu tergantung pada dua faktor. <br><br><ul><li>  <strong>Dari pengembang</strong> .  Tidak ada bahasa di mana fungsi apa pun akan cepat.  Pengembang yang tidak berpengalaman bahkan akan menulis kode dalam C yang akan bekerja jauh lebih lambat daripada kode Python dari pengembang yang berpengalaman.  Bahasa apa pun memiliki trik dan nuansa tersendiri yang bergantung pada kinerja.  Kompiler, apakah itu statis biasa atau JIT, tidak dapat memberikan semua opsi yang mungkin dan mengoptimalkan semuanya. </li><li>  <strong>Dari stabilitas jenis</strong> .  Dalam versi yang lebih cepat, fungsi yang stabil berdasarkan jenis akan dikompilasi. </li></ul><br><h3>  Ketik stabilitas </h3><br>  Apa itu stabilitas tipe?  Ketika kompiler tidak dapat dengan cukup andal menebak apa yang terjadi dengan tipe-tipe itu, ia harus menghasilkan banyak kode wrapper sehingga segala sesuatu yang masuk ke input bekerja. <br><br>  Contoh sederhana untuk memahami stabilitas tipe. <br><br><img src="https://habrastorage.org/webt/ye/83/jv/ye83jvzws3gkfjvobwf6xvtlpaq.png"><br><br>  Spesialis pembelajaran mesin akan mengatakan bahwa ini adalah aktivasi relu yang normal: jika x&gt; 0, kembalikan seperti apa adanya, jika tidak kembalikan nol.  Satu masalah adalah nol setelah bilangan bulat tanda tanya.  Ini berarti bahwa jika kita memanggil fungsi ini untuk angka titik-mengambang, maka dalam satu kasus, angka titik-mengambang akan dikembalikan, dan dalam kasus lain, bilangan bulat. <br><br>  Kompiler tidak dapat menebak jenis hasil hanya dengan jenis argumen fungsi.  Dia juga perlu tahu artinya.  Karena itu, ia menghasilkan banyak kode. <br><br>  Selanjutnya, kita membuat array 100 per 100 angka acak dari 0 ke 1, menggesernya 0,5 untuk mendistribusikan angka positif dan negatif secara merata, dan mengukur hasilnya.  Ada dua poin menarik: titik dan fungsinya.  Titik setelah <code>rand(100,100)</code> berarti "berlaku untuk setiap elemen."  Jika Anda memiliki semacam koleksi dan fungsi skalar, Anda mengakhiri itu, dan Julia akan melakukan sisanya.  Kita dapat mengasumsikan bahwa ini sama efektifnya dengan loop normal dalam bahasa yang dikompilasi normal.  Tidak perlu menulis - semuanya akan dilakukan untuk Anda. <br><br>  Tidak ada masalah di titik - <strong>masalahnya ada di dalam fungsi itu sendiri</strong> .  Perkiraan waktu eksekusi dari opsi semacam itu pada komputer yang layak untuk matriks semacam itu adalah mikrodetik.  Tetapi dalam kenyataannya - milidetik, yang terlalu banyak untuk matriks sekecil itu. <br><br>  Ubah hanya satu baris. <br><br><img src="https://habrastorage.org/webt/bt/3g/4t/bt3g4t3kgng3thzuyb75mi_bmzw.png"><br><br>  Fungsi <code>zero(x)</code> dijalankan menghasilkan nol dengan tipe yang sama dengan argumen <code>(x)</code> .  Ini berarti bahwa tidak peduli berapa nilai <code>x</code> , tipe hasil akan selalu diketahui oleh tipe <code>x</code> itu sendiri. <br><blockquote>  Ketika kita melihat hanya pada tipe argumen dan sudah tahu tipe hasil, ini adalah fungsi yang tipe stabil. </blockquote>  Jika kita perlu melihat makna argumen, ini bukan fungsi yang stabil. <br><br>  Ketika kompiler dapat mengoptimalkan kode, perbedaan waktu eksekusi diperoleh oleh dua urutan besarnya.  Dalam contoh kedua, hanya dialokasikan tepat untuk array baru, beberapa byte lebih banyak dan tidak lebih.  Opsi ini jauh lebih efektif daripada yang sebelumnya. <br><br>  Ini adalah hal utama yang harus diperhatikan ketika kita menulis kode dalam Julia.  Jika Anda menulis seperti di Python, maka itu akan berfungsi seperti di Python.  Jika Anda melakukan operasi yang sama pada NumPy, maka nol dengan atau tanpa titik tidak memainkan peran.  Tetapi di Julia, ini bisa sangat merusak kinerja. <br><br>  Untungnya, ada metode untuk mengetahui apakah ada masalah.  Ini adalah makro <code>@code_warntype</code> , yang memungkinkan Anda untuk mengetahui apakah kompiler dapat menebak di mana jenis berada dan mengoptimalkan jika semuanya baik-baik saja. <br><br><img src="https://habrastorage.org/webt/bg/jp/xf/bgjpxfne2jxskxqaloz2omljbda.png"><br><br>  Pada opsi pertama (kiri), kompiler tidak yakin akan jenisnya dan menampilkannya dengan warna merah.  Dalam kasus kedua, akan selalu ada <code>Float64</code> untuk argumen seperti itu, sehingga Anda dapat menghasilkan kode yang jauh lebih pendek. <br><br>  Ini belum LLVM, tetapi kode Julia berlabel, <code>return 0</code> atau <code>return 0.0</code> memberikan perbedaan kinerja dua urutan besarnya. <br><br><h3>  Metaprogramming </h3><blockquote>  Metaprogramming adalah ketika kita membuat program dalam suatu program dan menjalankannya saat bepergian. </blockquote>  Ini adalah metode yang ampuh yang memungkinkan Anda melakukan banyak hal menarik yang berbeda.  Contoh klasik adalah Django ORM, yang membuat bidang menggunakan metaclasses. <br><br>  Banyak orang mengetahui penafian dari <strong>Tim Peters</strong> , penulis Zen of Python: <i>“Metaclasses adalah keajaiban yang lebih dalam yang tidak perlu dikhawatirkan oleh 99% pengguna.</i>  <i>Jika Anda bertanya-tanya apakah metaclasses diperlukan dalam Python, Anda tidak membutuhkannya.</i>  <i>Jika Anda membutuhkannya, maka Anda tahu persis mengapa dan bagaimana menggunakannya. ”</i> <i><br></i> <br>  Dengan metaprogramming, situasinya mirip, tetapi di Julia dijahit lebih dalam, ini adalah fitur penting dari seluruh bahasa.  Kode Julia adalah struktur data yang sama dengan yang lain, Anda dapat memanipulasi, menggabungkan, membuat ekspresi, dan semua ini akan berhasil. <br><br><pre> <code class="julia hljs">julia&gt; x = <span class="hljs-number"><span class="hljs-number">4</span></span>; julia&gt; typeof(:(x+<span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-built_in"><span class="hljs-built_in">Expr</span></span> julia&gt; expr = :(x+<span class="hljs-number"><span class="hljs-number">1</span></span>) :(x + <span class="hljs-number"><span class="hljs-number">1</span></span>) julia&gt; expr.head :call julia&gt; expr.args <span class="hljs-number"><span class="hljs-number">3</span></span>-element <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Any</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}: :+ :x <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  <strong>Makro adalah salah satu alat pemrograman di Julia</strong> : kami memberi mereka sesuatu, mereka melihat, menambahkan yang tepat, menghapus yang tidak perlu, dan memberikan hasilnya.  Dalam semua contoh sebelumnya, kami meneruskan panggilan ke fungsi, dan makro di dalamnya mem-parsing panggilan.  Semua ini terjadi pada tingkat bekerja dengan pohon sintaksis. <br><br>  Anda dapat menguraikan ekspresi yang sangat sederhana: jika itu, misalnya, <code>(x+1)</code> , maka ini adalah panggilan ke fungsi <code>+</code> (penambahan bukan operator, seperti dalam banyak bahasa lain, tetapi fungsi) dan dua argumen: satu karakter (titik dua berarti bahwa itu adalah karakter ), dan yang kedua hanya sebuah konstanta. <br><br>  Contoh makro sederhana lainnya: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">macro</span></span> named(name, expr) println(<span class="hljs-string"><span class="hljs-string">"Starting </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$name</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">quote</span></span> $(esc(expr)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> julia&gt; <span class="hljs-meta"><span class="hljs-meta">@named</span></span> <span class="hljs-string"><span class="hljs-string">"some process"</span></span> x=<span class="hljs-number"><span class="hljs-number">5</span></span>; Starting some process julia&gt; x <span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre> <br>  Menggunakan makro, misalnya, indikator kemajuan atau filter untuk bingkai data dibuat - ini adalah mekanisme umum di Julia. <br><blockquote>  Macro tidak dieksekusi pada saat panggilan, tetapi ketika menguraikan kode. </blockquote>  Ini adalah fitur makro utama di Julia.  -    ,       .   ,   ,       . <br><br><h3> ,      </h3><br> Julia —     .      . <br><br><ul><li> Julia  <strong> </strong> .       . </li><li> <strong> </strong> ,    .    ,   ,  C    . </li><li>  Julia <strong>JIT-  </strong> .   ,  , ,   ,    . </li><li>     — <strong> </strong> .      . </li><li> <strong>    </strong>     ( ).       ,         .    ,    ,    . </li><li> Julia  <strong></strong> —      . </li></ul><br><h2>  Ekosistem </h2><br>  ,    ,   Julia   .    ,     , data science   ,    ,  ,     Python. ,  Python  Pandas,      ,    ,    ,   Julia      . <br><br>  Julia  ,       Python 2008 .        Python,        ,    Julia.    ,     .    ,    Julia. <br><br><h3>   ( ) Python  Julia </h3><br> <strong> </strong> .    Julia:  , ,    .… <br><br> <strong></strong> .   . <br><br><ul><li> <strong>DataFrames.jl</strong> . </li><li>   <strong>JuliaDB</strong>     ,       . </li><li>        <strong>Query.jl</strong> .     Pandas —    - ,   .. </li></ul><br> <strong>Plotting</strong> .     <strong>Matplotlib</strong> ,         Julia.     :  <strong>VegaLite.jl</strong> ,   <strong>Plots.jl</strong> ,     ,  <strong>Gadfly.jl</strong> . <br><br> <strong> </strong> .    <strong>TensorFlow</strong> ,     Flux.jl.    Flux    , ,     ,   Keras  TensorFlow,   .      . <br><br> <strong>Scikit-learn</strong> .   ,  ,     sklearn,    ,  . <br><br> <strong>XGBoost</strong> .  ,  Julia   . <br><br><h3>     ? </h3><br>     <strong>Jupyter</strong> . IDE —  Juno,    Visual Studio,         . <br><br> <strong></strong> .  GPU/TPU  .  CUDAnative.jl    Julia     .    Julia-,    -     ,        .    ,      ,      , , . <br><br> <strong> :</strong>   C, Fortran, Python   . <br><br> <strong> </strong>   ,    . <br><br> <strong>Packaging</strong> :      Julia:      , ,   .. <br><br><h3>   </h3><br>      ,      ,   .  ,   ,    .   ,   <strong>PyTorch</strong>       ,  TensorFlow,     ,        . <br><br>      ,        , ,      .      Julia,   , ,      .   ,   <strong> </strong> ,  <strong>Zygote.jl</strong> .     Flux.jl. <br><br><pre> <code class="julia hljs">julia&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Zygote julia&gt; <span class="hljs-literal"><span class="hljs-literal">φ</span></span>(x) = x*sin(x) julia&gt; Zygote.gradient(<span class="hljs-literal"><span class="hljs-literal">φ</span></span>, <span class="hljs-literal"><span class="hljs-literal">π</span></span>/<span class="hljs-number"><span class="hljs-number">2.</span></span>) (<span class="hljs-number"><span class="hljs-number">1.0</span></span>,) julia&gt; model = Chain(Dense(<span class="hljs-number"><span class="hljs-number">768</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span>, relu), Dense(<span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>), softmax) julia&gt; loss(x, y) = crossentropy(model(x), y) + sum(norm, params(model)) julia&gt; optimizer = ADAM(<span class="hljs-number"><span class="hljs-number">0.001</span></span>) julia&gt; Flux.train!(loss, params(model), data, optimizer) julia&gt; model = Chain(x -&gt; sqrt(x), x-&gt;x-<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>     <code>φ</code>  , , ,       . <br><br>  Zygote   «source-to-source»:         ,    ,   .   <strong>differentiable programming —  </strong> —       backpropagation     ,    . <br><br>     Julia     : «source-to-source»          ,      . ,     . <br><br><h2>  Julia  ? </h2><br>     ,         —  .        . <br><br>   - , , ,       — . <br><br>    ,   ,  . <br><br>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Julia</a> ,   . <br><br><ul><li>     ,  ,    . Julia   «» . </li><li>    ,     API,     ,    . </li></ul><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Moscow Python Conf++</a>    ,  27   ,          Python  Julia.   ,     ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">telegram-</a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>  MoscowPython. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id476114/">https://habr.com/ru/post/id476114/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id476104/index.html">Jangan gunakan MTProxy gratis dan jenis proxy gratis lainnya ...</a></li>
<li><a href="../id476106/index.html">"Cryptosystems Protocols": Diffie - Hellman, El-Gamal, MTI / A (0), STS</a></li>
<li><a href="../id476108/index.html">Otak yang bisa berubah</a></li>
<li><a href="../id476110/index.html">Mengapa TI membutuhkan merek pribadi</a></li>
<li><a href="../id476112/index.html">Elixir sebagai tujuan pengembangan untuk python async</a></li>
<li><a href="../id476118/index.html">Desain antarmuka untuk game, menggambar cincin Havel dari Dark Souls 3</a></li>
<li><a href="../id476122/index.html">“Dengarkan” kosmos: dari materi gelap hingga komet Churyumov - Gerasimenko</a></li>
<li><a href="../id476126/index.html">Cara menguji kinerja server: pemilihan beberapa tolok ukur sumber terbuka</a></li>
<li><a href="../id476128/index.html">Ivan Osipov dan Yuri Artamonov tentang Kotlin dan plugin untuk IntelliJ IDEA di pertemuan jug.msk.ru</a></li>
<li><a href="../id476134/index.html">MONQ - pemantauan dan AIOps berasal dari Rusia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>