<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👆🏼 📈 🕴🏼 Recherchez des incidents et des réclamations similaires. Mesures et optimisation 🧙🏽 🕴🏽 👩‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans un article précédent, j'ai parlé de notre moteur de recherche pour des applications similaires . Après son lancement, nous avons commencé à recev...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Recherchez des incidents et des réclamations similaires. Mesures et optimisation</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472772/"><p>  Dans un article précédent, j'ai parlé de notre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">moteur de recherche pour des applications similaires</a> .  Après son lancement, nous avons commencé à recevoir les premiers avis.  Les analystes ont aimé et recommandé certaines recommandations, d'autres non. </p><br><p>  Pour avancer et trouver de meilleurs modèles, il a d'abord fallu évaluer les performances du modèle actuel.  Il était également nécessaire de sélectionner des critères permettant de comparer les deux modèles. </p><br><p>  Sous la coupe, je vais parler de: </p><br><ul><li>  recueillir des commentaires sur les recommandations </li><li>  élaboration de paramètres pour évaluer la qualité des recommandations </li><li>  construire un cycle d'optimisation de modèle </li><li>  reçu des idées et un nouveau modèle </li></ul><a name="habracut"></a><br><h2 id="sbor-otzyvov">  Collecte de commentaires </h2><br><p>  Il serait idéal de recueillir des commentaires explicites des analystes: quelle est la pertinence de la recommandation de chacun des incidents proposés.  Cela nous permettra de comprendre la situation actuelle et de continuer à améliorer le système sur la base d'indicateurs quantitatifs. </p><br><p>  Il a été décidé de collecter les avis dans un format extrêmement simple: </p><br><ul><li>  nombre d'incidents que nous analysons </li><li>  numéro d'incident recommandé </li><li>  examen des recommandations: bon / mauvais </li></ul><br><p>  Le "vote" (un petit projet qui a accepté les demandes GET avec des paramètres et a mis les informations dans un fichier) a été placé directement dans le bloc de recommandations afin que les analystes puissent laisser leurs commentaires immédiatement en cliquant simplement sur l'un des liens: "bon" ou "mauvais". </p><br><p>  De plus, pour un examen rétrospectif de la recommandation, une solution très simple a été faite: </p><br><ul><li>  pour une grande partie des données historiques, un modèle a été lancé; </li><li>  Les recommandations recueillies ont été présentées sous la forme de plusieurs fichiers HTML autonomes, dans lesquels le même «vote» a été utilisé; </li><li>  des dossiers préparés ont été remis aux analystes afin de visualiser les résultats de 50 à 100 incidents. </li></ul><br><p>  Il a donc été possible de collecter des données sur environ 4000+ paires de recommandations d'incidents. </p><br><h2 id="pervichnyy-analiz-otzyvov">  Analyse de l'examen initial </h2><br><p>  Les mesures initiales étaient «moyennes» - la part des «bonnes» recommandations, selon les collègues, n'était que d'environ 25%. </p><br><p>  Les principaux problèmes du premier modèle: </p><br><ol><li>  les incidents concernant de «nouveaux» problèmes ont reçu des recommandations non pertinentes du système;  Il s'est avéré qu'en l'absence de coïncidences dans le contenu de l'appel, le système a sélectionné des incidents proches du service de l'employé contactant. </li><li>  des recommandations pour un incident sur un système frappent des incidents d'autres systèmes.  Les mots utilisés dans l'appel étaient similaires, mais décrivaient les problèmes des autres systèmes et étaient différents. </li></ol><br><p>  Les moyens possibles d'améliorer la qualité des recommandations ont été sélectionnés: </p><br><ul><li>  ajustement de la composition et du poids des attributs de traitement inclus dans le vecteur final </li><li> sélection des paramètres de vectorisation <code>TfidfVectorizer</code> </li><li>  sélection de la distance de coupure des recommandations </li></ul><br><h2 id="vyrabotka-kriteriev-kachestva-i-metodiki-ocenki">  Élaboration de critères de qualité et de méthodes d'évaluation </h2><br><p>  Pour rechercher une version améliorée du modèle, il est nécessaire de déterminer le principe de l'évaluation de la qualité des résultats du modèle.  Cela vous permettra de comparer quantitativement les deux modèles et de choisir le meilleur. </p><br><h3 id="chto-mozhno-poluchit-iz-sobrannyh-otzyvov">  Que peut-on obtenir des avis recueillis </h3><br><p>  Nous avons plusieurs <strong>m</strong> tuples de la forme: "Incident", "Incident recommandé", "Evaluation de la recommandation". </p><br><ul><li>  "Note de recommandation" ( <strong>v</strong> ) - est défini en binaire: "Bon" |  Pauvre (1 / -1); </li><li>  "Incident" et "Incident recommandé" sont simplement des numéros d'incident.  Sur eux, vous pouvez trouver l'incident dans la base de données. </li></ul><br><p>  Ayant de telles données, vous pouvez calculer: </p><br><ul><li>  <code>n_inc_total</code> - Le nombre total d'incidents pour lesquels il existe des recommandations </li><li>  <code>n_inc_good</code> - Le nombre d'incidents pour lesquels il existe de «bonnes» recommandations </li><li>  <code>avg_inc_good</code> - Le nombre moyen de «bonnes» recommandations pour les incidents </li><li>  <code>n_rec_total</code> - Nombre total de recommandations </li><li>  <code>n_rec_good</code> - Le nombre total de «bonnes» recommandations </li><li>  <code>pct_inc_good</code> - part des incidents pour lesquels il existe de "bonnes" recommandations <br> <code>pct_inc_good = n_inc_good / n_inc_total</code> </li> <li>  <code>pct_rec_good</code> - part totale des "bonnes" recommandations <br> <code>pct_rec_good = n_rec_good / n_rec_total</code> </li> </ul><br><p>  Ces indicateurs, calculés sur la base des estimations des utilisateurs, peuvent être considérés comme des «indicateurs de base» du modèle d'origine.  Avec lui, nous comparerons des indicateurs similaires de nouvelles versions du modèle. </p><br><p>  Prenez tous les «incidents» uniques de <strong>m</strong> et faites-les passer par le nouveau modèle. </p><br><p>  En conséquence, nous obtenons de nombreux <strong>m *</strong> tuples: "Incident", "Incident recommandé", "Distance". <br>  Ici, "distance" est la métrique définie dans NearestNeighbors.  Dans notre modèle, c'est la distance cosinus.  La valeur "0" correspond à la coïncidence complète des vecteurs. </p><br><h3 id="podbor-rasstoyaniya-otsechki">  Sélection de la "distance de coupure" </h3><br><p>  En complétant l'ensemble de recommandations <strong>m * avec des</strong> informations sur l'estimation vraie de <strong>v à</strong> partir de l'ensemble initial d'estimations de <strong>m</strong> , nous obtenons la correspondance entre la distance <strong>d</strong> et l'estimation vraie de <strong>v</strong> pour ce modèle. </p><br><p>  Ayant l'ensemble ( <strong>d</strong> , <strong>v</strong> ), il est possible de choisir le niveau de coupure optimal <strong>t</strong> , qui pour d &lt;= t la recommandation sera "bonne", et pour d&gt; t - "mauvaise".  La sélection de t peut être effectuée en optimisant le classificateur binaire le plus simple <code>v = -1 if d&gt;t else 1</code> rapport à l'hyperparamètre t, et en utilisant, par exemple, AUC ROC comme métrique. </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#     class BinarizerClassifier(Binarizer): def transform(self, x): return np.array([-1 if _x &gt; self.threshold else 1 for _x in np.array(x, dtype=float)]).reshape(-1, 1) def predict_proba(self, x): z = self.transform(x) return np.array([[0 if _x &gt; 0 else 1, 1 if _x &gt; 0 else 0] for _x in z.ravel()]) def predict(self, x): return self.transform(x) # #   : # -  , # -    m* # -   (d,v)  z_data_for_t # #   t b = BinarizerClassifier() z_x = z_data_for_t[['distance']] z_y = z_data_for_t['TYPE'] cv = GridSearchCV(b, param_grid={'threshold': np.arange(0.1, 0.7, 0.01)}, scoring='roc_auc', cv=5, iid=False, n_jobs=-1) cv.fit(z_x, z_y) score = cv.best_score_ t = cv.best_params_['threshold'] best_b = cv.best_estimator_</span></span></code> </pre> <br><p>  La valeur <strong>t</strong> obtenue peut être utilisée pour filtrer les recommandations. </p><br><p>  Bien sûr, cette approche peut encore ignorer les «mauvaises» recommandations et couper les «bonnes».  Par conséquent, à ce stade, nous affichons toujours les recommandations du "Top 5", mais nous marquons spécialement celles qui sont considérées comme "bonnes", en tenant compte du <strong>t</strong> trouvé. <br>  Alternative: si au moins une «bonne» recommandation est trouvée, ne montrer que «bonne».  Sinon, affichez tous les disponibles (également - "Top N"). </p><br><h3 id="predpolozhenie-dlya-sravneniya-modeley">  Hypothèse de comparaison des modèles </h3><br><p>  Pour les modèles de formation, le même cas d'incident est utilisé. <br>  Supposons que si une «bonne» recommandation a déjà été trouvée, le nouveau modèle devrait également trouver une «bonne» recommandation pour le même incident.  En particulier, le nouveau modèle peut trouver les mêmes «bonnes» recommandations que l'ancien.  Cependant, avec le nouveau modèle, nous nous attendons à ce que le nombre de «mauvaises» recommandations diminue. </p><br><p>  Ensuite, en considérant les mêmes indicateurs pour les recommandations <strong>m * du</strong> nouveau modèle, ils peuvent être comparés aux indicateurs correspondants pour <strong>m</strong> .  Sur la base de la comparaison, vous pouvez choisir le meilleur modèle. </p><br><p>  Il existe deux manières de prendre en compte les «bonnes» recommandations pour l'ensemble <strong>m *</strong> : </p><br><ol><li>  sur la base du <strong>t</strong> trouvé: considérer que toutes les recommandations de <strong>m *</strong> avec <strong>d</strong> &lt; <strong>t</strong> sont «bonnes» et les prendre en compte pour le calcul des métriques </li><li>  sur la base des estimations vraies correspondantes de l'ensemble <strong>m</strong> : dans les recommandations <strong>m *,</strong> sélectionnez uniquement celles pour lesquelles il existe une estimation vraie en <strong>m</strong> et jetez le reste. </li></ol><br><p>  Dans le premier cas, les indicateurs "absolus" ( <code>n_inc_good</code> , <code>n_rec_good</code> ) du nouveau modèle doivent être supérieurs à ceux du modèle de base.  Dans le second cas, les indicateurs doivent s'approcher des indicateurs du modèle de base. <br>  Le problème de la seconde méthode: si le nouveau modèle est meilleur que l'original, et qu'il trouve quelque chose de précédemment inconnu, une telle recommandation ne sera pas prise en compte dans le calcul. </p><br><h3 id="vybor-parametrov-sravneniya-modeley">  Sélectionnez les options de comparaison de modèles </h3><br><p>  Lors du choix d'un nouveau modèle, je souhaite que les indicateurs s'améliorent par rapport au modèle existant: </p><br><ul><li>  nombre moyen de «bonnes» recommandations par incident ( <code>avg_inc_good</code> ) </li><li>  nombre d'incidents pour lesquels il existe de «bonnes» recommandations ( <code>n_inc_good</code> ). </li></ul><br><p>  Pour la comparaison avec le modèle d'origine, nous utiliserons les relations de ces paramètres du nouveau modèle et de l'original.  Ainsi, si le rapport du paramètre du nouveau modèle à l'ancien est supérieur à 1, le nouveau modèle est meilleur. </p><br><pre> <code class="plaintext hljs">benchmark_agv_inc_good = avg_inc_good* / avg_inc_good benchmark_n_inc_good = n_inc_good* / n_inc_good</code> </pre> <br><p>  Pour simplifier la sélection, il est préférable d'utiliser un seul paramètre.  Nous prenons la moyenne harmonique des indicateurs relatifs individuels et nous l'utilisons comme seul critère de qualité composite pour le nouveau modèle. </p><br><pre> <code class="plaintext hljs">composite = 2 / ( 1/benchmark_agv_inc_good + 1/benchmark_n_inc_good)</code> </pre> <br><h2 id="novaya-model-i-ee-optimizaciya">  Nouveau modèle et son optimisation </h2><br><p>  Pour le nouveau modèle, dans le vecteur final représentant l'incident, nous ajoutons les composants responsables de la "zone d'incident" (l'un des nombreux systèmes desservis par notre équipe). <br>  Les informations sur l'unité et l'emplacement de l'employé qui a créé l'incident sont également placées dans un composant vectoriel distinct.  Tous les composants ont leur poids dans le vecteur final. </p><br><pre> <code class="python hljs">p = Pipeline( steps=[ (<span class="hljs-string"><span class="hljs-string">'grp'</span></span>, ColumnTransformer( transformers=[ (<span class="hljs-string"><span class="hljs-string">'text'</span></span>, Pipeline(steps=[ (<span class="hljs-string"><span class="hljs-string">'pp'</span></span>, CommentsTextTransformer(n_jobs=<span class="hljs-number"><span class="hljs-number">-1</span></span>)), (<span class="hljs-string"><span class="hljs-string">"tfidf"</span></span>, TfidfVectorizer(stop_words=get_stop_words(), ngram_range=(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), max_features=<span class="hljs-number"><span class="hljs-number">10000</span></span>, min_df=<span class="hljs-number"><span class="hljs-number">0</span></span>)) ]), [<span class="hljs-string"><span class="hljs-string">'short_description'</span></span>, <span class="hljs-string"><span class="hljs-string">'comments'</span></span>] ), (<span class="hljs-string"><span class="hljs-string">'area'</span></span>, OneHotEncoder(handle_unknown=<span class="hljs-string"><span class="hljs-string">'ignore'</span></span>), [<span class="hljs-string"><span class="hljs-string">'area'</span></span>] ), (<span class="hljs-string"><span class="hljs-string">'dept'</span></span>, OneHotEncoder(handle_unknown=<span class="hljs-string"><span class="hljs-string">'ignore'</span></span>), [<span class="hljs-string"><span class="hljs-string">'u_impacted_department'</span></span>] ), (<span class="hljs-string"><span class="hljs-string">'loc'</span></span>, OneHotEncoder(handle_unknown=<span class="hljs-string"><span class="hljs-string">'ignore'</span></span>), [<span class="hljs-string"><span class="hljs-string">'u_impacted_location'</span></span>] ) ], transformer_weights={<span class="hljs-string"><span class="hljs-string">'text'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'area'</span></span>: <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-string"><span class="hljs-string">'dept'</span></span>: <span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-string"><span class="hljs-string">'loc'</span></span>: <span class="hljs-number"><span class="hljs-number">0.1</span></span>}, n_jobs=<span class="hljs-number"><span class="hljs-number">-1</span></span> )), (<span class="hljs-string"><span class="hljs-string">'norm'</span></span>, Normalizer()), (<span class="hljs-string"><span class="hljs-string">"nn"</span></span>, NearestNeighborsTransformer(n_neighbors=<span class="hljs-number"><span class="hljs-number">10</span></span>, metric=<span class="hljs-string"><span class="hljs-string">'cosine'</span></span>)) ], memory=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>)</code> </pre> <br><p>  Les hyperparamètres du modèle devraient affecter les cibles du modèle.  Dans l'architecture du modèle sélectionné, nous considérerons comme hyperparamètres: </p><br><ul><li>  Paramètres de vectorisation TF-IDF - n-grammes utilisés (ngram_range), taille du dictionnaire (max_features), durée minimale de conduite (min_df) </li><li>  contribution des composantes au vecteur final - transformer_weights. </li></ul><br><p>  Les valeurs initiales des hyperparamètres de vectorisation de texte sont tirées du modèle précédent.  Les poids initiaux des composants sont sélectionnés sur la base d'un jugement d'expert. </p><br><h3 id="cikl-podbora-parametrov">  Cycle de sélection des paramètres </h3><br><p>  Comment comparer, sélectionner le niveau de raté et comparer les modèles entre eux ont déjà été déterminés.  Nous pouvons maintenant procéder à l'optimisation par la sélection d'hyperparamètres. </p><br><p><img src="https://habrastorage.org/webt/zy/zy/kb/zyzykbygrls9ca0bjscn3usfqby.png" alt="Cycle d'optimisation"></p><br><pre> <code class="python hljs">param_grid = { <span class="hljs-string"><span class="hljs-string">'grp__text__tfidf__ngram_range'</span></span>: [(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)], <span class="hljs-string"><span class="hljs-string">'grp__text__tfidf__max_features'</span></span>: [<span class="hljs-number"><span class="hljs-number">5000</span></span>, <span class="hljs-number"><span class="hljs-number">10000</span></span>, <span class="hljs-number"><span class="hljs-number">20000</span></span>], <span class="hljs-string"><span class="hljs-string">'grp__text__tfidf__min_df'</span></span>: [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0001</span></span>, <span class="hljs-number"><span class="hljs-number">0.0005</span></span>, <span class="hljs-number"><span class="hljs-number">0.001</span></span>], <span class="hljs-string"><span class="hljs-string">'grp__transformer_weights'</span></span>: [{<span class="hljs-string"><span class="hljs-string">'text'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'area'</span></span>: <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-string"><span class="hljs-string">'dept'</span></span>: <span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-string"><span class="hljs-string">'loc'</span></span>: <span class="hljs-number"><span class="hljs-number">0.1</span></span>}, {<span class="hljs-string"><span class="hljs-string">'text'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'area'</span></span>: <span class="hljs-number"><span class="hljs-number">0.75</span></span>, <span class="hljs-string"><span class="hljs-string">'dept'</span></span>: <span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-string"><span class="hljs-string">'loc'</span></span>: <span class="hljs-number"><span class="hljs-number">0.1</span></span>}, {<span class="hljs-string"><span class="hljs-string">'text'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'area'</span></span>: <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-string"><span class="hljs-string">'dept'</span></span>: <span class="hljs-number"><span class="hljs-number">0.3</span></span>, <span class="hljs-string"><span class="hljs-string">'loc'</span></span>: <span class="hljs-number"><span class="hljs-number">0.3</span></span>}, {<span class="hljs-string"><span class="hljs-string">'text'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'area'</span></span>: <span class="hljs-number"><span class="hljs-number">0.75</span></span>, <span class="hljs-string"><span class="hljs-string">'dept'</span></span>: <span class="hljs-number"><span class="hljs-number">0.3</span></span>, <span class="hljs-string"><span class="hljs-string">'loc'</span></span>: <span class="hljs-number"><span class="hljs-number">0.3</span></span>}, {<span class="hljs-string"><span class="hljs-string">'text'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'area'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'dept'</span></span>: <span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-string"><span class="hljs-string">'loc'</span></span>: <span class="hljs-number"><span class="hljs-number">0.1</span></span>}, {<span class="hljs-string"><span class="hljs-string">'text'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'area'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'dept'</span></span>: <span class="hljs-number"><span class="hljs-number">0.3</span></span>, <span class="hljs-string"><span class="hljs-string">'loc'</span></span>: <span class="hljs-number"><span class="hljs-number">0.3</span></span>}, {<span class="hljs-string"><span class="hljs-string">'text'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'area'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'dept'</span></span>: <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-string"><span class="hljs-string">'loc'</span></span>: <span class="hljs-number"><span class="hljs-number">0.5</span></span>}], } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> param <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ParameterGrid(param_grid=param_grid): p.set_params(**param) p.fit(x) ...</code> </pre> <br><h3 id="rezultaty-optimizacii">  Résultats d'optimisation </h3><br><p>  Le tableau montre les résultats d'expériences dans lesquelles des résultats intéressants ont été obtenus - les 5 meilleures et les pires valeurs pour les indicateurs contrôlés. </p><br><p><img src="https://habrastorage.org/webt/bi/l2/tj/bil2tj8dbqexqtezwmxealh3imq.png"></p><br><p>  Les cellules avec des indicateurs dans le tableau sont marquées comme suit: </p><br><ul><li>  le vert foncé est le meilleur indicateur parmi toutes les expériences </li><li>  vert pâle - la valeur de l'indicateur est dans le top-5 </li><li>  rouge foncé - le pire indicateur de toutes les expériences </li><li>  rouge pâle - l'indicateur est dans le pire-5 </li></ul><br><p>  Le meilleur indicateur composite a été obtenu pour un modèle avec paramètres: </p><br><pre> <code class="plaintext hljs">ngram_range = (1,2) min_df = 0.0001 max_features = 20000 transformer_weights = {'text': 1, 'area': 1, 'dept': 0.1, 'loc': 0.1}</code> </pre> <br><p>  Un modèle avec ces paramètres a montré une amélioration de l'indicateur composite par rapport au modèle d'origine 24% </p><br><h2 id="nekotorye-nablyudeniya-i-vyvody">  Quelques observations et conclusions </h2><br><p>  Selon les résultats d'optimisation: </p><br><ol><li><p>  L'utilisation de trigrammes ( <code>ngram_range = (1,3)</code> ) ne semble pas justifiée.  Ils gonflent le dictionnaire et augmentent légèrement la précision par rapport aux bigrammes. </p><br></li><li><p>  Un comportement intéressant lors de la construction d'un dictionnaire utilisant uniquement des bigrammes ( <code>ngram_range = (2,2)</code> ): la "précision" des recommandations augmente et le nombre de recommandations trouvées diminue.  Tout comme un équilibre précision / rappel dans les classificateurs.  Un comportement similaire est observé dans la sélection du niveau de coupure <strong>t</strong> - pour les bigrammes, un «cône» de coupure plus étroit et une meilleure séparation des «bonnes» et des «mauvaises» recommandations sont caractéristiques. </p><br></li><li><p>  Le paramètre non nul min_df, avec les bigrammes, augmente la précision des recommandations.  Ils commencent à être basés sur des termes qui se produisent au moins plusieurs fois.  À mesure que le paramètre augmente, le dictionnaire commence à rétrécir rapidement.  Pour les petits échantillons, comme dans notre cas, il sera probablement plus compréhensible d'opérer avec le nombre de documents (valeur entière min_df) que la fraction de documents (valeur fractionnaire min_df) contenant le terme. </p><br></li><li><p>  De bons résultats sont obtenus lorsque l'attribut incident responsable de la "région" est inclus dans le vecteur final avec une pondération égale ou proche de la composante texte.  Des valeurs faibles entraînent une augmentation de la proportion de «mauvaises» recommandations en raison de la découverte de mots similaires dans des documents provenant d'autres domaines.  Mais les signes de l'emplacement du client n'affectent pas si bien les résultats des recommandations dans notre cas. </p><br></li></ol><br><p>  De nouvelles idées ont émergé: </p><br><ul><li>  ajouter une composante «temps» afin que les incidents récents aient priorité sur les incidents similaires. </li><li>  voyez comment l'introduction du paramètre max_df influencera - bien qu'avec tf-idf des mots trop généraux pour le corpus ne devraient pas avoir un poids significatif, par définition. </li><li>  essayer enfin d'autres façons de vectoriser le contenu, par exemple, en se basant sur le mot à vecteur, ou en se basant sur la convolution de vues tf-idf à l'aide de réseaux. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr472772/">https://habr.com/ru/post/fr472772/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr472760/index.html">Réduisez le temps de calcul de quelques années à quelques minutes. Comprendre l'apprentissage automatique quantique</a></li>
<li><a href="../fr472762/index.html">Analyse technique de l'exploit checkm8</a></li>
<li><a href="../fr472766/index.html">Paramétrage à partir d'un fichier dans py.test</a></li>
<li><a href="../fr472768/index.html">Comment recruter, licencier et revenir de la gestion au développement: vidéo du Badoo Techleads Meetup # 5</a></li>
<li><a href="../fr472770/index.html">Organisation de l'interface dans Unity avec UI Canvas</a></li>
<li><a href="../fr472776/index.html">Sauvegarde, partie 7: Conclusions</a></li>
<li><a href="../fr472778/index.html">5 façons d'utiliser le Raspberry Pi</a></li>
<li><a href="../fr472780/index.html">Pourquoi éviter les amis ou comment j'ai perdu tous mes avantages</a></li>
<li><a href="../fr472782/index.html">Pourquoi 3D Headache / Part 8 Defocus et l'avenir de la 3D</a></li>
<li><a href="../fr472790/index.html">Antiquités: i-Mate Jasjar, un communicateur pour les entreprises</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>