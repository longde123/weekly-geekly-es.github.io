<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§Ωüèø üìú üíã Wenn man eine Programmiersprache des 21. Jahrhunderts erfindet üçÑ üå©Ô∏è üç∏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Autor des Artikels diskutiert die Probleme moderner Programmiersprachen und die M√∂glichkeiten, M√§ngel zu beheben. 


 In den letzten 18 Jahren hab...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wenn man eine Programmiersprache des 21. Jahrhunderts erfindet</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/wirex/blog/431558/">  <i>Der Autor des Artikels diskutiert die Probleme moderner Programmiersprachen und die M√∂glichkeiten, M√§ngel zu beheben.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tk/nl/u6/tknlu6j7laqqcrsjz_arrflsebm.jpeg"></div><br>  In den letzten 18 Jahren haben sich viele Sprachen ausgedacht, von denen Swift, Kotlin und Go wahrscheinlich die beliebtesten sind.  Gleichzeitig ist das Unterscheidungsmerkmal der Programmiersprache des 21. Jahrhunderts das Fehlen jeglicher Unterscheidungsmerkmale.  Das Sch√∂nste an der Arbeit mit solchen Sprachen ist, dass Sie ein Wochenende damit verbringen k√∂nnen, eine dieser Sprachen zu lernen, und schlie√ülich sagen, dass Sie es geschafft haben, eine beliebte Neuheit zu lernen, aber tats√§chlich haben Sie nichts Neues gelernt.  Sie sind wirklich nichts Neues.  Alle modernen Sprachen werden auf der Grundlage einer korrekten und bew√§hrten Formel erstellt, deren Name h√∂chstwahrscheinlich Objective-C, Java oder C lautet. <br><br>  "Mangel an Neuheit" kann als wertvolles Merkmal angesehen werden, aber diese Situation wirft eine Frage auf.  Stehen wir wirklich vor den Sprachen des neuen 21. Jahrhunderts oder spiegelt dies nur die schlechten Programmiergewohnheiten des 20. Jahrhunderts wider? <br><br>  Wenn ich die Sprache erfinden w√ºrde, w√ºrde ich nicht versuchen, die Vergangenheit zu korrigieren, sondern etwas schaffen, das unter modernen Bedingungen gut funktioniert, aber auch in der Lage ist, den Test der Zeit zu entwickeln und zu √ºberstehen.  Wenn dies radikale konstruktive L√∂sungen erfordert, dann sei es so. <br><br><h3>  Nieder mit der Syntax! </h3><br>  Die Syntax moderner Sprachen spiegelt den Versuch wider, die Freiheit von Kreide und Tafel in die Fesseln von ASCII zu dr√ºcken.  Einige Elemente eines Datensatzes, wie z. B. arithmetische Zeichen oder Klammern, werden mehr oder weniger nat√ºrlich wahrgenommen.  Eine Reihe anderer Bezeichnungen ist jedoch nur durch Einsparung von Aufwand beim Dr√ºcken der Teletyp-Tasten gerechtfertigt. <a name="habracut"></a><br><br>  Die Eingabe von Text √ºber die Tastatur ist nicht mehr schwierig.  Wir m√ºssen uns nicht in eine Position bringen, in der es notwendig ist, die Bedeutung der Syntax zu erraten.  St√ºcke wie <i>(($: @ (&lt;# [), (= # [), $: @ (&gt; # [)) ({~? @ #)) ^: (1 &lt;#)</i> - ein sehr kurzes und umfangreiches Aufnahmeformat (Dies ist √ºbrigens ein echtes St√ºck Code in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">echter Sprache</a> ), aber es verbessert in keiner Weise die Lesbarkeit.  Und was noch wichtiger ist, es ist schwierig, es zu "googeln" oder im Stackoverflow zu finden. <br><br>  Gleiches gilt f√ºr die mysteri√∂sen Namen von Funktionen, Konventionen von R√ºckkehrcodes und Attributen mit unklarer Bedeutung.  Sie haben in der Vergangenheit gute Dienste geleistet und viel Platz auf Lochkarten gespart, aber heute ist es Zeit f√ºr eine wohlverdiente Pause. <br><br>  So etwas wie <br><br> <code>FILE * test_file = fopen("/tmp/test.txt", "w+");</code> <br> <br>  sollte umgewandelt werden in <br><br> <code>create file /tmp/test.txt for input and output as test_file</code> <br> <br>  Wir brauchen nicht alle diese Klammern, Anf√ºhrungszeichen, Sternchen und Semikolons (es sei denn, sie vermitteln die Idee wirklich nicht klarer).  Die Syntaxhervorhebung kann die Syntaxnotation vollst√§ndig ersetzen. <br><br>  Im 21. Jahrhundert gibt es einige reichlich vorhandene Dinge: zum Beispiel Analysegeschwindigkeit, Computerspeicher, Online-Suche.  Andere Ressourcen sind noch im Preis: Entwicklungszeit, Speicher des Programmierers, Aufwand f√ºr das Erlernen der Merkmale der Sprache.  √Ñnderungen an den Regeln f√ºr das Schreiben von Code sollten den Fokus auf billigere Ressourcen verlagern und teurere einsparen. <br><br><h3>  Nieder mit den eingebauten Typen! </h3><br>  Sie sind wahrscheinlich mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JavaScript-Paradoxien</a> vertraut.  Zum Beispiel: <br><br> <code>&gt; 10.8 / 100 <br> 0.10800000000000001</code> <br> <br>  Dieses Ergebnis gilt nicht nur f√ºr JavaScript.  Und dies ist √ºberhaupt kein Paradoxon, sondern ein Beispiel f√ºr die absolut korrekte Einhaltung des anerkannten IEEE 754-Standards. Eine √§hnliche Implementierung von Gleitkommazahlen findet sich in fast allen Architekturen.  Und es ist nicht so schlimm, wenn man bedenkt, dass wir versuchen, eine unendliche Anzahl von reellen Zahlen in 32, 64 oder 256 Bit zu packen. <br><br>  Was Mathematiker f√ºr unm√∂glich halten, verk√∂rpern Ingenieure durch die Ablehnung des gesunden Menschenverstandes im Interesse der praktischen Umsetzung.  Die Gleitkommazahlen in der IEEE-Interpretation sind √ºberhaupt keine Zahlen.  Mathematik erfordert Assoziativit√§t aus der Operation ihrer Addition.  Die Typen float und double speichern diese Eigenschaft nicht immer.  F√ºr die Mathematik ist es erforderlich, dass die Menge der reellen Zahlen Ganzzahlen enth√§lt. Diese Anforderung wird jedoch auch f√ºr float und uint32_t derselben Gr√∂√üe nicht erf√ºllt.  Mathematik erfordert, dass reelle Zahlen ein Nullelement haben.  In dieser Hinsicht √ºbertrifft der IEEE-Standard alle Erwartungen, da Gleitkommazahlen zwei Nullelemente anstelle von einem haben. <br><br>  Nicht nur Gleitkommazahlen weisen √§hnliche Merkmale auf.  Eingebettete Ganzzahlen sind nicht besser implementiert.  Wissen Sie, was passiert, wenn Sie versuchen, zwei solche 16-Bit-Zahlen hinzuzuf√ºgen? <br><br> <code>0xFFFF + 0x0001</code> <br> <br>  Niemand wird eine genaue Antwort geben.  Ein Instinkt sagt uns, dass ein √úberlauf 0x0000 ergibt.  Ein solches Ergebnis ist jedoch in keinem internationalen Standard dokumentiert.  Bei der Handhabung dieses Vorgangs orientiert sich jeder am C-Ansatz und an der x86-Prozessorfamilie.  Alternativ kann 0xFFFF resultieren oder ein Interrupt wird ausgel√∂st oder ein spezielles Bit, das einen √úberlauf anzeigt, wird an einem speziellen Ort gespeichert. <br><br>  Solche Momente werden im Allgemeinen nirgendwo ber√ºcksichtigt, und die Regeln f√ºr die Verarbeitung solcher Operationen unterscheiden sich von Sprache zu Sprache.  Wenn Gleitkomma-Kuriosit√§ten zumindest durch den Standard festgelegt sind, ist die zuletzt aufgeworfene Frage im Prinzip unvorhersehbar. <br><br>  Stattdessen w√ºrde ich f√ºr numerische Berechnungen vorschlagen, Datentypen mit einem definierbaren Wert mit einem festen Punkt und mit standardisiertem Verhalten einzuf√ºhren, falls die Genauigkeit verloren geht oder die obere oder untere Grenze √ºberschritten wird.  So etwas wie das: <br><br> <code>1.000 / 3.000 = 0.333 <br> 0001 + 9999 = overflowed 9999 <br> 0.001 / 2 = underflowed 0</code> <br> <br>  Es ist nicht erforderlich, alle nachgestellten Nullen anzuh√§ngen: Ihr Vorhandensein muss durch die Definition des Datentyps impliziert werden.  Es ist jedoch wichtig, die maximalen und minimalen Grenzen selbst ausw√§hlen zu k√∂nnen und nicht von der Prozessorarchitektur abh√§ngig zu sein. <br><br>  Funktionieren solche Berechnungen nicht langsamer?  Ja, das werden sie.  Aber fragen Sie sich: Wie oft m√ºssen Sie Hochleistungsrechnen programmieren?  Ich glaube, wenn Sie kein Experte auf diesem Gebiet sind, ist dies sehr selten.  Und wenn Sie mit solchen Aufgaben besch√§ftigt sind, verwenden Sie f√ºr diese Zwecke spezielle Ger√§te und Compiler.  Soweit ich das beurteilen kann, l√∂st ein typischer Programmierer des 21. Jahrhunderts selten Differentialgleichungen. <br><br>  Wie dem auch sei, nichts hindert die Verwendung schneller, komplexer und unvorhersehbarer integrierter Typen aus der Vergangenheit als Alternative und nicht als Standardoption. <br><br><h3>  Nieder mit der Praxis der Metasprachen! </h3><br>  Es gibt wunderbare Sprachen, die nicht f√ºr die Ausf√ºhrung von Aufgaben erfunden wurden, sondern f√ºr die Erstellung von Sprachen, die diese ausf√ºhren k√∂nnen.  Racket, Rebol und Forth sind nur einige Beispiele.  Ich mag sie alle, mit ihnen zu spielen ist pure Freude.  Aber wie Sie wahrscheinlich vermutet haben, ist die Freude an der Arbeit mit der Sprache nicht das Hauptkriterium, das die Sprache universell und beliebt macht. <br><br>  Die F√§higkeit, neue Sprachen in einer Sprache zu erstellen, um eine bestimmte Aufgabe auszuf√ºhren, ist ein sehr leistungsf√§higes Werkzeug, das sich bei unabh√§ngigen Forschungsarbeiten voll auszahlt.  Wenn der Code nicht nur f√ºr den Autor, sondern auch f√ºr den Hauptcode klar sein soll, m√ºssen Sie leider andere Personen und die neue interne Sprache unterrichten.  Und hier beginnen die Probleme. <br><br>  Die Leute wollen die Aufgabe erledigen und keine Sprache lernen, die ihnen hilft, die Arbeit genau einmal zu erledigen, und danach werden sie sich nicht als n√ºtzlich erweisen.  F√ºr Au√üenstehende ist die Idee, Ihre Sprache zu beherrschen, eine Investition, die sich wahrscheinlich nicht auszahlt.  Aber etwas Standardisiertes zu lernen ist eine Investition f√ºrs Leben.  Daher schreiben sie Ihren Code erneut und lernen ihn erst dann.  Somit erscheinen unz√§hlige Dialekte f√ºr eine angewandte Sph√§re.  Die Leute streiten sich √ºber √Ñsthetik, Ideologie, Architektur und andere unwichtige Dinge.  Und Millionen von Codezeilen werden geschrieben, um in wenigen Monaten in Vergessenheit zu geraten. <br><br>  Die Lisp-Jungs haben das in den 80ern durchgemacht.  Sie erkannten, dass je mehr angewandte Sprachelemente standardisiert sind, desto besser.  So entstand Common Lisp. <br><br>  Und er war riesig.  Der INCITS 226‚Äì1994-Standard umfasst 1.153 Seiten.  Dieser Rekord 17 Jahre sp√§ter wurde nur von C ++ mit der Norm ISO / IEC 14882: 2011 (1338 Seiten) gebrochen.  C ++ muss ein unertr√§gliches Erbe schleppen, obwohl es nicht immer so gro√ü war.  Common Lisp wurde gr√∂√ütenteils von Grund auf neu erstellt. <br><br>  Die Programmiersprache sollte nicht so gro√ü sein.  Dies ist nicht erforderlich.  Er braucht nur eine gute Standardbibliothek, die mit allen m√∂glichen n√ºtzlichen Dingen gef√ºllt ist, damit die Leute das Rad nicht neu erfinden m√ºssen. <br><br>  Nat√ºrlich ist es nicht einfach, ein Gleichgewicht zwischen Gr√∂√üe und Anwendungseignung zu halten.  Die Erfahrung von C ++ in der Praxis hat gezeigt, wie schwierig es ist.  Ich glaube, um das notwendige Gleichgewicht zu erreichen, sollte die Sprache des 21. Jahrhunderts unter einem bestimmten Anwendungsbereich unter bestimmten Bedingungen gesch√§rft werden.  Da die meisten Probleme jetzt genau im Bereich der Gesch√§ftsanwendungen auftreten, sollte sich die Sprache wahrscheinlich auf gesch√§ftliche Probleme konzentrieren und nicht auf die Spieleentwicklung oder das Webdesign. <br><br><h3>  Also ... </h3><br>  Die Sprache des 21. Jahrhunderts sollte gesch√§ftsorientiert sein, klare Sprachausdr√ºcke verwenden und nicht von integrierten Typen abh√§ngen.  Sch√∂n, dass es eine solche Sprache schon gibt!  Was denkst du, wovon reden wir? <br><br>  Ja, das ist COBOL. <br><br>  Dies ist eine der ersten Hochsprachen, die heute meist vergessen sind.  Ich muss zugeben, dass ich die alten Merkmale von COBOL absichtlich als hochmodern und unglaublich vielversprechend beschrieben habe.  Und ich habe es getan, um eines zu zeigen.  Der Code wird nicht durch Sprachfunktionen geschrieben.  Du machst es. <br><br>  Es ist naiv zu glauben, dass die Sprache f√ºr die Qualit√§t des Codes verantwortlich ist und dass das Hinzuf√ºgen (oder Entfernen) einiger Gadgets automatisch alles verbessern kann.  Fr√ºher mochten Programmierer Fortran und COBOL nicht, deshalb erfanden sie C ++ und Java, um schlie√ülich zu einer Situation zu gelangen, in der sie 20 oder 30 Jahre sp√§ter auch alle nicht mochten. <br><br>  Nach meinen Gef√ºhlen liegt die Wurzel des Problems irgendwo im Bereich der Soziologie und Psychologie, aber nicht der Programmierung.  M√∂gen wir Sprachen wirklich nicht so sehr?  Und sind wir zufrieden mit dem Umfeld, in dem wir arbeiten?  Windows ist anf√§llig, Visual Studio ist zu langsam, es ist unm√∂glich, Vim zu beenden.  Tats√§chlich sind es diese Dinge, die Unzufriedenheit verursachen, und nicht der kreative Prozess selbst. <br><br>  Aber man muss immer den Schuldigen finden.  Als Software-Ingenieure, die teilweise daf√ºr verantwortlich sind, wie mies Programme sind, werden wir uns keine Vorw√ºrfe machen, oder?  Deshalb suchen wir nach Fehlern in den Werkzeugen.  Lassen Sie uns neue COBOLs erfinden, bis eines Tages die Sonne heller scheint, die V√∂gel nicht lauter singen und Windows in 2 Sekunden geladen wird. <br><br>  Aber h√∂chstwahrscheinlich wird dieser Tag niemals kommen. <br><br>  Wenn ich also die Programmiersprache des 21. Jahrhunderts erfinden wollte, w√ºrde ich stattdessen versuchen, einen neuen Ansatz f√ºr Verantwortung zu finden.  Oder eine neue M√∂glichkeit, vorhandene Tools besser zu beherrschen.  Ich w√ºrde versuchen, auf die wesentlichen Details zu achten und unn√∂tige Komplexit√§t gnadenlos loszuwerden.  Anstelle von Sprachen, die in die Mode kommen und aus der Mode kommen, gibt es immer einige grundlegende Dinge, die ein st√§ndiges Umdenken verdienen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/4bd/bf6/597/4bdbf659775744b1bdbb4d8a00a0a980.png" alt="Bild"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de431558/">https://habr.com/ru/post/de431558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de431546/index.html">Warum sagen wir OK?</a></li>
<li><a href="../de431548/index.html">Solar Dozor - Was steckt hinter den Sternen?</a></li>
<li><a href="../de431550/index.html">Film Injection Moulding (IMD): Wie es funktioniert</a></li>
<li><a href="../de431554/index.html">Facebook wie Z√§hler von einem alten Stromz√§hler</a></li>
<li><a href="../de431556/index.html">Sidenis √ºber die Zusammenarbeit mit Versicherungsunternehmen, agiles Coaching und verbotene Technologien</a></li>
<li><a href="../de431560/index.html">Zugriff auf SS7-Signalisierungsnetzwerke √ºber das Funksubsystem - jetzt ist es m√∂glich</a></li>
<li><a href="../de431562/index.html">Wie man mit altem Code rollt, wenn gestern ein Projekt ben√∂tigt wurde</a></li>
<li><a href="../de431564/index.html">Gr√∂√üter Fehler in der Geschichte der Physik</a></li>
<li><a href="../de431566/index.html">MEMS-Beschleunigungsmesser und Gyroskope - Verstehen der Spezifikationen</a></li>
<li><a href="../de431568/index.html">Fintech Digest: Telefon bezahlen, Geldautomaten erneut angreifen, Institutionalisierung der Kryptosph√§re</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>