<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👟 🐰 🧘🏽 Tinjauan singkat dan segar arsitektur kompiler 🦔 🚞 🙅🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sebagian besar kompiler memiliki arsitektur berikut: 



 Pada artikel ini, saya akan membedah arsitektur ini secara rinci, elemen demi elemen. 
 Kita...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tinjauan singkat dan segar arsitektur kompiler</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/451894/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/sl/ej/-i/slej-ivpokabgczeqdbgiafc0rw.jpeg"></div><br>  Sebagian besar kompiler memiliki arsitektur berikut: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/73e/ff7/c46/73eff7c467213f5de1b9134666f9e569.png"><br><br>  Pada artikel ini, saya akan membedah arsitektur ini secara rinci, elemen demi elemen. <br>  Kita dapat mengatakan bahwa artikel ini adalah tambahan untuk sumber daya yang ada dalam jumlah besar pada topik kompiler.  Ini adalah sumber otonom yang akan memungkinkan Anda untuk memahami dasar-dasar desain dan implementasi bahasa pemrograman. <br><br>  Target pembaca artikel ini adalah orang-orang yang idenya tentang pekerjaan penyusun sangat terbatas (maksimal adalah bahwa mereka terlibat dalam penyusunan).  Namun, saya berharap pembaca memahami struktur data dan algoritma. <br><br>  Artikel ini sama sekali tidak ditujukan untuk kompiler produksi modern dengan jutaan baris kode - tidak, ini adalah kursus singkat "kompiler untuk boneka" yang membantu untuk memahami apa itu kompiler. <br><a name="habracut"></a><br><h2>  Pendahuluan </h2><br>  Saat ini saya sedang mengerjakan bahasa sistem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Krug</a> yang terinspirasi oleh Rust and Go.  Dalam artikel itu saya akan merujuk ke Krug sebagai contoh untuk menggambarkan pikiran saya.  Krug sedang dalam pengembangan, tetapi sudah tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/krug-lang</a> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gudang</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">krug</a> repositori.  Bahasa ini tidak terlalu khas dibandingkan dengan arsitektur kompiler yang biasa, yang sebagian mengilhami saya untuk menulis artikel - tetapi lebih pada nanti. <br><br>  Saya segera memberi tahu Anda bahwa saya sama sekali bukan spesialis dalam penyusun!  Saya tidak memiliki gelar doktor, dan saya tidak menjalani pelatihan formal - saya mempelajari segala sesuatu yang dijelaskan dalam artikel saya sendiri di waktu luang saya.  Saya juga harus mengatakan bahwa saya tidak menggambarkan pendekatan yang sebenarnya, satu-satunya yang benar untuk membuat kompiler, tetapi saya menyajikan metode dasar yang cocok untuk membuat kompiler "mainan" kecil. <br><br><h2>  Frontend </h2><br>  Mari kita kembali ke diagram di atas: panah di sebelah kiri diarahkan ke bidang frontend adalah bahasa yang terkenal dan dicintai seperti C. Frontend terlihat seperti ini: analisis leksikal -&gt; pengurai. <br><br><h2>  Analisis leksikal </h2><br>  Ketika saya mulai mempelajari kompiler dan desain bahasa, saya diberitahu bahwa analisis leksikal sama dengan tokenization.  Kami akan menggunakan deskripsi ini.  Penganalisa mengambil input data dalam bentuk string atau aliran karakter dan mengenali pola di dalamnya, yang memotong token. <br><br>  Dalam hal kompiler, ia menerima program tertulis pada input.  Itu dibaca menjadi string dari file, dan alat analisa tokenizes kode sumbernya. <br><br><pre><code class="plaintext hljs">enum TokenType { Identifier, Number, }; struct Token { std::string Lexeme; TokenType type; // ... // It's also handy to store things in here // like the position of the token (start to end row:col) };</code> </pre> <br>  Dalam fragmen ini, ditulis dalam bahasa berbentuk-C, Anda dapat melihat struktur yang mengandung leksem tersebut, serta TokenType, yang berfungsi untuk mengenali token ini. <br><br>  Catatan: artikel ini bukan instruksi untuk membuat bahasa dengan contoh - tetapi untuk pemahaman yang lebih baik, saya akan memasukkan potongan kode dari waktu ke waktu. <br><br>  Analisis biasanya merupakan komponen kompiler paling sederhana.  Seluruh frontend, sebenarnya, cukup sederhana dibandingkan dengan potongan puzzle lainnya.  Meskipun itu sangat tergantung pada pekerjaan Anda. <br><br>  Ambil bagian kode C berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello world!\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Setelah membacanya dari file ke baris dan melakukan pemindaian linier, Anda mungkin dapat mengiris token.  Kami mengidentifikasi token dengan cara alami - melihat int adalah "kata", dan 0 dalam pernyataan pengembalian adalah "angka".  Alat analisis leksikal melakukan prosedur yang sama seperti yang kita lakukan - nanti kita akan memeriksa proses ini secara lebih rinci.  Misalnya, analisis angka: <br><br><pre> <code class="plaintext hljs">0xdeadbeef — HexNumber ( ) 1231234234 — WholeNumber ( ) 3.1412 — FloatingNumber (   ) 55.5555 — FloatingNumber (   ) 0b0001 — BinaryNumber ( )</code> </pre> <br>  Mendefinisikan kata bisa sulit.  Sebagian besar bahasa mendefinisikan kata sebagai urutan huruf dan angka, dan pengidentifikasi biasanya dimulai dengan huruf atau garis bawah.  Sebagai contoh: <br><br><pre> <code class="plaintext hljs">123foobar := 3 person-age := 5 fmt.Println(123foobar)</code> </pre> <br>  Di Go, kode ini tidak akan dianggap benar dan akan diuraikan ke dalam token berikut: <br><br><pre> <code class="plaintext hljs">Number(123), Identifier(foobar), Symbol(:=), Number(3) ...</code> </pre> <br>  Sebagian besar pengidentifikasi yang dijumpai terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">foo_bar __uint8_t fooBar123</code> </pre> <br>  Analisator harus menyelesaikan masalah lain, misalnya, dengan spasi, komentar multiline dan single-line, pengidentifikasi, angka, sistem angka dan pemformatan angka (misalnya, 1_000_000) dan pengkodean (misalnya, dukungan untuk UTF8 alih-alih ASCII). <br><br>  Dan jika Anda berpikir Anda dapat menggunakan ekspresi reguler - lebih baik tidak sepadan.  Jauh lebih mudah untuk menulis analisa dari awal, tetapi saya sangat merekomendasikan membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini</a> dari raja dan dewa kita Rob Pike.  Alasan Regex tidak cocok untuk kami dijelaskan dalam banyak artikel lain, jadi saya akan menghilangkan poin ini.  Selain itu, menulis analisa jauh lebih menarik daripada menyiksa diri sendiri dengan ekspresi panjang yang diunggah ke regex101.com pada jam 5:24 pagi.  Dalam bahasa pertama saya, saya menggunakan fungsi <code>split(str)</code> untuk tokenization - dan saya tidak pergi jauh. <br><br><h2>  Parsing </h2><br>  Parsing agak lebih rumit daripada analisis leksikal.  Ada banyak parser dan parser-generator - di sini permainan dimulai dengan cara yang besar. <br><br>  Parser dalam kompiler biasanya mengambil input dalam bentuk token dan membangun pohon tertentu - pohon sintaksis abstrak atau pohon parsing.  Secara alami, mereka mirip, tetapi memiliki beberapa perbedaan. <br><br>  Tahapan-tahapan ini dapat direpresentasikan sebagai fungsi: <br><br><pre> <code class="plaintext hljs">fn lex(string input) []Token {...} fn parse(tokens []Token) AST {...} let input = "int main() { return 0; }"; let tokens = lex(input); let parse_tree = parse(tokens); // ....</code> </pre> <br>  Biasanya, kompiler dibangun dari banyak komponen kecil yang mengambil input, mengubahnya, atau mengubahnya menjadi output yang berbeda.  Ini adalah salah satu alasan mengapa bahasa fungsional sangat cocok untuk membuat kompiler.  Alasan lainnya adalah pembandingan yang sangat baik dan perpustakaan standar yang cukup luas.  Fakta menyenangkan: implementasi pertama dari kompiler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rust</a> ada di Ocaml. <br><br>  Saya menyarankan Anda untuk menjaga komponen ini sesederhana dan otonom mungkin - modularitas akan sangat memudahkan proses.  Menurut pendapat saya, hal yang sama dapat dikatakan tentang banyak aspek lain dari pengembangan perangkat lunak. <br><br><h2>  Pohon </h2><br><h4>  Pohon parsing </h4><br>  Apa ini?  Juga dikenal sebagai parsing tree, pohon tebal ini berfungsi untuk memvisualisasikan program sumber.  Mereka berisi semua informasi (atau sebagian besar) tentang program input, biasanya sama dengan yang dijelaskan dalam tata bahasa bahasa Anda.  Setiap simpul pohon akan mengikuti atau tidak mengikuti, misalnya, NumberConstant atau StringConstant. <br><br><h4>  Pohon sintaksis abstrak </h4><br>  Seperti namanya, ASD adalah pohon sintaksis <i>abstrak</i> .  Pohon parsing berisi banyak (sering berlebihan) informasi tentang program Anda, dan dalam kasus ASD, itu tidak diperlukan.  ASD tidak memerlukan informasi yang tidak berguna tentang struktur dan tata bahasa, yang tidak mempengaruhi semantik program. <br><br>  Misalkan pohon Anda memiliki ekspresi seperti ((5 + 5) -3) +2.  Di pohon parsing, Anda akan menyimpannya sepenuhnya, bersama dengan tanda kurung, operator, dan nilai 5, 5, 3, dan 2. Tetapi Anda dapat dengan mudah mengaitkan dengan ASD - kita hanya perlu mengetahui nilai, operator, dan urutannya. <br><br>  Gambar di bawah ini menunjukkan pohon untuk ekspresi a + b / c. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98c/61a/cb3/98c61acb355e7887b53b5c37de0aa34f.png" width="400"></div><br>  ASD dapat direpresentasikan sebagai berikut: <br><br><pre> <code class="plaintext hljs">interface Expression { ... }; struct UnaryExpression { Expression value; char op; }; struct BinaryExpression { Expression lhand, rhand; string op; // string because the op could be more than 1 char. }; interface Node { ... }; // or for something like a variable struct Variable : Node { Token identifier; Expression value; };</code> </pre> <br>  Pandangan ini sangat terbatas, tetapi saya harap Anda dapat melihat bagaimana node Anda akan terstruktur.  Untuk penguraian, Anda dapat menggunakan prosedur berikut: <br><br><pre> <code class="plaintext hljs">Node parseNode() { Token current = consume(); switch (current.lexeme) { case "var": return parseVariableNode(); // ... } panic("unrecognized input!"); } Node n = parseNode(); if (n != null) { // append to some list of top level nodes? // or append to a block of nodes! }</code> </pre> <br>  Saya harap Anda mendapatkan inti tentang bagaimana langkah-demi-langkah parsing dari node yang tersisa akan dilanjutkan, dimulai dengan konstruksi bahasa tingkat tinggi.  Bagaimana tepatnya parser dengan keturunan rekursif diimplementasikan, Anda perlu belajar sendiri. <br><br><h2>  Tata bahasa </h2><br>  Mem-parsing dalam ADS dari sejumlah token bisa jadi sulit.  Biasanya Anda harus mulai dengan tata bahasa Anda.  Intinya, tata bahasa menentukan struktur bahasa Anda.  Ada beberapa bahasa untuk mendefinisikan bahasa yang dapat menggambarkan (atau menguraikan) sendiri. <br><br>  Contoh bahasa untuk menentukan bahasa adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bentuk diperpanjang dari Backus-Naur</a> (RBNF).  Ini adalah variasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BNF</a> dengan kurung sudut yang lebih sedikit.  Ini adalah contoh RBNF dari artikel Wikipedia: <br><br><pre> <code class="plaintext hljs">digit excluding zero = "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ; digit = "0" | digit excluding zero ;</code> </pre> <br>  Aturan produksi didefinisikan: mereka menunjukkan templat terminal mana yang "non-terminal".  Terminal adalah bagian dari alfabet, misalnya token atau 0 dan 1 pada contoh di atas adalah terminal.  Non-terminal adalah kebalikannya, mereka berada di sisi kiri aturan produksi, dan mereka dapat dianggap sebagai variabel atau "penunjuk bernama" untuk kelompok terminal dan non-terminal. <br><br>  Banyak bahasa memiliki spesifikasi yang mengandung tata bahasa.  Misalnya, untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Go</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rust,</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">D.</a> <br><br><h2>  Analisis Keturunan Rekursif </h2><br>  Turunan rekursif adalah yang termudah dari banyak pendekatan parsing. <br><br>  Analisis keturunan rekursif - turun, berdasarkan prosedur rekursif.  Jauh lebih mudah untuk menulis parser, karena tata bahasa Anda tidak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">meninggalkan rekursi</a> .  Dalam sebagian besar bahasa "mainan", teknik ini cukup untuk parsing.  GCC menggunakan parser descending yang ditulis tangan, meskipun YACC pernah digunakan sebelumnya. <br><br>  Namun, parsing bahasa-bahasa ini dapat menyebabkan masalah.  Secara khusus, C, di mana <br><br><pre> <code class="cpp hljs">foo * bar</code> </pre> <br>  dapat diartikan sebagai <br><br><pre> <code class="plaintext hljs">int foo = 3; int bar = 4; foo * bar; // unused expression</code> </pre> <br>  atau bagaimana <br><br><pre> <code class="plaintext hljs">typedef struct { int b; } foo; foo* bar; bar.b = 3;</code> </pre> <br>  Implementasi Dentang juga menggunakan penganalisa keturunan rekursif: <br><br>  <i>Karena ini adalah kode C ++ reguler, turunan rekursif memudahkan pemula untuk memahaminya.</i>  <i>Ini mendukung aturan khusus dan hal-hal aneh lainnya yang dibutuhkan C / C ++ dan membantu Anda dengan mudah mendiagnosis dan memperbaiki kesalahan.</i> <br><br>  Penting juga memperhatikan pendekatan lain: <br><br><ul><li>  turun LL, keturunan rekursif </li><li>  ascending LR, shift, keturunan naik </li></ul><br><h2>  Generator Parser </h2><br>  Cara lain yang bagus.  Tentu saja, ada juga kelemahannya - tetapi ini bisa dikatakan tentang pilihan lain yang dibuat programmer saat membuat perangkat lunak. <br><br>  Generator Parser bekerja sangat cepat.  Menggunakannya lebih mudah daripada menulis analisis Anda sendiri dan mendapatkan hasil yang berkualitas - meskipun mereka tidak sangat ramah pengguna dan tidak selalu menampilkan pesan kesalahan.  Selain itu, Anda harus belajar cara menggunakan generator parser, dan saat mempromosikan kompiler, Anda mungkin harus melepas generator parser. <br><br>  Contoh generator parser adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ANTLR</a> , ada banyak lainnya. <br><br>  Saya pikir alat ini cocok untuk mereka yang tidak ingin menghabiskan waktu menulis sebuah frontend, dan yang lebih suka menulis tengah dan backend dari kompiler / juru bahasa dan menganalisis apa pun. <br><br><h2>  Aplikasi parsing </h2><br>  Jika Anda masih tidak mengerti diri sendiri.  Bahkan frontend kompiler (lex / parse) dapat digunakan untuk memecahkan masalah lain: <br><br><ul><li>  penyorotan sintaksis </li><li>  Penguraian HTML / CSS untuk mesin rendering </li><li>  transpiler: TypeScript, CoffeeScript </li><li>  penghubung </li><li>  REGEX </li><li>  analisis data antarmuka </li><li>  Penguraian URL </li><li>  alat pemformatan seperti <i>gofmt</i> </li><li>  SQL parsing dan lainnya. </li></ul><br><h2>  Pertengahan </h2><br>  Analisis semantik!  Analisis semantik bahasa adalah salah satu tugas yang paling sulit saat membuat kompiler. <br><br>  Anda perlu memastikan bahwa semua program input bekerja dengan benar.  Dalam bahasa Krug saya, aspek yang terkait dengan analisis semantik belum dimasukkan, dan tanpanya, programmer akan selalu diminta untuk menulis kode yang benar.  Pada kenyataannya, ini tidak mungkin - dan kami selalu menulis, mengkompilasi, terkadang menjalankan, memperbaiki kesalahan.  Spiral ini tidak ada habisnya. <br><br>  Selain itu, kompilasi program tidak mungkin tanpa analisis kebenaran semantik pada tahap kompilasi yang sesuai. <br><br>  Saya pernah menemukan grafik tentang persentase front-end, midland dan backend.  Kemudian tampak seperti <br><br><pre> <code class="plaintext hljs">F: 20% M: 20%: B: 60%</code> </pre> <br>  Hari ini seperti itu <br><br><pre> <code class="plaintext hljs">F: 5% M: 60% B: 35%</code> </pre> <br>  Frontend terutama berkaitan dengan generator, dan dalam bahasa tanpa konteks yang tidak memiliki dualitas tata bahasa, mereka dapat diselesaikan dengan cukup cepat - keturunan rekursif akan membantu di sini. <br><br>  Dengan teknologi LLVM, sebagian besar pekerjaan pengoptimalan dapat diunggah ke kerangka kerja, yang menghadirkan sejumlah optimasi yang sudah jadi. <br><br>  Langkah selanjutnya adalah analisis semantik, bagian penting dari fase kompilasi. <br><br>  Misalnya, di Rust, dengan model manajemen memorinya, kompiler bertindak sebagai mesin besar dan kuat yang melakukan berbagai jenis analisis statis pada formulir pengantar.  Bagian dari tugas ini adalah mengubah input data menjadi bentuk yang lebih nyaman untuk analisis. <br><br>  Untuk alasan ini, analisis semantik memainkan peran penting dalam arsitektur kompiler, dan pekerjaan persiapan yang melelahkan seperti mengoptimalkan perakitan yang dihasilkan atau membaca data input di ASD dilakukan untuk Anda. <br><br><h2>  Bagian Semantik </h2><br>  Dalam proses analisis semantik, kebanyakan kompiler melakukan sejumlah besar "lintasan semantik" pada SDA atau bentuk abstrak ekspresi kode lainnya.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel ini</a> memberikan detail tentang sebagian besar lintasan yang dibuat dalam kompiler .NET C #. <br><br>  Saya tidak akan mempertimbangkan setiap bagian, terutama karena mereka bervariasi tergantung pada bahasa, tetapi beberapa langkah dijelaskan di bawah ini di Krug. <br><br><h2>  Iklan Tingkat Atas </h2><br>  Kompiler akan melalui semua pengumuman "tingkat atas" dalam modul dan mengetahui keberadaannya.  Dia tidak akan masuk lebih dalam ke blok - dia hanya akan menyatakan struktur, fungsi, dll.  tersedia dalam satu atau modul lain. <br><br><h2>  Resolusi Nama / Simbol </h2><br>  Kompiler melewati semua blok kode dalam fungsi, dll.  dan menyelesaikannya - yaitu, menemukan karakter yang memerlukan izin.  Ini adalah pass umum, dan dari sinilah kesalahan <i>No simbol XYZ seperti itu</i> biasanya datang ketika mengkompilasi kode Go. <br><br>  Melakukan pass ini bisa sangat sulit, terutama jika ada dependensi melingkar dalam diagram dependensi Anda.  Beberapa bahasa tidak mengizinkannya, misalnya, Go akan membuat kesalahan jika salah satu paket Anda membentuk sebuah loop, seperti bahasa Krug saya.  Ketergantungan siklik dapat dianggap sebagai efek samping dari arsitektur yang buruk. <br><br>  Loop dapat ditentukan dengan memodifikasi DFS dalam diagram dependensi, atau dengan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">algoritma Tarjan</a> (seperti yang dilakukan oleh Krug) untuk mendefinisikan (banyak) loop. <br><br><h2>  Ketikkan Inference </h2><br>  Compiler memeriksa semua variabel dan menampilkan tipenya.  Jenis inferensi di Krug sangat lemah, itu hanya menghasilkan variabel berdasarkan nilai-nilai mereka.  Ini sama sekali bukan sistem yang aneh, seperti yang dapat Anda temukan dalam bahasa fungsional seperti Haskell. <br><br>  Jenis dapat diturunkan menggunakan proses "penyatuan", atau "penyatuan jenis".  Untuk sistem tipe yang lebih sederhana, implementasi yang sangat sederhana dapat digunakan. <br><br>  Jenis diterapkan di Krug seperti ini: <br><br><pre> <code class="plaintext hljs">interface Type {}; struct IntegerType : Type { int width; bool signed; }; struct FloatingType : Type { int width; }; struct ArrayType : Type { Type base_type; uint64 length; };</code> </pre> <br>  Anda juga dapat memiliki inferensi tipe sederhana, di mana Anda menetapkan tipe ke node ekspresi, misalnya, <code>IntegerConstantNode</code> bisa dari tipe IntegerType (64).  Dan kemudian Anda bisa mendapatkan fungsi <code>unify(t1, t2)</code> , yang akan memilih tipe terluas yang dapat digunakan untuk menyimpulkan tipe ekspresi yang lebih kompleks, katakanlah, yang biner.  Jadi itu masalah menugaskan variabel di sebelah kiri ke nilai dari jenis yang diberikan di sebelah kanan. <br><br>  Saya pernah menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jenis cor</a> sederhana di Go, yang menjadi implementasi prototipe untuk Krug. <br><br><h2>  Pass Mutability </h2><br>  Krug (seperti Rust) secara default adalah bahasa yang tidak dapat diubah, yaitu, variabel tetap tidak berubah kecuali ditentukan lain: <br><br><pre> <code class="plaintext hljs">let x = 3; x = 4; // BAD! mut y = 5; y = 6; // OK!</code> </pre> <br>  Compiler memeriksa semua blok dan fungsi dan memeriksa bahwa “variabel-variabelnya benar”, yaitu, kita tidak mengubah apa yang tidak diikuti, dan bahwa semua variabel yang dikirimkan ke fungsi tertentu konstan atau dapat diubah jika diperlukan. <br><br>  Ini dilakukan dengan bantuan informasi simbolik yang telah dikumpulkan melalui lintasan sebelumnya.  Tabel simbol berdasarkan hasil dari semantic pass berisi nama token dan tanda-tanda variabilitas variabel.  Mungkin berisi data lain, misalnya, dalam C ++ tabel dapat menyimpan informasi tentang apakah simbol itu eksternal atau statis. <br><br><h2>  Tabel karakter </h2><br>  Tabel karakter, atau "tusukan," adalah tabel untuk menemukan karakter yang digunakan dalam program Anda.  Satu tabel dibuat untuk setiap cakupan, dan semuanya berisi informasi tentang karakter yang ada dalam lingkup tertentu. <br><br>  Informasi ini mencakup properti seperti nama simbol, jenis, tanda mutabilitas, keberadaan komunikasi eksternal, lokasi dalam memori statis, dan sebagainya. <br><br><h3>  Lingkup </h3><br>  Ini adalah konsep penting dalam bahasa pemrograman.  Tentu saja, bahasa Anda tidak harus memungkinkan untuk membuat cakupan bersarang, semuanya dapat ditempatkan dalam satu namespace umum! <br><br>  Meskipun mewakili ruang lingkup adalah tugas yang menarik untuk arsitektur kompiler, dalam sebagian besar bahasa mirip C, ruang lingkup berperilaku (atau) seperti struktur data tumpukan. <br><br>  Biasanya kita membuat dan menghancurkan cakupan, dan mereka biasanya digunakan untuk mengelola nama, yaitu, mereka memungkinkan kita untuk menyembunyikan (membayangi) variabel: <br><br><pre> <code class="plaintext hljs">{ // push scope let x = 3; { // push scope let x = 4; // OK! } // pop scope } // pop scope</code> </pre> <br>  Itu dapat direpresentasikan secara berbeda: <br><br><pre> <code class="plaintext hljs">struct Scope { Scope* outer; SymbolTable symbols; }</code> </pre> <br>  Offtopic kecil, tapi saya sarankan membaca tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tumpukan spageti</a> .  Ini adalah struktur data yang digunakan untuk menyimpan area visibilitas di ASD node dari blok yang berlawanan. <br><br><h2>  Jenis sistem </h2><br>  Banyak bagian berikut ini dapat dikembangkan menjadi artikel yang terpisah, tetapi bagi saya tampaknya judul ini paling pantas.  Saat ini banyak informasi tersedia tentang sistem jenis, serta varietas sistem itu sendiri, di mana banyak salinan rusak.  Saya tidak akan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mempelajari secara</a> mendalam topik ini, tinggalkan saja tautan ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel yang bagus oleh Steve Klabnik</a> . <br><br>  Jenis sistem adalah apa yang disediakan dan ditentukan secara semantik dalam kompiler menggunakan representasi kompiler dan analisis representasi ini. <br><br><h2>  Kepemilikan </h2><br>  Konsep ini semakin banyak digunakan dalam pemrograman.  Prinsip-prinsip semantik kepemilikan dan gerakan tertanam dalam bahasa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rust</a> , dan saya berharap mereka akan muncul dalam bahasa lain.  Rust melakukan berbagai jenis analisis statis, yang memeriksa untuk melihat apakah input memenuhi seperangkat aturan mengenai memori: siapa yang memiliki memori mana, ketika memori dihancurkan, dan berapa banyak referensi (atau pinjaman) yang ada pada nilai atau memori ini. <br><br>  Keindahan Rust terletak pada kenyataan bahwa semua ini dilakukan selama kompilasi, di dalam kompiler, sehingga programmer tidak harus berurusan dengan pengumpulan sampah atau penghitungan tautan.  Semua semantik ini ditugaskan untuk sistem tipe dan dapat disediakan bahkan sebelum program disajikan dalam bentuk file biner yang lengkap. <br><br>  Saya tidak bisa mengatakan bagaimana semuanya bekerja di bawah tenda, tetapi semua ini adalah hasil analisis statis dan penelitian hebat oleh tim Mozilla dan peserta proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cyclone</a> . <br><br><h2>  Grafik Aliran Kontrol </h2><br>  Untuk mewakili aliran program, kami menggunakan grafik aliran kontrol (CFG), yang berisi semua jalur yang dapat diikuti oleh eksekusi program.  Ini digunakan dalam analisis semantik untuk mengecualikan bagian kode yang menganggur, yaitu, blok, fungsi, dan bahkan modul yang tidak akan pernah tercapai selama eksekusi program.  Grafik juga dapat digunakan untuk mengidentifikasi siklus yang tidak dapat diinterupsi.  Atau untuk mencari kode yang tidak dapat diakses, misalnya, ketika Anda memanggil "panik" (memanggil panik), atau kembali dalam satu lingkaran, dan kode di luar lingkaran tidak dijalankan.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Analisis aliran data</a> memainkan peran penting selama fase semantik kompiler, jadi saya sarankan membaca tentang jenis analisis yang dapat Anda lakukan, bagaimana mereka bekerja dan optimasi apa yang dapat dilakukan. <br><br><h2>  Backend </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/330/914/1b9/3309141b9d53be1d9e5c8f77fb46d982.jpg"><br>  <i>Bagian terakhir dari skema arsitektur kami.</i> <br><br>  Kami telah melakukan sebagian besar pekerjaan menghasilkan binari yang dapat dieksekusi.  Ini bisa dilakukan dengan berbagai cara, yang akan kita bahas di bawah ini. <br><br>        - ,   . ,     ,    «». <br><br><h2>     </h2><br>   ,           . ,    ,      .   ,   ,         ,    .        ,      . <br><br>   ,           .  ,   ++ — Cfront —     C. <br><br>    JavaScript.     TypeScript    ,     ,   ,              ,         . <br><br>    «» ,     ,             ,       ,    «  »  .        —   ,        ,     . <br><br><h2> LLVM </h2><br>          LLVM: Rust, Swift, C/C++ (clang), D, Haskell. <br><br>    « »,             ,      .     , LLVM      .   ,       .  ,   ,     , , 1, 4, 8  16-.       ,  ,   -    . <br><br><h2>  - </h2><br>      —     , —     ,      . <br><br> Go —    ,      LLVM (    ). Go     ,    Windows, Linux  MacOS. ,    Krug    -. <br><br>        .  ,     LLVM,     ,   ,        LLVM      ,     . <br><br>   ,        ,       ,        LLVM,      IR,    ,  , ,    (    ). <br><br>     .      ,         ,   ,       .       IR (    )  «»       fprintf   .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">8cc</a> . <br><br><h2>   </h2><br>             .   — Java:  , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JVM</a>        , , Kotlin. <br><br>     ,   Java   .         ,           .            ,       . <br>   , JVM   JIT       ,     JIT-,     . <br><br><h2>  </h2><br>     ,      !      ,     ,   .   -          ,   ,   . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Godbolt</a> —  ,  ,             .       , ,     . <br><br>      ,         ,       (strip the debug symbols),  ,   GCC.     ,  -  . <br><br>            .       .    ,         .        production-. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>        rwmj ,    8  ,   80%     .        1971-!    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>  ,  Rust. <br><br><h2> IR </h2><br>   (intermediate representation, IR)  ,  .      ,        ,     . <br><br>   IR     .      ,  ,    ,    . <br><br>    IR,  «»,       IR   . , SSA — Static Single Assignment,   ,        . <br><br>  Go     IR   SSA. IR  LLVM   SSA,    . <br><br>  SSA   ,  ,   (constant propagation),     ( )  . <br><br><h2>   </h2><br>      ,  .  ,    ,   ,      ,    .         (  16  32),     ,      (spill to the stack). <br><br>   —             (   ).     ,     ,          . <br><br>     : <br><br><ul><li>   (graph colouring) —   (NP- ).      ,     (liveness ranges) . <br></li><li>   —       . <br></li></ul><br><h2>     </h2><br>     . ,       .   ,       ,         . <br><br><h2>   ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Name Mangling</a> ) </h2><br>    -,            ,        .         ,   . <br><br><pre> <code class="plaintext hljs">fn main() int { let x = 0; { let x = 0; { let x = 0; } } return 0; }</code> </pre> <br> ,    (  -    :) )      ,      .        ,        . <br><br><h2>   </h2><br>   LLDB     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DWARF</a> .     LLVM   ,   DWARF         GNU-. ,     ,     ,   . <br><br><h2>    (Foreign Function Interface, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FFI</a> ) </h2><br>   libc   ,        ,      .       ,        ? <br><br><h2>  </h2><br>   —  .     ,      (  .s/.asm)?       ? ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jai</a>        .   ,     . <br><br><h2>    (CaaS) </h2><br>         API-.  ,       Krug-,         .  ,     ,      . <br><br> ,     , ,      .         ,     API-. <br><br>   production-   CaaS.    Microsofts Roslyn,       ,     .    , , ,      ,     API-,     , ,  Rust  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RLS</a> . <br><br>    Krug —        —   Caasper  CaaS-. <br><br> Caasper      (,  ,  ),      , krug,    .   ,        ,      (bootstrap)   ,     . <br><br>   Krug   JavaScript,       Go*,  , ,   Krug. JavaScript     ,         yarn/npm. <br><br> <i>*      Go   ()  ,    JS.</i> <br><br>    Caasper  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> Github   Krug,    D    LLVM.       YouTube- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . <br><br>   Krug ()  <a href=""></a> . <br><br><h2>  Tautan yang bermanfaat </h2><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jack Crenshaw</a> —        . <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Crafting Interpreters</a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  LLVM ( Go)</a> — ! <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PL/0</a> <br></li><li> The Dragon Book —  ,    . <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">8cc</a> <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id451894/">https://habr.com/ru/post/id451894/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id451878/index.html">Streaming langsung video stereo ke kacamata VR (Oculus Go)</a></li>
<li><a href="../id451880/index.html">DevPRO'19: pemandangan dari bilik Wrike</a></li>
<li><a href="../id451884/index.html">Tujuh tahun bekerja sebagai pengembang: pelajaran apa yang telah saya pelajari</a></li>
<li><a href="../id451886/index.html">Menggunakan matematika diskrit dalam pengujian</a></li>
<li><a href="../id451890/index.html">Delegasi zona reverse subnet kurang dari / 24 di BIND. Bagaimana cara kerjanya</a></li>
<li><a href="../id451896/index.html">EyeDisk "yang tidak dapat dipecahkan" dilindungi oleh pemindaian iris, tetapi mengirimkan kata sandi dalam teks yang jelas</a></li>
<li><a href="../id451898/index.html">Inovasi dalam bahasa Rusia</a></li>
<li><a href="../id451900/index.html">Kontribusi pertama ke API browser dari Facebook</a></li>
<li><a href="../id451902/index.html">Kamp Pengembang Microsoft Azure Rusia</a></li>
<li><a href="../id451904/index.html">Terkadang lebih banyak lebih sedikit. Ketika penurunan beban menyebabkan peningkatan penundaan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>