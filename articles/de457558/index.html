<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÆ üê¶ üèÇüèΩ EvilParcel-Sicherheitsanf√§lligkeitsanalyse ‚ú°Ô∏è ‚öæÔ∏è üßòüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 
 Mitte April ver√∂ffentlichten wir Nachrichten √ºber den Trojaner Android.InfectionAds.1 , der mehrere kritische Sicherheitsl√ºcken im Androi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>EvilParcel-Sicherheitsanf√§lligkeitsanalyse</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/drweb/blog/457558/"><h3>  Einf√ºhrung </h3><br>  Mitte April ver√∂ffentlichten wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nachrichten</a> √ºber den Trojaner <b>Android.InfectionAds.1</b> , der mehrere kritische Sicherheitsl√ºcken im Android-Betriebssystem ausnutzte.  Einer von ihnen - CVE-2017-13156 (auch als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Janus bekannt</a> ) - erm√∂glicht es einem Schadprogramm, APK-Dateien zu infizieren, ohne ihre digitale Signatur zu besch√§digen. <br><br>  Der andere ist CVE-2017-13315.  Es gew√§hrt dem Trojaner erweiterte Berechtigungen und kann Anwendungen unabh√§ngig installieren und deinstallieren.  Eine detaillierte Analyse von <b>Android.InfectionAds.1 finden Sie</b> in unserer <b>Virenbibliothek.</b> Sie finden sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Wir werden uns eingehender mit der Sicherheitsanf√§lligkeit CVE-2017-13315 befassen und sehen, wie sie ist. <br><a name="habracut"></a><br>  CVE-2017-13315 geh√∂rt zu der Gruppe von Sicherheitsl√ºcken, die den allgemeinen Namen EvilParcel erhalten haben.  Sie befinden sich in verschiedenen Systemklassen des Android-Betriebssystems.  Aufgrund von Fehlern in letzterem beim Datenaustausch zwischen Anwendungen und dem System ist es m√∂glich, diese Daten zu ersetzen.  Sch√§dliche Programme, die EvilParcel-Schwachstellen ausnutzen, erhalten h√∂here Berechtigungen und k√∂nnen mit ihrer Hilfe Folgendes tun: <br><br><ul><li>  Installieren und Deinstallieren von Anwendungen mit Berechtigungen ohne Benutzerbest√§tigung; </li><li>  Infizieren Sie in Verbindung mit anderen Sicherheitsl√ºcken installierte Programme auf dem Ger√§t und ersetzen Sie ‚Äûsaubere‚Äú Originale durch infizierte Kopien. </li><li>  Setzen Sie den Bildschirmsperrcode f√ºr das Android-Ger√§t zur√ºck </li><li>  Setzen Sie die PIN des Android-Ger√§tesperrbildschirms zur√ºck. </li></ul><br>  Derzeit sind 7 Sicherheitsl√ºcken dieses Typs bekannt: <br><br><ul><li>  CVE-2017-0806 (Fehler in der GateKeeperResponse-Klasse), ver√∂ffentlicht im Oktober 2017; </li><li>  CVE-2017-13286 (Fehler in der Klasse OutputConfiguration, ver√∂ffentlicht im April 2018; </li><li>  CVE-2017-13287 (Fehler in der VerifyCredentialResponse-Klasse), ver√∂ffentlicht im April 2018; </li><li>  CVE-2017-13288 (Fehler in der PeriodicAdvertizingReport-Klasse), ver√∂ffentlicht im April 2018; </li><li>  CVE-2017-13289 (Fehler in der ParcelableRttResults-Klasse), ver√∂ffentlicht im April 2018; </li><li>  CVE-2017-13311 (Fehler in der SparseMappingTable-Klasse), ver√∂ffentlicht im Mai 2018; </li><li>  CVE-2017-13315 (Fehler in der DcParamObject-Klasse), ver√∂ffentlicht im Mai 2018. </li></ul><br>  Alle von ihnen bedrohen Ger√§te mit Android OS-Versionen 5.0 - 8.1, auf denen die Sicherheitsupdates vom Mai 2018 und h√∂her nicht installiert sind. <br><br><h3>  Voraussetzungen f√ºr EvilParcel-Sicherheitsl√ºcken </h3><br>  Mal sehen, wie EvilParcel-Schwachstellen entstehen.  Zun√§chst werden wir uns einige Funktionen von Android-Anwendungen ansehen.  Unter Android OS interagieren alle Programme miteinander und mit dem Betriebssystem selbst, indem sie Objekte vom Typ Intent senden und empfangen.  Diese Objekte k√∂nnen eine beliebige Anzahl von Schl√ºssel-Wert-Paaren in einem Objekt vom Typ Bundle enthalten. <br><br>  Beim √úbertragen von Intent wird das Bundle-Objekt in ein in Parcel eingeschlossenes Byte-Array konvertiert (serialisiert), und beim Lesen von Schl√ºsseln und Werten aus einem serialisierten Bundle wird es automatisch deserialisiert. <br><br>  Im Bundle ist die Zeichenfolge der Schl√ºssel, und der Wert kann fast alles sein.  Zum Beispiel ein primitiver Typ, eine Zeichenfolge oder ein Container, der primitive Typen oder Zeichenfolgen enth√§lt.  Dar√ºber hinaus kann es sich um ein Objekt vom Typ Parcelable handeln. <br><br>  Auf diese Weise k√∂nnen Sie im Bundle ein Objekt eines beliebigen Typs platzieren, der die Parcelable-Schnittstelle implementiert.  Dazu m√ºssen Sie die Methoden writeToParcel () und createFromParcel () zum Serialisieren und Deserialisieren des Objekts implementieren. <br><br>  Als gutes Beispiel erstellen wir ein einfaches serialisiertes Bundle.  Schreiben wir einen Code, der drei Schl√ºssel-Wert-Paare in das Bundle einf√ºgt und es serialisiert: <br><br>  Bundle-Demo = neues Bundle (); <br>  demo.putString ("String", "Hallo Welt!"); <br>  demo.putInt ("Integer", 42); <br>  demo.putByteArray ("ByteArray", neues Byte [] {1, 2, 3, 4, 5, 6, 7, 8}); <br>  Paket Paket = Paket.obtain (); <br>  parcel.writeBundle (Demo); <br><br>  Nach dem Ausf√ºhren dieses Codes erhalten wir ein Bundle des folgenden Formulars: <br><br><img src="https://habrastorage.org/webt/53/gn/x5/53gnx5bjhjfdaqjr5isxgva6fzg.png"><br><br>  <b>Abbildung 1.</b> Struktur eines serialisierten Bundle-Objekts. <br><br>  Beachten Sie die folgenden Funktionen der Bundle-Serialisierung: <br><br><ul><li>  Alle Schl√ºssel-Wert-Paare werden nacheinander geschrieben. </li><li>  vor jedem Wert wird sein Typ angegeben (13 f√ºr ein Byte-Array, 1 f√ºr eine Ganzzahl, 0 f√ºr eine Zeichenfolge usw.); </li><li>  vor Daten variabler L√§nge wird ihre Gr√∂√üe angegeben (L√§nge f√ºr die Zeichenfolge, Anzahl der Bytes f√ºr das Array); </li><li>  Alle Werte werden mit einer Ausrichtung von 4 Bytes geschrieben. </li></ul><br>  Aufgrund der Tatsache, dass alle Schl√ºssel und Werte im Bundle beim Zugriff auf einen Schl√ºssel oder den Wert eines serialisierten Bundle-Objekts nacheinander geschrieben werden, wird letzteres vollst√§ndig deserialisiert, einschlie√ülich der Initialisierung aller darin enthaltenen Parcelable-Objekte. <br><br>  Es scheint, was k√∂nnte das Problem sein?  In einigen Systemklassen, die Parcelable implementieren, k√∂nnen die Methoden createFromParcel () und writeToParcel () auf Fehler sto√üen.  In diesen Klassen unterscheidet sich die Anzahl der in der Methode createFromParcel () gelesenen Bytes von der Anzahl der in der Methode writeToParcel () geschriebenen Bytes.  Wenn Sie ein Objekt einer solchen Klasse im Bundle platzieren, √§ndern sich die Grenzen des Objekts im Bundle nach der erneuten Serialisierung.  Hier werden die Bedingungen f√ºr die Ausnutzung der EvilParcel-Sicherheitsanf√§lligkeit geschaffen. <br><br>  Hier ist ein Beispiel f√ºr eine Klasse mit einem √§hnlichen Fehler: <br><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parcelable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Demo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Demo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Parcel in)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = in.readInt(); data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[length]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { in.readByteArray(data); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Creator&lt;Demo&gt; CREATOR = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Creator&lt;Demo&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Demo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createFromParcel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Parcel in)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Demo(in); } }; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeToParcel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Parcel parcel, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ parcel.writeInt(data.length); parcel.writeByteArray(data); } }</code> </pre> <br>  Wenn die Gr√∂√üe des Datenarrays 0 ist, wird beim Erstellen eines Objekts in createFromParcel () ein int (4 Byte) gelesen und zwei int (8 Byte) in writeToParcel () geschrieben.  Das erste int wird in einem expliziten Aufruf von writeInt geschrieben.  Das zweite int wird geschrieben, wenn writeByteArray () aufgerufen wird, da die L√§nge des Arrays immer davor in Parcel geschrieben wird (siehe Abbildung 1). <br><br>  Situationen, in denen die Gr√∂√üe des Datenarrays 0 betr√§gt, sind selten.  Aber selbst wenn dies geschieht, funktioniert das Programm weiterhin, wenn jeweils nur ein Objekt in serialisierter Form √ºbertragen wird (in unserem Beispiel das Demo-Objekt).  Daher bleiben solche Fehler in der Regel unbemerkt. <br><br>  Versuchen wir nun, ein Demo-Objekt mit einer Array-L√§nge von Null im Bundle zu platzieren: <br><br><img src="https://habrastorage.org/webt/2y/2v/i0/2y2vi0ftdkartg9i01cc-b858g0.png"><br>  <b>Abbildung 2.</b> Das Ergebnis des Hinzuf√ºgens eines Demo-Objekts mit einer Array-L√§nge von Null zum Bundle. <br><br>  Wir serialisieren das Objekt: <br><br><img src="https://habrastorage.org/webt/hv/tw/if/hvtwifj9curkc7ip6jplbdlk-yc.png"><br>  <b>Abbildung 3.</b> Objekt nach der Serialisierung b√ºndeln. <br><br>  Versuchen wir es zu deserialisieren: <br><br><img src="https://habrastorage.org/webt/_u/a1/k4/_ua1k4hp34wknsvnppv8zla0jei.png"><br>  <b>Abbildung 4.</b> Nach dem Deserialisieren des Bundle-Objekts. <br><br>  Was ist das Ergebnis?  Betrachten Sie einen Paketausschnitt: <br><br><img src="https://habrastorage.org/webt/g0/qs/y4/g0qsy4cigykwv2gxgpizo2qsu7u.png"><br>  <b>Abbildung 5.</b> Paketstruktur nach Deserialisierung des B√ºndels. <br><br>  Aus den Abbildungen 4 und 5 geht hervor, dass w√§hrend der Deserialisierung ein int in der Methode createFromParcel anstelle von zwei zuvor geschriebenen gelesen wurde.  Daher wurden alle nachfolgenden Werte aus dem Bundle nicht korrekt gelesen.  Der Wert 0x0 an der Adresse 0x60 wurde als L√§nge des n√§chsten Schl√ºssels gelesen.  Und der Wert 0x1 an der Adresse 0x64 wurde als Schl√ºssel gelesen.  In diesem Fall wurde der Wert 0x31 an der Adresse 0x68 als Werttyp gelesen.  In Parcel gibt es keine Werte, deren Typ 0x31 ist. ReadFromParcel () hat daher einen Fehler (Ausnahme) getreu gemeldet. <br><br>  Wie kann dies in der Praxis genutzt werden und zu einer Sicherheitsl√ºcke werden?  Mal sehen!  Mit dem oben in den Parcelable-Systemklassen beschriebenen Fehler k√∂nnen Sie ein Bundle erstellen, das sich w√§hrend der ersten und wiederholten Deserialisierung unterscheiden kann.  √Ñndern Sie das vorherige Beispiel, um dies zu demonstrieren: <br><br><pre> <code class="java hljs">Parcel data = Parcel.obtain(); data.writeInt(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 3 entries data.writeString("vuln_class"); data.writeInt(4); // value is Parcelable data.writeString("com.drweb.testbundlemismatch.Demo"); data.writeInt(0); // data.length data.writeInt(1); // key length -&gt; key value data.writeInt(6); // key value -&gt; value is long data.writeInt(0xD); // value is bytearray -&gt; low(long) data.writeInt(-1); // bytearray length dummy -&gt; high(long) int startPos = data.dataPosition(); data.writeString("hidden"); // bytearray data -&gt; hidden key data.writeInt(0); // value is string data.writeString("Hi there"); // hidden value int endPos = data.dataPosition(); int triggerLen = endPos - startPos; data.setDataPosition(startPos - 4); data.writeInt(triggerLen); // overwrite dummy value with the real value data.setDataPosition(endPos); data.writeString("A padding"); data.writeInt(0); // value is string data.writeString("to match pair count"); int length = data.dataSize(); Parcel bndl = Parcel.obtain(); bndl.writeInt(length); bndl.writeInt(0x4C444E42); // bundle magic bndl.appendFrom(data, 0, length); bndl.setDataPosition(0);</span></span></code> </pre> <br>  Dieser Code erstellt ein serialisiertes Bundle, das eine anf√§llige Klasse enth√§lt.  Schauen wir uns das Ergebnis der Ausf√ºhrung dieses Codes an: <br><br><img src="https://habrastorage.org/webt/tc/ke/wf/tckewffnaop28wllxnrt7pagdvs.png"><br>  <b>Abbildung 6.</b> Erstellen eines Bundles mit einer anf√§lligen Klasse <br><br>  Nach der ersten Deserialisierung enth√§lt dieses Bundle die folgenden Schl√ºssel: <br><br><img src="https://habrastorage.org/webt/cj/si/l0/cjsil0--g_jsoew8ht-oxely1u4.png"><br>  <b>Abbildung 7.</b> Ergebnis der Deserialisierung eines Bundles mit einer anf√§lligen Klasse. <br><br>  Serialisieren Sie nun das resultierende Bundle erneut, deserialisieren Sie es erneut und sehen Sie sich die Liste der Schl√ºssel an: <br><br><img src="https://habrastorage.org/webt/uw/e1/mj/uwe1mjdtywr59oyshaah2q1gkus.png"><br>  <b>Abbildung 8.</b> Ergebnis der Re-Serialisierung und Deserialisierung eines Bundles mit einer anf√§lligen Klasse. <br><br>  Was sehen wir?  Der versteckte Schl√ºssel (mit dem Zeichenfolgenwert "Hi there!") Wurde im Bundle angezeigt, das vorher nicht vorhanden war.  Betrachten Sie den Paketausschnitt dieses Bundles, um zu verstehen, warum dies passiert ist: <br><br><img src="https://habrastorage.org/webt/cx/za/dz/cxzadza4tugyeemlefk1lmlkdbu.png"><br>  <b>Abbildung 9.</b> Paketstruktur des Bundle-Objekts mit der anf√§lligen Klasse nach zwei Serialisierungs-Deserialisierungs-Zyklen. <br><br>  Hier wird das Wesen der EvilParcel-Schwachstellen klarer.  Es ist m√∂glich, ein speziell geformtes Bundle zu erstellen, das eine anf√§llige Klasse enth√§lt.  Durch √Ñndern der Grenzen dieser Klasse k√∂nnen Sie jedes Objekt in diesem Bundle platzieren, z. B. Intent, das erst nach der zweiten Deserialisierung im Bundle angezeigt wird.  Dadurch k√∂nnen Sie Intent vor den Schutzmechanismen des Betriebssystems verbergen. <br><br><h3>  Operation EvilParcel </h3><br>  Android.InfectionAds.1 mit CVE-2017-13315 installierte und deinstallierte Programme selbstst√§ndig, ohne dass der Besitzer des infizierten Ger√§ts eingreifen musste.  Aber wie geht das? <br><br>  Im Jahr 2013 wurde auch der Fehler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">7699048</a> entdeckt, der auch als Launch AnyWhere bezeichnet wird.  Es erm√∂glichte einer Drittanbieteranwendung, beliebige Aktivit√§ten im Namen des privilegierteren Benutzersystems auszuf√ºhren.  Das folgende Diagramm zeigt den Wirkmechanismus: <br><br><img src="https://habrastorage.org/webt/dg/no/n9/dgnon92txtobknvvgr5eo2cmi54.png"><br>  <b>Abbildung 10.</b> Fehlerschema 7699048. <br><br>  Mit dieser Sicherheitsanf√§lligkeit kann eine Exploit-Anwendung den AccountAuthenticator-Dienst implementieren, mit dem dem Betriebssystem neue Konten hinzugef√ºgt werden sollen.  Dank des Fehlers 7699048 kann der Exploit Aktivit√§ten ausf√ºhren, um Anwendungen zu installieren, zu deinstallieren, zu ersetzen, die PIN oder die Mustersperre zur√ºckzusetzen und andere unangenehme Dinge zu tun. <br><br>  Google hat diese L√ºcke geschlossen, indem es den Start beliebiger Aktivit√§ten √ºber den AccountManager untersagte.  Jetzt erm√∂glicht der AccountManager nur das Starten von Aktivit√§ten, die von derselben Anwendung stammen.  Zu diesem Zweck wird die digitale Signatur des Programms, das den Start der Aktivit√§t initiiert hat, √ºberpr√ºft und mit der Signatur der Anwendung verglichen, in der sich die gestartete Aktivit√§t befindet.  Es sieht so aus: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; (intent = result.getParcelable(AccountManager.KEY_INTENT)) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* * The Authenticator API allows third party authenticators to * supply arbitrary intents to other apps that they can run, * this can be very bad when those apps are in the system like * the System Settings. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> authenticatorUid = Binder.getCallingUid(); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> bid = Binder.clearCallingIdentity(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { PackageManager pm = mContext.getPackageManager(); ResolveInfo resolveInfo = pm.resolveActivityAsUser(intent, <span class="hljs-number"><span class="hljs-number">0</span></span>, mAccounts.userId); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> targetUid = resolveInfo.activityInfo.applicationInfo.uid; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PackageManager.SIGNATURE_MATCH != pm.checkSignatures(authenticatorUid, targetUid)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecurityException( <span class="hljs-string"><span class="hljs-string">"Activity to be started with KEY_INTENT must "</span></span> + <span class="hljs-string"><span class="hljs-string">"share Authenticator's signatures"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { Binder.restoreCallingIdentity(bid); } }</code> </pre><br>  Es scheint, dass das Problem gel√∂st wurde, aber nicht alles hier ist so glatt.  Es stellte sich heraus, dass dieses Update mithilfe der bekannten Sicherheitsanf√§lligkeit EvilParcel CVE-2017-13315 umgangen werden kann!  Wie wir bereits wissen, √ºberpr√ºft das System nach dem Fixieren von Launch AnyWhere die digitale Signatur der Anwendung.  Wenn diese Pr√ºfung erfolgreich ist, wird das Bundle an IAccountManagerResponse.onResult () √ºbergeben.  Gleichzeitig wird onResult () √ºber den IPC-Mechanismus aufgerufen, sodass das Bundle erneut serialisiert wird.  In der Implementierung von onResult () geschieht Folgendes: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** Handles the responses from the AccountManager */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Response</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IAccountManagerResponse</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stub</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle bundle)</span></span></span><span class="hljs-function"> </span></span>{ Intent intent = bundle.getParcelable(KEY_INTENT); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (intent != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; mActivity != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// since the user provided an Activity we will silently start intents // that we see mActivity.startActivity(intent); // leave the Future running to wait for the real response to this request } //&lt;.....&gt; } //&lt;.....&gt; }</span></span></code> </pre><br>  Als n√§chstes extrahiert das Bundle den Intent-Schl√ºssel und die Aktivit√§t wird ohne Pr√ºfung gestartet.  Um eine beliebige Aktivit√§t mit Systemrechten zu starten, reicht es daher aus, das Bundle so zu erstellen, dass das Absichtsfeld bei der ersten Deserialisierung ausgeblendet wird und bei der zweiten Deserialisierung angezeigt wird.  Und wie wir bereits gesehen haben, erf√ºllen EvilParcel-Schwachstellen genau diese Aufgabe. <br><br>  Derzeit werden alle bekannten Schwachstellen dieses Typs durch Korrekturen in den anf√§lligen Parcelable-Klassen selbst behoben.  Das Wiederauftreten gef√§hrdeter Klassen in der Zukunft kann jedoch nicht ausgeschlossen werden.  Die Implementierung des Bundles und der Mechanismus zum Hinzuf√ºgen neuer Konten sind weiterhin dieselben wie zuvor.  Mit ihnen k√∂nnen Sie immer noch genau denselben Exploit erstellen, wenn Sie anf√§llige Parcelable-Klassen entdecken (oder neue).  Dar√ºber hinaus erfolgt die Implementierung dieser Klassen immer noch manuell, und der Programmierer muss die konstante L√§nge des serialisierten Parcelable-Objekts im Auge behalten.  Und das ist ein menschlicher Faktor mit allen Konsequenzen.  Wir hoffen jedoch, dass solche Fehler so gering wie m√∂glich sind und die Schwachstellen von EvilParcel die Benutzer von Android-Ger√§ten nicht st√∂ren. <br><br>  Sie k√∂nnen Ihr Mobilger√§t mithilfe unseres <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dr.Web Security Space-</a> Antivirus auf EvilParcel-Schwachstellen √ºberpr√ºfen.  Der integrierte ‚ÄûSicherheitspr√ºfer‚Äú berichtet √ºber die erkannten Probleme und gibt Empfehlungen zu deren L√∂sung. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457558/">https://habr.com/ru/post/de457558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de457542/index.html">Das Hacken und Sch√ºtzen von Verschl√ºsselungslaufwerken LUKS</a></li>
<li><a href="../de457546/index.html">Demo-Tag: Warum ist das alles und wie geht das? UPD + Broadcast</a></li>
<li><a href="../de457548/index.html">Mehrphasige PWM-Signalerzeugung auf TMS320F28027</a></li>
<li><a href="../de457550/index.html">Wovor die digitale Industrie gesch√ºtzt werden muss</a></li>
<li><a href="../de457552/index.html">Kletterer in Zafasadia. Wie die Promalps auf dem Lakhta Center Tower funktionieren</a></li>
<li><a href="../de457560/index.html">Tokenized Shares: So werden Sie vor dem B√∂rsengang ein Gett-Investor</a></li>
<li><a href="../de457562/index.html">Ivideon Counter 3D: Wen, wie und warum werden Besucher gez√§hlt?</a></li>
<li><a href="../de457564/index.html">Sch√§tzung der Kosten der IT-Systeme eines Unternehmens</a></li>
<li><a href="../de457566/index.html">Druck ist in Ordnung: Warum ben√∂tigt das Rechenzentrum eine Luftdruckregelung?</a></li>
<li><a href="../de457568/index.html">Futurologischer Kongress: Eine Auswahl von Berichten √ºber die Evangelisten der Zukunft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>