<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>âš«ï¸ âœ… ğŸµ Apa yang salah dengan artikel populer yang mengatakan bahwa foo lebih cepat daripada bar? ğŸ“ âœ… ğŸ«</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Catatan Penerjemah: Saya juga berpikir bahwa waktu untuk artikel adalah "Apa yang lebih cepat - kutipan ganda atau tunggal?" Butuh 10 tahun yang lalu....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apa yang salah dengan artikel populer yang mengatakan bahwa foo lebih cepat daripada bar?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419743/"><p>  <em><strong>Catatan Penerjemah:</strong> Saya juga berpikir bahwa waktu untuk artikel adalah "Apa yang lebih cepat - kutipan ganda atau tunggal?"</em>  <em>Butuh 10 tahun yang lalu.</em>  <em>Tapi di sini artikel serupa ("Trik kinerja apa yang sebenarnya berhasil") baru-baru ini mengumpulkan peringkat yang relatif tinggi pada Reddit dan bahkan masuk ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">intisari PHP</a> di HabrÃ©.</em>  <em>Oleh karena itu, saya memutuskan untuk menerjemahkan artikel itu dengan analisis kritis tentang ini dan "tes" serupa.</em> </p><br><p>  Ada banyak artikel (dan bahkan seluruh situs) yang ditujukan untuk meluncurkan berbagai tes membandingkan kinerja berbagai konstruksi sintaksis dan menyatakan berdasarkan ini bahwa yang satu lebih cepat daripada yang lain. </p><br><h3 id="glavnaya-problema">  Masalah utama </h3><br><p>  Tes semacam itu salah karena berbagai alasan, mulai dari mengajukan pertanyaan hingga kesalahan implementasi.  Tetapi yang paling penting - tes semacam itu tidak ada artinya <em>dan pada saat yang sama</em> berbahaya. </p><br><ul><li>  Mereka tidak ada artinya karena mereka tidak memiliki nilai praktis.  Tidak ada proyek nyata yang pernah dipercepat menggunakan metode yang disediakan dalam artikel tersebut.  Hanya karena bukan perbedaan dalam hal sintaksis untuk kinerja, tetapi <strong>pengolahan data.</strong> </li><li>  Mereka berbahaya karena menyebabkan munculnya takhayul yang paling liar dan - bahkan lebih buruk - mendorong pembaca yang tidak menaruh curiga untuk menulis kode yang buruk, berpikir bahwa mereka "mengoptimalkan" itu. </li></ul><br><p>  Itu sudah cukup untuk menutup pertanyaan.  Tetapi bahkan jika Anda menerima aturan permainan dan berpura-pura bahwa "tes" ini setidaknya memiliki beberapa perasaan, ternyata hasilnya berkurang hanya untuk menunjukkan kurangnya pengetahuan penguji dan kurangnya pengalaman apa pun. <a name="habracut"></a></p><br><h3 id="odinarnye-protiv-dvoynyh">  Tunggal versus ganda </h3><br><p>  Ambil kutipan terkenal, "tunggal versus ganda".  Tentu saja, tidak ada kutipan yang lebih cepat.  Pertama, ada yang namanya <em>cache opcode</em> , yang menyimpan hasil parsing skrip PHP dalam cache.  Dalam hal ini, kode PHP disimpan dalam format opcode, di mana literal string yang sama disimpan sebagai entitas yang benar-benar identik, terlepas dari kutipan mana yang digunakan dalam skrip PHP.  Yang berarti bahkan tidak ada perbedaan teoretis dalam kinerja. </p><br><p>  Tetapi bahkan jika kita tidak menggunakan opcode cache (walaupun kita seharusnya, jika tugas kita adalah benar-benar meningkatkan kinerja), kita akan menemukan bahwa perbedaan dalam kode parsing sangat kecil (beberapa transisi kondisional yang membandingkan karakter byte tunggal, beberapa instruksi prosesor) yang akan benar-benar tidak terdeteksi.  Ini berarti bahwa setiap hasil yang diperoleh hanya akan menunjukkan masalah di lingkungan pengujian.  Ada artikel yang sangat rinci, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Membantah Mitos Kinerja Kutipan Tunggal</a> dari pengembang inti PHP Nikita Popov, yang mengurai masalah ini secara rinci.  Namun demikian, seorang penguji yang energetik muncul hampir setiap bulan untuk mengungkapkan kepada masyarakat suatu "perbedaan" imajiner dalam kinerja. </p><br><h3 id="logicheskie-nestykovki">  Inkonsistensi logis </h3><br><p>  Beberapa tes pada umumnya tidak berarti, hanya dari sudut pandang mengajukan pertanyaan: Misalnya, tes berjudul "Apakah melempar benar-benar operasi yang sangat mahal?"  ini pada dasarnya pertanyaan "Apakah benar memproses kesalahan akan lebih mahal daripada tidak memproses?".  Apakah kamu serius?  Tentu saja, menambahkan beberapa fungsionalitas dasar ke kode akan membuatnya "lebih lambat".  Tetapi ini tidak berarti bahwa fungsionalitas baru tidak perlu ditambahkan sama sekali, dengan dalih yang konyol.  Jika Anda berbicara seperti itu, maka program tercepat adalah yang tidak melakukan apa-apa!  Program harus bermanfaat dan bekerja tanpa kesalahan sejak awal.  Dan hanya setelah ini tercapai, dan hanya jika itu bekerja lambat, itu perlu dioptimalkan.  Tetapi jika pertanyaan itu sendiri tidak masuk akal, lalu mengapa repot-repot menguji kinerja?  Lucu sekali bahwa penguji tidak dapat menerapkan dengan benar bahkan pengujian yang tidak masuk akal ini, yang akan ditampilkan di bagian selanjutnya. </p><br><p> Atau contoh lain, tes berjudul "Apakah <code>$row[id]</code> benar-benar lebih lambat dari <code>$row['id']</code> ?"  ini pada dasarnya pertanyaan "Kode mana yang lebih cepat - kode yang berfungsi dengan kesalahan, atau tanpa?"  (karena menulis <code>id</code> tanpa tanda kutip dalam hal ini adalah kesalahan tingkat <code>E_NOTICE</code> , dan penulisan seperti itu akan ditinggalkan dalam versi PHP yang akan datang).  WTF?  Apa gunanya mengukur kinerja kode kesalahan secara umum?  Kesalahan harus diperbaiki hanya karena itu adalah kesalahan, dan bukan karena itu akan membuat kode berjalan lebih lambat.  Lucu sekali bahwa penguji tidak dapat menerapkan dengan benar bahkan pengujian yang tidak masuk akal ini, yang akan diperlihatkan di bagian selanjutnya. </p><br><h3 id="kachestvo-testov">  Kualitas tes </h3><br><p>  Dan lagi - bahkan tes yang tidak berguna tanpa sadar harus konsisten, konsisten - yaitu, mengukur nilai yang sebanding.  Tetapi, sebagai aturan, tes tersebut dilakukan dengan tumit kiri, dan sebagai hasilnya, hasil yang diperoleh tidak berarti dan tidak relevan dengan tugas tersebut. </p><br><p>  Sebagai contoh, penguji bodoh kami melakukan pengukuran "penggunaan operator <code>try..catch</code> berlebihan".  Tetapi dalam tes saat ini, ia mengukur tidak hanya <code>try catch</code> , tetapi juga <code>throw</code> , melemparkan pengecualian pada setiap iterasi dari loop.  Tetapi tes semacam itu tidak benar, karena dalam kehidupan nyata kesalahan tidak terjadi pada setiap eksekusi skrip. </p><br><p>  Tentu saja, tes tidak boleh dilakukan pada versi beta PHP dan tidak boleh membandingkan solusi utama dengan yang eksperimental.  Dan jika penguji berusaha untuk membandingkan "kecepatan parsing json dan xml", maka ia tidak boleh menggunakan fungsi eksperimental dalam tes. </p><br><p>  Beberapa tes hanya menunjukkan kesalahpahaman total oleh penguji tugas yang ditetapkan olehnya.  Contoh serupa dari artikel yang baru-baru ini diterbitkan telah disebutkan di atas: penulis tes mencoba mencari tahu apakah kode yang menyebabkan kesalahan ("Penggunaan konstanta tidak terdefinisi") akan lebih lambat daripada kode tanpa kesalahan (yang menggunakan string literal yang benar secara sintaksis), tetapi gagal bahkan dengan tes yang jelas tidak berarti ini, membandingkan kinerja <em>angka yang dikutip</em> dengan kinerja angka yang ditulis tanpa tanda kutip.  Tentu saja, Anda dapat menulis angka tanpa tanda kutip dalam PHP (tidak seperti string), dan sebagai hasilnya, penulis menguji fungsi yang sama sekali berbeda, menerima hasil yang salah. </p><br><p>  Ada masalah lain yang perlu dipertimbangkan, seperti lingkungan pengujian.  Ada ekstensi ke PHP seperti XDebug yang dapat memiliki dampak yang sangat besar pada hasil tes.  Atau cache opcode yang telah disebutkan, yang harus dimasukkan selama tes kinerja sehingga hasil tes setidaknya masuk akal. </p><br><p>  Bagaimana pengujian dilakukan juga penting.  Karena proses PHP mati sepenuhnya setelah setiap permintaan, masuk akal untuk menguji kinerja seluruh siklus hidup, mulai dari membuat koneksi ke server web dan berakhir dengan menutup koneksi ini.  Ada utilitas seperti benchmark Apache atau Pengepungan yang memungkinkan Anda melakukan ini. </p><br><h3 id="realnoe-uluchshenie-proizvoditelnosti">  Peningkatan kinerja nyata </h3><br><p>  Semua ini baik, tetapi kesimpulan apa yang harus diambil pembaca dari artikel ini?  Apa tes kinerja yang tidak berguna menurut definisi?  Tentu saja tidak.  Tapi yang terpenting adalah <em>alasan</em> mereka harus memulai.  Menguji dari awal adalah buang-buang waktu.  Harus selalu ada alasan khusus untuk menjalankan tes kinerja.  Dan alasan ini disebut <em>"profiling</em> . <em>"</em>  Ketika aplikasi Anda mulai berjalan lambat, Anda perlu melakukan profil, yang berarti mengukur kecepatan berbagai bagian kode untuk menemukan yang paling lambat.  Setelah situs semacam itu ditemukan, kita harus menentukan penyebabnya.  Paling sering, ini jauh lebih besar dari yang dibutuhkan, jumlah data yang diproses, atau permintaan ke sumber data eksternal.  Untuk kasus pertama, optimasi akan terdiri dalam mengurangi jumlah data yang diproses, dan untuk kasus kedua, caching hasil kueri. </p><br><p>  Misalnya, dalam hal kinerja, tidak ada bedanya apakah kita menggunakan loop yang ditentukan secara eksplisit atau fungsi PHP bawaan untuk memproses array (yang pada dasarnya hanya gula sintaksis).  Yang benar-benar penting adalah <em>jumlah data</em> yang kami kirimkan untuk diproses.  Jika terlalu besar, kita harus memotongnya, atau memindahkan pemrosesan di tempat lain (ke database).  Ini akan memberi kita dorongan kinerja <em>besar</em> yang akan <em>nyata</em> .  Sementara perbedaan antara metode memanggil loop untuk pemrosesan data tidak mungkin terlihat sama sekali. </p><br><p>  Hanya setelah melakukan peningkatan kinerja wajib tersebut, atau jika kami tidak dapat memotong jumlah data yang diproses, kami dapat memulai pengujian kinerja.  Tetapi sekali lagi, tes seperti itu tidak harus dilakukan dari awal.  Untuk mulai membandingkan kinerja loop eksplisit dan fungsi inline, kita harus yakin bahwa loop adalah penyebab masalah, bukan isinya (spoiler: tentu saja, ini isinya). </p><br><p>  Contoh terbaru dari praktik saya: dalam kode ada kueri menggunakan Doctrine Query Builder, yang seharusnya mengambil beberapa ribu parameter.  Query itu sendiri cukup cepat, tetapi Doctrine membutuhkan waktu cukup lama untuk mencerna beberapa ribu parameter.  Akibatnya, kueri itu ditulis ulang dalam SQL murni, dan parameter ditransfer ke metode execute () dari perpustakaan PDO, yang mengatasi dengan begitu banyak parameter hampir secara instan. </p><br><p>  Apakah ini berarti saya tidak akan pernah menggunakan Doctrine Query Builder?  Tentu saja tidak.  Ini sempurna untuk 99% tugas, dan saya akan terus menggunakannya untuk semua pertanyaan.  Dan hanya dalam kasus luar biasa layak menggunakan metode yang kurang nyaman, tetapi lebih produktif. </p><br><p>  Permintaan dan parameter untuk seleksi ini dibangun dalam satu lingkaran.  Jika saya punya ide bodoh untuk berurusan dengan bagaimana siklus itu disebut, maka saya hanya akan kehilangan waktu tanpa hasil positif.  Dan ini adalah inti dari semua optimasi kinerja: untuk <strong>mengoptimalkan hanya kode yang berjalan lambat</strong> dalam kasus khusus Anda.  Dan bukan kode yang dianggap lambat sejak lama, di galaksi yang jauh, jauh, atau kode yang terpikir oleh seseorang untuk memanggil lambat berdasarkan tes yang tidak berarti. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id419743/">https://habr.com/ru/post/id419743/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id419727/index.html">Harbor - registri untuk keluar dari wadah Docker kotak</a></li>
<li><a href="../id419729/index.html">Acara amal "Berikan sayap kepada anak-anak"</a></li>
<li><a href="../id419731/index.html">Mini-review dari printer 3D photopolymer gigi MoonRay S</a></li>
<li><a href="../id419733/index.html">Git terjadi! 6 Kesalahan Umum Git dan Cara Memperbaikinya</a></li>
<li><a href="../id419735/index.html">Memeriksa sinyal I / Q dengan SDR menggunakan Adobe Audition</a></li>
<li><a href="../id419745/index.html">Genre AI klasik: ML mencari dirinya dalam puisi</a></li>
<li><a href="../id419747/index.html">DJI Ronin S - Peluncuran Pertama dan Fitur Utama</a></li>
<li><a href="../id419757/index.html">Terjemahan buku Andrew Un, Passion for Machine Learning, Bab 1 - 14</a></li>
<li><a href="../id419765/index.html">Kursus "bahasa pemrograman Web" (berdasarkan Ruby) dari MSTU. N.E. Bauman di saluran Technostream</a></li>
<li><a href="../id419767/index.html">Pembuat Wikipedia menjawab pertanyaan: pemrograman, tidur, buku, tips seumur hidup</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>