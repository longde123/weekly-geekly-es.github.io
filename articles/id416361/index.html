<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>âš–ï¸ ğŸ© ğŸŒ± Bagaimana mengatur keadaan umum dalam bereaksi aplikasi tanpa menggunakan perpustakaan (dan mengapa mobx diperlukan) ğŸšš ğŸ•´ï¸ ğŸ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Segera spoiler kecil - mengatur keadaan dalam mobx tidak berbeda dengan mengatur keadaan umum tanpa menggunakan mobx dalam reaksi murni. Jawaban atas ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana mengatur keadaan umum dalam bereaksi aplikasi tanpa menggunakan perpustakaan (dan mengapa mobx diperlukan)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416361/"><p>  Segera spoiler kecil - mengatur keadaan dalam mobx tidak berbeda dengan mengatur keadaan umum tanpa menggunakan mobx dalam reaksi murni.  Jawaban atas pertanyaan alami adalah mengapa, pada kenyataannya, apakah ini diperlukan? Anda akan menemukannya di akhir artikel. Sementara itu, artikel tersebut akan fokus pada organisasi negara dalam aplikasi reaksi bersih tanpa perpustakaan eksternal. </p><br><p><img src="https://habrastorage.org/webt/4x/dh/gw/4xdhgwhcoygforqwxaue1xutwwe.png"><br></p><br>  Reaksi menyediakan cara untuk menyimpan dan memperbarui status komponen menggunakan properti state pada instance komponen kelas dan metode setState.  Namun demikian, di antara komunitas yang bereaksi, sekelompok perpustakaan tambahan dan pendekatan untuk bekerja dengan negara digunakan (fluks, redux, reduxasi, efektor, mobx, otak, banyak dari mereka).  Tetapi apakah mungkin untuk membangun aplikasi yang cukup besar dengan sekelompok logika bisnis dengan sejumlah besar entitas dan hubungan data yang kompleks antara komponen yang hanya menggunakan setState?  Apakah ada kebutuhan untuk perpustakaan tambahan untuk bekerja dengan negara?  Mari kita cari tahu. <a name="habracut"></a><br><p>  Jadi kami telah setState dan yang memperbarui negara dan memanggil renderer komponen.  Tetapi bagaimana jika data yang sama diperlukan oleh banyak komponen yang tidak saling berhubungan?  Di dok resmi reaksi terdapat bagian "mengangkat keadaan" dengan uraian terperinci - kami hanya menaikkan status ke leluhur yang sama dengan komponen-komponen ini, melewati alat peraga (dan melalui komponen perantara, jika perlu) data dan fungsi untuk mengubahnya.  Untuk contoh kecil, ini terlihat masuk akal, tetapi kenyataannya adalah bahwa dalam aplikasi yang kompleks dapat ada banyak ketergantungan antara komponen dan kecenderungan untuk mentransfer status ke komponen umum leluhur mengarah pada kenyataan bahwa seluruh negara akan lebih tinggi dan lebih tinggi dan akan berakhir di komponen root dari App bersama dengan logika untuk memperbarui keadaan ini untuk semua komponen.  Akibatnya, setState hanya akan terjadi untuk memperbarui komponen data lokal atau dalam komponen root dari App, di mana semua logika akan terkonsentrasi. </p><br><p>  Tetapi apakah mungkin untuk menyimpan proses dan membuat status dalam aplikasi reaksi tanpa menggunakan setState atau pustaka tambahan dan menyediakan akses umum ke data ini dari komponen apa pun? </p><br><p>  Objek javascript yang paling umum dan aturan tertentu untuk mengaturnya datang untuk membantu kami. </p><br><p>  Tetapi pertama-tama Anda perlu mempelajari cara menguraikan aplikasi menjadi tipe entitas dan hubungannya. </p><br><p>  Untuk memulainya, kami memperkenalkan objek yang akan menyimpan data global yang berlaku untuk seluruh aplikasi secara keseluruhan - (ini bisa menjadi pengaturan untuk gaya, lokalisasi, ukuran jendela, dll.) Dalam satu objek AppState dan hanya menempatkan objek ini ke dalam file terpisah. </p><br><pre><code class="hljs julia">// src/stores/AppState.js <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AppState = { locale: <span class="hljs-string"><span class="hljs-string">"en"</span></span>, theme: <span class="hljs-string"><span class="hljs-string">"..."</span></span>, .... }</code> </pre> <br><p>  Sekarang dalam komponen apa pun Anda dapat mengimpor dan menggunakan data toko kami. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> AppState <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"../stores/AppState.js"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SomeComponent = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {AppState.locale === "..." ? ... : ...} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> )</code> </pre><br><p>  Kami melangkah lebih jauh - hampir setiap aplikasi memiliki esensi dari pengguna saat ini (tidak masalah bagaimana itu dibuat atau berasal dari server, dll.), Sehingga objek tunggal pengguna kami juga akan berada dalam keadaan aplikasi.  Itu juga dapat dipindahkan ke file terpisah dan juga diimpor, atau dapat langsung disimpan di dalam objek AppState.  Dan sekarang yang utama - Anda perlu menentukan diagram entitas yang membentuk aplikasi.  Dalam hal basis data, ini akan berupa tabel dengan hubungan satu-ke-banyak atau banyak-ke-banyak, dan seluruh rantai hubungan ini dimulai dari esensi utama pengguna.  Nah, dalam kasus kami, objek pengguna hanya akan menyimpan array dari objek-entitas-toko lain, di mana setiap objek-toko, pada gilirannya, akan menyimpan array dari toko-entitas lain. </p><br><p>  Berikut ini adalah contoh - ada logika bisnis yang dinyatakan sebagai "pengguna dapat membuat / mengedit / menghapus folder, proyek di setiap folder, di setiap proyek tugas dan di setiap tugas subtugas" (ternyata sesuatu seperti manajer tugas) dan akan terlihat dalam diagram keadaan sesuatu seperti ini: </p><br><pre> <code class="hljs powershell">export const AppStore = { locale: <span class="hljs-string"><span class="hljs-string">"en"</span></span>, theme: <span class="hljs-string"><span class="hljs-string">"..."</span></span>, currentUser: { name: <span class="hljs-string"><span class="hljs-string">"..."</span></span>, email: <span class="hljs-string"><span class="hljs-string">""</span></span> folders: [ { <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"folder1"</span></span>, <span class="hljs-type"><span class="hljs-type">projects</span></span>: [ { <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"project1"</span></span>, <span class="hljs-type"><span class="hljs-type">tasks</span></span>: [ { <span class="hljs-type"><span class="hljs-type">text</span></span>: <span class="hljs-string"><span class="hljs-string">"task1"</span></span>, <span class="hljs-type"><span class="hljs-type">subtasks</span></span>: [ {<span class="hljs-type"><span class="hljs-type">text</span></span>: <span class="hljs-string"><span class="hljs-string">"subtask1"</span></span>}, <span class="hljs-type"><span class="hljs-type">....</span></span> ] }, <span class="hljs-type"><span class="hljs-type">....</span></span> ] }, <span class="hljs-type"><span class="hljs-type">.....</span></span> ] }, <span class="hljs-type"><span class="hljs-type">.....</span></span> ] } }</code> </pre> <br><p>  Sekarang komponen root dari App hanya dapat mengimpor objek ini dan memberikan beberapa informasi tentang pengguna, dan kemudian dapat mentransfer objek pengguna ke komponen dasbor </p><br><pre> <code class="hljs xml"> .... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Dashboard</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">user</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{appState.user}/</span></span></span><span class="hljs-tag">&gt;</span></span> ....</code> </pre> <br><p>  dan dia dapat membuat daftar folder </p><br><pre> <code class="hljs javascript"> ... &lt;div&gt;{user.folders.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">folder</span></span></span><span class="hljs-function">=&gt;</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Folder</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">folder</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{folder}/</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">)}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ...</code> </pre> <br><p>  dan setiap komponen folder akan menampilkan daftar proyek </p><br><pre> <code class="hljs javascript"> .... &lt;div&gt;{folder.projects.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">project</span></span></span><span class="hljs-function">=&gt;</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Project</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">project</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{project}/</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">)}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ....</code> </pre> <br><p>  dan setiap komponen proyek dapat membuat daftar tugas </p><br><pre> <code class="hljs javascript"> .... &lt;div&gt;{project.tasks.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">task</span></span></span><span class="hljs-function">=&gt;</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Task</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">task</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{task}/</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">)}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ....</code> </pre> <br><p>  dan akhirnya, setiap komponen tugas dapat menyajikan daftar subtugas dengan meneruskan objek yang diinginkan ke komponen subtugas </p><br><pre> <code class="hljs javascript"> .... &lt;div&gt;{task.subtask.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">subtask</span></span></span><span class="hljs-function">=&gt;</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Subtask</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">subtask</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{subtask}/</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">)}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ....</code> </pre> <br><p>  Secara alami, pada satu halaman tidak ada yang akan menampilkan semua tugas dari semua proyek dari semua folder, mereka akan dibagi oleh panel samping (misalnya, daftar folder), oleh halaman, dll. Tetapi struktur umum kira-kira sama - komponen induk membuat komponen tertanam melewati sebuah objek dengan alat peraga data.  Poin penting harus dicatat - objek apa pun (misalnya, objek folder, proyek, tugas) tidak disimpan dalam keadaan komponen apa pun - komponen hanya menerimanya melalui alat peraga sebagai bagian dari objek yang lebih umum.  Dan misalnya, ketika komponen proyek melewati objek tugas ( <code>&lt;div&gt;{project.tasks.map(task=&gt;&lt;Task task={task}/&gt;)}&lt;/div&gt;</code> ) ke komponen turunan Tugas, karena fakta bahwa objek disimpan di dalam satu objek tunggal Anda selalu dapat mengubah objek tugas ini dari luar - misalnya, AppState.currentUser.folders [2] .projects [3] .tasks [4] .text = "tugas yang diedit" dan kemudian menyebabkan komponen root diperbarui (ReactDOM.render (&lt;App /&gt;&gt; ) dan dengan cara ini kita mendapatkan status aplikasi saat ini. </p><br><p>  Misalkan lebih lanjut bahwa kita ingin membuat subtugas baru ketika mengklik tombol "+" di komponen Tugas.  Semuanya sederhana </p><br><pre> <code class="hljs coffeescript"><span class="hljs-function"><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onClick</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.task.subtasks.push({text: <span class="hljs-string"><span class="hljs-string">""</span></span>}); updateDOM() }</code> </pre> <br><p>  karena komponen Tugas menerima sebagai alat bantu objek tugas dan objek ini tidak disimpan di dalam keadaannya tetapi merupakan bagian dari toko AppState global (yaitu, objek tugas disimpan di dalam array tugas dari objek proyek yang lebih umum, dan pada gilirannya merupakan bagian dari objek pengguna dan pengguna sudah disimpan di dalam AppState ) dan berkat konektivitas ini, setelah menambahkan objek tugas baru ke array subtasks, Anda dapat memanggil pembaruan komponen root dan dengan demikian memperbarui dan memperbarui rumah untuk semua perubahan data (di mana pun mereka terjadi) hanya dengan memanggil fungsi pembaruan  ateDOM, yang pada gilirannya hanya memperbarui komponen root. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateDOM</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ ReactDom.render(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">App</span></span></span></span><span class="xml"><span class="hljs-tag">/&gt;</span></span></span></span>, rootElement); }</code> </pre> <br><p>  Dan tidak masalah data bagian AppState mana dan dari tempat apa yang kami ubah (misalnya, Anda dapat meneruskan objek folder melalui alat peraga melalui komponen Proyek dan Tugas perantara ke komponen Subtask, dan hanya dapat memperbarui nama folder (this.props.folder.name = "nama baru ") - karena komponen menerima data melalui alat peraga, memperbarui komponen root akan memperbarui semua komponen bersarang dan memperbarui seluruh aplikasi. </p><br><p>  Sekarang mari kita coba menambahkan beberapa kenyamanan untuk bekerja dengan sisi.  Dalam contoh di atas, Anda dapat melihat bahwa membuat objek entitas baru setiap kali (misalnya <code>project.tasks.push({text: "", subtasks: [], ...})</code> jika objek memiliki banyak properti dengan parameter default, maka setiap kali untuk membuat daftar mereka dan Anda dapat membuat kesalahan dan melupakan sesuatu, dll. Hal pertama yang terlintas dalam pikiran adalah untuk menempatkan penciptaan objek ke fungsi di mana bidang default akan ditugaskan dan pada saat yang sama mendefinisikan ulang mereka dengan data baru </p><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { text: <span class="hljs-string"><span class="hljs-string">""</span></span>, subtasks: [], ... //many default fields ...data } }</code> </pre> <br><p>  tetapi jika Anda melihat dari sisi lain, fungsi ini adalah konstruktor dari entitas tertentu dan kelas javascript sangat bagus untuk peran ini </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class"> </span></span>{ text: <span class="hljs-string"><span class="hljs-string">""</span></span>; subtasks: []; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>){ Object.assign(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) } }</code> </pre> <br><p>  dan kemudian membuat objek hanya akan membuat turunan kelas dengan kemampuan untuk menimpa beberapa bidang default </p><br><pre> <code class="hljs coffeescript"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAddTask</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.project.tasks.push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Task({...}) }</code> </pre><br><p>  Lebih lanjut, Anda dapat melihat bahwa dengan cara yang sama, membuat kelas untuk objek proyek, pengguna, subtugas, kami mendapatkan duplikasi kode di dalam konstruktor </p><br><pre> <code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ Object.assign(this,data) }</span></span></span></span></code> </pre> <br><p>  tetapi kita dapat mengambil keuntungan dari pewarisan dan menarik kode ini ke konstruktor kelas dasar. </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseStore</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>){ Object.update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); } }</code> </pre> <br><p>  Lebih lanjut, Anda akan melihat bahwa setiap kali kami memperbarui beberapa keadaan, kami mengubah bidang objek secara manual </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.firstName = "..."; <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.lastName = "..."; updateDOM();</code> </pre> <br><p>  dan menjadi sulit untuk melacak, tawar-menawar dan memahami apa yang terjadi dalam komponen dan oleh karena itu ada kebutuhan untuk menentukan saluran umum di mana pembaruan data apa pun akan melalui dan kemudian kita dapat menambahkan logging dan segala macam fasilitas lainnya.  Untuk melakukan ini, solusinya adalah membuat metode pembaruan di kelas yang akan mengambil objek sementara dengan data baru dan memperbarui sendiri dan menetapkan aturan bahwa objek dapat diperbarui hanya melalui metode pembaruan dan bukan dengan penugasan langsung </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class"> </span></span>{ update(newData){ console.log(<span class="hljs-string"><span class="hljs-string">"before update"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); Object.assign(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); console.log(<span class="hljs-string"><span class="hljs-string">"after update"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } } <span class="hljs-comment"><span class="hljs-comment">//// user.update({firstName: "...", lastName: "..."})</span></span></code> </pre> <br><p>  Nah, agar tidak menduplikasi kode di setiap kelas, kami juga memindahkan metode pembaruan ini ke kelas dasar. </p><br><p>  Sekarang Anda dapat melihat bahwa ketika kami memperbarui beberapa data, kami harus memanggil metode updateDOM () secara manual.  Namun dimungkinkan untuk melakukan pembaruan ini secara otomatis setiap kali panggilan ke metode pembaruan ({...}) dari kelas dasar terjadi. <br>  Ternyata kelas dasar akan terlihat seperti ini </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseStore</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>){ Object.update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); } update(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>){ Object.update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); ReactDOM.render(&lt;App/&gt;, rootElement) } }</code> </pre><br><p>  Nah, agar selama panggilan berturut-turut dari metode pembaruan () tidak ada pembaruan yang tidak perlu, Anda dapat menunda memperbarui komponen ke siklus acara berikutnya </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> TimerId = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseStore</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(data){ <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, data); } update(data){ <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, data); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(TimerId === <span class="hljs-number"><span class="hljs-number">0</span></span>) { TimerId = setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{ TimerId = <span class="hljs-number"><span class="hljs-number">0</span></span>; ReactDOM.render(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">App</span></span></span></span><span class="xml"><span class="hljs-tag">/&gt;</span></span></span></span>, rootElement); }) } } }</code> </pre> <br><p>  Selanjutnya, Anda dapat secara bertahap meningkatkan fungsionalitas kelas dasar - misalnya, agar tidak harus mengirim permintaan secara manual ke server setiap kali, selain memperbarui status, Anda dapat mengirim permintaan ke metode pembaruan ({..}) di latar belakang.  Anda dapat mengatur saluran pembaruan langsung untuk soket web dengan menambahkan akun dari setiap objek yang dibuat di peta hash global tanpa mengubah komponen dan bekerja dengan data dengan cara apa pun. </p><br><p>  Masih banyak yang harus dilakukan, tetapi saya ingin menyebutkan satu topik yang menarik - sangat sering melewati objek dengan data ke komponen yang diperlukan (misalnya, ketika komponen proyek membuat komponen tugas - </p><br><pre> <code class="hljs javascript">&lt;div&gt;{project.tasks.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">task</span></span></span><span class="hljs-function">=&gt;</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Task</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">task</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{task}/</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">)}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><p>  komponen tugas yang paling mungkin memerlukan beberapa informasi yang tidak disimpan langsung di dalam tugas tetapi terletak di objek induk. </p><br><p>  Misalkan Anda ingin mewarnai semua tugas dalam warna yang disimpan dalam proyek dan umum untuk semua tugas.  Untuk melakukan ini, selain alat peraga tugas, komponen proyek juga harus mengirimkan alat peraga proyeknya <code>&lt;Task task={task} project={this.props.project}/&gt;</code> .  Dan jika Anda tiba-tiba perlu mewarnai tugas dengan warna yang sama untuk semua tugas dalam satu folder, Anda harus mentransfer objek folder saat ini dari komponen Folder ke komponen Tugas dengan meneruskannya melalui komponen Proyek perantara. <br>  Muncul ketergantungan rapuh bahwa komponen harus tahu apa yang diperlukan komponen bersarang.  Selain itu, kemungkinan konteks reaksi, meskipun akan menyederhanakan transfer melalui komponen perantara, masih akan memerlukan deskripsi penyedia dan pengetahuan tentang data apa yang diperlukan untuk komponen anak. </p><br><p>  Tetapi masalah utama adalah bahwa setiap kali Anda mengedit desain atau mengubah daftar harapan pelanggan ketika suatu komponen membutuhkan informasi baru, Anda harus mengubah komponen yang lebih tinggi baik untuk meneruskan alat peraga atau membuat penyedia konteks.  Saya ingin komponen menerima melalui alat peraga sebuah objek dengan data untuk mengakses bagian aplikasi kita.  Dan di sini, javascript sangat cocok (tidak seperti bahasa fungsional seperti elm atau pendekatan abadi seperti redux) - sehingga objek dapat menyimpan tautan melingkar satu sama lain.  Dalam kasus ini, objek tugas harus memiliki bidang tugas.proyek dengan tautan ke objek proyek induk di mana disimpan, dan objek proyek pada gilirannya harus memiliki tautan ke objek folder, dll., Ke objek AppState root.  Dengan demikian, komponen, tidak peduli seberapa dalam itu, selalu dapat melalui objek induk melalui tautan dan mendapatkan semua informasi yang diperlukan dan tidak perlu membuangnya melalui banyak komponen perantara.  Oleh karena itu, kami memperkenalkan aturan - setiap kali membuat objek Anda perlu menambahkan tautan ke objek induk.  Misalnya, sekarang membuat tugas baru akan terlihat seperti ini </p><br><pre> <code class="hljs kotlin"> ... <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {project} = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newTask = new Task({project: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.project}) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.project.tasks.push(newTask);</code> </pre> <br><p>  Lebih jauh, dengan peningkatan logika bisnis, Anda dapat melihat bahwa bollerplate dikaitkan dengan dukungan backlink (misalnya, menetapkan tautan ke objek induk saat membuat objek baru atau misalnya, saat mentransfer proyek dari satu folder ke folder lain, ia tidak hanya akan memerlukan memperbarui proyek.folder = properti baruFolder diri Anda dari array proyek folder sebelumnya dan menambahkan folder baru ke array proyek) mulai mengulangi dan juga dapat dipindahkan ke kelas dasar sehingga ketika Anda membuat objek itu cukup untuk menentukan induk - <code>new Task({project: this.porps.project})</code>  <code>new Task({project: this.porps.project})</code> dan kelas dasar akan secara otomatis menambahkan objek baru ke array <code>project.tasks</code> dan juga ketika mentransfer tugas ke proyek lain, cukup dengan memperbarui bidang <code>task.update({project: newProject})</code> dan kelas dasar akan secara otomatis menghapus tugas dari berbagai tugas dari proyek sebelumnya dan ditambahkan ke yang baru.  Tetapi ini sudah membutuhkan deklarasi hubungan (misalnya, dalam properti atau metode statis) sehingga kelas dasar tahu bidang mana yang harus diperbarui. </p><br><p>  <strong>Kesimpulan</strong> </p><br><p>  Dengan cara yang sederhana, hanya menggunakan objek-js, kami sampai pada kesimpulan bahwa Anda bisa mendapatkan semua kenyamanan bekerja dengan keadaan umum aplikasi tanpa memperkenalkan ke dalam aplikasi ketergantungan pada perpustakaan eksternal untuk bekerja dengan negara. </p><br><p>  Pertanyaannya adalah, mengapa kita membutuhkan perpustakaan untuk mengelola negara dan, khususnya, mobx? </p><br><p>  Faktanya adalah bahwa dalam pendekatan yang dijelaskan untuk organisasi keadaan umum, ketika menggunakan objek "vanilla" js (atau objek kelas) asli biasa ada satu kelemahan besar - ketika sebagian kecil dari negara atau bahkan satu bidang berubah, komponen akan diperbarui atau "dirender" yang tidak terhubung dengan cara apa pun dan tidak bergantung pada bagian negara ini. <br>  Dan pada aplikasi besar dengan huruf tebal, ini akan menyebabkan rem karena reaksinya tidak punya waktu untuk secara rekursif membandingkan rumah virtual dari seluruh aplikasi, mengingat bahwa selain membandingkan setiap penyaji, pohon objek baru akan dihasilkan setiap kali menggambarkan tata letak dari semua komponen. </p><br><p>  Tetapi masalah ini, meskipun penting, adalah murni teknis - ada perpustakaan yang mirip dengan reaksi dom vitual yang lebih baik mengoptimalkan renderer dan dapat meningkatkan batas komponen. </p><br><p>  Ada teknik renovasi rumah yang lebih efektif daripada membuat pohon rumah virtual baru dan lulus perbandingan rekursif berikutnya dengan pohon sebelumnya. </p><br><p>  Dan akhirnya, ada perpustakaan yang mencoba memecahkan masalah pembaruan lambat melalui pendekatan yang berbeda - yaitu, untuk melacak bagian negara mana yang terhubung ke komponen mana dan ketika mengubah beberapa data, menghitung dan memperbarui hanya komponen-komponen yang bergantung pada data ini dan tidak menyentuh komponen yang tersisa.  Redux juga perpustakaan seperti itu, tetapi membutuhkan pendekatan yang sama sekali berbeda untuk organisasi negara.  Tetapi pustaka mobx, sebaliknya, tidak membawa sesuatu yang baru dan kita bisa mendapatkan percepatan penyaji secara praktis tanpa mengubah apa pun dalam aplikasi - cukup tambahkan dekorator yang dapat <code>@observable</code> ke bidang kelas dan dekorator <code>@observable</code> ke komponen yang membuat bidang ini tetap ada untuk hanya memotong kode pembaruan yang tidak perlu untuk komponen root dalam metode pembaruan () dari kelas dasar kami dan kami akan mendapatkan aplikasi yang berfungsi penuh, tetapi sekarang mengubah bagian dari keadaan atau bahkan satu bidang akan memperbarui hanya komponen-komponen itu  yang jatuh tempo ditandatangani (memutar metode dalam render ()) untuk bidang tertentu dari negara tertentu objek. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id416361/">https://habr.com/ru/post/id416361/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id416349/index.html">Lihat riaknya</a></li>
<li><a href="../id416351/index.html">Pendekatan top-down. Ekonomi Produk. Laba kotor</a></li>
<li><a href="../id416353/index.html">Audio Digest: 20 bahan tentang sejarah sistem akustik dan musik dalam budaya Soviet</a></li>
<li><a href="../id416355/index.html">Wawancara dengan Gary Hudson, CEO Oisin Biotechnologies</a></li>
<li><a href="../id416359/index.html">Lingkungan kerja yang cepat untuk pengembang web (Vagrant dan PHPStorm)</a></li>
<li><a href="../id416363/index.html">Taobao resmi dibuka di Rusia</a></li>
<li><a href="../id416365/index.html">Koleksi keinginan dan pemungutan suara untuk fitur-fitur baru dari browser Vivaldi</a></li>
<li><a href="../id416367/index.html">Kami memulai ReactOS dengan BTRFS dari bagian ini</a></li>
<li><a href="../id416369/index.html">Hampir rumit. Bagian 2, menciptakan "rumah pintar" nirkabel. Berbasis pada teknologi Linux, perangkat lunak Z-Wave dan MajorDoMo</a></li>
<li><a href="../id416371/index.html">Lampu berkemah analog</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>