<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍✈️ 🈂️ 👡 Unity Hexagon Maps: Wasser, Sehenswürdigkeiten und Festungsmauern ✔️ 🤶 👨🏿‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Teile 1-3: Netz, Farben und Zellenhöhen 

 Teile 4-7: Unebenheiten, Flüsse und Straßen 

 Teile 8-11: Wasser, Landformen und Wälle 

 Teile 12-15: Spe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unity Hexagon Maps: Wasser, Sehenswürdigkeiten und Festungsmauern</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425463/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 1-3: Netz, Farben und Zellenhöhen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 4-7: Unebenheiten, Flüsse und Straßen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 8-11: Wasser, Landformen und Wälle</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 12-15: Speichern und Laden, Texturen, Entfernungen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 16-19: Weg finden, Spielerkader, Animationen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 20-23: Nebel des Krieges, Kartenforschung, Verfahrensgenerierung</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 24-27: Wasserkreislauf, Erosion, Biomes, zylindrische Karte</a> <br><br><h1>  Teil 8: Wasser </h1><br><ul><li>  Wasser in die Zellen geben. </li><li>  Triangulieren Sie die Wasseroberfläche. </li><li>  Erstellen Sie eine Brandung mit Schaum. </li><li>  Kombinieren Sie Wasser und Flüsse. </li></ul><br>  Wir haben bereits Flussunterstützung hinzugefügt, und in diesem Teil werden wir die Zellen vollständig in das Wasser eintauchen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a9/73c/b6e/2a973cb6eb97eba7d04a325f3ac89a3e.jpg"></div><br>  <i>Wasser kommt.</i> <br><a name="habracut"></a><br><h2>  Wasserstand </h2><br>  Am einfachsten ist es, die Wasserunterstützung zu implementieren, indem Sie sie auf das gleiche Niveau einstellen.  Alle Zellen, deren Höhe unter diesem Niveau liegt, werden in Wasser getaucht.  Ein flexiblerer Weg wäre jedoch, das Wasser in unterschiedlichen Höhen zu halten. Lassen Sie uns also den Wasserstand veränderbar machen.  Dazu muss <code>HexCell</code> den Wasserstand überwachen. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> WaterLevel { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> waterLevel; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (waterLevel == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } waterLevel = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Refresh(); } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> waterLevel;</code> </pre> <br>  Falls gewünscht, können Sie sicherstellen, dass bestimmte Merkmale des Reliefs unter Wasser nicht vorhanden waren.  Aber im Moment werde ich das nicht tun.  Dinge wie Unterwasserstraßen passen zu mir.  Sie können als Gebiete betrachtet werden, die kürzlich überflutet wurden. <br><br><h3>  Zellen überfluten </h3><br>  Jetzt, wo wir Wasserstände haben, ist die wichtigste Frage, ob sich die Zellen unter Wasser befinden.  Eine Zelle befindet sich unter Wasser, wenn ihr Wasserstand über ihrer Höhe liegt.  Um diese Informationen zu erhalten, fügen wir eine Eigenschaft hinzu. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsUnderwater { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> waterLevel &gt; elevation; } }</code> </pre> <br>  Dies bedeutet, dass sich die Zelle bei gleichem Wasserstand und gleicher Höhe über das Wasser erhebt.  Das heißt, die reale Wasseroberfläche befindet sich unterhalb dieser Höhe.  <code>HexMetrics.riverSurfaceElevationOffset</code> wir wie bei Flussoberflächen den gleichen Versatz hinzu - <code>HexMetrics.riverSurfaceElevationOffset</code> .  Ändern Sie den Namen in einen allgemeineren. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public const float riverSurfaceElevationOffset = -0.5f; public const float waterElevationOffset = -0.5f;</span></span></code> </pre> <br>  Ändern Sie <code>HexCell.RiverSurfaceY</code> so, dass der neue Name verwendet wird.  Dann fügen wir der Wasseroberfläche der überfluteten Zelle eine ähnliche Eigenschaft hinzu. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> RiverSurfaceY { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (elevation + HexMetrics.waterElevationOffset) * HexMetrics.elevationStep; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> WaterSurfaceY { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (waterLevel + HexMetrics.waterElevationOffset) * HexMetrics.elevationStep; } }</code> </pre> <br><h3>  Wasserbearbeitung </h3><br>  Das Bearbeiten des Wasserstandes ähnelt dem Ändern der Höhe.  Daher muss <code>HexMapEditor</code> den aktiven Wasserstand überwachen und prüfen, ob er auf die Zellen angewendet werden soll. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> activeElevation; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> activeWaterLevel; … <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> applyElevation = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> applyWaterLevel = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre><br>  Fügen Sie Methoden hinzu, um diese Parameter mit der Benutzeroberfläche zu verbinden. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetApplyWaterLevel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { applyWaterLevel = toggle; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetWaterLevel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level</span></span></span><span class="hljs-function">)</span></span> { activeWaterLevel = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)level; }</code> </pre> <br>  Und fügen Sie den Wasserstand zu <code>EditCell</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { cell.Color = activeColor; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyElevation) { cell.Elevation = activeElevation; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyWaterLevel) { cell.WaterLevel = activeWaterLevel; } … } }</code> </pre> <br>  Um der Benutzeroberfläche einen Wasserstand hinzuzufügen, duplizieren Sie die Beschriftung und den Höhenregler und ändern Sie sie dann.  Denken Sie daran, ihre Ereignisse an die entsprechenden Methoden anzuhängen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/42b/a13/de4/42ba13de4120b43e460628021c77d99f.png"></div><br>  <i>Wasserstandsregler.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einheitspaket</a> <br><br><h2>  Wassertriangulation </h2><br>  Um Wasser zu triangulieren, brauchen wir ein neues Netz mit neuem Material.  Erstellen Sie zunächst einen <em>Wasser-</em> Shader, der den <em>River-</em> Shader dupliziert.  Ändern Sie es so, dass es die Farbeigenschaft verwendet. <br><br><pre> <code class="hljs pgsql">Shader "Custom/Water" { Properties { _Color ("Color", Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex ("Albedo (RGB)", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Glossiness ("Smoothness", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.5</span></span> _Metallic ("Metallic", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.0</span></span> } SubShader { Tags { "RenderType"="Transparent" "Queue"="Transparent" } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> CGPROGRAM #pragma surface surf Standard alpha #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; }; half _Glossiness; half _Metallic; fixed4 _Color; <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = _Color; o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; } ENDCG } FallBack "Diffuse" }</code> </pre> <br>  Erstellen Sie mit diesem Shader ein neues Material, indem Sie das <em>Wassermaterial</em> duplizieren und durch einen Shader ersetzen.  Lassen Sie die Rauschstruktur, da wir sie später verwenden werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd9/238/283/fd9238283d92bacd26a3ff5dce73b17b.png"></div><br>  <i>Wassermaterial.</i> <br><br>  Fügen Sie dem Fertighaus ein neues Kind hinzu, indem Sie das <em>Rivers-</em> Kind duplizieren.  Er braucht keine UV-Koordinaten und er muss <em>Wasser verwenden</em> .  Wie üblich erstellen wir dazu eine Instanz des Fertighauses, ändern es und wenden die Änderungen dann auf das Fertighaus an.  Entfernen Sie danach die Instanz. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ec/6e6/82f/6ec6e682f16c604d75c0e5b835d5b03e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c5/3f3/eeb/7c53f3eeb282e533f9f0b8a20e813091.png"></div><br>  <i>Kinderobjekt Wasser.</i> <br><br>  Als nächstes fügen Sie <code>HexGridChunk</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMesh terrain, rivers, roads, water; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrain.Clear(); rivers.Clear(); roads.Clear(); water.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { Triangulate(cells[i]); } terrain.Apply(); rivers.Apply(); roads.Apply(); water.Apply(); }</code> </pre> <br>  Und verbinden Sie es mit dem Fertighaus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4d/19a/76a/b4d19a76a745d550314b277fd2c0e13c.png"></div><br>  <i>Das Wasserobjekt ist verbunden.</i> <br><br><h3>  Sechsecke aus Wasser </h3><br>  Da Wasser eine zweite Schicht bildet, geben wir ihm für jede Richtung unsere eigene Triangulationsmethode.  Wir müssen es nur nennen, wenn die Zelle in Wasser getaucht ist. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { TriangulateWater(direction, cell, center); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br>  Wie bei Flüssen variiert die Höhe der Wasseroberfläche in Zellen mit gleichem Wasserstand nicht stark.  Daher scheinen wir keine komplexen Rippen zu benötigen.  Ein einfaches Dreieck wird ausreichen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { center.y = cell.WaterSurfaceY; Vector3 c1 = center + HexMetrics.GetFirstSolidCorner(direction); Vector3 c2 = center + HexMetrics.GetSecondSolidCorner(direction); water.AddTriangle(center, c1, c2); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a51/72b/99b/a5172b99ba382c6e79abff653e4b7fb2.png"></div><br>  <i>Sechsecke aus Wasser.</i> <br><br><h3>  Wasserverbindungen </h3><br>  Wir können benachbarte Zellen mit Wasser mit einem Viereck verbinden. <br><br><pre> <code class="cs hljs"> water.AddTriangle(center, c1, c2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { HexCell neighbor = cell.GetNeighbor(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || !neighbor.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 bridge = HexMetrics.GetBridge(direction); Vector3 e1 = c1 + bridge; Vector3 e2 = c2 + bridge; water.AddQuad(c1, c2, e1, e2); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a6/3af/949/0a63af9496da925e966b008f41f808a8.png"></div><br>  <i>Verbindungen der Ränder des Wassers.</i> <br><br>  Und füllen Sie die Ecken mit einem Dreieck. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { … water.AddQuad(c1, c2, e1, e2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E) { HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || !nextNeighbor.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } water.AddTriangle( c2, e2, c2 + HexMetrics.GetBridge(direction.Next()) ); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c32/37e/5b4/c3237e5b4e492f9a1c334f90aaa88ee4.png"></div><br>  <i>Fugen von Wasserecken.</i> <br><br>  Jetzt haben wir Wasserzellen angeschlossen, wenn sie in der Nähe sind.  Sie lassen eine Lücke zwischen sich und trockenen Zellen mit einer höheren Höhe, aber wir werden dies für später belassen. <br><br><h3>  Harmonisierte Wasserstände </h3><br>  Wir haben angenommen, dass benachbarte Unterwasserzellen den gleichen Wasserstand haben.  Wenn dies so ist, sieht alles gut aus, aber wenn diese Annahme verletzt wird, treten Fehler auf. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fcf/a8b/b4f/fcfa8bb4fb960ddc788d358e60f9023f.png"></div><br>  <i>Inkonsistenter Wasserstand.</i> <br><br>  Wir können dafür sorgen, dass das Wasser auf dem gleichen Niveau bleibt.  Wenn sich beispielsweise der Wasserstand einer überfluteten Zelle ändert, können wir die Änderungen auf benachbarte Zellen übertragen, um die Wasserstände synchron zu halten.  Dieser Prozess sollte jedoch fortgesetzt werden, bis er auf Zellen trifft, die nicht in Wasser eingetaucht sind.  Diese Zellen definieren die Grenzen der Wassermasse. <br><br>  Die Gefahr dieses Ansatzes besteht darin, dass er schnell außer Kontrolle geraten kann.  Wenn die Bearbeitung nicht erfolgreich ist, kann Wasser die gesamte Karte bedecken.  Dann müssen alle Fragmente gleichzeitig trianguliert werden, was zu einem enormen Anstieg der Verzögerungen führt. <br><br>  Also lass es uns noch nicht tun.  Diese Funktion kann in einem komplexeren Editor hinzugefügt werden.  Während die Konsistenz des Wasserstandes, verlassen wir das Gewissen des Benutzers. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Einheitspaket</a> <br><br><h2>  Wasseranimation </h2><br>  Anstelle einer einheitlichen Farbe werden wir etwas erzeugen, das Wellen ähnelt.  Wie bei anderen Shadern werden wir vorerst nicht nach einer schönen Grafik streben, sondern nur die Wellen bezeichnen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca1/a2f/1f9/ca1a2f1f978cd2f2993a96b44440227b.png"></div><br>  <i>Perfekt flaches Wasser.</i> <br><br>  Machen wir das, was wir mit den Flüssen gemacht haben.  Wir probieren das Rauschen mit der Position der Welt aus und fügen es einer einheitlichen Farbe hinzu.  Fügen Sie der V-Koordinate Zeit hinzu, um die Oberfläche zu animieren. <br><br><pre> <code class="hljs pgsql"> struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; float3 worldPos; }; … <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz; uv.y += _Time.y; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, uv * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); <span class="hljs-type"><span class="hljs-type">float</span></span> waves = noise.z; fixed4 c = saturate(_Color + waves); o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Scrollendes Wasser, Zeit × 10.</i> <br><br><h3>  Zwei Richtungen </h3><br>  Bisher ist das überhaupt nicht wie Wellen.  Lassen Sie uns das Bild komplizieren, indem wir ein zweites Rauschmuster hinzufügen <br>  und diesmal Hinzufügen der U-Koordinate. Wir verwenden einen anderen Rauschkanal, um als Ergebnis zwei verschiedene Muster zu erhalten.  Die fertigen Wellen sind diese beiden zusammen gestapelten Samples. <br><br><pre> <code class="hljs pgsql"> float2 uv1 = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz; uv1.y += _Time.y; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise1 = tex2D(_MainTex, uv1 * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); float2 uv2 = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz; uv2.x += _Time.y; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise2 = tex2D(_MainTex, uv2 * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); <span class="hljs-type"><span class="hljs-type">float</span></span> waves = noise1.z + noise2.x;</code> </pre> <br>  Wenn wir beide Stichproben summieren, erhalten wir Ergebnisse im Intervall 0–2, daher müssen wir sie auf 0–1 zurückskalieren.  Anstatt die Wellen einfach in zwei <code>smoothstep</code> zu teilen, können wir die <code>smoothstep</code> Funktion verwenden, um ein interessanteres Ergebnis zu <code>smoothstep</code> .  Wir setzen ¾ - 2 auf 0–1, damit keine sichtbaren Wellen auf der Wasseroberfläche sind. <br><br><pre> <code class="hljs mel"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> waves = noise1.z + noise2.x; waves = <span class="hljs-keyword"><span class="hljs-keyword">smoothstep</span></span>(<span class="hljs-number"><span class="hljs-number">0.75</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, waves);</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Zwei Richtungen, Zeit × 10.</i> <br><br><h3>  Wellen des Mischens </h3><br>  Es fällt immer noch auf, dass wir zwei sich bewegende Geräuschmuster haben, die sich nicht wirklich ändern.  Es wäre plausibler, wenn sich die Muster ändern würden.  Wir können dies realisieren, indem wir zwischen verschiedenen Kanälen von Rauschproben interpolieren.  Dies kann jedoch nicht auf die gleiche Weise erfolgen, da sich sonst gleichzeitig die gesamte Wasseroberfläche ändert, was sehr auffällig ist.  Stattdessen werden wir eine Welle der Verwirrung erzeugen. <br><br>  Wir werden mit Hilfe einer Sinuskurve eine Mischwelle erzeugen, die sich diagonal entlang der Wasseroberfläche bewegt.  Wir werden dies tun, indem wir die Weltkoordinaten X und Z addieren und die Summe als Eingabe für die <code>sin</code> Funktion verwenden.  Verkleinern Sie die Ansicht, um ausreichend große Bänder zu erhalten.  Und natürlich fügen wir den gleichen Wert hinzu, um sie zu animieren. <br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float</span></span> blendWave = sin((<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.x + <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.z) * <span class="hljs-number"><span class="hljs-number">0.1</span></span> + _Time.y);</code> </pre> <br>  Sinuswellen liegen zwischen -1 und 1, und wir benötigen ein Intervall von 0–1.  Sie können es erhalten, indem Sie die Welle quadrieren.  Um ein isoliertes Ergebnis anzuzeigen, verwenden Sie es anstelle der geänderten Farbe als Ausgabewert. <br><br><pre> <code class="hljs pgsql"> sin((<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.x + <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.z) * <span class="hljs-number"><span class="hljs-number">0.1</span></span> + _Time.y); blendWave *= blendWave; <span class="hljs-type"><span class="hljs-type">float</span></span> waves = noise1.z + noise2.x; waves = smoothstep(<span class="hljs-number"><span class="hljs-number">0.75</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, waves); fixed4 c = blendWave; //saturate(_Color + waves);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa3/3d9/d70/aa33d9d70a022df57a0348423181b258.png"></div><br>  <i>Wellen des Mischens.</i> <br><br>  Um die Mischwellen weniger wahrnehmbar zu machen, fügen Sie ihnen etwas Rauschen von beiden Samples hinzu. <br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float</span></span> blendWave = sin( (<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.x + <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.z) * <span class="hljs-number"><span class="hljs-number">0.1</span></span> + (noise1.y + noise2.z) + _Time.y ); blendWave *= blendWave;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/618/c8f/697/618c8f697cd2e463d7349030277d1a82.png"></div><br>  <i>Verzerrte Mischwellen.</i> <br><br>  Schließlich verwenden wir eine Mischwelle, um zwischen den beiden Kanälen beider Rauschproben zu interpolieren.  Nehmen Sie für maximale Variation vier verschiedene Kanäle. <br><br><pre> <code class="hljs lisp"> float waves = lerp(<span class="hljs-name"><span class="hljs-name">noise1</span></span>.z, noise1.w, blendWave) + lerp(<span class="hljs-name"><span class="hljs-name">noise2</span></span>.x, noise2.y, blendWave)<span class="hljs-comment"><span class="hljs-comment">; waves = smoothstep(0.75, 2, waves); fixed4 c = saturate(_Color + waves);</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Wellen mischen, Zeit × 2.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Einheitspaket</a> <br><br><h2>  Die Küste </h2><br>  Wir sind mit offenem Wasser fertig, aber jetzt müssen wir die Lücke im Wasser entlang der Küste füllen.  Da wir uns an die Landkonturen anpassen müssen, erfordert das Küstenwasser einen anderen Ansatz.  Teilen wir <code>TriangulateWater</code> in zwei Methoden ein - eine für offenes Wasser und eine für die Küste.  Um zu verstehen, wann wir mit der Küste arbeiten, müssen wir uns die benachbarte Zelle ansehen.  Das heißt, in <code>TriangulateWater</code> wir einen Nachbarn bekommen.  Wenn es einen Nachbarn gibt und er nicht unter Wasser ist, dann haben wir es mit der Küste zu tun. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { center.y = cell.WaterSurfaceY; HexCell neighbor = cell.GetNeighbor(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; !neighbor.IsUnderwater) { TriangulateWaterShore(direction, cell, neighbor, center); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateOpenWater(direction, cell, neighbor, center); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateOpenWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { Vector3 c1 = center + HexMetrics.GetFirstSolidCorner(direction); Vector3 c2 = center + HexMetrics.GetSecondSolidCorner(direction); water.AddTriangle(center, c1, c2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE &amp;&amp; neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// HexCell neighbor = cell.GetNeighbor(direction); // if (neighbor == null || !neighbor.IsUnderwater) { // return; // } Vector3 bridge = HexMetrics.GetBridge(direction); … } } void TriangulateWaterShore ( HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center ) { }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f04/799/441/f0479944178dcb5646bbf935700a798e.png"></div><br>  <i>Es gibt keine Triangulation entlang der Küste.</i> <br><br>  Da die Küste verzerrt ist, müssen wir die Wasserdreiecke entlang der Küste verzerren.  Deshalb brauchen wir die Kanten und einen Fächer mit Dreiecken. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( center + HexMetrics.GetFirstSolidCorner(direction), center + HexMetrics.GetSecondSolidCorner(direction) ); water.AddTriangle(center, e1.v1, e1.v2); water.AddTriangle(center, e1.v2, e1.v3); water.AddTriangle(center, e1.v3, e1.v4); water.AddTriangle(center, e1.v4, e1.v5); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bbd/761/283/bbd76128386859bb388e6e2d3f105ff0.png"></div><br>  <i>Fans von Dreiecken entlang der Küste.</i> <br><br>  Als nächstes kommt ein Rippenstreifen, wie bei einem normalen Relief.  Wir sind jedoch nicht verpflichtet, uns nur auf bestimmte Gebiete zu beschränken, da wir <code>TriangulateWaterShore</code> nur anrufen, wenn wir die Küste treffen, für die der Streifen immer benötigt wird. <br><br><pre> <code class="cs hljs"> water.AddTriangle(center, e1.v4, e1.v5); Vector3 bridge = HexMetrics.GetBridge(direction); EdgeVertices e2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( e1.v1 + bridge, e1.v5 + bridge ); water.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); water.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); water.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); water.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7da/fbc/aa9/7dafbcaa95a4b48509ab68fbf111c703.png"></div><br>  <i>Rippenstreifen entlang der Küste.</i> <br><br>  Ebenso müssen wir jedes Mal ein eckiges Dreieck hinzufügen. <br><br><pre> <code class="cs hljs"> water.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { water.AddTriangle( e1.v5, e2.v5, e1.v5 + HexMetrics.GetBridge(direction.Next()) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/064/18f/8b1/06418f8b10cc0fc0a4e2276b86375385.png"></div><br>  <i>Die Ecken der Rippen entlang der Küste.</i> <br><br>  Jetzt haben wir Wasser für die Küste bereit.  Ein Teil davon befindet sich immer unterhalb des Reliefnetzes, sodass keine Löcher vorhanden sind. <br><br><h3>  UV-Küste </h3><br>  Wir können alles so lassen, wie es ist, aber es wäre interessant, wenn das Küstenwasser einen eigenen Zeitplan hätte.  Zum Beispiel die Wirkung von Schaum, der bei Annäherung an die Küste größer wird.  Um es zu implementieren, muss der Shader wissen, wie nahe das Fragment an der Küste liegt.  Wir können diese Informationen über UV-Koordinaten übertragen. <br><br>  Offenes Wasser hat keine UV-Koordinaten und benötigt keinen Schaum.  Es wird nur für Wasser in Küstennähe benötigt.  Daher sind die Anforderungen für beide Wassertypen sehr unterschiedlich.  Es wäre logisch, für jeden Typ ein eigenes Netz zu erstellen.  Aus diesem Grund fügen wir HexGridChunk Unterstützung für ein anderes Netzobjekt hinzu. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMesh terrain, rivers, roads, water, waterShore; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrain.Clear(); rivers.Clear(); roads.Clear(); water.Clear(); waterShore.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { Triangulate(cells[i]); } terrain.Apply(); rivers.Apply(); roads.Apply(); water.Apply(); waterShore.Apply(); }</code> </pre> <br>  Dieses neue Netz verwendet <code>TriangulateWaterShore</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { … waterShore.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); waterShore.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); waterShore.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); waterShore.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { waterShore.AddTriangle( e1.v5, e2.v5, e1.v5 + HexMetrics.GetBridge(direction.Next()) ); } }</code> </pre> <br>  Duplizieren Sie das Wasserobjekt, verbinden Sie es mit dem Fertighaus und stellen Sie es so ein, dass es UV-Koordinaten verwendet.  Wir erstellen auch einen Shader und ein Material für Küstenwasser, wobei der vorhandene Shader und das vorhandene Wassermaterial dupliziert werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/561/77e/e73/56177ee7331ce092a859a058645f0364.png"></div><br>  <i>Wasseruferanlage und UV-Material.</i> <br><br>  Ändern Sie den <em>Water Shore-</em> Shader so, dass anstelle von Wasser UV-Koordinaten angezeigt werden. <br><br><pre> <code class="hljs lisp"> fixed4 c = fixed4(<span class="hljs-name"><span class="hljs-name">IN</span></span>.uv_MainTex, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  Da noch keine Koordinaten festgelegt wurden, wird eine Volltonfarbe angezeigt.  Dank dessen ist leicht zu erkennen, dass die Küste tatsächlich ein separates Netz mit Material verwendet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/630/45c/ec0/63045cec0f1f367bfee191f69cfa11ad.png"></div><br>  <i>Separates Netz für die Küste.</i> <br><br>  Lassen Sie uns die Küsteninformationen in Koordinate V einfügen. Weisen Sie ihr auf der Wasserseite den Wert 0 zu, auf der Landseite den Wert 1. Da wir nichts anderes übertragen müssen, sind alle U-Koordinaten einfach 0. <br><br><pre> <code class="cs hljs"> waterShore.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); waterShore.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); waterShore.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); waterShore.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { waterShore.AddTriangle( e1.v5, e2.v5, e1.v5 + HexMetrics.GetBridge(direction.Next()) ); waterShore.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f4/3fa/f86/8f43faf864c259e21c2ce731d08f43f6.png"></div><br>  <i>Übergänge zu den Küsten sind falsch.</i> <br><br>  Der obige Code funktioniert für Kanten, ist jedoch in einigen Winkeln falsch.  Wenn der nächste Nachbar unter Wasser ist, ist dieser Ansatz korrekt.  Wenn der nächste Nachbar nicht unter Wasser ist, befindet sich der dritte Gipfel des Dreiecks unter Land. <br><br><pre> <code class="cs hljs"> waterShore.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, nextNeighbor.IsUnderwater ? <span class="hljs-number"><span class="hljs-number">0f</span></span> : <span class="hljs-number"><span class="hljs-number">1f</span></span>) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2e/9e9/6e6/c2e9e96e63c161d0f71f81e31742af89.png"></div><br>  <i>Übergänge zu den Küsten sind korrekt.</i> <br><br><h3>  Schaum an der Küste </h3><br>  Nachdem die Übergänge zur Küste korrekt implementiert wurden, können Sie sie verwenden, um einen Schaumeffekt zu erzielen.  Am einfachsten ist es, den Wert der Küste einer einheitlichen Farbe hinzuzufügen. <br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float</span></span> shore = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y; <span class="hljs-type"><span class="hljs-type">float</span></span> foam = shore; fixed4 c = saturate(_Color + foam); o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef5/502/a56/ef5502a56ab665732312be25a6961817.png"></div><br>  <i>Linearer Schaum.</i> <br><br>  Um den Schaum interessanter zu machen, multiplizieren Sie ihn mit dem Quadrat der Sinuskurve. <br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float</span></span> foam = sin(shore * <span class="hljs-number"><span class="hljs-number">10</span></span>); foam *= foam * shore;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2e/acf/6d8/c2eacf6d83e9f7c1298cdd7a05e551d0.png"></div><br>  <i>Verblassender sinusförmiger quadratischer Schaum.</i> <br><br>  Lassen Sie uns die Schaumstofffront größer machen, wenn Sie sich dem Ufer nähern.  Dies kann erreicht werden, indem die Quadratwurzel gezogen wird, bevor der Küstenwert verwendet wird. <br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float</span></span> shore = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y; shore = sqrt(shore);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/762/675/e98/762675e987d119034cd5b643c86ca672.png"></div><br>  <i>Der Schaum wird in Ufernähe dicker.</i> <br><br>  Fügen Sie Verzerrungen hinzu, damit es natürlicher aussieht.  Lassen Sie uns die Verzerrung schwächer machen, wenn wir uns der Küste nähern.  Es wird also besser sein, die Küste zu säumen. <br><br><pre> <code class="hljs pgsql"> float2 noiseUV = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, noiseUV * <span class="hljs-number"><span class="hljs-number">0.015</span></span>); <span class="hljs-type"><span class="hljs-type">float</span></span> distortion = noise.x * (<span class="hljs-number"><span class="hljs-number">1</span></span> - shore); <span class="hljs-type"><span class="hljs-type">float</span></span> foam = sin((shore + distortion) * <span class="hljs-number"><span class="hljs-number">10</span></span>); foam *= foam * shore;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31a/7fd/59a/31a7fd59ad215b200571133543f1406b.png"></div><br>  <i>Schaum mit Verzerrung.</i> <br><br>  Und natürlich animieren wir all dies: sowohl eine Sinuskurve als auch Verzerrungen. <br><br><pre> <code class="hljs pgsql"> float2 noiseUV = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz + _Time.y * <span class="hljs-number"><span class="hljs-number">0.25</span></span>; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, noiseUV * <span class="hljs-number"><span class="hljs-number">0.015</span></span>); <span class="hljs-type"><span class="hljs-type">float</span></span> distortion = noise.x * (<span class="hljs-number"><span class="hljs-number">1</span></span> - shore); <span class="hljs-type"><span class="hljs-type">float</span></span> foam = sin((shore + distortion) * <span class="hljs-number"><span class="hljs-number">10</span></span> - _Time.y); foam *= foam * shore;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Animierter Schaum.</i> <br><br>  Neben dem ankommenden Schaum gibt es auch einen zurückgehenden.  Fügen wir eine zweite Sinuskurve hinzu, die sich in die entgegengesetzte Richtung bewegt, um sie zu simulieren.  Machen Sie es schwächer und fügen Sie eine Zeitverschiebung hinzu.  Fertiger Schaum ist das Maximum dieser beiden Sinuskurven. <br><br><pre> <code class="hljs mel"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distortion1 = <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>.x * (<span class="hljs-number"><span class="hljs-number">1</span></span> - shore); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> foam1 = <span class="hljs-keyword"><span class="hljs-keyword">sin</span></span>((shore + distortion1) * <span class="hljs-number"><span class="hljs-number">10</span></span> - _Time.y); foam1 *= foam1; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distortion2 = <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>.y * (<span class="hljs-number"><span class="hljs-number">1</span></span> - shore); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> foam2 = <span class="hljs-keyword"><span class="hljs-keyword">sin</span></span>((shore + distortion2) * <span class="hljs-number"><span class="hljs-number">10</span></span> + _Time.y + <span class="hljs-number"><span class="hljs-number">2</span></span>); foam2 *= foam2 * <span class="hljs-number"><span class="hljs-number">0.7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> foam = <span class="hljs-keyword"><span class="hljs-keyword">max</span></span>(foam1, foam2) * shore;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Eingehender und zurückgehender Schaum.</i> <br><br><h3>  Mischung aus Wellen und Schaum </h3><br>  Es gibt einen scharfen Übergang zwischen offenem und Küstenwasser, da offene Wasserwellen nicht im Küstenwasser enthalten sind.  Um dies zu beheben, müssen wir diese Wellen in den <em>Water Shore-</em> Shader aufnehmen. <br><br>  Anstatt den Wave-Code zu kopieren, fügen wir ihn in die <em>Water.cginc-</em> Include-Datei ein.  Tatsächlich fügen wir Code sowohl für Schaum als auch für Wellen als separate Funktion ein. <br><br><div class="spoiler">  <b class="spoiler_title">Wie funktionieren Shader-Include-Dateien?</b> <div class="spoiler_text">  Das Erstellen eigener Include-Shader-Dateien wird im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rendering 5-</a> Lernprogramm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Multiple Lights behandelt</a> . </div></div><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> Foam (<span class="hljs-type"><span class="hljs-type">float</span></span> shore, float2 worldXZ, sampler2D noiseTex) { // <span class="hljs-type"><span class="hljs-type">float</span></span> shore = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y; shore = sqrt(shore); float2 noiseUV = worldXZ + _Time.y * <span class="hljs-number"><span class="hljs-number">0.25</span></span>; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(noiseTex, noiseUV * <span class="hljs-number"><span class="hljs-number">0.015</span></span>); <span class="hljs-type"><span class="hljs-type">float</span></span> distortion1 = noise.x * (<span class="hljs-number"><span class="hljs-number">1</span></span> - shore); <span class="hljs-type"><span class="hljs-type">float</span></span> foam1 = sin((shore + distortion1) * <span class="hljs-number"><span class="hljs-number">10</span></span> - _Time.y); foam1 *= foam1; <span class="hljs-type"><span class="hljs-type">float</span></span> distortion2 = noise.y * (<span class="hljs-number"><span class="hljs-number">1</span></span> - shore); <span class="hljs-type"><span class="hljs-type">float</span></span> foam2 = sin((shore + distortion2) * <span class="hljs-number"><span class="hljs-number">10</span></span> + _Time.y + <span class="hljs-number"><span class="hljs-number">2</span></span>); foam2 *= foam2 * <span class="hljs-number"><span class="hljs-number">0.7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> max(foam1, foam2) * shore; } <span class="hljs-type"><span class="hljs-type">float</span></span> Waves (float2 worldXZ, sampler2D noiseTex) { float2 uv1 = worldXZ; uv1.y += _Time.y; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise1 = tex2D(noiseTex, uv1 * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); float2 uv2 = worldXZ; uv2.x += _Time.y; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise2 = tex2D(noiseTex, uv2 * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); <span class="hljs-type"><span class="hljs-type">float</span></span> blendWave = sin( (worldXZ.x + worldXZ.y) * <span class="hljs-number"><span class="hljs-number">0.1</span></span> + (noise1.y + noise2.z) + _Time.y ); blendWave *= blendWave; <span class="hljs-type"><span class="hljs-type">float</span></span> waves = lerp(noise1.z, noise1.w, blendWave) + lerp(noise2.x, noise2.y, blendWave); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> smoothstep(<span class="hljs-number"><span class="hljs-number">0.75</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, waves); }</code> </pre> <br>  Ändern Sie den <em>Water</em> Shader so, dass er die neue Include-Datei verwendet. <br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Water.cginc" sampler2D _MainTex; … <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float</span></span> waves = Waves(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz, _MainTex); fixed4 c = saturate(_Color + waves); o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br>  Im <em>Water Shore</em> Shader werden Werte sowohl für Schaum als auch für Wellen berechnet.  Dann dämpfen wir die Wellen, wenn wir uns dem Ufer nähern.  Das Endergebnis ist ein Maximum an Schaum und Wellen. <br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Water.cginc" sampler2D _MainTex; … <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float</span></span> shore = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y; <span class="hljs-type"><span class="hljs-type">float</span></span> foam = Foam(shore, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz, _MainTex); <span class="hljs-type"><span class="hljs-type">float</span></span> waves = Waves(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz, _MainTex); waves *= <span class="hljs-number"><span class="hljs-number">1</span></span> - shore; fixed4 c = saturate(_Color + max(foam, waves)); o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Eine Mischung aus Schaum und Wellen.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Einheitspaket</a> <br><br><h2>  Wieder über Küstenwasser </h2><br>  Ein Teil des Küstennetzes ist unter dem Reliefnetz versteckt.  Dies ist normal, aber nur ein kleiner Teil ist verborgen.  Leider verbergen steile Klippen den größten Teil des Küstenwassers und schäumen daher. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dea/adf/7e3/deaadf7e3290f93b28ed6177c713bbaa.png"></div><br>  <i>Fast verstecktes Küstenwasser.</i> <br><br>  Wir können damit umgehen, indem wir den Küstenstreifen vergrößern.  Dies kann durch Verringern des Radius der Sechsecke des Wassers erfolgen.  Dazu benötigen wir zusätzlich zum Integritätskoeffizienten einen <code>HexMetrics</code> Wasserkoeffizienten sowie Methoden zur <code>HexMetrics</code> Wasserwinkeln. <br><br>  Der Integritätskoeffizient beträgt 0,8.  Um die Größe der Wasserverbindungen zu verdoppeln, müssen wir den Wasserkoeffizienten auf 0,6 einstellen. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> waterFactor = <span class="hljs-number"><span class="hljs-number">0.6f</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFirstWaterCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] * waterFactor; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSecondWaterCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction + <span class="hljs-number"><span class="hljs-number">1</span></span>] * waterFactor; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden diese neuen Methoden verwenden </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um die Winkel des Wassers zu finden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateOpenWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { Vector3 c1 = center + HexMetrics.GetFirstWaterCorner(direction); Vector3 c2 = center + HexMetrics.GetSecondWaterCorner(direction); … } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( center + HexMetrics.GetFirstWaterCorner(direction), center + HexMetrics.GetSecondWaterCorner(direction) ); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/123/b85/fcf/123b85fcffde7ae313f177f76f882ef5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wasserecken benutzen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Abstand zwischen den Sechsecken des Wassers hat sich tatsächlich verdoppelt. </font><font style="vertical-align: inherit;">Jetzt </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sollte es auch eine Methode zum Erstellen von Brücken im Wasser geben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> waterBlendFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span> - waterFactor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWaterBridge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] + corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction + <span class="hljs-number"><span class="hljs-number">1</span></span>]) * waterBlendFactor; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ändern Sie, </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">damit er die neue Methode verwendet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateOpenWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE &amp;&amp; neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Vector3 bridge = HexMetrics.GetWaterBridge(direction); … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E) { … water.AddTriangle( c2, e2, c2 + HexMetrics.GetWaterBridge(direction.Next()) ); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { … Vector3 bridge = HexMetrics.GetWaterBridge(direction); … HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { waterShore.AddTriangle( e1.v5, e2.v5, e1.v5 + HexMetrics.GetWaterBridge(direction.Next()) ); … } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99b/756/1fa/99b7561fad8556733ea1f10b2dcdd233.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lange Brücken im Wasser.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zwischen den Rippen von Wasser und Land </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl dies uns mehr Platz für Schaum gibt, ist jetzt noch mehr unter dem Relief verborgen. </font><font style="vertical-align: inherit;">Idealerweise können wir eine Wasserrippe auf der Wasserseite und eine Landrippe auf der Landseite verwenden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können keine einfache Brücke benutzen, um den gegenüberliegenden Rand des Landes zu finden, wenn wir von den Ecken des Wassers aus starten. </font><font style="vertical-align: inherit;">Stattdessen können wir vom Zentrum des Nachbarn aus in die entgegengesetzte Richtung gehen. </font><font style="vertical-align: inherit;">Ändern Sie </font></font><code>TriangulateWaterShore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diesen neuen Ansatz.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Vector3 bridge = HexMetrics.GetWaterBridge(direction); Vector3 center2 = neighbor.Position; center2.y = center.y; EdgeVertices e2 = new EdgeVertices( center2 + HexMetrics.GetSecondSolidCorner(direction.Opposite()), center2 + HexMetrics.GetFirstSolidCorner(direction.Opposite()) ); … HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); if (nextNeighbor != null) { Vector3 center3 = nextNeighbor.Position; center3.y = center.y; waterShore.AddTriangle( e1.v5, e2.v5, center3 + HexMetrics.GetFirstSolidCorner(direction.Previous()) ); … }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b29/3f2/01f/b293f201f065b7921f1098484e3b725d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Falsche Kantenecken. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies hat funktioniert, erst jetzt müssen wir wieder zwei Fälle für eckige Dreiecke betrachten.</font></font><br><br><pre> <code class="cs hljs"> HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Vector3 center3 = nextNeighbor.Position; // center3.y = center.y; Vector3 v3 = nextNeighbor.Position + (nextNeighbor.IsUnderwater ? HexMetrics.GetFirstWaterCorner(direction.Previous()) : HexMetrics.GetFirstSolidCorner(direction.Previous())); v3.y = center.y; waterShore.AddTriangle(e1.v5, e2.v5, v3); waterShore.AddTriangleUV( new Vector2(0f, 0f), new Vector2(0f, 1f), new Vector2(0f, nextNeighbor.IsUnderwater ? 0f : 1f) ); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e1/f64/db1/4e1f64db1a34a8e6cff0f402f5fc6bd8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die richtigen Ecken der Kanten. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies hat gut funktioniert, aber jetzt, da der größte Teil des Schaums sichtbar ist, wird er ziemlich ausgeprägt. </font><font style="vertical-align: inherit;">Um dies zu kompensieren, werden wir den Effekt etwas schwächer machen, indem wir die Skala des Küstenwerts im Shader reduzieren.</font></font><br><br><pre> <code class="hljs lisp"> shore = sqrt(<span class="hljs-name"><span class="hljs-name">shore</span></span>) * <span class="hljs-number"><span class="hljs-number">0.9</span></span><span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fertigschaum. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> U-Boot-Flüsse </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben Wasser bekommen, zumindest an den Stellen, an denen keine Flüsse hineinfließen. </font><font style="vertical-align: inherit;">Da sich Wasser und Flüsse noch nicht bemerken, fließen Flüsse durch und unter Wasser.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/051/1ee/bc5/0511eebc5420c9203475b65ce5c478b3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flüsse fließen im Wasser. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Reihenfolge, in der durchscheinende Objekte gerendert werden, hängt von ihrer Entfernung zur Kamera ab. </font><font style="vertical-align: inherit;">Die nächsten Objekte werden zuletzt gerendert, sodass sie sich oben befinden. </font><font style="vertical-align: inherit;">Wenn Sie die Kamera bewegen, bedeutet dies, dass manchmal Flüsse und manchmal Wasser übereinander erscheinen. </font><font style="vertical-align: inherit;">Beginnen wir damit, die Renderreihenfolge konstant zu halten. </font><font style="vertical-align: inherit;">Flüsse müssen über das Wasser gezogen werden, damit die Wasserfälle korrekt angezeigt werden. </font><font style="vertical-align: inherit;">Wir können dies implementieren, indem wir die Warteschlange des </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">River-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shaders ändern </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs objectivec"> Tags { <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> <span class="hljs-string"><span class="hljs-string">"Queue"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent+1"</span></span> }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4bc/74e/d91/4bc74ed9179598f5b9e82c3ff0cde851.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir zeichnen die Flüsse zuletzt.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unterwasserfluss verstecken </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl sich das Flussbett möglicherweise unter Wasser befindet und tatsächlich Wasser durch es fließen kann, sollten wir dieses Wasser nicht sehen. </font><font style="vertical-align: inherit;">Und noch mehr, es sollte nicht auf einer echten Wasseroberfläche gerendert werden. </font><font style="vertical-align: inherit;">Wir können das Wasser von U-Boot-Flüssen loswerden, indem wir nur dann Flusssegmente hinzufügen, wenn sich die aktuelle Zelle nicht unter Wasser befindet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiverBeginOrEnd</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reversed = cell.HasIncomingRiver; … } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reversed = cell.IncomingRiver == direction; … } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beginnen , </font><font style="vertical-align: inherit;">dass ein Segment des Flusses hinzufügen, wenn kein Strom, keine Nachbarzelle nicht unter Wasser ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e2.v3.y = neighbor.StreamBedY; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !neighbor.IsUnderwater) { TriangulateRiverQuad( e1.v2, e1.v4, e2.v2, e2.v4, cell.RiverSurfaceY, neighbor.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction ); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/899/0c7/cf6/8990c7cf6af7bf25596b4ffc05204817.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keine Unterwasserflüsse mehr.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wasserfälle </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt keine Unterwasserflüsse mehr, aber jetzt haben wir Löcher an den Stellen der Flüsse, an denen sie auf die Wasseroberfläche treffen. Flüsse auf gleicher Wasserhöhe bilden kleine Löcher oder Überlagerungen. Am auffälligsten sind jedoch die fehlenden Wasserfälle für Flüsse, die aus größerer Höhe fließen. Kümmern wir uns zuerst um sie. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Flusssegment mit einem Wasserfall, der durch die Wasseroberfläche führte. Infolgedessen befand er sich teilweise über und teilweise unter Wasser. Wir müssen einen Teil über dem Wasserspiegel halten und alles andere wegwerfen. Sie müssen hart dafür arbeiten, also erstellen Sie eine separate Methode. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die neue Methode erfordert vier Gipfel, zwei Flussniveaus und einen Wasserstand. Wir werden es so einstellen, dass wir in Richtung der Strömung den Wasserfall hinunter schauen. Daher befinden sich die ersten beiden Peaks sowie die linke und rechte Seite oben und die unteren folgen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterfallInWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> waterY </span></span></span><span class="hljs-function">)</span></span> { v1.y = v2.y = y1; v3.y = v4.y = y2; rivers.AddQuad(v1, v2, v3, v4); rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden diese Methode aufrufen, </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn ein Nachbar unter Wasser ist und wir einen Wasserfall erstellen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor.IsUnderwater) { TriangulateRiverQuad( e1.v2, e1.v4, e2.v2, e2.v4, cell.RiverSurfaceY, neighbor.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt; neighbor.WaterLevel) { TriangulateWaterfallInWater( e1.v2, e1.v4, e2.v2, e2.v4, cell.RiverSurfaceY, neighbor.RiverSurfaceY, neighbor.WaterSurfaceY ); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir müssen die Wasserfälle auch in die entgegengesetzte Richtung verarbeiten, wenn sich die aktuelle Zelle unter Wasser befindet und die nächste nicht. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !neighbor.IsUnderwater &amp;&amp; neighbor.Elevation &gt; cell.WaterLevel ) { TriangulateWaterfallInWater( e2.v4, e2.v2, e1.v4, e1.v2, neighbor.RiverSurfaceY, cell.RiverSurfaceY, cell.WaterSurfaceY ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also bekommen wir wieder das Quad des ursprünglichen Flusses. </font><font style="vertical-align: inherit;">Als nächstes müssen wir uns ändern </font></font><code>TriangulateWaterfallInWater</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, damit die unteren Spitzen auf den Wasserspiegel angehoben werden. </font><font style="vertical-align: inherit;">Leider reicht es nicht aus, nur die Y-Koordinaten zu ändern. </font><font style="vertical-align: inherit;">Dies kann den Wasserfall von der Klippe schieben, wodurch Löcher entstehen können. </font><font style="vertical-align: inherit;">Stattdessen müssen Sie die unteren Scheitelpunkte durch Interpolation zu den oberen verschieben.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/942/11b/250/94211b250d95b614a5d6be6ff52c9e9e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interpolieren. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die unteren Gipfel nach oben zu bewegen, teilen Sie ihren Abstand unter der Wasseroberfläche durch die Höhe des Wasserfalls. </font><font style="vertical-align: inherit;">Dies gibt uns einen Interpolatorwert.</font></font><br><br><pre> <code class="cs hljs"> v1.y = v2.y = y1; v3.y = v4.y = y2; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = (waterY - y2) / (y1 - y2); v3 = Vector3.Lerp(v3, v1, t); v4 = Vector3.Lerp(v4, v2, t); rivers.AddQuad(v1, v2, v3, v4); rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als Ergebnis erhalten wir einen verkürzten Wasserfall mit der gleichen Ausrichtung. </font><font style="vertical-align: inherit;">Da sich jedoch die Positionen der unteren Scheitelpunkte geändert haben, werden sie nicht wie die ursprünglichen Scheitelpunkte verzerrt. </font><font style="vertical-align: inherit;">Dies bedeutet, dass das Endergebnis immer noch nicht mit dem ursprünglichen Wasserfall übereinstimmt. </font><font style="vertical-align: inherit;">Um dieses Problem zu lösen, müssen wir die Scheitelpunkte vor der Interpolation manuell verzerren und dann das unverzerrte Quad hinzufügen.</font></font><br><br><pre> <code class="cs hljs"> v1.y = v2.y = y1; v3.y = v4.y = y2; v1 = HexMetrics.Perturb(v1); v2 = HexMetrics.Perturb(v2); v3 = HexMetrics.Perturb(v3); v4 = HexMetrics.Perturb(v4); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = (waterY - y2) / (y1 - y2); v3 = Vector3.Lerp(v3, v1, t); v4 = Vector3.Lerp(v4, v2, t); rivers.AddQuadUnperturbed(v1, v2, v3, v4); rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir bereits eine Methode zum Hinzufügen unverzerrter Dreiecke haben, müssen wir für Quads wirklich keine erstellen. </font><font style="vertical-align: inherit;">Deshalb fügen wir die notwendige Methode hinzu </font></font><code>HexMesh.AddQuadUnperturbed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadUnperturbed</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4 </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vertexIndex = vertices.Count; vertices.Add(v1); vertices.Add(v2); vertices.Add(v3); vertices.Add(v4); triangles.Add(vertexIndex); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">2</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">2</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">3</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc4/605/bdd/dc4605bdd24ed9460b0ca3a310a11fb5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wasserfälle enden an der Wasseroberfläche. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flussmündungen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Flüsse auf der gleichen Höhe wie die Wasseroberfläche fließen, berührt das Flussnetz das Küstennetz. Wenn es ein Fluss wäre, der ins Meer oder in den Ozean fließt, dann würde es einen Strom des Flusses mit einer Brandung geben. Deshalb werden wir solche Gebiete Flussmündungen nennen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddd/27b/efa/ddd27befa12ec543e2969505365b0d91.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Fluss trifft auf die Küste, ohne die Gipfel zu verzerren.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt haben wir zwei Probleme mit dem Mund. Erstens verbinden Quad-Flüsse die zweite und vierte Spitze der Rippen und überspringen die dritte. Da die Küste des Wassers nicht den dritten Gipfel nutzt, kann es zu einem Loch oder einer Überlappung kommen. Wir können dieses Problem lösen, indem wir die Geometrie der Münder ändern. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das zweite Problem ist, dass es einen scharfen Übergang zwischen Schaum und Flussmaterialien gibt. Um es zu lösen, brauchen wir ein anderes Material, das die Auswirkungen von Fluss und Wasser vermischt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies bedeutet, dass die Münder einen speziellen Ansatz erfordern. Erstellen wir daher eine separate Methode für sie. Es sollte aufgerufen werden, </font></font><code>TriangulateWaterShore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn sich ein Fluss in die aktuelle Richtung bewegt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { TriangulateEstuary(e1, e2); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { waterShore.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); waterShore.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); waterShore.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); waterShore.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); } … } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEstuary</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EdgeVertices e1, EdgeVertices e2</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Bereich, der beide Effekte mischt, ist nicht erforderlich, um den gesamten Streifen zu füllen. </font><font style="vertical-align: inherit;">Die Trapezform wird für uns ausreichen. </font><font style="vertical-align: inherit;">Daher können wir zwei Küstendreiecke an den Seiten verwenden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEstuary</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EdgeVertices e1, EdgeVertices e2</span></span></span><span class="hljs-function">)</span></span> { waterShore.AddTriangle(e2.v1, e1.v2, e1.v1); waterShore.AddTriangle(e2.v5, e1.v5, e1.v4); waterShore.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); waterShore.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ece/ca1/fc9/ececa1fc9852f7350a54e00fa71df0b3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trapezloch für den Mischbereich.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UV2-Koordinaten </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um einen Flusseffekt zu erzielen, benötigen wir UV-Koordinaten. </font><font style="vertical-align: inherit;">Um einen Schaumeffekt zu erzielen, benötigen Sie jedoch auch UV-Koordinaten. </font><font style="vertical-align: inherit;">Das heißt, wenn wir sie mischen, benötigen wir zwei Sätze von UV-Koordinaten. </font><font style="vertical-align: inherit;">Glücklicherweise können Unity-Engine-Meshes bis zu vier UV-Sets unterstützen. </font><font style="vertical-align: inherit;">Wir müssen nur zur </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterstützung des zweiten Satzes </font><font style="vertical-align: inherit;">hinzufügen </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useCollider, useColors, useUVCoordinates, useUV2Coordinates; [NonSerialized] List&lt;Vector2&gt; uvs, uv2s; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useUVCoordinates) { uvs = ListPool&lt;Vector2&gt;.Get(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useUV2Coordinates) { uv2s = ListPool&lt;Vector2&gt;.Get(); } triangles = ListPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Get(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useUVCoordinates) { hexMesh.SetUVs(<span class="hljs-number"><span class="hljs-number">0</span></span>, uvs); ListPool&lt;Vector2&gt;.Add(uvs); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useUV2Coordinates) { hexMesh.SetUVs(<span class="hljs-number"><span class="hljs-number">1</span></span>, uv2s); ListPool&lt;Vector2&gt;.Add(uv2s); } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um einen zweiten Satz UVs hinzuzufügen, duplizieren wir die Methoden zum Arbeiten mit UV und ändern die Art und Weise, wie wir sie benötigen. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleUV2</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 uv1, Vector2 uv2, Vector3 uv3</span></span></span><span class="hljs-function">)</span></span> { uv2s.Add(uv1); uv2s.Add(uv2); uv2s.Add(uv3); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadUV2</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 uv1, Vector2 uv2, Vector3 uv3, Vector3 uv4</span></span></span><span class="hljs-function">)</span></span> { uv2s.Add(uv1); uv2s.Add(uv2); uv2s.Add(uv3); uv2s.Add(uv4); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadUV2</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uMin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uMax, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vMin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vMax</span></span></span><span class="hljs-function">)</span></span> { uv2s.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMin, vMin)); uv2s.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMax, vMin)); uv2s.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMin, vMax)); uv2s.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMax, vMax)); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> River Shader-Funktion </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir den River-Effekt in zwei Shadern verwenden, verschieben wir den Code vom </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">River-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font><font style="vertical-align: inherit;">in die neue </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Include-Dateifunktion </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> River (float2 riverUV, sampler2D noiseTex) { float2 uv = riverUV; uv.x = uv.x * <span class="hljs-number"><span class="hljs-number">0.0625</span></span> + _Time.y * <span class="hljs-number"><span class="hljs-number">0.005</span></span>; uv.y -= _Time.y * <span class="hljs-number"><span class="hljs-number">0.25</span></span>; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(noiseTex, uv); float2 uv2 = riverUV; uv2.x = uv2.x * <span class="hljs-number"><span class="hljs-number">0.0625</span></span> - _Time.y * <span class="hljs-number"><span class="hljs-number">0.0052</span></span>; uv2.y -= _Time.y * <span class="hljs-number"><span class="hljs-number">0.23</span></span>; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise2 = tex2D(noiseTex, uv2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> noise.x * noise2.w; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ändern Sie den </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">River-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font><font style="vertical-align: inherit;">, um diese neue Funktion zu verwenden.</font></font><br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Water.cginc" sampler2D _MainTex; … <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float</span></span> river = River(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex, _MainTex); fixed4 c = saturate(_Color + river); … }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mundgegenstände </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie einen </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mund hinzu </font><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">um das Netzobjekt </font><font style="vertical-align: inherit;">zu </font><font style="vertical-align: inherit;">stützen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMesh terrain, rivers, roads, water, waterShore, estuaries; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrain.Clear(); rivers.Clear(); roads.Clear(); water.Clear(); waterShore.Clear(); estuaries.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { Triangulate(cells[i]); } terrain.Apply(); rivers.Apply(); roads.Apply(); water.Apply(); waterShore.Apply(); estuaries.Apply(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie einen Shader, ein Material und ein Objekt des Mundes, duplizieren Sie die Küste und ändern Sie sie. </font><font style="vertical-align: inherit;">Verbinden Sie es mit dem Fragment und lassen Sie es die UV- und UV2-Koordinaten verwenden.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/540/77a/7fc/54077a7fc8653228cd723ca855330fed.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objekt Estuarties.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mundtriangulation </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können das Loch- oder Überlappungsproblem lösen, indem wir ein Dreieck zwischen dem Ende des Flusses und der Mitte des Wasserrands platzieren. </font><font style="vertical-align: inherit;">Da unser Mund-Shader ein Duplikat des Coast-Shaders ist, stellen wir die UV-Koordinaten so ein, dass sie dem Schaumeffekt entsprechen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEstuary</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EdgeVertices e1, EdgeVertices e2</span></span></span><span class="hljs-function">)</span></span> { … estuaries.AddTriangle(e1.v3, e2.v2, e2.v4); estuaries.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f02/bb6/f76/f02bb6f768f915d39c05296055cc0b83.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mittleres Dreieck. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können das gesamte Trapez füllen, indem wir auf beiden Seiten des mittleren Dreiecks ein Quad hinzufügen.</font></font><br><br><pre> <code class="cs hljs"> estuaries.AddQuad(e1.v2, e1.v3, e2.v1, e2.v2); estuaries.AddTriangle(e1.v3, e2.v2, e2.v4); estuaries.AddQuad(e1.v3, e1.v4, e2.v4, e2.v5); estuaries.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); estuaries.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); estuaries.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef2/672/e7e/ef2672e7e62b9d66463e4fc44dc43b7a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fertiges Trapez. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drehen wir die Quad-Ausrichtung nach links, so dass sie eine verkürzte diagonale Verbindung hat, und als Ergebnis erhalten wir eine symmetrische Geometrie.</font></font><br><br><pre> <code class="cs hljs"> estuaries.AddQuad(e2.v1, e1.v2, e2.v2, e1.v3); estuaries.AddTriangle(e1.v3, e2.v2, e2.v4); estuaries.AddQuad(e1.v3, e1.v4, e2.v4, e2.v5); estuaries.AddQuadUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); <span class="hljs-comment"><span class="hljs-comment">// estuaries.AddQuadUV(0f, 0f, 0f, 1f);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd5/dd0/7d1/cd5dd07d1b9f1fb8126e6a5a7c1bc29b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gedrehtes Quad, symmetrische Geometrie</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flussfluss </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um den Flusseffekt zu unterstützen, müssen wir UV2-Koordinaten hinzufügen. </font><font style="vertical-align: inherit;">Der Grund des mittleren Dreiecks befindet sich in der Mitte des Flusses, daher sollte seine Koordinate U gleich 0,5 sein. </font><font style="vertical-align: inherit;">Da der Fluss in Richtung des Wassers fließt, erhält der linke Punkt die U-Koordinate gleich 1 und der rechte die U-Koordinate mit einem Wert von 0. Wir setzen die Y-Koordinaten auf 0 und 1, entsprechend der Richtung des Stroms.</font></font><br><br><pre> <code class="cs hljs"> estuaries.AddTriangleUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Vierecke auf beiden Seiten des Dreiecks sollten mit dieser Ausrichtung übereinstimmen. </font><font style="vertical-align: inherit;">Wir behalten die gleichen U-Koordinaten für Punkte bei, die die Breite des Flusses überschreiten.</font></font><br><br><pre> <code class="cs hljs"> estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); estuaries.AddTriangleUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a98/475/d50/a98475d50fe84d16eeeff5397f6aa43f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UV2-Trapez. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um sicherzustellen, dass die UV2-Koordinaten korrekt eingestellt sind, lassen Sie sie vom </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estuary-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font><font style="vertical-align: inherit;">rendern. </font><font style="vertical-align: inherit;">Wir können auf diese Koordinaten zugreifen, indem wir sie zur Eingabestruktur hinzufügen </font></font><code>float2 uv2_MainTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs pgsql"> struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; float2 uv2_MainTex; float3 worldPos; }; … <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float</span></span> shore = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y; <span class="hljs-type"><span class="hljs-type">float</span></span> foam = Foam(shore, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz, _MainTex); <span class="hljs-type"><span class="hljs-type">float</span></span> waves = Waves(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz, _MainTex); waves *= <span class="hljs-number"><span class="hljs-number">1</span></span> - shore; fixed4 c = fixed4(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv2_MainTex, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/efd/416/d95/efd416d95c7827f264f2f0e8360e6fde.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UV2-Koordinaten. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alles sieht gut aus, Sie können einen Shader verwenden, um einen Flusseffekt zu erzeugen.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { … <span class="hljs-type"><span class="hljs-type">float</span></span> river = River(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv2_MainTex, _MainTex); fixed4 c = saturate(_Color + river); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e3/2c9/fda/0e32c9fda58b356534c2070d0b74adae.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden Sie UV2, um einen Flusseffekt zu erzielen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben die Flüsse so erstellt, dass sich beim Triangulieren der Verbindungen zwischen den Zellen die Koordinaten des V-Flusses von 0,8 auf 1 ändern. Daher sollten wir hier auch dieses Intervall verwenden und nicht von 0 auf 1. Die Küstenverbindung ist jedoch 50% höher als bei normalen Zellverbindungen . </font><font style="vertical-align: inherit;">Für eine optimale Anpassung an den Flusslauf müssen wir daher die Werte von 0,8 auf 1,1 ändern.</font></font><br><br><pre> <code class="cs hljs"> estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>) ); estuaries.AddTriangleUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>) ); estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27d/beb/7c6/27dbeb7c67553163422fd560e64ddb03.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b0c/4d9/2e3/b0c4d92e3797274e2534a6921334d184.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Synchronisierter Fluss von Fluss und Mündung.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Durchflusseinstellung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Während sich der Fluss in einer geraden Linie bewegt. </font><font style="vertical-align: inherit;">Wenn Wasser jedoch in ein größeres Gebiet fließt, dehnt es sich aus. </font><font style="vertical-align: inherit;">Der Strom wird sich krümmen. </font><font style="vertical-align: inherit;">Wir können dies simulieren, indem wir die UV2-Koordinaten falten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anstatt die oberen U-Koordinaten außerhalb der Flussbreite konstant zu halten, verschieben Sie sie um 0,5. </font><font style="vertical-align: inherit;">Der Punkt ganz links ist 1,5, der Punkt ganz rechts ist –0,5. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gleichzeitig erweitern wir den Fluss, indem wir die U-Koordinaten des linken und rechten unteren Punkts verschieben. </font><font style="vertical-align: inherit;">Ändern Sie die linke von 1 auf 0,7 und die rechte von 0 auf 0,3.</font></font><br><br><pre> <code class="cs hljs"> estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.7f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>) ); … estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.3f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/850/99d/976/85099d97610434a630621e9e06f885ad.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c1/567/f72/0c1567f72c979734719b298c7850b59e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erweiterung des Flusses. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um den Krümmungseffekt zu vervollständigen, ändern Sie die V-Koordinaten derselben vier Punkte. </font><font style="vertical-align: inherit;">Da das Wasser vom Ende des Flusses wegfließt, erhöhen wir die Koordinaten von V der oberen Punkte auf 1. Um eine bessere Kurve zu erstellen, erhöhen wir die Koordinaten von V der beiden unteren Punkte auf 1,15.</font></font><br><br><pre> <code class="cs hljs"> estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.7f</span></span>, <span class="hljs-number"><span class="hljs-number">1.15f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>) ); estuaries.AddTriangleUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>) ); estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.3f</span></span>, <span class="hljs-number"><span class="hljs-number">1.15f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1fa/86d/320/1fa86d32037da7fab579ce9a195d1e71.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b07/edb/dfe/b07edbdfeb3615b1a597712a6bda5c8e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der geschwungene Flusslauf.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fluss- und Küstenmischung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir müssen nur noch die Auswirkungen von Küste und Fluss mischen. </font><font style="vertical-align: inherit;">Dazu verwenden wir die lineare Interpolation, wobei der Küstenwert als Interpolator verwendet wird.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float</span></span> shoreWater = max(foam, waves); <span class="hljs-type"><span class="hljs-type">float</span></span> river = River(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv2_MainTex, _MainTex); <span class="hljs-type"><span class="hljs-type">float</span></span> water = lerp(shoreWater, river, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.x); fixed4 c = saturate(_Color + water);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl dies funktionieren sollte, wird möglicherweise ein Kompilierungsfehler angezeigt. </font><font style="vertical-align: inherit;">Der Compiler beschwert sich über eine Neudefinition </font></font><code>_MainTex_ST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Der Grund ist ein Fehler im Unity Surface Shader-Compiler, der durch die gleichzeitige Verwendung von </font></font><code>uv_MainTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und verursacht wird </font></font><code>uv2_MainTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir müssen eine Problemumgehung finden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anstatt </font></font><code>uv2_MainTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es zu verwenden, müssen wir die sekundären UV-Koordinaten manuell übertragen. </font><font style="vertical-align: inherit;">Um dies zu tun, umbenennen </font></font><code>uv2_MainTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font></font><code>riverUV</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Fügen Sie dann dem Shader eine Scheitelpunktfunktion hinzu, die ihm Koordinaten zuweist.</font></font><br><br><pre> <code class="hljs pgsql"> #pragma surface surf Standard alpha vertex:vert … struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; float2 riverUV; float3 worldPos; }; … <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> o) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, o); o.riverUV = v.texcoord1.xy; } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { … <span class="hljs-type"><span class="hljs-type">float</span></span> river = River(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.riverUV, _MainTex); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/904/b40/c98/904b40c98323b2e9f32bd16513344181.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interpolation basierend auf dem Küstenwert. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Interpolation funktioniert mit Ausnahme des linken und rechten Scheitelpunkts oben. </font><font style="vertical-align: inherit;">An diesen Stellen sollte der Fluss verschwinden. </font><font style="vertical-align: inherit;">Daher können wir den Wert der Küste nicht verwenden. </font><font style="vertical-align: inherit;">Wir müssen einen anderen Wert verwenden, der an diesen beiden Eckpunkten 0 ist. Glücklicherweise haben wir immer noch die U-Koordinate des ersten UV-Satzes, sodass wir diesen Wert dort speichern können.</font></font><br><br><pre> <code class="cs hljs"> estuaries.AddQuadUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); estuaries.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); estuaries.AddQuadUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); <span class="hljs-comment"><span class="hljs-comment">// estuaries.AddQuadUV(0f, 0f, 0f, 1f);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b34/e93/432/b34e93432248fb7be818b53aca4d8b20.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die richtige Mischung. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt haben die Mündungen eine gute Mischung zwischen dem expandierenden Fluss, dem Küstenwasser und dem Schaum. </font><font style="vertical-align: inherit;">Obwohl dies nicht genau zu Wasserfällen passt, sieht dieser Effekt auch bei Wasserfällen gut aus.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"></font></i> <font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Mündungen </font></a><i><font style="vertical-align: inherit;">in Aktion </font></i></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flüsse fließen aus Gewässern </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben bereits Flüsse, die in Gewässer fließen, aber es gibt keine Unterstützung für Flüsse, die in eine andere Richtung fließen. </font><font style="vertical-align: inherit;">Es gibt Seen, aus denen Flüsse fließen, also müssen wir sie auch hinzufügen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn ein Fluss aus einem Gewässer fließt, fließt er tatsächlich in eine höhere Höhe. </font><font style="vertical-align: inherit;">Dies ist derzeit nicht möglich. </font><font style="vertical-align: inherit;">Wir müssen eine Ausnahme machen und diese Situation zulassen, wenn der Wasserstand der Höhe des Zielpunkts entspricht. </font><font style="vertical-align: inherit;">Fügen wir einer </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">privaten Methode hinzu, die nach unserem neuen Kriterium prüft, ob der Nachbar der richtige Zielpunkt für den abgehenden Fluss ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsValidRiverDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell neighbor</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> neighbor &amp;&amp; ( elevation &gt;= neighbor.elevation || waterLevel == neighbor.elevation ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir werden unsere neue Methode verwenden, um festzustellen, ob es möglich ist, einen abgehenden Fluss zu erzeugen. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetOutgoingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasOutgoingRiver &amp;&amp; outgoingRiver == direction) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } HexCell neighbor = GetNeighbor(direction); <span class="hljs-comment"><span class="hljs-comment">// if (!neighbor || elevation &lt; neighbor.elevation) { if (!IsValidRiverDestination(neighbor)) { return; } RemoveOutgoingRiver(); … }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Außerdem müssen Sie dort den Fluss überprüfen, wenn Sie die Höhe der Zelle oder den Wasserstand ändern. </font><font style="vertical-align: inherit;">Erstellen wir eine private Methode, die diese Aufgabe übernimmt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidateRivers</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( hasOutgoingRiver &amp;&amp; !IsValidRiverDestination(GetNeighbor(outgoingRiver)) ) { RemoveOutgoingRiver(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( hasIncomingRiver &amp;&amp; !GetNeighbor(incomingRiver).IsValidRiverDestination(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) ) { RemoveIncomingRiver(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden diese neue Methode in den Eigenschaften </font></font><code>Elevation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font><font style="vertical-align: inherit;">verwenden </font></font><code>WaterLevel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { … <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { … <span class="hljs-comment"><span class="hljs-comment">// if ( // hasOutgoingRiver &amp;&amp; // elevation &lt; GetNeighbor(outgoingRiver).elevation // ) { // RemoveOutgoingRiver(); // } // if ( // hasIncomingRiver &amp;&amp; // elevation &gt; GetNeighbor(incomingRiver).elevation // ) { // RemoveIncomingRiver(); // } ValidateRivers(); … } } public int WaterLevel { … set { if (waterLevel == value) { return; } waterLevel = value; ValidateRivers(); Refresh(); } }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c04/ca4/b49/c04ca4b49ccff20e71dba70dc1a2bea7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausgehende und eintretende Flussseen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wende das Blatt </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben geschaffen </font></font><code>HexGridChunk.TriangulateEstuary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, was darauf hindeutet, dass Flüsse nur in Gewässer fließen können. </font><font style="vertical-align: inherit;">Daher bewegt sich der Flusslauf immer in eine Richtung. </font><font style="vertical-align: inherit;">Wir müssen den Fluss umkehren, wenn es sich um einen Fluss handelt, der aus einem Gewässer fließt. </font><font style="vertical-align: inherit;">Dazu müssen Sie </font></font><code>TriangulateEstuary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Strömungsrichtung kennen. </font><font style="vertical-align: inherit;">Daher geben wir ihm einen Booleschen Parameter, der bestimmt, ob es sich um einen eingehenden Fluss handelt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEstuary</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, EdgeVertices e2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> incomingRiver </span></span></span><span class="hljs-function">)</span></span> { … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden diese Informationen übergeben, wenn wir diese Methode von aufrufen </font></font><code>TriangulateWaterShore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { TriangulateEstuary(e1, e2, cell.IncomingRiver == direction); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt müssen wir den Flussfluss erweitern, indem wir die Koordinaten von UV2 ändern. </font><font style="vertical-align: inherit;">U-Koordinaten für ausgehende Flüsse müssen gespiegelt werden: –0,5 wird 1,5, 0 wird 1, 1 wird 0 und 1,5 wird –0,5. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit V-Koordinaten sind die Dinge etwas komplizierter. </font><font style="vertical-align: inherit;">Wenn Sie sich ansehen, wie wir mit invertierten Flussverbindungen gearbeitet haben, sollte 0,8 0 und 1 –0,2 sein. </font><font style="vertical-align: inherit;">Dies bedeutet, dass 1,1 zu –0,3 und 1,15 zu –0,35 wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da die UV2-Koordinaten in jedem Fall sehr unterschiedlich sind, schreiben wir einen separaten Code für sie.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEstuary</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, EdgeVertices e2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> incomingRiver </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (incomingRiver) { estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.7f</span></span>, <span class="hljs-number"><span class="hljs-number">1.15f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>) ); estuaries.AddTriangleUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>) ); estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.3f</span></span>, <span class="hljs-number"><span class="hljs-number">1.15f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.2f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.3f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.35f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.3f</span></span>) ); estuaries.AddTriangleUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.3f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.3f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.7f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.35f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.2f</span></span>) ); } }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der richtige Lauf der Flüsse. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil 9: Reliefmerkmale </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fügen Sie dem Relief Objekte hinzu. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir schaffen Unterstützung für die Dichte von Objekten. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir verwenden verschiedene Objekte im Level. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mischen Sie drei verschiedene Arten von Objekten. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Teil werden wir über das Hinzufügen von Objekten zum Gelände sprechen. </font><font style="vertical-align: inherit;">Wir werden Objekte wie Gebäude und Bäume erstellen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b8b/1ec/f84/b8b1ecf8496a03d50c881bbd47c262ad.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konflikt zwischen Wäldern, landwirtschaftlichen Flächen und Urbanisierung.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unterstützung für Objekte hinzufügen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl die Form des Reliefs unterschiedlich ist, passiert bisher nichts darauf. </font><font style="vertical-align: inherit;">Dies ist ein lebloses Land. </font><font style="vertical-align: inherit;">Um ihm Leben einzuhauchen, müssen Sie solche Objekte hinzufügen. </font><font style="vertical-align: inherit;">wie Bäume und Häuser. </font><font style="vertical-align: inherit;">Diese Objekte sind nicht Teil des Reliefnetzes, sondern separate Objekte. </font><font style="vertical-align: inherit;">Dies hindert uns jedoch nicht daran, sie beim Triangulieren des Geländes hinzuzufügen. </font></font><br><br> <code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist mir egal, wie das Netz funktioniert. </font><font style="vertical-align: inherit;">Er befiehlt einfach einem seiner Kinder, </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein Dreieck oder Quad hinzuzufügen. </font><font style="vertical-align: inherit;">Ebenso kann es ein untergeordnetes Element geben, das sich mit der Platzierung von Objekten auf ihnen befasst.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objektmanager </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen wir eine Komponente </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die sich um Objekte innerhalb eines einzelnen Fragments kümmert. </font><font style="vertical-align: inherit;">Wir verwenden das gleiche Schema wie in </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- geben Sie ihm Methoden </font></font><code>Clear</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>Apply</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Da das Objekt irgendwo platziert werden muss, </font></font><code>AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">empfängt die </font><font style="vertical-align: inherit;">Methode </font><font style="vertical-align: inherit;">den Positionsparameter. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden mit einer leeren Implementierung beginnen, die vorerst nichts bewirken wird.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexFeatureManager</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> {} }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir einen Link zu einer solchen Komponente in hinzufügen </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dann können Sie es wie alle untergeordneten Elemente in den Triangulationsprozess einbeziehen </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexFeatureManager features; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrain.Clear(); rivers.Clear(); roads.Clear(); water.Clear(); waterShore.Clear(); estuaries.Clear(); features.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { Triangulate(cells[i]); } terrain.Apply(); rivers.Apply(); roads.Apply(); water.Apply(); waterShore.Apply(); estuaries.Apply(); features.Apply(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beginnen wir mit der Platzierung eines Objekts in der Mitte jeder Zelle </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { Triangulate(d, cell); } features.AddFeature(cell.Position); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt brauchen wir einen echten Objektmanager. </font><font style="vertical-align: inherit;">Fügen Sie </font><font style="vertical-align: inherit;">dem </font><font style="vertical-align: inherit;">Fertighaus </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid Chunk ein</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> weiteres Kind </font><font style="vertical-align: inherit;">hinzu </font><font style="vertical-align: inherit;">und geben Sie ihm eine Komponente </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dann können Sie ein Fragment damit verbinden.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eeb/1f4/626/eeb1f462652650c6dfe5e3cb34a2ec12.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51b/7ec/8f2/51b7ec8f20b4a79589fd2b464744230b.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/620/c6f/8cd/620c6f8cd7c54c52597fcc289b160c57.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Objektmanager, der dem Fragment-Fertighaus hinzugefügt wurde.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fertighäuser </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Welches Geländeobjekt werden wir erstellen? </font><font style="vertical-align: inherit;">Für den ersten Test ist ein Würfel gut geeignet. </font><font style="vertical-align: inherit;">Erstellen wir beispielsweise einen ausreichend großen Würfel mit einer Skala von (3, 3, 3) und verwandeln ihn in ein Fertighaus. </font><font style="vertical-align: inherit;">Erstellen Sie auch Material für ihn. </font><font style="vertical-align: inherit;">Ich habe das Standardmaterial mit Rot verwendet. </font><font style="vertical-align: inherit;">Entfernen wir den Collider, weil wir ihn nicht brauchen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7a/1b1/315/a7a1b1315e7f2756ac2940dac661f95a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fertigwürfel. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objektmanager benötigen einen Link zu diesem Fertighaus. Fügen Sie ihn hinzu </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und verbinden Sie sie. </font><font style="vertical-align: inherit;">Da zum Platzieren des Objekts Zugriff auf die Transformationskomponente erforderlich ist, verwenden wir es als Verknüpfungstyp.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform featurePrefab;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cfc/34d/e84/cfc34de84fbc12ac5fde17d7d1d09b58.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objektmanager mit Fertighaus.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objektinstanzen erstellen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Struktur ist fertig und wir können mit dem Hinzufügen von Geländemerkmalen beginnen! </font><font style="vertical-align: inherit;">Erstellen Sie einfach eine Instanz des Fertighauses </font></font><code>HexFeatureManager.AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und legen Sie dessen Position fest.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Transform instance = Instantiate(featurePrefab); instance.localPosition = position; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dd8/59c/ae5/dd859cae56fa9439e91d0ccb5d659f62.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instanzen von Geländemerkmalen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Von nun an wird das Gelände mit Würfeln gefüllt. </font><font style="vertical-align: inherit;">Zumindest die oberen Hälften der Würfel, da der lokale Ursprung für das Würfelnetz in Unity in der Mitte des Würfels liegt und der Boden unter der Oberfläche des Reliefs liegt. </font><font style="vertical-align: inherit;">Um Würfel auf der Topographie zu platzieren, müssen wir sie um die Hälfte ihrer Höhe nach oben bewegen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Transform instance = Instantiate(featurePrefab); position.y += instance.localScale.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.localPosition = position; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb0/6be/89b/bb06be89b647d5ff29f1894bfdcf199b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Würfel auf der Oberfläche des Reliefs.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist, wenn wir ein anderes Netz verwenden?</font></font></b> <div class="spoiler_text">       .     ,      ,        .       . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Natürlich sind unsere Zellen verzerrt, daher müssen wir die Position von Objekten verzerren. </font><font style="vertical-align: inherit;">So werden wir die perfekte Wiederholbarkeit des Netzes los.</font></font><br><br><pre> <code class="cs hljs"> instance.localPosition = HexMetrics.Perturb(position);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e5/7ec/a43/9e57eca43cf9127691cb5eb11bc6a11a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verzerrte Positionen von Objekten.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zerstörung von Hilfsgegenständen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jedes Mal, wenn ein Fragment aktualisiert wird, erstellen wir neue Reliefobjekte. </font><font style="vertical-align: inherit;">Dies bedeutet, dass wir immer mehr Objekte an denselben Positionen erstellen. </font><font style="vertical-align: inherit;">Um Duplikate zu vermeiden, müssen wir beim Reinigen eines Fragments alte Objekte entfernen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der schnellste Weg, dies zu tun, besteht darin, ein Spielcontainerobjekt zu erstellen und alle Reliefobjekte in seine untergeordneten Objekte umzuwandeln. </font><font style="vertical-align: inherit;">Wenn </font></font><code>Clear</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">dann aufgerufen werden, </font><font style="vertical-align: inherit;">zerstören wir diesen Container und erstellen einen neuen. </font><font style="vertical-align: inherit;">Der Container selbst ist ein Kind seines Managers.</font></font><br><br><pre> <code class="cs hljs"> Transform container; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (container) { Destroy(container.gameObject); } container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameObject(<span class="hljs-string"><span class="hljs-string">"Features Container"</span></span>).transform; container.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Transform instance = Instantiate(featurePrefab); position.y += instance.localScale.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.localPosition = HexMetrics.Perturb(position); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wahrscheinlich ist es ineffizient, jedes Mal Reliefobjekte zu erstellen und zu zerstören.</font></font></b> <div class="spoiler_text"> , ,   .       .      .   ,  ,      ,    .          <code>HexFeatureManager.Apply</code> .      .  ,    ,       . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Platzierung von Reliefobjekten </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Während wir Objekte in der Mitte jeder Zelle platzieren. </font><font style="vertical-align: inherit;">Für leere Zellen sieht dies normal aus, aber für Zellen, die Flüsse und Straßen enthalten und mit Wasser überflutet sind, scheint es seltsam.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/01d/e88/ab8/01de88ab8777d38afeb4ca374571a2f1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objekte sind überall. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Überprüfen Sie daher vor dem Platzieren des Objekts, </font></font><code>HexGridChunk.Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ob die Zelle leer ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !cell.HasRiver &amp;&amp; !cell.HasRoads) { features.AddFeature(cell.Position); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5db/b98/75f/5dbb9875f8510c7f9224f8ba10465ae4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Begrenzte Unterkunft.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ein Objekt pro Richtung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nur ein Objekt pro Zelle ist nicht zu viel. </font><font style="vertical-align: inherit;">Es gibt immer noch viel Platz für ein paar Gegenstände. </font><font style="vertical-align: inherit;">Daher fügen wir der Mitte jedes der sechs Dreiecke der Zelle ein zusätzliches Objekt hinzu, dh eines pro Richtung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden dies auf eine andere Weise tun </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wenn wir wissen, dass sich kein Fluss in der Zelle befindet. </font><font style="vertical-align: inherit;">Wir müssen noch überprüfen, ob wir unter Wasser sind und ob sich eine Straße in der Zelle befindet. </font><font style="vertical-align: inherit;">In diesem Fall interessieren wir uns jedoch nur für Straßen, die in die aktuelle Richtung verlaufen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiver) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateWithoutRiver(direction, cell, center, e); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !cell.HasRoadThroughEdge(direction)) { features.AddFeature((center + e.v1 + e.v5) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>)); } } … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e7/b60/d4b/7e7b60d4b54d2f9a7b3119e78554507a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Viele Einrichtungen, aber nicht in der Nähe von Flüssen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dadurch entstehen viel mehr Objekte! </font><font style="vertical-align: inherit;">Sie erscheinen in der Nähe der Straßen, meiden aber dennoch die Flüsse. </font><font style="vertical-align: inherit;">Um Objekte entlang von Flüssen zu platzieren, können wir sie auch hinzufügen </font></font><code>TriangulateAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Aber wieder nur, wenn das Dreieck nicht unter Wasser ist und keine Straße darauf ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !cell.HasRoadThroughEdge(direction)) { features.AddFeature((center + e.v1 + e.v5) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>)); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30c/90a/f9f/30c90af9ffb31cec360ea027fc4f1815.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objekte tauchten neben den Flüssen auf.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ist es möglich, so viele Objekte zu rendern?</font></font></b> <div class="spoiler_text">       ,    dynamic batching  Unity.    ,       .         batch.     « »,       .    instancing,          dynamic batching. </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vielzahl von Objekten </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle unsere Reliefobjekte haben die gleiche Ausrichtung, was völlig unnatürlich aussieht. </font><font style="vertical-align: inherit;">Lassen Sie uns jedem eine zufällige Wendung geben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Transform instance = Instantiate(featurePrefab); position.y += instance.localScale.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.localPosition = HexMetrics.Perturb(position); instance.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span> * Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b42/8bd/0bc/b428bd0bcb9b27676853f7bb1e491165.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zufällige Drehungen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Ergebnis wird also viel vielfältiger. </font><font style="vertical-align: inherit;">Leider erhalten Objekte jedes Mal, wenn ein Fragment aktualisiert wird, eine neue zufällige Drehung. </font><font style="vertical-align: inherit;">Das Bearbeiten von Zellen sollte keine Objekte in der Nachbarschaft ändern, daher benötigen wir einen anderen Ansatz. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben eine Rauschstruktur, die immer gleich ist. </font><font style="vertical-align: inherit;">Diese Textur enthält jedoch Perlin-Gradientenrauschen und ist lokal konsistent. </font><font style="vertical-align: inherit;">Dies ist genau das, was wir brauchen, wenn wir die Positionen von Eckpunkten in Zellen verzerren. </font><font style="vertical-align: inherit;">Aber die Kurven müssen nicht konsistent sein. </font><font style="vertical-align: inherit;">Alle Windungen sollten gleich wahrscheinlich und gemischt sein. </font><font style="vertical-align: inherit;">Daher benötigen wir eine Textur mit zufälligen Werten ohne Gradienten, die ohne bilineare Filterung abgetastet werden können. </font><font style="vertical-align: inherit;">Im Wesentlichen handelt es sich hierbei um ein Hash-Gitter, das die Grundlage für Gradientenrauschen bildet.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erstellen einer Hash-Tabelle </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können eine Hash-Tabelle aus einem Array von Float-Werten erstellen und sie einmal mit zufälligen Werten füllen. </font><font style="vertical-align: inherit;">Dank dessen brauchen wir überhaupt keine Textur. </font><font style="vertical-align: inherit;">Fügen wir es hinzu </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Eine Größe von 256 x 256 reicht für eine ausreichende Variation aus.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hashGridSize = <span class="hljs-number"><span class="hljs-number">256</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] hashGrid; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeHashGrid</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hashGrid = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[hashGridSize * hashGridSize]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; hashGrid.Length; i++) { hashGrid[i] = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zufallswerte werden durch eine mathematische Formel generiert, die immer die gleichen Ergebnisse liefert. </font><font style="vertical-align: inherit;">Die resultierende Sequenz hängt von der Anzahl der Seeds ab, die standardmäßig dem aktuellen Zeitwert entspricht. </font><font style="vertical-align: inherit;">Deshalb erhalten wir in jeder Spielsitzung unterschiedliche Ergebnisse. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um sicherzustellen, dass immer identische Objekte neu erstellt werden, müssen wir den Startparameter zur Initialisierungsmethode hinzufügen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeHashGrid</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> seed</span></span></span><span class="hljs-function">)</span></span> { hashGrid = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[hashGridSize * hashGridSize]; Random.InitState(seed); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; hashGrid.Length; i++) { hashGrid[i] = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir den Zufallszahlenstrom initialisiert haben, erhalten wir immer die gleiche Reihenfolge. </font><font style="vertical-align: inherit;">Daher sind scheinbar zufällige Ereignisse, die nach der Erstellung der Karte auftreten, auch immer gleich. </font><font style="vertical-align: inherit;">Wir können dies vermeiden, indem wir den Status des Zufallszahlengenerators speichern, bevor wir ihn initialisieren. </font><font style="vertical-align: inherit;">Nach Abschluss der Arbeiten können wir ihn nach dem alten Zustand fragen.</font></font><br><br><pre> <code class="cs hljs"> Random.State currentState = Random.state; Random.InitState(seed); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; hashGrid.Length; i++) { hashGrid[i] = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } Random.state = currentState;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Hash-Tabelle wird </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gleichzeitig mit der Zuweisung der Rauschtextur </font><font style="vertical-align: inherit;">initialisiert </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Das heißt, in den Methoden </font></font><code>HexGrid.Start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>HexGrid.Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir machen es so, dass die Werte nicht öfter als nötig generiert werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> seed; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); … } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HexMetrics.noiseSource) { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit der generischen Startvariablen können wir den Startwert für die Karte auswählen. </font><font style="vertical-align: inherit;">Jeder Wert reicht aus. </font><font style="vertical-align: inherit;">Ich habe 1234 gewählt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/60c/8b3/5a3/60c8b35a3b6a92b61165ed3a00473076.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Wahl des Samens.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verwenden einer Hash-Tabelle </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie der </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stichprobenmethode </font><font style="vertical-align: inherit;">hinzu, um die Hash-Tabelle zu </font><font style="vertical-align: inherit;">verwenden. </font><font style="vertical-align: inherit;">Ebenso </font></font><code>SampleNoise</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden die Koordinaten der XZ-Position verwendet, um den Wert zu erhalten. </font><font style="vertical-align: inherit;">Der Hash-Index wird ermittelt, indem die Koordinaten auf ganzzahlige Werte beschränkt werden und dann der Rest der ganzzahligen Division durch die Größe der Tabelle ermittelt wird.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleHashGrid</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)position.x % hashGridSize; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)position.z % hashGridSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hashGrid[x + z * hashGridSize]; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was macht %?</font></font></b> <div class="spoiler_text">   ,     ,    —  . ,  −4, −3, −2, −1, 0, 1, 2, 3, 4 modulo 3   −1, 0, −2, −1, 0, 1, 2, 0, 1. </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies funktioniert für positive Koordinaten, aber nicht für negative, da für solche Zahlen der Rest negativ ist. </font><font style="vertical-align: inherit;">Wir können dies beheben, indem wir die Größe der Tabelle zu den negativen Ergebnissen hinzufügen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)position.x % hashGridSize; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { x += hashGridSize; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)position.z % hashGridSize; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { z += hashGridSize; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt schaffen wir für jede quadratische Einheit unseren eigenen Wert. </font><font style="vertical-align: inherit;">Tatsächlich benötigen wir jedoch keine solche Tabellendichte. </font><font style="vertical-align: inherit;">Objekte sind voneinander beabstandet. </font><font style="vertical-align: inherit;">Wir können die Tabelle dehnen, indem wir die Positionsskala reduzieren, bevor wir den Index berechnen. </font><font style="vertical-align: inherit;">Ein eindeutiger Wert für ein 4 x 4-Quadrat reicht für uns aus.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> hashGridScale = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleHashGrid</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(position.x * hashGridScale) % hashGridSize; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { x += hashGridSize; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(position.z * hashGridScale) % hashGridSize; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { z += hashGridSize; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hashGrid[x + z * hashGridSize]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gehen wir zurück zu </font></font><code>HexFeatureManager.AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und verwenden Sie unsere neue Hash-Tabelle, um den Wert zu erhalten. </font><font style="vertical-align: inherit;">Nachdem wir es angewendet haben, um die Drehung festzulegen, bleiben die Objekte beim Bearbeiten des Geländes stationär.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> hash = HexMetrics.SampleHashGrid(position); Transform instance = Instantiate(featurePrefab); position.y += instance.localScale.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.localPosition = HexMetrics.Perturb(position); instance.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span> * hash, <span class="hljs-number"><span class="hljs-number">0f</span></span>); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Platzierungsschwelle </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl Objekte unterschiedliche Rotationen haben, ist ein Muster in ihrer Platzierung immer noch erkennbar. </font><font style="vertical-align: inherit;">Jede Zelle hat sieben Objekte. </font><font style="vertical-align: inherit;">Wir können diesem Schema Chaos hinzufügen und einige der Objekte willkürlich überspringen. </font><font style="vertical-align: inherit;">Wie entscheiden wir, ob wir ein Objekt hinzufügen oder nicht? </font><font style="vertical-align: inherit;">Natürlich einen anderen zufälligen Wert auschecken! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das heißt, anstelle eines Hashwerts benötigen wir zwei. </font><font style="vertical-align: inherit;">Ihre Unterstützung kann durch Verwendung von Hashes anstelle einer </font></font><code>float</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variablen </font><font style="vertical-align: inherit;">als Tabellenarraytyp hinzugefügt werden </font></font><code>Vector2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Da Vektoroperationen für Hash-Werte jedoch keinen Sinn ergeben, erstellen wir zu diesem Zweck eine spezielle Struktur. </font><font style="vertical-align: inherit;">Sie benötigt nur zwei Float-Werte. </font><font style="vertical-align: inherit;">Fügen wir eine statische Methode hinzu, um ein Paar zufälliger Werte zu erstellen.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> HexHash { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a, b; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexHash </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexHash hash; hash.a = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; hash.b = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash; } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muss es nicht serialisiert werden?</font></font></b> <div class="spoiler_text">        ,  ,        Unity. ,     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ändern Sie es </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so, dass es die neue Struktur verwendet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> HexHash[] hashGrid; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeHashGrid</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> seed</span></span></span><span class="hljs-function">)</span></span> { hashGrid = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexHash[hashGridSize * hashGridSize]; Random.State currentState = Random.state; Random.InitState(seed); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; hashGrid.Length; i++) { hashGrid[i] = HexHash.Create(); } Random.state = currentState; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexHash </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleHashGrid</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hat jetzt </font></font><code>HexFeatureManager.AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zugriff auf zwei Hashwerte. </font><font style="vertical-align: inherit;">Lassen Sie uns zunächst entscheiden, ob ein Objekt hinzugefügt oder übersprungen werden soll. </font><font style="vertical-align: inherit;">Wenn der Wert gleich oder größer als 0,5 ist, überspringen Sie. </font><font style="vertical-align: inherit;">Auf diese Weise werden wir etwa die Hälfte der Objekte entfernen. </font><font style="vertical-align: inherit;">Der zweite Wert wird wie gewohnt zur Bestimmung der Drehung verwendet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { HexHash hash = HexMetrics.SampleHashGrid(position); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hash.a &gt;= <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Transform instance = Instantiate(featurePrefab); position.y += instance.localScale.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.localPosition = HexMetrics.Perturb(position); instance.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span> * hash.b, <span class="hljs-number"><span class="hljs-number">0f</span></span>); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e89/e69/761/e89e697613f8eef3d149b07720e8a26a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Dichte von Objekten wird um 50% reduziert. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objekte zeichnen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anstatt Objekte überall zu platzieren, können Sie sie bearbeitbar machen. </font><font style="vertical-align: inherit;">Wir werden jedoch keine separaten Objekte zeichnen, sondern jeder Zelle die Objektebene hinzufügen. </font><font style="vertical-align: inherit;">Diese Stufe steuert die Wahrscheinlichkeit, dass Objekte in der Zelle erscheinen. </font><font style="vertical-align: inherit;">Standardmäßig ist der Wert Null, dh Objekte fehlen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da rote Würfel in unserem Gelände nicht wie natürliche Objekte aussehen, nennen wir sie Gebäude. </font><font style="vertical-align: inherit;">Sie werden die Urbanisierung darstellen. </font><font style="vertical-align: inherit;">Fügen wir den </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grad der Urbanisierung hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> UrbanLevel { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> urbanLevel; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (urbanLevel != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { urbanLevel = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; RefreshSelfOnly(); } } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> urbanLevel;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können den Urbanisierungsgrad für eine Unterwasserzelle auf Null setzen, aber das ist nicht notwendig, wir überspringen trotzdem die Erstellung von Unterwasserobjekten. </font><font style="vertical-align: inherit;">Und vielleicht werden wir irgendwann Gewässer der Urbanisierung hinzufügen, wie Docks und Unterwasserstrukturen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dichteschieberegler </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um den Grad der Urbanisierung zu ändern, fügen wir </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einen weiteren Schieberegler </font><font style="vertical-align: inherit;">zur </font><font style="vertical-align: inherit;">Unterstützung hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> activeUrbanLevel; … <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> applyUrbanLevel; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetApplyUrbanLevel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { applyUrbanLevel = toggle; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetUrbanLevel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level</span></span></span><span class="hljs-function">)</span></span> { activeUrbanLevel = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)level; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyWaterLevel) { cell.WaterLevel = activeWaterLevel; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyUrbanLevel) { cell.UrbanLevel = activeUrbanLevel; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (riverMode == OptionalToggle.No) { cell.RemoveRiver(); } … } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie der Benutzeroberfläche einen weiteren Schieberegler hinzu und kombinieren Sie ihn mit den entsprechenden Methoden. </font><font style="vertical-align: inherit;">Ich werde ein neues Feld auf der rechten Seite des Bildschirms platzieren, um ein Überlaufen des linken Feldes zu vermeiden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie viele Level brauchen wir? </font><font style="vertical-align: inherit;">Lassen Sie uns bei vier verweilen und Null, niedrige, mittlere und hohe Dichte bezeichnen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02f/e64/996/02fe649968954603df834d2a3b5f633b.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95e/9e4/6f5/95e9e46f5ff83a9b7d713e85db86d67a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Urbanisierungsregler.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schwellenwertänderung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt, da wir den Grad der Urbanisierung haben, müssen wir ihn verwenden, um zu bestimmen, ob Objekte platziert werden sollen. </font><font style="vertical-align: inherit;">Dazu müssen wir den Urbanisierungsgrad als zusätzlichen Parameter hinzufügen </font></font><code>HexFeatureManager.AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Machen wir noch einen Schritt und übertragen einfach die Zelle selbst. </font><font style="vertical-align: inherit;">In Zukunft wird es für uns bequemer sein. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der schnellste Weg, den Urbanisierungsgrad zu verwenden, besteht darin, ihn mit 0,25 zu multiplizieren und den Wert als neuen Schwellenwert für das Überspringen von Objekten zu verwenden. </font><font style="vertical-align: inherit;">Aus diesem Grund erhöht sich die Wahrscheinlichkeit des Auftretens des Objekts mit jedem Level um 25%.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, Vector3 position</span></span></span><span class="hljs-function">)</span></span> { HexHash hash = HexMetrics.SampleHashGrid(position); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hash.a &gt;= cell.UrbanLevel * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit dies funktioniert, übergeben wir die Zellen an </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !cell.HasRiver &amp;&amp; !cell.HasRoads) { features.AddFeature(cell, cell.Position); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !cell.HasRoadThroughEdge(direction)) { features.AddFeature(cell, (center + e.v1 + e.v5) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>)); } … } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !cell.HasRoadThroughEdge(direction)) { features.AddFeature(cell, (center + e.v1 + e.v5) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>)); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd8/7e9/de5/fd87e9de5b6b6ea4b4b490549ae5cbf5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeichnen der Urbanisierungsdichte. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mehrere Fertighäuser von Reliefobjekten </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterschiede in der Wahrscheinlichkeit des Auftretens von Objekten reichen nicht aus, um eine klare Trennung zwischen niedrigem und hohem Urbanisierungsgrad zu erreichen. In einigen Zellen wird es einfach mehr oder weniger als die erwartete Anzahl von Gebäuden geben. Wir können den Unterschied klarer machen, indem wir für jedes Level unser eigenes Fertighaus verwenden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden das Feld </font></font><code>featurePrefab</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font><font style="vertical-align: inherit;">loswerden </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und es durch ein Array für Fertighäuser der Urbanisierung ersetzen. Um das passende Fertighaus zu erhalten, subtrahieren wir eines vom Urbanisierungsgrad und verwenden den Wert als Index.</font></font><br><br><pre> <code class="cs hljs">&lt;del&gt;<span class="hljs-comment"><span class="hljs-comment">// public Transform featurePrefab;&lt;/del&gt; public Transform[] urbanPrefabs; public void AddFeature (HexCell cell, Vector3 position) { … Transform instance = Instantiate(urbanPrefabs[cell.UrbanLevel - 1]); … }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie zwei Duplikate des Fertighauses des Objekts, benennen Sie es um und ändern Sie es so, dass es drei verschiedene Urbanisierungsebenen anzeigt. </font><font style="vertical-align: inherit;">Stufe 1 ist eine niedrige Dichte, daher verwenden wir einen Würfel mit einer Einheitslänge einer Kante, der eine Hütte bezeichnet. </font><font style="vertical-align: inherit;">Ich werde das Fertighaus der Ebene 2 auf (1,5, 2, 1,5) skalieren, damit es wie ein zweistöckiges Gebäude aussieht. </font><font style="vertical-align: inherit;">Für hohe Gebäude der Stufe 3 habe ich die Skala (2, 5, 2) verwendet.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b83/4ad/cb6/b834adcb61a34d1e30cdec28925f066f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d4f/41d/552/d4f41d5529d4716924345520ffc36280.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwendung unterschiedlicher Fertighäuser für jede Urbanisierungsstufe.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fertigmischung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir sind nicht verpflichtet, uns auf eine strikte Trennung der Gebäudetypen zu beschränken. Sie können sie ein wenig mischen, wie es in der realen Welt passiert. Verwenden Sie anstelle eines Schwellenwerts pro Ebene drei, einen für jeden Gebäudetyp. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf Stufe 1 verwenden wir in 40% der Fälle die Platzierung von Hütten. Es wird hier überhaupt keine anderen Gebäude geben. Für die Ebene verwenden wir die drei Werte (0,4, 0, 0). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ersetzen Sie auf Stufe 2 die Hütten durch größere Gebäude und erhöhen Sie die Wahrscheinlichkeit für zusätzliche Hütten um 20%. Wir werden keine hohen Gebäude bauen. Das heißt, wir verwenden den Schwellenwert drei Werte (0,2, 0,4, 0). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf Stufe 3 ersetzen wir mittlere Gebäude durch hohe, ersetzen erneut Hütten und erhöhen die Wahrscheinlichkeit von Hütten um weitere 20%. Die Schwellenwerte sind gleich (0,2, 0,2, 0,4).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das heißt, die Idee ist, dass wir mit zunehmendem Urbanisierungsgrad bestehende Gebäude aufwerten und leere Orte um neue erweitern werden. Um ein vorhandenes Gebäude zu entfernen, müssen dieselben Hashwertintervalle verwendet werden. Wenn die Hashes zwischen 0 und 0,4 auf Ebene 1 Hütten waren, werden auf Ebene 3 im gleichen Intervall hohe Gebäude erstellt. Auf Stufe 3 sollten hohe Gebäude mit Hashes im Bereich von 0 bis 0,4, zweistöckigen Gebäuden im Bereich von 0,4 bis 0,6 und Hütten im Bereich von 0,6 bis 0,8 erstellt werden. Wenn Sie sie vom größten zum kleinsten prüfen, kann dies mit dem Dreifach der Schwellenwerte (0,4, 0,6, 0,8) erfolgen. Die Schwellenwerte der Stufe 2 werden dann (0, 0,4, 0,6) und die Schwellenwerte der Stufe 1 werden (0, 0, 0,4). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speichern wir diese Schwellenwerte in</font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">als Sammlung von Arrays mit einer Methode, mit der Sie Schwellenwerte für eine bestimmte Ebene abrufen können. </font><font style="vertical-align: inherit;">Da wir nur an Ebenen mit Objekten interessiert sind, ignorieren wir Ebene 0.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[][] featureThresholds = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] {<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>}, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] {<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>}, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] {<span class="hljs-number"><span class="hljs-number">0.4f</span></span>, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>} }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFeatureThresholds</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> featureThresholds[level]; }</code> </pre> <br><font style="vertical-align: inherit;"></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie als </font><font style="vertical-align: inherit;">Nächstes der </font><font style="vertical-align: inherit;">Methode hinzu, die die Hash-Ebene und den Wert verwendet, um das Fertighaus auszuwählen. </font><font style="vertical-align: inherit;">Wenn der Pegel größer als Null ist, erhalten wir Schwellenwerte mit einem um eins reduzierten Pegel. </font><font style="vertical-align: inherit;">Dann durchlaufen wir die Schwellenwerte, bis einer von ihnen den Hashwert überschreitet. </font><font style="vertical-align: inherit;">Dies bedeutet, dass wir ein Fertighaus gefunden haben. </font><font style="vertical-align: inherit;">Wenn wir nicht finden, geben Sie null zurück.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Transform </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PickPrefab</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hash</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (level &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] thresholds = HexMetrics.GetFeatureThresholds(level - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; thresholds.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hash &lt; thresholds[i]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> urbanPrefabs[i]; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dieser Ansatz erfordert die Neuordnung von Links zu Fertighäusern, sodass diese von hoher zu niedriger Dichte wechseln. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4dc/eb5/80e/4dceb580e2410400a003b2ecad72d5c5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Invertierte Fertighausreihenfolge. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden unsere neue Methode verwenden </font></font><code>AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um ein Fertighaus auszuwählen. </font><font style="vertical-align: inherit;">Wenn wir es nicht erhalten, überspringen wir das Objekt. </font><font style="vertical-align: inherit;">Andernfalls erstellen Sie eine Instanz davon und fahren Sie wie zuvor fort.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, Vector3 position</span></span></span><span class="hljs-function">)</span></span> { HexHash hash = HexMetrics.SampleHashGrid(position); <span class="hljs-comment"><span class="hljs-comment">// if (hash.a &gt;= cell.UrbanLevel * 0.25f) { // return; // } // Transform instance = Instantiate(urbanPrefabs[cell.UrbanLevel - 1]); Transform prefab = PickPrefab(cell.UrbanLevel, hash.a); if (!prefab) { return; } Transform instance = Instantiate(prefab); position.y += instance.localScale.y * 0.5f; instance.localPosition = HexMetrics.Perturb(position); instance.localRotation = Quaternion.Euler(0f, 360f * hash.b, 0f); instance.SetParent(container, false); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d33/6f0/fcb/d336f0fcbf85285b38bb9c3de27ad77f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mischen Sie die Fertighäuser.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pegelschwankungen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt haben wir gut gemischte Gebäude, aber bisher gibt es nur drei. </font><font style="vertical-align: inherit;">Wir können die Variabilität weiter erhöhen, indem wir eine Sammlung von Fertighäusern mit jeder Ebene der Urbanisierungsdichte verknüpfen. </font><font style="vertical-align: inherit;">Danach ist es möglich, eine davon zufällig auszuwählen. </font><font style="vertical-align: inherit;">Dadurch wird einen neuen Zufallswert erfordern, so ein dritten hinzuzufügen </font></font><code>HexHash</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a, b, c; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexHash </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexHash hash; hash.a = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; hash.b = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; hash.c = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie es uns </font></font><code>HexFeatureManager.urbanPrefabs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in ein Array von Arrays </font><font style="vertical-align: inherit;">verwandeln </font><font style="vertical-align: inherit;">und der Methode einen </font></font><code>PickPrefab</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameter </font><font style="vertical-align: inherit;">hinzufügen </font></font><code>choice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir verwenden es, um den Index des eingebauten Arrays auszuwählen, ihn mit der Länge dieses Arrays zu multiplizieren und in eine Ganzzahl umzuwandeln.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform[][] urbanPrefabs; … <span class="hljs-function"><span class="hljs-function">Transform </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PickPrefab</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hash, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> choice</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (level &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] thresholds = HexMetrics.GetFeatureThresholds(level - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; thresholds.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hash &lt; thresholds[i]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> urbanPrefabs[i][(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(choice * urbanPrefabs[i].Length)]; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Begründen wir unsere Wahl mit dem Wert des zweiten Hashs (B). </font><font style="vertical-align: inherit;">Dann müssen Sie von B nach C abbiegen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, Vector3 position</span></span></span><span class="hljs-function">)</span></span> { HexHash hash = HexMetrics.SampleHashGrid(position); Transform prefab = PickPrefab(cell.UrbanLevel, hash.a, hash.b); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!prefab) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Transform instance = Instantiate(prefab); position.y += instance.localScale.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.localPosition = HexMetrics.Perturb(position); instance.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span> * hash.c, <span class="hljs-number"><span class="hljs-number">0f</span></span>); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevor wir fortfahren, müssen wir überlegen, was </font></font><code>Random.value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einen Wert von 1 zurückgeben könnte. Aus diesem Grund kann der Array-Index darüber hinausgehen. </font><font style="vertical-align: inherit;">Um dies zu verhindern, skalieren wir die Hash-Werte leicht. </font><font style="vertical-align: inherit;">Wir skalieren sie einfach alle, um uns keine Gedanken über die von uns verwendeten Besonderheiten zu machen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexHash </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexHash hash; hash.a = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.999f</span></span>; hash.b = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.999f</span></span>; hash.c = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.999f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leider zeigt der Inspektor keine Arrays von Arrays an. </font><font style="vertical-align: inherit;">Daher können wir sie nicht konfigurieren. </font><font style="vertical-align: inherit;">Um diese Einschränkung zu umgehen, erstellen Sie eine serialisierbare Struktur, in die das integrierte Array eingekapselt werden kann. </font><font style="vertical-align: inherit;">Geben wir ihr eine Methode, die von der Auswahl in den Array-Index konvertiert und ein Fertighaus zurückgibt.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> HexFeatureCollection { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform[] prefabs; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Transform </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pick</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> choice</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prefabs[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(choice * prefabs.Length)]; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir verwenden </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anstelle von eingebauten Arrays ein Array solcher Sammlungen.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Transform[][] urbanPrefabs; public HexFeatureCollection[] urbanCollections; … Transform PickPrefab (int level, float hash, float choice) { if (level &gt; 0) { float[] thresholds = HexMetrics.GetFeatureThresholds(level - 1); for (int i = 0; i &lt; thresholds.Length; i++) { if (hash &lt; thresholds[i]) { return urbanCollections[i].Pick(choice); } } } return null; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir jeder Dichtestufe mehrere Gebäude zuweisen. </font><font style="vertical-align: inherit;">Da sie unabhängig sind, müssen wir nicht den gleichen Betrag pro Level verwenden. </font><font style="vertical-align: inherit;">Ich habe nur zwei Optionen pro Level verwendet und jeder eine längere niedrigere Option hinzugefügt. </font><font style="vertical-align: inherit;">Ich habe die Skalen für sie (3,5, 3, 2), (2,75, 1,5, 1,5) und (1,75, 1, 1) gewählt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b71/a6e/c9f/b71a6ec9f2c379c223e007dda071c94b.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a72/618/81d/a7261881d23703b54aaf22ba59942d2a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zwei Gebäudetypen pro Dichtestufe. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verschiedene Arten von Objekten </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In dem bestehenden Schema können wir durchaus würdige städtische Strukturen schaffen. </font><font style="vertical-align: inherit;">Das Relief kann aber nicht nur Gebäude enthalten. </font><font style="vertical-align: inherit;">Wie wäre es mit Bauernhöfen oder Pflanzen? </font><font style="vertical-align: inherit;">Lassen Sie uns zu den </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ebenen und für sie </font><font style="vertical-align: inherit;">hinzufügen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sie schließen sich nicht gegenseitig aus und können sich mischen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> FarmLevel { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> farmLevel; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (farmLevel != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { farmLevel = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; RefreshSelfOnly(); } } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> PlantLevel { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> plantLevel; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (plantLevel != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { plantLevel = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; RefreshSelfOnly(); } } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> urbanLevel, farmLevel, plantLevel;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies erfordert natürlich die Unterstützung von </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zwei zusätzlichen Schiebereglern.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> activeUrbanLevel, activeFarmLevel, activePlantLevel; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> applyUrbanLevel, applyFarmLevel, applyPlantLevel; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetApplyFarmLevel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { applyFarmLevel = toggle; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetFarmLevel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level</span></span></span><span class="hljs-function">)</span></span> { activeFarmLevel = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)level; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetApplyPlantLevel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { applyPlantLevel = toggle; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetPlantLevel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level</span></span></span><span class="hljs-function">)</span></span> { activePlantLevel = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)level; } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyUrbanLevel) { cell.UrbanLevel = activeUrbanLevel; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyFarmLevel) { cell.FarmLevel = activeFarmLevel; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyPlantLevel) { cell.PlantLevel = activePlantLevel; } … } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fügen Sie sie der Benutzeroberfläche hinzu. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/956/70b/f35/95670bf35594faa69fe46201b78080f7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drei Schieberegler.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Außerdem werden zusätzliche Sammlungen benötigt </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexFeatureCollection[] urbanCollections, farmCollections, plantCollections;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f5d/001/cec/f5d001cecb2bee3c60a0dad637de7dc9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drei Sammlungen von Reliefobjekten.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ich habe sowohl für Farmen als auch für Pflanzen zwei Fertighäuser pro Dichtestufe sowie für den Bau von Sammlungen erstellt. Für alle habe ich Würfel verwendet. Bauernhöfe haben hellgrünes Material, Pflanzen haben dunkelgrünes Material. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe Farmwürfel mit einer Höhe von 0,1 Einheiten hergestellt, um quadratische Parzellen landwirtschaftlicher Flächen anzuzeigen. Als hochdichte Skalen habe ich (2,5, 0,1, 2,5) und (3,5, 0,1, 2) gewählt. Im Durchschnitt haben Standorte eine Fläche von 1,75 und eine Größe von 2,5 x 1,25. Im Bereich 1 wurde eine geringe Dichte und eine Größe von 1,5 mal 0,75 erhalten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fertige Pflanzen bezeichnen hohe Bäume und große Sträucher. Fertighäuser mit hoher Dichte sind die größten (1,25, 4,5, 1,25) und (1,5, 3, 1,5). Die durchschnittlichen Skalen sind (0,75, 3, 0,75) und (1, 1,5, 1). Die kleinsten Pflanzen haben Größen (0,5, 1,5, 0,5) und (0,75, 1, 0,75).</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Auswahl der Reliefmerkmale </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jeder Objekttyp muss einen eigenen Hashwert erhalten, damit sie unterschiedliche Erstellungsmuster haben und Sie sie mischen können. </font><font style="vertical-align: inherit;">Fügen Sie </font></font><code>HexHash</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zwei zusätzliche Werte hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a, b, c, d, e; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexHash </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexHash hash; hash.a = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.999f</span></span>; hash.b = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.999f</span></span>; hash.c = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.999f</span></span>; hash.d = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.999f</span></span>; hash.e = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.999f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt müssen Sie </font></font><code>HexFeatureManager.PickPrefab</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit verschiedenen Sammlungen arbeiten. </font><font style="vertical-align: inherit;">Fügen Sie einen Parameter hinzu, um den Vorgang zu vereinfachen. </font><font style="vertical-align: inherit;">Ändern Sie außerdem den von der Variante des ausgewählten Fertighauses verwendeten Hash in D und den Hash für die Rotation in E.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Transform </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PickPrefab</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexFeatureCollection[] collection, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hash, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> choice </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (level &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] thresholds = HexMetrics.GetFeatureThresholds(level - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; thresholds.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hash &lt; thresholds[i]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collection[i].Pick(choice); } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, Vector3 position</span></span></span><span class="hljs-function">)</span></span> { HexHash hash = HexMetrics.SampleHashGrid(position); Transform prefab = PickPrefab( urbanCollections, cell.UrbanLevel, hash.a, hash.d ); … instance.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span> * hash.e, <span class="hljs-number"><span class="hljs-number">0f</span></span>); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Derzeit </font></font><code>AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wählt vorgefertigte Urbanisierung. </font><font style="vertical-align: inherit;">Das ist normal, wir brauchen mehr Optionen. </font><font style="vertical-align: inherit;">Deshalb fügen wir ein weiteres Fertighaus von den Farmen hinzu. </font><font style="vertical-align: inherit;">Verwenden Sie als Hash-Wert B. Die Option ist wieder D.</font></font><br><br><pre> <code class="cs hljs"> Transform prefab = PickPrefab( urbanCollections, cell.UrbanLevel, hash.a, hash.d ); Transform otherPrefab = PickPrefab( farmCollections, cell.FarmLevel, hash.b, hash.d ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!prefab) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Welche Art von Fertiginstanz werden wir als Ergebnis erstellen? </font><font style="vertical-align: inherit;">Wenn sich herausstellt, dass einer von ihnen null ist, liegt die Wahl auf der Hand. </font><font style="vertical-align: inherit;">Wenn jedoch beide existieren, müssen wir eine Entscheidung treffen. </font><font style="vertical-align: inherit;">Fügen wir einfach das Fertighaus mit dem niedrigsten Hashwert hinzu.</font></font><br><br><pre> <code class="cs hljs"> Transform otherPrefab = PickPrefab( farmCollections, cell.FarmLevel, hash.b, hash.d ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prefab) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab &amp;&amp; hash.b &lt; hash.a) { prefab = otherPrefab; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab) { prefab = otherPrefab; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/baf/369/d71/baf369d71420a1ded309880b38d94c53.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Mischung aus städtischen und ländlichen Objekten. </font></font></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Machen Sie dasselbe mit den Pflanzen, indem Sie den Wert des C-Hash verwenden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prefab) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab &amp;&amp; hash.b &lt; hash.a) { prefab = otherPrefab; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab) { prefab = otherPrefab; } otherPrefab = PickPrefab( plantCollections, cell.PlantLevel, hash.c, hash.d ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prefab) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab &amp;&amp; hash.c &lt; hash.a) { prefab = otherPrefab; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab) { prefab = otherPrefab; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können den Code jedoch nicht einfach kopieren. </font><font style="vertical-align: inherit;">Wenn wir ländliches statt städtisches Objekt wählen, müssen wir den Hasch der Pflanzen mit dem Hasch der Farmen vergleichen und nicht mit dem städtischen. </font><font style="vertical-align: inherit;">Daher müssen wir den Hash verfolgen, den wir ausgewählt und mit ihm verglichen haben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> usedHash = hash.a; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prefab) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab &amp;&amp; hash.b &lt; hash.a) { prefab = otherPrefab; usedHash = hash.b; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab) { prefab = otherPrefab; usedHash = hash.b; } otherPrefab = PickPrefab( plantCollections, cell.PlantLevel, hash.c, hash.d ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prefab) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab &amp;&amp; hash.c &lt; usedHash) { prefab = otherPrefab; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab) { prefab = otherPrefab; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8eb/2e2/215/8eb2e2215e6219b08e8bc42612b31493.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Mischung aus städtischen, ländlichen und pflanzlichen Objekten. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil 10: Wände </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir schließen die Zellen ein. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir bauen Mauern entlang der Ränder der Zellen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lass uns durch Flüsse und Straßen gehen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vermeiden Sie Wasser und verbinden Sie sich mit Klippen. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In diesem Teil werden wir zwischen den Zellen der Wand hinzufügen. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/924/d07/0cd/924d070cd67c3baccf02a0284ef9cdc4.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nichts ist einladender als eine hohe Mauer.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wandbearbeitung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Wände zu stützen, müssen wir wissen, wo sie platziert werden müssen. </font><font style="vertical-align: inherit;">Wir werden sie zwischen die Zellen entlang der Kanten legen, die sie verbinden. </font><font style="vertical-align: inherit;">Da sich bereits vorhandene Objekte im zentralen Teil der Zellen befinden, müssen wir uns keine Sorgen machen, dass die Wände durch sie hindurchgehen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a1/bbb/c11/7a1bbbc1158301bb0091638858fa79fd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wände entlang der Ränder. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wände sind Geländeobjekte, obwohl sie groß sind. </font><font style="vertical-align: inherit;">Wie andere Objekte werden wir sie nicht direkt bearbeiten. </font><font style="vertical-align: inherit;">Stattdessen werden wir die Zellen ändern. </font><font style="vertical-align: inherit;">Wir werden keine getrennten Segmente der Wände haben, sondern die Zellen als Ganzes einschließen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ummauertes Eigentum </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie der </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eigenschaft </font><font style="vertical-align: inherit;">hinzu, um eingezäunte Zellen zu unterstützen </font></font><code>Walled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies ist ein einfacher Schalter. </font><font style="vertical-align: inherit;">Da sich die Wände zwischen den Zellen befinden, müssen wir sowohl die bearbeiteten Zellen als auch ihre Nachbarn aktualisieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Walled { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> walled; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (walled != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { walled = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Refresh(); } } } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> walled;</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Editor wechseln </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um den "eingezäunten" Zustand der Zellen zu ändern, müssen wir </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterstützung für den Schalter </font><font style="vertical-align: inherit;">hinzufügen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Daher fügen wir ein weiteres Feld </font></font><code>OptionalToggle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und eine Methode zum Festlegen hinzu.</font></font><br><br><pre> <code class="cs hljs"> OptionalToggle riverMode, roadMode, walledMode; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetWalledMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mode</span></span></span><span class="hljs-function">)</span></span> { walledMode = (OptionalToggle)mode; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Gegensatz zu Flüssen und Straßen verlaufen Mauern nicht von Zelle zu Zelle, sondern befinden sich zwischen ihnen. </font><font style="vertical-align: inherit;">Daher müssen wir nicht über Drag &amp; Drop nachdenken. </font><font style="vertical-align: inherit;">Wenn der Wandschalter aktiv ist, setzen wir einfach den eingezäunten Zustand der aktuellen Zelle basierend auf dem Zustand dieses Schalters.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roadMode == OptionalToggle.No) { cell.RemoveRoads(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (walledMode != OptionalToggle.Ignore) { cell.Walled = walledMode == OptionalToggle.Yes; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isDrag) { … } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir duplizieren eines der vorherigen Elemente der UI-Schalter und ändern sie so, dass sie den Status des "Fechtens" steuern. </font><font style="vertical-align: inherit;">Ich werde sie zusammen mit anderen Objekten in das UI-Bedienfeld einfügen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ac/f7f/0ca/0acf7f0caaaae171e31d42141fa75947.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Schalter "Fechten". </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wände schaffen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da die Wände den Konturen der Zellen folgen, sollten sie keine konstante Form haben. </font><font style="vertical-align: inherit;">Daher können wir nicht einfach ein Fertighaus für sie verwenden, wie wir es bei anderen Geländemerkmalen getan haben. </font><font style="vertical-align: inherit;">Stattdessen müssen wir ein Netz bauen, wie wir es mit dem Relief getan haben. </font><font style="vertical-align: inherit;">Dies bedeutet, dass unser Fertighausfragment ein weiteres untergeordnetes Element benötigt </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Duplizieren Sie eines der anderen untergeordneten Netze und lassen Sie die neuen </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Walls-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objekte </font><font style="vertical-align: inherit;">Schatten werfen. </font><font style="vertical-align: inherit;">Sie benötigen nur Scheitelpunkte und Dreiecke, daher müssen alle Optionen </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deaktiviert werden.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/615/387/31d/61538731d2eed271c9348c4da2f5d844.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2bf/c6e/af5/2bfc6eaf5ff31f5467ab252c00b7bcce.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tochtergefertigte Fertigmauern. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird logisch sein, dass die Wände ein städtisches Objekt sind, deshalb habe ich für sie das rote Material der Gebäude verwendet.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wandverwaltung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da die Wände Reliefobjekte sind, müssen sie sich mit ihnen befassen </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Daher wird der Manager Relief Objekt Referenz auf das Objekt geben </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Walls</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , und stellen Sie </font><font style="vertical-align: inherit;">sicher , </font><font style="vertical-align: inherit;">dass die Methoden aufrufen </font></font><code>Clear</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>Apply</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMesh walls; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … walls.Clear(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { walls.Apply(); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31d/8f9/0f3/31d8f90f315c7aa43910c67aab6b73cb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit dem Topografiemanager verbundene Wände.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sollten Wände nicht ein Kind von Features sein?</font></font></b> <div class="spoiler_text">       ,   .             ,    <em>Walls</em>    <em>Hex Grid Chunk</em> . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt müssen wir dem Manager eine Methode hinzufügen, mit der wir ihm Wände hinzufügen können. </font><font style="vertical-align: inherit;">Da sich die Wände entlang der Kanten zwischen den Zellen befinden, muss er die entsprechenden Eckpunkte der Kanten und Zellen kennen. </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird es </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zum Zeitpunkt der Triangulation der Zelle und eines ihrer Nachbarn durch verursachen. </font><font style="vertical-align: inherit;">Unter diesem Gesichtspunkt befindet sich die aktuelle Zelle auf der nahen Seite der Wand und die andere auf der anderen Seite.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices near, HexCell nearCell, EdgeVertices far, HexCell farCell </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden diese neue Methode </font></font><code>HexGridChunk.TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nach Abschluss aller anderen Verbindungsarbeiten und unmittelbar vor dem Übergang zum Winkeldreieck aufrufen. </font><font style="vertical-align: inherit;">Wir lassen den Manager der Reliefobjekte selbst entscheiden, wo sich die Wand tatsächlich befinden soll.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { … } features.AddWall(e1, cell, e2, neighbor); HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E &amp;&amp; nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { … } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bauen Sie ein Wandsegment </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die gesamte Wand schlängelt sich durch mehrere Kanten der Zellen. </font><font style="vertical-align: inherit;">Jede Kante enthält nur ein Wandelement. </font><font style="vertical-align: inherit;">Aus Sicht der nahen Zelle beginnt das Segment auf der linken Seite der Rippe und endet auf der rechten Seite. </font><font style="vertical-align: inherit;">Fügen wir eine </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">separate Methode hinzu, die vier Eckpunkte an den Ecken einer Kante verwendet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 nearLeft, Vector3 farLeft, Vector3 nearRight, Vector3 farRight </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f32/2a0/d7b/f322a0d7bc325b13f65c62cfb76b2d0c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nahe und ferne Seite. </font></font></i> <br><br> <code>AddWall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann diese Methode mit der ersten und letzten Kante der Kanten aufrufen. </font><font style="vertical-align: inherit;">Wände sollten jedoch nur hinzugefügt werden, wenn eine Verbindung zwischen einer eingezäunten Zelle und einer nicht eingezäunten Zelle besteht. </font><font style="vertical-align: inherit;">Es spielt keine Rolle, welche der Zellen sich innerhalb und welche außerhalb befindet, nur der Unterschied in ihren Zuständen wird berücksichtigt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices near, HexCell nearCell, EdgeVertices far, HexCell farCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nearCell.Walled != farCell.Walled) { AddWallSegment(near.v1, far.v1, near.v5, far.v5); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das einfachste Segment der Wand ist ein Quad, das in der Mitte der Rippe steht. </font><font style="vertical-align: inherit;">Wir werden seine unteren Spitzen finden, die von den nächstgelegenen zu den am weitesten entfernten Spitzen in die Mitte interpolieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 nearLeft, Vector3 farLeft, Vector3 nearRight, Vector3 farRight </span></span></span><span class="hljs-function">)</span></span> { Vector3 left = Vector3.Lerp(nearLeft, farLeft, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); Vector3 right = Vector3.Lerp(nearRight, farRight, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie hoch sollte die Wand sein? </font><font style="vertical-align: inherit;">Stellen wir die Höhe auf ein </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ich habe sie auf die Größe einer Zellenhöhe gebracht.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> wallHeight = <span class="hljs-number"><span class="hljs-number">3f</span></span>;</code> </pre> <br> <code>HexFeatureManager.AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit dieser Höhe können Sie den dritten und vierten Scheitelpunkt des Quad positionieren und dem Netz hinzufügen </font></font><code>walls</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> Vector3 left = Vector3.Lerp(nearLeft, farLeft, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); Vector3 right = Vector3.Lerp(nearRight, farRight, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); Vector3 v1, v2, v3, v4; v1 = v3 = left; v2 = v4 = right; v3.y = v4.y = left.y + HexMetrics.wallHeight; walls.AddQuad(v1, v2, v3, v4);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir die Wände bearbeiten und sie werden als Quad-Streifen angezeigt. </font><font style="vertical-align: inherit;">Wir werden jedoch keine durchgehende Wand sehen. </font><font style="vertical-align: inherit;">Jedes Quad ist nur auf einer Seite sichtbar. </font><font style="vertical-align: inherit;">Sein Gesicht ist auf die Zelle gerichtet, aus der es hinzugefügt wurde.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5a/2f0/442/e5a2f0442a2d1812b73dd2977d80d565.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einseitige Quadwände. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können dieses Problem schnell lösen, indem wir ein zweites Quad hinzufügen, das in die andere Richtung zeigt.</font></font><br><br><pre> <code class="cs hljs"> walls.AddQuad(v1, v2, v3, v4); walls.AddQuad(v2, v1, v4, v3);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/302/e53/129/302e53129e87c3432848772688e9d896.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bilaterale Wände. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt sind alle Wände in ihrer Gesamtheit sichtbar, aber es gibt immer noch Löcher in den Ecken der Zellen, in denen sich die drei Zellen treffen. </font><font style="vertical-align: inherit;">Wir werden sie später ausfüllen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dicke Wände </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl die Wände bereits auf beiden Seiten sichtbar sind, haben sie keine Dicke. </font><font style="vertical-align: inherit;">Tatsächlich sind die Wände dünn wie Papier und in einem bestimmten Winkel fast unsichtbar. </font><font style="vertical-align: inherit;">Machen wir sie also ganz, indem wir die Dicke hinzufügen. </font><font style="vertical-align: inherit;">Stellen Sie ihre Dicke ein </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ich habe einen Wert von 0,75 Einheiten gewählt, es schien mir geeignet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> wallThickness = <span class="hljs-number"><span class="hljs-number">0.75f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um zwei Wände dick zu machen, müssen Sie zwei Quads an den Seiten trennen. </font><font style="vertical-align: inherit;">Sie sollten sich in entgegengesetzte Richtungen bewegen. </font><font style="vertical-align: inherit;">Eine Seite sollte sich zur nahen Kante bewegen, die andere zur fernen Kante. </font><font style="vertical-align: inherit;">Der Versatzvektor hierfür ist gleich </font></font><code>far - near</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber um die Oberseite der Wand flach zu lassen, müssen wir ihre Komponente Y auf 0 setzen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da dies sowohl für die linke als auch für die rechte Seite des Wandsegments erfolgen muss, fügen wir der </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode </font><font style="vertical-align: inherit;">einen </font><font style="vertical-align: inherit;">Versatzvektor hinzu, um dies zu berechnen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WallThicknessOffset</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 near, Vector3 far</span></span></span><span class="hljs-function">)</span></span> { Vector3 offset; offset.x = far.x - near.x; offset.y = <span class="hljs-number"><span class="hljs-number">0f</span></span>; offset.z = far.z - near.z; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> offset; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit die Wand in der Mitte der Rippe bleibt, sollte der tatsächliche Bewegungsabstand entlang dieses Vektors der halben Dicke für jede Seite entsprechen. </font><font style="vertical-align: inherit;">Und um sicherzustellen, dass wir wirklich die richtige Strecke zurückgelegt haben, normalisieren wir den Verschiebungsvektor, bevor wir ihn skalieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> offset.normalized * (wallThickness * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir verwenden diese Methode </font></font><code>HexFeatureManager.AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um die Position der Quads zu ändern. </font><font style="vertical-align: inherit;">Da der Verschiebungsvektor von der nächsten zur fernen Zelle geht, subtrahieren Sie ihn vom nahen Quad und addieren Sie zum fernen.</font></font><br><br><pre> <code class="cs hljs"> Vector3 left = Vector3.Lerp(nearLeft, farLeft, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); Vector3 right = Vector3.Lerp(nearRight, farRight, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); Vector3 leftThicknessOffset = HexMetrics.WallThicknessOffset(nearLeft, farLeft); Vector3 rightThicknessOffset = HexMetrics.WallThicknessOffset(nearRight, farRight); Vector3 v1, v2, v3, v4; v1 = v3 = left - leftThicknessOffset; v2 = v4 = right - rightThicknessOffset; v3.y = v4.y = left.y + HexMetrics.wallHeight; walls.AddQuad(v1, v2, v3, v4); v1 = v3 = left + leftThicknessOffset; v2 = v4 = right + rightThicknessOffset; v3.y = v4.y = left.y + HexMetrics.wallHeight; walls.AddQuad(v2, v1, v4, v3);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df7/746/08b/df774608b2b06114b4afbc6ec2904e61.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wände mit Versatz. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Quads sind jetzt voreingenommen, obwohl dies nicht ganz auffällt.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sind die Wandstärken gleich?</font></font></b> <div class="spoiler_text">    ,      «-»     .      ,    .       .       ,   .    ,    .  , -      ,     .      . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spitzen der Wände </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Wandstärke von oben sichtbar zu machen, müssen wir oben an der Wand ein Quad hinzufügen. </font><font style="vertical-align: inherit;">Der einfachste Weg, dies zu tun, besteht darin, sich die beiden oberen Eckpunkte des ersten Quadrats zu merken und sie mit den beiden oberen Eckpunkten des zweiten Quadrats zu verbinden.</font></font><br><br><pre> <code class="cs hljs"> Vector3 v1, v2, v3, v4; v1 = v3 = left - leftThicknessOffset; v2 = v4 = right - rightThicknessOffset; v3.y = v4.y = left.y + HexMetrics.wallHeight; walls.AddQuad(v1, v2, v3, v4); Vector3 t1 = v3, t2 = v4; v1 = v3 = left + leftThicknessOffset; v2 = v4 = right + rightThicknessOffset; v3.y = v4.y = left.y + HexMetrics.wallHeight; walls.AddQuad(v2, v1, v4, v3); walls.AddQuad(t1, t2, v3, v4);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d7/15d/627/1d715d627770a9e7a17bf135a461833d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wände mit Spitzen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kurvenfahrt </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben immer noch Löcher an den Ecken der Zellen. </font><font style="vertical-align: inherit;">Um sie zu füllen, müssen wir dem dreieckigen Bereich zwischen den Zellen ein Segment hinzufügen. </font><font style="vertical-align: inherit;">Jede Ecke verbindet drei Zellen. </font><font style="vertical-align: inherit;">Jede Zelle kann eine Wand haben oder nicht. </font><font style="vertical-align: inherit;">Das heißt, acht Konfigurationen sind möglich.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed9/277/8ee/ed92778ee39106d3a448892a124d366c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Winkelkonfigurationen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir platzieren Wände nur zwischen Zellen mit unterschiedlichen eingezäunten Zuständen. </font><font style="vertical-align: inherit;">Dies reduziert die Anzahl der Konfigurationen auf sechs. </font><font style="vertical-align: inherit;">In jedem von ihnen befindet sich eine der Zellen innerhalb der Krümmung der Wände. </font><font style="vertical-align: inherit;">Betrachten wir diese Zelle als Referenzpunkt, um den die Wand gekrümmt ist. </font><font style="vertical-align: inherit;">Aus der Sicht dieser Zelle beginnt die Wand mit einer Kante, die der linken Zelle gemeinsam ist, und endet mit einer Kante, die der rechten Zelle gemeinsam ist.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48e/f68/19a/48ef6819a839339a17d1513f7ca546b5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zellrollen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das heißt, wir müssen eine Methode erstellen, </font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deren Parameter drei Eckpunkte der Ecke sind. </font><font style="vertical-align: inherit;">Obwohl wir Code schreiben können, um dieses Segment zu triangulieren, ist dies tatsächlich ein Sonderfall der Methode </font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ein Ankerpunkt spielt die Rolle beider naher Eckpunkte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 pivot, HexCell pivotCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { AddWallSegment(pivot, left, pivot, right); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie als Nächstes eine Variante der Methode </font></font><code>AddWall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">für die drei Eckpunkte des Winkels und ihre Zellen. </font><font style="vertical-align: inherit;">Das Ziel dieser Methode ist es, den Winkel zu bestimmen, der der Referenzpunkt ist, falls vorhanden. </font><font style="vertical-align: inherit;">Daher muss er alle acht möglichen Konfigurationen berücksichtigen und </font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sechs davon anfordern.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 c1, HexCell cell1, Vector3 c2, HexCell cell2, Vector3 c3, HexCell cell3 </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell1.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell2.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell3.Walled) { AddWallSegment(c3, cell3, c1, cell1, c2, cell2); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell3.Walled) { AddWallSegment(c2, cell2, c3, cell3, c1, cell1); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddWallSegment(c1, cell1, c2, cell2, c3, cell3); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell2.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell3.Walled) { AddWallSegment(c1, cell1, c2, cell2, c3, cell3); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddWallSegment(c2, cell2, c3, cell3, c1, cell1); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell3.Walled) { AddWallSegment(c3, cell3, c1, cell1, c2, cell2); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rufen Sie diese Methode am Ende auf, um Eckensegmente hinzuzufügen </font></font><code>HexGridChunk.TriangulateCorner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { … features.AddWall(bottom, bottomCell, left, leftCell, right, rightCell); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a8e/e63/304/a8ee63304fce04d4db9dcdf46076b3a9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wände mit Ecken, aber es gibt noch Löcher.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schließen Sie die Löcher </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt immer noch Löcher in den Wänden, da die Höhe der Wandsegmente variabel ist. Während die Segmente entlang der Kanten eine konstante Höhe haben, befinden sich die Ecksegmente zwischen zwei verschiedenen Kanten. Da jede Kante ihre eigene Höhe haben kann, erscheinen an den Ecken Löcher. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um dies zu beheben, ändern Sie </font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es so, dass die Y-Koordinaten des linken und rechten oberen Scheitelpunkts getrennt gespeichert werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> leftTop = left.y + HexMetrics.wallHeight; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rightTop = right.y + HexMetrics.wallHeight; Vector3 v1, v2, v3, v4; v1 = v3 = left - leftThicknessOffset; v2 = v4 = right - rightThicknessOffset; v3.y = leftTop; v4.y = rightTop; walls.AddQuad(v1, v2, v3, v4); Vector3 t1 = v3, t2 = v4; v1 = v3 = left + leftThicknessOffset; v2 = v4 = right + rightThicknessOffset; v3.y = leftTop; v4.y = rightTop; walls.AddQuad(v2, v1, v4, v3);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9cd/f1d/a88/9cdf1da889ce427e1d519a284532d6a8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geschlossene Wände.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Wände sind jetzt geschlossen, aber Sie sehen wahrscheinlich immer noch Löcher in den Schatten der Wand. Dies wird durch den Parameter </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normal Bias</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der </font><font style="vertical-align: inherit;">Richtungsschatteneinstellung verursacht. Wenn es größer als Null ist, bewegen sich die Dreiecke der Objekte, die einen Schatten werfen, entlang der Normalen zur Oberfläche. Dies vermeidet Selbstbeschattung, erzeugt aber gleichzeitig Löcher in Fällen, in denen die Dreiecke in verschiedene Richtungen schauen. In diesem Fall können Löcher in den Schatten feiner Geometrie erzeugt werden, beispielsweise in unseren Wänden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie können diese Schattenartefakte entfernen, indem Sie die normale Vorspannung auf Null senken. Oder ändern Sie den </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cast Shadows</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mesh Renderer- </font><font style="vertical-align: inherit;">Wandmodus </font><font style="vertical-align: inherit;">in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Two Sided</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dadurch rendert das Schattenwurfobjekt beide Seiten jedes Wanddreiecks zum Rendern, wodurch alle Löcher geschlossen werden.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b14/9d5/d0b/b149d5d0bb36f049faa5ca9d49261618.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt keine Löcher mehr in den Schatten. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Leistenwand </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher sind unsere Wände gerade genug. </font><font style="vertical-align: inherit;">Für ein flaches Gelände ist dies überhaupt nicht schlecht, aber es sieht seltsam aus, wenn die Wände mit den Leisten zusammenfallen. </font><font style="vertical-align: inherit;">Dies geschieht, wenn zwischen Zellen auf gegenüberliegenden Seiten der Wand ein Höhenunterschied von einer Höhe besteht.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/065/481/c1a/065481c1a0859ced22d0ae6568acbe86.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gerade Wände auf den Leisten.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Folgen Sie der Kante </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anstatt ein Segment für die gesamte Kante zu erstellen, erstellen wir eines für jeden Teil des Kantenstreifens. </font><font style="vertical-align: inherit;">Wir können dies tun, indem wir </font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der </font></font><code>AddWall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Edge- </font><font style="vertical-align: inherit;">Version </font><font style="vertical-align: inherit;">viermal aufrufen </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices near, HexCell nearCell, EdgeVertices far, HexCell farCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nearCell.Walled != farCell.Walled) { AddWallSegment(near.v1, far.v1, near.v2, far.v2); AddWallSegment(near.v2, far.v2, near.v3, far.v3); AddWallSegment(near.v3, far.v3, near.v4, far.v4); AddWallSegment(near.v4, far.v4, near.v5, far.v5); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a96/8aa/0f9/a968aa0f984b31e81dc9edb12e8d31bb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geschwungene Wände. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wände wiederholen nun die Form verzerrter Kanten. </font><font style="vertical-align: inherit;">In Kombination mit den Leisten sieht es viel besser aus. </font><font style="vertical-align: inherit;">Darüber hinaus entstehen interessantere Wände auf einem flachen Relief.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wände auf den Boden stellen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie sich die Wände auf den Leisten ansehen, können Sie ein Problem feststellen. Die Wände hängen über dem Boden! Dies gilt für geneigte flache Kanten, ist aber normalerweise nicht so auffällig.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/039/8f0/a59/0398f0a59aca756824e162c3fba5a891.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wände hängen in der Luft.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um das Problem zu lösen, müssen wir die Wände absenken. Am einfachsten ist es, die gesamte Wand so abzusenken, dass ihre Oberseite flach bleibt. Gleichzeitig senkt sich ein Teil der Wand auf der Oberseite leicht in das Relief, aber das passt zu uns. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Wand abzusenken, müssen wir bestimmen, welche Seite niedriger ist - nah oder fern. Wir können nur die Höhe der untersten Seite verwenden, müssen aber nicht so tief gehen. Sie können die Y-Koordinate mit einem Versatz von knapp 0,5 von niedrig nach hoch interpolieren. Da die Wände nur gelegentlich höher als die untere Stufe der Kante werden, können wir die vertikale Stufe der Kante als Versatz verwenden. Eine unterschiedliche Wandstärke der Leistenkonfiguration kann einen anderen Versatz erfordern.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/960/61c/817/96061c817bfdc69db9682e0799ba3751.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die abgesenkte Wand. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen wir der </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode </font></font><code>WallLerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die sich mit dieser Interpolation befasst, zusätzlich zur Mittelung der X- und Z-Koordinaten der nahen und fernen Eckpunkte hinzu. </font><font style="vertical-align: inherit;">Es basiert auf einer Methode </font></font><code>TerraceLerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> wallElevationOffset = verticalTerraceStepSize; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WallLerp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 near, Vector3 far</span></span></span><span class="hljs-function">)</span></span> { near.x += (far.x - near.x) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; near.z += (far.z - near.z) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> v = near.y &lt; far.y ? wallElevationOffset : (<span class="hljs-number"><span class="hljs-number">1f</span></span> - wallElevationOffset); near.y += (far.y - near.y) * v; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> near; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erzwingen Sie </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diese Methode, um den linken und rechten Scheitelpunkt zu bestimmen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 nearLeft, Vector3 farLeft, Vector3 nearRight, Vector3 farRight </span></span></span><span class="hljs-function">)</span></span> { Vector3 left = HexMetrics.WallLerp(nearLeft, farLeft); Vector3 right = HexMetrics.WallLerp(nearRight, farRight); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/957/a4c/b49/957a4cb498eb8a712064a0b99a4041be.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wände stehen auf dem Boden.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Änderung der Wandverzerrung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt stimmen unsere Wände gut mit Höhenunterschieden überein. Sie entsprechen jedoch immer noch nicht vollständig den verzerrten Kanten, obwohl sie sich in ihrer Nähe befinden. Dies geschah, weil wir zuerst die Oberseiten der Wände bestimmen und sie dann verzerren. Da diese Scheitelpunkte irgendwo zwischen den Scheitelpunkten der nahen und fernen Kante liegen, ist ihre Verzerrung geringfügig unterschiedlich. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Tatsache, dass die Wände den Rippen ungenau folgen, ist kein Problem. Die Verformung der Wandoberseiten ändert sich jedoch ansonsten relativ gleichmäßige Dicke. Wenn wir die Wände basierend auf verzerrten Eckpunkten anordnen und dann unverzerrte Quads hinzufügen, sollte ihre Dicke nicht stark variieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 nearLeft, Vector3 farLeft, Vector3 nearRight, Vector3 farRight </span></span></span><span class="hljs-function">)</span></span> { nearLeft = HexMetrics.Perturb(nearLeft); farLeft = HexMetrics.Perturb(farLeft); nearRight = HexMetrics.Perturb(nearRight); farRight = HexMetrics.Perturb(farRight); … walls.AddQuadUnperturbed(v1, v2, v3, v4); … walls.AddQuadUnperturbed(v2, v1, v4, v3); walls.AddQuadUnperturbed(t1, t2, v3, v4); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b10/fa3/03d/b10fa303dc91a50665bf92b47feed5e7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die unverzerrten Oberseiten der Wände. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dank dieses Ansatzes folgen die Wände nicht mehr so ​​genau wie zuvor den Kanten. </font><font style="vertical-align: inherit;">Im Gegenzug werden sie jedoch weniger gebrochen und haben eine konstantere Dicke.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d38/7f6/b6f/d387f6b6f1c4fed424d2582a8ef5c12c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gleichmäßigere Wandstärke. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Löcher in den Wänden </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher haben wir die Möglichkeit ignoriert, dass ein Fluss oder eine Straße die Mauer überquert. </font><font style="vertical-align: inherit;">In diesem Fall müssen wir ein Loch in die Wand bohren, durch das ein Fluss oder eine Straße führen kann. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie dazu </font></font><code>AddWall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zwei Boolesche Parameter hinzu, um anzugeben, ob ein Fluss oder eine Straße durch eine Kante verläuft. </font><font style="vertical-align: inherit;">Obwohl wir sie unterschiedlich behandeln können, entfernen wir in beiden Fällen einfach die beiden mittleren Segmente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices near, HexCell nearCell, EdgeVertices far, HexCell farCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRiver, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nearCell.Walled != farCell.Walled) { AddWallSegment(near.v1, far.v1, near.v2, far.v2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRiver || hasRoad) { <span class="hljs-comment"><span class="hljs-comment">// Leave a gap. } else { AddWallSegment(near.v2, far.v2, near.v3, far.v3); AddWallSegment(near.v3, far.v3, near.v4, far.v4); } AddWallSegment(near.v4, far.v4, near.v5, far.v5); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt </font></font><code>HexGridChunk.TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sollte es die notwendigen Daten liefern. </font><font style="vertical-align: inherit;">Da er bereits dieselben Informationen benötigte, speichern wir sie in booleschen Variablen und zeichnen die Aufrufe der entsprechenden Methoden nur einmal auf.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasRiver = cell.HasRiverThroughEdge(direction); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasRoad = cell.HasRoadThroughEdge(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRiver) { … } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(e1, cell, e2, neighbor, hasRoad); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateEdgeStrip(e1, cell.Color, e2, neighbor.Color, hasRoad); } features.AddWall(e1, cell, e2, neighbor, hasRiver, hasRoad); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64c/d05/425/64cd0542540b5d9347a071d727fe2fa4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Löcher in den Wänden für den Durchgang von Flüssen und Straßen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir bedecken die Wände </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese neuen Öffnungen schaffen Orte, um die Wände zu vervollständigen. </font><font style="vertical-align: inherit;">Wir müssen diese Endpunkte mit Quads schließen, damit wir nicht durch die Seiten der Wände schauen können. </font><font style="vertical-align: inherit;">Erstellen wir zu diesem Zweck eine </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode </font></font><code>AddWallCap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es funktioniert wie </font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber es braucht nur ein Paar Nah-Fern-Spitzen. </font><font style="vertical-align: inherit;">Lassen Sie ihn ein Quad hinzufügen, das von der nahen zur anderen Seite der Wand geht.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallCap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 near, Vector3 far</span></span></span><span class="hljs-function">)</span></span> { near = HexMetrics.Perturb(near); far = HexMetrics.Perturb(far); Vector3 center = HexMetrics.WallLerp(near, far); Vector3 thickness = HexMetrics.WallThicknessOffset(near, far); Vector3 v1, v2, v3, v4; v1 = v3 = center - thickness; v2 = v4 = center + thickness; v3.y = v4.y = center.y + HexMetrics.wallHeight; walls.AddQuadUnperturbed(v1, v2, v3, v4); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn sich </font></font><code>AddWall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">herausstellt, dass wir ein Loch benötigen, fügen wir eine Abdeckung zwischen dem zweiten und vierten Kantenpaar der Kanten hinzu. </font><font style="vertical-align: inherit;">Für das vierte Scheitelpunktpaar müssen Sie die Ausrichtung ändern, da sonst die Quad-Fläche nach innen schaut.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices near, HexCell nearCell, EdgeVertices far, HexCell farCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRiver, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nearCell.Walled != farCell.Walled) { AddWallSegment(near.v1, far.v1, near.v2, far.v2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRiver || hasRoad) { AddWallCap(near.v2, far.v2); AddWallCap(far.v4, near.v4); } … } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/413/98c/828/41398c82892a2c1f706ca85c9230813a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geschlossene Löcher in den Wänden.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist mit Löchern an den Rändern der Karte?</font></font></b> <div class="spoiler_text">   ,     .        .    ,        . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vermeiden Sie Klippen und Wasser </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauen wir uns zum Schluss Kanten an, die Klippen oder Wasser enthalten. </font><font style="vertical-align: inherit;">Da es sich bei den Klippen im Wesentlichen um große Mauern handelt, wäre es unlogisch, eine zusätzliche Mauer darauf zu platzieren. </font><font style="vertical-align: inherit;">Außerdem wird es schlecht aussehen. </font><font style="vertical-align: inherit;">Unterwasserwände sind ebenso völlig unlogisch wie die Einschränkung durch die Küstenwände.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45a/94e/027/45a94e027094c6ebdae0763663d6eb8e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wände auf Klippen und im Wasser. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können die Wände von diesen unnötigen Kanten durch zusätzliches Einchecken entfernen </font></font><code>AddWall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Eine Wand kann nicht unter Wasser sein, und eine gemeinsame Rippe kann keine Klippe sein.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices near, HexCell nearCell, EdgeVertices far, HexCell farCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRiver, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( nearCell.Walled != farCell.Walled &amp;&amp; !nearCell.IsUnderwater &amp;&amp; !farCell.IsUnderwater &amp;&amp; nearCell.GetEdgeType(farCell) != HexEdgeType.Cliff ) { … } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/128/baf/75a/128baf75ace7d0cf4ed5f12ef380eec8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die störenden Wände entlang der Rippen wurden entfernt, aber die Ecken blieben an Ort und Stelle.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wandecken entfernen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Entfernen unnötiger Ecksegmente erfordert etwas mehr Aufwand. </font><font style="vertical-align: inherit;">Der einfachste Fall ist, wenn sich die Stützzelle unter Wasser befindet. </font><font style="vertical-align: inherit;">Dadurch wird sichergestellt, dass keine Wandsegmente in der Nähe angeschlossen werden können.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 pivot, HexCell pivotCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pivotCell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } AddWallSegment(pivot, left, pivot, right); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecc/475/9f3/ecc4759f38ced7802ad8743626f91d51.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt keine Unterwasser-Stützzellen mehr. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt müssen wir uns zwei andere Zellen ansehen. </font><font style="vertical-align: inherit;">Befindet sich einer von ihnen unter Wasser oder ist er durch eine Unterbrechung mit der Stützzelle verbunden, gibt es entlang dieser Rippe keine Wand. </font><font style="vertical-align: inherit;">Wenn dies für mindestens eine Seite zutrifft, sollte sich in dieser Ecke kein Wandsegment befinden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir bestimmen individuell, ob es eine linke oder eine rechte Wand gibt. </font><font style="vertical-align: inherit;">Wir setzen die Ergebnisse in boolesche Variablen, um die Arbeit zu erleichtern.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pivotCell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasLeftWall = !leftCell.IsUnderwater &amp;&amp; pivotCell.GetEdgeType(leftCell) != HexEdgeType.Cliff; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasRighWall = !rightCell.IsUnderwater &amp;&amp; pivotCell.GetEdgeType(rightCell) != HexEdgeType.Cliff; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasLeftWall &amp;&amp; hasRighWall) { AddWallSegment(pivot, left, pivot, right); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cd/f17/82d/8cdf1782d522d5b9e19e461ee5253436.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle Störwinkel entfernt.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schließen Sie die Ecken </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn sich weder am linken noch am rechten Rand eine Wand befindet, sind die Arbeiten abgeschlossen. </font><font style="vertical-align: inherit;">Wenn sich die Wand jedoch nur in eine Richtung befindet, bedeutet dies, dass sich ein weiteres Loch in der Wand befindet. </font><font style="vertical-align: inherit;">Daher müssen Sie es schließen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasLeftWall) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRighWall) { AddWallSegment(pivot, left, pivot, right); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddWallCap(pivot, left); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRighWall) { AddWallCap(right, pivot); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/20e/c4d/176/20ec4d17689500d123fc5fd41d447e88.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir schließen die Wände.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verbindung von Mauern mit Klippen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In einer Situation sehen die Wände unvollkommen aus. </font><font style="vertical-align: inherit;">Wenn die Wand den Boden der Klippe erreicht, endet sie. </font><font style="vertical-align: inherit;">Da die Klippen jedoch nicht vollständig vertikal sind, entsteht zwischen der Wand und dem Rand der Klippe ein schmales Loch. </font><font style="vertical-align: inherit;">Oben auf der Klippe tritt ein solches Problem nicht auf.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/633/5c6/9a7/6335c69a7f45dcd1c2a0609503b2504a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Löcher zwischen Wänden und Felswänden. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wäre viel besser, wenn die Mauer bis zum Rand der Klippe reichen würde. </font><font style="vertical-align: inherit;">Wir können dies tun, indem wir ein weiteres Wandsegment zwischen dem aktuellen Ende der Wand und der Ecke oben auf der Klippe hinzufügen. </font><font style="vertical-align: inherit;">Da der größte Teil dieses Segments in der Klippe verborgen ist, können wir darauf verzichten, die Wandstärke innerhalb der Klippe auf Null zu reduzieren. </font><font style="vertical-align: inherit;">Es reicht uns also, einen Keil zu erstellen: zwei Quads, die auf den Punkt gehen, und ein Dreieck darüber. </font><font style="vertical-align: inherit;">Erstellen wir zu diesem Zweck eine Methode </font></font><code>AddWallWedge</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies kann durch Kopieren </font></font><code>AddWallCap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und Hinzufügen eines Keilpunkts erfolgen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallWedge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 near, Vector3 far, Vector3 point</span></span></span><span class="hljs-function">)</span></span> { near = HexMetrics.Perturb(near); far = HexMetrics.Perturb(far); point = HexMetrics.Perturb(point); Vector3 center = HexMetrics.WallLerp(near, far); Vector3 thickness = HexMetrics.WallThicknessOffset(near, far); Vector3 v1, v2, v3, v4; Vector3 pointTop = point; point.y = center.y; v1 = v3 = center - thickness; v2 = v4 = center + thickness; v3.y = v4.y = pointTop.y = center.y + HexMetrics.wallHeight; <span class="hljs-comment"><span class="hljs-comment">// walls.AddQuadUnperturbed(v1, v2, v3, v4); walls.AddQuadUnperturbed(v1, point, v3, pointTop); walls.AddQuadUnperturbed(point, v2, pointTop, v4); walls.AddTriangleUnperturbed(pointTop, v3, v4); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In </font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ecken nennen wir diese Methode, wenn die Wand nur in eine Richtung verläuft und sich diese Wand auf einer niedrigeren Höhe als die andere Seite befindet. </font><font style="vertical-align: inherit;">Unter diesen Bedingungen stoßen wir auf den Rand einer Klippe.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasLeftWall) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRighWall) { AddWallSegment(pivot, left, pivot, right); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.Elevation &lt; rightCell.Elevation) { AddWallWedge(pivot, left, right); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddWallCap(pivot, left); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRighWall) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightCell.Elevation &lt; leftCell.Elevation) { AddWallWedge(right, pivot, left); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddWallCap(right, pivot); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5c/30f/33a/b5c30f33ac93582e2ce319996d9ed1ac.png"></div><br> <i> ,   .</i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">unitypackage</a> <br><br><h1>  11:    </h1><br><ul><li>    . </li><li>     . </li><li>     . </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef5/a07/5ea/ef5a075ea4c14c810825388be274f817.jpg"></div><br> <i>  .</i> <br><br><h2>    </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im vorherigen Teil haben wir eine Wandstütze hinzugefügt. Dies sind einfache gerade Wandsegmente ohne erkennbare Unterschiede. Jetzt werden wir die Wände interessanter machen, indem wir ihnen Türme hinzufügen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wandsegmente müssen prozedural erstellt werden, um dem Relief zu entsprechen. Dies ist für die Türme nicht erforderlich, wir können das übliche Fertighaus verwenden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können einen einfachen Turm aus zwei Würfeln mit rotem Material erstellen. Die Basis des Turms hat eine Größe von 2 mal 2 Einheiten und eine Höhe von 4 Einheiten, dh sie ist dicker und höher als die Wand. Über diesem Würfel platzieren wir einen Einheitswürfel, der die Spitze des Turms kennzeichnet. Wie alle anderen Fertighäuser benötigen diese Würfel keine Kollider.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da das Turmmodell aus mehreren Objekten besteht, machen wir sie zu Kindern des Stammobjekts. </font><font style="vertical-align: inherit;">Platzieren Sie sie so, dass der lokale Ursprung der Wurzel am Fuß des Turms liegt. </font><font style="vertical-align: inherit;">Dank dessen können wir die Türme platzieren, ohne uns um ihre Höhe sorgen zu müssen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f1/a54/335/2f1a54335d81a6682707e740107362c6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fertighaus. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie einen Link zu diesem Fertighaus hinzu </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und verbinden Sie es.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform wallTower;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f76/df1/c7e/f76df1c7e5b1c808d2ae636f7e823487.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link zum Fertighaus.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Türme bauen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beginnen wir mit der Platzierung von Türmen in der Mitte jedes Wandsegments. </font><font style="vertical-align: inherit;">Dazu erstellen wir am Ende der Methode einen Turm </font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ihre Position ist der Durchschnitt der linken und rechten Punkte des Segments.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 nearLeft, Vector3 farLeft, Vector3 nearRight, Vector3 farRight </span></span></span><span class="hljs-function">)</span></span> { … Transform towerInstance = Instantiate(wallTower); towerInstance.transform.localPosition = (left + right) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; towerInstance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/559/541/487/559541487b79dd6877b4456dbdf010b1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Turm pro Wandsegment. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben viele Türme entlang der Mauer, aber ihre Ausrichtung ändert sich nicht. </font><font style="vertical-align: inherit;">Wir müssen ihre Drehung so ändern, dass sie mit der Wand ausgerichtet sind. </font><font style="vertical-align: inherit;">Da wir den rechten und den linken Punkt der Wand haben, wissen wir, welche Richtung richtig ist. </font><font style="vertical-align: inherit;">Mit diesem Wissen können wir die Ausrichtung des Wandsegments und damit des Turms bestimmen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anstatt die Rotation selbst zu berechnen, weisen wir </font></font><code>Transform.right</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der </font><font style="vertical-align: inherit;">Eigenschaft einfach einen </font><font style="vertical-align: inherit;">Vektor zu. </font><font style="vertical-align: inherit;">Der Einheitscode ändert die Drehung des Objekts so, dass seine lokale Richtung rechts dem übertragenen Vektor entspricht.</font></font><br><br><pre> <code class="cs hljs"> Transform towerInstance = Instantiate(wallTower); towerInstance.transform.localPosition = (left + right) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; Vector3 rightDirection = right - left; rightDirection.y = <span class="hljs-number"><span class="hljs-number">0f</span></span>; towerInstance.transform.right = rightDirection; towerInstance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d3/2c3/777/5d32c3777d5b63db90ddf9f8fbbf1dee.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Türme sind mit der Wand ausgerichtet.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie funktioniert die Zuweisung von Transform.right?</font></font></b> <div class="spoiler_text">     <code>Quaternion.FromToRotation</code>   .   . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 right { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rotation * Vector3.right; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { rotation = Quaternion.FromToRotation(Vector3.right, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); } }</code> </pre> </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reduzieren Sie die Anzahl der Türme </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Turm pro Wandsegment ist zu viel. </font><font style="vertical-align: inherit;">Lassen Sie uns das Hinzufügen des Turms optional machen, indem wir dem </font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Booleschen </font><font style="vertical-align: inherit;">Wert einen </font><font style="vertical-align: inherit;">Parameter </font><font style="vertical-align: inherit;">hinzufügen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Stellen Sie den Standardwert ein </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In diesem Fall verschwinden alle Türme.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 nearLeft, Vector3 farLeft, Vector3 nearRight, Vector3 farRight, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> addTower = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (addTower) { Transform towerInstance = Instantiate(wallTower); towerInstance.transform.localPosition = (left + right) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; Vector3 rightDirection = right - left; rightDirection.y = <span class="hljs-number"><span class="hljs-number">0f</span></span>; towerInstance.transform.right = rightDirection; towerInstance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Platzieren wir die Türme nur in den Ecken der Zellen. </font><font style="vertical-align: inherit;">Infolgedessen erhalten wir weniger Türme mit ziemlich konstanten Abständen zwischen ihnen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 pivot, HexCell pivotCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { … AddWallSegment(pivot, left, pivot, right, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d60/823/d7b/d60823d7b381eccaf5916bf2bc636061.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Türme sind nur in den Ecken. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es sieht gut aus, aber wir müssen die Türme möglicherweise weniger regelmäßig platzieren. </font><font style="vertical-align: inherit;">Wie bei anderen Geländemerkmalen können wir anhand der Hash-Tabelle entscheiden, ob der Turm in eine Ecke gestellt werden soll. </font><font style="vertical-align: inherit;">Dazu verwenden wir die Mitte der Ecke, um die Tabelle abzutasten, und vergleichen dann einen der Hash-Werte mit dem Schwellenwert der Türme.</font></font><br><br><pre> <code class="cs hljs"> HexHash hash = HexMetrics.SampleHashGrid( (pivot + left + right) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>) ); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasTower = hash.e &lt; HexMetrics.wallTowerThreshold; AddWallSegment(pivot, left, pivot, right, hasTower);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Schwellenwert bezieht sich auf </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mit einem Wert von 0,5 werden Türme in der Hälfte der Fälle erstellt, aber wir können Wände mit vielen Türmen oder ohne sie erstellen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> wallTowerThreshold = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b54/40c/f0f/b5440cf0ffa4f615f2dcbf37532bbb0a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zufällige Türme.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir entfernen die Türme von den Hängen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt platzieren wir Türme unabhängig von der Form des Geländes. </font><font style="vertical-align: inherit;">An den Hängen des Turms wirken sie jedoch unlogisch. </font><font style="vertical-align: inherit;">Hier verlaufen die Wände schräg und können die Turmspitze durchschneiden.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/24c/c5e/2dd/24cc5e2ddb97b83d14e0826bc64e3f20.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Türme an den Pisten. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um Steigungen zu vermeiden, prüfen wir, ob sich die Zellen der rechten und linken Ecke auf derselben Höhe befinden. </font><font style="vertical-align: inherit;">Nur in diesem Fall ist es möglich, einen Turm zu platzieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasTower = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.Elevation == rightCell.Elevation) { HexHash hash = HexMetrics.SampleHashGrid( (pivot + left + right) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>) ); hasTower = hash.e &lt; HexMetrics.wallTowerThreshold; } AddWallSegment(pivot, left, pivot, right, hasTower);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/770/1b4/fd9/7701b4fd9d0a4952fce2a9e00bbb4571.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt keine Türme mehr an den Wänden der Pisten.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir stellen die Mauern und Türme auf den Boden </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl wir Wände an Hängen vermeiden, kann das Relief auf beiden Seiten der Wand immer noch unterschiedliche Höhen haben. </font><font style="vertical-align: inherit;">Wände können entlang von Leisten verlaufen, und Zellen gleicher Höhe können unterschiedliche vertikale Positionen haben. </font><font style="vertical-align: inherit;">Aus diesem Grund kann sich die Basis des Turms in der Luft befinden.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd2/4d8/b10/cd24d8b1012804af5d073c3901c874ad.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Türme in der Luft. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tatsächlich können die Wände an den Hängen auch in der Luft hängen, aber dies ist nicht so auffällig wie bei den Türmen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8b6/ae3/d24/8b6ae3d2489f253ae1a78593af0abd6c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wände sind in der Luft. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies kann behoben werden, indem die Basis der Wände und Türme auf den Boden gespannt wird. </font><font style="vertical-align: inherit;">Fügen Sie dazu den Y-Versatz für die Wände in hinzu </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Eine Einheit weniger wird ausreichen. </font><font style="vertical-align: inherit;">Erhöhen Sie die Höhe der Türme um den gleichen Betrag.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> wallHeight = <span class="hljs-number"><span class="hljs-number">4f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> wallYOffset = <span class="hljs-number"><span class="hljs-number">-1f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir ändern es </font></font><code>HexMetrics.WallLerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so, dass bei der Bestimmung der Y-Koordinate der neue Versatz berücksichtigt wird.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WallLerp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 near, Vector3 far</span></span></span><span class="hljs-function">)</span></span> { near.x += (far.x - near.x) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; near.z += (far.z - near.z) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> v = near.y &lt; far.y ? wallElevationOffset : (<span class="hljs-number"><span class="hljs-number">1f</span></span> - wallElevationOffset); near.y += (far.y - near.y) * v + wallYOffset; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> near; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir müssen auch das Fertighaus des Turms ändern, da die Basis jetzt eine Einheit unter der Erde sein wird. </font><font style="vertical-align: inherit;">Daher erhöhen wir die Höhe des Basiswürfels um eine Einheit und ändern dementsprechend die lokale Position der Würfel.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2d/e4e/503/f2de4e50398fbae4ee296737dbe3a922.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecd/5d7/0eb/ecd5d70ebb620e3bae84f17aedb4a2a9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mauern und Türme auf dem Boden. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2>  Brücken </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu diesem Zeitpunkt haben wir Flüsse und Straßen, aber Straßen können Flüsse in keiner Weise überqueren. </font><font style="vertical-align: inherit;">Es ist der richtige Zeitpunkt, um Brücken hinzuzufügen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beginnen wir mit einem einfachen skalierten Würfel, der die Rolle einer vorgefertigten Brücke spielt. </font><font style="vertical-align: inherit;">Die Breite der Flüsse variiert, aber es gibt ungefähr sieben Abstandseinheiten zwischen den Straßenzentren auf beiden Seiten. </font><font style="vertical-align: inherit;">Daher geben wir eine ungefähre Skala (3, 1, 7). </font><font style="vertical-align: inherit;">Fügen Sie vorgefertigtes rotes städtisches Material hinzu und entfernen Sie den Collider. </font><font style="vertical-align: inherit;">Platzieren Sie den Würfel wie bei Türmen mit derselben Skalierung im Stammobjekt. </font><font style="vertical-align: inherit;">Aus diesem Grund ist die Geometrie der Brücke selbst nicht wichtig. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie einen Link zum Fertighaus der Brücke hinzu </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und weisen Sie ihm ein Fertighaus zu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform wallTower, bridge;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/808/ac6/dc5/808ac6dc523d16d2005da48dcf4d1f65.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zugewiesenes Brückenfertigteil.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Platzierung von Brücken </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Brücke zu platzieren, brauchen wir eine Methode </font></font><code>HexFeatureManager.AddBridge</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die Brücke sollte sich zwischen der Mitte des Flusses und einer der Seiten des Flusses befinden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddBridge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 roadCenter1, Vector3 roadCenter2</span></span></span><span class="hljs-function">)</span></span> { Transform instance = Instantiate(bridge); instance.localPosition = (roadCenter1 + roadCenter2) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir werden unverzerrte Straßenzentren übertragen, daher müssen wir sie verzerren, bevor wir die Brücke platzieren. </font></font><br><br><pre> <code class="cs hljs"> roadCenter1 = HexMetrics.Perturb(roadCenter1); roadCenter2 = HexMetrics.Perturb(roadCenter2); Transform instance = Instantiate(bridge);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Brücke richtig auszurichten, können wir den gleichen Ansatz wie beim Drehen der Türme verwenden. </font><font style="vertical-align: inherit;">In diesem Fall definieren die Straßenmitten den Vorwärtsvektor der Brücke. </font><font style="vertical-align: inherit;">Da wir in derselben Zelle bleiben, ist dieser Vektor definitiv horizontal, sodass wir seine Komponente Y nicht auf Null setzen müssen.</font></font><br><br><pre> <code class="cs hljs"> Transform instance = Instantiate(bridge); instance.localPosition = (roadCenter1 + roadCenter2) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.forward = roadCenter2 - roadCenter1; instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir bauen Brücken über gerade Flüsse </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die einzigen Flusskonfigurationen, die Brücken erfordern, sind gerade und gekrümmt. Straßen können durch Endpunkte verlaufen, und im Zickzack können Straßen nur in der Nähe sein. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns zunächst gerade Flüsse herausfinden. Im Inneren </font><font style="vertical-align: inherit;">ordnet </font><font style="vertical-align: inherit;">der </font></font><code>HexGridChunk.TriangulateRoadAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erste Betreiber </font></font><code>else if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Straßen in der Nähe solcher Flüsse an. Deshalb werden wir hier Brücken hinzufügen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir sind auf einer Seite des Flusses. Das Zentrum der Straße bewegt sich vom Fluss weg, und dann verschiebt sich auch das Zentrum der Zelle. Um die Mitte der Straße auf der gegenüberliegenden Seite zu finden, müssen wir die entgegengesetzte Richtung um den gleichen Betrag bewegen. Dies muss erfolgen, bevor das Zentrum selbst geändert wird.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Opposite()) { … roadCenter += corner * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; features.AddBridge(roadCenter, center - corner * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); center += corner * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97c/c7f/420/97cc7f42004ba86c6cd0333af352f24b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brücken über gerade Flüsse. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brücken sind erschienen! </font><font style="vertical-align: inherit;">Aber jetzt haben wir eine Instanz von Brücken für jede Richtung, durch die der Fluss nicht fließt. </font><font style="vertical-align: inherit;">Wir müssen sicherstellen, dass nur eine Instanz der Brücke in der Zelle generiert wird. </font><font style="vertical-align: inherit;">Dies kann durch Auswahl einer Richtung relativ zum Fluss und auf dessen Grundlage zur Erzeugung einer Brücke erfolgen. </font><font style="vertical-align: inherit;">Sie können eine beliebige Richtung wählen.</font></font><br><br><pre> <code class="cs hljs"> roadCenter += corner * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == direction.Next()) { features.AddBridge(roadCenter, center - corner * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); } center += corner * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Außerdem müssen wir nur dann eine Brücke hinzufügen, wenn es auf beiden Seiten des Flusses eine Straße gibt. </font><font style="vertical-align: inherit;">Im Moment sind wir uns bereits sicher, dass es auf der aktuellen Seite eine Straße gibt. </font><font style="vertical-align: inherit;">Daher müssen Sie überprüfen, ob sich auf der anderen Seite des Flusses eine Straße befindet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == direction.Next() &amp;&amp; ( cell.HasRoadThroughEdge(direction.Next2()) || cell.HasRoadThroughEdge(direction.Opposite()) )) { features.AddBridge(roadCenter, center - corner * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/635/a47/978/635a4797816f9f35297f67224a0ec449.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brücken zwischen den Straßen auf beiden Seiten.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Brücken über geschwungene Flüsse </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brücken über gekrümmte Flüsse funktionieren ähnlich, aber ihre Topologie unterscheidet sich geringfügig. </font><font style="vertical-align: inherit;">Wir werden eine Brücke hinzufügen, wenn wir uns außerhalb der Kurve befinden. </font><font style="vertical-align: inherit;">Dies geschieht im letzten Block </font></font><code>else</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es verwendet die mittlere Richtung, um die Mitte der Straße zu versetzen. </font><font style="vertical-align: inherit;">Wir müssen diesen Offset zweimal mit verschiedenen Maßstäben verwenden, also speichern Sie ihn in einer Variablen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { HexDirection middle; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { middle = direction.Next(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextHasRiver) { middle = direction.Previous(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { middle = direction; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !cell.HasRoadThroughEdge(middle) &amp;&amp; !cell.HasRoadThroughEdge(middle.Previous()) &amp;&amp; !cell.HasRoadThroughEdge(middle.Next()) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 offset = HexMetrics.GetSolidEdgeMiddle(middle); roadCenter += offset * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Verschiebungsskala an der Außenseite der Kurve beträgt 0,25 und an der Innenseite </font></font><code>HexMetrics.innerToOuter * 0.7f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir benutzen es, um die Brücke zu platzieren.</font></font><br><br><pre> <code class="cs hljs"> Vector3 offset = HexMetrics.GetSolidEdgeMiddle(middle); roadCenter += offset * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; features.AddBridge( roadCenter, center - offset * (HexMetrics.innerToOuter * <span class="hljs-number"><span class="hljs-number">0.7f</span></span>) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/612/f9e/da9/612f9eda9f9e4cd31ba20dfe2db7687b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brücken über geschwungene Flüsse. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auch hier müssen doppelte Brücken vermieden werden. </font><font style="vertical-align: inherit;">Wir können dies tun, indem wir Brücken nur aus der mittleren Richtung hinzufügen.</font></font><br><br><pre> <code class="cs hljs"> Vector3 offset = HexMetrics.GetSolidEdgeMiddle(middle); roadCenter += offset * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction == middle) { features.AddBridge( roadCenter, center - offset * (HexMetrics.innerToOuter * <span class="hljs-number"><span class="hljs-number">0.7f</span></span>) ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und wieder müssen Sie sicherstellen, dass sich die Straße auf der gegenüberliegenden Seite befindet. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( direction == middle &amp;&amp; cell.HasRoadThroughEdge(direction.Opposite()) ) { features.AddBridge( roadCenter, center - offset * (HexMetrics.innerToOuter * <span class="hljs-number"><span class="hljs-number">0.7f</span></span>) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/744/33c/275/74433c2750e413c44d17139982ecff3b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brücken zwischen den Straßen auf beiden Seiten.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Brückenskalierung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir das Gelände verzerren, variiert der Abstand zwischen den Straßenmitten und den gegenüberliegenden Seiten des Flusses. </font><font style="vertical-align: inherit;">Manchmal sind die Brücken zu kurz, manchmal zu lang.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/770/f2c/e53/770f2ce537ab16628c799eceb6ca4ad7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterschiedliche Abstände bei konstanten Brückenlängen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl wir eine Brücke mit einer Länge von sieben Einheiten erstellt haben, können Sie sie so skalieren, dass sie dem tatsächlichen Abstand zwischen den Straßenmitten entspricht. </font><font style="vertical-align: inherit;">Dies bedeutet, dass das Brückenmodell deformiert ist. </font><font style="vertical-align: inherit;">Da die Abstände nicht sehr unterschiedlich sind, kann eine Verformung akzeptabler sein als Brücken, die für die Länge nicht geeignet sind. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um eine ordnungsgemäße Skalierung durchzuführen, müssen wir die Anfangslänge des Brückenfertigteils kennen. </font><font style="vertical-align: inherit;">Wir werden diese Länge in speichern </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bridgeDesignLength = <span class="hljs-number"><span class="hljs-number">7f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir den Maßstab entlang der Z-Instanz der Brücke dem Abstand zwischen den Straßenmitten, geteilt durch die ursprüngliche Länge, zuordnen. </font><font style="vertical-align: inherit;">Da die Wurzel des Fertighauses der Brücke den gleichen Maßstab hat, wird die Brücke korrekt gedehnt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddBridge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 roadCenter1, Vector3 roadCenter2</span></span></span><span class="hljs-function">)</span></span> { roadCenter1 = HexMetrics.Perturb(roadCenter1); roadCenter2 = HexMetrics.Perturb(roadCenter2); Transform instance = Instantiate(bridge); instance.localPosition = (roadCenter1 + roadCenter2) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.forward = roadCenter2 - roadCenter1; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> length = Vector3.Distance(roadCenter1, roadCenter2); instance.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3( <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, length * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / HexMetrics.bridgeDesignLength) ); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21e/b73/49c/21eb7349c5e7ae6d5480b2e61d19e046.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die wechselnde Länge der Brücken. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Brückenbau </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anstelle eines einfachen Würfels können wir ein interessanteres Brückenmodell verwenden. </font><font style="vertical-align: inherit;">Sie können beispielsweise eine grobe Bogenbrücke aus drei skalierten und gedrehten Würfeln erstellen. </font><font style="vertical-align: inherit;">Natürlich können Sie viel komplexere 3D-Modelle erstellen, einschließlich Teilen der Straße. </font><font style="vertical-align: inherit;">Beachten Sie jedoch, dass das gesamte Objekt leicht komprimiert und gedehnt wird.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eee/83f/3b6/eee83f3b67cf879abe3114117614af08.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a9/741/f7f/8a9741f7f024aa8914e29b12c1ae9d94.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bogenbrücken unterschiedlicher Länge. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spezielle Objekte </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher können unsere Zellen städtische, ländliche und pflanzliche Objekte enthalten. Obwohl jede von ihnen drei Ebenen hat, sind alle Objekte im Vergleich zur Größe der Zelle recht klein. Was ist, wenn wir ein großes Gebäude wie eine Burg brauchen? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen wir dem Gelände einen speziellen Objekttyp hinzu. Solche Objekte sind so groß, dass sie die gesamte Zelle einnehmen. Jedes dieser Objekte ist einzigartig und benötigt ein eigenes Fertighaus. Zum Beispiel kann eine einfache Burg aus einem zentralen Würfel plus vier Ecktürmen erstellt werden. Die Skala (6, 4, 6) für den zentralen Würfel erzeugt eine ausreichend große Verriegelung, die dennoch auch in eine stark deformierte Zelle passt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e1/9bf/0dc/7e19bf0dc5f1568bf4b21ec467ba9063.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fertighaus der Burg. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein weiteres spezielles Objekt kann beispielsweise eine Zikkurat sein, die aus drei übereinander angeordneten Würfeln besteht. </font><font style="vertical-align: inherit;">Für den unteren Würfel ist die Skala (8, 2,5, 8) geeignet.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ad/7d3/291/1ad7d3291224358562b3472f528973a1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fertige Zikkurat. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spezielle Objekte können beliebig sein, nicht unbedingt architektonisch. </font><font style="vertical-align: inherit;">Beispielsweise kann eine Gruppe von massiven Bäumen mit einer Höhe von bis zu zehn Einheiten auf eine mit Megaflora gefüllte Zelle hinweisen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1bb/e91/907/1bbe91907deba70f6ab9d02cd13de795.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fertige Megaflora. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie dem </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Array hinzu, um diese Fertighäuser zu verfolgen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform[] special;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fügen Sie zuerst eine Burg zum Array hinzu, dann Zikkurat und dann Megaflora. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bbc/2e3/e94/bbc2e3e949b25efc800a8f2e799490c7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anpassung von Spezialobjekten.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zellen zu etwas Besonderem machen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist ein Index spezieller Objekte erforderlich, der den Typ eines speziellen Objekts bestimmt, wenn es sich dort befindet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> specialIndex;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Geben wir ihm wie anderen Reliefobjekten die Möglichkeit, diesen Wert zu empfangen und einzustellen. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SpecialIndex { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> specialIndex; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (specialIndex != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { specialIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; RefreshSelfOnly(); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standardmäßig enthält die Zelle kein spezielles Objekt. </font><font style="vertical-align: inherit;">Wir bezeichnen dies mit dem Index 0. Fügen Sie eine Eigenschaft hinzu, die diesen Ansatz verwendet, um festzustellen, ob eine Zelle etwas Besonderes ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsSpecial { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> specialIndex &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie zum Bearbeiten von Zellen Unterstützung für den Index spezieller Objekte in hinzu </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es funktioniert ähnlich wie städtische, ländliche und pflanzliche Einrichtungen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> activeUrbanLevel, activeFarmLevel, activePlantLevel, activeSpecialIndex; … <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> applyUrbanLevel, applyFarmLevel, applyPlantLevel, applySpecialIndex; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetApplySpecialIndex</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { applySpecialIndex = toggle; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetSpecialIndex</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span> { activeSpecialIndex = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)index; } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { cell.Color = activeColor; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyElevation) { cell.Elevation = activeElevation; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyWaterLevel) { cell.WaterLevel = activeWaterLevel; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applySpecialIndex) { cell.SpecialIndex = activeSpecialIndex; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyUrbanLevel) { cell.UrbanLevel = activeUrbanLevel; } … } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie der Benutzeroberfläche einen Schieberegler hinzu, um das spezielle Objekt zu steuern. </font><font style="vertical-align: inherit;">Da wir drei Objekte haben, verwenden wir das Intervall 0–3 im Schieberegler. </font><font style="vertical-align: inherit;">Null bedeutet das Fehlen eines Objekts, eines - einer Burg, zwei - Zikkurat, drei - Megaflora.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab4/2ea/9bf/ab42ea9bf68565a294f4ded5d2d7ebf0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schieberegler für spezielle Objekte.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spezielle Objekte hinzufügen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir den Zellen spezielle Objekte zuweisen. </font><font style="vertical-align: inherit;">Damit sie angezeigt werden, müssen wir eine </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">andere Methode </font><font style="vertical-align: inherit;">hinzufügen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es wird einfach eine Instanz des gewünschten Spezialobjekts erstellt und an der gewünschten Position platziert. </font><font style="vertical-align: inherit;">Da Null das Fehlen eines Objekts anzeigt, müssen wir die Einheit vom Index der speziellen Objekte der Zelle abziehen, bevor wir Zugriff auf das Array von Fertighäusern erhalten.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddSpecialFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Transform instance = Instantiate(special[cell.SpecialIndex - <span class="hljs-number"><span class="hljs-number">1</span></span>]); instance.localPosition = HexMetrics.Perturb(position); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Geben Sie dem Objekt mithilfe der Hash-Tabelle eine beliebige Drehung. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddSpecialFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Transform instance = Instantiate(special[cell.SpecialIndex - <span class="hljs-number"><span class="hljs-number">1</span></span>]); instance.localPosition = HexMetrics.Perturb(position); HexHash hash = HexMetrics.SampleHashGrid(position); instance.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span> * hash.e, <span class="hljs-number"><span class="hljs-number">0f</span></span>); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Triangulieren einer Zelle </font></font><code>HexGridChunk.Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prüfen </font><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">, ob die Zelle ein spezielles Objekt enthält. </font><font style="vertical-align: inherit;">Wenn ja, dann nennen wir unsere neue Methode genau so </font></font><code>AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { Triangulate(d, cell); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !cell.HasRiver &amp;&amp; !cell.HasRoads) { features.AddFeature(cell, cell.Position); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsSpecial) { features.AddSpecialFeature(cell, cell.Position); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b69/242/657/b692426576e292bbdc9ed0752624db51.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spezielle Objekte. </font><font style="vertical-align: inherit;">Sie sind viel größer als gewöhnlich.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vermeiden Sie die Flüsse </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Da sich spezielle Objekte in der Mitte der Zellen befinden, verbinden sie sich nicht mit den Flüssen, da sie über ihnen hängen. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a51/92f/cc2/a5192fcc2c5718f33bafc631f60a07a8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objekte auf den Flüssen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um zu verhindern, dass spezielle Objekte auf den Flüssen erstellt werden, ändern wir die Eigenschaft </font></font><code>HexCell.SpecialIndex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir werden den Index nur ändern, wenn sich keine Flüsse in der Zelle befinden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SpecialIndex { … <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (specialIndex != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &amp;&amp; !HasRiver) { specialIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; RefreshSelfOnly(); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir einen Fluss hinzufügen, müssen wir außerdem alle speziellen Objekte entfernen. </font><font style="vertical-align: inherit;">Der Fluss sollte sie abwaschen. </font><font style="vertical-align: inherit;">Dies kann erreicht werden, </font></font><code>HexCell.SetOutgoingRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indem der Index spezieller Objekte </font><font style="vertical-align: inherit;">in der Methode </font><font style="vertical-align: inherit;">auf 0 gesetzt </font><font style="vertical-align: inherit;">wird </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetOutgoingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { … hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; outgoingRiver = direction; specialIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; neighbor.RemoveIncomingRiver(); neighbor.hasIncomingRiver = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; neighbor.incomingRiver = direction.Opposite(); neighbor.specialIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; SetRoad((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir meiden Straßen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Flüsse verlaufen auch Straßen schlecht mit speziellen Gegenständen, aber nicht alles ist so schrecklich. </font><font style="vertical-align: inherit;">Sie können die Straßen sogar so lassen, wie sie sind. </font><font style="vertical-align: inherit;">Einige Einrichtungen sind möglicherweise mit Straßen kompatibel, andere möglicherweise nicht. </font><font style="vertical-align: inherit;">Daher können Sie sie vom Objekt abhängig machen. </font><font style="vertical-align: inherit;">Aber wir werden es einfacher machen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b3b/ebf/939/b3bebf9399ed016e8d79a4c1ee53ace8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objekte auf der Straße. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie in diesem Fall die Spezialobjekte die Straße besiegen. </font><font style="vertical-align: inherit;">Wenn Sie den Index spezieller Objekte ändern, werden daher auch alle Straßen aus der Zelle entfernt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SpecialIndex { … <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (specialIndex != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &amp;&amp; !HasRiver) { specialIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; RemoveRoads(); RefreshSelfOnly(); } } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist, wenn wir ein bestimmtes Objekt löschen?</font></font></b> <div class="spoiler_text">      0,   ,       .            . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies bedeutet außerdem, dass wir beim Hinzufügen von Straßen zusätzliche Überprüfungen durchführen müssen. </font><font style="vertical-align: inherit;">Wir werden nur Straßen hinzufügen, wenn keine der Zellen eine Zelle mit einem speziellen Objekt ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] &amp;&amp; !HasRiverThroughEdge(direction) &amp;&amp; !IsSpecial &amp;&amp; !GetNeighbor(direction).IsSpecial &amp;&amp; GetElevationDifference(direction) &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> ) { SetRoad((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vermeiden Sie andere Gegenstände </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spezielle Objekte können nicht mit anderen Objekttypen gemischt werden. </font><font style="vertical-align: inherit;">Wenn sie sich überlappen, sieht es unordentlich aus. </font><font style="vertical-align: inherit;">Es kann auch von einem bestimmten Objekt abhängen, aber wir werden den gleichen Ansatz verwenden.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/03b/7f1/8fc/03b7f18fc9f9d7543bdb0d9c24a074e2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Objekt, das sich mit anderen Objekten schneidet. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Fall unterdrücken wir kleinere Objekte, als wären sie unter Wasser. </font><font style="vertical-align: inherit;">Diesmal werden wir einchecken </font></font><code>HexFeatureManager.AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsSpecial) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } … }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vermeiden Sie Wasser </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben auch ein Problem mit Wasser. </font><font style="vertical-align: inherit;">Bleiben die Besonderheiten während des Hochwassers bestehen? </font><font style="vertical-align: inherit;">Da wir kleine Objekte in überfluteten Zellen zerstören, machen wir dasselbe mit speziellen Objekten.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d9/479/e79/8d9479e79cb0555c81f562dc32937552.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gegenstände im Wasser. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In werden </font></font><code>HexGridChunk.Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir den gleichen Hochwassercheck für spezielle und gewöhnliche Objekte durchführen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { Triangulate(d, cell); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !cell.HasRiver &amp;&amp; !cell.HasRoads) { features.AddFeature(cell, cell.Position); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; cell.IsSpecial) { features.AddSpecialFeature(cell, cell.Position); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da beide Bediener </font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jetzt prüfen, ob sich die Zelle unter Wasser befindet, können wir den Test übertragen und nur einmal durchführen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { Triangulate(d, cell); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.HasRiver &amp;&amp; !cell.HasRoads) { features.AddFeature(cell, cell.Position); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsSpecial) { features.AddSpecialFeature(cell, cell.Position); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für Experimente wird uns eine solche Anzahl von Objekten ausreichen. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425463/">https://habr.com/ru/post/de425463/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425449/index.html">Aktualisierung des Ansatzes für kontextbezogene Werbung: Yandex.Direct Turbo Pages</a></li>
<li><a href="../de425453/index.html">Von Space Invaders zu Half Life 2: Die Geschichte von Game Dzdoks</a></li>
<li><a href="../de425457/index.html">Zwanzig Rätsel (in verrückter, erstaunlicher Geometrie)</a></li>
<li><a href="../de425459/index.html">Ein Upgrade auf Windows 1809 zerstört (manchmal) alle Dateien in einem Profil</a></li>
<li><a href="../de425461/index.html">Devops and Security: Interviews mit Seth Wargo und Liz Rice</a></li>
<li><a href="../de425465/index.html">Wie ein Designer mehr verdienen kann, ein ideales Werkzeug zum Arbeiten und Suchen nach Ideen</a></li>
<li><a href="../de425467/index.html">Motoren Renault D4F> B4D (auch bekannt als SCe). Generationswechsel. Autofahrer schauen</a></li>
<li><a href="../de425469/index.html">Der Python-Autor leitet die Entwicklung nicht mehr. Wird es die Sprache besser oder schlechter machen?</a></li>
<li><a href="../de425471/index.html">Arbeiten mit Bildern in Python</a></li>
<li><a href="../de425473/index.html">Konferenz über Python und über Kommunikation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>