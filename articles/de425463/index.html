<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äç‚úàÔ∏è üàÇÔ∏è üë° Unity Hexagon Maps: Wasser, Sehensw√ºrdigkeiten und Festungsmauern ‚úîÔ∏è ü§∂ üë®üèø‚ÄçüöÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Teile 1-3: Netz, Farben und Zellenh√∂hen 

 Teile 4-7: Unebenheiten, Fl√ºsse und Stra√üen 

 Teile 8-11: Wasser, Landformen und W√§lle 

 Teile 12-15: Spe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unity Hexagon Maps: Wasser, Sehensw√ºrdigkeiten und Festungsmauern</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425463/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 1-3: Netz, Farben und Zellenh√∂hen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 4-7: Unebenheiten, Fl√ºsse und Stra√üen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 8-11: Wasser, Landformen und W√§lle</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 12-15: Speichern und Laden, Texturen, Entfernungen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 16-19: Weg finden, Spielerkader, Animationen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 20-23: Nebel des Krieges, Kartenforschung, Verfahrensgenerierung</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 24-27: Wasserkreislauf, Erosion, Biomes, zylindrische Karte</a> <br><br><h1>  Teil 8: Wasser </h1><br><ul><li>  Wasser in die Zellen geben. </li><li>  Triangulieren Sie die Wasseroberfl√§che. </li><li>  Erstellen Sie eine Brandung mit Schaum. </li><li>  Kombinieren Sie Wasser und Fl√ºsse. </li></ul><br>  Wir haben bereits Flussunterst√ºtzung hinzugef√ºgt, und in diesem Teil werden wir die Zellen vollst√§ndig in das Wasser eintauchen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a9/73c/b6e/2a973cb6eb97eba7d04a325f3ac89a3e.jpg"></div><br>  <i>Wasser kommt.</i> <br><a name="habracut"></a><br><h2>  Wasserstand </h2><br>  Am einfachsten ist es, die Wasserunterst√ºtzung zu implementieren, indem Sie sie auf das gleiche Niveau einstellen.  Alle Zellen, deren H√∂he unter diesem Niveau liegt, werden in Wasser getaucht.  Ein flexiblerer Weg w√§re jedoch, das Wasser in unterschiedlichen H√∂hen zu halten. Lassen Sie uns also den Wasserstand ver√§nderbar machen.  Dazu muss <code>HexCell</code> den Wasserstand √ºberwachen. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> WaterLevel { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> waterLevel; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (waterLevel == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } waterLevel = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Refresh(); } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> waterLevel;</code> </pre> <br>  Falls gew√ºnscht, k√∂nnen Sie sicherstellen, dass bestimmte Merkmale des Reliefs unter Wasser nicht vorhanden waren.  Aber im Moment werde ich das nicht tun.  Dinge wie Unterwasserstra√üen passen zu mir.  Sie k√∂nnen als Gebiete betrachtet werden, die k√ºrzlich √ºberflutet wurden. <br><br><h3>  Zellen √ºberfluten </h3><br>  Jetzt, wo wir Wasserst√§nde haben, ist die wichtigste Frage, ob sich die Zellen unter Wasser befinden.  Eine Zelle befindet sich unter Wasser, wenn ihr Wasserstand √ºber ihrer H√∂he liegt.  Um diese Informationen zu erhalten, f√ºgen wir eine Eigenschaft hinzu. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsUnderwater { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> waterLevel &gt; elevation; } }</code> </pre> <br>  Dies bedeutet, dass sich die Zelle bei gleichem Wasserstand und gleicher H√∂he √ºber das Wasser erhebt.  Das hei√üt, die reale Wasseroberfl√§che befindet sich unterhalb dieser H√∂he.  <code>HexMetrics.riverSurfaceElevationOffset</code> wir wie bei Flussoberfl√§chen den gleichen Versatz hinzu - <code>HexMetrics.riverSurfaceElevationOffset</code> .  √Ñndern Sie den Namen in einen allgemeineren. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public const float riverSurfaceElevationOffset = -0.5f; public const float waterElevationOffset = -0.5f;</span></span></code> </pre> <br>  √Ñndern Sie <code>HexCell.RiverSurfaceY</code> so, dass der neue Name verwendet wird.  Dann f√ºgen wir der Wasseroberfl√§che der √ºberfluteten Zelle eine √§hnliche Eigenschaft hinzu. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> RiverSurfaceY { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (elevation + HexMetrics.waterElevationOffset) * HexMetrics.elevationStep; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> WaterSurfaceY { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (waterLevel + HexMetrics.waterElevationOffset) * HexMetrics.elevationStep; } }</code> </pre> <br><h3>  Wasserbearbeitung </h3><br>  Das Bearbeiten des Wasserstandes √§hnelt dem √Ñndern der H√∂he.  Daher muss <code>HexMapEditor</code> den aktiven Wasserstand √ºberwachen und pr√ºfen, ob er auf die Zellen angewendet werden soll. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> activeElevation; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> activeWaterLevel; ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> applyElevation = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> applyWaterLevel = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre><br>  F√ºgen Sie Methoden hinzu, um diese Parameter mit der Benutzeroberfl√§che zu verbinden. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetApplyWaterLevel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { applyWaterLevel = toggle; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetWaterLevel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level</span></span></span><span class="hljs-function">)</span></span> { activeWaterLevel = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)level; }</code> </pre> <br>  Und f√ºgen Sie den Wasserstand zu <code>EditCell</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { cell.Color = activeColor; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyElevation) { cell.Elevation = activeElevation; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyWaterLevel) { cell.WaterLevel = activeWaterLevel; } ‚Ä¶ } }</code> </pre> <br>  Um der Benutzeroberfl√§che einen Wasserstand hinzuzuf√ºgen, duplizieren Sie die Beschriftung und den H√∂henregler und √§ndern Sie sie dann.  Denken Sie daran, ihre Ereignisse an die entsprechenden Methoden anzuh√§ngen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/42b/a13/de4/42ba13de4120b43e460628021c77d99f.png"></div><br>  <i>Wasserstandsregler.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einheitspaket</a> <br><br><h2>  Wassertriangulation </h2><br>  Um Wasser zu triangulieren, brauchen wir ein neues Netz mit neuem Material.  Erstellen Sie zun√§chst einen <em>Wasser-</em> Shader, der den <em>River-</em> Shader dupliziert.  √Ñndern Sie es so, dass es die Farbeigenschaft verwendet. <br><br><pre> <code class="hljs pgsql">Shader "Custom/Water" { Properties { _Color ("Color", Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex ("Albedo (RGB)", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Glossiness ("Smoothness", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.5</span></span> _Metallic ("Metallic", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.0</span></span> } SubShader { Tags { "RenderType"="Transparent" "Queue"="Transparent" } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> CGPROGRAM #pragma surface surf Standard alpha #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; }; half _Glossiness; half _Metallic; fixed4 _Color; <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = _Color; o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; } ENDCG } FallBack "Diffuse" }</code> </pre> <br>  Erstellen Sie mit diesem Shader ein neues Material, indem Sie das <em>Wassermaterial</em> duplizieren und durch einen Shader ersetzen.  Lassen Sie die Rauschstruktur, da wir sie sp√§ter verwenden werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd9/238/283/fd9238283d92bacd26a3ff5dce73b17b.png"></div><br>  <i>Wassermaterial.</i> <br><br>  F√ºgen Sie dem Fertighaus ein neues Kind hinzu, indem Sie das <em>Rivers-</em> Kind duplizieren.  Er braucht keine UV-Koordinaten und er muss <em>Wasser verwenden</em> .  Wie √ºblich erstellen wir dazu eine Instanz des Fertighauses, √§ndern es und wenden die √Ñnderungen dann auf das Fertighaus an.  Entfernen Sie danach die Instanz. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ec/6e6/82f/6ec6e682f16c604d75c0e5b835d5b03e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c5/3f3/eeb/7c53f3eeb282e533f9f0b8a20e813091.png"></div><br>  <i>Kinderobjekt Wasser.</i> <br><br>  Als n√§chstes f√ºgen Sie <code>HexGridChunk</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMesh terrain, rivers, roads, water; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrain.Clear(); rivers.Clear(); roads.Clear(); water.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { Triangulate(cells[i]); } terrain.Apply(); rivers.Apply(); roads.Apply(); water.Apply(); }</code> </pre> <br>  Und verbinden Sie es mit dem Fertighaus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4d/19a/76a/b4d19a76a745d550314b277fd2c0e13c.png"></div><br>  <i>Das Wasserobjekt ist verbunden.</i> <br><br><h3>  Sechsecke aus Wasser </h3><br>  Da Wasser eine zweite Schicht bildet, geben wir ihm f√ºr jede Richtung unsere eigene Triangulationsmethode.  Wir m√ºssen es nur nennen, wenn die Zelle in Wasser getaucht ist. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { TriangulateWater(direction, cell, center); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br>  Wie bei Fl√ºssen variiert die H√∂he der Wasseroberfl√§che in Zellen mit gleichem Wasserstand nicht stark.  Daher scheinen wir keine komplexen Rippen zu ben√∂tigen.  Ein einfaches Dreieck wird ausreichen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { center.y = cell.WaterSurfaceY; Vector3 c1 = center + HexMetrics.GetFirstSolidCorner(direction); Vector3 c2 = center + HexMetrics.GetSecondSolidCorner(direction); water.AddTriangle(center, c1, c2); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a51/72b/99b/a5172b99ba382c6e79abff653e4b7fb2.png"></div><br>  <i>Sechsecke aus Wasser.</i> <br><br><h3>  Wasserverbindungen </h3><br>  Wir k√∂nnen benachbarte Zellen mit Wasser mit einem Viereck verbinden. <br><br><pre> <code class="cs hljs"> water.AddTriangle(center, c1, c2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { HexCell neighbor = cell.GetNeighbor(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || !neighbor.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 bridge = HexMetrics.GetBridge(direction); Vector3 e1 = c1 + bridge; Vector3 e2 = c2 + bridge; water.AddQuad(c1, c2, e1, e2); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a6/3af/949/0a63af9496da925e966b008f41f808a8.png"></div><br>  <i>Verbindungen der R√§nder des Wassers.</i> <br><br>  Und f√ºllen Sie die Ecken mit einem Dreieck. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { ‚Ä¶ water.AddQuad(c1, c2, e1, e2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E) { HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || !nextNeighbor.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } water.AddTriangle( c2, e2, c2 + HexMetrics.GetBridge(direction.Next()) ); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c32/37e/5b4/c3237e5b4e492f9a1c334f90aaa88ee4.png"></div><br>  <i>Fugen von Wasserecken.</i> <br><br>  Jetzt haben wir Wasserzellen angeschlossen, wenn sie in der N√§he sind.  Sie lassen eine L√ºcke zwischen sich und trockenen Zellen mit einer h√∂heren H√∂he, aber wir werden dies f√ºr sp√§ter belassen. <br><br><h3>  Harmonisierte Wasserst√§nde </h3><br>  Wir haben angenommen, dass benachbarte Unterwasserzellen den gleichen Wasserstand haben.  Wenn dies so ist, sieht alles gut aus, aber wenn diese Annahme verletzt wird, treten Fehler auf. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fcf/a8b/b4f/fcfa8bb4fb960ddc788d358e60f9023f.png"></div><br>  <i>Inkonsistenter Wasserstand.</i> <br><br>  Wir k√∂nnen daf√ºr sorgen, dass das Wasser auf dem gleichen Niveau bleibt.  Wenn sich beispielsweise der Wasserstand einer √ºberfluteten Zelle √§ndert, k√∂nnen wir die √Ñnderungen auf benachbarte Zellen √ºbertragen, um die Wasserst√§nde synchron zu halten.  Dieser Prozess sollte jedoch fortgesetzt werden, bis er auf Zellen trifft, die nicht in Wasser eingetaucht sind.  Diese Zellen definieren die Grenzen der Wassermasse. <br><br>  Die Gefahr dieses Ansatzes besteht darin, dass er schnell au√üer Kontrolle geraten kann.  Wenn die Bearbeitung nicht erfolgreich ist, kann Wasser die gesamte Karte bedecken.  Dann m√ºssen alle Fragmente gleichzeitig trianguliert werden, was zu einem enormen Anstieg der Verz√∂gerungen f√ºhrt. <br><br>  Also lass es uns noch nicht tun.  Diese Funktion kann in einem komplexeren Editor hinzugef√ºgt werden.  W√§hrend die Konsistenz des Wasserstandes, verlassen wir das Gewissen des Benutzers. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Einheitspaket</a> <br><br><h2>  Wasseranimation </h2><br>  Anstelle einer einheitlichen Farbe werden wir etwas erzeugen, das Wellen √§hnelt.  Wie bei anderen Shadern werden wir vorerst nicht nach einer sch√∂nen Grafik streben, sondern nur die Wellen bezeichnen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca1/a2f/1f9/ca1a2f1f978cd2f2993a96b44440227b.png"></div><br>  <i>Perfekt flaches Wasser.</i> <br><br>  Machen wir das, was wir mit den Fl√ºssen gemacht haben.  Wir probieren das Rauschen mit der Position der Welt aus und f√ºgen es einer einheitlichen Farbe hinzu.  F√ºgen Sie der V-Koordinate Zeit hinzu, um die Oberfl√§che zu animieren. <br><br><pre> <code class="hljs pgsql"> struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; float3 worldPos; }; ‚Ä¶ <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz; uv.y += _Time.y; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, uv * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); <span class="hljs-type"><span class="hljs-type">float</span></span> waves = noise.z; fixed4 c = saturate(_Color + waves); o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Scrollendes Wasser, Zeit √ó 10.</i> <br><br><h3>  Zwei Richtungen </h3><br>  Bisher ist das √ºberhaupt nicht wie Wellen.  Lassen Sie uns das Bild komplizieren, indem wir ein zweites Rauschmuster hinzuf√ºgen <br>  und diesmal Hinzuf√ºgen der U-Koordinate. Wir verwenden einen anderen Rauschkanal, um als Ergebnis zwei verschiedene Muster zu erhalten.  Die fertigen Wellen sind diese beiden zusammen gestapelten Samples. <br><br><pre> <code class="hljs pgsql"> float2 uv1 = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz; uv1.y += _Time.y; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise1 = tex2D(_MainTex, uv1 * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); float2 uv2 = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz; uv2.x += _Time.y; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise2 = tex2D(_MainTex, uv2 * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); <span class="hljs-type"><span class="hljs-type">float</span></span> waves = noise1.z + noise2.x;</code> </pre> <br>  Wenn wir beide Stichproben summieren, erhalten wir Ergebnisse im Intervall 0‚Äì2, daher m√ºssen wir sie auf 0‚Äì1 zur√ºckskalieren.  Anstatt die Wellen einfach in zwei <code>smoothstep</code> zu teilen, k√∂nnen wir die <code>smoothstep</code> Funktion verwenden, um ein interessanteres Ergebnis zu <code>smoothstep</code> .  Wir setzen ¬æ - 2 auf 0‚Äì1, damit keine sichtbaren Wellen auf der Wasseroberfl√§che sind. <br><br><pre> <code class="hljs mel"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> waves = noise1.z + noise2.x; waves = <span class="hljs-keyword"><span class="hljs-keyword">smoothstep</span></span>(<span class="hljs-number"><span class="hljs-number">0.75</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, waves);</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Zwei Richtungen, Zeit √ó 10.</i> <br><br><h3>  Wellen des Mischens </h3><br>  Es f√§llt immer noch auf, dass wir zwei sich bewegende Ger√§uschmuster haben, die sich nicht wirklich √§ndern.  Es w√§re plausibler, wenn sich die Muster √§ndern w√ºrden.  Wir k√∂nnen dies realisieren, indem wir zwischen verschiedenen Kan√§len von Rauschproben interpolieren.  Dies kann jedoch nicht auf die gleiche Weise erfolgen, da sich sonst gleichzeitig die gesamte Wasseroberfl√§che √§ndert, was sehr auff√§llig ist.  Stattdessen werden wir eine Welle der Verwirrung erzeugen. <br><br>  Wir werden mit Hilfe einer Sinuskurve eine Mischwelle erzeugen, die sich diagonal entlang der Wasseroberfl√§che bewegt.  Wir werden dies tun, indem wir die Weltkoordinaten X und Z addieren und die Summe als Eingabe f√ºr die <code>sin</code> Funktion verwenden.  Verkleinern Sie die Ansicht, um ausreichend gro√üe B√§nder zu erhalten.  Und nat√ºrlich f√ºgen wir den gleichen Wert hinzu, um sie zu animieren. <br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float</span></span> blendWave = sin((<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.x + <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.z) * <span class="hljs-number"><span class="hljs-number">0.1</span></span> + _Time.y);</code> </pre> <br>  Sinuswellen liegen zwischen -1 und 1, und wir ben√∂tigen ein Intervall von 0‚Äì1.  Sie k√∂nnen es erhalten, indem Sie die Welle quadrieren.  Um ein isoliertes Ergebnis anzuzeigen, verwenden Sie es anstelle der ge√§nderten Farbe als Ausgabewert. <br><br><pre> <code class="hljs pgsql"> sin((<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.x + <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.z) * <span class="hljs-number"><span class="hljs-number">0.1</span></span> + _Time.y); blendWave *= blendWave; <span class="hljs-type"><span class="hljs-type">float</span></span> waves = noise1.z + noise2.x; waves = smoothstep(<span class="hljs-number"><span class="hljs-number">0.75</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, waves); fixed4 c = blendWave; //saturate(_Color + waves);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa3/3d9/d70/aa33d9d70a022df57a0348423181b258.png"></div><br>  <i>Wellen des Mischens.</i> <br><br>  Um die Mischwellen weniger wahrnehmbar zu machen, f√ºgen Sie ihnen etwas Rauschen von beiden Samples hinzu. <br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float</span></span> blendWave = sin( (<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.x + <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.z) * <span class="hljs-number"><span class="hljs-number">0.1</span></span> + (noise1.y + noise2.z) + _Time.y ); blendWave *= blendWave;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/618/c8f/697/618c8f697cd2e463d7349030277d1a82.png"></div><br>  <i>Verzerrte Mischwellen.</i> <br><br>  Schlie√ülich verwenden wir eine Mischwelle, um zwischen den beiden Kan√§len beider Rauschproben zu interpolieren.  Nehmen Sie f√ºr maximale Variation vier verschiedene Kan√§le. <br><br><pre> <code class="hljs lisp"> float waves = lerp(<span class="hljs-name"><span class="hljs-name">noise1</span></span>.z, noise1.w, blendWave) + lerp(<span class="hljs-name"><span class="hljs-name">noise2</span></span>.x, noise2.y, blendWave)<span class="hljs-comment"><span class="hljs-comment">; waves = smoothstep(0.75, 2, waves); fixed4 c = saturate(_Color + waves);</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Wellen mischen, Zeit √ó 2.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Einheitspaket</a> <br><br><h2>  Die K√ºste </h2><br>  Wir sind mit offenem Wasser fertig, aber jetzt m√ºssen wir die L√ºcke im Wasser entlang der K√ºste f√ºllen.  Da wir uns an die Landkonturen anpassen m√ºssen, erfordert das K√ºstenwasser einen anderen Ansatz.  Teilen wir <code>TriangulateWater</code> in zwei Methoden ein - eine f√ºr offenes Wasser und eine f√ºr die K√ºste.  Um zu verstehen, wann wir mit der K√ºste arbeiten, m√ºssen wir uns die benachbarte Zelle ansehen.  Das hei√üt, in <code>TriangulateWater</code> wir einen Nachbarn bekommen.  Wenn es einen Nachbarn gibt und er nicht unter Wasser ist, dann haben wir es mit der K√ºste zu tun. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { center.y = cell.WaterSurfaceY; HexCell neighbor = cell.GetNeighbor(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; !neighbor.IsUnderwater) { TriangulateWaterShore(direction, cell, neighbor, center); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateOpenWater(direction, cell, neighbor, center); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateOpenWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { Vector3 c1 = center + HexMetrics.GetFirstSolidCorner(direction); Vector3 c2 = center + HexMetrics.GetSecondSolidCorner(direction); water.AddTriangle(center, c1, c2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE &amp;&amp; neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// HexCell neighbor = cell.GetNeighbor(direction); // if (neighbor == null || !neighbor.IsUnderwater) { // return; // } Vector3 bridge = HexMetrics.GetBridge(direction); ‚Ä¶ } } void TriangulateWaterShore ( HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center ) { }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f04/799/441/f0479944178dcb5646bbf935700a798e.png"></div><br>  <i>Es gibt keine Triangulation entlang der K√ºste.</i> <br><br>  Da die K√ºste verzerrt ist, m√ºssen wir die Wasserdreiecke entlang der K√ºste verzerren.  Deshalb brauchen wir die Kanten und einen F√§cher mit Dreiecken. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( center + HexMetrics.GetFirstSolidCorner(direction), center + HexMetrics.GetSecondSolidCorner(direction) ); water.AddTriangle(center, e1.v1, e1.v2); water.AddTriangle(center, e1.v2, e1.v3); water.AddTriangle(center, e1.v3, e1.v4); water.AddTriangle(center, e1.v4, e1.v5); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bbd/761/283/bbd76128386859bb388e6e2d3f105ff0.png"></div><br>  <i>Fans von Dreiecken entlang der K√ºste.</i> <br><br>  Als n√§chstes kommt ein Rippenstreifen, wie bei einem normalen Relief.  Wir sind jedoch nicht verpflichtet, uns nur auf bestimmte Gebiete zu beschr√§nken, da wir <code>TriangulateWaterShore</code> nur anrufen, wenn wir die K√ºste treffen, f√ºr die der Streifen immer ben√∂tigt wird. <br><br><pre> <code class="cs hljs"> water.AddTriangle(center, e1.v4, e1.v5); Vector3 bridge = HexMetrics.GetBridge(direction); EdgeVertices e2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( e1.v1 + bridge, e1.v5 + bridge ); water.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); water.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); water.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); water.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7da/fbc/aa9/7dafbcaa95a4b48509ab68fbf111c703.png"></div><br>  <i>Rippenstreifen entlang der K√ºste.</i> <br><br>  Ebenso m√ºssen wir jedes Mal ein eckiges Dreieck hinzuf√ºgen. <br><br><pre> <code class="cs hljs"> water.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { water.AddTriangle( e1.v5, e2.v5, e1.v5 + HexMetrics.GetBridge(direction.Next()) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/064/18f/8b1/06418f8b10cc0fc0a4e2276b86375385.png"></div><br>  <i>Die Ecken der Rippen entlang der K√ºste.</i> <br><br>  Jetzt haben wir Wasser f√ºr die K√ºste bereit.  Ein Teil davon befindet sich immer unterhalb des Reliefnetzes, sodass keine L√∂cher vorhanden sind. <br><br><h3>  UV-K√ºste </h3><br>  Wir k√∂nnen alles so lassen, wie es ist, aber es w√§re interessant, wenn das K√ºstenwasser einen eigenen Zeitplan h√§tte.  Zum Beispiel die Wirkung von Schaum, der bei Ann√§herung an die K√ºste gr√∂√üer wird.  Um es zu implementieren, muss der Shader wissen, wie nahe das Fragment an der K√ºste liegt.  Wir k√∂nnen diese Informationen √ºber UV-Koordinaten √ºbertragen. <br><br>  Offenes Wasser hat keine UV-Koordinaten und ben√∂tigt keinen Schaum.  Es wird nur f√ºr Wasser in K√ºstenn√§he ben√∂tigt.  Daher sind die Anforderungen f√ºr beide Wassertypen sehr unterschiedlich.  Es w√§re logisch, f√ºr jeden Typ ein eigenes Netz zu erstellen.  Aus diesem Grund f√ºgen wir HexGridChunk Unterst√ºtzung f√ºr ein anderes Netzobjekt hinzu. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMesh terrain, rivers, roads, water, waterShore; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrain.Clear(); rivers.Clear(); roads.Clear(); water.Clear(); waterShore.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { Triangulate(cells[i]); } terrain.Apply(); rivers.Apply(); roads.Apply(); water.Apply(); waterShore.Apply(); }</code> </pre> <br>  Dieses neue Netz verwendet <code>TriangulateWaterShore</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ waterShore.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); waterShore.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); waterShore.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); waterShore.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { waterShore.AddTriangle( e1.v5, e2.v5, e1.v5 + HexMetrics.GetBridge(direction.Next()) ); } }</code> </pre> <br>  Duplizieren Sie das Wasserobjekt, verbinden Sie es mit dem Fertighaus und stellen Sie es so ein, dass es UV-Koordinaten verwendet.  Wir erstellen auch einen Shader und ein Material f√ºr K√ºstenwasser, wobei der vorhandene Shader und das vorhandene Wassermaterial dupliziert werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/561/77e/e73/56177ee7331ce092a859a058645f0364.png"></div><br>  <i>Wasseruferanlage und UV-Material.</i> <br><br>  √Ñndern Sie den <em>Water Shore-</em> Shader so, dass anstelle von Wasser UV-Koordinaten angezeigt werden. <br><br><pre> <code class="hljs lisp"> fixed4 c = fixed4(<span class="hljs-name"><span class="hljs-name">IN</span></span>.uv_MainTex, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  Da noch keine Koordinaten festgelegt wurden, wird eine Volltonfarbe angezeigt.  Dank dessen ist leicht zu erkennen, dass die K√ºste tats√§chlich ein separates Netz mit Material verwendet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/630/45c/ec0/63045cec0f1f367bfee191f69cfa11ad.png"></div><br>  <i>Separates Netz f√ºr die K√ºste.</i> <br><br>  Lassen Sie uns die K√ºsteninformationen in Koordinate V einf√ºgen. Weisen Sie ihr auf der Wasserseite den Wert 0 zu, auf der Landseite den Wert 1. Da wir nichts anderes √ºbertragen m√ºssen, sind alle U-Koordinaten einfach 0. <br><br><pre> <code class="cs hljs"> waterShore.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); waterShore.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); waterShore.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); waterShore.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { waterShore.AddTriangle( e1.v5, e2.v5, e1.v5 + HexMetrics.GetBridge(direction.Next()) ); waterShore.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f4/3fa/f86/8f43faf864c259e21c2ce731d08f43f6.png"></div><br>  <i>√úberg√§nge zu den K√ºsten sind falsch.</i> <br><br>  Der obige Code funktioniert f√ºr Kanten, ist jedoch in einigen Winkeln falsch.  Wenn der n√§chste Nachbar unter Wasser ist, ist dieser Ansatz korrekt.  Wenn der n√§chste Nachbar nicht unter Wasser ist, befindet sich der dritte Gipfel des Dreiecks unter Land. <br><br><pre> <code class="cs hljs"> waterShore.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, nextNeighbor.IsUnderwater ? <span class="hljs-number"><span class="hljs-number">0f</span></span> : <span class="hljs-number"><span class="hljs-number">1f</span></span>) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2e/9e9/6e6/c2e9e96e63c161d0f71f81e31742af89.png"></div><br>  <i>√úberg√§nge zu den K√ºsten sind korrekt.</i> <br><br><h3>  Schaum an der K√ºste </h3><br>  Nachdem die √úberg√§nge zur K√ºste korrekt implementiert wurden, k√∂nnen Sie sie verwenden, um einen Schaumeffekt zu erzielen.  Am einfachsten ist es, den Wert der K√ºste einer einheitlichen Farbe hinzuzuf√ºgen. <br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float</span></span> shore = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y; <span class="hljs-type"><span class="hljs-type">float</span></span> foam = shore; fixed4 c = saturate(_Color + foam); o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef5/502/a56/ef5502a56ab665732312be25a6961817.png"></div><br>  <i>Linearer Schaum.</i> <br><br>  Um den Schaum interessanter zu machen, multiplizieren Sie ihn mit dem Quadrat der Sinuskurve. <br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float</span></span> foam = sin(shore * <span class="hljs-number"><span class="hljs-number">10</span></span>); foam *= foam * shore;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2e/acf/6d8/c2eacf6d83e9f7c1298cdd7a05e551d0.png"></div><br>  <i>Verblassender sinusf√∂rmiger quadratischer Schaum.</i> <br><br>  Lassen Sie uns die Schaumstofffront gr√∂√üer machen, wenn Sie sich dem Ufer n√§hern.  Dies kann erreicht werden, indem die Quadratwurzel gezogen wird, bevor der K√ºstenwert verwendet wird. <br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float</span></span> shore = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y; shore = sqrt(shore);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/762/675/e98/762675e987d119034cd5b643c86ca672.png"></div><br>  <i>Der Schaum wird in Ufern√§he dicker.</i> <br><br>  F√ºgen Sie Verzerrungen hinzu, damit es nat√ºrlicher aussieht.  Lassen Sie uns die Verzerrung schw√§cher machen, wenn wir uns der K√ºste n√§hern.  Es wird also besser sein, die K√ºste zu s√§umen. <br><br><pre> <code class="hljs pgsql"> float2 noiseUV = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, noiseUV * <span class="hljs-number"><span class="hljs-number">0.015</span></span>); <span class="hljs-type"><span class="hljs-type">float</span></span> distortion = noise.x * (<span class="hljs-number"><span class="hljs-number">1</span></span> - shore); <span class="hljs-type"><span class="hljs-type">float</span></span> foam = sin((shore + distortion) * <span class="hljs-number"><span class="hljs-number">10</span></span>); foam *= foam * shore;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31a/7fd/59a/31a7fd59ad215b200571133543f1406b.png"></div><br>  <i>Schaum mit Verzerrung.</i> <br><br>  Und nat√ºrlich animieren wir all dies: sowohl eine Sinuskurve als auch Verzerrungen. <br><br><pre> <code class="hljs pgsql"> float2 noiseUV = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz + _Time.y * <span class="hljs-number"><span class="hljs-number">0.25</span></span>; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, noiseUV * <span class="hljs-number"><span class="hljs-number">0.015</span></span>); <span class="hljs-type"><span class="hljs-type">float</span></span> distortion = noise.x * (<span class="hljs-number"><span class="hljs-number">1</span></span> - shore); <span class="hljs-type"><span class="hljs-type">float</span></span> foam = sin((shore + distortion) * <span class="hljs-number"><span class="hljs-number">10</span></span> - _Time.y); foam *= foam * shore;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Animierter Schaum.</i> <br><br>  Neben dem ankommenden Schaum gibt es auch einen zur√ºckgehenden.  F√ºgen wir eine zweite Sinuskurve hinzu, die sich in die entgegengesetzte Richtung bewegt, um sie zu simulieren.  Machen Sie es schw√§cher und f√ºgen Sie eine Zeitverschiebung hinzu.  Fertiger Schaum ist das Maximum dieser beiden Sinuskurven. <br><br><pre> <code class="hljs mel"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distortion1 = <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>.x * (<span class="hljs-number"><span class="hljs-number">1</span></span> - shore); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> foam1 = <span class="hljs-keyword"><span class="hljs-keyword">sin</span></span>((shore + distortion1) * <span class="hljs-number"><span class="hljs-number">10</span></span> - _Time.y); foam1 *= foam1; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distortion2 = <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>.y * (<span class="hljs-number"><span class="hljs-number">1</span></span> - shore); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> foam2 = <span class="hljs-keyword"><span class="hljs-keyword">sin</span></span>((shore + distortion2) * <span class="hljs-number"><span class="hljs-number">10</span></span> + _Time.y + <span class="hljs-number"><span class="hljs-number">2</span></span>); foam2 *= foam2 * <span class="hljs-number"><span class="hljs-number">0.7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> foam = <span class="hljs-keyword"><span class="hljs-keyword">max</span></span>(foam1, foam2) * shore;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Eingehender und zur√ºckgehender Schaum.</i> <br><br><h3>  Mischung aus Wellen und Schaum </h3><br>  Es gibt einen scharfen √úbergang zwischen offenem und K√ºstenwasser, da offene Wasserwellen nicht im K√ºstenwasser enthalten sind.  Um dies zu beheben, m√ºssen wir diese Wellen in den <em>Water Shore-</em> Shader aufnehmen. <br><br>  Anstatt den Wave-Code zu kopieren, f√ºgen wir ihn in die <em>Water.cginc-</em> Include-Datei ein.  Tats√§chlich f√ºgen wir Code sowohl f√ºr Schaum als auch f√ºr Wellen als separate Funktion ein. <br><br><div class="spoiler">  <b class="spoiler_title">Wie funktionieren Shader-Include-Dateien?</b> <div class="spoiler_text">  Das Erstellen eigener Include-Shader-Dateien wird im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rendering 5-</a> Lernprogramm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Multiple Lights behandelt</a> . </div></div><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> Foam (<span class="hljs-type"><span class="hljs-type">float</span></span> shore, float2 worldXZ, sampler2D noiseTex) { // <span class="hljs-type"><span class="hljs-type">float</span></span> shore = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y; shore = sqrt(shore); float2 noiseUV = worldXZ + _Time.y * <span class="hljs-number"><span class="hljs-number">0.25</span></span>; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(noiseTex, noiseUV * <span class="hljs-number"><span class="hljs-number">0.015</span></span>); <span class="hljs-type"><span class="hljs-type">float</span></span> distortion1 = noise.x * (<span class="hljs-number"><span class="hljs-number">1</span></span> - shore); <span class="hljs-type"><span class="hljs-type">float</span></span> foam1 = sin((shore + distortion1) * <span class="hljs-number"><span class="hljs-number">10</span></span> - _Time.y); foam1 *= foam1; <span class="hljs-type"><span class="hljs-type">float</span></span> distortion2 = noise.y * (<span class="hljs-number"><span class="hljs-number">1</span></span> - shore); <span class="hljs-type"><span class="hljs-type">float</span></span> foam2 = sin((shore + distortion2) * <span class="hljs-number"><span class="hljs-number">10</span></span> + _Time.y + <span class="hljs-number"><span class="hljs-number">2</span></span>); foam2 *= foam2 * <span class="hljs-number"><span class="hljs-number">0.7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> max(foam1, foam2) * shore; } <span class="hljs-type"><span class="hljs-type">float</span></span> Waves (float2 worldXZ, sampler2D noiseTex) { float2 uv1 = worldXZ; uv1.y += _Time.y; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise1 = tex2D(noiseTex, uv1 * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); float2 uv2 = worldXZ; uv2.x += _Time.y; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise2 = tex2D(noiseTex, uv2 * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); <span class="hljs-type"><span class="hljs-type">float</span></span> blendWave = sin( (worldXZ.x + worldXZ.y) * <span class="hljs-number"><span class="hljs-number">0.1</span></span> + (noise1.y + noise2.z) + _Time.y ); blendWave *= blendWave; <span class="hljs-type"><span class="hljs-type">float</span></span> waves = lerp(noise1.z, noise1.w, blendWave) + lerp(noise2.x, noise2.y, blendWave); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> smoothstep(<span class="hljs-number"><span class="hljs-number">0.75</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, waves); }</code> </pre> <br>  √Ñndern Sie den <em>Water</em> Shader so, dass er die neue Include-Datei verwendet. <br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Water.cginc" sampler2D _MainTex; ‚Ä¶ <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float</span></span> waves = Waves(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz, _MainTex); fixed4 c = saturate(_Color + waves); o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br>  Im <em>Water Shore</em> Shader werden Werte sowohl f√ºr Schaum als auch f√ºr Wellen berechnet.  Dann d√§mpfen wir die Wellen, wenn wir uns dem Ufer n√§hern.  Das Endergebnis ist ein Maximum an Schaum und Wellen. <br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Water.cginc" sampler2D _MainTex; ‚Ä¶ <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float</span></span> shore = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y; <span class="hljs-type"><span class="hljs-type">float</span></span> foam = Foam(shore, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz, _MainTex); <span class="hljs-type"><span class="hljs-type">float</span></span> waves = Waves(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz, _MainTex); waves *= <span class="hljs-number"><span class="hljs-number">1</span></span> - shore; fixed4 c = saturate(_Color + max(foam, waves)); o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Eine Mischung aus Schaum und Wellen.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Einheitspaket</a> <br><br><h2>  Wieder √ºber K√ºstenwasser </h2><br>  Ein Teil des K√ºstennetzes ist unter dem Reliefnetz versteckt.  Dies ist normal, aber nur ein kleiner Teil ist verborgen.  Leider verbergen steile Klippen den gr√∂√üten Teil des K√ºstenwassers und sch√§umen daher. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dea/adf/7e3/deaadf7e3290f93b28ed6177c713bbaa.png"></div><br>  <i>Fast verstecktes K√ºstenwasser.</i> <br><br>  Wir k√∂nnen damit umgehen, indem wir den K√ºstenstreifen vergr√∂√üern.  Dies kann durch Verringern des Radius der Sechsecke des Wassers erfolgen.  Dazu ben√∂tigen wir zus√§tzlich zum Integrit√§tskoeffizienten einen <code>HexMetrics</code> Wasserkoeffizienten sowie Methoden zur <code>HexMetrics</code> Wasserwinkeln. <br><br>  Der Integrit√§tskoeffizient betr√§gt 0,8.  Um die Gr√∂√üe der Wasserverbindungen zu verdoppeln, m√ºssen wir den Wasserkoeffizienten auf 0,6 einstellen. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> waterFactor = <span class="hljs-number"><span class="hljs-number">0.6f</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFirstWaterCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] * waterFactor; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSecondWaterCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction + <span class="hljs-number"><span class="hljs-number">1</span></span>] * waterFactor; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden diese neuen Methoden verwenden </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um die Winkel des Wassers zu finden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateOpenWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { Vector3 c1 = center + HexMetrics.GetFirstWaterCorner(direction); Vector3 c2 = center + HexMetrics.GetSecondWaterCorner(direction); ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( center + HexMetrics.GetFirstWaterCorner(direction), center + HexMetrics.GetSecondWaterCorner(direction) ); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/123/b85/fcf/123b85fcffde7ae313f177f76f882ef5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wasserecken benutzen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Abstand zwischen den Sechsecken des Wassers hat sich tats√§chlich verdoppelt. </font><font style="vertical-align: inherit;">Jetzt </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sollte es auch eine Methode zum Erstellen von Br√ºcken im Wasser geben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> waterBlendFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span> - waterFactor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWaterBridge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] + corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction + <span class="hljs-number"><span class="hljs-number">1</span></span>]) * waterBlendFactor; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ñndern Sie, </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">damit er die neue Methode verwendet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateOpenWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE &amp;&amp; neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Vector3 bridge = HexMetrics.GetWaterBridge(direction); ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E) { ‚Ä¶ water.AddTriangle( c2, e2, c2 + HexMetrics.GetWaterBridge(direction.Next()) ); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Vector3 bridge = HexMetrics.GetWaterBridge(direction); ‚Ä¶ HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { waterShore.AddTriangle( e1.v5, e2.v5, e1.v5 + HexMetrics.GetWaterBridge(direction.Next()) ); ‚Ä¶ } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99b/756/1fa/99b7561fad8556733ea1f10b2dcdd233.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lange Br√ºcken im Wasser.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zwischen den Rippen von Wasser und Land </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl dies uns mehr Platz f√ºr Schaum gibt, ist jetzt noch mehr unter dem Relief verborgen. </font><font style="vertical-align: inherit;">Idealerweise k√∂nnen wir eine Wasserrippe auf der Wasserseite und eine Landrippe auf der Landseite verwenden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen keine einfache Br√ºcke benutzen, um den gegen√ºberliegenden Rand des Landes zu finden, wenn wir von den Ecken des Wassers aus starten. </font><font style="vertical-align: inherit;">Stattdessen k√∂nnen wir vom Zentrum des Nachbarn aus in die entgegengesetzte Richtung gehen. </font><font style="vertical-align: inherit;">√Ñndern Sie </font></font><code>TriangulateWaterShore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diesen neuen Ansatz.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Vector3 bridge = HexMetrics.GetWaterBridge(direction); Vector3 center2 = neighbor.Position; center2.y = center.y; EdgeVertices e2 = new EdgeVertices( center2 + HexMetrics.GetSecondSolidCorner(direction.Opposite()), center2 + HexMetrics.GetFirstSolidCorner(direction.Opposite()) ); ‚Ä¶ HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); if (nextNeighbor != null) { Vector3 center3 = nextNeighbor.Position; center3.y = center.y; waterShore.AddTriangle( e1.v5, e2.v5, center3 + HexMetrics.GetFirstSolidCorner(direction.Previous()) ); ‚Ä¶ }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b29/3f2/01f/b293f201f065b7921f1098484e3b725d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Falsche Kantenecken. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies hat funktioniert, erst jetzt m√ºssen wir wieder zwei F√§lle f√ºr eckige Dreiecke betrachten.</font></font><br><br><pre> <code class="cs hljs"> HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Vector3 center3 = nextNeighbor.Position; // center3.y = center.y; Vector3 v3 = nextNeighbor.Position + (nextNeighbor.IsUnderwater ? HexMetrics.GetFirstWaterCorner(direction.Previous()) : HexMetrics.GetFirstSolidCorner(direction.Previous())); v3.y = center.y; waterShore.AddTriangle(e1.v5, e2.v5, v3); waterShore.AddTriangleUV( new Vector2(0f, 0f), new Vector2(0f, 1f), new Vector2(0f, nextNeighbor.IsUnderwater ? 0f : 1f) ); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e1/f64/db1/4e1f64db1a34a8e6cff0f402f5fc6bd8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die richtigen Ecken der Kanten. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies hat gut funktioniert, aber jetzt, da der gr√∂√üte Teil des Schaums sichtbar ist, wird er ziemlich ausgepr√§gt. </font><font style="vertical-align: inherit;">Um dies zu kompensieren, werden wir den Effekt etwas schw√§cher machen, indem wir die Skala des K√ºstenwerts im Shader reduzieren.</font></font><br><br><pre> <code class="hljs lisp"> shore = sqrt(<span class="hljs-name"><span class="hljs-name">shore</span></span>) * <span class="hljs-number"><span class="hljs-number">0.9</span></span><span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fertigschaum. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> U-Boot-Fl√ºsse </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben Wasser bekommen, zumindest an den Stellen, an denen keine Fl√ºsse hineinflie√üen. </font><font style="vertical-align: inherit;">Da sich Wasser und Fl√ºsse noch nicht bemerken, flie√üen Fl√ºsse durch und unter Wasser.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/051/1ee/bc5/0511eebc5420c9203475b65ce5c478b3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fl√ºsse flie√üen im Wasser. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Reihenfolge, in der durchscheinende Objekte gerendert werden, h√§ngt von ihrer Entfernung zur Kamera ab. </font><font style="vertical-align: inherit;">Die n√§chsten Objekte werden zuletzt gerendert, sodass sie sich oben befinden. </font><font style="vertical-align: inherit;">Wenn Sie die Kamera bewegen, bedeutet dies, dass manchmal Fl√ºsse und manchmal Wasser √ºbereinander erscheinen. </font><font style="vertical-align: inherit;">Beginnen wir damit, die Renderreihenfolge konstant zu halten. </font><font style="vertical-align: inherit;">Fl√ºsse m√ºssen √ºber das Wasser gezogen werden, damit die Wasserf√§lle korrekt angezeigt werden. </font><font style="vertical-align: inherit;">Wir k√∂nnen dies implementieren, indem wir die Warteschlange des </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">River-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shaders √§ndern </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs objectivec"> Tags { <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> <span class="hljs-string"><span class="hljs-string">"Queue"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent+1"</span></span> }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4bc/74e/d91/4bc74ed9179598f5b9e82c3ff0cde851.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir zeichnen die Fl√ºsse zuletzt.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unterwasserfluss verstecken </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl sich das Flussbett m√∂glicherweise unter Wasser befindet und tats√§chlich Wasser durch es flie√üen kann, sollten wir dieses Wasser nicht sehen. </font><font style="vertical-align: inherit;">Und noch mehr, es sollte nicht auf einer echten Wasseroberfl√§che gerendert werden. </font><font style="vertical-align: inherit;">Wir k√∂nnen das Wasser von U-Boot-Fl√ºssen loswerden, indem wir nur dann Flusssegmente hinzuf√ºgen, wenn sich die aktuelle Zelle nicht unter Wasser befindet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiverBeginOrEnd</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reversed = cell.HasIncomingRiver; ‚Ä¶ } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reversed = cell.IncomingRiver == direction; ‚Ä¶ } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beginnen , </font><font style="vertical-align: inherit;">dass ein Segment des Flusses hinzuf√ºgen, wenn kein Strom, keine Nachbarzelle nicht unter Wasser ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e2.v3.y = neighbor.StreamBedY; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !neighbor.IsUnderwater) { TriangulateRiverQuad( e1.v2, e1.v4, e2.v2, e2.v4, cell.RiverSurfaceY, neighbor.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction ); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/899/0c7/cf6/8990c7cf6af7bf25596b4ffc05204817.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keine Unterwasserfl√ºsse mehr.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wasserf√§lle </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt keine Unterwasserfl√ºsse mehr, aber jetzt haben wir L√∂cher an den Stellen der Fl√ºsse, an denen sie auf die Wasseroberfl√§che treffen. Fl√ºsse auf gleicher Wasserh√∂he bilden kleine L√∂cher oder √úberlagerungen. Am auff√§lligsten sind jedoch die fehlenden Wasserf√§lle f√ºr Fl√ºsse, die aus gr√∂√üerer H√∂he flie√üen. K√ºmmern wir uns zuerst um sie. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Flusssegment mit einem Wasserfall, der durch die Wasseroberfl√§che f√ºhrte. Infolgedessen befand er sich teilweise √ºber und teilweise unter Wasser. Wir m√ºssen einen Teil √ºber dem Wasserspiegel halten und alles andere wegwerfen. Sie m√ºssen hart daf√ºr arbeiten, also erstellen Sie eine separate Methode. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die neue Methode erfordert vier Gipfel, zwei Flussniveaus und einen Wasserstand. Wir werden es so einstellen, dass wir in Richtung der Str√∂mung den Wasserfall hinunter schauen. Daher befinden sich die ersten beiden Peaks sowie die linke und rechte Seite oben und die unteren folgen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterfallInWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> waterY </span></span></span><span class="hljs-function">)</span></span> { v1.y = v2.y = y1; v3.y = v4.y = y2; rivers.AddQuad(v1, v2, v3, v4); rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden diese Methode aufrufen, </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn ein Nachbar unter Wasser ist und wir einen Wasserfall erstellen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor.IsUnderwater) { TriangulateRiverQuad( e1.v2, e1.v4, e2.v2, e2.v4, cell.RiverSurfaceY, neighbor.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt; neighbor.WaterLevel) { TriangulateWaterfallInWater( e1.v2, e1.v4, e2.v2, e2.v4, cell.RiverSurfaceY, neighbor.RiverSurfaceY, neighbor.WaterSurfaceY ); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir m√ºssen die Wasserf√§lle auch in die entgegengesetzte Richtung verarbeiten, wenn sich die aktuelle Zelle unter Wasser befindet und die n√§chste nicht. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !neighbor.IsUnderwater &amp;&amp; neighbor.Elevation &gt; cell.WaterLevel ) { TriangulateWaterfallInWater( e2.v4, e2.v2, e1.v4, e1.v2, neighbor.RiverSurfaceY, cell.RiverSurfaceY, cell.WaterSurfaceY ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also bekommen wir wieder das Quad des urspr√ºnglichen Flusses. </font><font style="vertical-align: inherit;">Als n√§chstes m√ºssen wir uns √§ndern </font></font><code>TriangulateWaterfallInWater</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, damit die unteren Spitzen auf den Wasserspiegel angehoben werden. </font><font style="vertical-align: inherit;">Leider reicht es nicht aus, nur die Y-Koordinaten zu √§ndern. </font><font style="vertical-align: inherit;">Dies kann den Wasserfall von der Klippe schieben, wodurch L√∂cher entstehen k√∂nnen. </font><font style="vertical-align: inherit;">Stattdessen m√ºssen Sie die unteren Scheitelpunkte durch Interpolation zu den oberen verschieben.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/942/11b/250/94211b250d95b614a5d6be6ff52c9e9e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interpolieren. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die unteren Gipfel nach oben zu bewegen, teilen Sie ihren Abstand unter der Wasseroberfl√§che durch die H√∂he des Wasserfalls. </font><font style="vertical-align: inherit;">Dies gibt uns einen Interpolatorwert.</font></font><br><br><pre> <code class="cs hljs"> v1.y = v2.y = y1; v3.y = v4.y = y2; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = (waterY - y2) / (y1 - y2); v3 = Vector3.Lerp(v3, v1, t); v4 = Vector3.Lerp(v4, v2, t); rivers.AddQuad(v1, v2, v3, v4); rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als Ergebnis erhalten wir einen verk√ºrzten Wasserfall mit der gleichen Ausrichtung. </font><font style="vertical-align: inherit;">Da sich jedoch die Positionen der unteren Scheitelpunkte ge√§ndert haben, werden sie nicht wie die urspr√ºnglichen Scheitelpunkte verzerrt. </font><font style="vertical-align: inherit;">Dies bedeutet, dass das Endergebnis immer noch nicht mit dem urspr√ºnglichen Wasserfall √ºbereinstimmt. </font><font style="vertical-align: inherit;">Um dieses Problem zu l√∂sen, m√ºssen wir die Scheitelpunkte vor der Interpolation manuell verzerren und dann das unverzerrte Quad hinzuf√ºgen.</font></font><br><br><pre> <code class="cs hljs"> v1.y = v2.y = y1; v3.y = v4.y = y2; v1 = HexMetrics.Perturb(v1); v2 = HexMetrics.Perturb(v2); v3 = HexMetrics.Perturb(v3); v4 = HexMetrics.Perturb(v4); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = (waterY - y2) / (y1 - y2); v3 = Vector3.Lerp(v3, v1, t); v4 = Vector3.Lerp(v4, v2, t); rivers.AddQuadUnperturbed(v1, v2, v3, v4); rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir bereits eine Methode zum Hinzuf√ºgen unverzerrter Dreiecke haben, m√ºssen wir f√ºr Quads wirklich keine erstellen. </font><font style="vertical-align: inherit;">Deshalb f√ºgen wir die notwendige Methode hinzu </font></font><code>HexMesh.AddQuadUnperturbed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadUnperturbed</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4 </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vertexIndex = vertices.Count; vertices.Add(v1); vertices.Add(v2); vertices.Add(v3); vertices.Add(v4); triangles.Add(vertexIndex); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">2</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">2</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">3</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc4/605/bdd/dc4605bdd24ed9460b0ca3a310a11fb5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wasserf√§lle enden an der Wasseroberfl√§che. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flussm√ºndungen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Fl√ºsse auf der gleichen H√∂he wie die Wasseroberfl√§che flie√üen, ber√ºhrt das Flussnetz das K√ºstennetz. Wenn es ein Fluss w√§re, der ins Meer oder in den Ozean flie√üt, dann w√ºrde es einen Strom des Flusses mit einer Brandung geben. Deshalb werden wir solche Gebiete Flussm√ºndungen nennen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddd/27b/efa/ddd27befa12ec543e2969505365b0d91.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Fluss trifft auf die K√ºste, ohne die Gipfel zu verzerren.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt haben wir zwei Probleme mit dem Mund. Erstens verbinden Quad-Fl√ºsse die zweite und vierte Spitze der Rippen und √ºberspringen die dritte. Da die K√ºste des Wassers nicht den dritten Gipfel nutzt, kann es zu einem Loch oder einer √úberlappung kommen. Wir k√∂nnen dieses Problem l√∂sen, indem wir die Geometrie der M√ºnder √§ndern. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das zweite Problem ist, dass es einen scharfen √úbergang zwischen Schaum und Flussmaterialien gibt. Um es zu l√∂sen, brauchen wir ein anderes Material, das die Auswirkungen von Fluss und Wasser vermischt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies bedeutet, dass die M√ºnder einen speziellen Ansatz erfordern. Erstellen wir daher eine separate Methode f√ºr sie. Es sollte aufgerufen werden, </font></font><code>TriangulateWaterShore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn sich ein Fluss in die aktuelle Richtung bewegt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { TriangulateEstuary(e1, e2); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { waterShore.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); waterShore.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); waterShore.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); waterShore.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); } ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEstuary</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EdgeVertices e1, EdgeVertices e2</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Bereich, der beide Effekte mischt, ist nicht erforderlich, um den gesamten Streifen zu f√ºllen. </font><font style="vertical-align: inherit;">Die Trapezform wird f√ºr uns ausreichen. </font><font style="vertical-align: inherit;">Daher k√∂nnen wir zwei K√ºstendreiecke an den Seiten verwenden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEstuary</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EdgeVertices e1, EdgeVertices e2</span></span></span><span class="hljs-function">)</span></span> { waterShore.AddTriangle(e2.v1, e1.v2, e1.v1); waterShore.AddTriangle(e2.v5, e1.v5, e1.v4); waterShore.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); waterShore.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ece/ca1/fc9/ececa1fc9852f7350a54e00fa71df0b3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trapezloch f√ºr den Mischbereich.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UV2-Koordinaten </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um einen Flusseffekt zu erzielen, ben√∂tigen wir UV-Koordinaten. </font><font style="vertical-align: inherit;">Um einen Schaumeffekt zu erzielen, ben√∂tigen Sie jedoch auch UV-Koordinaten. </font><font style="vertical-align: inherit;">Das hei√üt, wenn wir sie mischen, ben√∂tigen wir zwei S√§tze von UV-Koordinaten. </font><font style="vertical-align: inherit;">Gl√ºcklicherweise k√∂nnen Unity-Engine-Meshes bis zu vier UV-Sets unterst√ºtzen. </font><font style="vertical-align: inherit;">Wir m√ºssen nur zur </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterst√ºtzung des zweiten Satzes </font><font style="vertical-align: inherit;">hinzuf√ºgen </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useCollider, useColors, useUVCoordinates, useUV2Coordinates; [NonSerialized] List&lt;Vector2&gt; uvs, uv2s; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useUVCoordinates) { uvs = ListPool&lt;Vector2&gt;.Get(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useUV2Coordinates) { uv2s = ListPool&lt;Vector2&gt;.Get(); } triangles = ListPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Get(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useUVCoordinates) { hexMesh.SetUVs(<span class="hljs-number"><span class="hljs-number">0</span></span>, uvs); ListPool&lt;Vector2&gt;.Add(uvs); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useUV2Coordinates) { hexMesh.SetUVs(<span class="hljs-number"><span class="hljs-number">1</span></span>, uv2s); ListPool&lt;Vector2&gt;.Add(uv2s); } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um einen zweiten Satz UVs hinzuzuf√ºgen, duplizieren wir die Methoden zum Arbeiten mit UV und √§ndern die Art und Weise, wie wir sie ben√∂tigen. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleUV2</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 uv1, Vector2 uv2, Vector3 uv3</span></span></span><span class="hljs-function">)</span></span> { uv2s.Add(uv1); uv2s.Add(uv2); uv2s.Add(uv3); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadUV2</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 uv1, Vector2 uv2, Vector3 uv3, Vector3 uv4</span></span></span><span class="hljs-function">)</span></span> { uv2s.Add(uv1); uv2s.Add(uv2); uv2s.Add(uv3); uv2s.Add(uv4); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadUV2</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uMin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uMax, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vMin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vMax</span></span></span><span class="hljs-function">)</span></span> { uv2s.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMin, vMin)); uv2s.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMax, vMin)); uv2s.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMin, vMax)); uv2s.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMax, vMax)); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> River Shader-Funktion </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir den River-Effekt in zwei Shadern verwenden, verschieben wir den Code vom </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">River-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font><font style="vertical-align: inherit;">in die neue </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Include-Dateifunktion </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> River (float2 riverUV, sampler2D noiseTex) { float2 uv = riverUV; uv.x = uv.x * <span class="hljs-number"><span class="hljs-number">0.0625</span></span> + _Time.y * <span class="hljs-number"><span class="hljs-number">0.005</span></span>; uv.y -= _Time.y * <span class="hljs-number"><span class="hljs-number">0.25</span></span>; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(noiseTex, uv); float2 uv2 = riverUV; uv2.x = uv2.x * <span class="hljs-number"><span class="hljs-number">0.0625</span></span> - _Time.y * <span class="hljs-number"><span class="hljs-number">0.0052</span></span>; uv2.y -= _Time.y * <span class="hljs-number"><span class="hljs-number">0.23</span></span>; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise2 = tex2D(noiseTex, uv2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> noise.x * noise2.w; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ñndern Sie den </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">River-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font><font style="vertical-align: inherit;">, um diese neue Funktion zu verwenden.</font></font><br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Water.cginc" sampler2D _MainTex; ‚Ä¶ <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float</span></span> river = River(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex, _MainTex); fixed4 c = saturate(_Color + river); ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mundgegenst√§nde </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie einen </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mund hinzu </font><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">um das Netzobjekt </font><font style="vertical-align: inherit;">zu </font><font style="vertical-align: inherit;">st√ºtzen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMesh terrain, rivers, roads, water, waterShore, estuaries; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrain.Clear(); rivers.Clear(); roads.Clear(); water.Clear(); waterShore.Clear(); estuaries.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { Triangulate(cells[i]); } terrain.Apply(); rivers.Apply(); roads.Apply(); water.Apply(); waterShore.Apply(); estuaries.Apply(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie einen Shader, ein Material und ein Objekt des Mundes, duplizieren Sie die K√ºste und √§ndern Sie sie. </font><font style="vertical-align: inherit;">Verbinden Sie es mit dem Fragment und lassen Sie es die UV- und UV2-Koordinaten verwenden.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/540/77a/7fc/54077a7fc8653228cd723ca855330fed.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objekt Estuarties.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mundtriangulation </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen das Loch- oder √úberlappungsproblem l√∂sen, indem wir ein Dreieck zwischen dem Ende des Flusses und der Mitte des Wasserrands platzieren. </font><font style="vertical-align: inherit;">Da unser Mund-Shader ein Duplikat des Coast-Shaders ist, stellen wir die UV-Koordinaten so ein, dass sie dem Schaumeffekt entsprechen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEstuary</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EdgeVertices e1, EdgeVertices e2</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ estuaries.AddTriangle(e1.v3, e2.v2, e2.v4); estuaries.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f02/bb6/f76/f02bb6f768f915d39c05296055cc0b83.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mittleres Dreieck. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen das gesamte Trapez f√ºllen, indem wir auf beiden Seiten des mittleren Dreiecks ein Quad hinzuf√ºgen.</font></font><br><br><pre> <code class="cs hljs"> estuaries.AddQuad(e1.v2, e1.v3, e2.v1, e2.v2); estuaries.AddTriangle(e1.v3, e2.v2, e2.v4); estuaries.AddQuad(e1.v3, e1.v4, e2.v4, e2.v5); estuaries.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); estuaries.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); estuaries.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef2/672/e7e/ef2672e7e62b9d66463e4fc44dc43b7a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fertiges Trapez. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drehen wir die Quad-Ausrichtung nach links, so dass sie eine verk√ºrzte diagonale Verbindung hat, und als Ergebnis erhalten wir eine symmetrische Geometrie.</font></font><br><br><pre> <code class="cs hljs"> estuaries.AddQuad(e2.v1, e1.v2, e2.v2, e1.v3); estuaries.AddTriangle(e1.v3, e2.v2, e2.v4); estuaries.AddQuad(e1.v3, e1.v4, e2.v4, e2.v5); estuaries.AddQuadUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); <span class="hljs-comment"><span class="hljs-comment">// estuaries.AddQuadUV(0f, 0f, 0f, 1f);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd5/dd0/7d1/cd5dd07d1b9f1fb8126e6a5a7c1bc29b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gedrehtes Quad, symmetrische Geometrie</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flussfluss </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um den Flusseffekt zu unterst√ºtzen, m√ºssen wir UV2-Koordinaten hinzuf√ºgen. </font><font style="vertical-align: inherit;">Der Grund des mittleren Dreiecks befindet sich in der Mitte des Flusses, daher sollte seine Koordinate U gleich 0,5 sein. </font><font style="vertical-align: inherit;">Da der Fluss in Richtung des Wassers flie√üt, erh√§lt der linke Punkt die U-Koordinate gleich 1 und der rechte die U-Koordinate mit einem Wert von 0. Wir setzen die Y-Koordinaten auf 0 und 1, entsprechend der Richtung des Stroms.</font></font><br><br><pre> <code class="cs hljs"> estuaries.AddTriangleUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Vierecke auf beiden Seiten des Dreiecks sollten mit dieser Ausrichtung √ºbereinstimmen. </font><font style="vertical-align: inherit;">Wir behalten die gleichen U-Koordinaten f√ºr Punkte bei, die die Breite des Flusses √ºberschreiten.</font></font><br><br><pre> <code class="cs hljs"> estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); estuaries.AddTriangleUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a98/475/d50/a98475d50fe84d16eeeff5397f6aa43f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UV2-Trapez. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um sicherzustellen, dass die UV2-Koordinaten korrekt eingestellt sind, lassen Sie sie vom </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estuary-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font><font style="vertical-align: inherit;">rendern. </font><font style="vertical-align: inherit;">Wir k√∂nnen auf diese Koordinaten zugreifen, indem wir sie zur Eingabestruktur hinzuf√ºgen </font></font><code>float2 uv2_MainTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs pgsql"> struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; float2 uv2_MainTex; float3 worldPos; }; ‚Ä¶ <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float</span></span> shore = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y; <span class="hljs-type"><span class="hljs-type">float</span></span> foam = Foam(shore, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz, _MainTex); <span class="hljs-type"><span class="hljs-type">float</span></span> waves = Waves(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz, _MainTex); waves *= <span class="hljs-number"><span class="hljs-number">1</span></span> - shore; fixed4 c = fixed4(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv2_MainTex, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/efd/416/d95/efd416d95c7827f264f2f0e8360e6fde.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UV2-Koordinaten. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alles sieht gut aus, Sie k√∂nnen einen Shader verwenden, um einen Flusseffekt zu erzeugen.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { ‚Ä¶ <span class="hljs-type"><span class="hljs-type">float</span></span> river = River(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv2_MainTex, _MainTex); fixed4 c = saturate(_Color + river); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e3/2c9/fda/0e32c9fda58b356534c2070d0b74adae.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden Sie UV2, um einen Flusseffekt zu erzielen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben die Fl√ºsse so erstellt, dass sich beim Triangulieren der Verbindungen zwischen den Zellen die Koordinaten des V-Flusses von 0,8 auf 1 √§ndern. Daher sollten wir hier auch dieses Intervall verwenden und nicht von 0 auf 1. Die K√ºstenverbindung ist jedoch 50% h√∂her als bei normalen Zellverbindungen . </font><font style="vertical-align: inherit;">F√ºr eine optimale Anpassung an den Flusslauf m√ºssen wir daher die Werte von 0,8 auf 1,1 √§ndern.</font></font><br><br><pre> <code class="cs hljs"> estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>) ); estuaries.AddTriangleUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>) ); estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27d/beb/7c6/27dbeb7c67553163422fd560e64ddb03.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b0c/4d9/2e3/b0c4d92e3797274e2534a6921334d184.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Synchronisierter Fluss von Fluss und M√ºndung.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Durchflusseinstellung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W√§hrend sich der Fluss in einer geraden Linie bewegt. </font><font style="vertical-align: inherit;">Wenn Wasser jedoch in ein gr√∂√üeres Gebiet flie√üt, dehnt es sich aus. </font><font style="vertical-align: inherit;">Der Strom wird sich kr√ºmmen. </font><font style="vertical-align: inherit;">Wir k√∂nnen dies simulieren, indem wir die UV2-Koordinaten falten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anstatt die oberen U-Koordinaten au√üerhalb der Flussbreite konstant zu halten, verschieben Sie sie um 0,5. </font><font style="vertical-align: inherit;">Der Punkt ganz links ist 1,5, der Punkt ganz rechts ist ‚Äì0,5. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gleichzeitig erweitern wir den Fluss, indem wir die U-Koordinaten des linken und rechten unteren Punkts verschieben. </font><font style="vertical-align: inherit;">√Ñndern Sie die linke von 1 auf 0,7 und die rechte von 0 auf 0,3.</font></font><br><br><pre> <code class="cs hljs"> estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.7f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>) ); ‚Ä¶ estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.3f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/850/99d/976/85099d97610434a630621e9e06f885ad.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c1/567/f72/0c1567f72c979734719b298c7850b59e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erweiterung des Flusses. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um den Kr√ºmmungseffekt zu vervollst√§ndigen, √§ndern Sie die V-Koordinaten derselben vier Punkte. </font><font style="vertical-align: inherit;">Da das Wasser vom Ende des Flusses wegflie√üt, erh√∂hen wir die Koordinaten von V der oberen Punkte auf 1. Um eine bessere Kurve zu erstellen, erh√∂hen wir die Koordinaten von V der beiden unteren Punkte auf 1,15.</font></font><br><br><pre> <code class="cs hljs"> estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.7f</span></span>, <span class="hljs-number"><span class="hljs-number">1.15f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>) ); estuaries.AddTriangleUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>) ); estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.3f</span></span>, <span class="hljs-number"><span class="hljs-number">1.15f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1fa/86d/320/1fa86d32037da7fab579ce9a195d1e71.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b07/edb/dfe/b07edbdfeb3615b1a597712a6bda5c8e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der geschwungene Flusslauf.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fluss- und K√ºstenmischung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir m√ºssen nur noch die Auswirkungen von K√ºste und Fluss mischen. </font><font style="vertical-align: inherit;">Dazu verwenden wir die lineare Interpolation, wobei der K√ºstenwert als Interpolator verwendet wird.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float</span></span> shoreWater = max(foam, waves); <span class="hljs-type"><span class="hljs-type">float</span></span> river = River(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv2_MainTex, _MainTex); <span class="hljs-type"><span class="hljs-type">float</span></span> water = lerp(shoreWater, river, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.x); fixed4 c = saturate(_Color + water);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl dies funktionieren sollte, wird m√∂glicherweise ein Kompilierungsfehler angezeigt. </font><font style="vertical-align: inherit;">Der Compiler beschwert sich √ºber eine Neudefinition </font></font><code>_MainTex_ST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Der Grund ist ein Fehler im Unity Surface Shader-Compiler, der durch die gleichzeitige Verwendung von </font></font><code>uv_MainTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und verursacht wird </font></font><code>uv2_MainTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir m√ºssen eine Problemumgehung finden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anstatt </font></font><code>uv2_MainTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es zu verwenden, m√ºssen wir die sekund√§ren UV-Koordinaten manuell √ºbertragen. </font><font style="vertical-align: inherit;">Um dies zu tun, umbenennen </font></font><code>uv2_MainTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font></font><code>riverUV</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">F√ºgen Sie dann dem Shader eine Scheitelpunktfunktion hinzu, die ihm Koordinaten zuweist.</font></font><br><br><pre> <code class="hljs pgsql"> #pragma surface surf Standard alpha vertex:vert ‚Ä¶ struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; float2 riverUV; float3 worldPos; }; ‚Ä¶ <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> o) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, o); o.riverUV = v.texcoord1.xy; } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { ‚Ä¶ <span class="hljs-type"><span class="hljs-type">float</span></span> river = River(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.riverUV, _MainTex); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/904/b40/c98/904b40c98323b2e9f32bd16513344181.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interpolation basierend auf dem K√ºstenwert. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Interpolation funktioniert mit Ausnahme des linken und rechten Scheitelpunkts oben. </font><font style="vertical-align: inherit;">An diesen Stellen sollte der Fluss verschwinden. </font><font style="vertical-align: inherit;">Daher k√∂nnen wir den Wert der K√ºste nicht verwenden. </font><font style="vertical-align: inherit;">Wir m√ºssen einen anderen Wert verwenden, der an diesen beiden Eckpunkten 0 ist. Gl√ºcklicherweise haben wir immer noch die U-Koordinate des ersten UV-Satzes, sodass wir diesen Wert dort speichern k√∂nnen.</font></font><br><br><pre> <code class="cs hljs"> estuaries.AddQuadUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); estuaries.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); estuaries.AddQuadUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); <span class="hljs-comment"><span class="hljs-comment">// estuaries.AddQuadUV(0f, 0f, 0f, 1f);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b34/e93/432/b34e93432248fb7be818b53aca4d8b20.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die richtige Mischung. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt haben die M√ºndungen eine gute Mischung zwischen dem expandierenden Fluss, dem K√ºstenwasser und dem Schaum. </font><font style="vertical-align: inherit;">Obwohl dies nicht genau zu Wasserf√§llen passt, sieht dieser Effekt auch bei Wasserf√§llen gut aus.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"></font></i> <font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">M√ºndungen </font></a><i><font style="vertical-align: inherit;">in Aktion </font></i></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fl√ºsse flie√üen aus Gew√§ssern </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben bereits Fl√ºsse, die in Gew√§sser flie√üen, aber es gibt keine Unterst√ºtzung f√ºr Fl√ºsse, die in eine andere Richtung flie√üen. </font><font style="vertical-align: inherit;">Es gibt Seen, aus denen Fl√ºsse flie√üen, also m√ºssen wir sie auch hinzuf√ºgen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn ein Fluss aus einem Gew√§sser flie√üt, flie√üt er tats√§chlich in eine h√∂here H√∂he. </font><font style="vertical-align: inherit;">Dies ist derzeit nicht m√∂glich. </font><font style="vertical-align: inherit;">Wir m√ºssen eine Ausnahme machen und diese Situation zulassen, wenn der Wasserstand der H√∂he des Zielpunkts entspricht. </font><font style="vertical-align: inherit;">F√ºgen wir einer </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">privaten Methode hinzu, die nach unserem neuen Kriterium pr√ºft, ob der Nachbar der richtige Zielpunkt f√ºr den abgehenden Fluss ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsValidRiverDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell neighbor</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> neighbor &amp;&amp; ( elevation &gt;= neighbor.elevation || waterLevel == neighbor.elevation ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir werden unsere neue Methode verwenden, um festzustellen, ob es m√∂glich ist, einen abgehenden Fluss zu erzeugen. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetOutgoingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasOutgoingRiver &amp;&amp; outgoingRiver == direction) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } HexCell neighbor = GetNeighbor(direction); <span class="hljs-comment"><span class="hljs-comment">// if (!neighbor || elevation &lt; neighbor.elevation) { if (!IsValidRiverDestination(neighbor)) { return; } RemoveOutgoingRiver(); ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au√üerdem m√ºssen Sie dort den Fluss √ºberpr√ºfen, wenn Sie die H√∂he der Zelle oder den Wasserstand √§ndern. </font><font style="vertical-align: inherit;">Erstellen wir eine private Methode, die diese Aufgabe √ºbernimmt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidateRivers</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( hasOutgoingRiver &amp;&amp; !IsValidRiverDestination(GetNeighbor(outgoingRiver)) ) { RemoveOutgoingRiver(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( hasIncomingRiver &amp;&amp; !GetNeighbor(incomingRiver).IsValidRiverDestination(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) ) { RemoveIncomingRiver(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden diese neue Methode in den Eigenschaften </font></font><code>Elevation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font><font style="vertical-align: inherit;">verwenden </font></font><code>WaterLevel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">// if ( // hasOutgoingRiver &amp;&amp; // elevation &lt; GetNeighbor(outgoingRiver).elevation // ) { // RemoveOutgoingRiver(); // } // if ( // hasIncomingRiver &amp;&amp; // elevation &gt; GetNeighbor(incomingRiver).elevation // ) { // RemoveIncomingRiver(); // } ValidateRivers(); ‚Ä¶ } } public int WaterLevel { ‚Ä¶ set { if (waterLevel == value) { return; } waterLevel = value; ValidateRivers(); Refresh(); } }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c04/ca4/b49/c04ca4b49ccff20e71dba70dc1a2bea7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausgehende und eintretende Flussseen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wende das Blatt </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben geschaffen </font></font><code>HexGridChunk.TriangulateEstuary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, was darauf hindeutet, dass Fl√ºsse nur in Gew√§sser flie√üen k√∂nnen. </font><font style="vertical-align: inherit;">Daher bewegt sich der Flusslauf immer in eine Richtung. </font><font style="vertical-align: inherit;">Wir m√ºssen den Fluss umkehren, wenn es sich um einen Fluss handelt, der aus einem Gew√§sser flie√üt. </font><font style="vertical-align: inherit;">Dazu m√ºssen Sie </font></font><code>TriangulateEstuary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Str√∂mungsrichtung kennen. </font><font style="vertical-align: inherit;">Daher geben wir ihm einen Booleschen Parameter, der bestimmt, ob es sich um einen eingehenden Fluss handelt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEstuary</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, EdgeVertices e2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> incomingRiver </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden diese Informationen √ºbergeben, wenn wir diese Methode von aufrufen </font></font><code>TriangulateWaterShore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { TriangulateEstuary(e1, e2, cell.IncomingRiver == direction); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt m√ºssen wir den Flussfluss erweitern, indem wir die Koordinaten von UV2 √§ndern. </font><font style="vertical-align: inherit;">U-Koordinaten f√ºr ausgehende Fl√ºsse m√ºssen gespiegelt werden: ‚Äì0,5 wird 1,5, 0 wird 1, 1 wird 0 und 1,5 wird ‚Äì0,5. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit V-Koordinaten sind die Dinge etwas komplizierter. </font><font style="vertical-align: inherit;">Wenn Sie sich ansehen, wie wir mit invertierten Flussverbindungen gearbeitet haben, sollte 0,8 0 und 1 ‚Äì0,2 sein. </font><font style="vertical-align: inherit;">Dies bedeutet, dass 1,1 zu ‚Äì0,3 und 1,15 zu ‚Äì0,35 wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da die UV2-Koordinaten in jedem Fall sehr unterschiedlich sind, schreiben wir einen separaten Code f√ºr sie.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEstuary</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, EdgeVertices e2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> incomingRiver </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (incomingRiver) { estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.7f</span></span>, <span class="hljs-number"><span class="hljs-number">1.15f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>) ); estuaries.AddTriangleUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>) ); estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.3f</span></span>, <span class="hljs-number"><span class="hljs-number">1.15f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.2f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.3f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.35f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.3f</span></span>) ); estuaries.AddTriangleUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.3f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.3f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.7f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.35f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.2f</span></span>) ); } }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der richtige Lauf der Fl√ºsse. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil 9: Reliefmerkmale </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> F√ºgen Sie dem Relief Objekte hinzu. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir schaffen Unterst√ºtzung f√ºr die Dichte von Objekten. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir verwenden verschiedene Objekte im Level. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mischen Sie drei verschiedene Arten von Objekten. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Teil werden wir √ºber das Hinzuf√ºgen von Objekten zum Gel√§nde sprechen. </font><font style="vertical-align: inherit;">Wir werden Objekte wie Geb√§ude und B√§ume erstellen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b8b/1ec/f84/b8b1ecf8496a03d50c881bbd47c262ad.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konflikt zwischen W√§ldern, landwirtschaftlichen Fl√§chen und Urbanisierung.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unterst√ºtzung f√ºr Objekte hinzuf√ºgen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl die Form des Reliefs unterschiedlich ist, passiert bisher nichts darauf. </font><font style="vertical-align: inherit;">Dies ist ein lebloses Land. </font><font style="vertical-align: inherit;">Um ihm Leben einzuhauchen, m√ºssen Sie solche Objekte hinzuf√ºgen. </font><font style="vertical-align: inherit;">wie B√§ume und H√§user. </font><font style="vertical-align: inherit;">Diese Objekte sind nicht Teil des Reliefnetzes, sondern separate Objekte. </font><font style="vertical-align: inherit;">Dies hindert uns jedoch nicht daran, sie beim Triangulieren des Gel√§ndes hinzuzuf√ºgen. </font></font><br><br> <code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist mir egal, wie das Netz funktioniert. </font><font style="vertical-align: inherit;">Er befiehlt einfach einem seiner Kinder, </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein Dreieck oder Quad hinzuzuf√ºgen. </font><font style="vertical-align: inherit;">Ebenso kann es ein untergeordnetes Element geben, das sich mit der Platzierung von Objekten auf ihnen befasst.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objektmanager </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen wir eine Komponente </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die sich um Objekte innerhalb eines einzelnen Fragments k√ºmmert. </font><font style="vertical-align: inherit;">Wir verwenden das gleiche Schema wie in </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- geben Sie ihm Methoden </font></font><code>Clear</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>Apply</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Da das Objekt irgendwo platziert werden muss, </font></font><code>AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">empf√§ngt die </font><font style="vertical-align: inherit;">Methode </font><font style="vertical-align: inherit;">den Positionsparameter. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden mit einer leeren Implementierung beginnen, die vorerst nichts bewirken wird.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexFeatureManager</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> {} }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir einen Link zu einer solchen Komponente in hinzuf√ºgen </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dann k√∂nnen Sie es wie alle untergeordneten Elemente in den Triangulationsprozess einbeziehen </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexFeatureManager features; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrain.Clear(); rivers.Clear(); roads.Clear(); water.Clear(); waterShore.Clear(); estuaries.Clear(); features.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { Triangulate(cells[i]); } terrain.Apply(); rivers.Apply(); roads.Apply(); water.Apply(); waterShore.Apply(); estuaries.Apply(); features.Apply(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beginnen wir mit der Platzierung eines Objekts in der Mitte jeder Zelle </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { Triangulate(d, cell); } features.AddFeature(cell.Position); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt brauchen wir einen echten Objektmanager. </font><font style="vertical-align: inherit;">F√ºgen Sie </font><font style="vertical-align: inherit;">dem </font><font style="vertical-align: inherit;">Fertighaus </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid Chunk ein</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> weiteres Kind </font><font style="vertical-align: inherit;">hinzu </font><font style="vertical-align: inherit;">und geben Sie ihm eine Komponente </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dann k√∂nnen Sie ein Fragment damit verbinden.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eeb/1f4/626/eeb1f462652650c6dfe5e3cb34a2ec12.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51b/7ec/8f2/51b7ec8f20b4a79589fd2b464744230b.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/620/c6f/8cd/620c6f8cd7c54c52597fcc289b160c57.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Objektmanager, der dem Fragment-Fertighaus hinzugef√ºgt wurde.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fertigh√§user </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Welches Gel√§ndeobjekt werden wir erstellen? </font><font style="vertical-align: inherit;">F√ºr den ersten Test ist ein W√ºrfel gut geeignet. </font><font style="vertical-align: inherit;">Erstellen wir beispielsweise einen ausreichend gro√üen W√ºrfel mit einer Skala von (3, 3, 3) und verwandeln ihn in ein Fertighaus. </font><font style="vertical-align: inherit;">Erstellen Sie auch Material f√ºr ihn. </font><font style="vertical-align: inherit;">Ich habe das Standardmaterial mit Rot verwendet. </font><font style="vertical-align: inherit;">Entfernen wir den Collider, weil wir ihn nicht brauchen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7a/1b1/315/a7a1b1315e7f2756ac2940dac661f95a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fertigw√ºrfel. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objektmanager ben√∂tigen einen Link zu diesem Fertighaus. F√ºgen Sie ihn hinzu </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und verbinden Sie sie. </font><font style="vertical-align: inherit;">Da zum Platzieren des Objekts Zugriff auf die Transformationskomponente erforderlich ist, verwenden wir es als Verkn√ºpfungstyp.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform featurePrefab;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cfc/34d/e84/cfc34de84fbc12ac5fde17d7d1d09b58.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objektmanager mit Fertighaus.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objektinstanzen erstellen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Struktur ist fertig und wir k√∂nnen mit dem Hinzuf√ºgen von Gel√§ndemerkmalen beginnen! </font><font style="vertical-align: inherit;">Erstellen Sie einfach eine Instanz des Fertighauses </font></font><code>HexFeatureManager.AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und legen Sie dessen Position fest.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Transform instance = Instantiate(featurePrefab); instance.localPosition = position; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dd8/59c/ae5/dd859cae56fa9439e91d0ccb5d659f62.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instanzen von Gel√§ndemerkmalen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Von nun an wird das Gel√§nde mit W√ºrfeln gef√ºllt. </font><font style="vertical-align: inherit;">Zumindest die oberen H√§lften der W√ºrfel, da der lokale Ursprung f√ºr das W√ºrfelnetz in Unity in der Mitte des W√ºrfels liegt und der Boden unter der Oberfl√§che des Reliefs liegt. </font><font style="vertical-align: inherit;">Um W√ºrfel auf der Topographie zu platzieren, m√ºssen wir sie um die H√§lfte ihrer H√∂he nach oben bewegen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Transform instance = Instantiate(featurePrefab); position.y += instance.localScale.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.localPosition = position; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb0/6be/89b/bb06be89b647d5ff29f1894bfdcf199b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W√ºrfel auf der Oberfl√§che des Reliefs.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist, wenn wir ein anderes Netz verwenden?</font></font></b> <div class="spoiler_text">       .     ,      ,        .       . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nat√ºrlich sind unsere Zellen verzerrt, daher m√ºssen wir die Position von Objekten verzerren. </font><font style="vertical-align: inherit;">So werden wir die perfekte Wiederholbarkeit des Netzes los.</font></font><br><br><pre> <code class="cs hljs"> instance.localPosition = HexMetrics.Perturb(position);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e5/7ec/a43/9e57eca43cf9127691cb5eb11bc6a11a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verzerrte Positionen von Objekten.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zerst√∂rung von Hilfsgegenst√§nden </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jedes Mal, wenn ein Fragment aktualisiert wird, erstellen wir neue Reliefobjekte. </font><font style="vertical-align: inherit;">Dies bedeutet, dass wir immer mehr Objekte an denselben Positionen erstellen. </font><font style="vertical-align: inherit;">Um Duplikate zu vermeiden, m√ºssen wir beim Reinigen eines Fragments alte Objekte entfernen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der schnellste Weg, dies zu tun, besteht darin, ein Spielcontainerobjekt zu erstellen und alle Reliefobjekte in seine untergeordneten Objekte umzuwandeln. </font><font style="vertical-align: inherit;">Wenn </font></font><code>Clear</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">dann aufgerufen werden, </font><font style="vertical-align: inherit;">zerst√∂ren wir diesen Container und erstellen einen neuen. </font><font style="vertical-align: inherit;">Der Container selbst ist ein Kind seines Managers.</font></font><br><br><pre> <code class="cs hljs"> Transform container; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (container) { Destroy(container.gameObject); } container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameObject(<span class="hljs-string"><span class="hljs-string">"Features Container"</span></span>).transform; container.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Transform instance = Instantiate(featurePrefab); position.y += instance.localScale.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.localPosition = HexMetrics.Perturb(position); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wahrscheinlich ist es ineffizient, jedes Mal Reliefobjekte zu erstellen und zu zerst√∂ren.</font></font></b> <div class="spoiler_text"> , ,   .       .      .   ,  ,      ,    .          <code>HexFeatureManager.Apply</code> .      .  ,    ,       . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Platzierung von Reliefobjekten </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W√§hrend wir Objekte in der Mitte jeder Zelle platzieren. </font><font style="vertical-align: inherit;">F√ºr leere Zellen sieht dies normal aus, aber f√ºr Zellen, die Fl√ºsse und Stra√üen enthalten und mit Wasser √ºberflutet sind, scheint es seltsam.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/01d/e88/ab8/01de88ab8777d38afeb4ca374571a2f1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objekte sind √ºberall. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úberpr√ºfen Sie daher vor dem Platzieren des Objekts, </font></font><code>HexGridChunk.Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ob die Zelle leer ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !cell.HasRiver &amp;&amp; !cell.HasRoads) { features.AddFeature(cell.Position); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5db/b98/75f/5dbb9875f8510c7f9224f8ba10465ae4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Begrenzte Unterkunft.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ein Objekt pro Richtung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nur ein Objekt pro Zelle ist nicht zu viel. </font><font style="vertical-align: inherit;">Es gibt immer noch viel Platz f√ºr ein paar Gegenst√§nde. </font><font style="vertical-align: inherit;">Daher f√ºgen wir der Mitte jedes der sechs Dreiecke der Zelle ein zus√§tzliches Objekt hinzu, dh eines pro Richtung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden dies auf eine andere Weise tun </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wenn wir wissen, dass sich kein Fluss in der Zelle befindet. </font><font style="vertical-align: inherit;">Wir m√ºssen noch √ºberpr√ºfen, ob wir unter Wasser sind und ob sich eine Stra√üe in der Zelle befindet. </font><font style="vertical-align: inherit;">In diesem Fall interessieren wir uns jedoch nur f√ºr Stra√üen, die in die aktuelle Richtung verlaufen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiver) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateWithoutRiver(direction, cell, center, e); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !cell.HasRoadThroughEdge(direction)) { features.AddFeature((center + e.v1 + e.v5) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>)); } } ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e7/b60/d4b/7e7b60d4b54d2f9a7b3119e78554507a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Viele Einrichtungen, aber nicht in der N√§he von Fl√ºssen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dadurch entstehen viel mehr Objekte! </font><font style="vertical-align: inherit;">Sie erscheinen in der N√§he der Stra√üen, meiden aber dennoch die Fl√ºsse. </font><font style="vertical-align: inherit;">Um Objekte entlang von Fl√ºssen zu platzieren, k√∂nnen wir sie auch hinzuf√ºgen </font></font><code>TriangulateAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Aber wieder nur, wenn das Dreieck nicht unter Wasser ist und keine Stra√üe darauf ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !cell.HasRoadThroughEdge(direction)) { features.AddFeature((center + e.v1 + e.v5) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>)); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30c/90a/f9f/30c90af9ffb31cec360ea027fc4f1815.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objekte tauchten neben den Fl√ºssen auf.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ist es m√∂glich, so viele Objekte zu rendern?</font></font></b> <div class="spoiler_text">       ,    dynamic batching  Unity.    ,       .         batch.     ¬´ ¬ª,       .    instancing,          dynamic batching. </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vielzahl von Objekten </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle unsere Reliefobjekte haben die gleiche Ausrichtung, was v√∂llig unnat√ºrlich aussieht. </font><font style="vertical-align: inherit;">Lassen Sie uns jedem eine zuf√§llige Wendung geben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Transform instance = Instantiate(featurePrefab); position.y += instance.localScale.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.localPosition = HexMetrics.Perturb(position); instance.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span> * Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b42/8bd/0bc/b428bd0bcb9b27676853f7bb1e491165.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuf√§llige Drehungen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Ergebnis wird also viel vielf√§ltiger. </font><font style="vertical-align: inherit;">Leider erhalten Objekte jedes Mal, wenn ein Fragment aktualisiert wird, eine neue zuf√§llige Drehung. </font><font style="vertical-align: inherit;">Das Bearbeiten von Zellen sollte keine Objekte in der Nachbarschaft √§ndern, daher ben√∂tigen wir einen anderen Ansatz. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben eine Rauschstruktur, die immer gleich ist. </font><font style="vertical-align: inherit;">Diese Textur enth√§lt jedoch Perlin-Gradientenrauschen und ist lokal konsistent. </font><font style="vertical-align: inherit;">Dies ist genau das, was wir brauchen, wenn wir die Positionen von Eckpunkten in Zellen verzerren. </font><font style="vertical-align: inherit;">Aber die Kurven m√ºssen nicht konsistent sein. </font><font style="vertical-align: inherit;">Alle Windungen sollten gleich wahrscheinlich und gemischt sein. </font><font style="vertical-align: inherit;">Daher ben√∂tigen wir eine Textur mit zuf√§lligen Werten ohne Gradienten, die ohne bilineare Filterung abgetastet werden k√∂nnen. </font><font style="vertical-align: inherit;">Im Wesentlichen handelt es sich hierbei um ein Hash-Gitter, das die Grundlage f√ºr Gradientenrauschen bildet.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erstellen einer Hash-Tabelle </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen eine Hash-Tabelle aus einem Array von Float-Werten erstellen und sie einmal mit zuf√§lligen Werten f√ºllen. </font><font style="vertical-align: inherit;">Dank dessen brauchen wir √ºberhaupt keine Textur. </font><font style="vertical-align: inherit;">F√ºgen wir es hinzu </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Eine Gr√∂√üe von 256 x 256 reicht f√ºr eine ausreichende Variation aus.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hashGridSize = <span class="hljs-number"><span class="hljs-number">256</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] hashGrid; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeHashGrid</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hashGrid = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[hashGridSize * hashGridSize]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; hashGrid.Length; i++) { hashGrid[i] = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zufallswerte werden durch eine mathematische Formel generiert, die immer die gleichen Ergebnisse liefert. </font><font style="vertical-align: inherit;">Die resultierende Sequenz h√§ngt von der Anzahl der Seeds ab, die standardm√§√üig dem aktuellen Zeitwert entspricht. </font><font style="vertical-align: inherit;">Deshalb erhalten wir in jeder Spielsitzung unterschiedliche Ergebnisse. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um sicherzustellen, dass immer identische Objekte neu erstellt werden, m√ºssen wir den Startparameter zur Initialisierungsmethode hinzuf√ºgen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeHashGrid</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> seed</span></span></span><span class="hljs-function">)</span></span> { hashGrid = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[hashGridSize * hashGridSize]; Random.InitState(seed); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; hashGrid.Length; i++) { hashGrid[i] = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir den Zufallszahlenstrom initialisiert haben, erhalten wir immer die gleiche Reihenfolge. </font><font style="vertical-align: inherit;">Daher sind scheinbar zuf√§llige Ereignisse, die nach der Erstellung der Karte auftreten, auch immer gleich. </font><font style="vertical-align: inherit;">Wir k√∂nnen dies vermeiden, indem wir den Status des Zufallszahlengenerators speichern, bevor wir ihn initialisieren. </font><font style="vertical-align: inherit;">Nach Abschluss der Arbeiten k√∂nnen wir ihn nach dem alten Zustand fragen.</font></font><br><br><pre> <code class="cs hljs"> Random.State currentState = Random.state; Random.InitState(seed); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; hashGrid.Length; i++) { hashGrid[i] = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } Random.state = currentState;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Hash-Tabelle wird </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gleichzeitig mit der Zuweisung der Rauschtextur </font><font style="vertical-align: inherit;">initialisiert </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Das hei√üt, in den Methoden </font></font><code>HexGrid.Start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>HexGrid.Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir machen es so, dass die Werte nicht √∂fter als n√∂tig generiert werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> seed; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HexMetrics.noiseSource) { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit der generischen Startvariablen k√∂nnen wir den Startwert f√ºr die Karte ausw√§hlen. </font><font style="vertical-align: inherit;">Jeder Wert reicht aus. </font><font style="vertical-align: inherit;">Ich habe 1234 gew√§hlt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/60c/8b3/5a3/60c8b35a3b6a92b61165ed3a00473076.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Wahl des Samens.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verwenden einer Hash-Tabelle </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie der </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stichprobenmethode </font><font style="vertical-align: inherit;">hinzu, um die Hash-Tabelle zu </font><font style="vertical-align: inherit;">verwenden. </font><font style="vertical-align: inherit;">Ebenso </font></font><code>SampleNoise</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden die Koordinaten der XZ-Position verwendet, um den Wert zu erhalten. </font><font style="vertical-align: inherit;">Der Hash-Index wird ermittelt, indem die Koordinaten auf ganzzahlige Werte beschr√§nkt werden und dann der Rest der ganzzahligen Division durch die Gr√∂√üe der Tabelle ermittelt wird.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleHashGrid</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)position.x % hashGridSize; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)position.z % hashGridSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hashGrid[x + z * hashGridSize]; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was macht %?</font></font></b> <div class="spoiler_text">   ,     ,    ‚Äî  . ,  ‚àí4, ‚àí3, ‚àí2, ‚àí1, 0, 1, 2, 3, 4 modulo 3   ‚àí1, 0, ‚àí2, ‚àí1, 0, 1, 2, 0, 1. </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies funktioniert f√ºr positive Koordinaten, aber nicht f√ºr negative, da f√ºr solche Zahlen der Rest negativ ist. </font><font style="vertical-align: inherit;">Wir k√∂nnen dies beheben, indem wir die Gr√∂√üe der Tabelle zu den negativen Ergebnissen hinzuf√ºgen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)position.x % hashGridSize; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { x += hashGridSize; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)position.z % hashGridSize; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { z += hashGridSize; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt schaffen wir f√ºr jede quadratische Einheit unseren eigenen Wert. </font><font style="vertical-align: inherit;">Tats√§chlich ben√∂tigen wir jedoch keine solche Tabellendichte. </font><font style="vertical-align: inherit;">Objekte sind voneinander beabstandet. </font><font style="vertical-align: inherit;">Wir k√∂nnen die Tabelle dehnen, indem wir die Positionsskala reduzieren, bevor wir den Index berechnen. </font><font style="vertical-align: inherit;">Ein eindeutiger Wert f√ºr ein 4 x 4-Quadrat reicht f√ºr uns aus.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> hashGridScale = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleHashGrid</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(position.x * hashGridScale) % hashGridSize; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { x += hashGridSize; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(position.z * hashGridScale) % hashGridSize; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { z += hashGridSize; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hashGrid[x + z * hashGridSize]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gehen wir zur√ºck zu </font></font><code>HexFeatureManager.AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und verwenden Sie unsere neue Hash-Tabelle, um den Wert zu erhalten. </font><font style="vertical-align: inherit;">Nachdem wir es angewendet haben, um die Drehung festzulegen, bleiben die Objekte beim Bearbeiten des Gel√§ndes station√§r.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> hash = HexMetrics.SampleHashGrid(position); Transform instance = Instantiate(featurePrefab); position.y += instance.localScale.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.localPosition = HexMetrics.Perturb(position); instance.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span> * hash, <span class="hljs-number"><span class="hljs-number">0f</span></span>); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Platzierungsschwelle </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl Objekte unterschiedliche Rotationen haben, ist ein Muster in ihrer Platzierung immer noch erkennbar. </font><font style="vertical-align: inherit;">Jede Zelle hat sieben Objekte. </font><font style="vertical-align: inherit;">Wir k√∂nnen diesem Schema Chaos hinzuf√ºgen und einige der Objekte willk√ºrlich √ºberspringen. </font><font style="vertical-align: inherit;">Wie entscheiden wir, ob wir ein Objekt hinzuf√ºgen oder nicht? </font><font style="vertical-align: inherit;">Nat√ºrlich einen anderen zuf√§lligen Wert auschecken! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das hei√üt, anstelle eines Hashwerts ben√∂tigen wir zwei. </font><font style="vertical-align: inherit;">Ihre Unterst√ºtzung kann durch Verwendung von Hashes anstelle einer </font></font><code>float</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variablen </font><font style="vertical-align: inherit;">als Tabellenarraytyp hinzugef√ºgt werden </font></font><code>Vector2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Da Vektoroperationen f√ºr Hash-Werte jedoch keinen Sinn ergeben, erstellen wir zu diesem Zweck eine spezielle Struktur. </font><font style="vertical-align: inherit;">Sie ben√∂tigt nur zwei Float-Werte. </font><font style="vertical-align: inherit;">F√ºgen wir eine statische Methode hinzu, um ein Paar zuf√§lliger Werte zu erstellen.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> HexHash { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a, b; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexHash </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexHash hash; hash.a = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; hash.b = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash; } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muss es nicht serialisiert werden?</font></font></b> <div class="spoiler_text">        ,  ,        Unity. ,     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ñndern Sie es </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so, dass es die neue Struktur verwendet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> HexHash[] hashGrid; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeHashGrid</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> seed</span></span></span><span class="hljs-function">)</span></span> { hashGrid = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexHash[hashGridSize * hashGridSize]; Random.State currentState = Random.state; Random.InitState(seed); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; hashGrid.Length; i++) { hashGrid[i] = HexHash.Create(); } Random.state = currentState; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexHash </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleHashGrid</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hat jetzt </font></font><code>HexFeatureManager.AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zugriff auf zwei Hashwerte. </font><font style="vertical-align: inherit;">Lassen Sie uns zun√§chst entscheiden, ob ein Objekt hinzugef√ºgt oder √ºbersprungen werden soll. </font><font style="vertical-align: inherit;">Wenn der Wert gleich oder gr√∂√üer als 0,5 ist, √ºberspringen Sie. </font><font style="vertical-align: inherit;">Auf diese Weise werden wir etwa die H√§lfte der Objekte entfernen. </font><font style="vertical-align: inherit;">Der zweite Wert wird wie gewohnt zur Bestimmung der Drehung verwendet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { HexHash hash = HexMetrics.SampleHashGrid(position); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hash.a &gt;= <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Transform instance = Instantiate(featurePrefab); position.y += instance.localScale.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.localPosition = HexMetrics.Perturb(position); instance.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span> * hash.b, <span class="hljs-number"><span class="hljs-number">0f</span></span>); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e89/e69/761/e89e697613f8eef3d149b07720e8a26a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Dichte von Objekten wird um 50% reduziert. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objekte zeichnen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anstatt Objekte √ºberall zu platzieren, k√∂nnen Sie sie bearbeitbar machen. </font><font style="vertical-align: inherit;">Wir werden jedoch keine separaten Objekte zeichnen, sondern jeder Zelle die Objektebene hinzuf√ºgen. </font><font style="vertical-align: inherit;">Diese Stufe steuert die Wahrscheinlichkeit, dass Objekte in der Zelle erscheinen. </font><font style="vertical-align: inherit;">Standardm√§√üig ist der Wert Null, dh Objekte fehlen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da rote W√ºrfel in unserem Gel√§nde nicht wie nat√ºrliche Objekte aussehen, nennen wir sie Geb√§ude. </font><font style="vertical-align: inherit;">Sie werden die Urbanisierung darstellen. </font><font style="vertical-align: inherit;">F√ºgen wir den </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grad der Urbanisierung hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> UrbanLevel { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> urbanLevel; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (urbanLevel != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { urbanLevel = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; RefreshSelfOnly(); } } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> urbanLevel;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen den Urbanisierungsgrad f√ºr eine Unterwasserzelle auf Null setzen, aber das ist nicht notwendig, wir √ºberspringen trotzdem die Erstellung von Unterwasserobjekten. </font><font style="vertical-align: inherit;">Und vielleicht werden wir irgendwann Gew√§sser der Urbanisierung hinzuf√ºgen, wie Docks und Unterwasserstrukturen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dichteschieberegler </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um den Grad der Urbanisierung zu √§ndern, f√ºgen wir </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einen weiteren Schieberegler </font><font style="vertical-align: inherit;">zur </font><font style="vertical-align: inherit;">Unterst√ºtzung hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> activeUrbanLevel; ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> applyUrbanLevel; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetApplyUrbanLevel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { applyUrbanLevel = toggle; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetUrbanLevel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level</span></span></span><span class="hljs-function">)</span></span> { activeUrbanLevel = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)level; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyWaterLevel) { cell.WaterLevel = activeWaterLevel; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyUrbanLevel) { cell.UrbanLevel = activeUrbanLevel; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (riverMode == OptionalToggle.No) { cell.RemoveRiver(); } ‚Ä¶ } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie der Benutzeroberfl√§che einen weiteren Schieberegler hinzu und kombinieren Sie ihn mit den entsprechenden Methoden. </font><font style="vertical-align: inherit;">Ich werde ein neues Feld auf der rechten Seite des Bildschirms platzieren, um ein √úberlaufen des linken Feldes zu vermeiden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie viele Level brauchen wir? </font><font style="vertical-align: inherit;">Lassen Sie uns bei vier verweilen und Null, niedrige, mittlere und hohe Dichte bezeichnen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02f/e64/996/02fe649968954603df834d2a3b5f633b.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95e/9e4/6f5/95e9e46f5ff83a9b7d713e85db86d67a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Urbanisierungsregler.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schwellenwert√§nderung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt, da wir den Grad der Urbanisierung haben, m√ºssen wir ihn verwenden, um zu bestimmen, ob Objekte platziert werden sollen. </font><font style="vertical-align: inherit;">Dazu m√ºssen wir den Urbanisierungsgrad als zus√§tzlichen Parameter hinzuf√ºgen </font></font><code>HexFeatureManager.AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Machen wir noch einen Schritt und √ºbertragen einfach die Zelle selbst. </font><font style="vertical-align: inherit;">In Zukunft wird es f√ºr uns bequemer sein. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der schnellste Weg, den Urbanisierungsgrad zu verwenden, besteht darin, ihn mit 0,25 zu multiplizieren und den Wert als neuen Schwellenwert f√ºr das √úberspringen von Objekten zu verwenden. </font><font style="vertical-align: inherit;">Aus diesem Grund erh√∂ht sich die Wahrscheinlichkeit des Auftretens des Objekts mit jedem Level um 25%.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, Vector3 position</span></span></span><span class="hljs-function">)</span></span> { HexHash hash = HexMetrics.SampleHashGrid(position); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hash.a &gt;= cell.UrbanLevel * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit dies funktioniert, √ºbergeben wir die Zellen an </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !cell.HasRiver &amp;&amp; !cell.HasRoads) { features.AddFeature(cell, cell.Position); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !cell.HasRoadThroughEdge(direction)) { features.AddFeature(cell, (center + e.v1 + e.v5) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>)); } ‚Ä¶ } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !cell.HasRoadThroughEdge(direction)) { features.AddFeature(cell, (center + e.v1 + e.v5) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>)); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd8/7e9/de5/fd87e9de5b6b6ea4b4b490549ae5cbf5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeichnen der Urbanisierungsdichte. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mehrere Fertigh√§user von Reliefobjekten </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterschiede in der Wahrscheinlichkeit des Auftretens von Objekten reichen nicht aus, um eine klare Trennung zwischen niedrigem und hohem Urbanisierungsgrad zu erreichen. In einigen Zellen wird es einfach mehr oder weniger als die erwartete Anzahl von Geb√§uden geben. Wir k√∂nnen den Unterschied klarer machen, indem wir f√ºr jedes Level unser eigenes Fertighaus verwenden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden das Feld </font></font><code>featurePrefab</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font><font style="vertical-align: inherit;">loswerden </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und es durch ein Array f√ºr Fertigh√§user der Urbanisierung ersetzen. Um das passende Fertighaus zu erhalten, subtrahieren wir eines vom Urbanisierungsgrad und verwenden den Wert als Index.</font></font><br><br><pre> <code class="cs hljs">&lt;del&gt;<span class="hljs-comment"><span class="hljs-comment">// public Transform featurePrefab;&lt;/del&gt; public Transform[] urbanPrefabs; public void AddFeature (HexCell cell, Vector3 position) { ‚Ä¶ Transform instance = Instantiate(urbanPrefabs[cell.UrbanLevel - 1]); ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie zwei Duplikate des Fertighauses des Objekts, benennen Sie es um und √§ndern Sie es so, dass es drei verschiedene Urbanisierungsebenen anzeigt. </font><font style="vertical-align: inherit;">Stufe 1 ist eine niedrige Dichte, daher verwenden wir einen W√ºrfel mit einer Einheitsl√§nge einer Kante, der eine H√ºtte bezeichnet. </font><font style="vertical-align: inherit;">Ich werde das Fertighaus der Ebene 2 auf (1,5, 2, 1,5) skalieren, damit es wie ein zweist√∂ckiges Geb√§ude aussieht. </font><font style="vertical-align: inherit;">F√ºr hohe Geb√§ude der Stufe 3 habe ich die Skala (2, 5, 2) verwendet.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b83/4ad/cb6/b834adcb61a34d1e30cdec28925f066f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d4f/41d/552/d4f41d5529d4716924345520ffc36280.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwendung unterschiedlicher Fertigh√§user f√ºr jede Urbanisierungsstufe.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fertigmischung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir sind nicht verpflichtet, uns auf eine strikte Trennung der Geb√§udetypen zu beschr√§nken. Sie k√∂nnen sie ein wenig mischen, wie es in der realen Welt passiert. Verwenden Sie anstelle eines Schwellenwerts pro Ebene drei, einen f√ºr jeden Geb√§udetyp. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf Stufe 1 verwenden wir in 40% der F√§lle die Platzierung von H√ºtten. Es wird hier √ºberhaupt keine anderen Geb√§ude geben. F√ºr die Ebene verwenden wir die drei Werte (0,4, 0, 0). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ersetzen Sie auf Stufe 2 die H√ºtten durch gr√∂√üere Geb√§ude und erh√∂hen Sie die Wahrscheinlichkeit f√ºr zus√§tzliche H√ºtten um 20%. Wir werden keine hohen Geb√§ude bauen. Das hei√üt, wir verwenden den Schwellenwert drei Werte (0,2, 0,4, 0). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf Stufe 3 ersetzen wir mittlere Geb√§ude durch hohe, ersetzen erneut H√ºtten und erh√∂hen die Wahrscheinlichkeit von H√ºtten um weitere 20%. Die Schwellenwerte sind gleich (0,2, 0,2, 0,4).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das hei√üt, die Idee ist, dass wir mit zunehmendem Urbanisierungsgrad bestehende Geb√§ude aufwerten und leere Orte um neue erweitern werden. Um ein vorhandenes Geb√§ude zu entfernen, m√ºssen dieselben Hashwertintervalle verwendet werden. Wenn die Hashes zwischen 0 und 0,4 auf Ebene 1 H√ºtten waren, werden auf Ebene 3 im gleichen Intervall hohe Geb√§ude erstellt. Auf Stufe 3 sollten hohe Geb√§ude mit Hashes im Bereich von 0 bis 0,4, zweist√∂ckigen Geb√§uden im Bereich von 0,4 bis 0,6 und H√ºtten im Bereich von 0,6 bis 0,8 erstellt werden. Wenn Sie sie vom gr√∂√üten zum kleinsten pr√ºfen, kann dies mit dem Dreifach der Schwellenwerte (0,4, 0,6, 0,8) erfolgen. Die Schwellenwerte der Stufe 2 werden dann (0, 0,4, 0,6) und die Schwellenwerte der Stufe 1 werden (0, 0, 0,4). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speichern wir diese Schwellenwerte in</font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">als Sammlung von Arrays mit einer Methode, mit der Sie Schwellenwerte f√ºr eine bestimmte Ebene abrufen k√∂nnen. </font><font style="vertical-align: inherit;">Da wir nur an Ebenen mit Objekten interessiert sind, ignorieren wir Ebene 0.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[][] featureThresholds = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] {<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>}, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] {<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>}, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] {<span class="hljs-number"><span class="hljs-number">0.4f</span></span>, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>} }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFeatureThresholds</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> featureThresholds[level]; }</code> </pre> <br><font style="vertical-align: inherit;"></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie als </font><font style="vertical-align: inherit;">N√§chstes der </font><font style="vertical-align: inherit;">Methode hinzu, die die Hash-Ebene und den Wert verwendet, um das Fertighaus auszuw√§hlen. </font><font style="vertical-align: inherit;">Wenn der Pegel gr√∂√üer als Null ist, erhalten wir Schwellenwerte mit einem um eins reduzierten Pegel. </font><font style="vertical-align: inherit;">Dann durchlaufen wir die Schwellenwerte, bis einer von ihnen den Hashwert √ºberschreitet. </font><font style="vertical-align: inherit;">Dies bedeutet, dass wir ein Fertighaus gefunden haben. </font><font style="vertical-align: inherit;">Wenn wir nicht finden, geben Sie null zur√ºck.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Transform </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PickPrefab</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hash</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (level &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] thresholds = HexMetrics.GetFeatureThresholds(level - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; thresholds.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hash &lt; thresholds[i]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> urbanPrefabs[i]; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dieser Ansatz erfordert die Neuordnung von Links zu Fertigh√§usern, sodass diese von hoher zu niedriger Dichte wechseln. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4dc/eb5/80e/4dceb580e2410400a003b2ecad72d5c5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Invertierte Fertighausreihenfolge. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden unsere neue Methode verwenden </font></font><code>AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um ein Fertighaus auszuw√§hlen. </font><font style="vertical-align: inherit;">Wenn wir es nicht erhalten, √ºberspringen wir das Objekt. </font><font style="vertical-align: inherit;">Andernfalls erstellen Sie eine Instanz davon und fahren Sie wie zuvor fort.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, Vector3 position</span></span></span><span class="hljs-function">)</span></span> { HexHash hash = HexMetrics.SampleHashGrid(position); <span class="hljs-comment"><span class="hljs-comment">// if (hash.a &gt;= cell.UrbanLevel * 0.25f) { // return; // } // Transform instance = Instantiate(urbanPrefabs[cell.UrbanLevel - 1]); Transform prefab = PickPrefab(cell.UrbanLevel, hash.a); if (!prefab) { return; } Transform instance = Instantiate(prefab); position.y += instance.localScale.y * 0.5f; instance.localPosition = HexMetrics.Perturb(position); instance.localRotation = Quaternion.Euler(0f, 360f * hash.b, 0f); instance.SetParent(container, false); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d33/6f0/fcb/d336f0fcbf85285b38bb9c3de27ad77f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mischen Sie die Fertigh√§user.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pegelschwankungen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt haben wir gut gemischte Geb√§ude, aber bisher gibt es nur drei. </font><font style="vertical-align: inherit;">Wir k√∂nnen die Variabilit√§t weiter erh√∂hen, indem wir eine Sammlung von Fertigh√§usern mit jeder Ebene der Urbanisierungsdichte verkn√ºpfen. </font><font style="vertical-align: inherit;">Danach ist es m√∂glich, eine davon zuf√§llig auszuw√§hlen. </font><font style="vertical-align: inherit;">Dadurch wird einen neuen Zufallswert erfordern, so ein dritten hinzuzuf√ºgen </font></font><code>HexHash</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a, b, c; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexHash </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexHash hash; hash.a = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; hash.b = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; hash.c = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie es uns </font></font><code>HexFeatureManager.urbanPrefabs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in ein Array von Arrays </font><font style="vertical-align: inherit;">verwandeln </font><font style="vertical-align: inherit;">und der Methode einen </font></font><code>PickPrefab</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameter </font><font style="vertical-align: inherit;">hinzuf√ºgen </font></font><code>choice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir verwenden es, um den Index des eingebauten Arrays auszuw√§hlen, ihn mit der L√§nge dieses Arrays zu multiplizieren und in eine Ganzzahl umzuwandeln.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform[][] urbanPrefabs; ‚Ä¶ <span class="hljs-function"><span class="hljs-function">Transform </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PickPrefab</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hash, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> choice</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (level &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] thresholds = HexMetrics.GetFeatureThresholds(level - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; thresholds.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hash &lt; thresholds[i]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> urbanPrefabs[i][(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(choice * urbanPrefabs[i].Length)]; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Begr√ºnden wir unsere Wahl mit dem Wert des zweiten Hashs (B). </font><font style="vertical-align: inherit;">Dann m√ºssen Sie von B nach C abbiegen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, Vector3 position</span></span></span><span class="hljs-function">)</span></span> { HexHash hash = HexMetrics.SampleHashGrid(position); Transform prefab = PickPrefab(cell.UrbanLevel, hash.a, hash.b); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!prefab) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Transform instance = Instantiate(prefab); position.y += instance.localScale.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.localPosition = HexMetrics.Perturb(position); instance.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span> * hash.c, <span class="hljs-number"><span class="hljs-number">0f</span></span>); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevor wir fortfahren, m√ºssen wir √ºberlegen, was </font></font><code>Random.value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einen Wert von 1 zur√ºckgeben k√∂nnte. Aus diesem Grund kann der Array-Index dar√ºber hinausgehen. </font><font style="vertical-align: inherit;">Um dies zu verhindern, skalieren wir die Hash-Werte leicht. </font><font style="vertical-align: inherit;">Wir skalieren sie einfach alle, um uns keine Gedanken √ºber die von uns verwendeten Besonderheiten zu machen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexHash </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexHash hash; hash.a = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.999f</span></span>; hash.b = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.999f</span></span>; hash.c = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.999f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leider zeigt der Inspektor keine Arrays von Arrays an. </font><font style="vertical-align: inherit;">Daher k√∂nnen wir sie nicht konfigurieren. </font><font style="vertical-align: inherit;">Um diese Einschr√§nkung zu umgehen, erstellen Sie eine serialisierbare Struktur, in die das integrierte Array eingekapselt werden kann. </font><font style="vertical-align: inherit;">Geben wir ihr eine Methode, die von der Auswahl in den Array-Index konvertiert und ein Fertighaus zur√ºckgibt.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> HexFeatureCollection { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform[] prefabs; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Transform </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pick</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> choice</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prefabs[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(choice * prefabs.Length)]; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir verwenden </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anstelle von eingebauten Arrays ein Array solcher Sammlungen.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Transform[][] urbanPrefabs; public HexFeatureCollection[] urbanCollections; ‚Ä¶ Transform PickPrefab (int level, float hash, float choice) { if (level &gt; 0) { float[] thresholds = HexMetrics.GetFeatureThresholds(level - 1); for (int i = 0; i &lt; thresholds.Length; i++) { if (hash &lt; thresholds[i]) { return urbanCollections[i].Pick(choice); } } } return null; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir jeder Dichtestufe mehrere Geb√§ude zuweisen. </font><font style="vertical-align: inherit;">Da sie unabh√§ngig sind, m√ºssen wir nicht den gleichen Betrag pro Level verwenden. </font><font style="vertical-align: inherit;">Ich habe nur zwei Optionen pro Level verwendet und jeder eine l√§ngere niedrigere Option hinzugef√ºgt. </font><font style="vertical-align: inherit;">Ich habe die Skalen f√ºr sie (3,5, 3, 2), (2,75, 1,5, 1,5) und (1,75, 1, 1) gew√§hlt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b71/a6e/c9f/b71a6ec9f2c379c223e007dda071c94b.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a72/618/81d/a7261881d23703b54aaf22ba59942d2a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zwei Geb√§udetypen pro Dichtestufe. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verschiedene Arten von Objekten </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In dem bestehenden Schema k√∂nnen wir durchaus w√ºrdige st√§dtische Strukturen schaffen. </font><font style="vertical-align: inherit;">Das Relief kann aber nicht nur Geb√§ude enthalten. </font><font style="vertical-align: inherit;">Wie w√§re es mit Bauernh√∂fen oder Pflanzen? </font><font style="vertical-align: inherit;">Lassen Sie uns zu den </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ebenen und f√ºr sie </font><font style="vertical-align: inherit;">hinzuf√ºgen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sie schlie√üen sich nicht gegenseitig aus und k√∂nnen sich mischen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> FarmLevel { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> farmLevel; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (farmLevel != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { farmLevel = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; RefreshSelfOnly(); } } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> PlantLevel { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> plantLevel; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (plantLevel != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { plantLevel = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; RefreshSelfOnly(); } } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> urbanLevel, farmLevel, plantLevel;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies erfordert nat√ºrlich die Unterst√ºtzung von </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zwei zus√§tzlichen Schiebereglern.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> activeUrbanLevel, activeFarmLevel, activePlantLevel; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> applyUrbanLevel, applyFarmLevel, applyPlantLevel; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetApplyFarmLevel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { applyFarmLevel = toggle; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetFarmLevel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level</span></span></span><span class="hljs-function">)</span></span> { activeFarmLevel = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)level; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetApplyPlantLevel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { applyPlantLevel = toggle; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetPlantLevel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level</span></span></span><span class="hljs-function">)</span></span> { activePlantLevel = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)level; } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyUrbanLevel) { cell.UrbanLevel = activeUrbanLevel; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyFarmLevel) { cell.FarmLevel = activeFarmLevel; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyPlantLevel) { cell.PlantLevel = activePlantLevel; } ‚Ä¶ } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> F√ºgen Sie sie der Benutzeroberfl√§che hinzu. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/956/70b/f35/95670bf35594faa69fe46201b78080f7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drei Schieberegler.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Au√üerdem werden zus√§tzliche Sammlungen ben√∂tigt </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexFeatureCollection[] urbanCollections, farmCollections, plantCollections;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f5d/001/cec/f5d001cecb2bee3c60a0dad637de7dc9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drei Sammlungen von Reliefobjekten.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ich habe sowohl f√ºr Farmen als auch f√ºr Pflanzen zwei Fertigh√§user pro Dichtestufe sowie f√ºr den Bau von Sammlungen erstellt. F√ºr alle habe ich W√ºrfel verwendet. Bauernh√∂fe haben hellgr√ºnes Material, Pflanzen haben dunkelgr√ºnes Material. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe Farmw√ºrfel mit einer H√∂he von 0,1 Einheiten hergestellt, um quadratische Parzellen landwirtschaftlicher Fl√§chen anzuzeigen. Als hochdichte Skalen habe ich (2,5, 0,1, 2,5) und (3,5, 0,1, 2) gew√§hlt. Im Durchschnitt haben Standorte eine Fl√§che von 1,75 und eine Gr√∂√üe von 2,5 x 1,25. Im Bereich 1 wurde eine geringe Dichte und eine Gr√∂√üe von 1,5 mal 0,75 erhalten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fertige Pflanzen bezeichnen hohe B√§ume und gro√üe Str√§ucher. Fertigh√§user mit hoher Dichte sind die gr√∂√üten (1,25, 4,5, 1,25) und (1,5, 3, 1,5). Die durchschnittlichen Skalen sind (0,75, 3, 0,75) und (1, 1,5, 1). Die kleinsten Pflanzen haben Gr√∂√üen (0,5, 1,5, 0,5) und (0,75, 1, 0,75).</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Auswahl der Reliefmerkmale </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jeder Objekttyp muss einen eigenen Hashwert erhalten, damit sie unterschiedliche Erstellungsmuster haben und Sie sie mischen k√∂nnen. </font><font style="vertical-align: inherit;">F√ºgen Sie </font></font><code>HexHash</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zwei zus√§tzliche Werte hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a, b, c, d, e; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexHash </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexHash hash; hash.a = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.999f</span></span>; hash.b = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.999f</span></span>; hash.c = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.999f</span></span>; hash.d = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.999f</span></span>; hash.e = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.999f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt m√ºssen Sie </font></font><code>HexFeatureManager.PickPrefab</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit verschiedenen Sammlungen arbeiten. </font><font style="vertical-align: inherit;">F√ºgen Sie einen Parameter hinzu, um den Vorgang zu vereinfachen. </font><font style="vertical-align: inherit;">√Ñndern Sie au√üerdem den von der Variante des ausgew√§hlten Fertighauses verwendeten Hash in D und den Hash f√ºr die Rotation in E.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Transform </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PickPrefab</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexFeatureCollection[] collection, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hash, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> choice </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (level &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] thresholds = HexMetrics.GetFeatureThresholds(level - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; thresholds.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hash &lt; thresholds[i]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collection[i].Pick(choice); } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, Vector3 position</span></span></span><span class="hljs-function">)</span></span> { HexHash hash = HexMetrics.SampleHashGrid(position); Transform prefab = PickPrefab( urbanCollections, cell.UrbanLevel, hash.a, hash.d ); ‚Ä¶ instance.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span> * hash.e, <span class="hljs-number"><span class="hljs-number">0f</span></span>); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Derzeit </font></font><code>AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w√§hlt vorgefertigte Urbanisierung. </font><font style="vertical-align: inherit;">Das ist normal, wir brauchen mehr Optionen. </font><font style="vertical-align: inherit;">Deshalb f√ºgen wir ein weiteres Fertighaus von den Farmen hinzu. </font><font style="vertical-align: inherit;">Verwenden Sie als Hash-Wert B. Die Option ist wieder D.</font></font><br><br><pre> <code class="cs hljs"> Transform prefab = PickPrefab( urbanCollections, cell.UrbanLevel, hash.a, hash.d ); Transform otherPrefab = PickPrefab( farmCollections, cell.FarmLevel, hash.b, hash.d ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!prefab) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Welche Art von Fertiginstanz werden wir als Ergebnis erstellen? </font><font style="vertical-align: inherit;">Wenn sich herausstellt, dass einer von ihnen null ist, liegt die Wahl auf der Hand. </font><font style="vertical-align: inherit;">Wenn jedoch beide existieren, m√ºssen wir eine Entscheidung treffen. </font><font style="vertical-align: inherit;">F√ºgen wir einfach das Fertighaus mit dem niedrigsten Hashwert hinzu.</font></font><br><br><pre> <code class="cs hljs"> Transform otherPrefab = PickPrefab( farmCollections, cell.FarmLevel, hash.b, hash.d ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prefab) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab &amp;&amp; hash.b &lt; hash.a) { prefab = otherPrefab; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab) { prefab = otherPrefab; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/baf/369/d71/baf369d71420a1ded309880b38d94c53.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Mischung aus st√§dtischen und l√§ndlichen Objekten. </font></font></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Machen Sie dasselbe mit den Pflanzen, indem Sie den Wert des C-Hash verwenden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prefab) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab &amp;&amp; hash.b &lt; hash.a) { prefab = otherPrefab; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab) { prefab = otherPrefab; } otherPrefab = PickPrefab( plantCollections, cell.PlantLevel, hash.c, hash.d ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prefab) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab &amp;&amp; hash.c &lt; hash.a) { prefab = otherPrefab; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab) { prefab = otherPrefab; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen den Code jedoch nicht einfach kopieren. </font><font style="vertical-align: inherit;">Wenn wir l√§ndliches statt st√§dtisches Objekt w√§hlen, m√ºssen wir den Hasch der Pflanzen mit dem Hasch der Farmen vergleichen und nicht mit dem st√§dtischen. </font><font style="vertical-align: inherit;">Daher m√ºssen wir den Hash verfolgen, den wir ausgew√§hlt und mit ihm verglichen haben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> usedHash = hash.a; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prefab) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab &amp;&amp; hash.b &lt; hash.a) { prefab = otherPrefab; usedHash = hash.b; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab) { prefab = otherPrefab; usedHash = hash.b; } otherPrefab = PickPrefab( plantCollections, cell.PlantLevel, hash.c, hash.d ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prefab) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab &amp;&amp; hash.c &lt; usedHash) { prefab = otherPrefab; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab) { prefab = otherPrefab; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8eb/2e2/215/8eb2e2215e6219b08e8bc42612b31493.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Mischung aus st√§dtischen, l√§ndlichen und pflanzlichen Objekten. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil 10: W√§nde </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir schlie√üen die Zellen ein. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir bauen Mauern entlang der R√§nder der Zellen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lass uns durch Fl√ºsse und Stra√üen gehen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vermeiden Sie Wasser und verbinden Sie sich mit Klippen. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In diesem Teil werden wir zwischen den Zellen der Wand hinzuf√ºgen. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/924/d07/0cd/924d070cd67c3baccf02a0284ef9cdc4.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nichts ist einladender als eine hohe Mauer.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wandbearbeitung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die W√§nde zu st√ºtzen, m√ºssen wir wissen, wo sie platziert werden m√ºssen. </font><font style="vertical-align: inherit;">Wir werden sie zwischen die Zellen entlang der Kanten legen, die sie verbinden. </font><font style="vertical-align: inherit;">Da sich bereits vorhandene Objekte im zentralen Teil der Zellen befinden, m√ºssen wir uns keine Sorgen machen, dass die W√§nde durch sie hindurchgehen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a1/bbb/c11/7a1bbbc1158301bb0091638858fa79fd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W√§nde entlang der R√§nder. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W√§nde sind Gel√§ndeobjekte, obwohl sie gro√ü sind. </font><font style="vertical-align: inherit;">Wie andere Objekte werden wir sie nicht direkt bearbeiten. </font><font style="vertical-align: inherit;">Stattdessen werden wir die Zellen √§ndern. </font><font style="vertical-align: inherit;">Wir werden keine getrennten Segmente der W√§nde haben, sondern die Zellen als Ganzes einschlie√üen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ummauertes Eigentum </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie der </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eigenschaft </font><font style="vertical-align: inherit;">hinzu, um eingez√§unte Zellen zu unterst√ºtzen </font></font><code>Walled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies ist ein einfacher Schalter. </font><font style="vertical-align: inherit;">Da sich die W√§nde zwischen den Zellen befinden, m√ºssen wir sowohl die bearbeiteten Zellen als auch ihre Nachbarn aktualisieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Walled { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> walled; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (walled != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { walled = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Refresh(); } } } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> walled;</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Editor wechseln </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um den "eingez√§unten" Zustand der Zellen zu √§ndern, m√ºssen wir </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterst√ºtzung f√ºr den Schalter </font><font style="vertical-align: inherit;">hinzuf√ºgen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Daher f√ºgen wir ein weiteres Feld </font></font><code>OptionalToggle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und eine Methode zum Festlegen hinzu.</font></font><br><br><pre> <code class="cs hljs"> OptionalToggle riverMode, roadMode, walledMode; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetWalledMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mode</span></span></span><span class="hljs-function">)</span></span> { walledMode = (OptionalToggle)mode; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Gegensatz zu Fl√ºssen und Stra√üen verlaufen Mauern nicht von Zelle zu Zelle, sondern befinden sich zwischen ihnen. </font><font style="vertical-align: inherit;">Daher m√ºssen wir nicht √ºber Drag &amp; Drop nachdenken. </font><font style="vertical-align: inherit;">Wenn der Wandschalter aktiv ist, setzen wir einfach den eingez√§unten Zustand der aktuellen Zelle basierend auf dem Zustand dieses Schalters.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roadMode == OptionalToggle.No) { cell.RemoveRoads(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (walledMode != OptionalToggle.Ignore) { cell.Walled = walledMode == OptionalToggle.Yes; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isDrag) { ‚Ä¶ } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir duplizieren eines der vorherigen Elemente der UI-Schalter und √§ndern sie so, dass sie den Status des "Fechtens" steuern. </font><font style="vertical-align: inherit;">Ich werde sie zusammen mit anderen Objekten in das UI-Bedienfeld einf√ºgen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ac/f7f/0ca/0acf7f0caaaae171e31d42141fa75947.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Schalter "Fechten". </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> W√§nde schaffen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da die W√§nde den Konturen der Zellen folgen, sollten sie keine konstante Form haben. </font><font style="vertical-align: inherit;">Daher k√∂nnen wir nicht einfach ein Fertighaus f√ºr sie verwenden, wie wir es bei anderen Gel√§ndemerkmalen getan haben. </font><font style="vertical-align: inherit;">Stattdessen m√ºssen wir ein Netz bauen, wie wir es mit dem Relief getan haben. </font><font style="vertical-align: inherit;">Dies bedeutet, dass unser Fertighausfragment ein weiteres untergeordnetes Element ben√∂tigt </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Duplizieren Sie eines der anderen untergeordneten Netze und lassen Sie die neuen </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Walls-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objekte </font><font style="vertical-align: inherit;">Schatten werfen. </font><font style="vertical-align: inherit;">Sie ben√∂tigen nur Scheitelpunkte und Dreiecke, daher m√ºssen alle Optionen </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deaktiviert werden.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/615/387/31d/61538731d2eed271c9348c4da2f5d844.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2bf/c6e/af5/2bfc6eaf5ff31f5467ab252c00b7bcce.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tochtergefertigte Fertigmauern. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird logisch sein, dass die W√§nde ein st√§dtisches Objekt sind, deshalb habe ich f√ºr sie das rote Material der Geb√§ude verwendet.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wandverwaltung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da die W√§nde Reliefobjekte sind, m√ºssen sie sich mit ihnen befassen </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Daher wird der Manager Relief Objekt Referenz auf das Objekt geben </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Walls</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , und stellen Sie </font><font style="vertical-align: inherit;">sicher , </font><font style="vertical-align: inherit;">dass die Methoden aufrufen </font></font><code>Clear</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>Apply</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMesh walls; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ walls.Clear(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { walls.Apply(); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31d/8f9/0f3/31d8f90f315c7aa43910c67aab6b73cb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit dem Topografiemanager verbundene W√§nde.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sollten W√§nde nicht ein Kind von Features sein?</font></font></b> <div class="spoiler_text">       ,   .             ,    <em>Walls</em>    <em>Hex Grid Chunk</em> . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt m√ºssen wir dem Manager eine Methode hinzuf√ºgen, mit der wir ihm W√§nde hinzuf√ºgen k√∂nnen. </font><font style="vertical-align: inherit;">Da sich die W√§nde entlang der Kanten zwischen den Zellen befinden, muss er die entsprechenden Eckpunkte der Kanten und Zellen kennen. </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird es </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zum Zeitpunkt der Triangulation der Zelle und eines ihrer Nachbarn durch verursachen. </font><font style="vertical-align: inherit;">Unter diesem Gesichtspunkt befindet sich die aktuelle Zelle auf der nahen Seite der Wand und die andere auf der anderen Seite.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices near, HexCell nearCell, EdgeVertices far, HexCell farCell </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden diese neue Methode </font></font><code>HexGridChunk.TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nach Abschluss aller anderen Verbindungsarbeiten und unmittelbar vor dem √úbergang zum Winkeldreieck aufrufen. </font><font style="vertical-align: inherit;">Wir lassen den Manager der Reliefobjekte selbst entscheiden, wo sich die Wand tats√§chlich befinden soll.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ‚Ä¶ } features.AddWall(e1, cell, e2, neighbor); HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E &amp;&amp; nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { ‚Ä¶ } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bauen Sie ein Wandsegment </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die gesamte Wand schl√§ngelt sich durch mehrere Kanten der Zellen. </font><font style="vertical-align: inherit;">Jede Kante enth√§lt nur ein Wandelement. </font><font style="vertical-align: inherit;">Aus Sicht der nahen Zelle beginnt das Segment auf der linken Seite der Rippe und endet auf der rechten Seite. </font><font style="vertical-align: inherit;">F√ºgen wir eine </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">separate Methode hinzu, die vier Eckpunkte an den Ecken einer Kante verwendet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 nearLeft, Vector3 farLeft, Vector3 nearRight, Vector3 farRight </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f32/2a0/d7b/f322a0d7bc325b13f65c62cfb76b2d0c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nahe und ferne Seite. </font></font></i> <br><br> <code>AddWall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann diese Methode mit der ersten und letzten Kante der Kanten aufrufen. </font><font style="vertical-align: inherit;">W√§nde sollten jedoch nur hinzugef√ºgt werden, wenn eine Verbindung zwischen einer eingez√§unten Zelle und einer nicht eingez√§unten Zelle besteht. </font><font style="vertical-align: inherit;">Es spielt keine Rolle, welche der Zellen sich innerhalb und welche au√üerhalb befindet, nur der Unterschied in ihren Zust√§nden wird ber√ºcksichtigt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices near, HexCell nearCell, EdgeVertices far, HexCell farCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nearCell.Walled != farCell.Walled) { AddWallSegment(near.v1, far.v1, near.v5, far.v5); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das einfachste Segment der Wand ist ein Quad, das in der Mitte der Rippe steht. </font><font style="vertical-align: inherit;">Wir werden seine unteren Spitzen finden, die von den n√§chstgelegenen zu den am weitesten entfernten Spitzen in die Mitte interpolieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 nearLeft, Vector3 farLeft, Vector3 nearRight, Vector3 farRight </span></span></span><span class="hljs-function">)</span></span> { Vector3 left = Vector3.Lerp(nearLeft, farLeft, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); Vector3 right = Vector3.Lerp(nearRight, farRight, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie hoch sollte die Wand sein? </font><font style="vertical-align: inherit;">Stellen wir die H√∂he auf ein </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ich habe sie auf die Gr√∂√üe einer Zellenh√∂he gebracht.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> wallHeight = <span class="hljs-number"><span class="hljs-number">3f</span></span>;</code> </pre> <br> <code>HexFeatureManager.AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit dieser H√∂he k√∂nnen Sie den dritten und vierten Scheitelpunkt des Quad positionieren und dem Netz hinzuf√ºgen </font></font><code>walls</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> Vector3 left = Vector3.Lerp(nearLeft, farLeft, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); Vector3 right = Vector3.Lerp(nearRight, farRight, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); Vector3 v1, v2, v3, v4; v1 = v3 = left; v2 = v4 = right; v3.y = v4.y = left.y + HexMetrics.wallHeight; walls.AddQuad(v1, v2, v3, v4);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir die W√§nde bearbeiten und sie werden als Quad-Streifen angezeigt. </font><font style="vertical-align: inherit;">Wir werden jedoch keine durchgehende Wand sehen. </font><font style="vertical-align: inherit;">Jedes Quad ist nur auf einer Seite sichtbar. </font><font style="vertical-align: inherit;">Sein Gesicht ist auf die Zelle gerichtet, aus der es hinzugef√ºgt wurde.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5a/2f0/442/e5a2f0442a2d1812b73dd2977d80d565.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einseitige Quadw√§nde. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen dieses Problem schnell l√∂sen, indem wir ein zweites Quad hinzuf√ºgen, das in die andere Richtung zeigt.</font></font><br><br><pre> <code class="cs hljs"> walls.AddQuad(v1, v2, v3, v4); walls.AddQuad(v2, v1, v4, v3);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/302/e53/129/302e53129e87c3432848772688e9d896.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bilaterale W√§nde. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt sind alle W√§nde in ihrer Gesamtheit sichtbar, aber es gibt immer noch L√∂cher in den Ecken der Zellen, in denen sich die drei Zellen treffen. </font><font style="vertical-align: inherit;">Wir werden sie sp√§ter ausf√ºllen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dicke W√§nde </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl die W√§nde bereits auf beiden Seiten sichtbar sind, haben sie keine Dicke. </font><font style="vertical-align: inherit;">Tats√§chlich sind die W√§nde d√ºnn wie Papier und in einem bestimmten Winkel fast unsichtbar. </font><font style="vertical-align: inherit;">Machen wir sie also ganz, indem wir die Dicke hinzuf√ºgen. </font><font style="vertical-align: inherit;">Stellen Sie ihre Dicke ein </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ich habe einen Wert von 0,75 Einheiten gew√§hlt, es schien mir geeignet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> wallThickness = <span class="hljs-number"><span class="hljs-number">0.75f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um zwei W√§nde dick zu machen, m√ºssen Sie zwei Quads an den Seiten trennen. </font><font style="vertical-align: inherit;">Sie sollten sich in entgegengesetzte Richtungen bewegen. </font><font style="vertical-align: inherit;">Eine Seite sollte sich zur nahen Kante bewegen, die andere zur fernen Kante. </font><font style="vertical-align: inherit;">Der Versatzvektor hierf√ºr ist gleich </font></font><code>far - near</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber um die Oberseite der Wand flach zu lassen, m√ºssen wir ihre Komponente Y auf 0 setzen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da dies sowohl f√ºr die linke als auch f√ºr die rechte Seite des Wandsegments erfolgen muss, f√ºgen wir der </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode </font><font style="vertical-align: inherit;">einen </font><font style="vertical-align: inherit;">Versatzvektor hinzu, um dies zu berechnen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WallThicknessOffset</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 near, Vector3 far</span></span></span><span class="hljs-function">)</span></span> { Vector3 offset; offset.x = far.x - near.x; offset.y = <span class="hljs-number"><span class="hljs-number">0f</span></span>; offset.z = far.z - near.z; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> offset; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit die Wand in der Mitte der Rippe bleibt, sollte der tats√§chliche Bewegungsabstand entlang dieses Vektors der halben Dicke f√ºr jede Seite entsprechen. </font><font style="vertical-align: inherit;">Und um sicherzustellen, dass wir wirklich die richtige Strecke zur√ºckgelegt haben, normalisieren wir den Verschiebungsvektor, bevor wir ihn skalieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> offset.normalized * (wallThickness * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir verwenden diese Methode </font></font><code>HexFeatureManager.AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um die Position der Quads zu √§ndern. </font><font style="vertical-align: inherit;">Da der Verschiebungsvektor von der n√§chsten zur fernen Zelle geht, subtrahieren Sie ihn vom nahen Quad und addieren Sie zum fernen.</font></font><br><br><pre> <code class="cs hljs"> Vector3 left = Vector3.Lerp(nearLeft, farLeft, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); Vector3 right = Vector3.Lerp(nearRight, farRight, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); Vector3 leftThicknessOffset = HexMetrics.WallThicknessOffset(nearLeft, farLeft); Vector3 rightThicknessOffset = HexMetrics.WallThicknessOffset(nearRight, farRight); Vector3 v1, v2, v3, v4; v1 = v3 = left - leftThicknessOffset; v2 = v4 = right - rightThicknessOffset; v3.y = v4.y = left.y + HexMetrics.wallHeight; walls.AddQuad(v1, v2, v3, v4); v1 = v3 = left + leftThicknessOffset; v2 = v4 = right + rightThicknessOffset; v3.y = v4.y = left.y + HexMetrics.wallHeight; walls.AddQuad(v2, v1, v4, v3);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df7/746/08b/df774608b2b06114b4afbc6ec2904e61.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W√§nde mit Versatz. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Quads sind jetzt voreingenommen, obwohl dies nicht ganz auff√§llt.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sind die Wandst√§rken gleich?</font></font></b> <div class="spoiler_text">    ,      ¬´-¬ª     .      ,    .       .       ,   .    ,    .  , -      ,     .      . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spitzen der W√§nde </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Wandst√§rke von oben sichtbar zu machen, m√ºssen wir oben an der Wand ein Quad hinzuf√ºgen. </font><font style="vertical-align: inherit;">Der einfachste Weg, dies zu tun, besteht darin, sich die beiden oberen Eckpunkte des ersten Quadrats zu merken und sie mit den beiden oberen Eckpunkten des zweiten Quadrats zu verbinden.</font></font><br><br><pre> <code class="cs hljs"> Vector3 v1, v2, v3, v4; v1 = v3 = left - leftThicknessOffset; v2 = v4 = right - rightThicknessOffset; v3.y = v4.y = left.y + HexMetrics.wallHeight; walls.AddQuad(v1, v2, v3, v4); Vector3 t1 = v3, t2 = v4; v1 = v3 = left + leftThicknessOffset; v2 = v4 = right + rightThicknessOffset; v3.y = v4.y = left.y + HexMetrics.wallHeight; walls.AddQuad(v2, v1, v4, v3); walls.AddQuad(t1, t2, v3, v4);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d7/15d/627/1d715d627770a9e7a17bf135a461833d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W√§nde mit Spitzen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kurvenfahrt </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben immer noch L√∂cher an den Ecken der Zellen. </font><font style="vertical-align: inherit;">Um sie zu f√ºllen, m√ºssen wir dem dreieckigen Bereich zwischen den Zellen ein Segment hinzuf√ºgen. </font><font style="vertical-align: inherit;">Jede Ecke verbindet drei Zellen. </font><font style="vertical-align: inherit;">Jede Zelle kann eine Wand haben oder nicht. </font><font style="vertical-align: inherit;">Das hei√üt, acht Konfigurationen sind m√∂glich.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed9/277/8ee/ed92778ee39106d3a448892a124d366c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Winkelkonfigurationen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir platzieren W√§nde nur zwischen Zellen mit unterschiedlichen eingez√§unten Zust√§nden. </font><font style="vertical-align: inherit;">Dies reduziert die Anzahl der Konfigurationen auf sechs. </font><font style="vertical-align: inherit;">In jedem von ihnen befindet sich eine der Zellen innerhalb der Kr√ºmmung der W√§nde. </font><font style="vertical-align: inherit;">Betrachten wir diese Zelle als Referenzpunkt, um den die Wand gekr√ºmmt ist. </font><font style="vertical-align: inherit;">Aus der Sicht dieser Zelle beginnt die Wand mit einer Kante, die der linken Zelle gemeinsam ist, und endet mit einer Kante, die der rechten Zelle gemeinsam ist.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48e/f68/19a/48ef6819a839339a17d1513f7ca546b5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zellrollen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das hei√üt, wir m√ºssen eine Methode erstellen, </font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deren Parameter drei Eckpunkte der Ecke sind. </font><font style="vertical-align: inherit;">Obwohl wir Code schreiben k√∂nnen, um dieses Segment zu triangulieren, ist dies tats√§chlich ein Sonderfall der Methode </font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ein Ankerpunkt spielt die Rolle beider naher Eckpunkte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 pivot, HexCell pivotCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { AddWallSegment(pivot, left, pivot, right); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie als N√§chstes eine Variante der Methode </font></font><code>AddWall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f√ºr die drei Eckpunkte des Winkels und ihre Zellen. </font><font style="vertical-align: inherit;">Das Ziel dieser Methode ist es, den Winkel zu bestimmen, der der Referenzpunkt ist, falls vorhanden. </font><font style="vertical-align: inherit;">Daher muss er alle acht m√∂glichen Konfigurationen ber√ºcksichtigen und </font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sechs davon anfordern.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 c1, HexCell cell1, Vector3 c2, HexCell cell2, Vector3 c3, HexCell cell3 </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell1.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell2.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell3.Walled) { AddWallSegment(c3, cell3, c1, cell1, c2, cell2); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell3.Walled) { AddWallSegment(c2, cell2, c3, cell3, c1, cell1); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddWallSegment(c1, cell1, c2, cell2, c3, cell3); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell2.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell3.Walled) { AddWallSegment(c1, cell1, c2, cell2, c3, cell3); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddWallSegment(c2, cell2, c3, cell3, c1, cell1); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell3.Walled) { AddWallSegment(c3, cell3, c1, cell1, c2, cell2); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rufen Sie diese Methode am Ende auf, um Eckensegmente hinzuzuf√ºgen </font></font><code>HexGridChunk.TriangulateCorner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ features.AddWall(bottom, bottomCell, left, leftCell, right, rightCell); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a8e/e63/304/a8ee63304fce04d4db9dcdf46076b3a9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W√§nde mit Ecken, aber es gibt noch L√∂cher.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schlie√üen Sie die L√∂cher </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt immer noch L√∂cher in den W√§nden, da die H√∂he der Wandsegmente variabel ist. W√§hrend die Segmente entlang der Kanten eine konstante H√∂he haben, befinden sich die Ecksegmente zwischen zwei verschiedenen Kanten. Da jede Kante ihre eigene H√∂he haben kann, erscheinen an den Ecken L√∂cher. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um dies zu beheben, √§ndern Sie </font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es so, dass die Y-Koordinaten des linken und rechten oberen Scheitelpunkts getrennt gespeichert werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> leftTop = left.y + HexMetrics.wallHeight; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rightTop = right.y + HexMetrics.wallHeight; Vector3 v1, v2, v3, v4; v1 = v3 = left - leftThicknessOffset; v2 = v4 = right - rightThicknessOffset; v3.y = leftTop; v4.y = rightTop; walls.AddQuad(v1, v2, v3, v4); Vector3 t1 = v3, t2 = v4; v1 = v3 = left + leftThicknessOffset; v2 = v4 = right + rightThicknessOffset; v3.y = leftTop; v4.y = rightTop; walls.AddQuad(v2, v1, v4, v3);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9cd/f1d/a88/9cdf1da889ce427e1d519a284532d6a8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geschlossene W√§nde.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die W√§nde sind jetzt geschlossen, aber Sie sehen wahrscheinlich immer noch L√∂cher in den Schatten der Wand. Dies wird durch den Parameter </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normal Bias</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der </font><font style="vertical-align: inherit;">Richtungsschatteneinstellung verursacht. Wenn es gr√∂√üer als Null ist, bewegen sich die Dreiecke der Objekte, die einen Schatten werfen, entlang der Normalen zur Oberfl√§che. Dies vermeidet Selbstbeschattung, erzeugt aber gleichzeitig L√∂cher in F√§llen, in denen die Dreiecke in verschiedene Richtungen schauen. In diesem Fall k√∂nnen L√∂cher in den Schatten feiner Geometrie erzeugt werden, beispielsweise in unseren W√§nden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen diese Schattenartefakte entfernen, indem Sie die normale Vorspannung auf Null senken. Oder √§ndern Sie den </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cast Shadows</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mesh Renderer- </font><font style="vertical-align: inherit;">Wandmodus </font><font style="vertical-align: inherit;">in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Two Sided</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dadurch rendert das Schattenwurfobjekt beide Seiten jedes Wanddreiecks zum Rendern, wodurch alle L√∂cher geschlossen werden.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b14/9d5/d0b/b149d5d0bb36f049faa5ca9d49261618.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt keine L√∂cher mehr in den Schatten. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Leistenwand </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher sind unsere W√§nde gerade genug. </font><font style="vertical-align: inherit;">F√ºr ein flaches Gel√§nde ist dies √ºberhaupt nicht schlecht, aber es sieht seltsam aus, wenn die W√§nde mit den Leisten zusammenfallen. </font><font style="vertical-align: inherit;">Dies geschieht, wenn zwischen Zellen auf gegen√ºberliegenden Seiten der Wand ein H√∂henunterschied von einer H√∂he besteht.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/065/481/c1a/065481c1a0859ced22d0ae6568acbe86.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gerade W√§nde auf den Leisten.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Folgen Sie der Kante </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anstatt ein Segment f√ºr die gesamte Kante zu erstellen, erstellen wir eines f√ºr jeden Teil des Kantenstreifens. </font><font style="vertical-align: inherit;">Wir k√∂nnen dies tun, indem wir </font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der </font></font><code>AddWall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Edge- </font><font style="vertical-align: inherit;">Version </font><font style="vertical-align: inherit;">viermal aufrufen </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices near, HexCell nearCell, EdgeVertices far, HexCell farCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nearCell.Walled != farCell.Walled) { AddWallSegment(near.v1, far.v1, near.v2, far.v2); AddWallSegment(near.v2, far.v2, near.v3, far.v3); AddWallSegment(near.v3, far.v3, near.v4, far.v4); AddWallSegment(near.v4, far.v4, near.v5, far.v5); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a96/8aa/0f9/a968aa0f984b31e81dc9edb12e8d31bb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geschwungene W√§nde. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W√§nde wiederholen nun die Form verzerrter Kanten. </font><font style="vertical-align: inherit;">In Kombination mit den Leisten sieht es viel besser aus. </font><font style="vertical-align: inherit;">Dar√ºber hinaus entstehen interessantere W√§nde auf einem flachen Relief.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> W√§nde auf den Boden stellen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie sich die W√§nde auf den Leisten ansehen, k√∂nnen Sie ein Problem feststellen. Die W√§nde h√§ngen √ºber dem Boden! Dies gilt f√ºr geneigte flache Kanten, ist aber normalerweise nicht so auff√§llig.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/039/8f0/a59/0398f0a59aca756824e162c3fba5a891.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W√§nde h√§ngen in der Luft.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um das Problem zu l√∂sen, m√ºssen wir die W√§nde absenken. Am einfachsten ist es, die gesamte Wand so abzusenken, dass ihre Oberseite flach bleibt. Gleichzeitig senkt sich ein Teil der Wand auf der Oberseite leicht in das Relief, aber das passt zu uns. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Wand abzusenken, m√ºssen wir bestimmen, welche Seite niedriger ist - nah oder fern. Wir k√∂nnen nur die H√∂he der untersten Seite verwenden, m√ºssen aber nicht so tief gehen. Sie k√∂nnen die Y-Koordinate mit einem Versatz von knapp 0,5 von niedrig nach hoch interpolieren. Da die W√§nde nur gelegentlich h√∂her als die untere Stufe der Kante werden, k√∂nnen wir die vertikale Stufe der Kante als Versatz verwenden. Eine unterschiedliche Wandst√§rke der Leistenkonfiguration kann einen anderen Versatz erfordern.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/960/61c/817/96061c817bfdc69db9682e0799ba3751.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die abgesenkte Wand. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen wir der </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode </font></font><code>WallLerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die sich mit dieser Interpolation befasst, zus√§tzlich zur Mittelung der X- und Z-Koordinaten der nahen und fernen Eckpunkte hinzu. </font><font style="vertical-align: inherit;">Es basiert auf einer Methode </font></font><code>TerraceLerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> wallElevationOffset = verticalTerraceStepSize; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WallLerp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 near, Vector3 far</span></span></span><span class="hljs-function">)</span></span> { near.x += (far.x - near.x) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; near.z += (far.z - near.z) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> v = near.y &lt; far.y ? wallElevationOffset : (<span class="hljs-number"><span class="hljs-number">1f</span></span> - wallElevationOffset); near.y += (far.y - near.y) * v; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> near; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erzwingen Sie </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diese Methode, um den linken und rechten Scheitelpunkt zu bestimmen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 nearLeft, Vector3 farLeft, Vector3 nearRight, Vector3 farRight </span></span></span><span class="hljs-function">)</span></span> { Vector3 left = HexMetrics.WallLerp(nearLeft, farLeft); Vector3 right = HexMetrics.WallLerp(nearRight, farRight); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/957/a4c/b49/957a4cb498eb8a712064a0b99a4041be.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W√§nde stehen auf dem Boden.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √Ñnderung der Wandverzerrung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt stimmen unsere W√§nde gut mit H√∂henunterschieden √ºberein. Sie entsprechen jedoch immer noch nicht vollst√§ndig den verzerrten Kanten, obwohl sie sich in ihrer N√§he befinden. Dies geschah, weil wir zuerst die Oberseiten der W√§nde bestimmen und sie dann verzerren. Da diese Scheitelpunkte irgendwo zwischen den Scheitelpunkten der nahen und fernen Kante liegen, ist ihre Verzerrung geringf√ºgig unterschiedlich. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Tatsache, dass die W√§nde den Rippen ungenau folgen, ist kein Problem. Die Verformung der Wandoberseiten √§ndert sich jedoch ansonsten relativ gleichm√§√üige Dicke. Wenn wir die W√§nde basierend auf verzerrten Eckpunkten anordnen und dann unverzerrte Quads hinzuf√ºgen, sollte ihre Dicke nicht stark variieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 nearLeft, Vector3 farLeft, Vector3 nearRight, Vector3 farRight </span></span></span><span class="hljs-function">)</span></span> { nearLeft = HexMetrics.Perturb(nearLeft); farLeft = HexMetrics.Perturb(farLeft); nearRight = HexMetrics.Perturb(nearRight); farRight = HexMetrics.Perturb(farRight); ‚Ä¶ walls.AddQuadUnperturbed(v1, v2, v3, v4); ‚Ä¶ walls.AddQuadUnperturbed(v2, v1, v4, v3); walls.AddQuadUnperturbed(t1, t2, v3, v4); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b10/fa3/03d/b10fa303dc91a50665bf92b47feed5e7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die unverzerrten Oberseiten der W√§nde. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dank dieses Ansatzes folgen die W√§nde nicht mehr so ‚Äã‚Äãgenau wie zuvor den Kanten. </font><font style="vertical-align: inherit;">Im Gegenzug werden sie jedoch weniger gebrochen und haben eine konstantere Dicke.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d38/7f6/b6f/d387f6b6f1c4fed424d2582a8ef5c12c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gleichm√§√üigere Wandst√§rke. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L√∂cher in den W√§nden </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher haben wir die M√∂glichkeit ignoriert, dass ein Fluss oder eine Stra√üe die Mauer √ºberquert. </font><font style="vertical-align: inherit;">In diesem Fall m√ºssen wir ein Loch in die Wand bohren, durch das ein Fluss oder eine Stra√üe f√ºhren kann. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie dazu </font></font><code>AddWall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zwei Boolesche Parameter hinzu, um anzugeben, ob ein Fluss oder eine Stra√üe durch eine Kante verl√§uft. </font><font style="vertical-align: inherit;">Obwohl wir sie unterschiedlich behandeln k√∂nnen, entfernen wir in beiden F√§llen einfach die beiden mittleren Segmente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices near, HexCell nearCell, EdgeVertices far, HexCell farCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRiver, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nearCell.Walled != farCell.Walled) { AddWallSegment(near.v1, far.v1, near.v2, far.v2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRiver || hasRoad) { <span class="hljs-comment"><span class="hljs-comment">// Leave a gap. } else { AddWallSegment(near.v2, far.v2, near.v3, far.v3); AddWallSegment(near.v3, far.v3, near.v4, far.v4); } AddWallSegment(near.v4, far.v4, near.v5, far.v5); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt </font></font><code>HexGridChunk.TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sollte es die notwendigen Daten liefern. </font><font style="vertical-align: inherit;">Da er bereits dieselben Informationen ben√∂tigte, speichern wir sie in booleschen Variablen und zeichnen die Aufrufe der entsprechenden Methoden nur einmal auf.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasRiver = cell.HasRiverThroughEdge(direction); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasRoad = cell.HasRoadThroughEdge(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRiver) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(e1, cell, e2, neighbor, hasRoad); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateEdgeStrip(e1, cell.Color, e2, neighbor.Color, hasRoad); } features.AddWall(e1, cell, e2, neighbor, hasRiver, hasRoad); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64c/d05/425/64cd0542540b5d9347a071d727fe2fa4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die L√∂cher in den W√§nden f√ºr den Durchgang von Fl√ºssen und Stra√üen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir bedecken die W√§nde </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese neuen √ñffnungen schaffen Orte, um die W√§nde zu vervollst√§ndigen. </font><font style="vertical-align: inherit;">Wir m√ºssen diese Endpunkte mit Quads schlie√üen, damit wir nicht durch die Seiten der W√§nde schauen k√∂nnen. </font><font style="vertical-align: inherit;">Erstellen wir zu diesem Zweck eine </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode </font></font><code>AddWallCap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es funktioniert wie </font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber es braucht nur ein Paar Nah-Fern-Spitzen. </font><font style="vertical-align: inherit;">Lassen Sie ihn ein Quad hinzuf√ºgen, das von der nahen zur anderen Seite der Wand geht.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallCap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 near, Vector3 far</span></span></span><span class="hljs-function">)</span></span> { near = HexMetrics.Perturb(near); far = HexMetrics.Perturb(far); Vector3 center = HexMetrics.WallLerp(near, far); Vector3 thickness = HexMetrics.WallThicknessOffset(near, far); Vector3 v1, v2, v3, v4; v1 = v3 = center - thickness; v2 = v4 = center + thickness; v3.y = v4.y = center.y + HexMetrics.wallHeight; walls.AddQuadUnperturbed(v1, v2, v3, v4); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn sich </font></font><code>AddWall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">herausstellt, dass wir ein Loch ben√∂tigen, f√ºgen wir eine Abdeckung zwischen dem zweiten und vierten Kantenpaar der Kanten hinzu. </font><font style="vertical-align: inherit;">F√ºr das vierte Scheitelpunktpaar m√ºssen Sie die Ausrichtung √§ndern, da sonst die Quad-Fl√§che nach innen schaut.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices near, HexCell nearCell, EdgeVertices far, HexCell farCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRiver, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nearCell.Walled != farCell.Walled) { AddWallSegment(near.v1, far.v1, near.v2, far.v2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRiver || hasRoad) { AddWallCap(near.v2, far.v2); AddWallCap(far.v4, near.v4); } ‚Ä¶ } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/413/98c/828/41398c82892a2c1f706ca85c9230813a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geschlossene L√∂cher in den W√§nden.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist mit L√∂chern an den R√§ndern der Karte?</font></font></b> <div class="spoiler_text">   ,     .        .    ,        . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vermeiden Sie Klippen und Wasser </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauen wir uns zum Schluss Kanten an, die Klippen oder Wasser enthalten. </font><font style="vertical-align: inherit;">Da es sich bei den Klippen im Wesentlichen um gro√üe Mauern handelt, w√§re es unlogisch, eine zus√§tzliche Mauer darauf zu platzieren. </font><font style="vertical-align: inherit;">Au√üerdem wird es schlecht aussehen. </font><font style="vertical-align: inherit;">Unterwasserw√§nde sind ebenso v√∂llig unlogisch wie die Einschr√§nkung durch die K√ºstenw√§nde.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45a/94e/027/45a94e027094c6ebdae0763663d6eb8e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W√§nde auf Klippen und im Wasser. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen die W√§nde von diesen unn√∂tigen Kanten durch zus√§tzliches Einchecken entfernen </font></font><code>AddWall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Eine Wand kann nicht unter Wasser sein, und eine gemeinsame Rippe kann keine Klippe sein.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices near, HexCell nearCell, EdgeVertices far, HexCell farCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRiver, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( nearCell.Walled != farCell.Walled &amp;&amp; !nearCell.IsUnderwater &amp;&amp; !farCell.IsUnderwater &amp;&amp; nearCell.GetEdgeType(farCell) != HexEdgeType.Cliff ) { ‚Ä¶ } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/128/baf/75a/128baf75ace7d0cf4ed5f12ef380eec8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die st√∂renden W√§nde entlang der Rippen wurden entfernt, aber die Ecken blieben an Ort und Stelle.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wandecken entfernen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Entfernen unn√∂tiger Ecksegmente erfordert etwas mehr Aufwand. </font><font style="vertical-align: inherit;">Der einfachste Fall ist, wenn sich die St√ºtzzelle unter Wasser befindet. </font><font style="vertical-align: inherit;">Dadurch wird sichergestellt, dass keine Wandsegmente in der N√§he angeschlossen werden k√∂nnen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 pivot, HexCell pivotCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pivotCell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } AddWallSegment(pivot, left, pivot, right); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecc/475/9f3/ecc4759f38ced7802ad8743626f91d51.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt keine Unterwasser-St√ºtzzellen mehr. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt m√ºssen wir uns zwei andere Zellen ansehen. </font><font style="vertical-align: inherit;">Befindet sich einer von ihnen unter Wasser oder ist er durch eine Unterbrechung mit der St√ºtzzelle verbunden, gibt es entlang dieser Rippe keine Wand. </font><font style="vertical-align: inherit;">Wenn dies f√ºr mindestens eine Seite zutrifft, sollte sich in dieser Ecke kein Wandsegment befinden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir bestimmen individuell, ob es eine linke oder eine rechte Wand gibt. </font><font style="vertical-align: inherit;">Wir setzen die Ergebnisse in boolesche Variablen, um die Arbeit zu erleichtern.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pivotCell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasLeftWall = !leftCell.IsUnderwater &amp;&amp; pivotCell.GetEdgeType(leftCell) != HexEdgeType.Cliff; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasRighWall = !rightCell.IsUnderwater &amp;&amp; pivotCell.GetEdgeType(rightCell) != HexEdgeType.Cliff; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasLeftWall &amp;&amp; hasRighWall) { AddWallSegment(pivot, left, pivot, right); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cd/f17/82d/8cdf1782d522d5b9e19e461ee5253436.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle St√∂rwinkel entfernt.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schlie√üen Sie die Ecken </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn sich weder am linken noch am rechten Rand eine Wand befindet, sind die Arbeiten abgeschlossen. </font><font style="vertical-align: inherit;">Wenn sich die Wand jedoch nur in eine Richtung befindet, bedeutet dies, dass sich ein weiteres Loch in der Wand befindet. </font><font style="vertical-align: inherit;">Daher m√ºssen Sie es schlie√üen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasLeftWall) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRighWall) { AddWallSegment(pivot, left, pivot, right); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddWallCap(pivot, left); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRighWall) { AddWallCap(right, pivot); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/20e/c4d/176/20ec4d17689500d123fc5fd41d447e88.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir schlie√üen die W√§nde.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verbindung von Mauern mit Klippen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In einer Situation sehen die W√§nde unvollkommen aus. </font><font style="vertical-align: inherit;">Wenn die Wand den Boden der Klippe erreicht, endet sie. </font><font style="vertical-align: inherit;">Da die Klippen jedoch nicht vollst√§ndig vertikal sind, entsteht zwischen der Wand und dem Rand der Klippe ein schmales Loch. </font><font style="vertical-align: inherit;">Oben auf der Klippe tritt ein solches Problem nicht auf.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/633/5c6/9a7/6335c69a7f45dcd1c2a0609503b2504a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L√∂cher zwischen W√§nden und Felsw√§nden. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es w√§re viel besser, wenn die Mauer bis zum Rand der Klippe reichen w√ºrde. </font><font style="vertical-align: inherit;">Wir k√∂nnen dies tun, indem wir ein weiteres Wandsegment zwischen dem aktuellen Ende der Wand und der Ecke oben auf der Klippe hinzuf√ºgen. </font><font style="vertical-align: inherit;">Da der gr√∂√üte Teil dieses Segments in der Klippe verborgen ist, k√∂nnen wir darauf verzichten, die Wandst√§rke innerhalb der Klippe auf Null zu reduzieren. </font><font style="vertical-align: inherit;">Es reicht uns also, einen Keil zu erstellen: zwei Quads, die auf den Punkt gehen, und ein Dreieck dar√ºber. </font><font style="vertical-align: inherit;">Erstellen wir zu diesem Zweck eine Methode </font></font><code>AddWallWedge</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies kann durch Kopieren </font></font><code>AddWallCap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und Hinzuf√ºgen eines Keilpunkts erfolgen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallWedge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 near, Vector3 far, Vector3 point</span></span></span><span class="hljs-function">)</span></span> { near = HexMetrics.Perturb(near); far = HexMetrics.Perturb(far); point = HexMetrics.Perturb(point); Vector3 center = HexMetrics.WallLerp(near, far); Vector3 thickness = HexMetrics.WallThicknessOffset(near, far); Vector3 v1, v2, v3, v4; Vector3 pointTop = point; point.y = center.y; v1 = v3 = center - thickness; v2 = v4 = center + thickness; v3.y = v4.y = pointTop.y = center.y + HexMetrics.wallHeight; <span class="hljs-comment"><span class="hljs-comment">// walls.AddQuadUnperturbed(v1, v2, v3, v4); walls.AddQuadUnperturbed(v1, point, v3, pointTop); walls.AddQuadUnperturbed(point, v2, pointTop, v4); walls.AddTriangleUnperturbed(pointTop, v3, v4); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In </font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ecken nennen wir diese Methode, wenn die Wand nur in eine Richtung verl√§uft und sich diese Wand auf einer niedrigeren H√∂he als die andere Seite befindet. </font><font style="vertical-align: inherit;">Unter diesen Bedingungen sto√üen wir auf den Rand einer Klippe.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasLeftWall) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRighWall) { AddWallSegment(pivot, left, pivot, right); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.Elevation &lt; rightCell.Elevation) { AddWallWedge(pivot, left, right); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddWallCap(pivot, left); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRighWall) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightCell.Elevation &lt; leftCell.Elevation) { AddWallWedge(right, pivot, left); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddWallCap(right, pivot); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5c/30f/33a/b5c30f33ac93582e2ce319996d9ed1ac.png"></div><br> <i> ,   .</i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">unitypackage</a> <br><br><h1>  11:    </h1><br><ul><li>    . </li><li>     . </li><li>     . </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef5/a07/5ea/ef5a075ea4c14c810825388be274f817.jpg"></div><br> <i>  .</i> <br><br><h2>    </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im vorherigen Teil haben wir eine Wandst√ºtze hinzugef√ºgt. Dies sind einfache gerade Wandsegmente ohne erkennbare Unterschiede. Jetzt werden wir die W√§nde interessanter machen, indem wir ihnen T√ºrme hinzuf√ºgen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wandsegmente m√ºssen prozedural erstellt werden, um dem Relief zu entsprechen. Dies ist f√ºr die T√ºrme nicht erforderlich, wir k√∂nnen das √ºbliche Fertighaus verwenden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen einen einfachen Turm aus zwei W√ºrfeln mit rotem Material erstellen. Die Basis des Turms hat eine Gr√∂√üe von 2 mal 2 Einheiten und eine H√∂he von 4 Einheiten, dh sie ist dicker und h√∂her als die Wand. √úber diesem W√ºrfel platzieren wir einen Einheitsw√ºrfel, der die Spitze des Turms kennzeichnet. Wie alle anderen Fertigh√§user ben√∂tigen diese W√ºrfel keine Kollider.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da das Turmmodell aus mehreren Objekten besteht, machen wir sie zu Kindern des Stammobjekts. </font><font style="vertical-align: inherit;">Platzieren Sie sie so, dass der lokale Ursprung der Wurzel am Fu√ü des Turms liegt. </font><font style="vertical-align: inherit;">Dank dessen k√∂nnen wir die T√ºrme platzieren, ohne uns um ihre H√∂he sorgen zu m√ºssen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f1/a54/335/2f1a54335d81a6682707e740107362c6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fertighaus. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie einen Link zu diesem Fertighaus hinzu </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und verbinden Sie es.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform wallTower;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f76/df1/c7e/f76df1c7e5b1c808d2ae636f7e823487.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link zum Fertighaus.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> T√ºrme bauen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beginnen wir mit der Platzierung von T√ºrmen in der Mitte jedes Wandsegments. </font><font style="vertical-align: inherit;">Dazu erstellen wir am Ende der Methode einen Turm </font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ihre Position ist der Durchschnitt der linken und rechten Punkte des Segments.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 nearLeft, Vector3 farLeft, Vector3 nearRight, Vector3 farRight </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Transform towerInstance = Instantiate(wallTower); towerInstance.transform.localPosition = (left + right) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; towerInstance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/559/541/487/559541487b79dd6877b4456dbdf010b1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Turm pro Wandsegment. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben viele T√ºrme entlang der Mauer, aber ihre Ausrichtung √§ndert sich nicht. </font><font style="vertical-align: inherit;">Wir m√ºssen ihre Drehung so √§ndern, dass sie mit der Wand ausgerichtet sind. </font><font style="vertical-align: inherit;">Da wir den rechten und den linken Punkt der Wand haben, wissen wir, welche Richtung richtig ist. </font><font style="vertical-align: inherit;">Mit diesem Wissen k√∂nnen wir die Ausrichtung des Wandsegments und damit des Turms bestimmen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anstatt die Rotation selbst zu berechnen, weisen wir </font></font><code>Transform.right</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der </font><font style="vertical-align: inherit;">Eigenschaft einfach einen </font><font style="vertical-align: inherit;">Vektor zu. </font><font style="vertical-align: inherit;">Der Einheitscode √§ndert die Drehung des Objekts so, dass seine lokale Richtung rechts dem √ºbertragenen Vektor entspricht.</font></font><br><br><pre> <code class="cs hljs"> Transform towerInstance = Instantiate(wallTower); towerInstance.transform.localPosition = (left + right) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; Vector3 rightDirection = right - left; rightDirection.y = <span class="hljs-number"><span class="hljs-number">0f</span></span>; towerInstance.transform.right = rightDirection; towerInstance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d3/2c3/777/5d32c3777d5b63db90ddf9f8fbbf1dee.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die T√ºrme sind mit der Wand ausgerichtet.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie funktioniert die Zuweisung von Transform.right?</font></font></b> <div class="spoiler_text">     <code>Quaternion.FromToRotation</code>   .   . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 right { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rotation * Vector3.right; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { rotation = Quaternion.FromToRotation(Vector3.right, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); } }</code> </pre> </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reduzieren Sie die Anzahl der T√ºrme </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Turm pro Wandsegment ist zu viel. </font><font style="vertical-align: inherit;">Lassen Sie uns das Hinzuf√ºgen des Turms optional machen, indem wir dem </font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Booleschen </font><font style="vertical-align: inherit;">Wert einen </font><font style="vertical-align: inherit;">Parameter </font><font style="vertical-align: inherit;">hinzuf√ºgen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Stellen Sie den Standardwert ein </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In diesem Fall verschwinden alle T√ºrme.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 nearLeft, Vector3 farLeft, Vector3 nearRight, Vector3 farRight, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> addTower = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (addTower) { Transform towerInstance = Instantiate(wallTower); towerInstance.transform.localPosition = (left + right) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; Vector3 rightDirection = right - left; rightDirection.y = <span class="hljs-number"><span class="hljs-number">0f</span></span>; towerInstance.transform.right = rightDirection; towerInstance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Platzieren wir die T√ºrme nur in den Ecken der Zellen. </font><font style="vertical-align: inherit;">Infolgedessen erhalten wir weniger T√ºrme mit ziemlich konstanten Abst√§nden zwischen ihnen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 pivot, HexCell pivotCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ AddWallSegment(pivot, left, pivot, right, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d60/823/d7b/d60823d7b381eccaf5916bf2bc636061.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die T√ºrme sind nur in den Ecken. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es sieht gut aus, aber wir m√ºssen die T√ºrme m√∂glicherweise weniger regelm√§√üig platzieren. </font><font style="vertical-align: inherit;">Wie bei anderen Gel√§ndemerkmalen k√∂nnen wir anhand der Hash-Tabelle entscheiden, ob der Turm in eine Ecke gestellt werden soll. </font><font style="vertical-align: inherit;">Dazu verwenden wir die Mitte der Ecke, um die Tabelle abzutasten, und vergleichen dann einen der Hash-Werte mit dem Schwellenwert der T√ºrme.</font></font><br><br><pre> <code class="cs hljs"> HexHash hash = HexMetrics.SampleHashGrid( (pivot + left + right) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>) ); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasTower = hash.e &lt; HexMetrics.wallTowerThreshold; AddWallSegment(pivot, left, pivot, right, hasTower);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Schwellenwert bezieht sich auf </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mit einem Wert von 0,5 werden T√ºrme in der H√§lfte der F√§lle erstellt, aber wir k√∂nnen W√§nde mit vielen T√ºrmen oder ohne sie erstellen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> wallTowerThreshold = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b54/40c/f0f/b5440cf0ffa4f615f2dcbf37532bbb0a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuf√§llige T√ºrme.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir entfernen die T√ºrme von den H√§ngen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt platzieren wir T√ºrme unabh√§ngig von der Form des Gel√§ndes. </font><font style="vertical-align: inherit;">An den H√§ngen des Turms wirken sie jedoch unlogisch. </font><font style="vertical-align: inherit;">Hier verlaufen die W√§nde schr√§g und k√∂nnen die Turmspitze durchschneiden.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/24c/c5e/2dd/24cc5e2ddb97b83d14e0826bc64e3f20.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T√ºrme an den Pisten. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um Steigungen zu vermeiden, pr√ºfen wir, ob sich die Zellen der rechten und linken Ecke auf derselben H√∂he befinden. </font><font style="vertical-align: inherit;">Nur in diesem Fall ist es m√∂glich, einen Turm zu platzieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasTower = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.Elevation == rightCell.Elevation) { HexHash hash = HexMetrics.SampleHashGrid( (pivot + left + right) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>) ); hasTower = hash.e &lt; HexMetrics.wallTowerThreshold; } AddWallSegment(pivot, left, pivot, right, hasTower);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/770/1b4/fd9/7701b4fd9d0a4952fce2a9e00bbb4571.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt keine T√ºrme mehr an den W√§nden der Pisten.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir stellen die Mauern und T√ºrme auf den Boden </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl wir W√§nde an H√§ngen vermeiden, kann das Relief auf beiden Seiten der Wand immer noch unterschiedliche H√∂hen haben. </font><font style="vertical-align: inherit;">W√§nde k√∂nnen entlang von Leisten verlaufen, und Zellen gleicher H√∂he k√∂nnen unterschiedliche vertikale Positionen haben. </font><font style="vertical-align: inherit;">Aus diesem Grund kann sich die Basis des Turms in der Luft befinden.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd2/4d8/b10/cd24d8b1012804af5d073c3901c874ad.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T√ºrme in der Luft. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tats√§chlich k√∂nnen die W√§nde an den H√§ngen auch in der Luft h√§ngen, aber dies ist nicht so auff√§llig wie bei den T√ºrmen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8b6/ae3/d24/8b6ae3d2489f253ae1a78593af0abd6c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W√§nde sind in der Luft. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies kann behoben werden, indem die Basis der W√§nde und T√ºrme auf den Boden gespannt wird. </font><font style="vertical-align: inherit;">F√ºgen Sie dazu den Y-Versatz f√ºr die W√§nde in hinzu </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Eine Einheit weniger wird ausreichen. </font><font style="vertical-align: inherit;">Erh√∂hen Sie die H√∂he der T√ºrme um den gleichen Betrag.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> wallHeight = <span class="hljs-number"><span class="hljs-number">4f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> wallYOffset = <span class="hljs-number"><span class="hljs-number">-1f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir √§ndern es </font></font><code>HexMetrics.WallLerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so, dass bei der Bestimmung der Y-Koordinate der neue Versatz ber√ºcksichtigt wird.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WallLerp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 near, Vector3 far</span></span></span><span class="hljs-function">)</span></span> { near.x += (far.x - near.x) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; near.z += (far.z - near.z) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> v = near.y &lt; far.y ? wallElevationOffset : (<span class="hljs-number"><span class="hljs-number">1f</span></span> - wallElevationOffset); near.y += (far.y - near.y) * v + wallYOffset; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> near; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir m√ºssen auch das Fertighaus des Turms √§ndern, da die Basis jetzt eine Einheit unter der Erde sein wird. </font><font style="vertical-align: inherit;">Daher erh√∂hen wir die H√∂he des Basisw√ºrfels um eine Einheit und √§ndern dementsprechend die lokale Position der W√ºrfel.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2d/e4e/503/f2de4e50398fbae4ee296737dbe3a922.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecd/5d7/0eb/ecd5d70ebb620e3bae84f17aedb4a2a9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mauern und T√ºrme auf dem Boden. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2>  Br√ºcken </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu diesem Zeitpunkt haben wir Fl√ºsse und Stra√üen, aber Stra√üen k√∂nnen Fl√ºsse in keiner Weise √ºberqueren. </font><font style="vertical-align: inherit;">Es ist der richtige Zeitpunkt, um Br√ºcken hinzuzuf√ºgen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beginnen wir mit einem einfachen skalierten W√ºrfel, der die Rolle einer vorgefertigten Br√ºcke spielt. </font><font style="vertical-align: inherit;">Die Breite der Fl√ºsse variiert, aber es gibt ungef√§hr sieben Abstandseinheiten zwischen den Stra√üenzentren auf beiden Seiten. </font><font style="vertical-align: inherit;">Daher geben wir eine ungef√§hre Skala (3, 1, 7). </font><font style="vertical-align: inherit;">F√ºgen Sie vorgefertigtes rotes st√§dtisches Material hinzu und entfernen Sie den Collider. </font><font style="vertical-align: inherit;">Platzieren Sie den W√ºrfel wie bei T√ºrmen mit derselben Skalierung im Stammobjekt. </font><font style="vertical-align: inherit;">Aus diesem Grund ist die Geometrie der Br√ºcke selbst nicht wichtig. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie einen Link zum Fertighaus der Br√ºcke hinzu </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und weisen Sie ihm ein Fertighaus zu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform wallTower, bridge;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/808/ac6/dc5/808ac6dc523d16d2005da48dcf4d1f65.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zugewiesenes Br√ºckenfertigteil.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Platzierung von Br√ºcken </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Br√ºcke zu platzieren, brauchen wir eine Methode </font></font><code>HexFeatureManager.AddBridge</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die Br√ºcke sollte sich zwischen der Mitte des Flusses und einer der Seiten des Flusses befinden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddBridge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 roadCenter1, Vector3 roadCenter2</span></span></span><span class="hljs-function">)</span></span> { Transform instance = Instantiate(bridge); instance.localPosition = (roadCenter1 + roadCenter2) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir werden unverzerrte Stra√üenzentren √ºbertragen, daher m√ºssen wir sie verzerren, bevor wir die Br√ºcke platzieren. </font></font><br><br><pre> <code class="cs hljs"> roadCenter1 = HexMetrics.Perturb(roadCenter1); roadCenter2 = HexMetrics.Perturb(roadCenter2); Transform instance = Instantiate(bridge);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Br√ºcke richtig auszurichten, k√∂nnen wir den gleichen Ansatz wie beim Drehen der T√ºrme verwenden. </font><font style="vertical-align: inherit;">In diesem Fall definieren die Stra√üenmitten den Vorw√§rtsvektor der Br√ºcke. </font><font style="vertical-align: inherit;">Da wir in derselben Zelle bleiben, ist dieser Vektor definitiv horizontal, sodass wir seine Komponente Y nicht auf Null setzen m√ºssen.</font></font><br><br><pre> <code class="cs hljs"> Transform instance = Instantiate(bridge); instance.localPosition = (roadCenter1 + roadCenter2) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.forward = roadCenter2 - roadCenter1; instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir bauen Br√ºcken √ºber gerade Fl√ºsse </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die einzigen Flusskonfigurationen, die Br√ºcken erfordern, sind gerade und gekr√ºmmt. Stra√üen k√∂nnen durch Endpunkte verlaufen, und im Zickzack k√∂nnen Stra√üen nur in der N√§he sein. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns zun√§chst gerade Fl√ºsse herausfinden. Im Inneren </font><font style="vertical-align: inherit;">ordnet </font><font style="vertical-align: inherit;">der </font></font><code>HexGridChunk.TriangulateRoadAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erste Betreiber </font></font><code>else if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stra√üen in der N√§he solcher Fl√ºsse an. Deshalb werden wir hier Br√ºcken hinzuf√ºgen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir sind auf einer Seite des Flusses. Das Zentrum der Stra√üe bewegt sich vom Fluss weg, und dann verschiebt sich auch das Zentrum der Zelle. Um die Mitte der Stra√üe auf der gegen√ºberliegenden Seite zu finden, m√ºssen wir die entgegengesetzte Richtung um den gleichen Betrag bewegen. Dies muss erfolgen, bevor das Zentrum selbst ge√§ndert wird.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Opposite()) { ‚Ä¶ roadCenter += corner * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; features.AddBridge(roadCenter, center - corner * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); center += corner * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97c/c7f/420/97cc7f42004ba86c6cd0333af352f24b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Br√ºcken √ºber gerade Fl√ºsse. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Br√ºcken sind erschienen! </font><font style="vertical-align: inherit;">Aber jetzt haben wir eine Instanz von Br√ºcken f√ºr jede Richtung, durch die der Fluss nicht flie√üt. </font><font style="vertical-align: inherit;">Wir m√ºssen sicherstellen, dass nur eine Instanz der Br√ºcke in der Zelle generiert wird. </font><font style="vertical-align: inherit;">Dies kann durch Auswahl einer Richtung relativ zum Fluss und auf dessen Grundlage zur Erzeugung einer Br√ºcke erfolgen. </font><font style="vertical-align: inherit;">Sie k√∂nnen eine beliebige Richtung w√§hlen.</font></font><br><br><pre> <code class="cs hljs"> roadCenter += corner * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == direction.Next()) { features.AddBridge(roadCenter, center - corner * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); } center += corner * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au√üerdem m√ºssen wir nur dann eine Br√ºcke hinzuf√ºgen, wenn es auf beiden Seiten des Flusses eine Stra√üe gibt. </font><font style="vertical-align: inherit;">Im Moment sind wir uns bereits sicher, dass es auf der aktuellen Seite eine Stra√üe gibt. </font><font style="vertical-align: inherit;">Daher m√ºssen Sie √ºberpr√ºfen, ob sich auf der anderen Seite des Flusses eine Stra√üe befindet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == direction.Next() &amp;&amp; ( cell.HasRoadThroughEdge(direction.Next2()) || cell.HasRoadThroughEdge(direction.Opposite()) )) { features.AddBridge(roadCenter, center - corner * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/635/a47/978/635a4797816f9f35297f67224a0ec449.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Br√ºcken zwischen den Stra√üen auf beiden Seiten.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Br√ºcken √ºber geschwungene Fl√ºsse </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Br√ºcken √ºber gekr√ºmmte Fl√ºsse funktionieren √§hnlich, aber ihre Topologie unterscheidet sich geringf√ºgig. </font><font style="vertical-align: inherit;">Wir werden eine Br√ºcke hinzuf√ºgen, wenn wir uns au√üerhalb der Kurve befinden. </font><font style="vertical-align: inherit;">Dies geschieht im letzten Block </font></font><code>else</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es verwendet die mittlere Richtung, um die Mitte der Stra√üe zu versetzen. </font><font style="vertical-align: inherit;">Wir m√ºssen diesen Offset zweimal mit verschiedenen Ma√üst√§ben verwenden, also speichern Sie ihn in einer Variablen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { HexDirection middle; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { middle = direction.Next(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextHasRiver) { middle = direction.Previous(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { middle = direction; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !cell.HasRoadThroughEdge(middle) &amp;&amp; !cell.HasRoadThroughEdge(middle.Previous()) &amp;&amp; !cell.HasRoadThroughEdge(middle.Next()) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 offset = HexMetrics.GetSolidEdgeMiddle(middle); roadCenter += offset * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Verschiebungsskala an der Au√üenseite der Kurve betr√§gt 0,25 und an der Innenseite </font></font><code>HexMetrics.innerToOuter * 0.7f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir benutzen es, um die Br√ºcke zu platzieren.</font></font><br><br><pre> <code class="cs hljs"> Vector3 offset = HexMetrics.GetSolidEdgeMiddle(middle); roadCenter += offset * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; features.AddBridge( roadCenter, center - offset * (HexMetrics.innerToOuter * <span class="hljs-number"><span class="hljs-number">0.7f</span></span>) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/612/f9e/da9/612f9eda9f9e4cd31ba20dfe2db7687b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Br√ºcken √ºber geschwungene Fl√ºsse. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auch hier m√ºssen doppelte Br√ºcken vermieden werden. </font><font style="vertical-align: inherit;">Wir k√∂nnen dies tun, indem wir Br√ºcken nur aus der mittleren Richtung hinzuf√ºgen.</font></font><br><br><pre> <code class="cs hljs"> Vector3 offset = HexMetrics.GetSolidEdgeMiddle(middle); roadCenter += offset * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction == middle) { features.AddBridge( roadCenter, center - offset * (HexMetrics.innerToOuter * <span class="hljs-number"><span class="hljs-number">0.7f</span></span>) ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und wieder m√ºssen Sie sicherstellen, dass sich die Stra√üe auf der gegen√ºberliegenden Seite befindet. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( direction == middle &amp;&amp; cell.HasRoadThroughEdge(direction.Opposite()) ) { features.AddBridge( roadCenter, center - offset * (HexMetrics.innerToOuter * <span class="hljs-number"><span class="hljs-number">0.7f</span></span>) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/744/33c/275/74433c2750e413c44d17139982ecff3b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Br√ºcken zwischen den Stra√üen auf beiden Seiten.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Br√ºckenskalierung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir das Gel√§nde verzerren, variiert der Abstand zwischen den Stra√üenmitten und den gegen√ºberliegenden Seiten des Flusses. </font><font style="vertical-align: inherit;">Manchmal sind die Br√ºcken zu kurz, manchmal zu lang.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/770/f2c/e53/770f2ce537ab16628c799eceb6ca4ad7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterschiedliche Abst√§nde bei konstanten Br√ºckenl√§ngen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl wir eine Br√ºcke mit einer L√§nge von sieben Einheiten erstellt haben, k√∂nnen Sie sie so skalieren, dass sie dem tats√§chlichen Abstand zwischen den Stra√üenmitten entspricht. </font><font style="vertical-align: inherit;">Dies bedeutet, dass das Br√ºckenmodell deformiert ist. </font><font style="vertical-align: inherit;">Da die Abst√§nde nicht sehr unterschiedlich sind, kann eine Verformung akzeptabler sein als Br√ºcken, die f√ºr die L√§nge nicht geeignet sind. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um eine ordnungsgem√§√üe Skalierung durchzuf√ºhren, m√ºssen wir die Anfangsl√§nge des Br√ºckenfertigteils kennen. </font><font style="vertical-align: inherit;">Wir werden diese L√§nge in speichern </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bridgeDesignLength = <span class="hljs-number"><span class="hljs-number">7f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir den Ma√üstab entlang der Z-Instanz der Br√ºcke dem Abstand zwischen den Stra√üenmitten, geteilt durch die urspr√ºngliche L√§nge, zuordnen. </font><font style="vertical-align: inherit;">Da die Wurzel des Fertighauses der Br√ºcke den gleichen Ma√üstab hat, wird die Br√ºcke korrekt gedehnt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddBridge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 roadCenter1, Vector3 roadCenter2</span></span></span><span class="hljs-function">)</span></span> { roadCenter1 = HexMetrics.Perturb(roadCenter1); roadCenter2 = HexMetrics.Perturb(roadCenter2); Transform instance = Instantiate(bridge); instance.localPosition = (roadCenter1 + roadCenter2) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.forward = roadCenter2 - roadCenter1; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> length = Vector3.Distance(roadCenter1, roadCenter2); instance.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3( <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, length * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / HexMetrics.bridgeDesignLength) ); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21e/b73/49c/21eb7349c5e7ae6d5480b2e61d19e046.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die wechselnde L√§nge der Br√ºcken. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Br√ºckenbau </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anstelle eines einfachen W√ºrfels k√∂nnen wir ein interessanteres Br√ºckenmodell verwenden. </font><font style="vertical-align: inherit;">Sie k√∂nnen beispielsweise eine grobe Bogenbr√ºcke aus drei skalierten und gedrehten W√ºrfeln erstellen. </font><font style="vertical-align: inherit;">Nat√ºrlich k√∂nnen Sie viel komplexere 3D-Modelle erstellen, einschlie√ülich Teilen der Stra√üe. </font><font style="vertical-align: inherit;">Beachten Sie jedoch, dass das gesamte Objekt leicht komprimiert und gedehnt wird.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eee/83f/3b6/eee83f3b67cf879abe3114117614af08.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a9/741/f7f/8a9741f7f024aa8914e29b12c1ae9d94.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bogenbr√ºcken unterschiedlicher L√§nge. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spezielle Objekte </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher k√∂nnen unsere Zellen st√§dtische, l√§ndliche und pflanzliche Objekte enthalten. Obwohl jede von ihnen drei Ebenen hat, sind alle Objekte im Vergleich zur Gr√∂√üe der Zelle recht klein. Was ist, wenn wir ein gro√ües Geb√§ude wie eine Burg brauchen? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen wir dem Gel√§nde einen speziellen Objekttyp hinzu. Solche Objekte sind so gro√ü, dass sie die gesamte Zelle einnehmen. Jedes dieser Objekte ist einzigartig und ben√∂tigt ein eigenes Fertighaus. Zum Beispiel kann eine einfache Burg aus einem zentralen W√ºrfel plus vier Eckt√ºrmen erstellt werden. Die Skala (6, 4, 6) f√ºr den zentralen W√ºrfel erzeugt eine ausreichend gro√üe Verriegelung, die dennoch auch in eine stark deformierte Zelle passt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e1/9bf/0dc/7e19bf0dc5f1568bf4b21ec467ba9063.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fertighaus der Burg. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein weiteres spezielles Objekt kann beispielsweise eine Zikkurat sein, die aus drei √ºbereinander angeordneten W√ºrfeln besteht. </font><font style="vertical-align: inherit;">F√ºr den unteren W√ºrfel ist die Skala (8, 2,5, 8) geeignet.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ad/7d3/291/1ad7d3291224358562b3472f528973a1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fertige Zikkurat. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spezielle Objekte k√∂nnen beliebig sein, nicht unbedingt architektonisch. </font><font style="vertical-align: inherit;">Beispielsweise kann eine Gruppe von massiven B√§umen mit einer H√∂he von bis zu zehn Einheiten auf eine mit Megaflora gef√ºllte Zelle hinweisen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1bb/e91/907/1bbe91907deba70f6ab9d02cd13de795.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fertige Megaflora. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie dem </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Array hinzu, um diese Fertigh√§user zu verfolgen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform[] special;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> F√ºgen Sie zuerst eine Burg zum Array hinzu, dann Zikkurat und dann Megaflora. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bbc/2e3/e94/bbc2e3e949b25efc800a8f2e799490c7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anpassung von Spezialobjekten.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zellen zu etwas Besonderem machen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist ein Index spezieller Objekte erforderlich, der den Typ eines speziellen Objekts bestimmt, wenn es sich dort befindet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> specialIndex;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Geben wir ihm wie anderen Reliefobjekten die M√∂glichkeit, diesen Wert zu empfangen und einzustellen. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SpecialIndex { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> specialIndex; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (specialIndex != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { specialIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; RefreshSelfOnly(); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standardm√§√üig enth√§lt die Zelle kein spezielles Objekt. </font><font style="vertical-align: inherit;">Wir bezeichnen dies mit dem Index 0. F√ºgen Sie eine Eigenschaft hinzu, die diesen Ansatz verwendet, um festzustellen, ob eine Zelle etwas Besonderes ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsSpecial { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> specialIndex &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie zum Bearbeiten von Zellen Unterst√ºtzung f√ºr den Index spezieller Objekte in hinzu </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es funktioniert √§hnlich wie st√§dtische, l√§ndliche und pflanzliche Einrichtungen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> activeUrbanLevel, activeFarmLevel, activePlantLevel, activeSpecialIndex; ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> applyUrbanLevel, applyFarmLevel, applyPlantLevel, applySpecialIndex; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetApplySpecialIndex</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { applySpecialIndex = toggle; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetSpecialIndex</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span> { activeSpecialIndex = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)index; } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { cell.Color = activeColor; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyElevation) { cell.Elevation = activeElevation; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyWaterLevel) { cell.WaterLevel = activeWaterLevel; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applySpecialIndex) { cell.SpecialIndex = activeSpecialIndex; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyUrbanLevel) { cell.UrbanLevel = activeUrbanLevel; } ‚Ä¶ } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie der Benutzeroberfl√§che einen Schieberegler hinzu, um das spezielle Objekt zu steuern. </font><font style="vertical-align: inherit;">Da wir drei Objekte haben, verwenden wir das Intervall 0‚Äì3 im Schieberegler. </font><font style="vertical-align: inherit;">Null bedeutet das Fehlen eines Objekts, eines - einer Burg, zwei - Zikkurat, drei - Megaflora.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab4/2ea/9bf/ab42ea9bf68565a294f4ded5d2d7ebf0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schieberegler f√ºr spezielle Objekte.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spezielle Objekte hinzuf√ºgen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir den Zellen spezielle Objekte zuweisen. </font><font style="vertical-align: inherit;">Damit sie angezeigt werden, m√ºssen wir eine </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">andere Methode </font><font style="vertical-align: inherit;">hinzuf√ºgen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es wird einfach eine Instanz des gew√ºnschten Spezialobjekts erstellt und an der gew√ºnschten Position platziert. </font><font style="vertical-align: inherit;">Da Null das Fehlen eines Objekts anzeigt, m√ºssen wir die Einheit vom Index der speziellen Objekte der Zelle abziehen, bevor wir Zugriff auf das Array von Fertigh√§usern erhalten.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddSpecialFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Transform instance = Instantiate(special[cell.SpecialIndex - <span class="hljs-number"><span class="hljs-number">1</span></span>]); instance.localPosition = HexMetrics.Perturb(position); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Geben Sie dem Objekt mithilfe der Hash-Tabelle eine beliebige Drehung. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddSpecialFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Transform instance = Instantiate(special[cell.SpecialIndex - <span class="hljs-number"><span class="hljs-number">1</span></span>]); instance.localPosition = HexMetrics.Perturb(position); HexHash hash = HexMetrics.SampleHashGrid(position); instance.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span> * hash.e, <span class="hljs-number"><span class="hljs-number">0f</span></span>); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Triangulieren einer Zelle </font></font><code>HexGridChunk.Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pr√ºfen </font><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">, ob die Zelle ein spezielles Objekt enth√§lt. </font><font style="vertical-align: inherit;">Wenn ja, dann nennen wir unsere neue Methode genau so </font></font><code>AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { Triangulate(d, cell); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !cell.HasRiver &amp;&amp; !cell.HasRoads) { features.AddFeature(cell, cell.Position); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsSpecial) { features.AddSpecialFeature(cell, cell.Position); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b69/242/657/b692426576e292bbdc9ed0752624db51.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spezielle Objekte. </font><font style="vertical-align: inherit;">Sie sind viel gr√∂√üer als gew√∂hnlich.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vermeiden Sie die Fl√ºsse </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Da sich spezielle Objekte in der Mitte der Zellen befinden, verbinden sie sich nicht mit den Fl√ºssen, da sie √ºber ihnen h√§ngen. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a51/92f/cc2/a5192fcc2c5718f33bafc631f60a07a8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objekte auf den Fl√ºssen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um zu verhindern, dass spezielle Objekte auf den Fl√ºssen erstellt werden, √§ndern wir die Eigenschaft </font></font><code>HexCell.SpecialIndex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir werden den Index nur √§ndern, wenn sich keine Fl√ºsse in der Zelle befinden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SpecialIndex { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (specialIndex != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &amp;&amp; !HasRiver) { specialIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; RefreshSelfOnly(); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir einen Fluss hinzuf√ºgen, m√ºssen wir au√üerdem alle speziellen Objekte entfernen. </font><font style="vertical-align: inherit;">Der Fluss sollte sie abwaschen. </font><font style="vertical-align: inherit;">Dies kann erreicht werden, </font></font><code>HexCell.SetOutgoingRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indem der Index spezieller Objekte </font><font style="vertical-align: inherit;">in der Methode </font><font style="vertical-align: inherit;">auf 0 gesetzt </font><font style="vertical-align: inherit;">wird </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetOutgoingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; outgoingRiver = direction; specialIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; neighbor.RemoveIncomingRiver(); neighbor.hasIncomingRiver = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; neighbor.incomingRiver = direction.Opposite(); neighbor.specialIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; SetRoad((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir meiden Stra√üen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Fl√ºsse verlaufen auch Stra√üen schlecht mit speziellen Gegenst√§nden, aber nicht alles ist so schrecklich. </font><font style="vertical-align: inherit;">Sie k√∂nnen die Stra√üen sogar so lassen, wie sie sind. </font><font style="vertical-align: inherit;">Einige Einrichtungen sind m√∂glicherweise mit Stra√üen kompatibel, andere m√∂glicherweise nicht. </font><font style="vertical-align: inherit;">Daher k√∂nnen Sie sie vom Objekt abh√§ngig machen. </font><font style="vertical-align: inherit;">Aber wir werden es einfacher machen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b3b/ebf/939/b3bebf9399ed016e8d79a4c1ee53ace8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objekte auf der Stra√üe. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie in diesem Fall die Spezialobjekte die Stra√üe besiegen. </font><font style="vertical-align: inherit;">Wenn Sie den Index spezieller Objekte √§ndern, werden daher auch alle Stra√üen aus der Zelle entfernt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SpecialIndex { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (specialIndex != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &amp;&amp; !HasRiver) { specialIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; RemoveRoads(); RefreshSelfOnly(); } } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist, wenn wir ein bestimmtes Objekt l√∂schen?</font></font></b> <div class="spoiler_text">      0,   ,       .            . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies bedeutet au√üerdem, dass wir beim Hinzuf√ºgen von Stra√üen zus√§tzliche √úberpr√ºfungen durchf√ºhren m√ºssen. </font><font style="vertical-align: inherit;">Wir werden nur Stra√üen hinzuf√ºgen, wenn keine der Zellen eine Zelle mit einem speziellen Objekt ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] &amp;&amp; !HasRiverThroughEdge(direction) &amp;&amp; !IsSpecial &amp;&amp; !GetNeighbor(direction).IsSpecial &amp;&amp; GetElevationDifference(direction) &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> ) { SetRoad((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vermeiden Sie andere Gegenst√§nde </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spezielle Objekte k√∂nnen nicht mit anderen Objekttypen gemischt werden. </font><font style="vertical-align: inherit;">Wenn sie sich √ºberlappen, sieht es unordentlich aus. </font><font style="vertical-align: inherit;">Es kann auch von einem bestimmten Objekt abh√§ngen, aber wir werden den gleichen Ansatz verwenden.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/03b/7f1/8fc/03b7f18fc9f9d7543bdb0d9c24a074e2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Objekt, das sich mit anderen Objekten schneidet. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Fall unterdr√ºcken wir kleinere Objekte, als w√§ren sie unter Wasser. </font><font style="vertical-align: inherit;">Diesmal werden wir einchecken </font></font><code>HexFeatureManager.AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsSpecial) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vermeiden Sie Wasser </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben auch ein Problem mit Wasser. </font><font style="vertical-align: inherit;">Bleiben die Besonderheiten w√§hrend des Hochwassers bestehen? </font><font style="vertical-align: inherit;">Da wir kleine Objekte in √ºberfluteten Zellen zerst√∂ren, machen wir dasselbe mit speziellen Objekten.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d9/479/e79/8d9479e79cb0555c81f562dc32937552.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gegenst√§nde im Wasser. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In werden </font></font><code>HexGridChunk.Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir den gleichen Hochwassercheck f√ºr spezielle und gew√∂hnliche Objekte durchf√ºhren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { Triangulate(d, cell); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !cell.HasRiver &amp;&amp; !cell.HasRoads) { features.AddFeature(cell, cell.Position); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; cell.IsSpecial) { features.AddSpecialFeature(cell, cell.Position); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da beide Bediener </font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jetzt pr√ºfen, ob sich die Zelle unter Wasser befindet, k√∂nnen wir den Test √ºbertragen und nur einmal durchf√ºhren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { Triangulate(d, cell); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.HasRiver &amp;&amp; !cell.HasRoads) { features.AddFeature(cell, cell.Position); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsSpecial) { features.AddSpecialFeature(cell, cell.Position); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr Experimente wird uns eine solche Anzahl von Objekten ausreichen. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425463/">https://habr.com/ru/post/de425463/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425449/index.html">Aktualisierung des Ansatzes f√ºr kontextbezogene Werbung: Yandex.Direct Turbo Pages</a></li>
<li><a href="../de425453/index.html">Von Space Invaders zu Half Life 2: Die Geschichte von Game Dzdoks</a></li>
<li><a href="../de425457/index.html">Zwanzig R√§tsel (in verr√ºckter, erstaunlicher Geometrie)</a></li>
<li><a href="../de425459/index.html">Ein Upgrade auf Windows 1809 zerst√∂rt (manchmal) alle Dateien in einem Profil</a></li>
<li><a href="../de425461/index.html">Devops and Security: Interviews mit Seth Wargo und Liz Rice</a></li>
<li><a href="../de425465/index.html">Wie ein Designer mehr verdienen kann, ein ideales Werkzeug zum Arbeiten und Suchen nach Ideen</a></li>
<li><a href="../de425467/index.html">Motoren Renault D4F> B4D (auch bekannt als SCe). Generationswechsel. Autofahrer schauen</a></li>
<li><a href="../de425469/index.html">Der Python-Autor leitet die Entwicklung nicht mehr. Wird es die Sprache besser oder schlechter machen?</a></li>
<li><a href="../de425471/index.html">Arbeiten mit Bildern in Python</a></li>
<li><a href="../de425473/index.html">Konferenz √ºber Python und √ºber Kommunikation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>