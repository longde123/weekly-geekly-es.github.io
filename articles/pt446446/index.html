<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöí ‚ôøÔ∏è ü•î No√ß√µes b√°sicas do mecanismo JavaScript: formul√°rios gerais e cache embutido. Parte 1 üåÖ üôèüèæ üë©üèΩ‚Äçü§ù‚Äçüë®üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° amigos. No final de abril, estamos lan√ßando um novo curso "Seguran√ßa de Sistemas de Informa√ß√£o" . E agora queremos compartilhar com voc√™ uma tradu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>No√ß√µes b√°sicas do mecanismo JavaScript: formul√°rios gerais e cache embutido. Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/446446/">  Ol√° amigos.  No final de abril, estamos lan√ßando um novo curso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Seguran√ßa de Sistemas de Informa√ß√£o"</a> .  E agora queremos compartilhar com voc√™ uma tradu√ß√£o do artigo, que certamente ser√° muito √∫til para o curso.  O artigo original pode ser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">encontrado aqui</a> . <br><br>  O artigo descreve os principais fundamentos, eles s√£o comuns a todos os mecanismos JavaScript, e n√£o apenas √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V8</a> , na qual os autores do mecanismo ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Benedict</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Matias</a> ) est√£o trabalhando.  Como desenvolvedor de JavaScript, posso dizer que uma compreens√£o mais profunda de como funciona o mecanismo JavaScript ajudar√° voc√™ a descobrir como escrever c√≥digo eficiente. <br><br><img src="https://habrastorage.org/webt/14/ef/xe/14efxewawb3ttgslcsxyzicgjy0.png"><br><a name="habracut"></a><br><blockquote>  <b>Nota</b> : se voc√™ preferir assistir a apresenta√ß√µes do que ler artigos, assista a este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">v√≠deo</a> .  Caso contr√°rio, pule e continue lendo. </blockquote>  <b>Mecanismo JavaScript de pipeline (pipeline)</b> <br><br>  Tudo come√ßa com o fato de voc√™ escrever o c√≥digo JavaScript.  Depois disso, o mecanismo JavaScript processa o c√≥digo-fonte e o apresenta como uma √°rvore de sintaxe abstrata (AST).  Com base no AST constru√≠do, o int√©rprete pode finalmente come√ßar a trabalhar e come√ßar a gerar bytecode.  √ìtimo!  Este √© o momento em que o mecanismo executa o c√≥digo JavaScript. <br><br><img src="https://habrastorage.org/webt/i6/8r/f2/i68rf23urqlxa20gzhubwz2-snq.jpeg"><br><br>  Para torn√°-lo mais r√°pido, voc√™ pode enviar o bytecode para o compilador de otimiza√ß√£o junto com os dados de cria√ß√£o de perfil.  O compilador de otimiza√ß√£o faz certas suposi√ß√µes com base nos dados de cria√ß√£o de perfil e gera c√≥digo de m√°quina altamente otimizado. <br><br>  Se, em algum momento, as suposi√ß√µes estiverem incorretas, o compilador de otimiza√ß√£o des otimiza o c√≥digo e retorna ao est√°gio do int√©rprete. <br><br>  <b>Interpreter pipelines / compilador em mecanismos JavaScript</b> <br><br>  Agora, vamos examinar mais de perto as partes do pipeline que executam seu c√≥digo JavaScript, ou seja, onde o c√≥digo √© interpretado e otimizado, e tamb√©m algumas diferen√ßas entre os principais mecanismos JavaScript. <br><br>  No centro de tudo, h√° um pipeline que cont√©m um int√©rprete e um compilador de otimiza√ß√£o.  O int√©rprete gera rapidamente c√≥digo de bytes n√£o otimizado, o compilador de otimiza√ß√£o, por sua vez, trabalha por mais tempo, mas a sa√≠da possui c√≥digo de m√°quina altamente otimizado. <br><br><img src="https://habrastorage.org/webt/gh/ap/o6/ghapo68sxzyqniyjqw0v0xewpry.jpeg"><br><br>  A seguir, um pipeline que mostra como a V8 funciona, o mecanismo JavaScript usado pelo Chrome e pelo Node.js. <br><br><img src="https://habrastorage.org/webt/8i/nu/0w/8inu0wkuzc8_enexkp8o7pn7jgi.jpeg"><br><br>  O int√©rprete na V8 √© chamado Ignition, respons√°vel por gerar e executar o bytecode.  Ele coleta dados de cria√ß√£o de perfil que podem ser usados ‚Äã‚Äãpara acelerar a execu√ß√£o na pr√≥xima etapa enquanto o bytecode est√° sendo processado.  Quando uma fun√ß√£o fica <i>quente</i> , por exemplo, se for iniciada com freq√º√™ncia, os dados do bycode e de cria√ß√£o de perfil gerados s√£o transferidos para o TurboFan, ou seja, para o compilador de otimiza√ß√£o para gerar c√≥digo de m√°quina altamente otimizado com base nos dados de cria√ß√£o de perfil. <br><br><img src="https://habrastorage.org/webt/ww/n5/zi/wwn5zi7l8vzzcfaik86qwhdtprc.jpeg"><br><br>  Por exemplo, o mecanismo SpiderMonkey JavaScript da Mozilla, usado no Firefox e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SpiderNode</a> , funciona de maneira um pouco diferente.  N√£o possui um, mas dois compiladores de otimiza√ß√£o.  O int√©rprete √© otimizado em um compilador b√°sico (compilador de linha de base), que produz algum c√≥digo otimizado.  Juntamente com os dados de cria√ß√£o de perfil coletados durante a execu√ß√£o do c√≥digo, o compilador IonMonkey pode gerar c√≥digo altamente otimizado.  Se a otimiza√ß√£o especulativa falhar, o IonMonkey retornar√° ao c√≥digo de linha de base. <br><br><img src="https://habrastorage.org/webt/gu/ek/ps/guekpsu0p1nqwv-pynj7ts8skdo.jpeg"><br><br>  Chakra - o mecanismo JavaScript da Microsoft, usado no Edge e no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Node-ChakraCore</a> , possui uma estrutura muito semelhante e usa dois compiladores de otimiza√ß√£o.  O int√©rprete √© otimizado no SimpleJIT (onde JIT significa "compilador Just-in-Time", que produz c√≥digo um pouco otimizado. Juntamente com os dados de cria√ß√£o de perfil, o FullJIT pode criar um c√≥digo ainda mais altamente otimizado. <br><br><img src="https://habrastorage.org/webt/z-/bl/0v/z-bl0va0qlsrvgandnxrb08q52g.jpeg"><br><br>  JavaScriptCore (abreviado como JSC), o mecanismo JavaScript da Apple usado pelo Safari e React Native, geralmente possui tr√™s compiladores de otimiza√ß√£o diferentes.  O LLInt √© um int√©rprete de baixo n√≠vel otimizado para o compilador base, que por sua vez √© otimizado para o compilador DFG (Data Flow Graph) e j√° est√° otimizado para o compilador FTL (Faster Than Light). <br><br>  Por que alguns mecanismos t√™m mais compiladores otimizadores do que outros?  √â tudo sobre compromissos.  O int√©rprete pode processar o bytecode rapidamente, mas o bytecode sozinho n√£o √© particularmente eficiente.  O compilador otimizador, por outro lado, trabalha um pouco mais, mas produz um c√≥digo de m√°quina mais eficiente.  Esse √© um compromisso entre obter rapidamente o c√≥digo (int√©rprete) ou esperar e executar o c√≥digo com desempenho m√°ximo (otimiza√ß√£o do compilador).  Alguns mecanismos optam por adicionar v√°rios compiladores otimizadores com caracter√≠sticas diferentes de tempo e efici√™ncia, o que permite fornecer o melhor controle sobre essa solu√ß√£o de comprometimento e entender o custo de complica√ß√µes adicionais do dispositivo interno.  Outra desvantagem √© o uso de mem√≥ria; confira este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> para entender melhor. <br><br>  Acabamos de examinar as principais diferen√ßas entre os pipelines do compilador interpretador e otimizador para v√°rios mecanismos JavaScript.  Apesar dessas diferen√ßas de alto n√≠vel, todos os mecanismos JavaScript t√™m a mesma arquitetura: todos eles t√™m um analisador e algum tipo de pipeline de interpretador / compilador. <br><br>  <b>Modelo de objeto JavaScript</b> <br><br>  Vamos ver o que mais os mecanismos JavaScript t√™m em comum e quais truques eles usam para acelerar o acesso √†s propriedades dos objetos JavaScript.  Acontece que todos os principais mecanismos fazem isso de maneira semelhante. <br><br>  A especifica√ß√£o ECMAScript define todos os objetos como dicion√°rios com chaves de sequ√™ncia que correspondem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aos</a> atributos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">propriedade</a> . <br><br><img src="https://habrastorage.org/webt/7s/vv/qq/7svvqqqqfcqi2y-v88nlstidtik.jpeg"><br><br>  Al√©m do pr√≥prio <code>[[Value]]</code> , a especifica√ß√£o define as seguintes propriedades: <br><br><ul><li>  <code>[[Writable]]</code> determina se uma propriedade pode ser reatribu√≠da; </li><li>  <code>[[Enumerable]]</code> determina se a propriedade √© exibida nos loops for-in; </li><li>  <code>[[Configurable]]</code> determina se uma propriedade pode ser exclu√≠da. </li></ul><br>  A nota√ß√£o <code>[[  ]]</code> parece estranha, mas √© assim que a especifica√ß√£o descreve propriedades em JavaScript.  Voc√™ ainda pode obter esses atributos de propriedade para qualquer objeto e propriedade em JavaScript usando a API <code>Object.getOwnPropertyDescriptor</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptor(object, <span class="hljs-string"><span class="hljs-string">'foo'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí { value: 42, writable: true, enumerable: true, configurable: true }</span></span></code> </pre> <br>  Ok, ent√£o o JavaScript define objetos.  E matrizes? <br><br>  Voc√™ pode imaginar matrizes como objetos especiais.  A √∫nica diferen√ßa √© que as matrizes t√™m processamento de √≠ndice especial.  Aqui, um √≠ndice de matriz √© um termo especial na especifica√ß√£o ECMAScript.  O JavaScript tem limites no n√∫mero de elementos em uma matriz - at√© 2¬≥¬≤ - 1.  Um √≠ndice de matriz √© qualquer √≠ndice dispon√≠vel desse intervalo, ou seja, qualquer valor inteiro de 0 a 2¬≥¬≤ - 2. <br><br>  Outra diferen√ßa √© que as matrizes t√™m a propriedade m√°gica de <code>length</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> array = [<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>]; array.length; <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 2 array[2] = 'c'; array.length; // ‚Üí 3</span></span></code> </pre> <br>  Neste exemplo, a matriz tem um comprimento de 2 no momento da cria√ß√£o.  Em seguida, atribu√≠mos outro elemento ao √≠ndice 2 e o comprimento aumenta automaticamente. <br><br>  JavaScript define matrizes, bem como objetos.  Por exemplo, todas as chaves, incluindo √≠ndices de matriz, s√£o representadas explicitamente como seq√º√™ncias de caracteres.  O primeiro elemento da matriz √© armazenado sob a tecla '0'. <br><br><img src="https://habrastorage.org/webt/a0/nr/18/a0nr18etozy9wzmzzsd9zbykxt0.jpeg"><br><br>  A propriedade <code>length</code> √© apenas outra propriedade que acaba sendo n√£o enumer√°vel e n√£o configur√°vel. <br><br>  Assim que um elemento √© adicionado √† matriz, o JavaScript atualiza automaticamente o atributo da propriedade <code>[[Value]]</code> propriedade <code>length</code> . <br><br><img src="https://habrastorage.org/webt/ws/hs/89/wshs896vflemplsrai-wqu5brkw.jpeg"><br><br>  Em geral, podemos dizer que matrizes se comportam de maneira semelhante aos objetos. <br><br>  <b>Otimiza√ß√£o de acesso a propriedades</b> <br><br>  Agora que sabemos como os objetos s√£o definidos em JavaScript, vamos dar uma olhada em como os mecanismos JavaScript permitem que voc√™ trabalhe com objetos com efici√™ncia. <br><br>  Na vida cotidiana, o acesso √†s propriedades √© a opera√ß√£o mais comum.  √â extremamente importante que o mecanismo fa√ßa isso rapidamente. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-string"><span class="hljs-string">'bar'</span></span>, <span class="hljs-attr"><span class="hljs-attr">baz</span></span>: <span class="hljs-string"><span class="hljs-string">'qux'</span></span>, }; <span class="hljs-comment"><span class="hljs-comment">// Here, we're accessing the property `foo` on `object`: doSomething(object.foo); // ^^^^^^^^^^</span></span></code> </pre> <br>  <b>Formul√°rios</b> <br><br>  Nos programas JavaScript, √© pr√°tica comum atribuir as mesmas chaves de propriedade a muitos objetos.  Eles dizem que esses objetos t√™m a mesma <i>forma</i> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object2 = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// `object1` and `object2` have the same shape.</span></span></code> </pre> <br>  Tamb√©m a mec√¢nica comum √© o acesso √† propriedade de objetos da mesma forma: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logX</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">object</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(object.x); <span class="hljs-comment"><span class="hljs-comment">// ^^^^^^^^ } const object1 = { x: 1, y: 2 }; const object2 = { x: 3, y: 4 }; logX(object1); logX(object2);</span></span></code> </pre> <br>  Sabendo disso, os mecanismos JavaScript podem otimizar o acesso √† propriedade de um objeto com base em sua forma.  Veja como funciona. <br><br>  Suponha que tenhamos um objeto com propriedades x e y, ele use a estrutura de dados do dicion√°rio, sobre a qual falamos anteriormente;  cont√©m cadeias de teclas que apontam para seus respectivos atributos. <br><br><img src="https://habrastorage.org/webt/ss/ne/v9/ssnev9md3jko58annrfjraz35ay.jpeg"><br><br>  Se voc√™ acessar uma propriedade, como <code>object.y,</code> o mecanismo JavaScript procurar√° um JSObject com a chave <code>'y'</code> , depois carregar√° os atributos de propriedade que correspondem a essa consulta e finalmente retornar√° <code>[[Value]]</code> . <br><br>  Mas onde esses atributos de propriedade s√£o armazenados na mem√≥ria?  Devemos armazen√°-los como parte de um JSObject?  Se fizermos isso, veremos mais objetos desse formul√°rio posteriormente; nesse caso, √© um desperd√≠cio de espa√ßo armazenar um dicion√°rio completo contendo os nomes de propriedades e atributos no pr√≥prio JSObject, j√° que os nomes de propriedades s√£o repetidos para todos os objetos do mesmo formul√°rio.  Isso causa muita duplica√ß√£o e leva √† m√° aloca√ß√£o de mem√≥ria.  Para otimiza√ß√£o, os mecanismos armazenam a forma do objeto separadamente. <br><br><img src="https://habrastorage.org/webt/mc/yr/mt/mcyrmt9jarqodgtvnwoxzatiwyy.jpeg"><br><br>  Esta <code>Shape</code> cont√©m todos os nomes e atributos de propriedades, exceto <code>[[Value]]</code> .  Em vez disso, o formul√°rio cont√©m os valores de deslocamento dentro do JSObject, para que o mecanismo JavaScript saiba onde procurar os valores.  Cada JSObject com um formul√°rio comum indica uma inst√¢ncia espec√≠fica do formul√°rio.  Agora, cada JSObject deve armazenar apenas valores exclusivos do objeto. <br><br><img src="https://habrastorage.org/webt/-0/-q/t5/-0-qt5an58iyuoeskzaibbtgcno.jpeg"><br><br>  A vantagem se torna √≥bvia assim que temos muitos objetos.  O n√∫mero deles n√£o importa, porque se eles tiverem um formul√°rio, salvaremos as informa√ß√µes sobre o formul√°rio e a propriedade apenas uma vez. <br><br>  Todos os mecanismos JavaScript usam formul√°rios como um meio de otimiza√ß√£o, mas n√£o os nomeiam diretamente como <code>shapes</code> : <br><br><ol><li>  A documenta√ß√£o acad√™mica os chama de classes ocultas (semelhantes √†s classes JavaScript); </li><li>  V8 os chama de Mapas; </li><li>  Chakra os chama de tipos; </li><li>  JavaScriptCore os chama de estruturas; </li><li>  SpiderMonkey os chama de Formas. </li></ol><br>  Neste artigo, continuamos a cham√°-los de <code>shapes</code> . <br><br>  <b>Cadeias de transi√ß√£o e √°rvores</b> <br><br>  O que acontece se voc√™ tiver um objeto de uma determinada forma, mas adicionar uma nova propriedade a ele?  Como o mecanismo JavaScript define um novo formul√°rio? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = {}; object.x = <span class="hljs-number"><span class="hljs-number">5</span></span>; object.y = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br>  Os formul√°rios criam o que √© chamado de cadeias de transi√ß√£o no mecanismo JavaScript.  Aqui est√° um exemplo: <br><br><img src="https://habrastorage.org/webt/tm/tz/np/tmtznpiuyzkz9vpxqe6byhw2x-k.jpeg"><br><br>  Um objeto inicialmente n√£o possui propriedades; corresponde a um formul√°rio vazio.  A express√£o a seguir adiciona a propriedade <code>'x'</code> com o valor 5 a esse objeto e, em seguida, o mecanismo segue para o formul√°rio que cont√©m a propriedade <code>'x'</code> e o valor 5 √© adicionado ao JSObject no primeiro deslocamento 0. A pr√≥xima linha adiciona a propriedade <code>'y'</code> e o mecanismo passa √† pr√≥xima um formul√°rio que j√° cont√©m <code>'x'</code> e <code>'y'</code> e tamb√©m adiciona o valor 6 ao JSObject no deslocamento 1. <br><blockquote>  <b>Nota</b> : A sequ√™ncia na qual as propriedades s√£o adicionadas afeta o formul√°rio.  Por exemplo, {x: 4, y: 5} resultar√° em uma forma diferente de {y: 5, x: 4}. <br></blockquote>  Nem precisamos armazenar a tabela de propriedades inteira para cada formul√°rio.  Em vez disso, cada formul√°rio precisa conhecer apenas uma nova propriedade que eles est√£o tentando incluir nele.  Por exemplo, neste caso, n√£o precisamos armazenar informa√ß√µes sobre 'x' na √∫ltima forma, pois elas podem ser encontradas anteriormente na cadeia.  Para que isso funcione, o formul√°rio √© mesclado com o formul√°rio anterior. <br><br><img src="https://habrastorage.org/webt/ks/ou/pv/ksoupve8bep3jsp0v7u2ahyv9jg.jpeg"><br><br>  Se voc√™ escrever <code>ox</code> no seu c√≥digo JavaScript, o JavaScript procurar√° a propriedade <code>'x'</code> ao longo da cadeia de transi√ß√£o at√© detectar um formul√°rio que j√° tenha a propriedade <code>'x'</code> . <br><br>  Mas o que acontece se for imposs√≠vel criar uma cadeia de transi√ß√£o?  Por exemplo, o que acontece se voc√™ tiver dois objetos vazios e adicionar propriedades diferentes a eles? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = {}; object1.x = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object2 = {}; object2.y = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br>  Nesse caso, um ramo aparece e, em vez da cadeia de transi√ß√£o, obtemos uma √°rvore de transi√ß√£o: <br><br><img src="https://habrastorage.org/webt/bc/ga/ax/bcgaaxeskfqwqt8geu_pxmqwdou.jpeg"><br><br>  Criamos um objeto vazio <code>a</code> e adicionamos a propriedade <code>'x'</code> .  Como resultado, temos um <code>JSObject</code> contendo um √∫nico valor e dois formul√°rios: vazio e um formul√°rio com uma √∫nica propriedade <code>'x'</code> . <br><br>  O segundo exemplo come√ßa com o fato de termos um objeto vazio <code>b</code> , mas adicionamos outra propriedade <code>'y'</code> .  Como resultado, aqui temos duas cadeias de formas, mas no final temos tr√™s cadeias. <br><br>  Isso significa que sempre come√ßamos com um formul√°rio vazio?  N√£o necessariamente.  Os mecanismos usam alguma otimiza√ß√£o de literais de objetos, que j√° cont√™m propriedades.  Digamos que adicionamos x, come√ßando com um literal de objeto vazio ou temos um literal de objeto que j√° cont√©m <code>x</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = {}; object1.x = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object2 = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span> };</code> </pre> <br>  No primeiro exemplo, come√ßamos com um formul√°rio vazio e vamos para uma cadeia que tamb√©m cont√©m <code>x</code> , como vimos anteriormente. <br><br>  No caso do <code>object2</code> faz sentido criar diretamente objetos que j√° possuem x desde o in√≠cio, em vez de come√ßar com um objeto vazio e uma transi√ß√£o. <br><br><img src="https://habrastorage.org/webt/qv/_0/l-/qv_0l-f5eekqflfmto7lfd-awwq.jpeg"><br><br>  O literal de um objeto que cont√©m a propriedade <code>'x'</code> come√ßa com um formul√°rio que cont√©m <code>'x'</code> desde o in√≠cio e o formul√°rio vazio √© efetivamente ignorado.  Isto √© (pelo menos) o que V8 e SpiderMonkey fazem.  A otimiza√ß√£o reduz a cadeia de transi√ß√£o e facilita a montagem de objetos a partir de literais. <br><br>  A publica√ß√£o no blog de Benedict sobre o incr√≠vel polimorfismo de aplicativos no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">React</a> fala sobre como essas sutilezas podem afetar o desempenho. <br><br>  Al√©m disso, voc√™ ver√° um exemplo de pontos de um objeto tridimensional com as propriedades <code>'x'</code> , <code>'y'</code> , <code>'z'</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> point = {}; point.x = <span class="hljs-number"><span class="hljs-number">4</span></span>; point.y = <span class="hljs-number"><span class="hljs-number">5</span></span>; point.z = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br>  Como voc√™ entendeu anteriormente, criamos um objeto com tr√™s formas na mem√≥ria (sem contar a forma vazia).  Para acessar a propriedade <code>'x'</code> desse objeto, por exemplo, se voc√™ escrever <code>point.x</code> em seu programa, o mecanismo JavaScript dever√° seguir uma lista vinculada: iniciando no formul√°rio na parte inferior e, em seguida, movendo-se gradualmente para o formul√°rio que possui <code>'x'</code> no topo. <br><br><img src="https://habrastorage.org/webt/tv/rn/mp/tvrnmp1s5p25dseplockgifr6x0.jpeg"><br><br>  Acontece muito lentamente, especialmente se voc√™ faz isso com frequ√™ncia e com muitas propriedades do objeto.  O tempo de perman√™ncia de uma propriedade √© <code>O(n)</code> , ou seja, √© uma fun√ß√£o linear que se correlaciona com o n√∫mero de propriedades do objeto.  Para acelerar as pesquisas de propriedades, os mecanismos JavaScript adicionam uma estrutura de dados ShapeTable.  ShapeTable √© um dicion√°rio onde as chaves s√£o mapeadas de uma certa maneira com os formul√°rios e produzem a propriedade desejada. <br><br><img src="https://habrastorage.org/webt/y8/vh/40/y8vh40rwdlx99jdv-rpumbe1u3u.jpeg"><br><br>  Espere um segundo, agora voltamos √† busca no dicion√°rio ... Foi exatamente assim que come√ßamos quando colocamos formul√°rios em primeiro lugar!  Ent√£o, por que nos preocupamos com formul√°rios? <br>  O fato √© que os formul√°rios contribuem para outra otimiza√ß√£o chamada <i>caches em linha.</i> <br><br>  Falaremos sobre o conceito de caches em linha ou ICs na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">segunda parte do</a> artigo, mas agora queremos convid√°-lo para um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">semin√°rio on-line gratuito</a> , que ser√° realizado pelo famoso analista viral e professor de meio per√≠odo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Alexander Kolesnikov</a> , em 9 de abril. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt446446/">https://habr.com/ru/post/pt446446/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt446434/index.html">Escala do Zimbra Collaboration Suite</a></li>
<li><a href="../pt446436/index.html">Como gerar hip√≥teses sobre as necessidades de potenciais consumidores do seu futuro produto</a></li>
<li><a href="../pt446438/index.html">Nossa experi√™ncia de cria√ß√£o de API de gateway</a></li>
<li><a href="../pt446440/index.html">O livro Reage R√°pido. Aplica√ß√µes Web em React, JSX, Redux e GraphQL ¬ª</a></li>
<li><a href="../pt446444/index.html">Do Skype ao WebRTC: Como organizamos a comunica√ß√£o por v√≠deo na Web</a></li>
<li><a href="../pt446448/index.html">5 regras b√°sicas para a realiza√ß√£o de entrevistas com problemas para identificar as necessidades do consumidor</a></li>
<li><a href="../pt446452/index.html">Miss√£o lunar ‚ÄúBereshit‚Äù - em 4 de abril de 2019, a transi√ß√£o para a √≥rbita lunar est√° conclu√≠da, 7 dias de voo, 6 manobras e 1 pouso</a></li>
<li><a href="../pt446454/index.html">Desenvolvimento de servidor Web Golang - do f√°cil ao complexo</a></li>
<li><a href="../pt446456/index.html">Substitui√ß√£o de importa√ß√£o na pr√°tica. Parte 1. Op√ß√µes</a></li>
<li><a href="../pt446458/index.html">DRO universal baseado no Arduino Nano - shDRO. Parte 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>