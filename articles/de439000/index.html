<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÖüèø üßúüèæ üë©üèø‚Äçü§ù‚Äçüë®üèª 2D-Raummanipulation mit vorzeichenbehafteten Entfernungsfeldern üë∏üèº üå∫ üë©‚Äçüç≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Sie mit Polygon-Assets arbeiten, k√∂nnen Sie jeweils nur ein Objekt zeichnen (wenn Sie Techniken wie Stapeln und Instanziieren nicht ber√ºcksichtig...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>2D-Raummanipulation mit vorzeichenbehafteten Entfernungsfeldern</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439000/"> Wenn Sie mit Polygon-Assets arbeiten, k√∂nnen Sie jeweils nur ein Objekt zeichnen (wenn Sie Techniken wie Stapeln und Instanziieren nicht ber√ºcksichtigen). Wenn Sie jedoch Entfernungsfelder mit einem Vorzeichen (signierte Entfernungsfelder, SDF) verwenden, sind wir nicht darauf beschr√§nkt.  Wenn zwei Positionen dieselbe Koordinate haben, geben die vorzeichenbehafteten Abstandsfunktionen denselben Wert zur√ºck, und in einer Berechnung k√∂nnen wir mehrere Zahlen erhalten.  Um zu verstehen, wie der zum Generieren von vorzeichenbehafteten Abstandsfeldern verwendete Raum transformiert wird, empfehlen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wir Ihnen, herauszufinden</a> , wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie mithilfe der vorzeichenbehafteten Abstandsfunktionen Formen erstellen</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SDF-Formen kombinieren</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b13/a59/cc9/b13a59cc9538d7f55cc41cba474575d7.gif"></div><a name="habracut"></a><br><h2>  Konfiguration </h2><br>  In diesem Tutorial √§ndere ich die Paarung zwischen dem Quadrat und dem Kreis, aber Sie k√∂nnen sie f√ºr jede andere Form verwenden.  Dies √§hnelt der Konfiguration f√ºr das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherige Lernprogramm</a> . <br><br>  Hierbei ist es wichtig, dass der modifizierbare Teil vor der Verwendung von Positionen zum Generieren von Zahlen liegt. <br><br><pre><code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Tutorial/036_SDF_Space_Manpulation/Type"</span></span>{ Properties{ _InsideColor(<span class="hljs-string"><span class="hljs-string">"Inside Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _OutsideColor(<span class="hljs-string"><span class="hljs-string">"Outside Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _LineDistance(<span class="hljs-string"><span class="hljs-string">"Mayor Line Distance"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) = <span class="hljs-number"><span class="hljs-number">1</span></span> _LineThickness(<span class="hljs-string"><span class="hljs-string">"Mayor Line Thickness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.05</span></span> [IntRange]_SubLines(<span class="hljs-string"><span class="hljs-string">"Lines between major lines"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)) = <span class="hljs-number"><span class="hljs-number">4</span></span> _SubLineThickness(<span class="hljs-string"><span class="hljs-string">"Thickness of inbetween lines"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.05</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.01</span></span> } SubShader{ <span class="hljs-comment"><span class="hljs-comment">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry Tags{ "RenderType"="Opaque" "Queue"="Geometry"} Pass{ CGPROGRAM #include "UnityCG.cginc" #include "2D_SDF.cginc" #pragma vertex vert #pragma fragment frag struct appdata{ float4 vertex : POSITION; }; struct v2f{ float4 position : SV_POSITION; float4 worldPos : TEXCOORD0; }; v2f vert(appdata v){ v2f o; //calculate the position in clip space to render the object o.position = UnityObjectToClipPos(v.vertex); //calculate world position of vertex o.worldPos = mul(unity_ObjectToWorld, v.vertex); return o; } float scene(float2 position) { // manipulate position with cool methods here! float2 squarePosition = position; squarePosition = translate(squarePosition, float2(2, 2)); squarePosition = rotate(squarePosition, .125); float squareShape = rectangle(squarePosition, float2(1, 1)); float2 circlePosition = position; circlePosition = translate(circlePosition, float2(1, 1.5)); float circleShape = circle(circlePosition, 1); float combination = merge(circleShape, squareShape); return combination; } float4 _InsideColor; float4 _OutsideColor; float _LineDistance; float _LineThickness; float _SubLines; float _SubLineThickness; fixed4 frag(v2f i) : SV_TARGET{ float dist = scene(i.worldPos.xz); fixed4 col = lerp(_InsideColor, _OutsideColor, step(0, dist)); float distanceChange = fwidth(dist) * 0.5; float majorLineDistance = abs(frac(dist / _LineDistance + 0.5) - 0.5) * _LineDistance; float majorLines = smoothstep(_LineThickness - distanceChange, _LineThickness + distanceChange, majorLineDistance); float distanceBetweenSubLines = _LineDistance / _SubLines; float subLineDistance = abs(frac(dist / distanceBetweenSubLines + 0.5) - 0.5) * distanceBetweenSubLines; float subLines = smoothstep(_SubLineThickness - distanceChange, _SubLineThickness + distanceChange, subLineDistance); return col * majorLines * subLines; } ENDCG } } FallBack "Standard" }</span></span></code> </pre> <br>  Und die Funktion 2D_SDF.cginc, die sich im selben Ordner wie der Shader befindet, den wir erweitern werden, sieht zun√§chst so aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> SDF_2D #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SDF_2D </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//transforms float2 rotate(float2 samplePosition, float rotation){ const float PI = 3.14159; float angle = rotation * PI * 2 * -1; float sine, cosine; sincos(angle, sine, cosine); return float2(cosine * samplePosition.x + sine * samplePosition.y, cosine * samplePosition.y - sine * samplePosition.x); } float2 translate(float2 samplePosition, float2 offset){ //move samplepoint in the opposite direction that we want to move shapes in return samplePosition - offset; } float2 scale(float2 samplePosition, float scale){ return samplePosition / scale; } //combinations ///basic float merge(float shape1, float shape2){ return min(shape1, shape2); } float intersect(float shape1, float shape2){ return max(shape1, shape2); } float subtract(float base, float subtraction){ return intersect(base, -subtraction); } float interpolate(float shape1, float shape2, float amount){ return lerp(shape1, shape2, amount); } /// round float round_merge(float shape1, float shape2, float radius){ float2 intersectionSpace = float2(shape1 - radius, shape2 - radius); intersectionSpace = min(intersectionSpace, 0); float insideDistance = -length(intersectionSpace); float simpleUnion = merge(shape1, shape2); float outsideDistance = max(simpleUnion, radius); return insideDistance + outsideDistance; } float round_intersect(float shape1, float shape2, float radius){ float2 intersectionSpace = float2(shape1 + radius, shape2 + radius); intersectionSpace = max(intersectionSpace, 0); float outsideDistance = length(intersectionSpace); float simpleIntersection = intersect(shape1, shape2); float insideDistance = min(simpleIntersection, -radius); return outsideDistance + insideDistance; } float round_subtract(float base, float subtraction, float radius){ return round_intersect(base, -subtraction, radius); } ///champfer float champfer_merge(float shape1, float shape2, float champferSize){ const float SQRT_05 = 0.70710678118; float simpleMerge = merge(shape1, shape2); float champfer = (shape1 + shape2) * SQRT_05; champfer = champfer - champferSize; return merge(simpleMerge, champfer); } float champfer_intersect(float shape1, float shape2, float champferSize){ const float SQRT_05 = 0.70710678118; float simpleIntersect = intersect(shape1, shape2); float champfer = (shape1 + shape2) * SQRT_05; champfer = champfer + champferSize; return intersect(simpleIntersect, champfer); } float champfer_subtract(float base, float subtraction, float champferSize){ return champfer_intersect(base, -subtraction, champferSize); } /// round border intersection float round_border(float shape1, float shape2, float radius){ float2 position = float2(shape1, shape2); float distanceFromBorderIntersection = length(position); return distanceFromBorderIntersection - radius; } float groove_border(float base, float groove, float width, float depth){ float circleBorder = abs(groove) - width; float grooveShape = subtract(circleBorder, base + depth); return subtract(base, grooveShape); } //shapes float circle(float2 samplePosition, float radius){ //get distance from center and grow it according to radius return length(samplePosition) - radius; } float rectangle(float2 samplePosition, float2 halfSize){ float2 componentWiseEdgeDistance = abs(samplePosition) - halfSize; float outsideDistance = length(max(componentWiseEdgeDistance, 0)); float insideDistance = min(max(componentWiseEdgeDistance.x, componentWiseEdgeDistance.y), 0); return outsideDistance + insideDistance; } #endif</span></span></span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e60/788/36d/e6078836d9a222c4df1578609bdfaced.png"></div><br><h2>  Wiederholung des Raumes </h2><br><h3>  Spiegelreflexion </h3><br>  Eine der einfachsten Operationen ist das Spiegeln der Welt um eine Achse.  Um es um die y-Achse zu spiegeln, nehmen wir den absoluten Wert der x-Komponente unserer Position.  Somit sind die Koordinaten rechts und links von der Achse gleich.  <code>(-1, 1)</code> wird zu <code>(1, 1)</code> und befindet sich innerhalb eines Kreises, wobei <code>(1, 1)</code> als Koordinatenursprung und mit einem Radius gr√∂√üer als 0 verwendet wird. <br><br>  Meistens sieht der Code, der diese Funktion verwendet, ungef√§hr so ‚Äã‚Äãaus wie <code>position = mirror(position);</code>  so k√∂nnen wir es ein bisschen vereinfachen.  Wir werden das Positionsargument einfach als inout deklarieren.  Wenn Sie also in das Argument schreiben, √§ndert sich auch die Variable, die wir an die Funktion √ºbergeben.  Der R√ºckgabewert kann dann vom Typ void sein, da wir den R√ºckgabewert immer noch nicht verwenden. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in 2D_SDF.cginc void mirror(inout float2 position){ position.x = abs(position.x); }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in shader function mirror(position);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/62f/6b0/40e/62f6b040e1e648e7d6411ecf634571f4.png"></div><br>  Es ist schon ziemlich gut gelaufen, aber auf diese Weise erhalten wir nur eine Achse zum Spiegeln.  Wir k√∂nnen die Funktion erweitern, indem wir den Raum drehen, wie wir es beim Drehen der Figuren getan haben.  Zuerst m√ºssen Sie den Raum drehen, dann spiegeln und dann zur√ºckdrehen.  Auf diese Weise k√∂nnen wir eine Spiegelung in Bezug auf jeden Winkel durchf√ºhren.  Das Gleiche ist m√∂glich, wenn Speicherplatz √ºbertragen und nach dem Spiegeln eine umgekehrte √úbertragung durchgef√ºhrt wird.  (Wenn Sie beide Operationen ausf√ºhren, vergessen Sie vor dem Spiegeln nicht, zuerst die √úbertragung durchzuf√ºhren und dann zu drehen. Danach geht die Runde zuerst.) <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in shader function float rotation = _Time.y * 0.25; position = rotate(position, rotation); mirror(position); position = rotate(position, -rotation);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/23a/afd/284/23aafd284c90054af5e7d8b453aac212.gif"></div><br><h2>  Zellen </h2><br>  Wenn Sie wissen, wie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rauschgenerierung</a> funktioniert, dann verstehen Sie, dass wir bei der prozeduralen Generierung h√§ufig die Position wiederholen und kleine Zellen erhalten, die im Wesentlichen gleich sind und sich nur in unbedeutenden Parametern unterscheiden.  Dasselbe k√∂nnen wir f√ºr Entfernungsfelder tun. <br><br>  Da die <code>fmod</code> Funktion (und die Verwendung von% zum Teilen mit dem Rest) den Rest und nicht die Definition des Rests ergibt, m√ºssen wir einen Trick verwenden.  Zun√§chst nehmen wir den Rest der Ganzzahldivision durch die Funktion fmod.  F√ºr positive Zahlen ist dies genau das, was wir brauchen, und f√ºr negative Zahlen ist dies das Ergebnis, das wir abz√ºglich der Periode ben√∂tigen.  Sie k√∂nnen dies beheben, indem Sie einen Punkt hinzuf√ºgen und den Rest der Division erneut √ºbernehmen.  Das Hinzuf√ºgen einer Periode ergibt das gew√ºnschte Ergebnis f√ºr negative Eingabewerte, und f√ºr positive Eingabewerte ist der Wert eine Periode h√∂her.  Der zweite Rest der Division wird mit den Werten f√ºr negative Eingabewerte nichts anfangen, da sie bereits im Bereich von 0 bis zur Periode liegen und f√ºr positive Eingabewerte im Wesentlichen eine Periode subtrahiert wird. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in 2D_SDF.cginc void cells(inout float2 position, float2 period){ position = fmod(position, period); //negative positions lead to negative modulo position += period; //negative positions now have correct cell coordinates, positive input positions too high position = fmod(position, period); //second mod doesn't change values between 0 and period, but brings down values that are above period. }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in shader function cells(position, float2(3, 3));</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b9/3f0/b53/4b93f0b53e221b11780ed0c627ebe5c8.png"></div><br>  Das Problem mit den Zellen ist, dass wir die Kontinuit√§t verlieren, f√ºr die wir Distanzfelder lieben.  Dies ist nicht schlecht, wenn sich die Formen nur in der Mitte der Zellen befinden. In dem oben gezeigten Beispiel kann dies jedoch zu erheblichen Artefakten f√ºhren, die vermieden werden sollten, wenn Distanzfelder f√ºr eine Vielzahl von Aufgaben verwendet werden, bei denen Distanzfelder normalerweise angewendet werden k√∂nnen. <br><br>  Es gibt eine L√∂sung, die nicht in jedem Fall funktioniert, aber wenn sie funktioniert, ist es wunderbar: jede andere Zelle zu spiegeln.  Daf√ºr ben√∂tigen wir einen Pixelzellenindex, aber wir haben immer noch keinen R√ºckgabewert in der Funktion, sodass wir ihn einfach verwenden k√∂nnen, um den Zellenindex zur√ºckzugeben. <br><br>  Um den Zellenindex zu berechnen, teilen wir die Position durch die Periode.  Somit ist 0-1 die erste Zelle, 1-2 die zweite und so weiter ... und wir k√∂nnen sie leicht diskretisieren.  Um den Index der Zelle zu erhalten, runden wir den Wert einfach ab und geben das Ergebnis zur√ºck.  Wichtig ist, dass wir den Index der Zelle berechnen, bevor wir uns mit dem Rest teilen, um die Zellen zu wiederholen.  Andernfalls w√ºrden wir √ºberall den Index 0 erhalten, da die Position den Zeitraum nicht √ºberschreiten kann. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in 2D_SDF.cginc float2 cells(inout float2 position, float2 period){ position = fmod(position, period); //negative positions lead to negative modulo position += period; //negative positions now have correct cell coordinates, positive input positions too high position = fmod(position, period); //second mod doesn't change values between 0 and period, but brings down values that are above period. float2 cellIndex = position / period; cellIndex = floor(cellIndex); return cellIndex; }</span></span></code> </pre> <br>  Mit diesen Informationen k√∂nnen wir Zellen umdrehen.  Um zu verstehen, ob umgedreht werden soll oder nicht, teilen wir den Zellenindex Modulo 2. Das Ergebnis dieser Operation ist abwechselnd 0 und 1 oder -1 pro zweite Zelle.  Um die √Ñnderung dauerhafter zu machen, nehmen wir den absoluten Wert und erhalten einen Wert, der zwischen 0 und 1 wechselt. <br><br>  Um diesen Wert zum Umschalten zwischen einer normalen und einer umgedrehten Position zu verwenden, ben√∂tigen wir eine Funktion, die nichts f√ºr den Wert 0 tut und die Position von der Periode subtrahiert, in der das Umdrehen 1 ist. Das hei√üt, wir f√ºhren eine lineare Interpolation von der normalen zur umgedrehten Position unter Verwendung der Umkehrvariablen durch .  Da die Flip-Variable ein 2d-Vektor ist, werden ihre Komponenten einzeln gespiegelt. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in shader function float2 period = 3; float2 cell = cells(position, period); float2 flip = abs(fmod(cell, 2)); position = lerp(position, period - position, flip);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45a/c36/5a1/45ac365a1cb18e89306a5ac1f0d01b57.png"></div><br><h2>  Radialzellen </h2><br>  Ein weiteres gro√üartiges Merkmal ist die Wiederholung des Raums in einem radialen Muster. <br><br>  Um diesen Effekt zu erzielen, berechnen wir zun√§chst die radiale Position.  Dazu codieren wir den Winkel relativ zum Mittelpunkt der x-Achse und den Abstand vom Mittelpunkt entlang der y-Achse. <br><br><pre> <code class="cpp hljs">float2 radialPosition = float2(<span class="hljs-built_in"><span class="hljs-built_in">atan2</span></span>(position.x, position.y), length(position));</code> </pre> <br>  Dann wiederholen wir die Ecke.  Da die √úbertragung der Anzahl der Wiederholungen viel einfacher ist als der Winkel jedes St√ºcks, berechnen wir zun√§chst die Gr√∂√üe jedes St√ºcks.  Der gesamte Kreis ist 2 * pi. Um den richtigen Teil zu erhalten, teilen wir 2 * pi durch die Zellengr√∂√üe. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> PI = <span class="hljs-number"><span class="hljs-number">3.14159</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cellSize = PI * <span class="hljs-number"><span class="hljs-number">2</span></span> / cells;</code> </pre> <br>  Mit diesen Informationen k√∂nnen wir die x-Komponente der radialen Position jeder cellSize-Einheit wiederholen.  Wir f√ºhren Wiederholungen durch Division mit dem Rest durch, daher erhalten wir nach wie vor Probleme mit negativen Zahlen, die mit Hilfe von zwei Funktionen der Division mit dem Rest beseitigt werden k√∂nnen. <br><br><pre> <code class="cpp hljs">radialPosition.x = <span class="hljs-built_in"><span class="hljs-built_in">fmod</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">fmod</span></span>(radialPosition.x, cellSize) + cellSize, cellSize);</code> </pre> <br>  Dann m√ºssen Sie die neue Position wieder auf die √ºblichen xy-Koordinaten verschieben.  Hier verwenden wir die Sincos-Funktion mit der x-Komponente der radialen Position als Winkel, um den Sinus in die x-Koordinate der Position und den Cosinus in die y-Koordinate zu schreiben.  Mit diesem Schritt erhalten wir eine normalisierte Position.  Um die richtige Richtung von der Mitte zu erhalten, m√ºssen Sie sie mit der Komponente y der radialen Position multiplizieren, dh der L√§nge. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in 2D_SDF.cginc void radial_cells(inout float2 position, float cells){ const float PI = 3.14159; float cellSize = PI * 2 / cells; float2 radialPosition = float2(atan2(position.x, position.y), length(position)); radialPosition.x = fmod(fmod(radialPosition.x, cellSize) + cellSize, cellSize); sincos(radialPosition.x, position.x, position.y); position = position * radialPosition.y; }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in shader function float2 period = 6; radial_cells(position, period, false);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1db/a77/c42/1dba77c426e68d224172d2587b0a3a6f.png"></div><br>  Dann k√∂nnen wir auch den Zellindex und die Spiegelung hinzuf√ºgen, wie wir es bei normalen Zellen getan haben. <br><br>  Es ist notwendig, den Zellenindex nach der Berechnung der radialen Position zu berechnen, aber bevor der Rest von der Teilung erhalten wird.  Wir erhalten es, indem wir die x-Komponente der radialen Position teilen und das Ergebnis abrunden.  In diesem Fall kann der Index auch negativ sein, und dies ist ein Problem, wenn die Anzahl der Zellen ungerade ist.  Zum Beispiel erhalten wir mit 3 Zellen 1 Zelle mit einem Index von 0, 1 Zelle mit einem Index von -1 und 2 Halbzellen mit den Indizes 1 und -2.  Um dieses Problem zu umgehen, addieren wir die Anzahl der Zellen zu der Variablen, die die Variable abgerundet hat, und dividieren sie durch die Gr√∂√üe der Zelle mit dem Rest. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in 2D_SDF.cginc float cellIndex = fmod(floor(radialPosition.x / cellSize) + cells, cells); //at the end of the function: return cellIndex;</span></span></code> </pre> <br>  Um dies widerzuspiegeln, m√ºssen die Koordinaten im Bogenma√ü angegeben werden. Um eine Neuberechnung der Radialkoordinaten au√üerhalb der Funktion zu vermeiden, f√ºgen wir ihr eine Option mit dem Argument bool hinzu.  Normalerweise ist in Shadern eine Verzweigung (wenn Konstrukte) nicht erw√ºnscht, aber in diesem Fall gehen alle Pixel auf dem Bildschirm denselben Pfad, sodass dies normal ist. <br><br>  Die Spiegelung sollte erfolgen, nachdem die Radialkoordinate geloopt wurde, aber bevor sie wieder in ihre normale Position konvertiert wurde.  Wir finden heraus, ob wir die aktuelle Zelle umdrehen m√ºssen, indem wir den Zellenindex durch 2 mit dem Rest teilen. Normalerweise sollte dies Nullen und Einsen ergeben, aber in meinem Fall erscheinen mehrere Zweien, was seltsam ist, und dennoch k√∂nnen wir damit umgehen.  Um Zweien zu eliminieren, subtrahieren wir einfach 1 von der Flip-Variablen und nehmen dann den absoluten Wert.  Somit werden Nullen und Zweien zu Einsen, und Einheiten werden nach Bedarf zu Nullen, und zwar nur in umgekehrter Reihenfolge. <br><br>  Da Nullen und Einsen in der falschen Reihenfolge sind, f√ºhren wir eine lineare Interpolation von der verkehrten Version zur verkehrten Version durch und nicht wie zuvor umgekehrt.  Um die Koordinate umzudrehen, subtrahieren wir einfach die Position von der Zellengr√∂√üe. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in 2D_SDF.cginc float radial_cells(inout float2 position, float cells, bool mirrorEverySecondCell = false){ const float PI = 3.14159; float cellSize = PI * 2 / cells; float2 radialPosition = float2(atan2(position.x, position.y), length(position)); float cellIndex = fmod(floor(radialPosition.x / cellSize) + cells, cells); radialPosition.x = fmod(fmod(radialPosition.x, cellSize) + cellSize, cellSize); if(mirrorEverySecondCell){ float flip = fmod(cellIndex, 2); flip = abs(flip-1); radialPosition.x = lerp(cellSize - radialPosition.x, radialPosition.x, flip); } sincos(radialPosition.x, position.x, position.y); position = position * radialPosition.y; return cellIndex; }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in shader function float2 period = 6; radial_cells(position, period, true);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b0/3ea/d5e/1b03ead5e0a63236e909d31a5025d8c7.png"></div><br><h2>  Schwankender Raum </h2><br>  Aber um den Raum zu √§ndern, ist es nicht notwendig, ihn zu wiederholen.  Im Tutorial zu den Grundlagen haben wir es beispielsweise gedreht, verschoben und skaliert.  Sie k√∂nnen auch Folgendes tun: Bewegen Sie jede Achse mit einer Sinuswelle auf der Basis der anderen.  Dadurch werden die Abst√§nde der vorzeichenbehafteten Abstandsfunktion weniger genau, aber bis sie zu stark schwingen, ist alles in Ordnung. <br><br>  Zuerst berechnen wir die Gr√∂√üe der Positions√§nderung, indem wir die x- und y-Komponenten umdrehen und sie dann mit der Wobbelfrequenz multiplizieren.  Dann nehmen wir den Sinus von diesem Wert und multiplizieren ihn mit der Menge an Wackeln, die wir hinzuf√ºgen m√∂chten.  Danach addieren wir einfach diesen Wobbelfaktor zur Position und wenden das Ergebnis erneut auf die Position an. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in 2D_SDF.cginc void wobble(inout float2 position, float2 frequency, float2 amount){ float2 wobble = sin(position.yx * frequency) * amount; position = position + wobble; }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in shader function wobble(position, 5, .05);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/01c/67e/ec8/01c67eec8726bff917f97e90a5fa8431.png"></div><br>  Wir k√∂nnen dieses Winken auch animieren, indem wir seine Position √§ndern, das Winken an der versetzten Position anwenden und den Raum zur√ºckgeben.  Damit die Gleitkommazahlen nicht zu gro√ü werden, dividiere ich mit dem Rest pi * 2 durch die Wobbelfrequenz, dies korreliert mit dem Wobble (die Sinuskurve wiederholt alle pi * 2-Einheiten), sodass Spr√ºnge und zu gro√üe Offsets vermieden werden. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in shader function const float PI = 3.14159; float frequency = 5; float offset = _Time.y; offset = fmod(offset, PI * 2 / frequency); position = translate(position, offset); wobble(position, 5, .05); position = translate(position, -offset);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b13/a59/cc9/b13a59cc9538d7f55cc41cba474575d7.gif"></div><br><h2>  Quellcode </h2><br><h3>  2D SDF Bibliothek </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/036_SDF_space_manipulation/2D_SDF.cginc</a> </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> SDF_2D #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SDF_2D </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//transforms float2 rotate(float2 samplePosition, float rotation){ const float PI = 3.14159; float angle = rotation * PI * 2 * -1; float sine, cosine; sincos(angle, sine, cosine); return float2(cosine * samplePosition.x + sine * samplePosition.y, cosine * samplePosition.y - sine * samplePosition.x); } float2 translate(float2 samplePosition, float2 offset){ //move samplepoint in the opposite direction that we want to move shapes in return samplePosition - offset; } float2 scale(float2 samplePosition, float scale){ return samplePosition / scale; } //combinations ///basic float merge(float shape1, float shape2){ return min(shape1, shape2); } float intersect(float shape1, float shape2){ return max(shape1, shape2); } float subtract(float base, float subtraction){ return intersect(base, -subtraction); } float interpolate(float shape1, float shape2, float amount){ return lerp(shape1, shape2, amount); } /// round float round_merge(float shape1, float shape2, float radius){ float2 intersectionSpace = float2(shape1 - radius, shape2 - radius); intersectionSpace = min(intersectionSpace, 0); float insideDistance = -length(intersectionSpace); float simpleUnion = merge(shape1, shape2); float outsideDistance = max(simpleUnion, radius); return insideDistance + outsideDistance; } float round_intersect(float shape1, float shape2, float radius){ float2 intersectionSpace = float2(shape1 + radius, shape2 + radius); intersectionSpace = max(intersectionSpace, 0); float outsideDistance = length(intersectionSpace); float simpleIntersection = intersect(shape1, shape2); float insideDistance = min(simpleIntersection, -radius); return outsideDistance + insideDistance; } float round_subtract(float base, float subtraction, float radius){ return round_intersect(base, -subtraction, radius); } ///champfer float champfer_merge(float shape1, float shape2, float champferSize){ const float SQRT_05 = 0.70710678118; float simpleMerge = merge(shape1, shape2); float champfer = (shape1 + shape2) * SQRT_05; champfer = champfer - champferSize; return merge(simpleMerge, champfer); } float champfer_intersect(float shape1, float shape2, float champferSize){ const float SQRT_05 = 0.70710678118; float simpleIntersect = intersect(shape1, shape2); float champfer = (shape1 + shape2) * SQRT_05; champfer = champfer + champferSize; return intersect(simpleIntersect, champfer); } float champfer_subtract(float base, float subtraction, float champferSize){ return champfer_intersect(base, -subtraction, champferSize); } /// round border intersection float round_border(float shape1, float shape2, float radius){ float2 position = float2(shape1, shape2); float distanceFromBorderIntersection = length(position); return distanceFromBorderIntersection - radius; } float groove_border(float base, float groove, float width, float depth){ float circleBorder = abs(groove) - width; float grooveShape = subtract(circleBorder, base + depth); return subtract(base, grooveShape); } // space repetition void mirror(inout float2 position){ position.x = abs(position.x); } float2 cells(inout float2 position, float2 period){ //find cell index float2 cellIndex = position / period; cellIndex = floor(cellIndex); //negative positions lead to negative modulo position = fmod(position, period); //negative positions now have correct cell coordinates, positive input positions too high position += period; //second mod doesn't change values between 0 and period, but brings down values that are above period. position = fmod(position, period); return cellIndex; } float radial_cells(inout float2 position, float cells, bool mirrorEverySecondCell = false){ const float PI = 3.14159; float cellSize = PI * 2 / cells; float2 radialPosition = float2(atan2(position.x, position.y), length(position)); float cellIndex = fmod(floor(radialPosition.x / cellSize) + cells, cells); radialPosition.x = fmod(fmod(radialPosition.x, cellSize) + cellSize, cellSize); if(mirrorEverySecondCell){ float flip = fmod(cellIndex, 2); flip = abs(flip-1); radialPosition.x = lerp(cellSize - radialPosition.x, radialPosition.x, flip); } sincos(radialPosition.x, position.x, position.y); position = position * radialPosition.y; return cellIndex; } void wobble(inout float2 position, float2 frequency, float2 amount){ float2 wobble = sin(position.yx * frequency) * amount; position = position + wobble; } //shapes float circle(float2 samplePosition, float radius){ //get distance from center and grow it according to radius return length(samplePosition) - radius; } float rectangle(float2 samplePosition, float2 halfSize){ float2 componentWiseEdgeDistance = abs(samplePosition) - halfSize; float outsideDistance = length(max(componentWiseEdgeDistance, 0)); float insideDistance = min(max(componentWiseEdgeDistance.x, componentWiseEdgeDistance.y), 0); return outsideDistance + insideDistance; } #endif</span></span></span></span></code> </pre> <br><h3>  Grundlegender Demo-Shader </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/036_SDF_space_manipulation/sdf_mirror.shader</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/036_SDF_space_manipulation/sdf_cells.shader</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/036_SDF_space_manipulation/sdf_wobble.shader</a> </li></ul><br><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Tutorial/036_SDF_Space_Manpulation/Mirror"</span></span>{ Properties{ _InsideColor(<span class="hljs-string"><span class="hljs-string">"Inside Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _OutsideColor(<span class="hljs-string"><span class="hljs-string">"Outside Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _LineDistance(<span class="hljs-string"><span class="hljs-string">"Mayor Line Distance"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) = <span class="hljs-number"><span class="hljs-number">1</span></span> _LineThickness(<span class="hljs-string"><span class="hljs-string">"Mayor Line Thickness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.05</span></span> [IntRange]_SubLines(<span class="hljs-string"><span class="hljs-string">"Lines between major lines"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)) = <span class="hljs-number"><span class="hljs-number">4</span></span> _SubLineThickness(<span class="hljs-string"><span class="hljs-string">"Thickness of inbetween lines"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.05</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.01</span></span> } SubShader{ <span class="hljs-comment"><span class="hljs-comment">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry Tags{ "RenderType"="Opaque" "Queue"="Geometry"} Pass{ CGPROGRAM #include "UnityCG.cginc" #include "2D_SDF.cginc" #pragma vertex vert #pragma fragment frag struct appdata{ float4 vertex : POSITION; }; struct v2f{ float4 position : SV_POSITION; float4 worldPos : TEXCOORD0; }; v2f vert(appdata v){ v2f o; //calculate the position in clip space to render the object o.position = UnityObjectToClipPos(v.vertex); //calculate world position of vertex o.worldPos = mul(unity_ObjectToWorld, v.vertex); return o; } float scene(float2 position) { // modify position here! float2 squarePosition = position; squarePosition = translate(squarePosition, float2(2, 2)); squarePosition = rotate(squarePosition, .125); float squareShape = rectangle(squarePosition, float2(1, 1)); float2 circlePosition = position; circlePosition = translate(circlePosition, float2(1, 1.5)); float circleShape = circle(circlePosition, 1); float combination = merge(circleShape, squareShape); return combination; } float4 _InsideColor; float4 _OutsideColor; float _LineDistance; float _LineThickness; float _SubLines; float _SubLineThickness; fixed4 frag(v2f i) : SV_TARGET{ float dist = scene(i.worldPos.xz); fixed4 col = lerp(_InsideColor, _OutsideColor, step(0, dist)); float distanceChange = fwidth(dist) * 0.5; float majorLineDistance = abs(frac(dist / _LineDistance + 0.5) - 0.5) * _LineDistance; float majorLines = smoothstep(_LineThickness - distanceChange, _LineThickness + distanceChange, majorLineDistance); float distanceBetweenSubLines = _LineDistance / _SubLines; float subLineDistance = abs(frac(dist / distanceBetweenSubLines + 0.5) - 0.5) * distanceBetweenSubLines; float subLines = smoothstep(_SubLineThickness - distanceChange, _SubLineThickness + distanceChange, subLineDistance); return col * majorLines * subLines; } ENDCG } } FallBack "Standard" //fallback adds a shadow pass so we get shadows on other objects }</span></span></code> </pre> <br>  Jetzt kennen Sie alle Grundlagen der Vorzeichenentfernungsfunktionen, an die ich mich erinnern konnte.  Im n√§chsten Tutorial werde ich versuchen, etwas Interessantes mit ihnen zu machen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/842/5fe/d84/8425fed84e484cd150a7eba8b4d8901c.gif"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439000/">https://habr.com/ru/post/de439000/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438988/index.html">React Tutorial Teil 15: Komponentenstatus-Workshops</a></li>
<li><a href="../de438992/index.html">Entwicklertagebuch oder schlechte Entscheidungen</a></li>
<li><a href="../de438994/index.html">Intel Xeon W-3175X, ein hei√üer Schlagzeuger. Testen</a></li>
<li><a href="../de438996/index.html">Firmennetzwerk und MitM. Teil 1</a></li>
<li><a href="../de438998/index.html">CGDevs Moscow Meetup # 2</a></li>
<li><a href="../de439002/index.html">Wie kann ich aufh√∂ren, "TK zu schreiben" und anfangen zu arbeiten?</a></li>
<li><a href="../de439006/index.html">Wie KI hilft, Geb√§rdensprache zu lernen</a></li>
<li><a href="../de439010/index.html">Funktionsweise der Archivkonsolidierung in DeviceLock DLP</a></li>
<li><a href="../de439012/index.html">Organisationstelefonbuch - Druckversion</a></li>
<li><a href="../de439016/index.html">Statische generische Tabellen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>