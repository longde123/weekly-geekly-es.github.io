<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🆑 🐿️ 👩🏼 Debugging keterlambatan jaringan di Kubernetes 🔝 👨🏾‍🤝‍👨🏻 🍑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beberapa tahun yang lalu, Kubernetes sudah dibahas di blog resmi GitHub. Sejak itu, ia telah menjadi teknologi standar untuk menyebarkan layanan. Kube...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Debugging keterlambatan jaringan di Kubernetes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/477390/"><img src="https://habrastorage.org/getpro/habr/post_images/c82/5b1/413/c825b1413d9c59cf78c51e6e2c8f8049.png"><br><br>  Beberapa tahun yang lalu, Kubernetes <a href="https://github.blog/2017-08-16-kubernetes-at-github/">sudah dibahas</a> di blog resmi GitHub.  Sejak itu, ia telah menjadi teknologi standar untuk menyebarkan layanan.  Kubernetes sekarang mengelola sebagian besar layanan internal dan publik.  Ketika kluster kami tumbuh dan persyaratan kinerja menjadi lebih ketat, kami mulai memperhatikan bahwa beberapa layanan di Kubernetes secara sporadis menampilkan penundaan yang tidak dapat dijelaskan oleh beban aplikasi itu sendiri. <br><br>  Bahkan, dalam aplikasi, penundaan jaringan acak hingga 100 ms atau lebih terjadi, yang mengarah ke waktu habis atau coba lagi.  Diharapkan bahwa layanan akan dapat menanggapi permintaan lebih cepat dari 100 ms.  Tetapi ini tidak mungkin jika koneksi itu sendiri membutuhkan banyak waktu.  Secara terpisah, kami mengamati permintaan MySQL yang sangat cepat, yang seharusnya mengambil milidetik, dan MySQL benar-benar dikelola dalam milidetik, tetapi dari sudut pandang aplikasi yang meminta, responsnya memakan waktu 100 ms atau lebih. <br><a name="habracut"></a><br>  Segera menjadi jelas bahwa masalah hanya terjadi ketika menghubungkan ke host Kubernetes, bahkan jika panggilan itu berasal dari luar Kubernetes.  Cara termudah untuk mereproduksi masalah adalah dalam tes <a href="https://github.com/tsenart/vegeta">Vegeta</a> , yang dijalankan dari host internal apa pun, menguji layanan Kubernetes pada port tertentu, dan secara sporadis mendaftarkan penundaan besar.  Di artikel ini, kita akan melihat bagaimana kami berhasil melacak penyebab masalah ini. <br><br><h1>  Hilangkan kompleksitas yang tidak perlu dalam rantai kegagalan </h1><br>  Setelah mereproduksi contoh yang sama, kami ingin mempersempit fokus masalah dan menghapus lapisan kompleksitas tambahan.  Awalnya, ada terlalu banyak elemen dalam aliran antara Vegeta dan polong di Kubernetes.  Untuk mengidentifikasi masalah jaringan yang lebih dalam, Anda perlu mengecualikan beberapa dari mereka. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/488/8c1/d29/4888c1d29a8fc1b4a1194c4c3a14c9ff.png"><br><br>  Klien (Vegeta) membuat koneksi TCP dengan node apa pun di cluster.  Kubernet bertindak sebagai jaringan overlay (di atas jaringan pusat data yang ada) yang menggunakan <a href="https://en.wikipedia.org/wiki/IP_in_IP">IPIP</a> , yaitu, merangkum paket IP dari jaringan overlay di dalam paket IP dari pusat data.  Ketika terhubung ke node pertama, terjemahan alamat jaringan <a href="https://en.wikipedia.org/wiki/Network_address_translation">Network Address Translation</a> (NAT) dilakukan dengan pemantauan negara untuk mengonversi alamat IP dan port host Kubernetes ke alamat IP dan port pada jaringan overlay (khususnya, pod dengan aplikasi).  Untuk paket yang diterima, urutan terbalik dilakukan.  Ini adalah sistem yang kompleks dengan banyak negara dan banyak elemen yang terus diperbarui dan diubah saat layanan dikerahkan dan dipindahkan. <br><br>  Utilitas <code>tcpdump</code> dalam tes Vegeta memberikan penundaan selama jabat tangan TCP (antara SYN dan SYN-ACK).  Untuk menghapus kompleksitas yang tidak perlu ini, Anda dapat menggunakan <code>hping3</code> untuk “ping” sederhana dengan paket SYN.  Periksa apakah ada keterlambatan dalam paket respons, dan kemudian atur ulang koneksi.  Kami dapat memfilter data dengan memasukkan hanya paket lebih dari 100 ms, dan mendapatkan opsi yang lebih sederhana untuk mereproduksi masalah daripada tes level 7 jaringan penuh di Vegeta.  Berikut adalah "ping" dari host Kubernetes menggunakan TCP SYN / SYN-ACK pada "port" host layanan (30927) dengan interval 10 ms, disaring oleh respons paling lambat: <br><br> <code>theojulienne@shell ~ $ sudo hping3 172.16.47.27 -S -p 30927 -i u10000 | egrep --line-buffered 'rtt=[0-9]{3}\.' <br> <br> len=46 ip=172.16.47.27 ttl=59 DF id=0 sport=30927 flags=SA seq=1485 win=29200 rtt=127.1 ms <br> <br> len=46 ip=172.16.47.27 ttl=59 DF id=0 sport=30927 flags=SA seq=1486 win=29200 rtt=117.0 ms <br> <br> len=46 ip=172.16.47.27 ttl=59 DF id=0 sport=30927 flags=SA seq=1487 win=29200 rtt=106.2 ms <br> <br> len=46 ip=172.16.47.27 ttl=59 DF id=0 sport=30927 flags=SA seq=1488 win=29200 rtt=104.1 ms <br> <br> len=46 ip=172.16.47.27 ttl=59 DF id=0 sport=30927 flags=SA seq=5024 win=29200 rtt=109.2 ms <br> <br> len=46 ip=172.16.47.27 ttl=59 DF id=0 sport=30927 flags=SA seq=5231 win=29200 rtt=109.2 ms</code> <br> <br>  Segera bisa melakukan pengamatan pertama.  Nomor seri dan pengaturan waktu menunjukkan bahwa ini bukan kemacetan satu kali.  Penundaan sering terakumulasi, dan akhirnya diproses. <br><br>  Selanjutnya, kami ingin mengetahui komponen mana yang mungkin terlibat dalam penampilan kemacetan.  Mungkin ini beberapa dari ratusan aturan iptables di NAT?  Atau beberapa masalah dengan tunneling IPIP di jaringan?  Salah satu cara untuk memverifikasi ini adalah memverifikasi setiap langkah sistem dengan mengecualikannya.  Apa yang terjadi jika Anda menghapus logika NAT dan firewall, hanya menyisakan sebagian dari IPIP: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5b3/e2a/cff/5b3e2acff2ef9f1f8c7c527356741d92.png"><br><br>  Untungnya, Linux memudahkan untuk secara langsung mengakses lapisan overlay IP jika mesin berada di jaringan yang sama: <br><br> <code>theojulienne@kube-node-client ~ $ sudo hping3 10.125.20.64 -S -i u10000 | egrep --line-buffered 'rtt=[0-9]{3}\.' <br> <br> len=40 ip=10.125.20.64 ttl=64 DF id=0 sport=0 flags=RA seq=7346 win=0 rtt=127.3 ms <br> <br> len=40 ip=10.125.20.64 ttl=64 DF id=0 sport=0 flags=RA seq=7347 win=0 rtt=117.3 ms <br> <br> len=40 ip=10.125.20.64 ttl=64 DF id=0 sport=0 flags=RA seq=7348 win=0 rtt=107.2 ms</code> <br> <br>  Menilai dari hasilnya, masalahnya masih ada!  Ini tidak termasuk iptables dan NAT.  Jadi masalahnya ada di TCP?  Mari kita lihat bagaimana ping ICMP biasa: <br><br> <code>theojulienne@kube-node-client ~ $ sudo hping3 10.125.20.64 --icmp -i u10000 | egrep --line-buffered 'rtt=[0-9]{3}\.' <br> <br> len=28 ip=10.125.20.64 ttl=64 id=42594 icmp_seq=104 rtt=110.0 ms <br> <br> len=28 ip=10.125.20.64 ttl=64 id=49448 icmp_seq=4022 rtt=141.3 ms <br> <br> len=28 ip=10.125.20.64 ttl=64 id=49449 icmp_seq=4023 rtt=131.3 ms <br> <br> len=28 ip=10.125.20.64 ttl=64 id=49450 icmp_seq=4024 rtt=121.2 ms <br> <br> len=28 ip=10.125.20.64 ttl=64 id=49451 icmp_seq=4025 rtt=111.2 ms <br> <br> len=28 ip=10.125.20.64 ttl=64 id=49452 icmp_seq=4026 rtt=101.1 ms <br> <br> len=28 ip=10.125.20.64 ttl=64 id=50023 icmp_seq=4343 rtt=126.8 ms <br> <br> len=28 ip=10.125.20.64 ttl=64 id=50024 icmp_seq=4344 rtt=116.8 ms <br> <br> len=28 ip=10.125.20.64 ttl=64 id=50025 icmp_seq=4345 rtt=106.8 ms <br> <br> len=28 ip=10.125.20.64 ttl=64 id=59727 icmp_seq=9836 rtt=106.1 ms</code> <br> <br>  Hasilnya menunjukkan bahwa masalahnya belum hilang.  Mungkin ini adalah terowongan IPIP?  Mari sederhanakan tesnya: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/267/ff6/137/267ff613754b99f8cc1bb1d89119206e.png"><br><br>  Apakah semua paket dikirim antara dua host ini? <br><br> <code>theojulienne@kube-node-client ~ $ sudo hping3 172.16.47.27 --icmp -i u10000 | egrep --line-buffered 'rtt=[0-9]{3}\.' <br> <br> len=46 ip=172.16.47.27 ttl=61 id=41127 icmp_seq=12564 rtt=140.9 ms <br> <br> len=46 ip=172.16.47.27 ttl=61 id=41128 icmp_seq=12565 rtt=130.9 ms <br> <br> len=46 ip=172.16.47.27 ttl=61 id=41129 icmp_seq=12566 rtt=120.8 ms <br> <br> len=46 ip=172.16.47.27 ttl=61 id=41130 icmp_seq=12567 rtt=110.8 ms <br> <br> len=46 ip=172.16.47.27 ttl=61 id=41131 icmp_seq=12568 rtt=100.7 ms <br> <br> len=46 ip=172.16.47.27 ttl=61 id=9062 icmp_seq=31443 rtt=134.2 ms <br> <br> len=46 ip=172.16.47.27 ttl=61 id=9063 icmp_seq=31444 rtt=124.2 ms <br> <br> len=46 ip=172.16.47.27 ttl=61 id=9064 icmp_seq=31445 rtt=114.2 ms <br> <br> len=46 ip=172.16.47.27 ttl=61 id=9065 icmp_seq=31446 rtt=104.2 ms</code> <br> <br>  Kami menyederhanakan situasinya ke dua host Kubernet yang saling mengirim paket, bahkan ping ICMP.  Mereka masih melihat penundaan jika host target "buruk" (beberapa lebih buruk daripada yang lain). <br><br>  Sekarang pertanyaan terakhir: mengapa penundaan hanya terjadi pada server kube-node?  Dan apakah itu terjadi ketika kube-node adalah pengirim atau penerima?  Untungnya, ini juga cukup mudah untuk diketahui dengan mengirim paket dari host di luar Kubernetes, tetapi dengan penerima yang "dikenal buruk" yang sama.  Seperti yang Anda lihat, masalahnya belum hilang: <br><br> <code>theojulienne@shell ~ $ sudo hping3 172.16.47.27 -p 9876 -S -i u10000 | egrep --line-buffered 'rtt=[0-9]{3}\.' <br> <br> len=46 ip=172.16.47.27 ttl=61 DF id=0 sport=9876 flags=RA seq=312 win=0 rtt=108.5 ms <br> <br> len=46 ip=172.16.47.27 ttl=61 DF id=0 sport=9876 flags=RA seq=5903 win=0 rtt=119.4 ms <br> <br> len=46 ip=172.16.47.27 ttl=61 DF id=0 sport=9876 flags=RA seq=6227 win=0 rtt=139.9 ms <br> <br> len=46 ip=172.16.47.27 ttl=61 DF id=0 sport=9876 flags=RA seq=7929 win=0 rtt=131.2 ms</code> <br> <br>  Kemudian kami melakukan permintaan yang sama dari node-sumber sebelumnya ke host eksternal (yang tidak termasuk host asli, karena ping menyertakan komponen RX dan TX): <br><br> <code>theojulienne@kube-node-client ~ $ sudo hping3 172.16.33.44 -p 9876 -S -i u10000 | egrep --line-buffered 'rtt=[0-9]{3}\.' <br> ^C <br> --- 172.16.33.44 hping statistic --- <br> 22352 packets transmitted, 22350 packets received, 1% packet loss <br> round-trip min/avg/max = 0.2/7.6/1010.6 ms</code> <br> <br>  Setelah memeriksa penangkapan paket yang tertunda, kami mendapat beberapa informasi tambahan.  Secara khusus, bahwa pengirim (di bawah) melihat batas waktu ini, tetapi penerima (di atas) tidak melihatnya - lihat kolom Delta (dalam detik): <br><br> <a href=""><img src="https://habrastorage.org/webt/4m/-t/dj/4m-tdjzws9lrhnva3xcxijel7eg.png"></a> <br><br>  Selain itu, jika Anda melihat perbedaan dalam urutan paket TCP dan ICMP (dengan nomor seri) di sisi penerima, maka paket ICMP selalu tiba dalam urutan yang sama di mana mereka dikirim, tetapi dengan waktu yang berbeda.  Pada saat yang sama, paket TCP kadang-kadang bergantian, dan beberapa di antaranya macet.  Secara khusus, jika kita memeriksa port dari paket SYN, maka di sisi pengirim mereka pergi dalam urutan, tetapi di sisi penerima mereka tidak. <br><br>  Ada sedikit perbedaan dalam bagaimana <a href="https://en.wikipedia.org/wiki/Network_address_translation">kartu jaringan</a> server modern (seperti dalam data center kami) memproses paket yang berisi TCP atau ICMP.  Ketika sebuah paket tiba, adapter jaringan “hashes it over the connection”, artinya, ia mencoba memutus koneksi secara bergantian dan mengirim setiap antrian ke inti prosesor yang terpisah.  Untuk TCP, hash ini mencakup sumber dan tujuan alamat IP dan port.  Dengan kata lain, setiap koneksi hash (berpotensi) berbeda.  Untuk ICMP, hanya alamat IP yang di-hash, karena tidak ada port. <br><br>  Pengamatan baru lainnya: selama periode ini kita melihat keterlambatan ICMP pada semua komunikasi antara dua host, tetapi TCP tidak.  Ini memberitahu kita bahwa alasannya mungkin karena hashing dari antrian RX: hampir pasti bahwa kemacetan terjadi dalam pemrosesan paket RX, daripada dalam mengirim tanggapan. <br><br>  Ini tidak termasuk pengiriman paket dari daftar kemungkinan alasan.  Sekarang kita tahu bahwa masalah dengan pemrosesan paket ada di sisi penerima pada beberapa server kube-node. <br><br><h1>  Memahami Pemrosesan Paket di Kernel Linux </h1><br>  Untuk memahami mengapa masalah terjadi dengan penerima pada beberapa server kube-node, mari kita lihat bagaimana kernel Linux menangani paket. <br><br>  Kembali ke implementasi tradisional yang paling sederhana, kartu jaringan menerima paket dan mengirimkan <a href="https://en.wikipedia.org/wiki/Interrupt">interupsi</a> ke kernel Linux, yang merupakan paket yang perlu diproses.  Kernel menghentikan operasi lain, mengalihkan konteks ke interrupt handler, memproses paket, dan kemudian kembali ke tugas saat ini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1a2/3c3/4ee/1a23c34eea2236294913fd09a25aa1e4.png"><br><br>  Switch konteks ini lambat: latensi mungkin tidak terlihat pada kartu jaringan 10-megabyte pada 1990-an, tetapi pada kartu 10G modern dengan throughput maksimum 15 juta paket per detik, setiap inti dari server delapan-inti kecil dapat diinterupsi jutaan kali per detik. <br><br>  Agar tidak berurusan dengan penanganan interupsi terus-menerus, bertahun-tahun yang lalu Linux menambahkan <a href="https://en.wikipedia.org/wiki/New_API">NAPI</a> : API jaringan yang digunakan semua driver modern untuk meningkatkan kinerja pada kecepatan tinggi.  Pada kecepatan rendah, kernel masih menerima interupsi dari kartu jaringan dengan cara lama.  Segera setelah jumlah paket yang cukup yang melebihi ambang batas, kernel menonaktifkan interupsi dan sebagai gantinya mulai polling adapter jaringan dan mengambil paket dalam batch.  Pemrosesan dilakukan dalam softirq, yaitu, dalam <a href="https://www.kernel.org/doc/htmldocs/kernel-hacking/basics-softirqs.html">konteks interupsi perangkat lunak</a> setelah panggilan sistem dan interupsi perangkat keras ketika kernel (tidak seperti ruang pengguna) sudah berjalan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/22a/50d/ee1/22a50dee1fffdbc20614db2b1db28fc4.png"><br><br>  Ini jauh lebih cepat, tetapi menyebabkan masalah yang berbeda.  Jika ada terlalu banyak paket, semua waktu yang diperlukan untuk memproses paket dari kartu jaringan, dan proses ruang pengguna tidak punya waktu untuk benar-benar mengosongkan antrian ini (membaca dari koneksi TCP, dll.).  Pada akhirnya, antrian terisi dan kami mulai menjatuhkan paket.  Mencoba menemukan keseimbangan, kernel menetapkan anggaran untuk jumlah maksimum paket yang diproses dalam konteks softirq.  Setelah anggaran ini terlampaui, utas <code>ksoftirqd</code> terpisah <code>ksoftirqd</code> (Anda akan melihat salah satunya di <code>ps</code> untuk setiap inti), yang memproses softirqs ini di luar jalur syscall / interrupt normal.  Utas ini direncanakan menggunakan penjadwal proses standar yang berupaya mendistribusikan sumber daya secara adil. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d0f/1e6/f0c/d0f1e6f0c54d45c24d62cb2bcf90c674.png"><br><br>  Setelah memeriksa bagaimana kernel memproses paket, Anda dapat melihat bahwa ada kemungkinan kemacetan tertentu.  Jika panggilan softirq diterima lebih jarang, paket harus menunggu beberapa saat untuk diproses dalam antrian RX pada kartu jaringan.  Mungkin ini karena beberapa tugas memblokir inti prosesor, atau sesuatu yang lain mencegah kernel memulai softirq. <br><br><h1>  Kami mempersempit pemrosesan ke kernel atau metode </h1><br>  Penundaan softirq hanyalah sebuah asumsi.  Tapi itu masuk akal, dan kita tahu bahwa kita melihat sesuatu yang sangat mirip.  Karena itu, langkah selanjutnya adalah mengkonfirmasi teori ini.  Dan jika sudah dikonfirmasi, maka cari alasan keterlambatannya. <br><br>  Kembali ke paket lambat kami: <br><br> <code>len=46 ip=172.16.53.32 ttl=61 id=29573 icmp_seq=1953 rtt=99.3 ms <br> <br> len=46 ip=172.16.53.32 ttl=61 id=29574 icmp_seq=1954 rtt=89.3 ms <br> <br> len=46 ip=172.16.53.32 ttl=61 id=29575 icmp_seq=1955 rtt=79.2 ms <br> <br> len=46 ip=172.16.53.32 ttl=61 id=29576 icmp_seq=1956 rtt=69.1 ms <br> <br> len=46 ip=172.16.53.32 ttl=61 id=29577 icmp_seq=1957 rtt=59.1 ms <br> <br> len=46 ip=172.16.53.32 ttl=61 id=29790 icmp_seq=2070 rtt=75.7 ms <br> <br> len=46 ip=172.16.53.32 ttl=61 id=29791 icmp_seq=2071 rtt=65.6 ms <br> <br> len=46 ip=172.16.53.32 ttl=61 id=29792 icmp_seq=2072 rtt=55.5 ms</code> <br> <br>  Seperti dibahas sebelumnya, paket ICMP ini di-hash menjadi satu antrian NIC RX dan diproses oleh satu inti CPU.  Jika kami ingin memahami cara kerja Linux, akan sangat berguna untuk mengetahui di mana (di mana inti CPU) dan bagaimana (softirq, ksoftirqd) paket ini diproses untuk melacak proses. <br><br>  Sekarang saatnya menggunakan alat yang memungkinkan pemantauan real-time dari kernel Linux.  Di sini kami menggunakan <a href="https://github.com/iovisor/bcc">bcc</a> .  Serangkaian alat ini memungkinkan Anda untuk menulis program C kecil yang mencegat fungsi sewenang-wenang di kernel dan buffer event ke dalam program Python ruang-pengguna yang dapat memprosesnya dan mengembalikan hasilnya kepada Anda.  Kait untuk fungsi sewenang-wenang di kernel sangat kompleks, tetapi utilitas ini dirancang untuk keamanan maksimum dan dirancang untuk melacak dengan tepat masalah-masalah produksi yang tidak mudah direproduksi dalam lingkungan pengujian atau pengembangan. <br><br>  Rencananya di sini sederhana: kita tahu bahwa kernel memproses ICMP ping ini, jadi kami mengaitkan <a href="">fungsi</a> kernel <a href="">icmp_echo</a> , yang menerima paket ICMP permintaan gema yang masuk dan memulai pengiriman respons ICMP respons gema.  Kami dapat mengidentifikasi paket dengan menambah nomor icmp_seq, yang menunjukkan <code>hping3</code> atas. <br><br>  Kode <a href="https://gist.github.com/theojulienne/9d78a0cb68dbe56f19a2ae6316bc6846">skrip bcc</a> terlihat rumit, tetapi tidak seseram kelihatannya.  Fungsi <code>icmp_echo</code> melewati <code>struct sk_buff *skb</code> : ini adalah paket dengan permintaan "echo request".  Kita dapat melacaknya, mengeluarkan urutan <code>echo.sequence</code> (yang memetakan ke <code>icmp_seq</code> dari hping3 di <code></code> ), dan mengirimkannya ke ruang pengguna.  Juga mudah untuk menangkap nama proses / pengenal saat ini.  Di bawah ini adalah hasil yang kami lihat langsung selama pemrosesan paket oleh kernel: <br><br><pre>  NAMA PROSES PID TGID ICMP_SEQ
 0 0 swapper / 11.770
 0 0 swapper / 11.771
 0 0 swapper / 11 772
 0 0 swapper / 11 773
 0 0 swapper / 11.774
 20041 20086 prometheus 775
 0 0 swapper / 11.776
 0 0 swapper / 11.777
 0 0 swapper / 11 778
 4512 4542 juru bicara-laporan 779 </pre><br>  Perlu dicatat di sini bahwa dalam konteks <code>softirq</code> proses yang membuat panggilan sistem muncul sebagai "proses", meskipun sebenarnya kernel ini dengan aman memproses paket dalam konteks kernel. <br><br>  Dengan alat ini kita dapat membangun koneksi proses-proses spesifik dengan paket-paket spesifik yang menunjukkan penundaan dalam <code>hping3</code> .  Kami membuat <code>grep</code> sederhana pada tangkapan ini untuk nilai <code>icmp_seq</code> tertentu.  Paket yang sesuai dengan nilai icmp_seq di atas ditandai dengan RTT mereka, yang kami amati di atas (dalam tanda kurung adalah nilai RTT yang diharapkan untuk paket yang kami filter karena nilai RTT kurang dari 50 ms): <br><br><pre>  NAMA PROSES PID TGID ICMP_SEQ ** RTT
 -
 10137 10436 cadvisor 1951
 10137 10436 cadvisor 1952
 76 76 ksoftirqd / 11 1953 ** 99ms
 76 76 ksoftirqd / 11 1954 ** 89ms
 76 76 ksoftirqd / 11 1955 ** 79ms
 76 76 ksoftirqd / 11 1956 ** 69ms
 76 76 ksoftirqd / 11 1957 ** 59ms
 76 76 ksoftirqd / 11 1958 ** (49ms)
 76 76 ksoftirqd / 11 1959 ** (39ms)
 76 76 ksoftirqd / 11 1960 ** (29ms)
 76 76 ksoftirqd / 11 1961 ** (19ms)
 76 76 ksoftirqd / 11 1962 ** (9ms)
 -
 10137 10436 cadvisor 2068
 10137 10436 cadvisor 2069
 76 76 ksoftirqd / 11 2070 ** 75ms
 76 76 ksoftirqd / 11 2071 ** 65ms
 76 76 ksoftirqd / 11 2072 ** 55ms
 76 76 ksoftirqd / 11 2073 ** (45ms)
 76 76 ksoftirqd / 11 2074 ** (35ms)
 76 76 ksoftirqd / 11 2075 ** (25ms)
 76 76 ksoftirqd / 11 2076 ** (15ms)
 76 76 ksoftirqd / 11 2077 ** (5ms) </pre><br>  Hasilnya memberi tahu kami beberapa hal.  Pertama, konteks <code>ksoftirqd/11</code> menangani semua paket ini.  Ini berarti bahwa untuk pasangan mesin khusus ini, paket ICMP di-hash pada inti 11 pada sisi penerima.  Kita juga melihat bahwa di setiap kemacetan ada paket yang diproses dalam konteks panggilan sistem <code>cadvisor</code> .  Kemudian <code>ksoftirqd</code> mengambil tugas dan memenuhi antrian yang terakumulasi: persis jumlah paket yang terakumulasi setelah <code>cadvisor</code> . <br><br>  Fakta bahwa <code>cadvisor</code> selalu berfungsi segera sebelum ini menyiratkan keterlibatannya dalam masalah tersebut.  Ironisnya, tujuan <a href="https://github.com/google/cadvisor">cadvisor</a> adalah untuk "menganalisis pemanfaatan sumber daya dan karakteristik kinerja wadah yang berjalan," daripada menyebabkan masalah kinerja ini. <br><br>  Seperti halnya aspek-aspek lain dalam penanganan peti kemas, semua ini adalah alat yang sangat canggih yang dapat menyebabkan masalah kinerja dalam beberapa keadaan yang tidak terduga. <br><br><h1>  Apa yang dilakukan cadvisor yang memperlambat antrian paket? </h1><br>  Sekarang kita memiliki pemahaman yang cukup baik tentang bagaimana kegagalan terjadi, proses mana yang menyebabkannya, dan pada CPU mana.  Kami melihat bahwa karena penguncian yang keras, kernel Linux tidak punya waktu untuk menjadwalkan <code>ksoftirqd</code> .  Dan kami melihat bahwa paket diproses dalam konteks <code>cadvisor</code> .  Adalah logis untuk mengasumsikan bahwa <code>cadvisor</code> memulai syscall lambat, setelah semua paket yang terakumulasi saat ini diproses: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6fd/6fb/970/6fd6fb970f2d27943039910db9b41743.png"><br><br>  Ini adalah teori, tetapi bagaimana cara mengujinya?  Apa yang dapat kita lakukan adalah melacak operasi inti CPU selama proses ini, menemukan titik di mana anggaran terlampaui oleh jumlah paket dan ksoftirqd dipanggil, dan kemudian melihat sedikit lebih awal - apa yang sebenarnya bekerja pada inti CPU tepat sebelum saat itu.  Ini seperti x-ray CPU setiap beberapa milidetik.  Akan terlihat seperti ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/44a/954/6e8/44a9546e8de19e43cb125eb8a03a8f47.png"><br><br>  Mudahnya, semua ini bisa dilakukan dengan alat yang ada.  Sebagai contoh, <a href="https://perf.wiki.kernel.org/index.php/Tutorial">catatan perf</a> memeriksa inti CPU yang ditentukan dengan frekuensi yang ditunjukkan dan dapat menghasilkan jadwal panggilan ke sistem yang sedang berjalan, termasuk ruang pengguna dan kernel Linux.  Anda dapat mengambil catatan ini dan memprosesnya menggunakan garpu kecil program <a href="https://github.com/brendangregg/FlameGraph">FlameGraph</a> dari Brendan Gregg, yang mempertahankan urutan jejak tumpukan.  Kita dapat menyimpan jejak tumpukan satu baris setiap 1 ms, dan kemudian memilih dan menyimpan sampel selama 100 milidetik sebelum <code>ksoftirqd</code> masuk ke jejak: <br><br> <code># record 999 times a second, or every 1ms with some offset so not to align exactly with timers <br> sudo perf record -C 11 -g -F 999 <br> # take that recording and make a simpler stack trace. <br> sudo perf script 2&gt;/dev/null | ./FlameGraph/stackcollapse-perf-ordered.pl | grep ksoftir -B 100</code> <br> <br>  Inilah hasilnya: <br><br> <code>( ,   ) <br> <br> cadvisor;[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];entry_SYSCALL_64_after_swapgs;do_syscall_64;sys_read;vfs_read;seq_read;memcg_stat_show;mem_cgroup_nr_lru_pages;mem_cgroup_node_nr_lru_pages cadvisor;[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];entry_SYSCALL_64_after_swapgs;do_syscall_64;sys_read;vfs_read;seq_read;memcg_stat_show;mem_cgroup_nr_lru_pages;mem_cgroup_node_nr_lru_pages cadvisor;[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];entry_SYSCALL_64_after_swapgs;do_syscall_64;sys_read;vfs_read;seq_read;memcg_stat_show;mem_cgroup_iter cadvisor;[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];entry_SYSCALL_64_after_swapgs;do_syscall_64;sys_read;vfs_read;seq_read;memcg_stat_show;mem_cgroup_nr_lru_pages;mem_cgroup_node_nr_lru_pages cadvisor;[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];entry_SYSCALL_64_after_swapgs;do_syscall_64;sys_read;vfs_read;seq_read;memcg_stat_show;mem_cgroup_nr_lru_pages;mem_cgroup_node_nr_lru_pages ksoftirqd/11;ret_from_fork;kthread;kthread;smpboot_thread_fn;smpboot_thread_fn;run_ksoftirqd;__do_softirq;net_rx_action;ixgbe_poll;ixgbe_clean_rx_irq;napi_gro_receive;netif_receive_skb_internal;inet_gro_receive;bond_handle_frame;__netif_receive_skb_core;ip_rcv_finish;ip_rcv;ip_forward_finish;ip_forward;ip_finish_output;nf_iterate;ip_output;ip_finish_output2;__dev_queue_xmit;dev_hard_start_xmit;ipip_tunnel_xmit;ip_tunnel_xmit;iptunnel_xmit;ip_local_out;dst_output;__ip_local_out;nf_hook_slow;nf_iterate;nf_conntrack_in;generic_packet;ipt_do_table;set_match_v4;ip_set_test;hash_net4_kadt;ixgbe_xmit_frame_ring;swiotlb_dma_mapping_error;hash_net4_test ksoftirqd/11;ret_from_fork;kthread;kthread;smpboot_thread_fn;smpboot_thread_fn;run_ksoftirqd;__do_softirq;net_rx_action;gro_cell_poll;napi_gro_receive;netif_receive_skb_internal;inet_gro_receive;__netif_receive_skb_core;ip_rcv_finish;ip_rcv;ip_forward_finish;ip_forward;ip_finish_output;nf_iterate;ip_output;ip_finish_output2;__dev_queue_xmit;dev_hard_start_xmit;dev_queue_xmit_nit;packet_rcv;tpacket_rcv;sch_direct_xmit;validate_xmit_skb_list;validate_xmit_skb;netif_skb_features;ixgbe_xmit_frame_ring;swiotlb_dma_mapping_error;__dev_queue_xmit;dev_hard_start_xmit;__bpf_prog_run;__bpf_prog_run</code> <br> <br>  Ada banyak hal di sini, tetapi yang utama adalah kita menemukan templat “cadvisor before ksoftirqd” yang kita lihat sebelumnya dalam pelacak ICMP.  Apa artinya ini? <br><br>  Setiap baris adalah jejak CPU pada titik waktu tertentu.  Setiap panggilan turun tumpukan dalam garis dipisahkan oleh tanda titik koma.  Di tengah baris kita melihat syscall disebut: <code>read(): .... ;do_syscall_64;sys_read; ...</code>  <code>read(): .... ;do_syscall_64;sys_read; ...</code>  Dengan demikian, cadvisor menghabiskan banyak waktu pada panggilan sistem <code>read()</code> , terkait dengan fungsi <code>mem_cgroup_*</code> (atas tumpukan panggilan / akhir baris). <br><br>  Dalam pelacakan panggilan, tidak nyaman untuk melihat apa yang sebenarnya sedang dibaca, jadi jalankan <code>strace</code> dan lihat apa yang dilakukan cadvisor, dan temukan panggilan sistem lebih dari 100 ms: <br><br> <code>theojulienne@kube-node-bad ~ $ sudo strace -p 10137 -T -ff 2&gt;&amp;1 | egrep '&lt;0\.[1-9]' <br> [pid 10436] &lt;... futex resumed&gt; ) = 0 &lt;0.156784&gt; <br> [pid 10432] &lt;... futex resumed&gt; ) = 0 &lt;0.258285&gt; <br> [pid 10137] &lt;... futex resumed&gt; ) = 0 &lt;0.678382&gt; <br> [pid 10384] &lt;... futex resumed&gt; ) = 0 &lt;0.762328&gt; <br> [pid 10436] &lt;... read resumed&gt; "cache 154234880\nrss 507904\nrss_h"..., 4096) = 658 &lt;0.179438&gt; <br> [pid 10384] &lt;... futex resumed&gt; ) = 0 &lt;0.104614&gt; <br> [pid 10436] &lt;... futex resumed&gt; ) = 0 &lt;0.175936&gt; <br> [pid 10436] &lt;... read resumed&gt; "cache 0\nrss 0\nrss_huge 0\nmapped_"..., 4096) = 577 &lt;0.228091&gt; <br> [pid 10427] &lt;... read resumed&gt; "cache 0\nrss 0\nrss_huge 0\nmapped_"..., 4096) = 577 &lt;0.207334&gt; <br> [pid 10411] &lt;... epoll_ctl resumed&gt; ) = 0 &lt;0.118113&gt; <br> [pid 10382] &lt;... pselect6 resumed&gt; ) = 0 (Timeout) &lt;0.117717&gt; <br> [pid 10436] &lt;... read resumed&gt; "cache 154234880\nrss 507904\nrss_h"..., 4096) = 660 &lt;0.159891&gt; <br> [pid 10417] &lt;... futex resumed&gt; ) = 0 &lt;0.917495&gt; <br> [pid 10436] &lt;... futex resumed&gt; ) = 0 &lt;0.208172&gt; <br> [pid 10417] &lt;... futex resumed&gt; ) = 0 &lt;0.190763&gt; <br> [pid 10417] &lt;... read resumed&gt; "cache 0\nrss 0\nrss_huge 0\nmapped_"..., 4096) = 576 &lt;0.154442&gt;</code> <br> <br>  Seperti yang mungkin Anda harapkan, di sini kita melihat panggilan <code>read()</code> lambat.  Dari isi operasi baca dan konteks <code>mem_cgroup</code> , dapat dilihat bahwa panggilan <code>read()</code> merujuk ke file <code>memory.stat</code> , yang menunjukkan penggunaan memori dan batasan cgroup (teknologi isolasi sumber daya Docker).  Alat cadvisor polling file ini untuk informasi penggunaan sumber daya untuk kontainer.  Mari kita periksa apakah core atau cadvisor ini melakukan sesuatu yang tidak terduga: <br><br> <code>theojulienne@kube-node-bad ~ $ time cat /sys/fs/cgroup/memory/memory.stat &gt;/dev/null <br> <br> real 0m0.153s <br> user 0m0.000s <br> sys 0m0.152s <br> theojulienne@kube-node-bad ~ $</code> <br> <br>  Sekarang kita dapat mereproduksi bug dan memahami bahwa kernel Linux menghadapi patologi. <br><br><h1>  Apa yang membuat membaca sangat lambat? </h1><br>  Pada titik ini, jauh lebih mudah untuk menemukan pesan dari pengguna lain tentang masalah serupa.  Ternyata, dalam pelacak cadvisor bug ini dilaporkan sebagai <a href="https://github.com/google/cadvisor/issues/1774">masalah penggunaan CPU yang berlebihan</a> , hanya tidak ada yang memperhatikan bahwa penundaan itu juga tercermin secara acak dalam tumpukan jaringan.  Memang, diketahui bahwa cadvisor menghabiskan lebih banyak waktu prosesor dari yang diharapkan, tetapi ini tidak terlalu penting, karena server kami memiliki banyak sumber daya prosesor, jadi kami tidak mempelajari masalah dengan cermat. <br><br>  Masalahnya adalah bahwa kelompok kontrol (cgroup) memperhitungkan penggunaan memori di dalam namespace (wadah).  Ketika semua proses dalam cgroup ini berakhir, Docker membebaskan grup kontrol memori.  Namun, "memori" bukan hanya memori proses.  Meskipun proses memori itu sendiri tidak lagi digunakan, ternyata kernel juga menetapkan konten yang di-cache, seperti dentries dan inode (direktori dan file metadata), yang di-cache dalam cgroup memori.  Dari uraian masalah: <br><br><blockquote>  cgroups zombie: grup kontrol di mana tidak ada proses dan mereka dihapus, tetapi untuk memori yang masih dialokasikan (dalam kasus saya, dari cache dentry, tetapi juga dapat dialokasikan dari cache halaman atau tmpfs). </blockquote><br>  Memeriksa oleh kernel semua halaman dalam cache ketika cgroup dibebaskan bisa sangat lambat, jadi proses malas dipilih: tunggu sampai halaman ini diminta lagi, dan bahkan ketika memori benar-benar dibutuhkan, akhirnya bersihkan cgroup.  Hingga saat ini, cgroup masih diperhitungkan saat mengumpulkan statistik. <br><br>  Dalam hal kinerja, mereka mengorbankan memori untuk kinerja: mempercepat pembersihan awal karena fakta bahwa sedikit memori cache masih ada.  Ini normal.  Ketika kernel menggunakan bagian terakhir dari memori yang di-cache, cgroup akhirnya dihapus, jadi ini tidak bisa disebut "kebocoran".  Sayangnya, implementasi spesifik <code>memory.stat</code> mesin pencari dalam versi kernel ini (4.9), dikombinasikan dengan sejumlah besar memori pada server kami, mengarah pada fakta bahwa dibutuhkan jauh lebih lama untuk mengembalikan data cache terbaru dan membersihkan zombie kelompok. <br><br>  Ternyata ada begitu banyak zombie grup pada beberapa node kami sehingga pembacaan dan latensi melebihi satu detik. <br><br>  Sebuah solusi untuk masalah cadvisor adalah dengan segera menghapus cache gigi / inode di seluruh sistem, yang segera menghilangkan latensi baca serta latensi jaringan pada host, karena menghapus cache termasuk halaman cache cgroup zombie, dan mereka juga dibebaskan.  Ini bukan solusi, tetapi mengkonfirmasi penyebab masalahnya. <br><br>  Ternyata versi kernel yang lebih baru (4.19+) meningkatkan kinerja <code>memory.stat</code> , jadi beralih ke kernel ini memperbaiki masalah.  Pada saat yang sama, kami memiliki alat untuk mendeteksi node masalah dalam kelompok Kubernetes, dengan baik menguras mereka dan me-reboot.  Kami menyisir semua cluster, menemukan node dengan penundaan yang cukup tinggi dan reboot mereka.  Ini memberi kami waktu untuk memperbarui OS di seluruh server. <br><br><h1>  Untuk meringkas </h1><br>  Karena bug ini menghentikan pemrosesan antrian NIC RX selama ratusan milidetik, maka secara bersamaan menyebabkan penundaan besar pada koneksi pendek dan penundaan di tengah koneksi, misalnya, antara kueri MySQL dan paket respons. <br><br>       ,   Kubernetes,            .    Kubernetes    . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id477390/">https://habr.com/ru/post/id477390/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id477378/index.html">Mixed Agile - Pendekatan Waterfall ketika menerapkan aplikasi bisnis (alias Agile-like)</a></li>
<li><a href="../id477382/index.html">Esports - menghasilkan keuntungan: Mercedes, megaphone, taruhan, dan branding untuk esports</a></li>
<li><a href="../id477384/index.html">Konferensi “Keamanan Informasi. Ancaman masa kini dan masa depan ”</a></li>
<li><a href="../id477386/index.html">Security Week 48: Kebocoran Data Raksasa dan Kerentanan Whatsapp</a></li>
<li><a href="../id477388/index.html">NILFS2 - sistem file antipeluru untuk / rumah</a></li>
<li><a href="../id477392/index.html">Buka mikrofon: backend. Kami mengundang pembicara</a></li>
<li><a href="../id477396/index.html">Cara mendaftar dalam suatu kursus dan ... lanjutkan ke bagian akhir</a></li>
<li><a href="../id477400/index.html">Tentang profesi manajer produk: bagaimana mencapai yang ideal?</a></li>
<li><a href="../id477402/index.html">Menyebarkan Model Keras Deep Learning sebagai Aplikasi Web Python</a></li>
<li><a href="../id477404/index.html">Masalah sering membuat dan menghapus objek di C ++</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>