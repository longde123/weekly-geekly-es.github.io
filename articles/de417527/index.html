<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì≤ üêÇ ‚ôçÔ∏è Wir entwickeln Shrimp: Wir kontrollieren parallele Anfragen, wir protokollieren √ºber spdlog und mehr ... üë©üèø‚Äçü§ù‚Äçüë©üèæ üíÜüèΩ üìΩÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Letzte Woche haben wir √ºber unser kleines Demo-Projekt Shrimp gesprochen , das deutlich zeigt, wie Sie die C ++ - Bibliotheken RESTinio und SObjectize...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir entwickeln Shrimp: Wir kontrollieren parallele Anfragen, wir protokollieren √ºber spdlog und mehr ...</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417527/"><img src="https://habrastorage.org/webt/6p/er/na/6pernaqwjoqg3picsc4pz2d1xba.jpeg"><br><br>  Letzte Woche haben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wir √ºber unser kleines Demo-Projekt Shrimp gesprochen</a> , das deutlich zeigt, wie Sie die C ++ - Bibliotheken <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RESTinio</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SObjectizer</a> unter mehr oder weniger √§hnlichen Bedingungen verwenden k√∂nnen.  Shrimp ist eine kleine C ++ 17-Anwendung, die √ºber RESTinio HTTP-Anforderungen f√ºr die Bildskalierung akzeptiert und diese Anforderungen im Multithread-Modus √ºber SObjectizer und ImageMagick ++ bereitstellt. <br><br>  Das Projekt hat sich f√ºr uns als mehr als n√ºtzlich erwiesen.  Das Sparschwein von Wishlist zur Erweiterung der Funktionalit√§t von RESTinio und SObjectizer wurde erheblich aufgef√ºllt.  Etwas, das sogar in einer sehr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aktuellen Version von RESTinio-0.4.7 enthalten ist</a> .  Deshalb haben wir uns entschlossen, nicht auf die allererste und trivialste Version von Shrimp einzugehen, sondern ein oder zwei weitere Iterationen um dieses Projekt herum durchzuf√ºhren.  Wenn sich jemand daf√ºr interessiert, was und wie wir in dieser Zeit gemacht haben, sind Sie unter cat willkommen. <br><blockquote>  Als Spoiler: Es geht darum, wie wir die parallele Verarbeitung identischer Anforderungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beseitigt haben</a> , wie wir die Protokollierung zu Shrimp mithilfe der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hervorragenden spdlog-Bibliothek</a> hinzugef√ºgt und einen Befehl zum Zur√ºcksetzen des Caches transformierter Bilder erstellt haben. </blockquote><a name="habracut"></a><h1>  v0.3: Steuerung der parallelen Verarbeitung identischer Anforderungen </h1><br>  Die allererste Version von Shrimp, die in einem fr√ºheren Artikel beschrieben wurde, enthielt eine ernsthafte Vereinfachung: Es gab keine Kontrolle dar√ºber, ob dieselbe Anfrage derzeit verarbeitet wird oder nicht. <br><br>  Stellen Sie sich vor, Shrimp erh√§lt zum ersten Mal eine Anfrage mit dem Formular "/demo.jpg?op=resize&amp;max=1024".  Es gibt noch kein solches Bild im transformierten Bildcache, daher wird die Anforderung verarbeitet.  Die Verarbeitung kann betr√§chtliche Zeit in Anspruch nehmen, beispielsweise einige hundert Millisekunden. <br><br>  Die Anforderungsverarbeitung ist noch nicht abgeschlossen, und Shrimp erh√§lt erneut dieselbe Anforderung "/demo.jpg?op=resize&amp;max=1024", jedoch von einem anderen Client.  Es gibt noch kein Transformationsergebnis im Cache, daher wird diese Anforderung ebenfalls verarbeitet. <br><br>  Weder die erste noch die zweite Anfrage wurden bereits abgeschlossen, und Shrimp kann erneut dieselbe Anfrage "/demo.jpg?op=resize&amp;max=1024" erhalten.  Und diese Anfrage wird auch bearbeitet.  Es stellt sich heraus, dass dasselbe Bild mehrmals parallel auf dieselbe Gr√∂√üe skaliert wird. <br><br>  Das ist nicht gut  Deshalb haben wir uns bei Shrimp als erstes entschieden, einen so ernsten Pfosten loszuwerden.  Wir haben dies aufgrund von zwei kniffligen Containern im transform_manager-Agenten getan.  Der erste Container ist eine Warteschlange zum Warten auf kostenlose Transformatoranforderungen.  Dies ist ein Container mit dem Namen m_pending_requests.  Der zweite Container speichert Anforderungen, die bereits verarbeitet wurden (d. H. Diesen Anforderungen wurden bestimmte Transformatoren zugewiesen).  Dies ist ein Container mit dem Namen m_inprogress_requests. <br><br>  Wenn transform_manager die n√§chste Anforderung empf√§ngt, pr√ºft es, ob das fertige Bild im Cache der transformierten Bilder vorhanden ist.  Wenn kein konvertiertes Bild vorhanden ist, werden die Container m_inprogress_requests und m_pending_requests √ºberpr√ºft.  Und wenn in keinem dieser Container eine Anforderung mit solchen Parametern vorhanden ist, wird nur dann versucht, die Anforderung in die Warteschlange m_pending_requests zu stellen.  Es sieht <a href="">so aus</a> : <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::handle_not_transformed_image( transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_request_key_t</span></span> request_key, <span class="hljs-keyword"><span class="hljs-keyword">sobj_shptr_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">resize_request_t</span></span>&gt; cmd ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> store_to = [&amp;](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.insert( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(request_key), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd) ); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_inprogress_requests.has_key( request_key ) ) { <span class="hljs-comment"><span class="hljs-comment">//    . //         . store_to( m_inprogress_requests ); } else if( m_pending_requests.has_key( request_key ) ) { //      . store_to( m_pending_requests ); } else if( m_pending_requests.unique_keys() &lt; max_pending_requests ) { //           . store_to( m_pending_requests ); //    transformer-     . try_initiate_pending_requests_processing(); } else { //  ,   . do_503_response( std::move(cmd-&gt;m_http_req) ); } }</span></span></code> </pre> <br>  Es wurde oben gesagt, dass m_inprogress_requests und m_pending_requests knifflige Container sind.  Aber was ist der Trick? <br><br>  Der Trick besteht darin, dass diese Container die Eigenschaften sowohl einer regul√§ren FIFO-Warteschlange (in der die chronologische Reihenfolge des Hinzuf√ºgens von Elementen beibehalten wird) als auch einer Multimap kombinieren, d. H.  Ein assoziativer Container, in dem mehrere Werte einem einzelnen Schl√ºssel zugeordnet werden k√∂nnen. <br><br>  Das Beibehalten der chronologischen Reihenfolge ist wichtig, da die √§ltesten Elemente in m_pending_requests regelm√§√üig √ºberpr√ºft und aus m_pending_requests die Anforderungen entfernt werden m√ºssen, f√ºr die das maximale Zeitlimit √ºberschritten wird.  Ein effektiver Zugriff auf die Elemente per Schl√ºssel ist erforderlich, um sowohl das Vorhandensein identischer Anforderungen in den Warteschlangen zu √ºberpr√ºfen als auch um sicherzustellen, dass alle doppelten Anforderungen gleichzeitig aus der Warteschlange entfernt werden k√∂nnen. <br><br>  Bei Shrimp sind wir zu diesem Zweck mit <a href="">unserem kleinen Container</a> gefahren.  Wenn Boost in Shrimp verwendet w√ºrde, k√∂nnte Boost.MultiIndex verwendet werden.  Und wahrscheinlich muss im Laufe der Zeit eine effektive Suche in m_pending_requests nach anderen Kriterien organisiert werden, dann muss Boost.MultiIndex in Shrimp aktiviert werden. <br><br><h1>  v0.4: Protokollierung mit spdlog </h1><br>  Wir haben versucht, die erste Version von Shrimp so einfach und kompakt wie m√∂glich zu gestalten.  Aus diesem Grund haben wir in der ersten Version von Shrimp keine Protokollierung verwendet.  Im Allgemeinen. <br><br>  Dies erm√∂glichte es einerseits, den Code der ersten Version kurz zu halten, der nur die notwendige Shrimp-Gesch√§ftslogik enthielt.  Andererseits macht es das Fehlen von Protokollierung schwierig, Shrimp und seinen Betrieb zu entwickeln.  Sobald wir es in die H√§nde bekommen haben, haben wir sofort eine exzellente moderne C ++ - Bibliothek f√ºr die Protokollierung - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">spdlog</a> - in Shrimp <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gezogen</a> .  Das Atmen wurde sofort einfacher, obwohl der Code einiger Methoden an Volumen zunahm. <br><br>  Der obige Code der handle_not_transformed_image () -Methode mit Protokollierung sieht beispielsweise ungef√§hr <a href="">so aus</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::handle_not_transformed_image( transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_request_key_t</span></span> request_key, <span class="hljs-keyword"><span class="hljs-keyword">sobj_shptr_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">resize_request_t</span></span>&gt; cmd ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> store_to = [&amp;](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.insert( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(request_key), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd) ); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_inprogress_requests.has_key( request_key ) ) { <span class="hljs-comment"><span class="hljs-comment">//    . m_logger-&gt;debug( "same request is already in progress; request_key={}", request_key ); //         . store_to( m_inprogress_requests ); } else if( m_pending_requests.has_key( request_key ) ) { //      . m_logger-&gt;debug( "same request is already pending; request_key={}", request_key ); store_to( m_pending_requests ); } else if( m_pending_requests.unique_keys() &lt; max_pending_requests ) { //           . m_logger-&gt;debug( "store request to pending requests queue; request_key={}", request_key ); store_to( m_pending_requests ); //    transformer-     . try_initiate_pending_requests_processing(); } else { //  ,   . m_logger-&gt;warn( "request is rejected because of overloading; " "request_key={}", request_key ); do_503_response( std::move(cmd-&gt;m_http_req) ); } }</span></span></code> </pre> <br><h2>  SPDlog-Logger konfigurieren </h2><br>  Die Anmeldung bei Shrimp erfolgt auf der Konsole (d. H. Im Standardausgabestream).  Im Prinzip k√∂nnte man einen sehr einfachen Weg gehen und in Shrimp die einzige Instanz des SPD-Loggers erstellen.  Das hei√üt,  Man k√∂nnte <a href="">stdout_color_mt</a> (oder <a href="">stdout_logger_mt</a> ) <a href="">aufrufen</a> und diesen Logger dann an alle Entit√§ten in Shrimp √ºbergeben.  Aber wir sind etwas komplizierter gegangen: Wir haben das sogenannte manuell erstellt  sink (d. h. der Kanal, in dem spdlog die generierten Nachrichten ausgibt), und f√ºr die Shrimp-Entit√§ten haben sie separate Logger erstellt, die an diese Senke angeh√§ngt sind. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     . [[nodiscard]] spdlog::sink_ptr make_logger_sink() { auto sink = std::make_shared&lt; spdlog::sinks::ansicolor_stdout_sink_mt &gt;(); return sink; } [[nodiscard]] std::shared_ptr&lt;spdlog::logger&gt; make_logger( const std::string &amp; name, spdlog::sink_ptr sink, spdlog::level::level_enum level = spdlog::level::trace ) { auto logger = std::make_shared&lt; spdlog::logger &gt;( name, std::move(sink) ); logger-&gt;set_level( level ); logger-&gt;flush_on( level ); return logger; } //        : auto manager = coop.make_agent_with_binder&lt; a_transform_manager_t &gt;( create_one_thread_disp( "manager" )-&gt;binder(), make_logger( "manager", logger_sink ) ); ... const auto worker_name = fmt::format( "worker_{}", worker ); auto transformer = coop.make_agent_with_binder&lt; a_transformer_t &gt;( create_one_thread_disp( worker_name )-&gt;binder(), make_logger( worker_name, logger_sink ), app_params.m_storage );</span></span></code> </pre><br>  Die Konfiguration von Loggern in spdlog hat einen subtilen Punkt: Standardm√§√üig ignoriert der Logger Nachrichten mit Schweregraden f√ºr Trace und Debug.  Sie erweisen sich n√§mlich als am n√ºtzlichsten beim Debuggen.  Daher aktivieren wir in make_logger standardm√§√üig die Protokollierung f√ºr alle Ebenen, einschlie√ülich Trace / Debug. <br><br>  Aufgrund der Tatsache, dass jede Entit√§t in Shrimp einen eigenen Logger mit einem eigenen Namen hat, k√∂nnen wir im Protokoll sehen, wer was tut: <br><br><img src="https://habrastorage.org/webt/1o/jh/yx/1ojhyxgywovfstlfsybe19h0lb0.png"><br><br><h2>  SObjectizer mit spdlog verfolgen </h2><br>  Protokollierungszeiten, die als Teil der Hauptgesch√§ftslogik einer SObjectizer-Anwendung ausgef√ºhrt werden, reichen nicht aus, um die Anwendung zu debuggen.  Es ist nicht klar, warum eine Aktion in einem Agenten initiiert wird, aber nicht tats√§chlich in einem anderen Agenten ausgef√ºhrt wird.  In diesem Fall hilft der in SObjectizer integrierte msg_tracing-Mechanismus sehr (wor√ºber wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in einem separaten Artikel gesprochen haben</a> ).  Unter den Standardimplementierungen von msg_tracing f√ºr SObjectizer gibt es jedoch keine, die spdlog verwendet.  Wir werden diese Implementierung f√ºr Shrimp selbst durchf√ºhren: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">spdlog_sobj_tracer_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::msg_tracing::<span class="hljs-keyword"><span class="hljs-keyword">tracer_t</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;spdlog::logger&gt; m_logger; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">spdlog_sobj_tracer_t</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;spdlog::logger&gt; logger ) : m_logger{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(logger) } {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; what )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> override </span></span>{ m_logger-&gt;trace( what ); } [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> so_5::msg_tracing::<span class="hljs-keyword"><span class="hljs-keyword">tracer_unique_ptr_t</span></span> make( spdlog::sink_ptr sink ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;<span class="hljs-keyword"><span class="hljs-keyword">spdlog_sobj_tracer_t</span></span>&gt;( make_logger( <span class="hljs-string"><span class="hljs-string">"sobjectizer"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(sink) ) ); } };</code> </pre> <br>  Hier sehen wir die Implementierung der speziellen SObjectizer-Schnittstelle tracer_t, in der die virtuelle trace () -Methode die Hauptsache ist.  Er ist es, der die Verfolgung der Interna von SObjectizer mittels spdlog durchf√ºhrt. <br><br>  Als n√§chstes wird diese Implementierung beim Starten des SObjectizer als Tracer installiert: <br><br><pre> <code class="cpp hljs">so_5::<span class="hljs-keyword"><span class="hljs-keyword">wrapped_env_t</span></span> sobj{ [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_t</span></span> &amp; env ) {...}, [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_params_t</span></span> &amp; params ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">sobj_tracing_t</span></span>::on == sobj_tracing ) params.message_delivery_tracer( <span class="hljs-keyword"><span class="hljs-keyword">spdlog_sobj_tracer_t</span></span>::make( logger_sink ) ); } };</code> </pre> <br><h2>  RESTinio-Trace durch spdlog </h2><br>  Zus√§tzlich zum Nachverfolgen, was im SObjectizer passiert, kann es manchmal sehr n√ºtzlich sein, das zu verfolgen, was im RESTinio passiert.  In der aktualisierten Version von Shrimp wird auch eine solche Ablaufverfolgung hinzugef√ºgt. <br><br>  Diese Ablaufverfolgung wird durch die Definition einer speziellen Klasse implementiert, die die Protokollierung in RESTinio durchf√ºhren kann: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">http_server_logger_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">http_server_logger_t</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;spdlog::logger&gt; logger ) : m_logger{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( logger ) } {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Builder &amp;&amp; msg_builder )</span></span></span><span class="hljs-function"> </span></span>{ log_if_enabled( spdlog::level::trace, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Builder&gt;(msg_builder) ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">info</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Builder &amp;&amp; msg_builder )</span></span></span><span class="hljs-function"> </span></span>{ log_if_enabled( spdlog::level::info, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Builder&gt;(msg_builder) ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">warn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Builder &amp;&amp; msg_builder )</span></span></span><span class="hljs-function"> </span></span>{ log_if_enabled( spdlog::level::warn, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Builder&gt;(msg_builder) ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Builder &amp;&amp; msg_builder )</span></span></span><span class="hljs-function"> </span></span>{ log_if_enabled( spdlog::level::err, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Builder&gt;(msg_builder) ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log_if_enabled</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( spdlog::level::level_enum lv, Builder &amp;&amp; msg_builder )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_logger-&gt;should_log(lv) ) { m_logger-&gt;<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>( lv, msg_builder() ); } } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;spdlog::logger&gt; m_logger; };</code> </pre> <br>  Diese Klasse wird von nichts geerbt, da der Protokollierungsmechanismus in RESTinio auf einer allgemeinen Programmierung und nicht auf dem traditionellen objektorientierten Ansatz basiert.  Auf diese Weise k√∂nnen Sie den Overhead in F√§llen, in denen keine Protokollierung erforderlich ist, vollst√§ndig <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beseitigen</a> (wir haben dieses Thema ausf√ºhrlicher behandelt, als wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºber die Verwendung von Vorlagen in RESTinio gesprochen haben</a> ). <br><br>  Als n√§chstes m√ºssen wir angeben, dass der HTTP-Server die oben gezeigte Klasse http_server_logger_t als Logger verwendet.  Dazu werden die Eigenschaften des HTTP-Servers gekl√§rt: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">http_server_traits_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">default_traits_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">logger_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">http_server_logger_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">request_handler_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">http_req_router_t</span></span>; };</code> </pre> <br>  Nun, dann bleibt nichts mehr zu tun - erstellen Sie eine bestimmte Instanz des SPD-Loggers und senden Sie diesen Logger an den erstellten HTTP-Server: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> restinio_logger = make_logger( <span class="hljs-string"><span class="hljs-string">"restinio"</span></span>, logger_sink, <span class="hljs-keyword"><span class="hljs-keyword">restinio_tracing_t</span></span>::off == restinio_tracing ? spdlog::level::off : log_level ); restinio::run( asio_io_ctx, shrimp::make_http_server_settings( thread_count.m_io_threads, params, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(restinio_logger), manager_mbox_promise.get_future().get() ) );</code> </pre> <br><h1>  v0.5: erzwungenes Zur√ºcksetzen des transformierten Bildcaches </h1><br>  Beim Debuggen von Shrimp wurde eine kleine Sache entdeckt, die etwas √§rgerlich war: Um den Inhalt des transformierten Bildcaches zu leeren, musste der gesamte Shrimp neu gestartet werden.  Es scheint eine Kleinigkeit, aber unangenehm. <br><br>  Wenn es unangenehm ist, sollten Sie dieses Manko beseitigen.  Zum Gl√ºck ist das √ºberhaupt nicht schwierig. <br><br>  Zuerst definieren wir eine andere URL in Shrimp, an die Sie HTTP DELETE-Anforderungen senden k√∂nnen: "/ cache".  Dementsprechend h√§ngen wir unseren Handler an diese URL: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">http_req_router_t</span></span> &gt; make_router( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">app_params_t</span></span> &amp; params, so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> req_handler_mbox ) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> router = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt; <span class="hljs-keyword"><span class="hljs-keyword">http_req_router_t</span></span> &gt;(); add_transform_op_handler( params, *router, req_handler_mbox ); add_delete_cache_handler( *router, req_handler_mbox ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> router; }</code> </pre> <br>  Dabei sieht die Funktion add_delete_cache_handler () folgenderma√üen aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_delete_cache_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">http_req_router_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; router, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req_handler_mbox )</span></span></span><span class="hljs-function"> </span></span>{ router.http_delete( <span class="hljs-string"><span class="hljs-string">"/cache"</span></span>, [req_handler_mbox]( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> req, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-comment"><span class="hljs-comment">/*params*/</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> qp = restinio::parse_query( req-&gt;header().query() ); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> token = qp.get_param( <span class="hljs-string"><span class="hljs-string">"token"</span></span>sv ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !token ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_403_response( req, <span class="hljs-string"><span class="hljs-string">"No token provided\r\n"</span></span> ); } <span class="hljs-comment"><span class="hljs-comment">// Delegate request processing to transform_manager. so_5::send&lt; so_5::mutable_msg&lt;a_transform_manager_t::delete_cache_request_t&gt; &gt;( req_handler_mbox, req, restinio::cast_to&lt;std::string&gt;(*token) ); return restinio::request_accepted(); } ); }</span></span></code> </pre> <br>  Ein bisschen ausf√ºhrlich, aber nichts kompliziertes.  Die Abfragezeichenfolge der Abfrage muss einen Token-Parameter haben.  Dieser Parameter muss eine Zeichenfolge mit einem speziellen Wert f√ºr das Verwaltungstoken enthalten.  Sie k√∂nnen den Cache nur zur√ºcksetzen, wenn der Token-Wert aus dem Token-Parameter mit dem Wert √ºbereinstimmt, der beim Start von Shrimp festgelegt wurde.  Wenn kein Token-Parameter vorhanden ist, wird die Verarbeitungsanforderung nicht akzeptiert.  Wenn ein Token vorhanden ist, wird dem transform_manager-Agenten, dem der Cache geh√∂rt, eine spezielle Befehlsnachricht gesendet, durch deren Ausf√ºhrung der transform_manager-Agent selbst auf die HTTP-Anforderung antwortet. <br><br>  Zweitens implementieren wir den neuen Nachrichtenhandler delete_cache_request_t im Agenten transform_manager_t: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_delete_cache_request( <span class="hljs-keyword"><span class="hljs-keyword">mutable_mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">delete_cache_request_t</span></span>&gt; cmd ) { m_logger-&gt;warn( <span class="hljs-string"><span class="hljs-string">"delete cache request received; "</span></span> <span class="hljs-string"><span class="hljs-string">"connection_id={}, token={}"</span></span>, cmd-&gt;m_http_req-&gt;connection_id(), cmd-&gt;m_token ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> delay_response = [&amp;]( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> response_text ) { so_5::send_delayed&lt; so_5::mutable_msg&lt;<span class="hljs-keyword"><span class="hljs-keyword">negative_delete_cache_response_t</span></span>&gt; &gt;( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::seconds{<span class="hljs-number"><span class="hljs-number">7</span></span>}, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd-&gt;m_http_req), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(response_text) ); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * env_token = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::getenv( <span class="hljs-string"><span class="hljs-string">"SHRIMP_ADMIN_TOKEN"</span></span> ); <span class="hljs-comment"><span class="hljs-comment">// Token must be present and must not be empty. env_token &amp;&amp; *env_token ) { if( cmd-&gt;m_token == env_token ) { m_transformed_cache.clear(); m_logger-&gt;info( "cache deleted" ); do_200_plaintext_response( std::move(cmd-&gt;m_http_req), "Cache deleted\r\n" ); } else { m_logger-&gt;error( "invalid token value for delete cache request; " "token={}", cmd-&gt;m_token ); delay_response( "Token value mismatch\r\n" ); } } else { m_logger-&gt;warn( "delete cache can't performed because there is no " "admin token defined" ); // Operation can't be performed because admin token is not avaliable. delay_response( "No admin token defined\r\n" ); } }</span></span></code> </pre> <br>  Hier gibt es zwei Punkte, die gekl√§rt werden sollten. <br><br>  Der erste Punkt bei der Implementierung von on_delete_cache_request () ist die √úberpr√ºfung des Token-Werts selbst.  Das administrative Token wird √ºber die Umgebungsvariable SHRIMP_ADMIN_TOKEN festgelegt.  Wenn diese Variable festgelegt ist und ihr Wert mit dem Wert aus dem Token-Parameter der HTTP-DELETE-Anforderung √ºbereinstimmt, wird der Cache geleert und sofort eine positive Antwort auf die Anforderung generiert. <br><br>  Und der zweite Punkt bei der Implementierung von on_delete_cache_request () ist die erzwungene Verz√∂gerung einer negativen Antwort auf HTTP DELETE.  Wenn der falsche Wert des administrativen Tokens eingetreten ist, sollten Sie die Antwort auf HTTP DELETE verz√∂gern, damit Sie den Wert des Tokens nicht mit brutaler Gewalt ausw√§hlen k√∂nnen.  Aber wie macht man diese Verz√∂gerung?  Der Aufruf von std :: thread :: sleep_for () ist schlie√ülich keine Option. <br><br>  Hier kommen die ausstehenden Nachrichten von SObjectizer zur Rettung.  Anstatt sofort eine negative Antwort in on_delete_cache_request () zu generieren, sendet sich der transform_manager-Agent einfach eine ausstehende negative_delete_cache_response_t-Nachricht.  Der SObjectizer-Timer z√§hlt die eingestellte Zeit und √ºbermittelt diese Nachricht an den Agenten, nachdem die angegebene Verz√∂gerung verstrichen ist.  Und jetzt k√∂nnen Sie im Handler negative_delete_cache_response_t bereits sofort eine Antwort auf die HTTP-DELETE-Anforderung generieren: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_negative_delete_cache_response( <span class="hljs-keyword"><span class="hljs-keyword">mutable_mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">negative_delete_cache_response_t</span></span>&gt; cmd ) { m_logger-&gt;debug( <span class="hljs-string"><span class="hljs-string">"send negative response to delete cache request; "</span></span> <span class="hljs-string"><span class="hljs-string">"connection_id={}"</span></span>, cmd-&gt;m_http_req-&gt;connection_id() ); do_403_response( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd-&gt;m_http_req), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd-&gt;m_response_text) ); }</code> </pre> <br>  Das hei√üt,  Es stellt sich das folgende Szenario heraus: <br><br><ul><li>  Der HTTP-Server empf√§ngt eine HTTP-DELETE-Anforderung und konvertiert diese Anforderung in eine delete_cache_request_t-Nachricht an den transform_manager-Agenten. </li><li>  Der transform_manager-Agent empf√§ngt die Nachricht delete_cache_request_t und generiert entweder sofort eine positive Antwort auf die Anforderung oder sendet sich selbst eine ausstehende negative_delete_cache_response_t-Nachricht. </li><li>  transform_manager empf√§ngt eine negative_delete_cache_response_t-Nachricht und generiert sofort eine negative Antwort auf die entsprechende HTTP-DELETE-Anforderung. </li></ul><br><h1>  Ende des zweiten Teils </h1><br>  Am Ende des zweiten Teils ist es ganz nat√ºrlich, die Frage zu stellen: "Was kommt als n√§chstes?" <br><br>  Au√üerdem wird es wahrscheinlich eine weitere Iteration und ein weiteres Update unseres Demo-Projekts geben.  Ich m√∂chte so etwas wie ein Bild von einem Format in ein anderes konvertieren.  Angenommen, auf dem Server befindet sich das Image in JPG und wird nach der Umwandlung in WebP an den Client gesendet. <br><br>  Es w√§re auch interessant, eine separate "Seite" mit der Anzeige der aktuellen Statistiken √ºber die Arbeit von Shrimp beizuf√ºgen.  Zuallererst ist es nur neugierig.  Grunds√§tzlich kann eine solche Seite aber auch an die Bed√ºrfnisse der √úberwachung der Lebensf√§higkeit von Shrimp angepasst werden. <br><br>  Wenn jemand anderes Vorschl√§ge dazu hat, was ich in Shrimp oder in Artikeln rund um Shrimp sehen m√∂chte, freuen wir uns √ºber konstruktive Gedanken. <br><br>  Unabh√§ngig davon m√∂chte ich einen Aspekt bei der Implementierung von Shrimp erw√§hnen, der uns etwas √ºberrascht hat.  Dies ist eine aktive Verwendung von ver√§nderlichen Nachrichten bei der Kommunikation untereinander und mit dem HTTP-Server.  In unserer Praxis geschieht normalerweise das Gegenteil: H√§ufiger werden Daten √ºber Immunnachrichten ausgetauscht.  Nicht so hier.  Dies deutet darauf hin, dass wir zu gegebener Zeit wissentlich auf die W√ºnsche der Benutzer geh√∂rt und SObjectizer ver√§nderbare Nachrichten hinzugef√ºgt haben.  Wenn Sie also etwas in RESTinio oder SObjectizer sehen m√∂chten, k√∂nnen Sie Ihre Ideen gerne teilen.  Wir werden sicher auf die Guten h√∂ren. <br><br>  Abschlie√üend m√∂chte ich mich bei allen bedanken, die sich die Zeit genommen und √ºber die erste Version von Shrimp gesprochen haben, sowohl hier auf Habr√© als auch √ºber andere Ressourcen.  Vielen Dank! <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortsetzung folgt ...</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417527/">https://habr.com/ru/post/de417527/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de417511/index.html">Intel erwirbt eASIC - Structural ASIC Developer</a></li>
<li><a href="../de417513/index.html">Analoge in Python und JavaScript. Teil zwei</a></li>
<li><a href="../de417515/index.html">Was ich durch das Erstellen von 100 Spielen in 5 Jahren gelernt habe</a></li>
<li><a href="../de417517/index.html">Seiten der Intel-Geschichte. Foto Chronik und Quiz</a></li>
<li><a href="../de417521/index.html">√úberpr√ºfen Sie die SSL-Zertifikate auf Widerruf</a></li>
<li><a href="../de417529/index.html">Drei technologische Trends, die Handel und Verbraucher ver√§ndern</a></li>
<li><a href="../de417531/index.html">Wie wir in SmartMailHack 2 gewonnen haben</a></li>
<li><a href="../de417533/index.html">Notepad unter Windows erhielt das erste bedeutende Update seit zwei Jahrzehnten</a></li>
<li><a href="../de417535/index.html">Ist die CUBA-Entwicklung einen gro√üen Schritt vom Fr√ºhling entfernt?</a></li>
<li><a href="../de417537/index.html">"Dein Spiel ist langweilig" oder wie man die ohnehin schon hohe Retention des ersten Tages erh√∂ht</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>