<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📲 🐂 ♍️ Wir entwickeln Shrimp: Wir kontrollieren parallele Anfragen, wir protokollieren über spdlog und mehr ... 👩🏿‍🤝‍👩🏾 💆🏽 📽️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Letzte Woche haben wir über unser kleines Demo-Projekt Shrimp gesprochen , das deutlich zeigt, wie Sie die C ++ - Bibliotheken RESTinio und SObjectize...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir entwickeln Shrimp: Wir kontrollieren parallele Anfragen, wir protokollieren über spdlog und mehr ...</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417527/"><img src="https://habrastorage.org/webt/6p/er/na/6pernaqwjoqg3picsc4pz2d1xba.jpeg"><br><br>  Letzte Woche haben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wir über unser kleines Demo-Projekt Shrimp gesprochen</a> , das deutlich zeigt, wie Sie die C ++ - Bibliotheken <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RESTinio</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SObjectizer</a> unter mehr oder weniger ähnlichen Bedingungen verwenden können.  Shrimp ist eine kleine C ++ 17-Anwendung, die über RESTinio HTTP-Anforderungen für die Bildskalierung akzeptiert und diese Anforderungen im Multithread-Modus über SObjectizer und ImageMagick ++ bereitstellt. <br><br>  Das Projekt hat sich für uns als mehr als nützlich erwiesen.  Das Sparschwein von Wishlist zur Erweiterung der Funktionalität von RESTinio und SObjectizer wurde erheblich aufgefüllt.  Etwas, das sogar in einer sehr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aktuellen Version von RESTinio-0.4.7 enthalten ist</a> .  Deshalb haben wir uns entschlossen, nicht auf die allererste und trivialste Version von Shrimp einzugehen, sondern ein oder zwei weitere Iterationen um dieses Projekt herum durchzuführen.  Wenn sich jemand dafür interessiert, was und wie wir in dieser Zeit gemacht haben, sind Sie unter cat willkommen. <br><blockquote>  Als Spoiler: Es geht darum, wie wir die parallele Verarbeitung identischer Anforderungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beseitigt haben</a> , wie wir die Protokollierung zu Shrimp mithilfe der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hervorragenden spdlog-Bibliothek</a> hinzugefügt und einen Befehl zum Zurücksetzen des Caches transformierter Bilder erstellt haben. </blockquote><a name="habracut"></a><h1>  v0.3: Steuerung der parallelen Verarbeitung identischer Anforderungen </h1><br>  Die allererste Version von Shrimp, die in einem früheren Artikel beschrieben wurde, enthielt eine ernsthafte Vereinfachung: Es gab keine Kontrolle darüber, ob dieselbe Anfrage derzeit verarbeitet wird oder nicht. <br><br>  Stellen Sie sich vor, Shrimp erhält zum ersten Mal eine Anfrage mit dem Formular "/demo.jpg?op=resize&amp;max=1024".  Es gibt noch kein solches Bild im transformierten Bildcache, daher wird die Anforderung verarbeitet.  Die Verarbeitung kann beträchtliche Zeit in Anspruch nehmen, beispielsweise einige hundert Millisekunden. <br><br>  Die Anforderungsverarbeitung ist noch nicht abgeschlossen, und Shrimp erhält erneut dieselbe Anforderung "/demo.jpg?op=resize&amp;max=1024", jedoch von einem anderen Client.  Es gibt noch kein Transformationsergebnis im Cache, daher wird diese Anforderung ebenfalls verarbeitet. <br><br>  Weder die erste noch die zweite Anfrage wurden bereits abgeschlossen, und Shrimp kann erneut dieselbe Anfrage "/demo.jpg?op=resize&amp;max=1024" erhalten.  Und diese Anfrage wird auch bearbeitet.  Es stellt sich heraus, dass dasselbe Bild mehrmals parallel auf dieselbe Größe skaliert wird. <br><br>  Das ist nicht gut  Deshalb haben wir uns bei Shrimp als erstes entschieden, einen so ernsten Pfosten loszuwerden.  Wir haben dies aufgrund von zwei kniffligen Containern im transform_manager-Agenten getan.  Der erste Container ist eine Warteschlange zum Warten auf kostenlose Transformatoranforderungen.  Dies ist ein Container mit dem Namen m_pending_requests.  Der zweite Container speichert Anforderungen, die bereits verarbeitet wurden (d. H. Diesen Anforderungen wurden bestimmte Transformatoren zugewiesen).  Dies ist ein Container mit dem Namen m_inprogress_requests. <br><br>  Wenn transform_manager die nächste Anforderung empfängt, prüft es, ob das fertige Bild im Cache der transformierten Bilder vorhanden ist.  Wenn kein konvertiertes Bild vorhanden ist, werden die Container m_inprogress_requests und m_pending_requests überprüft.  Und wenn in keinem dieser Container eine Anforderung mit solchen Parametern vorhanden ist, wird nur dann versucht, die Anforderung in die Warteschlange m_pending_requests zu stellen.  Es sieht <a href="">so aus</a> : <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::handle_not_transformed_image( transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_request_key_t</span></span> request_key, <span class="hljs-keyword"><span class="hljs-keyword">sobj_shptr_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">resize_request_t</span></span>&gt; cmd ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> store_to = [&amp;](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.insert( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(request_key), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd) ); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_inprogress_requests.has_key( request_key ) ) { <span class="hljs-comment"><span class="hljs-comment">//    . //         . store_to( m_inprogress_requests ); } else if( m_pending_requests.has_key( request_key ) ) { //      . store_to( m_pending_requests ); } else if( m_pending_requests.unique_keys() &lt; max_pending_requests ) { //           . store_to( m_pending_requests ); //    transformer-     . try_initiate_pending_requests_processing(); } else { //  ,   . do_503_response( std::move(cmd-&gt;m_http_req) ); } }</span></span></code> </pre> <br>  Es wurde oben gesagt, dass m_inprogress_requests und m_pending_requests knifflige Container sind.  Aber was ist der Trick? <br><br>  Der Trick besteht darin, dass diese Container die Eigenschaften sowohl einer regulären FIFO-Warteschlange (in der die chronologische Reihenfolge des Hinzufügens von Elementen beibehalten wird) als auch einer Multimap kombinieren, d. H.  Ein assoziativer Container, in dem mehrere Werte einem einzelnen Schlüssel zugeordnet werden können. <br><br>  Das Beibehalten der chronologischen Reihenfolge ist wichtig, da die ältesten Elemente in m_pending_requests regelmäßig überprüft und aus m_pending_requests die Anforderungen entfernt werden müssen, für die das maximale Zeitlimit überschritten wird.  Ein effektiver Zugriff auf die Elemente per Schlüssel ist erforderlich, um sowohl das Vorhandensein identischer Anforderungen in den Warteschlangen zu überprüfen als auch um sicherzustellen, dass alle doppelten Anforderungen gleichzeitig aus der Warteschlange entfernt werden können. <br><br>  Bei Shrimp sind wir zu diesem Zweck mit <a href="">unserem kleinen Container</a> gefahren.  Wenn Boost in Shrimp verwendet würde, könnte Boost.MultiIndex verwendet werden.  Und wahrscheinlich muss im Laufe der Zeit eine effektive Suche in m_pending_requests nach anderen Kriterien organisiert werden, dann muss Boost.MultiIndex in Shrimp aktiviert werden. <br><br><h1>  v0.4: Protokollierung mit spdlog </h1><br>  Wir haben versucht, die erste Version von Shrimp so einfach und kompakt wie möglich zu gestalten.  Aus diesem Grund haben wir in der ersten Version von Shrimp keine Protokollierung verwendet.  Im Allgemeinen. <br><br>  Dies ermöglichte es einerseits, den Code der ersten Version kurz zu halten, der nur die notwendige Shrimp-Geschäftslogik enthielt.  Andererseits macht es das Fehlen von Protokollierung schwierig, Shrimp und seinen Betrieb zu entwickeln.  Sobald wir es in die Hände bekommen haben, haben wir sofort eine exzellente moderne C ++ - Bibliothek für die Protokollierung - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">spdlog</a> - in Shrimp <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gezogen</a> .  Das Atmen wurde sofort einfacher, obwohl der Code einiger Methoden an Volumen zunahm. <br><br>  Der obige Code der handle_not_transformed_image () -Methode mit Protokollierung sieht beispielsweise ungefähr <a href="">so aus</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::handle_not_transformed_image( transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_request_key_t</span></span> request_key, <span class="hljs-keyword"><span class="hljs-keyword">sobj_shptr_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">resize_request_t</span></span>&gt; cmd ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> store_to = [&amp;](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.insert( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(request_key), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd) ); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_inprogress_requests.has_key( request_key ) ) { <span class="hljs-comment"><span class="hljs-comment">//    . m_logger-&gt;debug( "same request is already in progress; request_key={}", request_key ); //         . store_to( m_inprogress_requests ); } else if( m_pending_requests.has_key( request_key ) ) { //      . m_logger-&gt;debug( "same request is already pending; request_key={}", request_key ); store_to( m_pending_requests ); } else if( m_pending_requests.unique_keys() &lt; max_pending_requests ) { //           . m_logger-&gt;debug( "store request to pending requests queue; request_key={}", request_key ); store_to( m_pending_requests ); //    transformer-     . try_initiate_pending_requests_processing(); } else { //  ,   . m_logger-&gt;warn( "request is rejected because of overloading; " "request_key={}", request_key ); do_503_response( std::move(cmd-&gt;m_http_req) ); } }</span></span></code> </pre> <br><h2>  SPDlog-Logger konfigurieren </h2><br>  Die Anmeldung bei Shrimp erfolgt auf der Konsole (d. H. Im Standardausgabestream).  Im Prinzip könnte man einen sehr einfachen Weg gehen und in Shrimp die einzige Instanz des SPD-Loggers erstellen.  Das heißt,  Man könnte <a href="">stdout_color_mt</a> (oder <a href="">stdout_logger_mt</a> ) <a href="">aufrufen</a> und diesen Logger dann an alle Entitäten in Shrimp übergeben.  Aber wir sind etwas komplizierter gegangen: Wir haben das sogenannte manuell erstellt  sink (d. h. der Kanal, in dem spdlog die generierten Nachrichten ausgibt), und für die Shrimp-Entitäten haben sie separate Logger erstellt, die an diese Senke angehängt sind. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     . [[nodiscard]] spdlog::sink_ptr make_logger_sink() { auto sink = std::make_shared&lt; spdlog::sinks::ansicolor_stdout_sink_mt &gt;(); return sink; } [[nodiscard]] std::shared_ptr&lt;spdlog::logger&gt; make_logger( const std::string &amp; name, spdlog::sink_ptr sink, spdlog::level::level_enum level = spdlog::level::trace ) { auto logger = std::make_shared&lt; spdlog::logger &gt;( name, std::move(sink) ); logger-&gt;set_level( level ); logger-&gt;flush_on( level ); return logger; } //        : auto manager = coop.make_agent_with_binder&lt; a_transform_manager_t &gt;( create_one_thread_disp( "manager" )-&gt;binder(), make_logger( "manager", logger_sink ) ); ... const auto worker_name = fmt::format( "worker_{}", worker ); auto transformer = coop.make_agent_with_binder&lt; a_transformer_t &gt;( create_one_thread_disp( worker_name )-&gt;binder(), make_logger( worker_name, logger_sink ), app_params.m_storage );</span></span></code> </pre><br>  Die Konfiguration von Loggern in spdlog hat einen subtilen Punkt: Standardmäßig ignoriert der Logger Nachrichten mit Schweregraden für Trace und Debug.  Sie erweisen sich nämlich als am nützlichsten beim Debuggen.  Daher aktivieren wir in make_logger standardmäßig die Protokollierung für alle Ebenen, einschließlich Trace / Debug. <br><br>  Aufgrund der Tatsache, dass jede Entität in Shrimp einen eigenen Logger mit einem eigenen Namen hat, können wir im Protokoll sehen, wer was tut: <br><br><img src="https://habrastorage.org/webt/1o/jh/yx/1ojhyxgywovfstlfsybe19h0lb0.png"><br><br><h2>  SObjectizer mit spdlog verfolgen </h2><br>  Protokollierungszeiten, die als Teil der Hauptgeschäftslogik einer SObjectizer-Anwendung ausgeführt werden, reichen nicht aus, um die Anwendung zu debuggen.  Es ist nicht klar, warum eine Aktion in einem Agenten initiiert wird, aber nicht tatsächlich in einem anderen Agenten ausgeführt wird.  In diesem Fall hilft der in SObjectizer integrierte msg_tracing-Mechanismus sehr (worüber wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in einem separaten Artikel gesprochen haben</a> ).  Unter den Standardimplementierungen von msg_tracing für SObjectizer gibt es jedoch keine, die spdlog verwendet.  Wir werden diese Implementierung für Shrimp selbst durchführen: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">spdlog_sobj_tracer_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::msg_tracing::<span class="hljs-keyword"><span class="hljs-keyword">tracer_t</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;spdlog::logger&gt; m_logger; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">spdlog_sobj_tracer_t</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;spdlog::logger&gt; logger ) : m_logger{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(logger) } {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; what )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> override </span></span>{ m_logger-&gt;trace( what ); } [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> so_5::msg_tracing::<span class="hljs-keyword"><span class="hljs-keyword">tracer_unique_ptr_t</span></span> make( spdlog::sink_ptr sink ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;<span class="hljs-keyword"><span class="hljs-keyword">spdlog_sobj_tracer_t</span></span>&gt;( make_logger( <span class="hljs-string"><span class="hljs-string">"sobjectizer"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(sink) ) ); } };</code> </pre> <br>  Hier sehen wir die Implementierung der speziellen SObjectizer-Schnittstelle tracer_t, in der die virtuelle trace () -Methode die Hauptsache ist.  Er ist es, der die Verfolgung der Interna von SObjectizer mittels spdlog durchführt. <br><br>  Als nächstes wird diese Implementierung beim Starten des SObjectizer als Tracer installiert: <br><br><pre> <code class="cpp hljs">so_5::<span class="hljs-keyword"><span class="hljs-keyword">wrapped_env_t</span></span> sobj{ [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_t</span></span> &amp; env ) {...}, [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_params_t</span></span> &amp; params ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">sobj_tracing_t</span></span>::on == sobj_tracing ) params.message_delivery_tracer( <span class="hljs-keyword"><span class="hljs-keyword">spdlog_sobj_tracer_t</span></span>::make( logger_sink ) ); } };</code> </pre> <br><h2>  RESTinio-Trace durch spdlog </h2><br>  Zusätzlich zum Nachverfolgen, was im SObjectizer passiert, kann es manchmal sehr nützlich sein, das zu verfolgen, was im RESTinio passiert.  In der aktualisierten Version von Shrimp wird auch eine solche Ablaufverfolgung hinzugefügt. <br><br>  Diese Ablaufverfolgung wird durch die Definition einer speziellen Klasse implementiert, die die Protokollierung in RESTinio durchführen kann: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">http_server_logger_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">http_server_logger_t</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;spdlog::logger&gt; logger ) : m_logger{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( logger ) } {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Builder &amp;&amp; msg_builder )</span></span></span><span class="hljs-function"> </span></span>{ log_if_enabled( spdlog::level::trace, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Builder&gt;(msg_builder) ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">info</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Builder &amp;&amp; msg_builder )</span></span></span><span class="hljs-function"> </span></span>{ log_if_enabled( spdlog::level::info, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Builder&gt;(msg_builder) ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">warn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Builder &amp;&amp; msg_builder )</span></span></span><span class="hljs-function"> </span></span>{ log_if_enabled( spdlog::level::warn, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Builder&gt;(msg_builder) ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Builder &amp;&amp; msg_builder )</span></span></span><span class="hljs-function"> </span></span>{ log_if_enabled( spdlog::level::err, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Builder&gt;(msg_builder) ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log_if_enabled</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( spdlog::level::level_enum lv, Builder &amp;&amp; msg_builder )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_logger-&gt;should_log(lv) ) { m_logger-&gt;<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>( lv, msg_builder() ); } } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;spdlog::logger&gt; m_logger; };</code> </pre> <br>  Diese Klasse wird von nichts geerbt, da der Protokollierungsmechanismus in RESTinio auf einer allgemeinen Programmierung und nicht auf dem traditionellen objektorientierten Ansatz basiert.  Auf diese Weise können Sie den Overhead in Fällen, in denen keine Protokollierung erforderlich ist, vollständig <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beseitigen</a> (wir haben dieses Thema ausführlicher behandelt, als wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">über die Verwendung von Vorlagen in RESTinio gesprochen haben</a> ). <br><br>  Als nächstes müssen wir angeben, dass der HTTP-Server die oben gezeigte Klasse http_server_logger_t als Logger verwendet.  Dazu werden die Eigenschaften des HTTP-Servers geklärt: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">http_server_traits_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">default_traits_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">logger_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">http_server_logger_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">request_handler_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">http_req_router_t</span></span>; };</code> </pre> <br>  Nun, dann bleibt nichts mehr zu tun - erstellen Sie eine bestimmte Instanz des SPD-Loggers und senden Sie diesen Logger an den erstellten HTTP-Server: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> restinio_logger = make_logger( <span class="hljs-string"><span class="hljs-string">"restinio"</span></span>, logger_sink, <span class="hljs-keyword"><span class="hljs-keyword">restinio_tracing_t</span></span>::off == restinio_tracing ? spdlog::level::off : log_level ); restinio::run( asio_io_ctx, shrimp::make_http_server_settings( thread_count.m_io_threads, params, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(restinio_logger), manager_mbox_promise.get_future().get() ) );</code> </pre> <br><h1>  v0.5: erzwungenes Zurücksetzen des transformierten Bildcaches </h1><br>  Beim Debuggen von Shrimp wurde eine kleine Sache entdeckt, die etwas ärgerlich war: Um den Inhalt des transformierten Bildcaches zu leeren, musste der gesamte Shrimp neu gestartet werden.  Es scheint eine Kleinigkeit, aber unangenehm. <br><br>  Wenn es unangenehm ist, sollten Sie dieses Manko beseitigen.  Zum Glück ist das überhaupt nicht schwierig. <br><br>  Zuerst definieren wir eine andere URL in Shrimp, an die Sie HTTP DELETE-Anforderungen senden können: "/ cache".  Dementsprechend hängen wir unseren Handler an diese URL: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">http_req_router_t</span></span> &gt; make_router( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">app_params_t</span></span> &amp; params, so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> req_handler_mbox ) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> router = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt; <span class="hljs-keyword"><span class="hljs-keyword">http_req_router_t</span></span> &gt;(); add_transform_op_handler( params, *router, req_handler_mbox ); add_delete_cache_handler( *router, req_handler_mbox ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> router; }</code> </pre> <br>  Dabei sieht die Funktion add_delete_cache_handler () folgendermaßen aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_delete_cache_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">http_req_router_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; router, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req_handler_mbox )</span></span></span><span class="hljs-function"> </span></span>{ router.http_delete( <span class="hljs-string"><span class="hljs-string">"/cache"</span></span>, [req_handler_mbox]( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> req, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-comment"><span class="hljs-comment">/*params*/</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> qp = restinio::parse_query( req-&gt;header().query() ); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> token = qp.get_param( <span class="hljs-string"><span class="hljs-string">"token"</span></span>sv ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !token ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_403_response( req, <span class="hljs-string"><span class="hljs-string">"No token provided\r\n"</span></span> ); } <span class="hljs-comment"><span class="hljs-comment">// Delegate request processing to transform_manager. so_5::send&lt; so_5::mutable_msg&lt;a_transform_manager_t::delete_cache_request_t&gt; &gt;( req_handler_mbox, req, restinio::cast_to&lt;std::string&gt;(*token) ); return restinio::request_accepted(); } ); }</span></span></code> </pre> <br>  Ein bisschen ausführlich, aber nichts kompliziertes.  Die Abfragezeichenfolge der Abfrage muss einen Token-Parameter haben.  Dieser Parameter muss eine Zeichenfolge mit einem speziellen Wert für das Verwaltungstoken enthalten.  Sie können den Cache nur zurücksetzen, wenn der Token-Wert aus dem Token-Parameter mit dem Wert übereinstimmt, der beim Start von Shrimp festgelegt wurde.  Wenn kein Token-Parameter vorhanden ist, wird die Verarbeitungsanforderung nicht akzeptiert.  Wenn ein Token vorhanden ist, wird dem transform_manager-Agenten, dem der Cache gehört, eine spezielle Befehlsnachricht gesendet, durch deren Ausführung der transform_manager-Agent selbst auf die HTTP-Anforderung antwortet. <br><br>  Zweitens implementieren wir den neuen Nachrichtenhandler delete_cache_request_t im Agenten transform_manager_t: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_delete_cache_request( <span class="hljs-keyword"><span class="hljs-keyword">mutable_mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">delete_cache_request_t</span></span>&gt; cmd ) { m_logger-&gt;warn( <span class="hljs-string"><span class="hljs-string">"delete cache request received; "</span></span> <span class="hljs-string"><span class="hljs-string">"connection_id={}, token={}"</span></span>, cmd-&gt;m_http_req-&gt;connection_id(), cmd-&gt;m_token ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> delay_response = [&amp;]( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> response_text ) { so_5::send_delayed&lt; so_5::mutable_msg&lt;<span class="hljs-keyword"><span class="hljs-keyword">negative_delete_cache_response_t</span></span>&gt; &gt;( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::seconds{<span class="hljs-number"><span class="hljs-number">7</span></span>}, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd-&gt;m_http_req), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(response_text) ); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * env_token = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::getenv( <span class="hljs-string"><span class="hljs-string">"SHRIMP_ADMIN_TOKEN"</span></span> ); <span class="hljs-comment"><span class="hljs-comment">// Token must be present and must not be empty. env_token &amp;&amp; *env_token ) { if( cmd-&gt;m_token == env_token ) { m_transformed_cache.clear(); m_logger-&gt;info( "cache deleted" ); do_200_plaintext_response( std::move(cmd-&gt;m_http_req), "Cache deleted\r\n" ); } else { m_logger-&gt;error( "invalid token value for delete cache request; " "token={}", cmd-&gt;m_token ); delay_response( "Token value mismatch\r\n" ); } } else { m_logger-&gt;warn( "delete cache can't performed because there is no " "admin token defined" ); // Operation can't be performed because admin token is not avaliable. delay_response( "No admin token defined\r\n" ); } }</span></span></code> </pre> <br>  Hier gibt es zwei Punkte, die geklärt werden sollten. <br><br>  Der erste Punkt bei der Implementierung von on_delete_cache_request () ist die Überprüfung des Token-Werts selbst.  Das administrative Token wird über die Umgebungsvariable SHRIMP_ADMIN_TOKEN festgelegt.  Wenn diese Variable festgelegt ist und ihr Wert mit dem Wert aus dem Token-Parameter der HTTP-DELETE-Anforderung übereinstimmt, wird der Cache geleert und sofort eine positive Antwort auf die Anforderung generiert. <br><br>  Und der zweite Punkt bei der Implementierung von on_delete_cache_request () ist die erzwungene Verzögerung einer negativen Antwort auf HTTP DELETE.  Wenn der falsche Wert des administrativen Tokens eingetreten ist, sollten Sie die Antwort auf HTTP DELETE verzögern, damit Sie den Wert des Tokens nicht mit brutaler Gewalt auswählen können.  Aber wie macht man diese Verzögerung?  Der Aufruf von std :: thread :: sleep_for () ist schließlich keine Option. <br><br>  Hier kommen die ausstehenden Nachrichten von SObjectizer zur Rettung.  Anstatt sofort eine negative Antwort in on_delete_cache_request () zu generieren, sendet sich der transform_manager-Agent einfach eine ausstehende negative_delete_cache_response_t-Nachricht.  Der SObjectizer-Timer zählt die eingestellte Zeit und übermittelt diese Nachricht an den Agenten, nachdem die angegebene Verzögerung verstrichen ist.  Und jetzt können Sie im Handler negative_delete_cache_response_t bereits sofort eine Antwort auf die HTTP-DELETE-Anforderung generieren: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_negative_delete_cache_response( <span class="hljs-keyword"><span class="hljs-keyword">mutable_mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">negative_delete_cache_response_t</span></span>&gt; cmd ) { m_logger-&gt;debug( <span class="hljs-string"><span class="hljs-string">"send negative response to delete cache request; "</span></span> <span class="hljs-string"><span class="hljs-string">"connection_id={}"</span></span>, cmd-&gt;m_http_req-&gt;connection_id() ); do_403_response( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd-&gt;m_http_req), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd-&gt;m_response_text) ); }</code> </pre> <br>  Das heißt,  Es stellt sich das folgende Szenario heraus: <br><br><ul><li>  Der HTTP-Server empfängt eine HTTP-DELETE-Anforderung und konvertiert diese Anforderung in eine delete_cache_request_t-Nachricht an den transform_manager-Agenten. </li><li>  Der transform_manager-Agent empfängt die Nachricht delete_cache_request_t und generiert entweder sofort eine positive Antwort auf die Anforderung oder sendet sich selbst eine ausstehende negative_delete_cache_response_t-Nachricht. </li><li>  transform_manager empfängt eine negative_delete_cache_response_t-Nachricht und generiert sofort eine negative Antwort auf die entsprechende HTTP-DELETE-Anforderung. </li></ul><br><h1>  Ende des zweiten Teils </h1><br>  Am Ende des zweiten Teils ist es ganz natürlich, die Frage zu stellen: "Was kommt als nächstes?" <br><br>  Außerdem wird es wahrscheinlich eine weitere Iteration und ein weiteres Update unseres Demo-Projekts geben.  Ich möchte so etwas wie ein Bild von einem Format in ein anderes konvertieren.  Angenommen, auf dem Server befindet sich das Image in JPG und wird nach der Umwandlung in WebP an den Client gesendet. <br><br>  Es wäre auch interessant, eine separate "Seite" mit der Anzeige der aktuellen Statistiken über die Arbeit von Shrimp beizufügen.  Zuallererst ist es nur neugierig.  Grundsätzlich kann eine solche Seite aber auch an die Bedürfnisse der Überwachung der Lebensfähigkeit von Shrimp angepasst werden. <br><br>  Wenn jemand anderes Vorschläge dazu hat, was ich in Shrimp oder in Artikeln rund um Shrimp sehen möchte, freuen wir uns über konstruktive Gedanken. <br><br>  Unabhängig davon möchte ich einen Aspekt bei der Implementierung von Shrimp erwähnen, der uns etwas überrascht hat.  Dies ist eine aktive Verwendung von veränderlichen Nachrichten bei der Kommunikation untereinander und mit dem HTTP-Server.  In unserer Praxis geschieht normalerweise das Gegenteil: Häufiger werden Daten über Immunnachrichten ausgetauscht.  Nicht so hier.  Dies deutet darauf hin, dass wir zu gegebener Zeit wissentlich auf die Wünsche der Benutzer gehört und SObjectizer veränderbare Nachrichten hinzugefügt haben.  Wenn Sie also etwas in RESTinio oder SObjectizer sehen möchten, können Sie Ihre Ideen gerne teilen.  Wir werden sicher auf die Guten hören. <br><br>  Abschließend möchte ich mich bei allen bedanken, die sich die Zeit genommen und über die erste Version von Shrimp gesprochen haben, sowohl hier auf Habré als auch über andere Ressourcen.  Vielen Dank! <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortsetzung folgt ...</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417527/">https://habr.com/ru/post/de417527/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de417511/index.html">Intel erwirbt eASIC - Structural ASIC Developer</a></li>
<li><a href="../de417513/index.html">Analoge in Python und JavaScript. Teil zwei</a></li>
<li><a href="../de417515/index.html">Was ich durch das Erstellen von 100 Spielen in 5 Jahren gelernt habe</a></li>
<li><a href="../de417517/index.html">Seiten der Intel-Geschichte. Foto Chronik und Quiz</a></li>
<li><a href="../de417521/index.html">Überprüfen Sie die SSL-Zertifikate auf Widerruf</a></li>
<li><a href="../de417529/index.html">Drei technologische Trends, die Handel und Verbraucher verändern</a></li>
<li><a href="../de417531/index.html">Wie wir in SmartMailHack 2 gewonnen haben</a></li>
<li><a href="../de417533/index.html">Notepad unter Windows erhielt das erste bedeutende Update seit zwei Jahrzehnten</a></li>
<li><a href="../de417535/index.html">Ist die CUBA-Entwicklung einen großen Schritt vom Frühling entfernt?</a></li>
<li><a href="../de417537/index.html">"Dein Spiel ist langweilig" oder wie man die ohnehin schon hohe Retention des ersten Tages erhöht</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>