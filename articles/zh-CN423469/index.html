<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☑️ 😉 🔤 最快的狂野西部浮点数 👨🏼‍⚕️ 👨🏻‍💻 ☢️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在实现一个“阅读器”的过程中，随着计算精度的提高出现了一个问题。 该计算算法可以在标准浮点数上快速运行，但是当连接了用于精确计算的库时，一切开始急剧减速。 在本文中，我们将考虑使用多分量方法扩展浮点数的算法，由于浮点算法是在cp芯片上实现的，因此有可能实现加速。 这种方法对于更精确地计算数值导数，矩...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>最快的狂野西部浮点数</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423469/">在实现一个“阅读器”的过程中，随着计算精度的提高出现了一个问题。 该计算算法可以在标准浮点数上快速运行，但是当连接了用于精确计算的库时，一切开始急剧减速。 在本文中，我们将考虑使用多分量方法扩展浮点数的算法，由于浮点算法是在cp芯片上实现的，因此有可能实现加速。 这种方法对于更精确地计算数值导数，矩阵求逆，多边形修整或其他几何问题很有用。 因此，可以在不支持它们的视频卡上模拟64位浮点数。 <br><br><img src="https://habrastorage.org/webt/54/1e/jo/541ejotttsu8hl3swtihly-liro.png" alt="double.js基准"><br><br><a name="habracut"></a><br><br><h3> 引言 </h3><br> 由于Nikluas Wirth遗赠给我们以保持数字0和1，因此我们将它们存储在其中。 难道人类生活在十进制中，看似普通的数字0.1和0.3在二进制系统中不能用有限的分数表示吗？ 对它们进行计算时，会遇到文化冲击。 当然， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">正在</a>尝试为基于十进制的处理器创建库， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">IEEE</a>甚至采用了标准化格式。 <br><br> 但是现在，我们在所有地方都考虑了二进制存储，并使用库进行所有金钱计算以进行精确计算，例如bignumber，这会导致性能损失。 营销人员说，Asik会考虑使用加密，而在处理器中，这种十进制算术运算空间很小。 因此，当数字以未变换的数字总和的形式存储时，多分量方法是一种方便的技巧，并且在理论信息学领域是一个积极发展的领域。 尽管Decker仍然学会了正确地进行乘法运算而又不失准确性，但在1971年，现成的库（MPFR，QD）出现的时间要晚得多，并且不是所有语言都出现了，显然是因为并非所有的IEEE标准都支持它，但是更严格的证明了计算错误，例如在2017年推出双字运算。 <br><br><h3> 双字算术 </h3><br> 有什么意义？ 在有胡子的时期，没有浮点数的标准，为了避免舍入的问题，Møller提出了建议，而Knuth后来证明了无差值求和。 以这种方式运行 <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quickTwoSum</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s = a + b; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> z = s - a; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> e = b - z; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [s, e]; }</code> </pre> <br> 在此算法中，假设 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mi>a</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mo>&amp;gt;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mi>b</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.913ex" height="2.66ex" viewBox="0 -832 3407.1 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhhu06AfJMDT9Kvzd_mQsTSs1qE2Dg#MJMAIN-7C" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhhu06AfJMDT9Kvzd_mQsTSs1qE2Dg#MJMATHI-61" x="278" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhhu06AfJMDT9Kvzd_mQsTSs1qE2Dg#MJMAIN-7C" x="808" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhhu06AfJMDT9Kvzd_mQsTSs1qE2Dg#MJMAIN-3E" x="1364" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhhu06AfJMDT9Kvzd_mQsTSs1qE2Dg#MJMAIN-7C" x="2420" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhhu06AfJMDT9Kvzd_mQsTSs1qE2Dg#MJMATHI-62" x="2699" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhhu06AfJMDT9Kvzd_mQsTSs1qE2Dg#MJMAIN-7C" x="3128" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mi>a</mi><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mo>&gt;</mo><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mi>b</mi><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow></math></span></span><script type="math/tex" id="MathJax-Element-1"> | a | > | b | </script>  ，则它们的确切总和可以表示为两个数字的总和 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>s</mi><mo>+</mo><mi>e</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.014ex" height="1.937ex" viewBox="0 -676.4 2158.9 834" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhhu06AfJMDT9Kvzd_mQsTSs1qE2Dg#MJMATHI-73" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhhu06AfJMDT9Kvzd_mQsTSs1qE2Dg#MJMAIN-2B" x="691" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhhu06AfJMDT9Kvzd_mQsTSs1qE2Dg#MJMATHI-65" x="1692" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>s</mi><mo>+</mo><mi>e</mi></math></span></span><script type="math/tex" id="MathJax-Element-2"> s + e </script> 您可以成对存储它们以进行后续计算，并且减法被减为负数。 <br><br><img src="https://habrastorage.org/webt/6o/5b/h3/6o5bh3at9xelrvk2yslo4qk0jl0.png" alt="四舍五入与银行"><br><br> 后来，Dekker表明，如果使用的浮点数舍入到最接近的偶数（四舍五入到偶数，这通常是正确的过程，在长时间的计算和IEEE标准中不会导致大的误差），然后有一个无错误的乘法算法。 <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">twoMult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> A = split(a); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> B = split(b); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> r1 = a * b; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> t1 = -r1 + A[<span class="hljs-number"><span class="hljs-number">0</span></span>] * B[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> t2 = t1 + A[<span class="hljs-number"><span class="hljs-number">0</span></span>] * B[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> t3 = t2 + A[<span class="hljs-number"><span class="hljs-number">1</span></span>] * B[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [r1, t3 + A[<span class="hljs-number"><span class="hljs-number">1</span></span>] * B[<span class="hljs-number"><span class="hljs-number">1</span></span>]]; }</code> </pre><br> 其中split（）是Weltkamp先生分割数字的算法 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> splitter = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.pow(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">27</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">split</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> t = splitter * a; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> d = a - t; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> xh = t + d; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> xl = a - xh; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [xh, xl]; }</code> </pre><br> 使用常量 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi><mo>=</mo><msup><mn>2</mn><mi>s</mi></msup><mo>+</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="11.033ex" height="2.178ex" viewBox="0 -780.1 4750.5 937.7" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhhu06AfJMDT9Kvzd_mQsTSs1qE2Dg#MJMATHI-43" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhhu06AfJMDT9Kvzd_mQsTSs1qE2Dg#MJMAIN-3D" x="1038" y="0"></use><g transform="translate(2094,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhhu06AfJMDT9Kvzd_mQsTSs1qE2Dg#MJMAIN-32" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhhu06AfJMDT9Kvzd_mQsTSs1qE2Dg#MJMATHI-73" x="707" y="557"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhhu06AfJMDT9Kvzd_mQsTSs1qE2Dg#MJMAIN-2B" x="3249" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhhu06AfJMDT9Kvzd_mQsTSs1qE2Dg#MJMAIN-31" x="4249" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>C</mi><mo>=</mo><msup><mn>2</mn><mi>s</mi></msup><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-3"> C = 2 ^ s + 1 </script> 它等于尾数长度的一半多一点，这不会在乘法过程中导致数字溢出，而是将尾数分为两半。 例如，对于64位的字长，尾数的长度为53，则s = 27。 <br><br><img src="https://habrastorage.org/webt/ut/k-/rl/utk-rlv912w0uw44uvm4cce4uts.gif" alt="双浮子"><br><br> 这样，Dekker提供了双字算术计算所需的几乎完整的集合。 从那里开始，还指出了如何对两个双字数字进行乘，除和平方运算。 <br><br> 他的用于对两个双字求和的quickTwoSum算法到处都是“内联”，并且使用了校验 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mi>a</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mo>&amp;gt;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mi>b</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.913ex" height="2.66ex" viewBox="0 -832 3407.1 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhhu06AfJMDT9Kvzd_mQsTSs1qE2Dg#MJMAIN-7C" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhhu06AfJMDT9Kvzd_mQsTSs1qE2Dg#MJMATHI-61" x="278" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhhu06AfJMDT9Kvzd_mQsTSs1qE2Dg#MJMAIN-7C" x="808" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhhu06AfJMDT9Kvzd_mQsTSs1qE2Dg#MJMAIN-3E" x="1364" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhhu06AfJMDT9Kvzd_mQsTSs1qE2Dg#MJMAIN-7C" x="2420" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhhu06AfJMDT9Kvzd_mQsTSs1qE2Dg#MJMATHI-62" x="2699" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhhu06AfJMDT9Kvzd_mQsTSs1qE2Dg#MJMAIN-7C" x="3128" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mi>a</mi><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mo>&gt;</mo><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mi>b</mi><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow></math></span></span><script type="math/tex" id="MathJax-Element-4"> | a | > | b | </script>  。 如[4]中所述，在现代处理器上，使用带数字的附加操作比分支算法便宜。 因此，以下算法现在更适合于将两个单字数字相加 <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">twoSum</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s = a + b; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a1 = s - b; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b1 = s - a1; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> da = a - a1; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> db = b - b1; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [s, da + db]; }</code> </pre><br> 这就是双字数字的总和与乘法。 <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add22</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">X, Y</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> S = twoSum(X[<span class="hljs-number"><span class="hljs-number">0</span></span>], Y[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> E = twoSum(X[<span class="hljs-number"><span class="hljs-number">1</span></span>], Y[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = S[<span class="hljs-number"><span class="hljs-number">1</span></span>] + E[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> V = quickTwoSum(S[<span class="hljs-number"><span class="hljs-number">0</span></span>], c); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> w = V[<span class="hljs-number"><span class="hljs-number">1</span></span>] + E[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> quickTwoSum(V[<span class="hljs-number"><span class="hljs-number">0</span></span>], w); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul22</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">X, Y</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> S = twoMult(X[<span class="hljs-number"><span class="hljs-number">0</span></span>], Y[<span class="hljs-number"><span class="hljs-number">0</span></span>]); S[<span class="hljs-number"><span class="hljs-number">1</span></span>] += X[<span class="hljs-number"><span class="hljs-number">0</span></span>] * Y[<span class="hljs-number"><span class="hljs-number">1</span></span>] + X[<span class="hljs-number"><span class="hljs-number">1</span></span>] * Y[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> quickTwoSum(S[<span class="hljs-number"><span class="hljs-number">0</span></span>], S[<span class="hljs-number"><span class="hljs-number">1</span></span>]); }</code> </pre><br> 一般来说，有关双字算术，理论错误边界和实际实现的算法的最完整，最准确的列表在2017年的链接[3]中进行了描述。 因此，如果有兴趣，我强烈建议您直接去那里。 通常，在[6]中给出了四字算法，在[5]中给出了任意长度的多分量扩展算法。 仅在那里，在每次操作之后，都使用了重归一化过程，这对于小尺寸而言并不总是最佳的，并且没有严格定义QD中的计算精度。 通常，值得考虑的是这些方法的适用性限制。 <br><br><h3> 恐怖故事javascript-a。  decimal.js与bignumber.js与big.js的比较。 </h3><br> 碰巧，几乎所有用于js中精确计算的库都是由一个人编写的。 尽管他们几乎都是一样的，但是却产生了选择的幻觉。 此外，文档没有明确指出如果您在每次乘法/除法运算后不对数字进行四舍五入，那么数字的大小将一直加倍，并且算法的复杂性在x3500中会变得很容易。 例如，如果没有四舍五入，则它们的计算时间比较可能看起来像这样。 <br><br><img src="https://habrastorage.org/webt/lj/6r/pk/lj6rpkl_lenvq7vabfyqqhdwh8y.png"><br><br> 也就是说，您将精度设置为32位小数，然后...糟糕，您已经有64位数字，128位。我们认为非常准确！  256，512 ...但是我设置了32！.. 1024，2048 ...这样的开销出现了3500次。 该文档指出，如果您具有科学的计算能力，那么decimal.js可能更适合您。 尽管实际上，如果您只是定期取舍，那么对于科学计算，Bignumber.js的运行速度要快一些（见图1）。 如果不能找零，谁需要计算一分钱的百分之一呢？ 在任何情况下，当我需要存储更多指示的数字并且无法再输入一些额外的字符时，该怎么办？ 当没人知道泰勒级数对任意数的收敛的严格精度时，如何得出这样一个庞然大数的正弦？ 通常，没有毫无根据的怀疑，例如可以使用Schoenhage-Strassen乘法算法并使用Cordic计算来找到正弦值，从而提高计算速度。 <br><br><h3>  Double.js </h3><br>  <s>我想说，当然，Double.js可以快速准确地计数。</s>  <s>但这并非完全正确，也就是说，它认为的速度要快10倍，但并不总是准确的。</s>  <s>例如，它可以处理0.3-0.1，并转为双重存储，反之亦然。</s>  <s>但是Pi编号可以将近32位数字的双精度进行解析，并且无法解决。</s>  <s>16号产生一个错误，好像正在发生溢出一样。</s>  <s>总的来说，由于我被困住了，我敦促js社区一起努力解决解析问题。</s>  <s>我尝试以数字方式解析并以双精度除法，如在QD中一样，以16位数字为单位分割并以双精度除法，使用Julia.lib之一中的Big.js分割尾数。</s>  <s>现在，我犯了一个.parseFloat（）错误，因为即使使用ECMAScript 1，也支持四舍五入到最接近整数的IEEE标准。尽管您当然可以尝试绑定二进制缓冲区并观察每个0和1。通常，如果可以解决此问题，则然后，可以使用bignumber.js中的x10-x20加速度以任意精度进行计算。</s>  <s>但是，许多Mandelbrot已经可以渲染质量，您可以将其用于几何任务。</s> <br><br> 一年后，我回到这里，仍然解决了解析问题。 问题仅在于准确度不足（乘以10 ^（-n））。 所有算法都从头进行了修改，现在以惊人的准确性和速度运行。 <br><br><img src="https://habrastorage.org/webt/ax/gx/mb/axgxmb_wfffxczzejqaxa9mqdpy.png" alt="double.js vs数字"><br><br> 这是<a href="">lib</a>的链接，有一个交互式基准测试和一个沙箱，您可以在其中使用它。 <br><br><h3> 使用的来源 </h3><br><ol><li>  O.Møller。  <i>浮点运算中的拟双精度。</i>  ，1965年。 </li><li> 西奥多罗斯·德克（Theodorus Dekker）。  <i>一种用于扩展可用精度的浮点技术</i> ，1971年。[ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">查看器</a> ] </li><li>  Mioara Joldes，Jean-Michel Muller和Valentina Popescu。  <i>双字运算的基本构建块的严格严谨的误差范围</i> ，2017年。[ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PDF</a> ] </li><li> 穆勒，J.-M。  Brisebarre，N。de Dinechin等 浮点算法手册，第14章，2010年。 </li><li> 乔纳森·舒丘克（Jonathan Shewchuk）。  <i>鲁棒的自适应浮点几何谓词</i> ，1964年。[ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PDF</a> ] </li><li> 飞ida阳三，李小野，大卫·贝利。  <i>Double-Double和Quad-Double算法的库</i> ，2000年。[ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PDF</a> ] </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN423469/">https://habr.com/ru/post/zh-CN423469/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN423459/index.html">通过转换者的眼睛凤凰和Rails之间的差异</a></li>
<li><a href="../zh-CN423461/index.html">亚轨道秋天</a></li>
<li><a href="../zh-CN423463/index.html">当我们编写另一种RFM分析算法时</a></li>
<li><a href="../zh-CN423465/index.html">关于ITSM的读物：书籍，博客和最新文章</a></li>
<li><a href="../zh-CN423467/index.html">俄罗斯开发商将发布产品兼容性目录</a></li>
<li><a href="../zh-CN423475/index.html">破解老化代码：有关老化及其保持年轻状态的新科学</a></li>
<li><a href="../zh-CN423477/index.html">成为安全忍者：迈入IB的高峰</a></li>
<li><a href="../zh-CN423479/index.html">“第一”：是否飞往火星</a></li>
<li><a href="../zh-CN423481/index.html">我需要提升Kubernetes集群，但是我只是一个代码程序员。 有出路</a></li>
<li><a href="../zh-CN423483/index.html">找到使用Webpack分隔网站内容的正确方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>