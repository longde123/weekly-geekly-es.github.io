<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✊🏽 👨🏾‍🤝‍👨🏽 🤞🏼 GraphQL有什么问题 🧜🏽 💷 👨‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="最近，GraphQL越来越受欢迎。 请求，类型和订阅的优美语法。 


 似乎： “在这里-我们已经找到了进行数据交换的理想语言！” ... 


 我使用这种语言的开发已经有一年多了，我会告诉你：一切都不那么顺利。 GraphQL在语言设计本身中既有令人不适的时刻，又有真正的根本问题。 


 另...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>GraphQL有什么问题</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425041/"><p> 最近，GraphQL越来越受欢迎。 请求，类型和订阅的优美语法。 </p><br><p> 似乎： <em>“在这里-我们已经找到了进行数据交换的理想语言！”</em>  ... </p><br><p> 我使用这种语言的开发已经有一年多了，我会告诉你：一切都不那么顺利。  GraphQL在语言设计本身中既有令人不适的时刻，又有真正的根本问题。 </p><br><p> 另一方面，大多数“设计动作”是出于某种原因-这是出于各种考虑。 实际上，GraphQL并非适合所有人，并且可能根本不是您所需要的工具。 但是首先是第一件事。 </p><a name="habracut"></a><br><blockquote>我认为有必要对我在哪里使用这种语言做一番评论。 这是一个相当复杂的SPA管理面板，其中大多数操作都是相当重要的CRUD（复杂实体）。 该材料中的很大一部分论点与应用程序的性质和已处理数据的性质有关。 在不同类型（或数据性质不同）的应用程序中，原则上不会出现此类问题。 </blockquote><br><h2 id="1-non_null">  1. NON_NULL </h2><br><p> 这不是一个严重的问题。 而是，这与GraphQL中可空工作的组织方式有关，带来了一系列不便。 </p><br><p>有功能的（不仅是）编程语言，这种范例是monads。 因此，可能存在<code>Maybe</code> （Haskel）单价或<code>Option</code> （Scala）单价货币，最重要的是该单价货币中包含的值可能存在或可能不存在（即为null）。 好吧，或者可以像Rust一样通过枚举来实现。 </p><br><p> 一种或另一种方法，在大多数语言中，此值“包装”原始值，使null成为主要方法的附加选项。 从句法上讲-它始终是主要类型的补充。 这并不总是仅仅是一个单独的类型类-在某些语言中，它仅仅是后缀或前缀形式的加法<code>?</code>  。 </p><br><p> 在GraqhQL中，情况恰恰相反。 默认情况下，所有类型都是可为空的-相反，这不仅仅是将类型标记为可为空，而是<code>Maybe</code> monad。 </p><br><p> 如果我们考虑这种方案的<code>name</code>字段的自省部分： </p><br><pre> <code class="nginx hljs"><span class="hljs-comment"><span class="hljs-comment">#       schema -  ,    schema { query: Query } type Query { #       NonNull name: String! }</span></span></code> </pre> <br><p> 我们发现： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/15f/0ff/4ad/15f0ff4adfc31acf387165ad4adf7b5e.png" alt="图片"></p><br><p> 封装在<code>NON_NULL</code> <code>String</code>类型 </p><br><h3 id="11-output">  1.1。 输出值 </h3><br><p> 为什么这样 简而言之，它与默认的“容忍”语言设计有关（除其他外，它对微服务体系结构很友好）。 </p><br><p> 要了解这种“公差”的本质，请考虑一个稍微复杂的示例，其中所有返回值都严格包装在NON_NULL中： </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">type</span></span> User { name: String! <span class="hljs-comment"><span class="hljs-comment">#  :       . friends: [User!]! } type Query { #  :       . users(ids: [ID!]!): [User!]! }</span></span></code> </pre> <br><p> 假设我们有一个返回用户列表的服务，还有一个单独的微服务“友谊”，它为我们返回了用户朋友的匹配项。 然后，如果“友谊”服务失败，我们将根本无法列出用户。 需要解决的情况： </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">type</span></span> User { name: String! <span class="hljs-comment"><span class="hljs-comment">#    -  null   . #    ""  -      ,    . friends: [User!] }</span></span></code> </pre> <br><p> 这是对内部错误的容忍度。 一个例子，当然是牵强的。 但我希望您掌握了本质。 </p><br><p> 此外，在其他情况下，您可以使生活更轻松。 假设有远程用户，并且朋友的标识符可以存储在一些外部无关的结构中。 我们可以清除杂草，只返回所拥有的，但是那样我们将无法理解确切清除了什么杂草。 </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">type</span></span> Query { <span class="hljs-comment"><span class="hljs-comment">#  null   . #                . users(ids: [ID!]!): [User]! }</span></span></code> </pre> <br><p>  <em>一切都很好。</em>  <em>有什么问题吗？</em> <br> 一般来说，不是一个很大的问题-味道。 但是，如果您具有带有关系数据库的整体应用程序，那么最有可能的错误实际上就是错误，并且api应该尽可能严格。 您好，感叹号！ 只要有可能。 </p><br><p> 我希望能够“反转”此行为，并放置问号而不是感叹号。以某种方式会更熟悉。 </p><br><h3 id="12-input">  1.2。 输入 </h3><br><p> 但是进入时，可为空是一个完全不同的故事。 这是HTML中复选框级别的标记（我认为每个人都记得当未选中复选框的字段根本不发送到背面时，这种非显而易见性）。 </p><br><p> 考虑一个例子： </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">type</span></span> Post { id: ID! title: String! <span class="hljs-comment"><span class="hljs-comment">#  :     null description: String content: String! } input PostInput { title: String! #  :     ,   description: String content: String! } type Mutation { createPost(post: PostInput!): Post! }</span></span></code> </pre> <br><p> 到目前为止，一切都很好。 添加更新： </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">type</span></span> Mutation { createPost(post: PostInput!): Post! updatePost(id: ID!, post: PostInput!): Post! }</code> </pre> <br><p> 现在的问题是：更新帖子时，我们可以从描述字段中得到什么？ 该字段可以为空，也可以完全不存在。 </p><br><p> 如果缺少该字段，那么需要做什么？ 不更新吗？ 或将其设置为null？ 最重要的是，允许空值和允许不存在字段是两件事。 但是，GraphQL是同一回事。 </p><br><h2 id="2-razdelenie-vvoda-i-vyvoda">  2.输入和输出分离 </h2><br><p> 这只是痛苦。 在CRUD工作模型中，您从后面“扭曲”了对象，然后将其发送回去。 粗略地说，这是一个相同的对象。 但是您只需要描述两次-输入和输出。 除了编写用于此业务的代码生成器之外，此操作无济于事。 我宁愿将对象本身而不是对象本身分成“输入和输出”。 例如，修饰符： </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">type</span></span> Post { <span class="hljs-attribute"><span class="hljs-attribute">input</span></span> output text: String! output updatedAt(format: DateFormat = W3C): Date! }</code> </pre> <br><p> 或使用指令： </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">type</span></span> Post { text: String! @<span class="hljs-attribute"><span class="hljs-attribute">input</span></span> <span class="hljs-variable"><span class="hljs-variable">@output</span></span> updatedAt(format: DateFormat = W3C): Date! <span class="hljs-variable"><span class="hljs-variable">@output</span></span> }</code> </pre> <br><h2 id="3-polimorfizm">  3.多态性 </h2><br><p> 将类型分为输入和输出的问题不限于双重描述。 同时，对于泛型类型，您可以定义泛型接口： </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">interface</span></span> Commentable { comments: [Comment!]! } <span class="hljs-attribute"><span class="hljs-attribute">type</span></span> Post implements Commentable { text: String! comments: [Comment!]! } <span class="hljs-attribute"><span class="hljs-attribute">type</span></span> Photo implements Commentable { src: URL! comments: [Comment!]! }</code> </pre> <br><p> 或工会 </p><br><pre> <code class="plaintext hljs">type Person { firstName: String, lastName: String, } type Organiation { title: String } union Subject = Organiation | Person type Account { login: String subject: Subject }</code> </pre> <br><p> 您不能对输入类型执行相同的操作。 这样做有许多先决条件，但这部分是由于使用json作为传输的数据格式这一事实。 但是，在输出中， <code>__typename</code>字段用于指定类型。 为什么在进入时不可能做同样的事情-尚不清楚。 在我看来，通过在传输过程中放弃json并输入其自己的格式，可以更优雅地解决此问题。 精神上的东西： </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">union</span></span> Subject = OrganiationInput | PersonInput input AccountInput { login: String! password: String! subject: Subject! }</code> </pre> <br><pre> <code class="nginx hljs"><span class="hljs-comment"><span class="hljs-comment">#     { account: AccountInput { login: "Acme", password: "***", subject: OrganiationInput { title: "Acme Inc" } } }</span></span></code> </pre> <br><pre> <code class="nginx hljs"><span class="hljs-comment"><span class="hljs-comment">#      { account: AccountInput { login: "Acme", password: "***", subject: PersonInput { firstName: "Vasya", lastName: "Pupkin", } } }</span></span></code> </pre> <br><p> 但这将有必要为此业务编写其他解析器。 </p><br><h2 id="4-dzheneriki">  4.泛型 </h2><br><p> 具有泛型的GraphQL有什么问题？ 一切都很简单-事实并非如此。 让我们来看一个带有分页或光标的典型CRUD索引查询，这并不重要。 我将以分页为例。 </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">input</span></span> Pagination { page: UInt, perPage: UInt, } <span class="hljs-attribute"><span class="hljs-attribute">type</span></span> Query { users(pagination: Pagination): PageOfUsers! } <span class="hljs-attribute"><span class="hljs-attribute">type</span></span> PageOfUsers { total: <span class="hljs-attribute"><span class="hljs-attribute">UInt</span></span> items: [User!]! }</code> </pre> <br><p> 现在是组织 </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">type</span></span> Query { organizations(pagination: Pagination): PageOfOrganizations! } <span class="hljs-attribute"><span class="hljs-attribute">type</span></span> PageOfOrganizations { total: <span class="hljs-attribute"><span class="hljs-attribute">UInt</span></span> items: [Organization!]! }</code> </pre> <br><p> 等等...我想如何为此使用泛型 </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">type</span></span> PageOf&lt;T&gt; { total: <span class="hljs-attribute"><span class="hljs-attribute">UInt</span></span> items: [T!]! }</code> </pre> <br><p> 那我就写 </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">type</span></span> Query { users(page: UInt, perPage: UInt): PageOf&lt;User&gt;! }</code> </pre> <br><p> 是大量的应用程序！ 我应该告诉您有关仿制药的信息吗？ </p><br><h2 id="5-neymspeysy">  5.命名空间 </h2><br><p> 他们也不在那里。 当系统中类型的数量超过一百零五种时，名称冲突的可能性将趋于百分之一百。 </p><br><p> 出现各种<code>Service_GuideNDriving_Standard_Model_Input</code> 。 我不是在像SOAP中那样在不同端点上使用成熟的名称空间（是的，是的，这很糟糕，但是名称空间在此完美地制作了）。 并且在一个端点上至少具有几种方案，能够“混淆”方案之间的类型。 </p><br><h2 id="itogo"> 合计 </h2><br><p>  GraphQL是一个很好的工具。 它完全适合于容忍的微服务架构，该架构首先面向信息输出和简单的确定性输入。 </p><br><p> 如果要输入多态实体，则可能会有问题。 <br> 输入和输出类型的分离，以及缺少泛型-从头开始产生了很多涂鸦。 </p><br><p>  Graphql不是真的（有时一点<em>也不</em> ）关于CRUD。 </p><br><p> 但这并不意味着您不能吃它：) </p><br><p> 在下一篇文章中，我想谈谈我如何（有时成功）与上述一些问题作斗争。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN425041/">https://habr.com/ru/post/zh-CN425041/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN425027/index.html">在Kotlin上开发GLSL着色器</a></li>
<li><a href="../zh-CN425031/index.html">多练习！ 让我们在不召开任何会议的情况下教授Spring Framework和性能分析</a></li>
<li><a href="../zh-CN425033/index.html">建造喷气背包：喷气背包航空2017年度报告</a></li>
<li><a href="../zh-CN425037/index.html">IT Geek Hub新闻：我们如何在布拉格进行自行车探索，下一次会议将等您</a></li>
<li><a href="../zh-CN425039/index.html">安全周37：Facebook，Twitter和膨胀错误</a></li>
<li><a href="../zh-CN425043/index.html">典型开源解决方案开发简介</a></li>
<li><a href="../zh-CN425047/index.html">机器人咨询如何在投资中发挥作用。 扰流板：简单</a></li>
<li><a href="../zh-CN425051/index.html">戴尔Dell XPS 13 9370笔记本电脑的评测：轻巧，美观，快速</a></li>
<li><a href="../zh-CN425053/index.html">SSR：何时，为什么以及为什么。 以Vue为例</a></li>
<li><a href="../zh-CN425055/index.html">Oculus任务</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>