<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🤝‍👩🏽 😵 🌁 Apresentando o Python para camaradas superando a “linguagem A vs. V” língua B "e outros preconceitos ✌🏿 💇🏿 🖕🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Para todos os residentes de habrach que têm o sentimento de déjà vu: fui solicitado a escrever este post pelo artigo "Introdução ao Python" e comentá-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apresentando o Python para camaradas superando a “linguagem A vs. V” língua B "e outros preconceitos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450724/"><p>  Para todos os residentes de habrach que têm o sentimento de déjà vu: fui solicitado a escrever este post pelo artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Introdução ao Python"</a> e comentá-lo.  Infelizmente, a qualidade desta "introdução" ahem ... não vamos falar de coisas tristes.  Mas foi ainda mais triste observar brigas nos comentários, da categoria “C ++ é mais rápido que Python”, “Ferrugem é ainda mais rápida que C ++”, “Python não é necessário” etc.  É incrível que eles não se lembrassem de Ruby! </p><br><p>  Como Bjarn Stroustrup disse, </p><br><blockquote>  "Existem apenas dois tipos de linguagens de programação: aquelas que as pessoas juram o tempo todo e aquelas que ninguém usa". </blockquote><p>  Bem-vindo a todos que gostariam de se familiarizar com o Python sem cair em maldições sujas! </p><a name="habracut"></a><br><p> A manhã nas montanhas do Cáucaso Oriental foi marcada por gritos.  Dois jovens sentaram-se em uma pedra grande e discutiram vigorosamente algo, gesticulando ativamente.  Um minuto depois, eles começaram a se empurrar, e então se agarraram e caíram de uma pedra em (como se viu) um arbusto de urtiga.  Aparentemente, esse arbusto cresceu lá por uma razão - ele imediatamente pacificou os brigões e trouxe uma trégua à sua disputa insaciável.  Como você provavelmente adivinhou, eu era um dos debatedores, o outro era meu melhor amigo (olá, Quaker_t!), Mas o assunto da nossa conversa foi <strong>Visual Basic vs.</strong>  <strong>Delphi</strong> ! </p><br><p>  Você se reconhece?  Às vezes, transformamos nossas linguagens de programação favoritas em um culto e estamos prontos para defendê-la até o fim!  Mas os anos passam e chega o momento em que "A vs. B" do assunto das disputas se transforma em "Estou mais confortável trabalhando com A, mas, se necessário, aprenderei a trabalhar com B, C, D, E <em>e, em geral, com qualquer coisa</em> ".  Somente quando nos deparamos com novas linguagens de programação, velhos hábitos e cultura podem não nos deixar sair por um longo tempo. </p><br><p>  Gostaria de apresentar o Python e ajudar a transferir sua experiência para uma nova direção.  Como qualquer tecnologia, ela tem seus próprios pontos fortes e fracos.  Python, como C ++, Rust, Ruby, JS e todos os outros, é uma ferramenta.  As instruções estão anexadas a qualquer instrumento e você deve aprender a usá-lo <em>corretamente</em> . </p><br><p>  "Autor, não tem cérebro, você iria nos apresentar o Python?"  Vamos nos familiarizar! </p><br><p>  Python é uma linguagem de programação dinâmica e de alto nível para fins gerais.  Python é uma linguagem de programação <strong>madura</strong> , com um rico ecossistema e tradição.  Embora a linguagem tenha sido lançada em 1991, sua aparência moderna começou a tomar forma no início dos anos 2000.  Python é uma linguagem <strong>carregada</strong> , em sua biblioteca padrão existem soluções para muitas ocasiões.  Python é uma linguagem de programação <strong>popular</strong> : Dropbox, Reddit, Instagram, Disqus, YouTube, Netflix, droga, até Eve Online e muitas outras usam ativamente o Python. </p><br><p>  Qual o motivo dessa popularidade?  Com sua permissão, apresentarei minha própria versão. </p><br><p>  Python é uma linguagem de programação <strong>simples</strong> .  Digitação dinâmica.  Coletor de lixo.  Funções de ordem superior.  Sintaxe simples para trabalhar com dicionários, conjuntos, tuplas e listas (inclusive para obter fatias).  O Python é ótimo para iniciantes: torna possível começar com programação procedural, alternar lentamente para OOP e experimentar a programação funcional.  Mas essa simplicidade é como a ponta de um iceberg.  Vale a pena mergulhar nas profundezas quando você se deparar com a filosofia do Python - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Zen Of Python</a> .  Mergulhando ainda mais - e você se encontra em um conjunto de regras claras para o design de código - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Guia de Estilo para Código Python</a> .  Mergulhando, o programador aprofunda-se gradualmente no conceito de "caminho Python" ou "Pythonic".  Nesse estágio incrível do aprendizado de idiomas, você começa a entender por que bons programas Python são escritos dessa maneira e não de outra forma.  Por que a linguagem evoluiu nessa direção, e não em outra.  Python não teve sucesso em velocidade.  Mas ele conseguiu o aspecto mais importante do nosso trabalho - a legibilidade.  "Escreva código para pessoas, não para carros" - esta é a base do básico do Python. </p><br><p>  Um bom código Python está bonito.  E para escrever um código bonito - o que não é uma ocupação agradável? </p><br><p>  <strong>Dica 0:</strong> <em>Antes de ler mais, dê uma olhada em um canto do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Zen Python</a> .</em>  <em>O idioma é baseado nesses postulados e nossa comunicação será muito mais agradável se você estiver familiarizado com eles.</em> </p><br><h3 id="kakoy-umnik-dodumalsya-do-otstupov">  Que homem inteligente surgiu com indentação? </h3><br><p>  O primeiro choque para quem nunca viu o código em Python é o recuo do corpo de instruções: </p><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ins = input(<span class="hljs-string"><span class="hljs-string">'Please say something'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ins.split(<span class="hljs-string"><span class="hljs-string">' '</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w == <span class="hljs-string"><span class="hljs-string">'hello'</span></span>: print(<span class="hljs-string"><span class="hljs-string">'world!'</span></span>)</code> </pre> <br><p>  Lembro-me das noites no albergue do Politécnico de Petersburgo quando meu vizinho, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">VlK</a> , com olhos ardentes me disse que havia descoberto algo novo em Python.  "Corpo de indentação? Sério?"  - foi a minha reação.  De fato, para uma pessoa que passou do Visual Basic ( <code>if ... end if</code> ) para C # (chaves) através de C, C ++ e Java, essa abordagem parecia, para dizer o mínimo, estranha.  "Você está formatando o código com indentação?", Perguntou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">VlK</a> .  Claro que eu o formatei.  Mais precisamente, o Studio Visual espiral fez isso por mim.  Ela fez isso muito bem.  Eu nunca pensei em formatação e recuo - eles apareceram no código sozinhos e pareciam algo comum e familiar.  Mas não havia nada a esconder - o código sempre era formatado com recuo.  "Então por que você precisa de aparelho se o corpo das instruções é, de qualquer forma, deslocado para a direita?" </p><br><p>  Naquela noite, sentei-me com Python.  Olhando para trás, posso dizer com certeza o que exatamente ajudou a absorver rapidamente o novo material.  Era um editor de código.  Influenciado pelo mesmo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">VlK</a> , pouco antes dos eventos descritos acima, mudei do Windows para o Ubuntu e o Emacs como editor (no pátio de 2007, para PyCharm, Atom, VS Code e outros - muitos mais anos).  "Bem, agora o Emacs irá PR ..." - você diz.  Só um pouquinho :) Tradicionalmente, a tecla <code>&lt;tab&gt;</code> no Emacs não adiciona tabulações, mas serve para alinhar a linha de acordo com as regras deste modo.  Pressione <code>&lt;tab&gt;</code> - e a linha de código é deslocada para a próxima posição apropriada: </p><br><p><img src="https://habrastorage.org/webt/p_/8g/jm/p_8gjmuqid2ffw7ixile3wkjz74.gif"></p><br><p>  Dessa forma, você nunca precisará pensar se alinhara o código corretamente. </p><br><p>  <strong>Dica 1:</strong> <em>Ao conhecer o Python, use um editor que cuide do recuo.</em> </p><br><p>  Você sabe que efeito colateral toda essa desgraça tem?  O programador tenta evitar construções longas.  Assim que o tamanho da função ultrapassa as bordas verticais da tela, fica mais difícil distinguir a qual design o bloco de código especificado pertence.  E quanto mais investimentos, mais difícil.  Como resultado, você tenta escrever da forma mais concisa possível, dividindo os longos corpos de funções, loops, transições condicionais etc. </p><br><h3 id="da-nu-vashu-dinamicheskuyu-tipizaciyu">  Oh, bem, sua digitação dinâmica </h3><br><p>  O, essa discussão existe quase enquanto existir o conceito de “programação”!  A digitação dinâmica não é ruim nem boa.  A digitação dinâmica também é nossa ferramenta.  No Python, a digitação dinâmica oferece uma tremenda liberdade de ação.  E onde há maior liberdade de ação - é mais provável que você atire no próprio pé. </p><br><p>  Vale esclarecer que a digitação em Python é <strong>estrita</strong> e a adição de um número a uma string não funciona: </p><br><pre> <code class="python hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-string"><span class="hljs-string">'1'</span></span> &gt;&gt;&gt; TypeError: unsupported operand type(s) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> +: <span class="hljs-string"><span class="hljs-string">'int'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">'str'</span></span></code> </pre> <br><p>  O Python também verifica a assinatura da função quando é chamada e lança uma exceção se a assinatura da chamada não for verdadeira: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y sum(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>) &gt;&gt;&gt; TypeError: sum() takes <span class="hljs-number"><span class="hljs-number">2</span></span> positional arguments but <span class="hljs-number"><span class="hljs-number">3</span></span> were given</code> </pre> <br><p>  Porém, ao carregar um script, o Python não informará que a função espera um número e não uma string que você passa para ele.  E você só aprende sobre isso em tempo de execução: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y sum(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-string"><span class="hljs-string">'10'</span></span>) &gt;&gt;&gt; TypeError: can only concatenate str (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-string"><span class="hljs-string">"int"</span></span>) to str</code> </pre> <br><p>  Quanto mais forte o desafio para o programador, <em>especialmente ao escrever grandes projetos</em> .  O Python moderno respondeu a esse desafio com um mecanismo de anotação e uma biblioteca de tipos, e a comunidade desenvolveu programas que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">executam a verificação de tipo estático</a> .  Como resultado, o programador aprende sobre esses erros antes de executar o programa: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># main.py: def sum(x: int, y: int) -&gt; int: return x + y sum(10, '10') $ mypy main.py tmp.py:5: error: Argument 2 to "sum" has incompatible type "str"; expected "int"</span></span></code> </pre> <br><p>  O Python não atribui nenhuma importância às anotações, embora as armazene no atributo <code>__annotations__</code> .  A única condição é que as anotações sejam valores válidos em termos de idioma.  Desde a sua aparição na versão 3.0 (que foi há mais de dez anos!), Foram os esforços da comunidade que começaram a usar anotações para marcação digitada de variáveis ​​e argumentos. </p><br><div class="spoiler">  <b class="spoiler_title">Outro exemplo, mais complicado.</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#      , :   :) from typing import TypeVar, Iterable Num = TypeVar('Num', int, float) def sum(items: Iterable[Num]) -&gt; Num: accum = 0 for item in items: accum += item return accum sum([1, 2, 3]) &gt;&gt;&gt; 6</span></span></code> </pre> </div></div><br><p>  <strong>Dica 2:</strong> <em>Na prática, a digitação mais dinâmica causa problemas ao ler e depurar código.</em>  <em>Especialmente se esse código foi escrito sem anotações e você precisa gastar muito tempo descobrindo os tipos de variáveis.</em>  <em>Você não precisa indicar e documentar os tipos de tudo, mas o tempo gasto em uma descrição detalhada das interfaces públicas e nas seções mais críticas do código será recompensado em cem vezes!</em> </p><br><h3 id="krya-utinaya-tipizaciya">  Quack!  Digitação de pato </h3><br><p>  Às vezes, os entusiastas de Python fingem ser misteriosos e falam sobre "digitação de pato". <br>  Digitação de pato é o uso do teste de pato na programação: </p><br><blockquote>  Se um objeto se agita como um pato, voa como um pato e anda como um pato, provavelmente é um pato. </blockquote><p>  Considere um exemplo: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RpgCharacter</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, weapon)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">self</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">weapon</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">weapon</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">battle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.weapon.attack()</code> </pre> <br><p>  Aqui está a injeção de dependência clássica.  A classe <code>RpgCharacter</code> recebe o objeto de <code>weapon</code> no construtor e, mais tarde, no método <code>battle()</code> , chama <code>weapon.attack()</code> .  Mas o <code>RpgCharacter</code> não depende da implementação específica da <code>weapon</code> .  Pode ser uma espada, um BFG 9000 ou uma baleia com um vaso de flores, pronta para pousar na cabeça do inimigo a qualquer momento.  É importante que o objeto tenha um método <code>attack()</code> , pois o Python não está interessado em tudo o mais. </p><br><p></p><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img width="400" src="https://habrastorage.org/webt/l8/ld/yz/l8ldyzcgtvlj3ifvbpnswr2k7ws.png"></a> </div><p></p><br><p>  A rigor, a digitação de patos não é única.  Está presente em todas as linguagens dinâmicas (familiares para mim) que implementam OOP. </p><br><p>  Este é outro exemplo de como programar cuidadosamente no mundo da digitação dinâmica.  Método mal nomeado?  Nomeada uma variável de forma ambígua?  Seu colega, ou você mesmo, depois de cerca de meio ano, ficará feliz em usar esse código :) </p><br><div class="spoiler">  <b class="spoiler_title">O que aconteceria se usarmos Java condicional?</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IWeapon</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sword</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IWeapon</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... } } public class RpgCharacter { IWeapon weapon; public RpgCharacter(IWeapon weapon) { this.weapon = weapon; } public void battle() { weapon.attack(); } }</span></span></code> </pre> <br><p>  E haveria uma digitação estática clássica, com verificação de tipo no estágio de compilação.  Preço - a incapacidade de usar um objeto que possui um método <code>attack()</code> , mas não implementa explicitamente a interface <code>IWeapon</code> . </p></div></div><br><p>  <strong>Dica 3</strong> : <em>Se desejar, você pode descrever a interface criando sua própria <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">classe abstrata com métodos e propriedades</a> .</em>  <em>Melhor ainda, dedique algum tempo testando e escrevendo a documentação para você e seus usuários de código.</em> </p><br><h3 id="procedurnyy-podhod-i-__specialnye_metody__">  Abordagem processual e __ métodos especiais __ () </h3><br><p>  Python é uma linguagem orientada a <code>object</code> e a classe de <code>object</code> está na raiz da hierarquia de herança: </p><br><pre> <code class="python hljs">isinstance(<span class="hljs-string"><span class="hljs-string">'abc'</span></span>, object) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> isinstance(<span class="hljs-number"><span class="hljs-number">10</span></span>, object) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br><p>  Mas onde <code>obj.ToString()</code> usado em Java e C #, haverá uma chamada para <code>str(obj)</code> em Python.  Ou, por exemplo, em vez de <code>myList.length</code> , o Python terá <code>len(my_list)</code> .  O criador da linguagem, Guido van Rossum, explicou o seguinte: </p><br><blockquote>  Quando leio o código que diz <code>len(x)</code> , sei que o tamanho de algo está sendo solicitado.  Isso imediatamente me diz que o resultado será um número inteiro e o argumento é algum tipo de contêiner.  Por outro lado, ao ler <code>x.len()</code> , preciso saber que <code>x</code> é algum tipo de contêiner que implementa uma interface específica ou herda de uma classe que possui o método <code>len()</code> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">[Fonte]</a> . </blockquote><p>  No entanto, dentro de si, as funções <code>len()</code> , <code>str()</code> e algumas outras chamarão <strong>certos</strong> métodos do objeto: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, name, last_name)</span></span></span><span class="hljs-function">:</span></span> self.name = name self.last_name = last_name <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__str__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">f"Honourable </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{self.name}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{self.last_name}</span></span></span><span class="hljs-string">"</span></span> u = User(<span class="hljs-string"><span class="hljs-string">'Alex'</span></span>, <span class="hljs-string"><span class="hljs-string">'Black'</span></span>) label = str(u) print(label) &gt;&gt;&gt; Honourable Alex Black</code> </pre> <br><p>  Métodos especiais também são usados ​​por operadores de linguagem, matemáticos e booleanos, bem como <code>for ... in ...</code> operadores de loop, <code>with</code> operador de contexto, operador de índice <code>[]</code> , etc. <br>  Por exemplo, um protocolo iterador consiste em dois métodos: <code>__iter__()</code> e <code>__next__()</code> : </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#  Iterable, IEnumerable, std::iterator  .. class InfinitePositiveIntegers: def __init__(self): self.counter = 0 def __iter__(self): """      .    iter(). """ return self def __next__(self): """  .    next(). """ self.counter += 1 return self.counter for i in InfinitePositiveIntegers(): print(i) &gt;&gt;&gt; 1 &gt;&gt;&gt; 2 &gt;&gt;&gt; ... #  ,  Ctrl + C</span></span></code> </pre> <br><p>  Bem, digamos métodos especiais.  Mas por que eles parecem tão distorcidos?  Guido explicou isso pelo fato de terem os nomes usuais sem sublinhar, os próprios programadores não os redefiniriam, mais cedo ou mais tarde.  I.e.  <code>____()</code> é um tipo de proteção contra o tolo.  Como o tempo mostrou - a proteção é eficaz :) </p><br><p>  <strong>Dica 4:</strong> <em>observe atentamente as <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">funções</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">internas</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">os métodos de objetos especiais</a> .</em>  <em>Eles são parte integrante da linguagem, sem a qual é impossível falar completamente.</em> </p><br><h3 id="gde-inkapsulyaciya-gde-moy-private-gde-moya-skazochka">  Onde está o encapsulamento?  Onde está o meu privado ?!  Onde está o meu conto de fadas? !! </h3><br><p>  Python não possui modificadores de acesso para atributos de classe.  O interior dos objetos está aberto para acesso sem restrições.  No entanto, existe uma convenção segundo a qual os atributos com o prefixo <code>_</code> são considerados privados, por exemplo: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyFile</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    _os_handle = None def __init__(self, path: str): self._open(path) #    def _open(self, path): # os.open() - **    . #      open(). #   os.open()    . self._os_handle = os.open(path, os.O_RDWR | os.O_CREAT) #      def close(self): if self._os_handle is not None: os.close(self._os_handle) f = MyFile('/tmp/file.txt') print(f._os_handle) #    ""    ! f.close()</span></span></code> </pre> <br><p>  Porque </p><br><blockquote>  Não há nada particular em Python.  Nem a classe nem sua instância irão esconder de você o que está dentro (graças ao qual a introspecção mais profunda é possível).  Python confia em você.  Ele meio que diz: "Amigo, se você quiser remexer nos cantos escuros - não há problema. Acredito que existem boas razões para isso e espero que você não quebre nada. É claro. <br><br>  No final, somos todos adultos aqui. <br><br>  - Karl Fast <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">[fonte]</a> . </blockquote><br><div class="spoiler">  <b class="spoiler_title">Mas como evitar colisões de nomes durante a herança?</b> <div class="spoiler_text"><p>  O Python possui um mecanismo especial para manipular o nome dos atributos começando com sublinhado duplo e não terminando com sublinhado duplo ( <code>__my_attr</code> )!  Isso é feito para evitar colisões de nomes durante a herança.  Para chamar os métodos de classe fora do corpo, o Python adiciona o prefixo <code>___</code> .  Mas para acesso interno, nada muda: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.__x = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.__x c = C() c.__x &gt;&gt;&gt; <span class="hljs-string"><span class="hljs-string">'C'</span></span> object has no attribute <span class="hljs-string"><span class="hljs-string">'__x'</span></span> print(c.get_x()) &gt;&gt;&gt; <span class="hljs-number"><span class="hljs-number">10</span></span> print(c._C__x) &gt;&gt;&gt; <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre> <br><p>  Vamos olhar para uma aplicação prática.  Por exemplo, para a classe <code>File</code> , que lê arquivos do sistema de arquivos local, queremos adicionar recursos de cache.  Nosso colega conseguiu escrever uma aula de mixin para esses fins.  Mas, para isolar métodos e atributos de <strong>possíveis</strong> conflitos, um colega adicionou o prefixo <code>__</code> a seus nomes: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseFile</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, path)</span></span></span><span class="hljs-function">:</span></span> self.path = path <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalMixin</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_from_local</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(self.path) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f.read() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CachedMixin</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CacheMissError</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Exception)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Tepe,         #   __cache,   __from_cache(), # ,     ! self.__cache = {} def __from_cache(self): return self.__cache[self.path] def read_from_cache(self): try: return self.__from_cache() except KeyError as e: raise self.CacheMissError() from e def store_to_cache(self, data): self.__cache[self.path] = data class File(CachedMixin, LocalMixin, BaseFile): def __init__(self, path): CachedMixin.__init__(self) BaseFile.__init__(self, path) def read(self): try: return self.read_from_cache() except CachedMixin.CacheMissError: data = self.read_from_local() self.store_to_cache(data) return data</span></span></code> </pre> <br><p>  Se você estiver interessado em examinar a implementação desse mecanismo no CPython, por favor, em <a href="">Python / compile.c</a> </p></div></div><br><p>  Finalmente, devido à presença de propriedades na linguagem, não faz sentido escrever getters e setters no estilo Java: <code>getX(), setX()</code> .  Por exemplo, na classe originalmente escrita <code>Coordinates</code> , </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Coordinates</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, x, y)</span></span></span><span class="hljs-function">:</span></span> self.x = x self.y = y c = Coordinates(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) print(cx, cy) &gt;&gt;&gt; (<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)</code> </pre> <br><p>  Eu precisava controlar o acesso ao atributo <code>x</code> .  A abordagem correta seria substituí-la por <code>property</code> , mantendo assim um contrato com o mundo exterior. </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Coordinates</span></span></span><span class="hljs-class">:</span></span> _x = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, x, y)</span></span></span><span class="hljs-function">:</span></span> self.x = x self.y = y @property <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._x @x.setter <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, val)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> val &gt; <span class="hljs-number"><span class="hljs-number">10</span></span>: self._x = val <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ValueError(<span class="hljs-string"><span class="hljs-string">'x should be greater than 10'</span></span>) c = Coordinates(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) cx = <span class="hljs-number"><span class="hljs-number">5</span></span> &gt;&gt;&gt; ValueError: x should be greater than <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre> <br><p>  <strong>Dica 5:</strong> <em>Assim como em Python, o conceito de campos particulares e métodos de classe é baseado em uma convenção estabelecida.</em>  <em>Não se ofenda com os autores das bibliotecas se "tudo parou de funcionar" pelo motivo de você ter usado ativamente os campos particulares de suas classes.</em>  <em>No final, somos todos adultos aqui :)</em> . </p><br><h3 id="nemnogo-ob-isklyucheniyah">  Um pouco sobre exceções </h3><br><p>  A cultura Python tem uma abordagem única para exceções.  Além da interceptação e processamento usuais em C ++ / Java, você encontrará o uso de exceções no contexto </p><br><blockquote>  "Mais fácil pedir perdão do que permissão - EAFP." </blockquote><p>  Parafraseando - não escreva muito <code>if</code> , <code>if</code> , na maioria dos casos, a execução for neste ramo.  Em vez disso, envolva a lógica em <code>try..except</code> . </p><br><p>  Exemplo: imagine um manipulador de solicitação POST que crie um usuário em um banco de dados condicional.  Na entrada da função, há um dicionário (dicionário) do tipo de valor-chave: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_user_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data: Dict[str, str])</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: database.user.persist( username=data[<span class="hljs-string"><span class="hljs-string">'username'</span></span>], password=data[<span class="hljs-string"><span class="hljs-string">'password'</span></span>] ) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError: print(<span class="hljs-string"><span class="hljs-string">'There was a missing field in data passed for user creation'</span></span>)</code> </pre> <br><p>  Não poluimos o código com verificações "se o <code>username</code> ou a <code>password</code> estão nos <code>data</code> ".  Esperamos que eles provavelmente estejam lá.  Não pedimos “permissão” para usar esses campos, mas “pedimos desculpas” quando o próximo kulhacker postar um formulário com dados ausentes. </p><br><div class="spoiler">  <b class="spoiler_title">Só não leve ao ponto do absurdo!</b> <div class="spoiler_text"><p>  Por exemplo, você gostaria de verificar se o sobrenome do usuário está presente nos dados e se não o define como um valor vazio.  <code>if</code> aqui fosse muito mais apropriado: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_user_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-string"><span class="hljs-string">'last_name'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data: data[<span class="hljs-string"><span class="hljs-string">'last_name'</span></span>] = <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: database.user.persist( username=data[<span class="hljs-string"><span class="hljs-string">'username'</span></span>], password=data[<span class="hljs-string"><span class="hljs-string">'password'</span></span>], last_name=data[<span class="hljs-string"><span class="hljs-string">'last_name'</span></span>] ) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError: print(<span class="hljs-string"><span class="hljs-string">'There was a missing field in data passed for user creation'</span></span>)</code> </pre> </div></div><br><p>  <strong>Os erros nunca devem passar silenciosamente.</strong>  - não ignore as exceções!  O Python moderno tem um <code>raise from</code> maravilhoso <code>raise from</code> construção que permite manter o contexto da cadeia de exceções.  Por exemplo: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyProductError</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Exception)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> super().__init__(<span class="hljs-string"><span class="hljs-string">'There has been a terrible product error'</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> / x <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ZeroDivisionError <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> MyProductError() <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> e</code> </pre> <br><p>  Sem <code>raise from e</code> cadeia de exceção é interrompida em <code>MyProductError</code> e não podemos descobrir qual foi exatamente a causa desse erro.  Com <code>raise from X</code> , o motivo (ou seja, <code>X</code> ) da exceção lançada é armazenado no atributo <code>__cause__</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: calculate(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> MyProductError <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: print(e.__cause__) &gt;&gt;&gt; division by zero</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Mas há uma pequena nuance no caso da iteração: StopIteration</b> <div class="spoiler_text"><p>  No caso de uma iteração, o lançamento de uma exceção <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">StopIteration</a> é a maneira oficial de sinalizar que o iterador está completo. </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositiveIntegers</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, limit)</span></span></span><span class="hljs-function">:</span></span> self.counter = <span class="hljs-number"><span class="hljs-number">0</span></span> self.limit = limit <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__iter__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__next__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.counter += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.counter == self.limit: <span class="hljs-comment"><span class="hljs-comment">#  hasNext()  moveNext(), #  ,   raise StopIteration() return self.counter for i in PositiveIntegers(5): print(i) &gt; 1 &gt; 2 &gt; 3 &gt; 4</span></span></code> </pre> </div></div><br><p>  <strong>Dica 6:</strong> <em>pagamos pelo tratamento de exceções somente em situações excepcionais.</em>  <em>Não os negligencie!</em> </p><br><h3 id="there-should-be-one---and-preferably-only-one---obvious-way-to-do-it">  Deve haver um - e de preferência apenas um - a maneira anterior de fazer isso. </h3><br><p>  <code>switch</code> ou correspondência de padrões?  - use <code>if</code> e dicionários.  <code>do-</code> ?  - para isso há um <code>while</code> e <code>for</code> .  <code>goto</code> ?  Eu acho que você mesmo adivinhou.  O mesmo se aplica a algumas técnicas e padrões de design que parecem ter sido concedidos em outros idiomas.  O mais surpreendente é que não há restrições técnicas à sua implementação, é apenas "não aceitamos". </p><br><p>  Por exemplo, no Python, você não vê frequentemente o padrão "Construtor".  Em vez disso, ele usa a capacidade de transmitir e solicitar explicitamente argumentos de nome para a função.  Em vez disso </p><br><pre> <code class="python hljs">human = HumanBuilder.withName(<span class="hljs-string"><span class="hljs-string">"Alex"</span></span>).withLastName(<span class="hljs-string"><span class="hljs-string">"Black"</span></span>).ofAge(<span class="hljs-number"><span class="hljs-number">20</span></span>).withHobbies([<span class="hljs-string"><span class="hljs-string">'tennis'</span></span>, <span class="hljs-string"><span class="hljs-string">'programming'</span></span>]).build()</code> </pre> <br><p>  será </p><br><pre> <code class="python hljs">human = Human( name=<span class="hljs-string"><span class="hljs-string">"Alex"</span></span> last_name=<span class="hljs-string"><span class="hljs-string">"Black"</span></span> age=<span class="hljs-number"><span class="hljs-number">20</span></span> hobbies=[<span class="hljs-string"><span class="hljs-string">'tennis'</span></span>, <span class="hljs-string"><span class="hljs-string">'programming'</span></span>] )</code> </pre> <br><p>  A biblioteca padrão não usa cadeias de métodos para trabalhar com <em>coleções</em> .  Lembro-me de como um colega que veio do mundo de Kotlin me mostrou o código do seguinte sentido (extraído da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documentação oficial</a> do Kotlin): </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> shortGreetings = people .filter { it.name.length &lt; <span class="hljs-number"><span class="hljs-number">10</span></span> } .map { <span class="hljs-string"><span class="hljs-string">"Hello, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${it.name}</span></span></span><span class="hljs-string">!"</span></span> }</code> </pre> <br><p>  No Python, <code>map()</code> , <code>filter()</code> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">muitos outros</a> são funções, não métodos de coleta.  Reescrevendo este código um por um, obtemos: </p><br><pre> <code class="python hljs">short_greetings = map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> h: <span class="hljs-string"><span class="hljs-string">f"Hello, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{h.name}</span></span></span><span class="hljs-string">"</span></span>, filter(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> h: len(h.name) &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>, people))</code> </pre> <br><p>  Na minha opinião, parece horrível.  Portanto, para pacotes grandes como <code>.takewhile().filter().map().reduce()</code> , é melhor usar o chamado  <em>inclusão</em> (compreensões) ou bons ciclos antigos.  A propósito, o mesmo exemplo no Kotlin é dado na forma da compreensão da lista correspondente.  E no Python é assim: </p><br><pre> <code class="python hljs">short_greetings = [ <span class="hljs-string"><span class="hljs-string">f"Hello </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{h.name}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> h <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> people <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(h.name) &lt; <span class="hljs-number"><span class="hljs-number">10</span></span> ]</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Para quem sente falta das correntes</b> <div class="spoiler_text"><p>  Existem bibliotecas como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pipe</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">py_linq</a> ! </p></div></div><br><p>  As cadeias de métodos são usadas onde são mais eficientes que as ferramentas padrão.  Por exemplo, na estrutura da web do Django, cadeias são usadas para criar um objeto de consulta ao banco de dados: </p><br><pre> <code class="python hljs">query = User.objects \ .filter(last_visited__gte=<span class="hljs-string"><span class="hljs-string">'2019-05-01'</span></span>) \ .order_by(<span class="hljs-string"><span class="hljs-string">'username'</span></span>) \ .values(<span class="hljs-string"><span class="hljs-string">'username'</span></span>, <span class="hljs-string"><span class="hljs-string">'last_visited'</span></span>) \ [:<span class="hljs-number"><span class="hljs-number">5</span></span>]</code> </pre> <br><p>  <strong>Dica 7:</strong> <em>Antes de fazer algo muito familiar com a experiência passada, mas não familiar no Python, pergunte-se que decisão um pythonist experiente tomaria?</em> </p><br><h3 id="piton-medlennyy">  Python lento </h3><br><p>  Sim </p><br><p>  Sim, quando se trata de velocidade de execução em comparação com linguagens estaticamente tipadas e compiladas. </p><br><p>  Mas você parece querer uma resposta detalhada? </p><br><p>  A implementação de referência do Python (CPython) está longe de ser a sua implementação mais eficaz.  Uma das razões importantes é o desejo dos desenvolvedores de não complicá-lo.  E a lógica é compreensível - o código não muito obscuro significa menos erros, uma melhor oportunidade para fazer alterações e, no final, mais pessoas que desejam ler, entender e complementar esse código. </p><br><p>  Jake VanderPlas, em seu blog, analisa o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">que acontece no CPython</a> ao adicionar duas variáveis ​​que contêm valores inteiros: </p><br><pre> <code class="python hljs">a = <span class="hljs-number"><span class="hljs-number">1</span></span> b = <span class="hljs-number"><span class="hljs-number">2</span></span> c = a + b</code> </pre> <br><p>  Mesmo se não nos aprofundarmos na selva do CPython, podemos dizer que, para armazenar as variáveis <code>a</code> , <code>b</code> , o intérprete precisará criar três objetos na pilha, nos quais os valores de tipo e (indicadores para) serão armazenados;  <code>binary_add&lt;int, int&gt;(a-&gt;val, b-&gt;val)</code> novamente o tipo e os valores durante a operação de adição para chamar algo como <code>binary_add&lt;int, int&gt;(a-&gt;val, b-&gt;val)</code> ;  escreva o resultado em <code>c</code> . <br>  Isso é terrivelmente ineficiente em comparação com um programa C semelhante. </p><br><p>  Outro problema com o CPython é o chamado  Bloqueio Global de Intérpretes (GIL).  Esse mecanismo, essencialmente um valor booleano delimitado por um mutex, é usado para sincronizar a execução do bytecode.  O GIL simplifica o desenvolvimento de código em execução em um ambiente multiencadeado: o CPython não precisa pensar em sincronizar o acesso a variáveis ​​ou deadlocks.  Você precisa pagar por isso, pois apenas um thread obtém acesso e <em>executa o bytecode</em> em um determinado momento: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rw/od/if/rwodifh_niof7jaf5bvmagg4ypy.gif"></div><br><p>  <strong>UPD:</strong> Mas isso não significa que o programa em Python funcione magicamente em um ambiente multiencadeado!  O código no Python não é transferido para o bytecode um por um e não há garantias sobre a compatibilidade do bytecode entre as versões!  Portanto, você ainda precisa sincronizar os threads no código.  Felizmente, aqui o Python possui um rico conjunto de ferramentas, por exemplo, permitindo que você alterne entre um modelo de execução multiencadeado e multiprocesso. </p><br><div class="spoiler">  <b class="spoiler_title">Se você está curioso sobre quais esforços estão sendo feitos para erradicar o GIL</b> <div class="spoiler_text"><p>    Anthony Shaw " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Has the Python GIL been slain?</a> ". </p></div></div><br><p>    ? </p><br><ol><li>      .    ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CFFI</a> )              .           API    (extensions)  C/C++.    ,      Rust, Go   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Kotlin Native</a> ! </li><li>    , : <br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PyPy</a> ,   JIT-.    ,     ,          ? </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cython</a> —      Python    C. </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IronPython</a> — ,   .NET framework. </li></ul></li></ol><br><p> <strong> 8:</strong> <em>     ,              .      ,   IO (, ,  )   ,    ,      ,    ,     :)</em> </p><br><h3 id="osnovnye-instrumenty">   </h3><br><p>      ?      Linux  MacOS,   95%      .      ,      3.,       2.7.    Windows   .   :  Docker, Windows Subsystem for Linux, Cygwin, ,     . </p><br><p> <strong> 9:</strong> <em>     .  ,   —       -   .</em> </p><br><p>    "Hello world"   ?  Ótimo!      machine learning-    -    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Python Package Index</a> (PyPI). </p><br><p>        (packages),    ..   (virtual environments).        ,      .     -    .   <code>pip</code>    .     <code>pip</code>      .      ,  <code>pipenv</code>  <code>poetry</code> —  npm, bundler, cargo  .. </p><br><p> <strong> 0xA:</strong> <em>      —  <code>pip</code>  <code>virtualenv</code> .   —  , ,  .  ,      —   <code>sys.path</code> —  ,        .</em> </p><br><h3 id="chto-zhe-dalshe">   ? </h3><br><p>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> ?       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   </a> .     : </p><br><blockquote>      Dive into python... </blockquote><p> ,               .              , ,     :) </p><br><p> , ! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt450724/">https://habr.com/ru/post/pt450724/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt450710/index.html">Vídeos sobre reconstrução de Midi a partir de Synthesia (e similares)</a></li>
<li><a href="../pt450712/index.html">DotNetRu na DotNext 2019 Piter</a></li>
<li><a href="../pt450716/index.html">Anunciando as habilidades do Windows Vision (versão prévia)</a></li>
<li><a href="../pt450718/index.html">O que há de novo no RxJS v6.5</a></li>
<li><a href="../pt450720/index.html">Como desenvolver um aplicativo amigável</a></li>
<li><a href="../pt450726/index.html">Criando uma ferramenta para escrever de forma rápida e eficiente autotestes no Selenium</a></li>
<li><a href="../pt450728/index.html">NLog: regras e filtros</a></li>
<li><a href="../pt450730/index.html">ok.tech: frontend meetup</a></li>
<li><a href="../pt450732/index.html">Entendo, significa que existo: uma revisão do Deep Learning in Computer Vision (parte 1)</a></li>
<li><a href="../pt450734/index.html">Fuzzing é um passo importante no desenvolvimento seguro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>