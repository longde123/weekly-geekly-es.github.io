<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑 🏫 🚌 使用asyncio在MicroPython v.1.12上创建异步设备驱动程序 👦🏽 🔍 🦓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在研究MicroPython达到其目的的可能性时，我遇到了asyncio库的一种实现，并且在与库的作者Piter Hinch进行了简短的通信之后，我意识到我需要更深入地了解使用异步编程方法的原理，基本概念和典型错误。 此外，面向初学者的部分仅适合我。 

 本指南面向具有不同asyncio经验水平的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用asyncio在MicroPython v.1.12上创建异步设备驱动程序</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484472/"> <i>在研究<b>MicroPython</b>达到其目的的可能性时，我遇到了<b>asyncio</b>库的一种实现，并且在与库的作者<b>Piter Hinch</b>进行了简短的通信之后，我意识到我需要更深入地了解使用异步编程方法的原理，基本概念和典型错误。</i>  <i>此外，面向初学者的部分仅适合我。</i> <br><br> 本指南面向具有不同<i><b>asyncio</b></i>经验水平的用户，其中包括面向初学者的特殊部分。 <br><a name="habracut"></a><br>  <b>目录内容</b> <br>  <b>0.简介</b> <br>  0.1 .___在空设备（硬件）上安装<i><b>uasyncio</b></i> <br>  <b>1.规划联合计划执行</b> <br>  1.1 .___模块 <br>  <b>2. <i>uasyncio</i>库</b> <br>  2.1 .___程序结构：事件处理周期 <br>  2.2 .___协程 <br>  2.2.1 .______对<i>协程进行</i>排队<i>以参与计划</i> <br>  2.2.2 .______ <i>启动函数<i>回调</i> （ <i>callback</i> ）</i> <br>  2.2.3 .______ <i>注意：协程作为相关方法。</i>  <i>返回值。</i> <br>  2.3 .___延迟 <br>  <b>3.同步及其类</b> <br>  3.1 .___锁定<i><b>锁定</b></i> <br>  3.1.1 .______ <i>锁定和超时</i> <br>  3.2 .___ <i><b>事件</b></i> <br>  3.2.1 .______事件<i>值</i> <br>  3.3 .___屏障<i><b>屏障</b></i> <br>  3.4 .___ <i><b>信号量</b></i> <br>  3.4.1 .______ <i>受限信号量</i> <br>  3.5 .___队列<i><b>队列</b></i> <br>  3.6 .___其他同步类 <br>  <b>4. <i>asyncio的</i>类开发</b> <br>  4.1 .___类使用<i>await</i> <br>  4.1.1 .______ <i>在上下文管理器中使用</i> <br>  4.1.2 .______ <i>等待协程</i> <br>  4.2 .___异步迭代器 <br>  4.3 .___异步上下文管理器 <br>  <b>5.超时和任务取消导致的例外</b> <br>  5.1 .___例外 <br>  5.2 .___由于超时和取消任务而导致的异常 <br>  5.2.1 .______ <i>取消任务</i> <br>  5.2.2 <i>带有超时的协程</i> <br>  <b>6.与硬件设备的交互</b> <br>  6.1 .___同步问题 <br>  6.2 .___带有协程的轮询设备 <br>  6.3 .___使用流引擎 <br>  6.3.1 .______ <i>UART驱动程序示例</i> <br>  6.4 .___流设备的驱动程序开发 <br>  6.5 .___完整示例： <i>aremote.py</i>用于IR遥控接收器的驱动程序。 <br>  6.6 .___温湿度传感器HTU21D的驱动程序。 <br>  <b>7.技巧和窍门</b> <br>  7.1 .___程序冻结 <br>  7.2 .___ <b><i>uasyncio</i></b>保存状态 <br>  7.3 .___垃圾收集 <br>  7.4 .___测试 <br>  7.5 .___常见错误。 可能很难找到。 <br>  7.6 .___使用套接字编程（ <i>套接字</i> ） <br>  7.6.1 .______ <i>WiFi问题</i> <br>  7.7 .___事件循环构造函数的参数 <br>  <b>8.初学者注意事项</b> <br>  8.1 .___问题1：事件循环 <br>  8.2 .___问题2：锁定方法 <br>  8.3 .___ <b><i>uasyncio</i></b>方法 <br>  8.4 .___在<b><i>uasyncio中进行</i></b>规划 <br>  8.5 .___为什么要协作而不是基于线程的调度（ <i>_thread</i> ）？ <br>  8.6 .___互动 <br>  8.7 .___ <i>轮询</i> <br><br>  <b>0.简介</b> <br><br> 本文档的大部分内容假定您对异步编程有所了解。 对于初学者，可以在第7节中找到介绍。 <br><br>  <i><b>MicroPython的uasyncio</b></i>库包含<b><i>asyncio</i></b> <b>Python</b>库的一个子集，旨在用于微控制器。 这样，它占用少量RAM，并且配置为使用零RAM分配快速切换上下文。 <br><br> 本文档介绍了<i><b>uasyncio的</b></i>使用，重点是为硬件设备创建驱动程序。 <br><br> 目的是设计驱动程序，以使应用程序在驱动程序等待设备响应时继续运行。 同时，应用程序对其他事件和用户交互保持敏感。 <br><br>  <b><i>异步</i></b>应用的另一个重要领域是网络编程：在Internet上您可以找到有关此主题的足够信息。 <br><br> 请注意， <b>MicroPython</b>基于<b>Python 3.4，</b>带有最少的<b>Python 3.5</b>附加组件。 除以下详述外，不支持早于3.4的<b><i>asyncio</i></b>版本的功能。 本文档定义了此子集中支持的功能。 <br><br> 本指南的目的是介绍与<b>CPython V3.5</b>及更高<b>版本</b>兼容的编程风格。 <br><br>  <b>0.1在空设备上安装<b><i>uasyncio</i></b> （硬件）</b> <br><br> 建议使用固件<b>MicroPython V1.11</b>或更高版本。 在许多平台上，不需要安装，因为<b><i>uasyncio®</i></b>已在程序<b><i>集中进行</i></b>编译。 要检查，只需输入REPL <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio</code> </pre> <br> 以下说明介绍了未预装模块的情况。  <b><i>队列</i></b>和<b><i>同步</i></b>模块是可选的，但运行此处给出的示例是必需的。 <br><br>  <b>互联网连接设备</b> <br><br> 在连接到Internet并运行固件V1.11或更高版本的设备上，可以使用内置的<i>upip</i>版本进行安装。 确保设备已连接到网络： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> upip upip.install ( <span class="hljs-string"><span class="hljs-string">'micropython-uasyncio'</span></span> ) upip.install ( <span class="hljs-string"><span class="hljs-string">'micropython-uasyncio.synchro'</span></span> ) upip.install ( <span class="hljs-string"><span class="hljs-string">'micropython-uasyncio.queues'</span></span> )</code> </pre><br> 来自<i>upip</i>的错误消息不是很有用。 如果出现无法理解的错误，请再次检查Internet连接。 <br><br>  <b>没有互联网连接的硬件（ <i>micropip</i> ）</b> <br><br> 如果您的设备<b>没有</b> Internet连接（例如<b>Pyboard V1.x</b> ），最简单的方法是开始在计算机上安装<i>micropip.py</i>到您选择的目录，然后将生成的目录结构复制到目标设备。  <i>micropip.py</i>实用程序在<b>Python 3.2</b>或更高版本上运行，并在Linux，Windows和OSX上运行。 在<a href="https://github.com/peterhinch/micropython-samples/tree/master/micropip" rel="nofollow">此处</a>可以找到更多信息。 <br><br> 典型电话： <br><br><pre> <code class="python hljs">$ micropip.py install -p ~/rats micropython-uasyncio $ micropip.py install -p ~/rats micropython-uasyncio.synchro $ micropip.py install -p ~/rats micropython-uasyncio.queues</code> </pre><br>  <b>没有Internet连接的设备（复制源）</b> <br><br> 如果不使用<i>micropip.py</i> ，则必须从源复制文件。 以下说明描述了如何将最少数量的文件复制到目标设备，以及需要将<b><i>uasyncio</i></b>压缩为字节码形式的已编译程序集以减少占用空间的情况。 对于与官方固件兼容的最新版本，必须从官方<a href="http://github.com/micropython/micropython-lib" rel="nofollow">micropython-lib</a>网站复制文件。 <br><br> 使用以下命令将库克隆到计算机 <br><br><pre> <code class="python hljs">$ git clone https://github.com/micropython/micropython-lib.git</code> </pre><br> 在目标设备上，创建<b><i>uasyncio</i></b>目录（lib目录中的可选目录），并将以下文件复制到其中： <br><br>  <b>•uasyncio / uasyncio / __ init__.py</b> <b><br></b>  <b>•uasyncio.core / uasyncio / core.py</b> <b><br></b>  <b>•uasyncio.synchro / uasyncio / synchron.py</b> <b><br></b>  <b>•uasyncio.queues / uasyncio / queues.py</b> <b><br></b> <br><br> 通过将<b><i>uasyncio</i></b>目录及其内容放置在<b><i>modules</i></b>目录的端口中并重新编译内容，可以将这些<b><i>uasyncio</i></b>模块压缩为字节码。 <br><br>  <b>1.联合规划</b> <br><br> 联合执行多个任务的技术已在嵌入式系统中广泛使用，与线程调度（ <b>_thread</b> ）调度相比，它提供了更少的开销，避免了与真正的异步线程相关的许多陷阱。 <br><br>  <b>1.1模块</b> <br><br> 以下是可以在目标设备上运行的模块的列表。 <br><br>  <b><u>图书馆</u></b> <br><br>  1. <b><i>asyn.py</i></b>提供<i><b>锁，事件，屏障，信号量，BoundedSemaphore，条件，收集</b></i>同步原语。 通过<i><b>NamedTask</b></i>和<i><b>Cancellable</b></i>类提供对取消任务的支持。 <br><br>  2. <b><i>aswitch.py</i></b>表示配对开关和按钮的类，以及可能重复延迟的程序对象。 按钮是对开关的概括，它们提供逻辑状态而不是物理状态，以及双击和长按触发的事件。 <br><br>  <b>演示程序</b> <br><br> 前两个最有用，因为它们在访问<b>Pyboard硬件</b>时会给出可见的结果。 <br><br><ol><li>  <b><i>aledflash.py</i></b>异步闪烁四个<b>Pyboard</b>指示器10秒钟。  <b>uasyncio</b>的最简单演示。 导入运行。 </li><li>  <b><i>apoll.py</i></b> <b>Pyboard</b>加速度计的<b><i>设备</i></b>驱动程序。 演示使用协程查询设备。 工作20秒。 导入运行。 需要<b>PyboardV1.x。</b> </li><li>  <b><i>astests.py</i></b> <b><i>aswitch</i></b>模块的测试/演示程序。 </li><li>  <b><i>asyn_demos.py</i></b>取消任务的简单演示。 </li><li>  <b><i>roundrobin.py</i></b>循环计划的演示。 也是绩效计划的基准。 </li><li>  <b><i>awaitable.py</i></b>带有等待的类的演示。 一种实现轮询接口的设备驱动程序的方法。 </li><li>  <b><i>chain.py</i></b>从<b>Python</b>文档复制。 协程链演示。 </li><li>  <b><i>aqtest.py</i></b>演示<i><b>uasyncio</b></i>库的<b><i>Queue</i></b>类。 </li><li>  <b><i>aremote.py</i></b> NEC IR协议的示例设备驱动程序。 </li><li>  <b><i>auart.py</i></b>通过<b>Pyboard UART</b>进行流输入输出的演示。 </li><li>  <b><i>auart_hd.py</i></b>使用<b>Pyboard UART</b>使用半双工协议与设备进行通信。 适用于设备，例如，使用AT调制解调器命令集。 </li><li>  <b><i>iorw.py</i></b>演示使用流I / O的读取器/写入器设备。 </li></ol><br>  <b>测试程序</b> <br><br><ol><li>  <b><i>asyntest.py</i></b>测试<b><i>asyn.py</i></b>中的同步类。 </li><li>  <b><i>cantest.py</i></b>职位取消测试。 </li></ol><br>  <b>效用</b> <br><br>  1. <b><i>check_async_code.py</i></b>该实用程序是用<b>Python3</b>编写的，用于检测可能很难找到的特定编码错误。 请参阅第7.5节。 <br><br>  <b>控制权</b> <br><br>  <a href="" rel="nofollow"><i>基准</i></a>目录包含用于检查和表征<i><b>uasyncio调度程序的</b></i>脚本。 <br><br><cut></cut><br>  <b>2. <i>uasyncio</i>库</b> <br><br>  <i>异步</i>概念基于联合执行多个任务的计划组织，在本文中称为<b>协程</b> 。 <br><br>  <b>2.1程序结构：事件循环</b> <br><br> 考虑以下示例： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> : count + = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> ( count ) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep ( <span class="hljs-number"><span class="hljs-number">1</span></span> ) <span class="hljs-comment"><span class="hljs-comment">#  1 loop = asyncio.get_event_loop () loop.create_task ( bar ()) #     loop.run_forever ()</span></span></code> </pre><br> 程序将继续执行，直到<i>调用loop.run_forever</i>为止。 此时，执行由调度程序控制。  <i>loop.run_forever</i>之后的<i>行将</i>永远不会执行。 调度程序执行<i>条形码，</i>因为它已在<i>loop.create_task调度程序中</i>排队。 在这个简单的例子中，只有一个协程<i>吧</i> 。 如果还有其他内容，调度程序将在<i>栏</i>暂停期间执行它们。 <br><br> 大多数嵌入式应用程序都有一个连续的事件循环。 也可以使用<i>run_until_complete</i>事件循环方法以允许完成的方式启动事件循环。 它主要用于测试。 可以在<a href="https://github.com/peterhinch/micropython-async/blob/master/astests.py" rel="nofollow"><b><i>astests.py</i></b></a>模块中找到示例。 <br><br> 事件循环实例是由对<i>asyncio.get_event_loop（）</i>的第一次调用创建的单个对象，带有两个可选的整数参数，指示两个队列中协程的数量-开始和等待。 通常，两个参数将具有相同的值，至少等于应用程序中同时执行的协程数。 通常，默认值16就足够了，如果使用非默认值，请参见事件循环构造函数的参数（第7.7节）。 <br><br> 如果协程需要调用事件循环方法（通常为<i>create_task</i> ），则调用<i>asyncio.get_event_loop（）</i> （不带参数）将有效地返回它。 <br><br>  <b>2.2协程</b> <br><br> 协程的创建如下： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( delay_secs )</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep ( delay_secs ) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> ( <span class="hljs-string"><span class="hljs-string">'Hello'</span></span> )</code> </pre><br> 协程可以使用<i>await</i>语句启动其他协程。 协程必须至少包含一个<i>wait</i>语句。 这将导致协程在完成之前执行，然后执行下一条语句。 考虑一个例子： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep ( delay_secs ) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep ( <span class="hljs-number"><span class="hljs-number">0</span></span> )</code> </pre><br> 第一行使代码暂停一个延迟时间，而其他协程将这段时间用于执行它们。 延迟0会导致所有暂挂的协程以循环顺序执行，直到执行下一行为止。 请参见<i><b>roundrobin.py</b></i>的示例。 <br><br>  <b>2.2.1。</b>  <b>计划协程的队列</b> <br><br><ul><li>  <i>EventLoop.create_task</i>参数：协程运行。 调度程序将协程式排队以便尽快启动。  <i>create_task</i>调用立即返回。 使用带有必要参数的函数调用的语法指定参数中的协程。 </li><li>  <i>EventLoop.run_until_complete</i>参数：协程运行。 调度程序将协程式排队以便尽快启动。 使用带有必要参数的函数调用的语法指定参数中的协程。 协程完成后，将返回<i>un_until_complete</i>调用：此方法提供了一种退出调度程序的方法。 </li><li>  <i>await</i>参数：要运行的协程，使用函数调用语法指定。 尽快启动协程。 待处理的协程被阻塞，直到预期的协程之一完成。 </li></ul><br> 以上与<b>CPython</b>兼容。 注释（第2.2.3节） <b><i>中</i></b>讨论了其他<b><i>uasyncio</i></b>方法。 <br><br>  <b>2.2.2启动回调函数</b> <br><br> 回调应该是旨在在短时间内执行的<b>Python</b>函数。 这是由于协程在整个功能执行期间将无法工作的事实。 <br><br> 以下<b><i>EventLoop</i></b>类<b><i>方法</i></b>使用回调： <br><br><ol><li>  <i>call_soon-</i>尽快致电。  Args：要运行的<i>回调</i>回调， <i>* args</i>任何位置参数后都可以带逗号。 </li><li>  <i>call_later-</i>延迟几秒钟后调用。  Args： <i>延迟，回调，* args</i> </li><li>  <i>call_later_ms-</i>延迟毫秒后调用。  Args： <i>延迟，回调，* args</i> 。 </li></ol><br><pre> <code class="python hljs">loop = asyncio.get_event_loop () loop.call_soon ( foo , <span class="hljs-number"><span class="hljs-number">5</span></span> ) <span class="hljs-comment"><span class="hljs-comment">#    'foo'      5. loop.call_later ( 2 , foo , 5 ) #   2 . loop.call_later_ms ( 50 , foo , 5 ) #   50 . loop.run_forever ()</span></span></code> </pre><br>  <b>2.2.3注意事项</b> <br><br> 协程可以包含带有任意返回值的<i>return</i>语句。 要获得此值： <br><br><pre> <code class="python hljs">result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> my_coro ()</code> </pre><br> 协程可以受方法限制，并且必须至少包含一个<i>await</i>语句。 <br><br>  <b>2.3延误</b> <br><br> 组织协程的延迟有两种选择。 对于较长的延迟以及在持续时间不需要精确的情况下，可以使用： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( delay_secs , delay_ms )</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep ( delay_secs ) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> ( <span class="hljs-string"><span class="hljs-string">'Hello'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep_ms ( delay_ms )</code> </pre><br> 在此类延迟期间，调度程序将执行其他协程。 这可能会引入时间不确定性，因为调用协程仅在执行当前正在运行的协程时才会启动。 延迟量取决于应用程序开发人员，但可能约为数十或数百毫秒。 与硬件设备的交互（第6节）中将进一步讨论。 <br><br> 使用<i>utime</i>函数<i>-sleep_ms</i>和<i>sleep_us</i>可以执行非常精确的延迟。 它们最适合短延迟，因为在延迟进行期间，调度程序将无法执行其他协程。 <br><br>  <b>3.同步</b> <br><br> 通常，需要确保协程之间的同步。 一个常见的示例是在几个协程同时要求访问同一资源时避免所谓的“竞争条件”。 在<b><i>astests.py中</i></b>提供了一个示例，并在<a href="" rel="nofollow">文档中进行</a>了讨论。 当每个协程等待对方完成时，另一个危险是“死亡拥抱”。 <br><br> 在简单的应用程序中，可以使用全局标志或相关变量来实现同步。 一种更优雅的方法是使用同步类。  <b><i>asyn.py</i></b>模块提供<i><b>Event，Barrier，Semaphore</b></i>和<i><b>Conditios</b></i>类的“微型”实现，仅用于<b><i>asyncio</i></b> 。 除非另有说明，否则它们不是面向线程的，不应与<b><i>_thread</i></b>模块或中断处理程序一起使用。  <i><b>Lock</b></i>类也已实现，它是正式实现的替代方法。 <br><br> 协程生产者和协程消耗者出现另一个同步问题。 协程生产者生成协程消费者使用的数据。 为此， <b><i>asyncio</i></b>提供了<i><b>Queue</b></i>类。 协程生产者将数据放入队列中，而协程消费者正在等待其完成（按计划安排其他操作）。  <i><b>Queue</b></i>类可保证按接收顺序删除项目。 另外，如果生产者协程必须等到消费者协程准备访问数据，则可以使用<i><b>Barrier</b></i>类。 <br><br> 下面是这些类的简要概述。  <a href="" rel="nofollow">完整文档中有</a>更多详细信息。 <br><br>  <b>3.1 <a href="" rel="nofollow"><i>锁</i></a></b> <br><br>  <i><b>锁定可</b></i>确保对共享资源的唯一访问。 下面的代码示例创建<i>锁</i>类<b><i>Lock</i></b>的实例，该实例将传递给想要访问共享资源的所有客户端。 每个协程试图捕获锁，并暂停执行直到成功： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> uasyncio.synchro <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Lock <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">task</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, lock)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> lock.acquire() print(<span class="hljs-string"><span class="hljs-string">"Acquired lock in task"</span></span>, i) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">0.5</span></span>) lock.release() <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">killer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">10</span></span>) loop = asyncio.get_event_loop() lock = Lock() <span class="hljs-comment"><span class="hljs-comment"># The global Lock instance loop.create_task(task(1, lock)) loop.create_task(task(2, lock)) loop.create_task(task(3, lock)) loop.run_until_complete(killer()) #  10s</span></span></code> </pre><br>  <b>3.1.1锁定和超时</b> <br><br> 在撰写本文时（2018年1月5日）， <i><b>uasycio</b></i> <i>Lock</i>类的开发尚未正式完成。 如果协程有<u>超时（第5.2.2节）</u> ，则在触发触发时等待锁定时，超时将无效。 直到收到锁，它才会收到<i>TimeoutError</i> 。 取消任务也是如此。 <br><br>  <b><i>asyn.py</i></b>模块提供<a href="" rel="nofollow"><b><i>Lock</i></b></a>类，在这些情况下可以使用。 该类的实现不如正式类有效，但根据<b>CPython</b>版本支持其他接口，包括使用上下文管理器。 <br><br>  <b>3.2事件</b> <br><br>  <b><i>事件</i></b>为一个或几个协程暂停提供了机会，而另一个则发出了延续的信号。  <b>Event</b>实例可用于使用它的所有协程： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyn event = asyn.Event ()</code> </pre><br> 协程通过声明<i>await事件来等待事件</i> ，此后执行暂停，直到其他协程声明<i>event.set（）</i>为止。  <a href="" rel="nofollow">完整的信息</a> 。 <br><br> 如果在循环构造中发出<i>event.set（），</i>则可能会出现问题。 该代码必须等待，直到所有待处理的对象都可以访问该事件，然后才能再次进行设置。 如果某个<b>Coro</b>希望发生事件，可以通过接收清除事件的<b>Coro</b>事件来实现： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eventwait</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( event )</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> event event.clear()</code> </pre><br> 触发事件的协程检查它是否已被服务： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( event )</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> : <span class="hljs-comment"><span class="hljs-comment">#   - while event.is_set (): await asyncio.sleep ( 1 ) # ,  coro   event.set ()</span></span></code> </pre><br> 如果多个<b>角色</b>正在等待一个事件的同步，则可以使用确认事件解决问题。 每个<b>Coro</b>需要一个单独的事件。 <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eventwait</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(  , ack_event )</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> event ack_event.set ()</code> </pre><br> 在<i><b>asyntest.py</b></i>的<i>event_test</i>函数中给出了一个示例。 这很麻烦在大多数情况下-即使有一个等待的<b>Coro-</b>如下所示的<b>Barrier</b>类也提供了一种更简单的方法。 <br> 事件还可以提供中断处理程序和<b>coro</b>之间的通信方式。 处理程序维护硬件并设置事件，该事件已由正常模式下的<b>coro</b>检查。 <br><br>  <b>3.2.1事件值</b> <br><br>  <i>event.set（）</i>方法可以采用任何类型的可选数据值。 等待事件的<b>Coro</b>可以使用<i>event.value（）</i>来获取它。 请注意， <i>event.clear（）</i>将设置为<i>None</i> 。 在事件设置中，此方法的典型用法是发出<i>event.set（utime.ticks_ms（））</i> 。 任何等待事件的事件可以确定发生的延迟，例如，以对此进行补偿。 <br><br>  <b>3.3 <a href="" rel="nofollow"><i>障碍</i></a></b> <br><br>  <b><i>Barrier</i></b>类有两种用途。 <br><br> 首先，它可以暂停协程直到一个或几个其他协程完成。 <br><br> 其次，它允许几个协程在某个点相遇。 例如，生产者和消费者可以在生产者拥有数据并且消费者准备使用它的时刻进行同步。 在执行时， <b>屏障</b>可能会在移除屏障之前发出附加的回调，并且所有未决事件可能会继续。 <br><br> 回调可以是函数或协程。 在大多数应用程序中，最有可能会使用该功能：可以确保在完成之前，移除障碍之前执行该功能。 <br><br> 一个示例是<i>asyntest.py</i>中的<i>barrier_test</i>函数。 在该程序的代码段中： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyn <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(text)</span></span></span><span class="hljs-function">:</span></span> print(text) barrier = asyn.Barrier(<span class="hljs-number"><span class="hljs-number">3</span></span>, callback, (<span class="hljs-string"><span class="hljs-string">'Synch'</span></span>,)) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">report</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">5</span></span>): print(<span class="hljs-string"><span class="hljs-string">'{} '</span></span>.format(i), end=<span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> barrier</code> </pre> <br>  <i>报告</i>协程的几个实例将打印其结果并暂停，直到其他实例也完成并等待<b>障碍</b>继续。 此时，正在进行回调。 完成后，原始协程将恢复。 <br><br>  <b>3.4信号量</b> <br><br> 信号量限制了可以访问资源的协程的数量。 它可以用来限制可以同时运行的特定协程的实例数量。 这是使用访问计数器完成的，访问计数器由构造函数初始化，并在协程程序每次收到信号量时减少。 <br><br> 在上下文管理器中使用它的最简单方法是： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyn sema = asyn.Semaphore(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sema)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> sema: <span class="hljs-comment"><span class="hljs-comment">#   </span></span></code> </pre><br> 一个示例是<i><b>asyntest.py中</b></i>的<i>semaphore_test</i>函数。 <br><br>  <b>3.4.1（ <a href="" rel="nofollow"><i>Limited</i></a> ）信号量</b> <br><br> 它与<i><b>Semaphore</b></i>类的工作方式相似，不同之处在于，如果<i>释放</i>方法导致访问计数器超过其初始值， <i>则会</i>设置<i>ValueError</i> 。 <br><br>  <b>3.5排队</b> <br><br>  <i><b>Queue</b></i>类由官方<i><b>uasycio</b></i>维护，而<i><b>aqtest.py</b></i>示例程序演示了其用法。 队列创建如下： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> uasyncio.queues <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Queue q = Queue ()</code> </pre><br> 典型的制造商协程可以按以下方式工作： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">producer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(q)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> slow_process() <span class="hljs-comment"><span class="hljs-comment">#       await q.put(result) #  ,       </span></span></code> </pre><br> 消费者协程可以按以下方式工作： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">consumer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(q)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span>(q.get()) <span class="hljs-comment"><span class="hljs-comment"># ,  q  print('Result was {}'.format(result))</span></span></code> </pre><br> 当可以限制队列的大小并且可以轮询状态时， <i><b>Queue</b></i>类提供了重要的附加功能。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以控制队列为空的行为（如果大小受限制）和队列已满的行为。有关此文档，请参见代码。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.6其他同步类</font></font></b> <font style="vertical-align: inherit;"><i><b><font style="vertical-align: inherit;">asyn.py</font></b></i></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">库</font><font style="vertical-align: inherit;">提供了</font><b><font style="vertical-align: inherit;">CPython</font></b><font style="vertical-align: inherit;">其他一些功能的微型实现</font><font style="vertical-align: inherit;">。</font><a href="" rel="nofollow"><b><i><font style="vertical-align: inherit;">Condition</font></i></b></a><font style="vertical-align: inherit;">类</font><font style="vertical-align: inherit;">允许协程通知等待锁定资源的其他协程。收到通知后，他们将可以访问资源并依次解锁。通知协程可能会限制要通知的协程的数量。</font><font style="vertical-align: inherit;">班级</font><a href="" rel="nofollow"><b><i><font style="vertical-align: inherit;">聚会</font></i></b></a></font><i><b><font style="vertical-align: inherit;"></font></b></i><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><a href="" rel="nofollow"><b><i><font style="vertical-align: inherit;"></font></i></b></a><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><a href="" rel="nofollow"><b><i><font style="vertical-align: inherit;"></font></i></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">允许您运行协程列表。后者完成后，将返回结果列表。此“微”实现使用不同的语法。超时可以应用于任何协程。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步</font></font></i></b> <font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;">开发类</font></b></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在开发设备驱动程序的上下文中，目标是确保它们不阻塞地工作。协程驱动程序必须确保在驱动程序等待设备执行硬件操作时执行其他协程。例如，等待数据到达UART的任务或用户按下按钮的操作应允许安排其他事件，直到事件发生为止。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.1使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">await</font></font></i></b> <font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;">等待的类</font></b><b><i><font style="vertical-align: inherit;">协程</font></i></b></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以在等待对象时暂停执行</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值得期待的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPython下，</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过实现</font><font style="vertical-align: inherit;">生成器返回</font><font style="vertical-align: inherit;">的特殊</font><i><font style="vertical-align: inherit;">__await__</font></i><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">来</font><font style="vertical-align: inherit;">创建</font><font style="vertical-align: inherit;">自定义的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等待</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类</font><font style="vertical-align: inherit;">。</font><i><font style="vertical-align: inherit;">等待</font></i><font style="vertical-align: inherit;">类</font><i><font style="vertical-align: inherit;">的</font></i><font style="vertical-align: inherit;">用法如下：</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">()</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__await__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">5</span></span>): print(<span class="hljs-string"><span class="hljs-string">'__await__ called'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">#     return 42 __iter__ = __await__ # .   async def bar(): foo = Foo() # Foo - awaitable  print('waiting for foo') res = await foo #   print('done', res) loop = asyncio.get_event_loop() loop.run_until_complete(bar())</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目前</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MicroPython</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不支持</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__await__</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><a href="http://github.com/micropython/micropython/issues/2678" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题＃2678</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）和解决方案中使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__iter__</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。字符串</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__iter__ = __await__</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提供了</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPython</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MicroPython</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之间的可移植性</font><font style="vertical-align: inherit;">。代码示例，请参阅类</font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事件，道闸，撤销，条件</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asyn.py</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.1.1在上下文管理器中使用</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">期望的对象可以在同步或异步上下文管理器中使用，提供必要的特殊方法。语法：</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> awaitable <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> a: <span class="hljs-comment"><span class="hljs-comment">#  'as'   #    async with awaitable as a: #    (.) #  -</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为此，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__await__</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生成器必须返回</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">self</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这将传递给</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">子句</font><font style="vertical-align: inherit;">中的任何变量</font><font style="vertical-align: inherit;">，并且还允许特殊方法起作用。请参阅</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asyn.Condition</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asyntest.condition_test</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，其中</font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Condition</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类</font><font style="vertical-align: inherit;">使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">await，</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且可以在同步上下文管理器中使用。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.1.2等待协同程序</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">语言</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python的</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要求</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__await__</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是发电机的功能。在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MicroPython中，</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生成器和协程是相同的，因此解决方案是使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coro（args）的yield</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本指南的目的是提供可移植到</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPython 3.5</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或更高版本的代码。在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPython中，</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生成器和协程的含义不同。在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPython中，</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">协程具有</font><font style="vertical-align: inherit;">生成器检索</font><font style="vertical-align: inherit;">的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__await__</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特殊方法。这是便携式的：</font></font><br><br><pre> <code class="python hljs">up = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-comment"><span class="hljs-comment">#   MicroPython? try: import uasyncio as asyncio up = True #    sys.implementation.name except ImportError: import asyncio async def times_two(n): # Coro   await asyncio.sleep(1) return 2 * n class Foo(): def __await__(self): res = 1 for n in range(5): print('__await__ called') if up: # MicroPython res = yield from times_two(res) else: # CPython res = yield from times_two(res).__await__() return res __iter__ = __await__ async def bar(): foo = Foo() # foo is awaitable print('waiting for foo') res = await foo #   print('done', res) loop = asyncio.get_event_loop() loop.run_until_complete(bar())</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请注意，</font><b><font style="vertical-align: inherit;">CPython</font></b><font style="vertical-align: inherit;">允许</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__await__，从asyncio.sleep（1）产生</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我仍然不知道如何实现这一目标。</font><b><font style="vertical-align: inherit;">4.2异步迭代器</font></b><font style="vertical-align: inherit;">异步迭代器提供了一种返回有限或无限值序列的方法，并且可以用作检索来自只读设备的顺序数据元素的方法。</font><font style="vertical-align: inherit;">异步迭代器在其</font><i><font style="vertical-align: inherit;">下一个</font></i><font style="vertical-align: inherit;">方法中调用异步代码</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">该课程必须满足以下要求：</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br> <b><font style="vertical-align: inherit;"></font></b> <br><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它有一个</font><font style="vertical-align: inherit;">在</font><i><font style="vertical-align: inherit;">异步def中</font></i><font style="vertical-align: inherit;">定义</font><font style="vertical-align: inherit;">的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__aiter__</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">并返回一个异步迭代器。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它有一个</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__anext__</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">，它本身就是一个协程-通过</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步def</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定义</font><font style="vertical-align: inherit;">并包含至少一个</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">await</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">语句</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">要停止迭代，它必须引发</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StopAsyncIteration</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异常。</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">序列值使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检索</font><font style="vertical-align: inherit;">，如下所示：</font></font><br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsyncIterable</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.data = (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) self.index = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__aiter__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__anext__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> self.fetch_data() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> StopAsyncIteration <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">0.1</span></span>) <span class="hljs-comment"><span class="hljs-comment">#     if self.index &gt;= len(self.data): return None x = self.data[self.index] self.index += 1 return x async def run(): ai = AsyncIterable() async for x in ai: print(x)</span></span></code> </pre><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.3异步上下文管理器</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以将类设计为支持异步上下文管理器，这些异步上下文管理器具有作为共同程序的进入和退出过程。一个例子是上述的</font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">锁</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类</font><font style="vertical-align: inherit;">。它具有</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__aenter__</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">协程</font><font style="vertical-align: inherit;">，这在异步操作上在逻辑上是必需的。为了支持上下文管理器的异步协议，其</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__aexit__</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法也必须是协程，这可以通过包含</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">await asyncio.sleep（0）来实现</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。可从协程内部使用以下语法访问此类：</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( lock )</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> lock: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> ( « bar » )</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与常规上下文管理器一样，保证在上下文管理器照常完成工作并通过异常时调用exit方法。为了实现此目标，</font><font style="vertical-align: inherit;">必须</font><i><font style="vertical-align: inherit;">使用</font></i><font style="vertical-align: inherit;">特殊方法</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__aenter__</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__aexit__</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它们必须定义为等待另一个协程或</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等待</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对象的</font><font style="vertical-align: inherit;">协程</font><font style="vertical-align: inherit;">。这个例子来自</font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lock</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类</font><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__aenter__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> self.acquire() <span class="hljs-comment"><span class="hljs-comment"># a coro    async def return self async def __aexit__(self, *args): self.release() #   await asyncio.sleep_ms(0)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async with</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包含一个</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as变量</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">子句</font><font style="vertical-align: inherit;">，则该变量获取</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__aenter__</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回的值</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为确保正确的行为，固件必须为V1.9.10或更高版本。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.超时和由于任务取消引起的异常</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这些主题相关：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包括取消任务并对任务应用超时，以特殊方式为任务引发异常。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.1例外情况</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果协程中发生过外显子，则必须在此协程中或在协程中对其进行处理以等待其完成。这样可以确保该异常不适用于调度程序。如果发生异常，则调度程序将通过将异常传递给调度程序启动的代码来停止工作。因此，为避免调度程序停止，使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">loop.create_task（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">启动的协程</font><font style="vertical-align: inherit;">必须捕获内部的任何异常。</font><font style="vertical-align: inherit;">在协程中</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">throw</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">close </font></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">抛出</font></i><font style="vertical-align: inherit;">异常是不合理的。这破坏了</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，导致协程启动，并可能在协程仍在执行队列中时</font><b><font style="vertical-align: inherit;">退出</font></b><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上面的示例说明了这种情况。如果允许工作到最后，它将按预期工作。</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">3</span></span>) print(<span class="hljs-string"><span class="hljs-string">'About to throw exception.'</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> foo() <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ZeroDivisionError: print(<span class="hljs-string"><span class="hljs-string">'foo  -   0'</span></span>) <span class="hljs-comment"><span class="hljs-comment"># ! raise #     . except KeyboardInterrupt: print('foo was interrupted by ctrl-c') #   ! raise async def shutdown(): print('Shutdown is running.') #     await asyncio.sleep(1) print('done') loop = asyncio.get_event_loop() try: loop.run_until_complete(bar()) except ZeroDivisionError: loop.run_until_complete(shutdown()) except KeyboardInterrupt: print('Keyboard interrupt at loop level.') loop.run_until_complete(shutdown())</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，发出键盘中断会使异常进入事件循环。这是因为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio.sleep</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的执行</font><font style="vertical-align: inherit;">被传递到事件循环。因此，需要清晰代码来响应键盘中断的应用程序必须在事件循环级别捕获异常。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.2取消和超时</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如上所述，这些函数通过使用特殊的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MicroPython</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">coroutine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pend_throw</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以特殊的方式为任务</font><b><font style="vertical-align: inherit;">抛出</font></b><font style="vertical-align: inherit;">异常来工作</font><font style="vertical-align: inherit;">。它的工作方式取决于版本。在正式的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio v.2.0中，</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直到下一个计划任务才处理异常。如果任务预期进入</font><i><font style="vertical-align: inherit;">睡眠状态，</font></i><font style="vertical-align: inherit;">则会造成延迟</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">输入输出 </font><font style="vertical-align: inherit;">超时可能会超出其标称期限。</font><font style="vertical-align: inherit;">其他任务的撤消任务无法确定撤消完成的时间。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当前有一个解决方法和两个解决方案。</font></font><br><br><ul><li><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决方法</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font><b><font style="vertical-align: inherit;">asyn</font></b><font style="vertical-align: inherit;">库</font><font style="vertical-align: inherit;">提供了一种等待任务或任务组被取消的方法。</font><font style="vertical-align: inherit;">请参阅取消作业（第5.2.1节）。</font></font></li><li> <a href="http://github.com/pfalcon/pycopy-lib" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paul Sokolovsky库</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提供</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio v2.4</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但这需要其</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pycopy</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">固件</font><font style="vertical-align: inherit;">。</font></font></li><li> <a href="" rel="nofollow"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fast_io</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">库</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决了这个问题</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了Python</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（优雅地少）和运行官方固件。</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处使用的异常的层次结构是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exception-CanceledError-TimeoutError</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.2.1取消作业</font></font></b> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提供</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">取消（Coro）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">功能</font><font style="vertical-align: inherit;">。这通过抛出异常来使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pend_throw</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">协程来工作</font><font style="vertical-align: inherit;">。它也适用于嵌套的协程。用法如下：</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-comment"><span class="hljs-comment">#  -  10 secs await asyncio.sleep(10) async def bar(loop): foo_instance = foo() #   coro loop.create_task(foo_instance) # code omitted asyncio.cancel(foo_instance)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果此示例在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio v2.0</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下运行</font><font style="vertical-align: inherit;">，则在</font><i><font style="vertical-align: inherit;">取消</font></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bar</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题</font><font style="vertical-align: inherit;">时，</font><font style="vertical-align: inherit;">直到下一个计划的</font><i><font style="vertical-align: inherit;">foo</font></i><font style="vertical-align: inherit;">都不会生效</font><i><font style="vertical-align: inherit;">，</font></i><font style="vertical-align: inherit;">而取消</font><i><font style="vertical-align: inherit;">foo</font></i><font style="vertical-align: inherit;">时</font><font style="vertical-align: inherit;">可能会延迟10秒。如果</font><i><font style="vertical-align: inherit;">foo正在</font></i><font style="vertical-align: inherit;">等待I / O，</font><font style="vertical-align: inherit;">则将导致另一个延迟源</font><font style="vertical-align: inherit;">。无论延迟发生在何处，</font><i><font style="vertical-align: inherit;">bar</font></i><font style="vertical-align: inherit;">将无法确定</font><i><font style="vertical-align: inherit;">foo是否已</font></i><font style="vertical-align: inherit;">取消。在某些用例中，这很重要。</font><font style="vertical-align: inherit;">使用</font><b><font style="vertical-align: inherit;">Paul Sokolovsky</font></b><font style="vertical-align: inherit;">或</font><b><font style="vertical-align: inherit;">fast_io库时，</font></b><font style="vertical-align: inherit;">使用sleep（0）</font><b><font style="vertical-align: inherit;">就</font></b><font style="vertical-align: inherit;">足够了：</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-comment"><span class="hljs-comment">#  -  10 secs await asyncio.sleep(10) async def bar(loop): foo_instance = foo() #   coro loop.create_task(foo_instance) #    asyncio.cancel(foo_instance) await asyncio.sleep(0) #   </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果</font><i><font style="vertical-align: inherit;">foo</font></i><font style="vertical-align: inherit;">（以及任何待处理的协程</font><i><font style="vertical-align: inherit;">foo</font></i><font style="vertical-align: inherit;">）从未</font><font style="vertical-align: inherit;">返回</font><i><font style="vertical-align: inherit;">睡眠</font></i><font style="vertical-align: inherit;">并且不等待I / O，</font><font style="vertical-align: inherit;">则</font><font style="vertical-align: inherit;">这也将在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio v2.0中</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">工作</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">当由</font><i><font style="vertical-align: inherit;">create_task</font></i><font style="vertical-align: inherit;">运行</font><font style="vertical-align: inherit;">并处于待机模式</font><font style="vertical-align: inherit;">的协程被取消时，可能会发生使粗心大意的行为</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">考虑以下代码段：</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-comment"><span class="hljs-comment">#  -  10 secs await asyncio.sleep(10) async def foo_runner(foo_instance): await foo_instance print('   ') async def bar(loop): foo_instance = foo() loop.create_task(foo_runner(foo_instance)) #    asyncio.cancel(foo_instance)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FOO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">被取消，它是从调度器队列中删除; </font><font style="vertical-align: inherit;">因为它没有</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">语句，所以调用过程</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">foo_runner</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从不恢复。</font><font style="vertical-align: inherit;">建议始终在要撤消的函数的最外部范围中捕获异常：</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> my_coro <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> asyncio.CancelledError: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这种情况下，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">my_coro</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不需要捕获异常，因为它将被传播到调用通道并在此捕获。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意事项如果</font><font style="vertical-align: inherit;">在调度程序之外使用协程</font><font style="vertical-align: inherit;">，则禁止使用</font><font style="vertical-align: inherit;">协程的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关闭</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抛出</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法。这会破坏调度程序，迫使协程即使未调度代码也要执行代码。这可能会产生不良后果。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.2.2具有超时</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">协程</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">超时是使用</font><b><font style="vertical-align: inherit;">uasyncio</font></b><font style="vertical-align: inherit;">方法</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.wait_for（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.wait_for_ms（）实现的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。它们分别以协程和等待时间（以秒或毫秒为单位）作为参数。如果超时到期，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TimeoutError</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pend_throw</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">扔进协程</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">用户或调用者必须捕获此异常。</font><font style="vertical-align: inherit;">由于上述原因，这是必要的：如果超时到期，则取消超时。</font><font style="vertical-align: inherit;">除非捕获并返回了错误，否则调用者可以继续的唯一方法是捕获异常本身。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在协程程序捕获到异常的地方，如果异常未在外部范围中捕获，则我无法清除失败，如下所示：</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forever</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: print(<span class="hljs-string"><span class="hljs-string">'Starting'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep_ms(<span class="hljs-number"><span class="hljs-number">300</span></span>) print(<span class="hljs-string"><span class="hljs-string">'Got here'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> asyncio.TimeoutError: print(<span class="hljs-string"><span class="hljs-string">'Got timeout'</span></span>) <span class="hljs-comment"><span class="hljs-comment"># And return async def foo(): await asyncio.wait_for(forever(), 5) await asyncio.sleep(2) loop = asyncio.get_event_loop() loop.run_until_complete(foo())</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 另外，您可以拦截调用函数： </font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forever</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">'Starting'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep_ms(<span class="hljs-number"><span class="hljs-number">300</span></span>) print(<span class="hljs-string"><span class="hljs-string">'Got here'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.wait_for(forever(), <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> asyncio.TimeoutError: <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> print(<span class="hljs-string"><span class="hljs-string">'Timeout elapsed.'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>) loop = asyncio.get_event_loop() loop.run_until_complete(foo())</code> </pre><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uasyncio v2.0的</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意事项</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这不适用于</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paul Sokolovsky</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fast_io库</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果协程启动</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等待asyncio.sleep（t）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并延迟了很长的时间t，协程将不会重新启动，直到</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到期为止</font><font style="vertical-align: inherit;">。如果在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">睡眠</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结束之前已经超时</font><font style="vertical-align: inherit;">，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">则</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在重新加载协程时</font><font style="vertical-align: inherit;">将</font><i><font style="vertical-align: inherit;">发生TimeoutError-</font></i><font style="vertical-align: inherit;">即当</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到期时</font><font style="vertical-align: inherit;">。从调用者的角度实时而言，他的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TimeoutError</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">响应</font><font style="vertical-align: inherit;">将被延迟。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果这对于应用程序很重要，请在等待循环中的短暂延迟时创建较长的延迟。协程</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asyn.sleep</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">支持这一点。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6与设备</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的交互</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与外部异步事件</font><font style="vertical-align: inherit;">之间交互的基础</font><font style="vertical-align: inherit;">是轮询。需要快速响应的硬件可能会使用中断。但是，中断例程（ISR）与用户协程之间的交互将基于轮询。例如，ISR可以调用</font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事件</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或设置全局标志，而每次调度请求时，等待结果的协程会轮询对象。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以两种方式进行询问，即显式或隐式。后者是使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">流I / O完成的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一种机制，是一种用于</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UART</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">套接字</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等流设备的系统</font><font style="vertical-align: inherit;">。在最简单的显式轮询中，以下代码可能包含：</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">poll_my_device</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> my_flag <span class="hljs-comment"><span class="hljs-comment">#   ISR while True: if my_flag: my_flag = False # service the device await asyncio.sleep(0)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以使用</font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Event</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类的实例变量</font><font style="vertical-align: inherit;">或使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">await</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的类的实例</font><font style="vertical-align: inherit;">代替全局标志</font><font style="vertical-align: inherit;">。显式调查将在下面讨论。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">隐式轮询包括开发一个驱动程序，该驱动程序将用作流I / O设备，例如</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UART</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font><i><font style="vertical-align: inherit;">流I / O </font></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">套接字</font></font></i> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，该驱动程序使用</font><i><font style="vertical-align: inherit;">select.poll </font></i><b><font style="vertical-align: inherit;">Python</font></b><font style="vertical-align: inherit;">系统对设备进行</font><font style="vertical-align: inherit;">轮询：由于轮询是在C语言中执行的，因此它比C语言更快，更高效明确的民意调查。在第6.3节中讨论了流I / O的使用。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i> <b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于其有效性，隐式轮询为最快的I / O设备驱动程序提供了一个优势：可以为通常不视为流设备的许多设备创建流驱动程序。这将在6.4节中详细讨论。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.1同步问题</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当前的显式和隐式轮询均基于周期性计划。假设I / O与N个自定义协程同时工作，每个协程以零延迟运行。提供I / O后，将在安排所有用户操作后立即对其进行轮询。设计时应考虑估计的延迟。 I / O通道可能需要使用ISR服务设备从缓冲区和协程进行实时缓冲，以较慢的时间填充或释放缓冲区。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还必须考虑超越的可能性：这种情况是当协程实际询问的某件事在协程实际计划之前多次发生的情况。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另一个时序问题是延迟准确性。如果协程出现问题</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep_ms ( t ) <span class="hljs-comment"><span class="hljs-comment">#  </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调度程序保证执行将至少暂停t ms。实际延迟可能大于t，这取决于当前系统负载。如果此时其他协程正在等待非零延迟的完成，则将立即安排执行下一行。但是，如果其他协程也等待执行（因为它们发出了零延迟，或者因为它们的时间也已到期），则可以安排它们更早地执行。这将同步不确定性引入了</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sleep（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sleep_ms（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数。可以通过将所有此类协程的运行时值相加来确定此溢出的最坏情况值，以确定到调度程序的最坏情况传输时间。</font></font><br><br> <b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这种情况下</font><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio </font></font></b><font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;">的fast_io</font></b><font style="vertical-align: inherit;">版本</font><font style="vertical-align: inherit;">提供了一种确保在调度程序的每次迭代时都将轮询流I / O的方法。希望正式的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">会在适当的时候接受相关的修订。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.2使用协程查询设备</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是一种简单的方法，最适用于可以以较低速度查询的设备。这主要是由于以下事实：以短（或零）轮询间隔进行轮询可能导致以下事实：协程消耗的处理器时间多于进入该间隔所需的时间。</font><i><b><font style="vertical-align: inherit;">apoll.py</font></b></i></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">示例</font><font style="vertical-align: inherit;">通过查询</font><b><font style="vertical-align: inherit;">Pyboard</font></b><font style="vertical-align: inherit;">加速度计演示了这种方法</font></font><i><b><font style="vertical-align: inherit;"></font></b></i><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">间隔为100毫秒。它执行简单的过滤以忽略噪声，如果没有移动，则每两秒钟打印一条消息。</font><i><b><font style="vertical-align: inherit;">aswitch.py</font></b></i></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">示例</font><font style="vertical-align: inherit;">提供了用于开关和按钮设备的驱动程序。</font><font style="vertical-align: inherit;">下面显示了能够读取和写入的设备的示例驱动程序。为了便于测试，</font><b><font style="vertical-align: inherit;">Pyboard</font></b><font style="vertical-align: inherit;"> UART 4模拟了条件设备。驱动程序实现</font><b><i><font style="vertical-align: inherit;">RecordOrientedUart</font></i></b><font style="vertical-align: inherit;">类</font></font><i><b><font style="vertical-align: inherit;"></font></b></i><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><i><font style="vertical-align: inherit;"></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，其中数据以字节实例组成的可变长度记录形式提供。该对象在发送之前添加定界符，并缓冲传入的数据，直到收到添加的定界符。与流输入/输出相比，这只是使用UART的演示，并且效率低下。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了演示异步传输，我们假设仿真设备具有一种验证传输完成以及应用程序需要我们等待的方法。在此示例中，所有假设都不成立，但是代码通过</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asyncio.sleep（0.1）来</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">伪造它</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，请不要忘记连接</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pyboard</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> X1和X2 </font><font style="vertical-align: inherit;">的输出</font><font style="vertical-align: inherit;">（UART Txd和Rxd）</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pyb <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UART <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RecordOrientedUart</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">()</span></span></span><span class="hljs-class">:</span></span> DELIMITER = <span class="hljs-string"><span class="hljs-string">b'\0'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.uart = UART(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">9600</span></span>) self.data = <span class="hljs-string"><span class="hljs-string">b''</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__iter__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Not __await__ issue #2678 data = b'' while not data.endswith(self.DELIMITER): yield from asyncio.sleep(0) # ,  : while not self.uart.any(): yield from asyncio.sleep(0) # timing may mean this is never called data = b''.join((data, self.uart.read(self.uart.any()))) self.data = data async def send_record(self, data): data = b''.join((data, self.DELIMITER)) self.uart.write(data) await self._send_complete() #          #        await asyncio.sleep(0) async def _send_complete(self): await asyncio.sleep(0.1) def read_record(self): # Synchronous: await the object before calling return self.data[0:-1] # Discard delimiter async def run(): foo = RecordOrientedUart() rx_data = b'' await foo.send_record(b'A line of text.') for _ in range(20): await foo #  coros       foo rx_data = foo.read_record() print('Got: {}'.format(rx_data)) await foo.send_record(rx_data) rx_data = b'' loop = asyncio.get_event_loop() loop.run_until_complete(run())</span></span></code> </pre><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3使用流机构（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">流</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本实施例表明在单个UART的微处理器输入和输出同时</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pyboard</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，连接</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pyboard</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> X1和X2 </font><font style="vertical-align: inherit;">的输出</font><font style="vertical-align: inherit;">（UART Txd和Rxd）</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pyb <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UART uart = UART(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">9600</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sender</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> swriter = asyncio.StreamWriter(uart, {}) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> swriter.awrite(<span class="hljs-string"><span class="hljs-string">'Hello uart\n'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receiver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> sreader = asyncio.StreamReader(uart) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: res = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> sreader.readline() print(<span class="hljs-string"><span class="hljs-string">'Received'</span></span>, res) loop = asyncio.get_event_loop() loop.create_task(sender()) loop.create_task(receiver()) loop.run_forever()</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">支持代码可以</font><font style="vertical-align: inherit;">在</font><b><font style="vertical-align: inherit;">uasyncio</font></b><font style="vertical-align: inherit;">库的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__init__.py</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中</font><font style="vertical-align: inherit;">找到</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">该机制之所以有效，是因为设备驱动程序（用</font><b><font style="vertical-align: inherit;">C</font></b><font style="vertical-align: inherit;">编写</font><font style="vertical-align: inherit;">）实现了以下方法：</font><i><font style="vertical-align: inherit;">ioctl，read，readline</font></i><font style="vertical-align: inherit;">和</font><i><font style="vertical-align: inherit;">write</font></i><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">第6.4节：编写流设备驱动程序，详细介绍了如何使用</font><b><font style="vertical-align: inherit;">Python</font></b><font style="vertical-align: inherit;">编写此类驱动程序</font><font style="vertical-align: inherit;">。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UART可以随时接收数据。每当调度程序获得控制权时，流I / O机制都会检查未决的传入字符。当协程运行时，中断例程将缓冲传入的字符；当协程让位给调度程序时，它们将被删除。因此，必须设计UART应用程序，以使协程最小化两次传输到调度程序之间的时间，以避免缓冲区溢出和数据丢失。这可以通过使用较大的UART读取缓冲区或较低的数据速率来改善。另外，如果数据源支持，硬件流控制将提供解决方案。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3.1 UART驱动的实施例</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方案</font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auart_hd.py</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图1示出了与半双工设备（诸如响应AT调制解调器命令集的设备）的通信方法。半双工意味着设备永远不会发送未经请求的数据：其传输总是响应于从主机接收到的命令而执行。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过在</font><font style="vertical-align: inherit;">具有两个有线连接</font><font style="vertical-align: inherit;">的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pyboard</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上运行测试来仿真设备</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（非常简化的）仿真设备通过发送四行数据，每行之间都有一个暂停来模拟慢速处理，从而对任何命令做出响应。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该向导将发送命令，但事先不知道将返回多少行数据。它启动一个重新启动计时器，该计时器在每次接收到一行时重新启动。当计时器到期时，假定设备已完成传输并返回接收到的线路列表。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还演示了设备故障情况，这是通过在等待响应之前跳过传输来实现的。超时后，将返回一个空列表。有关更多详细信息，请参见代码注释。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.4发展流的（驱动器</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">流</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）单元</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">流输入/输出机构（</font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">流I / O</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），用于控制流传输的操作的I / O设备，诸如UART和插座（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">插座</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）该机制可以由任何定期轮询的设备的驱动程序使用，方法是委派给使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">select</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的调度程序，该调度程序</font><font style="vertical-align: inherit;">轮询队列中任何设备的就绪状态。这比执行几个协程操作更有效，每个协程操作都会轮询设备，部分原因是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">select</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编写的</font><font style="vertical-align: inherit;">，并且还因为执行轮询的协程被延迟到被轮询对象返回就绪状态为止。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">能够服务于流输入/输出机制的设备驱动程序应优选支持</font><i><font style="vertical-align: inherit;">StreamReader，StreamWriter</font></i><font style="vertical-align: inherit;">方法</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。可读设备必须提供以下方法中的至少一种。请注意，这些是同步方法。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ioctl</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">（请参见下文）确保仅在有数据时才调用它们。应该使用尽可能多的数据尽快返回方法。</font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">readline（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回尽可能多的字符，最多返回任何换行符。如果使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamReader.readline（），</font></font></i> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">则为必需；</font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">读取（n）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回尽可能多的字符，但不超过</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。如果使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamReader.read（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font><i><font style="vertical-align: inherit;">StreamReader.readexactly（），</font></i><font style="vertical-align: inherit;">则为必需</font></font><i><font style="vertical-align: inherit;"></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建的驱动程序应提供以下立即返回的同步方法：</font><font style="vertical-align: inherit;">使用参数</font><i><font style="vertical-align: inherit;">buf，off，sz进行</font></i></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">写入</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">其中：</font><i><font style="vertical-align: inherit;">buf</font></i><font style="vertical-align: inherit;">是写缓冲区。</font><i><font style="vertical-align: inherit;">off-</font></i><font style="vertical-align: inherit;">偏移到要写入的第一个字符的缓冲区。</font><i><font style="vertical-align: inherit;">sz-</font></i><font style="vertical-align: inherit;">请求的要写入的字符数。</font><i><font style="vertical-align: inherit;">返回值</font></i><font style="vertical-align: inherit;">是实际写入的字符数（如果设备运行缓慢，则可能为1）。</font><i><font style="vertical-align: inherit;">ioctl</font></i><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">可确保仅在设备准备好接收数据时才调用它。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> <i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br> <i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br> <i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br> <i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有设备都必须提供一种</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ioctl</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">该方法</font><font style="vertical-align: inherit;">可轮询设备以确定其可用性状态。</font><font style="vertical-align: inherit;">读/写驱动程序的典型示例：</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> io MP_STREAM_POLL_RD = const(<span class="hljs-number"><span class="hljs-number">1</span></span>) MP_STREAM_POLL_WR = const(<span class="hljs-number"><span class="hljs-number">4</span></span>) MP_STREAM_POLL = const(<span class="hljs-number"><span class="hljs-number">3</span></span>) MP_STREAM_ERROR = const(<span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyIO</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(io.IOBase)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    def ioctl(self, req, arg): # see ports/stm32/uart.c ret = MP_STREAM_ERROR if req == MP_STREAM_POLL: ret = 0 if arg &amp; MP_STREAM_POLL_RD: if hardware_has_at_least_one_char_to_read: ret |= MP_STREAM_POLL_RD if arg &amp; MP_STREAM_POLL_WR: if hardware_can_accept_at_least_one_write_character: ret |= MP_STREAM_POLL_WR return ret</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下面是对</font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MillisecTimer</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类</font><font style="vertical-align: inherit;">等待延迟</font><font style="vertical-align: inherit;">的描述</font><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> utime <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> io MP_STREAM_POLL_RD = const(<span class="hljs-number"><span class="hljs-number">1</span></span>) MP_STREAM_POLL = const(<span class="hljs-number"><span class="hljs-number">3</span></span>) MP_STREAM_ERROR = const(<span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MillisecTimer</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(io.IOBase)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.end = <span class="hljs-number"><span class="hljs-number">0</span></span> self.sreader = asyncio.StreamReader(self) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__iter__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> self.sreader.readline() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__call__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, ms)</span></span></span><span class="hljs-function">:</span></span> self.end = utime.ticks_add(utime.ticks_ms(), ms) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">b'\n'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ioctl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, req, arg)</span></span></span><span class="hljs-function">:</span></span> ret = MP_STREAM_ERROR <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> req == MP_STREAM_POLL: ret = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> arg &amp; MP_STREAM_POLL_RD: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> utime.ticks_diff(utime.ticks_ms(), self.end) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>: ret |= MP_STREAM_POLL_RD <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 可以如下使用： </font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timer_test</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( n )</span></span></span><span class="hljs-function">:</span></span> timer = ms_timer.MillisecTimer () <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> timer ( <span class="hljs-number"><span class="hljs-number">30</span></span> ) <span class="hljs-comment"><span class="hljs-comment">#  30 </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与正式的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相比，与</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">awaitio.sleep_ms（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相比</font><b><font style="vertical-align: inherit;">，</font></b><font style="vertical-align: inherit;">这种实现没有任何优势</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">当协程程序期望零延迟时</font><font style="vertical-align: inherit;">，使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fast_io</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以在正常使用模式中提供更准确的延迟。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以使用I / O调度将事件与回调关联。这比轮询周期更有效，因为直到</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ioctl</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回就绪</font><font style="vertical-align: inherit;">状态时才计划轮询</font><font style="vertical-align: inherit;">。接下来，当回调改变状态时执行一个回调。</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> io MP_STREAM_POLL_RD = const(<span class="hljs-number"><span class="hljs-number">1</span></span>) MP_STREAM_POLL = const(<span class="hljs-number"><span class="hljs-number">3</span></span>) MP_STREAM_ERROR = const(<span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PinCall</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(io.IOBase)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, pin, *, cb_rise=None, cbr_args=</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span><span class="hljs-function"><span class="hljs-params">, cb_fall=None, cbf_args=</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> self.pin = pin self.cb_rise = cb_rise self.cbr_args = cbr_args self.cb_fall = cb_fall self.cbf_args = cbf_args self.pinval = pin.value() self.sreader = asyncio.StreamReader(self) loop = asyncio.get_event_loop() loop.create_task(self.run()) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> self.sreader.read(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, _)</span></span></span><span class="hljs-function">:</span></span> v = self.pinval <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> self.cb_rise <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: self.cb_rise(*self.cbr_args) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">b'\n'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> self.cb_fall <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: self.cb_fall(*self.cbf_args) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">b'\n'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ioctl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, req, arg)</span></span></span><span class="hljs-function">:</span></span> ret = MP_STREAM_ERROR <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> req == MP_STREAM_POLL: ret = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> arg &amp; MP_STREAM_POLL_RD: v = self.pin.value() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> v != self.pinval: self.pinval = v ret = MP_STREAM_POLL_RD <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再说一次-在官方</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio上，</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">延迟可能会很高。根据应用程序设计，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fast_io</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">版本</font><font style="vertical-align: inherit;">可能更有效。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演示程序</font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iorw.py</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">展示了一个完整的例子。请注意，在用正式的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">撰写本文时，</font><font style="vertical-align: inherit;">由于存在错误，因此</font></font><a href="http://github.com/micropython/pull/3836" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无法正常工作</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。有两种解决方案。解决方法是编写两个单独的驱动程序，一个用于只读，另一个用于只读。第二种是使用</font></font><a href="" rel="nofollow"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fast_io</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它可以解决此问题。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在正式的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio中，</font></font></b><font style="vertical-align: inherit;"></font><a href="http://github.com/micropython/micropython/issues/2664" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">很少</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计划输入/输出</font><font style="vertical-align: inherit;">。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.5完整示例：aremote.py</font></font></b> <br><br> <a href="" rel="nofollow"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该驱动程序</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">旨在接收/解码来自红外遥控器的信号。</font></font><a href="http://github.com/peterhinch/micropython-async/blob/master/nec_ir/aremote.py" rel="nofollow"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aremote.py</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">驱动程序</font><a href="http://github.com/peterhinch/micropython-async/blob/master/nec_ir/aremote.py" rel="nofollow"><b><font style="vertical-align: inherit;">本身</font></b></a><font style="vertical-align: inherit;">。以下注意事项与</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> asyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的使用有关</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">联系人上的中断会记录状态更改的时间（以微秒为单位）并设置事件，从而跳过第一次状态更改发生的时间。协程会发生事件，报告数据包的持续时间，然后在调用用户指定的回调之前解码存储的数据。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将时间传递给</font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事件</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实例</font><font style="vertical-align: inherit;">使协程可以</font><font style="vertical-align: inherit;">在设置延迟时段时</font><font style="vertical-align: inherit;">补偿任何</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">延迟。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6.6 HTU21D环境传感器</font></font></b> <br><br> <a href="http://github.com/peterhinch/micropython-async/blob/master/nec_ir/aremote.py" rel="nofollow"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">驱动</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> HTU21D芯片提供的温度和湿度的精确测量。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该芯片需要大约120 ms的时间来接收两个数据元素。驱动程序异步工作，</font><font style="vertical-align: inherit;">在读取数据之前</font><font style="vertical-align: inherit;">启动</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> await asyncio.sleep（t）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的接收和使用</font><font style="vertical-align: inherit;">，更新温度和湿度变量，该变量可以随时访问，从而允许在芯片驱动程序运行时启动其他协程。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7.提示和技巧</font></font></b> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.1程序冻结冻结</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常是由于任务被无条件阻止而发生的：这将导致整个系统冻结。进行显影时，使用协程器定期打开内置LED很有用。这样可以确认调度程序仍在运行。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.2 uasyncio保存状态</font></font></b> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在REPL中</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">启动程序时</font><font style="vertical-align: inherit;">，请在启动之间执行软复位（ctrl-D）。由于</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">会在</font><b><font style="vertical-align: inherit;">两次</font></b><font style="vertical-align: inherit;">启动之间保持状态，因此在下次启动时可能会发生不可预测的行为。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.3垃圾收集</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以通过</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指定</font><i><font style="vertical-align: inherit;">import gc</font></i><font style="vertical-align: inherit;">来执行协程</font><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="python hljs">gc.collect () gc.treshold ( gc.mem_free () // <span class="hljs-number"><span class="hljs-number">4</span></span> + gc.mem_alloc ())</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这次讨论的目的，</font></font><a href="http://docs.micropython.org/en/latest/reference/constrained.html" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，在堆（堆）的部分。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.4测试</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">建议确保设备驱动程序在必要时保持控制，可以通过运行一个或多个虚拟协程副本来启动消息打印周期，并检查其是否在驱动程序处于待机模式时运行，以进行控制：</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: print(<span class="hljs-string"><span class="hljs-string">'Roundrobin '</span></span>, n) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作为可能出现的危险类型的一个示例，在上面的示例中，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RecordOrientedUart </font></font></i> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__await__</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法最初写为：</font></font><br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__await__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> data = <span class="hljs-string"><span class="hljs-string">b''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> data.endswith(self.DELIMITER): <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.uart.any(): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">0</span></span>) data = <span class="hljs-string"><span class="hljs-string">b''</span></span>.join((data, self.uart.read(self.uart.any()))) self.data = data</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结果，执行被拉伸到接收到整个记录为止，以及</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uart.any（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">始终返回接收到的字符数不为零</font><font style="vertical-align: inherit;">的事实</font><font style="vertical-align: inherit;">。在通话时，可能已经收到所有字符。可以使用外部循环解决这种情况：</font></font><br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__await__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> data = <span class="hljs-string"><span class="hljs-string">b''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> data.endswith(self.DELIMITER): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment"># ,  : while not self.uart.any(): yield from asyncio.sleep(0) #        data = b''.join((data, self.uart.read(self.uart.any()))) self.data = data</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能值得注意的是，如果数据以较低的速度而不是使用反馈测试发送到UART，则该错误不会很明显。欢迎来到实时编程的乐趣。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.5常见错误</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果函数或方法是由</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async def</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定义的，</font><font style="vertical-align: inherit;">并且随后被调用为常规（同步）调用，则</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MicroPython</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不会</font><b><font style="vertical-align: inherit;">显示</font></b><font style="vertical-align: inherit;">错误消息。这是设计使然。通常，这导致程序无提示地无法正常工作：</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># code loop.create_task(foo) #  1 1: foo     foo() #  2: .</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我有一个</font></font><a href="http://github.com/micropython-lib/pull/292" rel="nofollow"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">建议</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，建议使用</font></font><a href="" rel="nofollow"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fast_io解决</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方案1中的</font><a href="" rel="nofollow"><b><font style="vertical-align: inherit;">问题</font></b></a><font style="vertical-align: inherit;">。</font><b><font style="vertical-align: inherit;">check_async_code.py</font></b></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模块</font><font style="vertical-align: inherit;">尝试检测可疑程序的使用情况。它是用</font><b><font style="vertical-align: inherit;">Python3</font></b><font style="vertical-align: inherit;">编写的，</font><font style="vertical-align: inherit;">旨在在PC上工作。在根据本指南概述的指南编写的脚本中使用，并使用</font><i><font style="vertical-align: inherit;">async def</font></i><font style="vertical-align: inherit;">声明了协程</font><font style="vertical-align: inherit;">。该模块采用一个参数，即源</font><b><font style="vertical-align: inherit;">MicroPython</font></b><font style="vertical-align: inherit;">文件</font><font style="vertical-align: inherit;">（或--help）</font><font style="vertical-align: inherit;">的路径</font><font style="vertical-align: inherit;">。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请注意，它有点粗鲁，打算在语法正确的文件中使用，该文件默认情况下不会启动。</font><font style="vertical-align: inherit;">使用诸如</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pylint之</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类的工具</font><font style="vertical-align: inherit;">进行常规语法检查（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pylint</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当前没有此错误）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该脚本会产生误报。</font><font style="vertical-align: inherit;">根据计划，协程是第一级的对象；可以将它们传递给函数并存储在数据结构中。</font><font style="vertical-align: inherit;">根据程序的逻辑，可以保存函数或执行结果。</font><font style="vertical-align: inherit;">脚本无法确定意图。</font><font style="vertical-align: inherit;">它旨在忽略在确定其他要考虑的案例时似乎正确的案例。</font><font style="vertical-align: inherit;">假设</font><font style="vertical-align: inherit;">将协程声明为</font><i><font style="vertical-align: inherit;">异步def的</font></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">foo</font></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ： </font></font><br><br><pre> <code class="python hljs">loop.run_until_complete(foo()) <span class="hljs-comment"><span class="hljs-comment">#   bar(foo) #     ,      bar(foo()) z = (foo,) z = (foo(),) foo() #  :   .</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我觉得它很有用，但总是欢迎改进。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.6编程与插座（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">插座</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有到编程插座两种基本方法</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。默认情况下，套接字被阻止，直到指定的读取或写入操作完成。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">支持阻止使用套接字</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">select.poll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以防止它们阻塞调度。在大多数情况下，此机制最容易使用。客户端和服务器代码的示例可以在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">client_server</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目录中找到</font><font style="vertical-align: inherit;">。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Userver </font></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显式轮询服务器套接字</font><i><font style="vertical-align: inherit;">来</font></i><font style="vertical-align: inherit;">使用</font><i><font style="vertical-align: inherit;">select.poll</font></i><font style="vertical-align: inherit;">应用程序</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">客户端套接字在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">流引擎</font><font style="vertical-align: inherit;">直接使用它</font><font style="vertical-align: inherit;">的意义上隐式</font><font style="vertical-align: inherit;">使用它。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请注意，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">socket.getaddrinfo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当前被阻止。示例代码中的时间将最少，但是如果需要DNS查找，则阻止时间可能很长。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">套接字编程的第二种方法是使用非阻塞套接字。这增加了复杂性，但是在某些应用程序中是必需的，尤其是在通过WiFi连接的情况下（请参见下文）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在撰写本文时（2019年3月），正在开发对无阻塞套接字的TLS支持。它的确切状态（对我来说）是未知的。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用无阻塞插座需要注意一些细节。如果由于服务器延迟而发生非阻塞读取，则不能保证将返回所有（或任何一个）请求的数据。同样，条目可能不会完成。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，异步读取和写入方法必须迭代执行非阻塞操作，直到读取或写入所需的数据为止。实际上，可能需要超时来处理服务器中断。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另一个问题是，ESP32端口存在一些问题，需要进行非常讨厌的入侵才能实现无错误操作。我还没有测试是否仍然如此。</font><a href="" rel="nofollow"><i><b><font style="vertical-align: inherit;">Sock_nonblock.py</font></b></i></a></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模块</font></font><a href="" rel="nofollow"><i><b><font style="vertical-align: inherit;"></font></b></i></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">说明了所需的方法。这不是一个可行的演示，决策可能取决于应用程序。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.6.1 WiFi问题</font></font></b> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在检测WiFi中断时</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">流机制</font><font style="vertical-align: inherit;">不是最佳选择。我发现有必要使用非阻塞套接字来提供故障安全操作，并在发生故障时重新连接客户端。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该</font></font><a href="" rel="nofollow"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">描述了我在保持开放的插座长时间WiFi应用所遇到的问题，并概述了决定。</font></font><br><br> <a href="http://guthub.com/peterhinch/micropython-mqtt" rel="nofollow"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">厘米</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提供强大的异步MQTT客户端，可在WiFi故障期间提供消息完整性。描述了在无线客户端和有线服务器之间的一个简单的异步全双工串行链接，它保证了消息的传递。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.7事件循环构造函数的参数</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您需要创建一个值与默认值不同的事件循环，则可能会发生一个小错误。在使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">运行任何其他代码之前，必须声明这样的循环，</font><font style="vertical-align: inherit;">因为此代码中可能需要这些值。否则，代码将使用默认值初始化：</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> some_module bar = some_module.Bar() <span class="hljs-comment"><span class="hljs-comment">#   get_event_loop() #     loop = asyncio.get_event_loop(runq_len=40, waitq_len=40)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">鉴于导入模块可以执行代码，最安全的方法是在导入</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之后立即实例化事件循环</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio loop = asyncio.get_event_loop(runq_len=<span class="hljs-number"><span class="hljs-number">40</span></span>, waitq_len=<span class="hljs-number"><span class="hljs-number">40</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> some_module bar = some_module.Bar() <span class="hljs-comment"><span class="hljs-comment"># get_event_loop()   </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编写供其他程序使用的模块时，我宁愿避免</font><font style="vertical-align: inherit;">在导入时</font><font style="vertical-align: inherit;">运行</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代码</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">编写函数和方法以等待事件循环作为参数。</font><font style="vertical-align: inherit;">然后确保仅顶级应用程序调用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get_event_loop</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> my_module <span class="hljs-comment"><span class="hljs-comment">#      loop = asyncio.get_event_loop(runq_len=40, waitq_len=40) bar = my_module.Bar(loop)</span></span></code> </pre><br><font style="vertical-align: inherit;"></font><a href="http://github.com/micropython/micropython-lib/issues/295" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">讨论这个问题</font><font style="vertical-align: inherit;">。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8面向初学者的</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注释这些注释面向异步代码中的初学者，首先描述了计划人员试图解决的问题，并概述了</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio的</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决方案。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.5节讨论了</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和_ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">线程</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模块的相对优点</font><font style="vertical-align: inherit;">，以及为什么您可能更喜欢在</font><font style="vertical-align: inherit;">主动调度（_thread）中</font><font style="vertical-align: inherit;">使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">协程</font><font style="vertical-align: inherit;">。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.1问题1：事件循环</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">典型的固件应用程序连续工作，同时应响应外部事件，这些事件可能包括ADC电压的变化，硬件中断的出现，UART中接收到的符号或套接字上可用的数据。这些事件是异步发生的，并且代码应该能够响应，而不管它们发生的顺序如何。另外，可能需要与时间有关的任务，例如LED闪烁。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显而易见的方法是使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasycio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事件</font><b><font style="vertical-align: inherit;">循环</font></b><font style="vertical-align: inherit;">。此示例不是实际的代码，但用于说明事件循环的一般形式。</font></font><br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">event_loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> led_1_time = <span class="hljs-number"><span class="hljs-number">0</span></span> led_1_period = <span class="hljs-number"><span class="hljs-number">20</span></span> led_2_time = <span class="hljs-number"><span class="hljs-number">0</span></span> led_2_period = <span class="hljs-number"><span class="hljs-number">30</span></span> switch_state = switch.state() <span class="hljs-comment"><span class="hljs-comment">#    while True: time_now = utime.time() if time_now &gt;= led_1_time: #  LED #1 led1.toggle() led_1_time = time_now + led_1_period if time_now &gt;= led_2_time: #  LED #2 led2.toggle() led_2_time = time_now + led_2_period #    LEDs if switch.value() != switch_state: switch_state = switch.value() #  - if uart.any(): #    UART</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这样的循环适用于简单的示例，但是随着事件数量的增加，代码很快变得很麻烦。通过将大多数程序逻辑放在一个位置，而不是将代码链接到受控对象，它们还违反了面向对象编程的原理。我们要为可插入模块并导入的闪烁LED开发一个类。 OOP的LED闪烁方法可能如下所示：</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pyb <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LED_flashable</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">()</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, led_no)</span></span></span><span class="hljs-function">:</span></span> self.led = pyb.LED(led_no) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, period)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: self.led.toggle() <span class="hljs-comment"><span class="hljs-comment"># -     period, #         </span></span></code> </pre><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio中</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的调度</font><b><font style="vertical-align: inherit;">程序</font></b><font style="vertical-align: inherit;">允许您创建此类。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.2问题2：阻塞方法</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">假设您需要从套接字读取一定数量的字节。如果</font><font style="vertical-align: inherit;">默认情况下使用阻塞套接字</font><font style="vertical-align: inherit;">调用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">socket.read（n）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它将“阻塞”（即它将无法终止），直到收到</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">个字节</font><font style="vertical-align: inherit;">为止</font><font style="vertical-align: inherit;">。在此期间，应用程序将不会响应其他事件。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用非阻塞</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">套接字</font><b><font style="vertical-align: inherit;">，</font></b><font style="vertical-align: inherit;">您可以编写异步读取方法。需要数据的任务将被（有必要）阻止，直到接收到它为止，但是在此期间将执行其他任务，这将使应用程序保持响应状态。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.3。 Uasyncio进近</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下一课有一个可以打开和关闭的LED，您也可以任何速度闪烁。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LED_async</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实例</font><font style="vertical-align: inherit;">使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">run</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">，该方法可用于连续操作。可以使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on（），off（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flash（secs）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法控制LED的行为</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pyb <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LED_async</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">()</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, led_no)</span></span></span><span class="hljs-function">:</span></span> self.led = pyb.LED(led_no) self.rate = <span class="hljs-number"><span class="hljs-number">0</span></span> loop = asyncio.get_event_loop() loop.create_task(self.run()) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.rate &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep_ms(<span class="hljs-number"><span class="hljs-number">200</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: self.led.toggle() <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep_ms(int(<span class="hljs-number"><span class="hljs-number">500</span></span> / self.rate)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, rate)</span></span></span><span class="hljs-function">:</span></span> self.rate = rate <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.led.on() self.rate = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">off</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.led.off() self.rate = <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应当注意，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on（），off（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flash（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是普通的同步方法。它们改变了LED的行为，但立即返回。闪烁发生在“后台”。下一节将对此进行详细说明。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该类符合OOP原则，该原则在于将与设备关联的逻辑存储在该类中。同时，使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可确保应用程序可以在LED闪烁时响应其他事件。下面的程序以四个</font><font style="vertical-align: inherit;">不同频率的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pyboard</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LED闪烁</font><font style="vertical-align: inherit;">，并且还响应USR按钮，从而完成了该程序。</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pyb <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> led_async <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> LED_async <span class="hljs-comment"><span class="hljs-comment"># ,   async def killer(): # ,      sw = pyb.Switch() while not sw.value(): await asyncio.sleep_ms(100) leds = [LED_async(n) for n in range(1, 4)] for n, led in enumerate(leds): led.flash(0.7 + n/4) loop = asyncio.get_event_loop() loop.run_until_complete(killer())</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与事件循环的第一个示例不同，与开关关联的逻辑的功能与LED的功能不同。</font><font style="vertical-align: inherit;">注意用于启动调度程序的代码：</font></font><br><br><pre> <code class="python hljs">loop = asyncio.get_event_loop() loop.run_until_complete(killer()) <span class="hljs-comment"><span class="hljs-comment">#    #       killer (), #   .</span></span></code> </pre><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.4在uasyncio中进行规划</font></font></b> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python 3.5</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MicroPython</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">支持异步函数的概念，也称为协程或任务。</font><font style="vertical-align: inherit;">协程必须至少包含一个</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等待</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">声明</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">10</span></span>): print(<span class="hljs-string"><span class="hljs-string">'Hello world.'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此功能以一秒钟的间隔打印十次消息。当功能因预期延迟而暂停时，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步调度程序</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将执行其他任务，从而产生了同时运行它们的错觉。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当协程发出</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">await asyncio.sleep_ms（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asyncio.sleep（）时，</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当前任务将暂停并放置在按时间排序的队列中，执行将继续到队列顶部的任务。队列的设计方式是，即使指定的睡眠模式为零，也将执行其他相关任务，直到电流恢复为止。这是“诚实的通知”计划。一种常见的做法是运行</font><i><font style="vertical-align: inherit;">asyncio.sleep（0）</font></i><font style="vertical-align: inherit;">循环。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这样任务就不会延迟执行。</font><font style="vertical-align: inherit;">以下是一个忙等待循环，等待另一个任务来设置全局</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标志</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">las，它垄断了处理器，阻止了其他协程的启动：</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bad_code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> flag <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> flag: <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-comment"><span class="hljs-comment">#  flag = False #    </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里的问题是，直到</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flagis False</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">循环</font><i><font style="vertical-align: inherit;">将</font></i><font style="vertical-align: inherit;">控制权</font><i><font style="vertical-align: inherit;">传递</font></i><font style="vertical-align: inherit;">给调度程序，否则其他任务将不会启动。</font><font style="vertical-align: inherit;">正确的方法：</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">good_code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> flag <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> flag: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">#  flag = False #    </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出于同样的原因，设置延迟（例如</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utime.sleep（1））</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一种不好的做法，</font><font style="vertical-align: inherit;">因为它会阻塞其他任务1 s；</font><font style="vertical-align: inherit;">因此，设置延迟会导致延迟</font><font style="vertical-align: inherit;">。使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">await asyncio.sleep（1）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更正确</font><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请注意，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio </font></font></b> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sleep</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sleep_ms</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法产生的延迟</font><font style="vertical-align: inherit;">实际上可能超过了指定的时间。这是由于在延迟期间将执行其他任务。延迟时间过后，执行任务将</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等待</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或终止</font><font style="vertical-align: inherit;">之前，执行将不会继续</font><font style="vertical-align: inherit;">。行为规范的协程将始终声明</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等待</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定期地。在需要精确延迟的地方，尤其是当延迟小于几毫秒时，可能有必要使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utime.sleep_us（us）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.5为什么要协作而不是基于线程的调度（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_thread</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）？</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于协程协程的想法，初学者的最初反应通常令人失望。当然，流媒体计划更好吗？如果Python虚拟机可以为我做到这一点，为什么还要明确让位控制呢？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于嵌入式系统，协作模型具有两个优点。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先是重量轻。可能会有大量的协程，因为与预定线程不同，挂起的协程占用更少的空间。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其次，这避免了与流调度相关的一些细微问题。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实际上，协作多任务处理被广泛使用，尤其是在用户界面应用程序中。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了捍卫流媒体计划模型，我将展示一个优势：如果有人写</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range ( <span class="hljs-number"><span class="hljs-number">1000000</span></span> ): <span class="hljs-comment"><span class="hljs-comment">#  - </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它不会阻止其他任务。协作模型假定循环应显式地为每个任务的控制提供一定数量的迭代，例如，将代码放入协程中并定期发出</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">await asyncio.sleep（0）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">las，与缺点相比，这种优点显得苍白。其中一些描述在编写</font><a href="http://docs.micropython.org/en/latest/reference/isr_rules.html" rel="nofollow"><font style="vertical-align: inherit;">中断处理程序</font></a><font style="vertical-align: inherit;">的文档中</font></font><a href="http://docs.micropython.org/en/latest/reference/isr_rules.html" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。在流调度模型中，每个线程可以中断任何其他线程，从而更改可以在其他线程中使用的数据。通常，查找和修复由于没有给出结果的错误而导致的锁定要比检测在流规划中的模型框架中编写的代码中有时可能发生的细微且很少遇到的错误要容易得多。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">简而言之，如果您编写</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MicroPython</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">协程</font><font style="vertical-align: inherit;">，则可以确保变量不会被另一个协程突然更改：您的协程具有完全控制权，直到它</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回等待asyncio.sleep（0）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为止</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请记住，中断处理程序是抢占式的。这适用于可能在代码中任何地方发生的硬件和软件中断。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有关流式传输计划问题的雄辩讨论可以在</font></font><a href="http://glyph.twistedmatrix.com/" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">找到</font><font style="vertical-align: inherit;">。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.6交互</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在非平凡的应用程序中，协程必须进行交互。可以使用常规的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">。这些方法包括使用全局变量或将协程声明为对象方法：它们可以共享实例变量。或者，可以将可变对象作为参数传递给协程。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">流计划模型要求专家确保类提供安全的连接；</font><font style="vertical-align: inherit;">在协作模型中，很少需要这样做。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.7。</font><font style="vertical-align: inherit;">轮询（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">轮询</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一些硬件设备，诸如加速度计</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pyboard</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，不支持中断，因此应被轮询（即定期检查）。</font><font style="vertical-align: inherit;">轮询也可以与中断处理程序一起使用：中断处理程序维护设备并设置标志。</font><font style="vertical-align: inherit;">协程会轮询该标志-如果已设置该标志，则将处理数据并重置该标志。</font><font style="vertical-align: inherit;">最好的方法是使用</font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Event</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类</font><font style="vertical-align: inherit;">。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN484472/">https://habr.com/ru/post/zh-CN484472/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN484462/index.html">抄袭Github：搜索要开发的“秘密”</a></li>
<li><a href="../zh-CN484464/index.html">日本摩托车拍卖，这一切如何发生</a></li>
<li><a href="../zh-CN484466/index.html">每个人都应该知道的常见JavaScript承诺</a></li>
<li><a href="../zh-CN484468/index.html">红色企业文化是俄罗斯商业的主要问题（第2部分）</a></li>
<li><a href="../zh-CN484470/index.html">JavaScript中的可扩展扩展</a></li>
<li><a href="../zh-CN484480/index.html">美国5大科技公司的总市值超过5万亿美元</a></li>
<li><a href="../zh-CN484482/index.html">关于水处理的小型教育计划</a></li>
<li><a href="../zh-CN484484/index.html">Ubuntu不是最好的桌面Linux</a></li>
<li><a href="../zh-CN484486/index.html">拒绝死亡的计算机</a></li>
<li><a href="../zh-CN484488/index.html">量子系统有多混乱？ 答案可能无法计算。</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>