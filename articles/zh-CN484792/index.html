<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👐🏼 💃🏽 ♠️ 优化游戏场景的3D模型 🖕 🏫 🌤️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="本文完善了Krasnodar工作室Plarium的一系列出版物，涉及在Unity中使用3D模型的各个方面。 先前的文章： “在Unity中使用Mesh的功能” ， “ Unity：Mesh的过程编辑” ， “将3D模型导入Unity和陷阱” ， “纹理扫描中的像素压痕” 。 

 大约2年前，我们写...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>优化游戏场景的3D模型</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/plarium/blog/484792/"> 本文完善了Krasnodar工作室Plarium的一系列出版物，涉及在Unity中使用3D模型的各个方面。 先前的文章： <a href="https://habr.com/ru/company/plarium/blog/440690/">“在Unity中使用Mesh的功能”</a> ， <a href="https://habr.com/ru/company/plarium/blog/443870/">“ Unity：Mesh的过程编辑”</a> ， <a href="https://habr.com/ru/company/plarium/blog/447820/">“将3D模型导入Unity和陷阱”</a> ， <a href="https://habr.com/ru/company/plarium/blog/451794/">“纹理扫描中的像素压痕”</a> 。 <br><br> 大约2年前，我们写<a href="https://habr.com/ru/company/plarium/blog/348494/">了一篇文章</a> ，讨论了在场景中优化3D几何形状的选项，该场景在摄像机角度和相应对象的旋转受到限制的情况下。 从那以后并没有发生太多的事情，但是改进解决方案，考虑不同方法并监视其他方法的机会困扰着开发人员。 在本文中，我们将描述基于绘制多边形的算法的改进版本，并讨论如何将部分工作转移到3D包中。 <br><br><img src="https://habrastorage.org/webt/jl/v-/pz/jlv-pzi5qagnnmqhgkqaddzo1uo.jpeg"><a name="habracut"></a><br><br><h3> 在现场裁剪 </h3><br> 在上一篇文章中，我们已经考虑了该算法的基本原理：熄灭所有效果和透明对象，以一种颜色绘制未处理的多边形，并以不同颜色绘制已处理的多边形，然后渲染并提取结果。 在旧版本中，他们进行了绘画，因此所有黑色都是多余的，只有一个三角形被标记为红色。 <br><br>  <a href="https://habr.com/ru/company/plarium/blog/348494/">在对该</a>文章<a href="https://habr.com/ru/company/plarium/blog/348494/">的评论</a>中，一位读者指出了通过在一组多边形和一组唯一数字之间建立一对一的对应关系来优化算法的可能性。 这样就有可能以相同的方式处理多个三角形。 考虑此选项。 <br><br> 在这种情况下，以及上一次，都应该进行一些预训练，以禁用舞台上所有吹口哨的对象和保证不影响目标模型可见性的对象。 相机视图几乎是独立处理的；它们仅通过可见多边形的公共索引缓冲区连接。 另外，对每个角度执行几何形状预处理，在此期间，将多边形折回并返回相机（ <b>背面</b> ）。 这样做是因为在算法的某个阶段创建的临时网格的顶点数比原始顶点大得多。 此数字可能轻易超过65,535的阈值，这将需要在计算中使用其他手势并导致性能降低。 无论如何，这些多边形将被删除，因为它们的颜色不会落入框架中。 但是，由于每个三角形都有可能产生三个无用顶点，因此提前消除不必要的多边形将简化算法的主要阶段并降低存储成本。 <br><br> 假设有一些3D模型，其几何形状由网格表示。 要以唯一的颜色绘制特定的多边形，您需要以该颜色绘制其所有顶点。 由于一般情况下一个顶点可以属于不同的多边形，因此无法直接解决问题。 无论我们如何着色任何顶点，渲染时，根据视频卡侧面的插值算法，其颜色都会在拥有该顶点的所有三角形上蔓延。 <br><br><img src="https://habrastorage.org/webt/ay/td/qo/aytdqo0ah1fzsl7pcasymag9rf8.jpeg"><br>  <i>显示具有公共顶点的多边形时的颜色插值示例</i> <br><br> 因此，有必要以某种方式将网格划分为单独的独立多边形，同时保留对象的拓扑和几何形状。  Dictum事实。 我们以这样的方式变换三角形和顶点的数组，以便为​​每个三角形创建3个唯一的顶点，其位置由原始网格的相应顶点确定。 值得注意的是，在一般情况下，与原始网格相比，此类网格的顶点数量要大得多。 并且如果该数字超过65 535，则在创建网格时，必须指定适当的索引格式。 <br><br><div class="spoiler">  <b class="spoiler_title">将原始网格转换为每个多边形具有唯一顶点的网格</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Mesh </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNotSmoothMesh</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Mesh origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> oVertices = origin.vertices; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> oTriangles = origin.triangles; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3[oTriangles.Length]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> triangles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[oTriangles.Length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; triangles.Length; i++) { vertices[i] = oVertices[oTriangles[i]]; triangles[i] = i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mesh() { indexFormat = vertices.Length &gt; <span class="hljs-number"><span class="hljs-number">65535</span></span> ? IndexFormat.UInt32 : IndexFormat.UInt16, vertices = vertices, triangles = triangles }; }</code> </pre> <br></div></div><br> 现在，您需要指定该网格的多边形，以便在渲染操作之后可以确定屏幕上出现了哪个多边形。 如前所述，我们为多边形生成唯一的颜色，并用相应的颜色绘制每个三个顶点。 结果是一个新的网格，我们将其称为<b>Byte-Colored Mesh</b> 。 <br><br><img src="https://habrastorage.org/webt/jl/l0/co/jll0coliukddunmhl5kizfzwpzq.jpeg"><br>  <i><b>字节色网格</b></i> <br><br><div class="spoiler">  <b class="spoiler_title">每个顶点仅属于一个多边形的网格着色</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ColorizePolygons</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Mesh mesh</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pColors = ColorsOfPolygons(mesh); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> colors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color[mesh.vertexCount]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; colors.Length; i++) { colors[i] = pColors[i / <span class="hljs-number"><span class="hljs-number">3</span></span>]; } mesh.colors = colors; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Color[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetColorsOfPolygons</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Mesh mesh</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> colors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color[mesh.triangles.Length / <span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; colors.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> color = Int2Color(i);<span class="hljs-comment"><span class="hljs-comment">//         ,     Color2Int //      ,       int     Color32 colors[i] = color; } return colors; }</span></span></code> </pre> <br></div></div><br> 记住颜色。 现在该渲染了。 我们对所有摄像机角度进行3D渲染，并在处理每个摄像机角度时，补充在帧中检测到颜色的唯一多边形索引的缓冲区。 在计算相机时，您需要关闭抗锯齿功能，以避免由于相邻像素的插值而出现新的颜色。 <br><br><div class="spoiler">  <b class="spoiler_title">从不同的相机角度读取和存储颜色</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// CameraTransform —         //      SetCameraTransform private static HashSet&lt;Color&gt; GetVisibleColors(Camera camera, CameraTransform[] cameraTransforms) { var renderTexture = new RenderTexture(1920, 1080, 24);//for example var rtRect = new Rect(0, 0, renderTexture.width, renderTexture.height); var frame = new Texture2D(renderTexture.width, renderTexture.height, TextureFormat.RGB24, false);//    -  RGB24   ,    RGBA32 var visibleColorsSet = new HashSet&lt;Color&gt;(); foreach (var cameraTransform in cameraTransforms) { SetCameraTransform(camera, cameraTransform); CreateScreenShot(camera, renderTexture, frame, rtRect); visibleColorsSet.UnionWith(GetTextureColors(frame)); } return visibleColorsSet; } public static void SetCameraTransform(Camera camera, CameraTransform camTransform) { camera.transform.position = camTransform.Position; camera.transform.rotation = camTransform.Rotation; camera.fieldOfView = camTransform.FieldOfView; camera.orthographic = camTransform.IsOrthographic; camera.nearClipPlane = camTransform.NearClippingPlane; camera.farClipPlane = camTransform.FarClippingPlane; } private static HashSet&lt;Color&gt; GetTextureColors(Texture2D texture) { return new HashSet&lt;Color&gt;(texture.GetPixels()); } private static void CreateScreenShot(Camera cam, RenderTexture renderTexture, Texture2D screenShot, Rect renderTextureRect) { cam.targetTexture = renderTexture; cam.Render(); RenderTexture.active = cam.targetTexture; screenShot.ReadPixels(renderTextureRect, 0, 0); RenderTexture.active = null; cam.targetTexture = null; } }</span></span></code> </pre> <br></div></div><br> 值得一提的是，由于离散化，某些三角形可能不会显示，这是因为它们在屏幕上的投影尺寸特别小，而不是因为某些东西与它们重叠或在错误的一侧旋转了。 我们已经实现了算法的保守版本。 在这种情况下，计算三角形在屏幕上<b>的</b>投影的<b>AABB</b> ，并且如果其侧面中的至少一个小于图片中的纹素侧面，则将这样的多边形标记为可见。 当以低于目标设备的屏幕分辨率的分辨率运行算法时，此方法可防止伪影。 如果忽略小的多边形，只要使用的渲染纹理的分辨率高于目标设备屏幕的分辨率，则结果也是可以接受的。 <br><br> 我们在<b>Unity中</b>实现了这种裁剪算法，并使用它来优化静态对象，这些对象的模型在场景中的各个位置多次出现。 这主要是风景：石头，树木，雕像，花瓶等，是指经常使用的预制件。 我们想在3D程序包创建阶段更早地优化此类对象，但谁知道关卡设计师想要放置他最喜欢的烛台的幻影姿势。 <br><br> 使用此类工具修剪同一类型的对象集会减少场景的大小，因为在<b>静态批处理</b>期间<b>，</b>无论如何在构建阶段复制通用<b>预制</b>网格物体的数据是在场景中使用该网格物体表示的活动绘制对象的次数。 我们的方法还可以释放纹理地图集（例如<b>lightmap）中的空间</b> 。 我们使用节省的空间来增加模型中那些在清洗后仍然存在的部分的细节。 <br><br><h3>  3D裁剪 </h3><br> 不过，最好是艺术家可以减少编辑器中所有不必要的内容，从而减少内容准备的阶段数。 当模型用于相对于摄像机只有一个预定旋转的场景中时，这是合理的。 以前，在集成到项目中之前，通常会手动手动简化将对象完全偏向用户的对象。 重要的是要注意，由于包装<b>UV</b>开发的复杂性，在<b>Unity中</b>以编程方式实现这种简化要困难得多，因此3D封装阶段的自动化有时会使艺术家的生活更轻松。 <br><br>  <b>Blender</b>是我们公司中用于处理3D模型的工具之一。 我们爬进去了。 像<b>Blender</b>这样的“成人”软件似乎应该具有类似的功能。 但是，事实证明他不应该这样做。 我不得不看自己的自行车。 <br><br> 第一个想法是使用熟悉的选择工具-从一个摄影机角度基本上重复艺术家的手动工作的一部分：选择可见的多边形，反转选择，删除。 计划是这样的：移动摄像机，确定模型在每个位置的<b>AABB</b>投影，然后请求选择与<b>AABB</b>对应的区域的多边形的结果，获取当前视图的多边形集与先前视图的多边形的并集，最后删除未选择的多边形。 <br><br> 但是，在脚本执行期间，在任务方面发现了明显的缺点。  <b>Blender中的</b>选择工具<b>（矩形选择，圆形选择）</b> <a href="https://blender.stackexchange.com/questions/43886/why-wont-lasso-or-box-select-select-all-of-the-faces-in-the-region/93482">会</a>随着屏幕每单位面积上所选元素数量的增加而<a href="https://blender.stackexchange.com/questions/43886/why-wont-lasso-or-box-select-select-all-of-the-faces-in-the-region/93482">失去准确性</a> （某些多边形仍处于未选择状态），这使得它们无法在我们的自动化工具中使用。 有趣的事实：在相同的<b>3ds Max中</b> ，未观察到此类问题。 <br><br><img src="https://habrastorage.org/webt/ai/rr/bf/airrbf1enz0jfiucjtrhrbzv8bw.jpeg"><br>  <i>在<b>Blender</b>远处突出显示</i> <br><br><img src="https://habrastorage.org/webt/gt/vy/mh/gtvymh56yk7vp5lrwsvuav4fjqq.jpeg"><br>  <i>选择结果</i> <br><br> 下一个尝试旨在直接解决该问题：我们将来自摄影机的光线通过视口的每个像素发送，并查看哪些多边形首先与至少一条光线相交。 我们不希望这种方法获得准确的结果，但是值得尝试。 结果是显而易见的：在<b>CPU</b>或具有少量光线的相同孔上进行处理时，生产率非常低。 <br><br> 尽管如此，我们还是立足于实施更高级的方法。 这个想法是在每个多边形上选择一定数量的随机点，然后从摄像机沿其方向发送光线。 这种方法效果很好，但是我们遇到了一些边界情况：也切掉了多边形，其中光束与其法线之间的角度大约等于π/ 2。 因此，当相机由于透视变形而变焦时，切出区域可能会打开。 <br><br> 在艺术家看来，这种方法过于激进，因此我们决定只着重于<b>背面</b> 。 <br><br><h3> 结论 </h3><br> 众所周知，在创建游戏时，对设备资源的谨慎态度是影响最终产品质量的最重要因素。 对于移动平台而言，尤其是在积极使用RAM的情况下，尤其如此。 减少多边形的数量使您可以更有效地填充纹理地图集的空间，并稍微减少计算量。 <br><br> 另外，在使用上述工具等时，不要忘记工时成本和错误成本。 所提出的方法假设艺术部门的运作良好，尤其是涉及将模型集成到项目中的员工。 <br><br> 因此，有了本文讨论的条件和工具，我们遵守以下规则。 如果假设所创建的模型总是向用户一侧翻转，并且如果从这些角度来看，模型中某些部分的重叠部分很小，那么画家<b>可以</b>在3D编辑器中使用我们的<b>背面</b>修整<b>工具</b> ，检查正确性并继续包装<b>UV</b>开发。 如果模型经常在不同的位置使用或具有更复杂的几何形状，则在导入到项目中之后，我们将运行本文第一部分中描述的算法，并使用该算法处理场景中的所有静态对象。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN484792/">https://habr.com/ru/post/zh-CN484792/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN484776/index.html">1月21日至26日在圣彼得堡举行的数字活动</a></li>
<li><a href="../zh-CN484778/index.html">英特尔Parallel Studio XE 2020：面向开发人员的最佳选择</a></li>
<li><a href="../zh-CN484782/index.html">Blazor客户端在线商店：第2部分-CI / CD</a></li>
<li><a href="../zh-CN484788/index.html">系统的更多功能：电话集成和CRM / ERP /帮助台。 什么，如何以及为什么？</a></li>
<li><a href="../zh-CN484790/index.html">关于由于服务器Windows上的一个选项而导致我们的网站变慢的故事</a></li>
<li><a href="../zh-CN484796/index.html">我如何获得OSWE认证的？</a></li>
<li><a href="../zh-CN484798/index.html">为什么快速分类真的很慢？ 新的数组排序方法</a></li>
<li><a href="../zh-CN484800/index.html">Microsoft Application Inspector源代码分析器</a></li>
<li><a href="../zh-CN484802/index.html">自毁模式：内窥镜胶囊因光而分解</a></li>
<li><a href="../zh-CN484804/index.html">在企业系统中要加密什么？ 又为什么呢？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>