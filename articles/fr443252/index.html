<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ’ âœŒğŸ¿ ğŸ‘©ğŸ»â€ğŸ¤â€ğŸ‘¨ğŸ¿ Bots de fourmis modulaires avec mÃ©moire ğŸŸï¸ â¹ï¸ ğŸ›ŒğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'un des projets que j'avais longtemps rÃªvÃ© de mettre en Å“uvre Ã©tait des robots de tÃ¢ches modulaires avec mÃ©moire. Le but ultime du projet Ã©tait de cr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bots de fourmis modulaires avec mÃ©moire</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443252/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/nt/w1/te/ntw1telvkd_gywv-7drpcook6ua.gif"></div><br>  L'un des projets que j'avais longtemps rÃªvÃ© de mettre en Å“uvre Ã©tait des robots de tÃ¢ches modulaires avec mÃ©moire.  Le but ultime du projet Ã©tait de crÃ©er un monde avec des crÃ©atures capables d'agir indÃ©pendamment et collectivement. <br><br>  J'avais l'habitude de programmer des gÃ©nÃ©rateurs de monde, donc je voulais peupler le monde avec des robots simples qui utilisent l'IA pour dÃ©terminer leur comportement et leurs interactions.  Ainsi, grÃ¢ce Ã  l'influence des acteurs sur le monde, il a Ã©tÃ© possible d'augmenter ses dÃ©tails. <br><br>  J'ai dÃ©jÃ  implÃ©mentÃ© le systÃ¨me de pipeline de tÃ¢ches Javascript de base (car cela m'a simplifiÃ© la vie), mais je voulais quelque chose de plus fiable et Ã©volutif, j'ai donc Ã©crit ce projet en C ++.  Le concours pour la mise en Å“uvre du jardin procÃ©dural dans la gÃ©nÃ©ration subreddit / r / procÃ©durale m'a conduit Ã  cela (d'oÃ¹ le sujet correspondant). <br><br>  Dans mon systÃ¨me, la simulation se compose de trois composants: le monde, la population et un ensemble d'actions les reliant.  Par consÃ©quent, j'avais besoin de crÃ©er trois modÃ¨les, dont je parlerai dans cet article. <br><br>  Pour augmenter la difficultÃ©, je voulais que les acteurs conservent des informations sur les expÃ©riences prÃ©cÃ©dentes avec le monde et utilisent les connaissances sur ces interactions dans les actions futures. <br><a name="habracut"></a><br>  Lors de la crÃ©ation d'un modÃ¨le du monde, j'ai choisi un chemin simple et j'ai utilisÃ© le bruit Perlin pour le placer Ã  la surface de l'eau.  Tous les autres objets dans le monde Ã©taient localisÃ©s de maniÃ¨re absolument alÃ©atoire. <br><br>  Pour le modÃ¨le de population (et sa Â«mÃ©moireÂ»), j'ai simplement crÃ©Ã© une classe avec plusieurs caractÃ©ristiques et coordonnÃ©es.  C'Ã©tait censÃ© Ãªtre une simulation basse rÃ©solution.  La mÃ©moire est une file d'attente, les robots sont examinÃ©s, enregistrent des informations sur leur environnement, Ã©crivent dans la file d'attente et gÃ¨rent cette file d'attente comme une interprÃ©tation de leur mÃ©moire. <br><br>  Pour connecter ces deux systÃ¨mes d'actions, j'ai voulu crÃ©er un cadre de tÃ¢ches primitives Ã  l'intÃ©rieur d'un systÃ¨me hiÃ©rarchique de files d'attente de tÃ¢ches afin que les entitÃ©s individuelles puissent implÃ©menter un comportement complexe dans le monde. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/571/a8c/77b/571a8c77bb291d6802fe9c87b8aa8986.png"></div><br>  <i>Exemple de carte.</i>  <i>L'eau a pris la forme d'une riviÃ¨re sans le vouloir.</i>  <i>Tous les autres Ã©lÃ©ments sont situÃ©s au hasard, y compris la fourmiliÃ¨re, qui dans cette graine est trop dÃ©calÃ©e vers le bord (mais la riviÃ¨re est magnifique).</i> <br><br>  J'ai dÃ©cidÃ© qu'un tas de fourmis dans les feuilles de collecte d'herbe serait un bon modÃ¨le de test qui garantit la fiabilitÃ© de la mise en Å“uvre des fonctions de base (et du systÃ¨me de file d'attente des tÃ¢ches dans son ensemble) et empÃªche les fuites de mÃ©moire (il y en avait beaucoup). <br><br>  Je veux dÃ©crire plus en dÃ©tail la structure des systÃ¨mes de tÃ¢ches et de la mÃ©moire, et montrer Ã©galement comment la complexitÃ© a Ã©tÃ© crÃ©Ã©e Ã  partir (principalement) de fonctions de base primitives.  Je veux Ã©galement montrer quelques "fuites de mÃ©moire de fourmis" amusantes que vous pouvez rencontrer lorsque les fourmis commencent Ã  tourner follement en rond Ã  la recherche d'herbe ou Ã  rester immobile et Ã  ralentir le programme. <br><br><h3>  Structure gÃ©nÃ©rale </h3><br>  J'ai Ã©crit cette simulation en C ++ et utilisÃ© SDL2 pour le rendu (j'ai dÃ©jÃ  Ã©crit une petite classe de prÃ©sentation pour SLD2 auparavant).  J'ai Ã©galement utilisÃ© l'implÃ©mentation A * (lÃ©gÃ¨rement modifiÃ©e) que j'ai trouvÃ©e sur github car <em>mon implÃ©mentation</em> Ã©tait dÃ©sespÃ©rÃ©ment lente et je ne comprenais pas pourquoi. <br><br>  Une carte n'est qu'une grille 100 Ã— 100 Ã  deux couches - une couche de sol (utilisÃ©e pour rechercher des chemins) et une couche de remplissage (pour complÃ©ter l'interaction et rechercher des chemins).  La classe mondiale gÃ¨re Ã©galement diverses fonctions cosmÃ©tiques, telles que la croissance de l'herbe et de la vÃ©gÃ©tation.  J'en parle maintenant car ce sont les seules parties qui ne seront pas dÃ©crites dans l'article. <br><br><h2>  La population </h2><br>  Les robots Ã©taient dans une classe avec des propriÃ©tÃ©s dÃ©crivant une seule crÃ©ature.  Certains d'entre eux Ã©taient cosmÃ©tiques, d'autres influenÃ§aient l'exÃ©cution des actions (par exemple, la capacitÃ© de voler, le champ de vision, ce qu'il mange et ce que la crÃ©ature peut porter). <br><br>  Les plus importantes ici Ã©taient les valeurs auxiliaires qui dÃ©terminent le comportement.  Ã€ savoir: un vecteur contenant leur chemin actuel A *, de sorte qu'il n'a pas besoin d'Ãªtre comptÃ© Ã  chaque cycle d'horloge (cela Ã©conomise du temps de calcul et vous permet de simuler plus de bots), et une file d'attente de mÃ©moire qui dÃ©finit l'interprÃ©tation des crÃ©atures de leur environnement. <br><br><h3>  File d'attente mÃ©moire </h3><br>  Une file d'attente de mÃ©moire est une file d'attente simple contenant un ensemble d'objets de mÃ©moire dont la taille est limitÃ©e par une propriÃ©tÃ© de bot.  Chaque fois que de nouveaux souvenirs Ã©taient ajoutÃ©s, ils Ã©taient poussÃ©s vers l'avant et tout ce qui dÃ©passait les frontiÃ¨res derriÃ¨re Ã©tait coupÃ©.  GrÃ¢ce Ã  cela, certains souvenirs pourraient Ãªtre plus Â«fraisÂ» que d'autres. <br><br>  Si le bot voulait rappeler des informations de la mÃ©moire, alors il a crÃ©Ã© un objet mÃ©moire (demande) et l'a comparÃ© avec ce qui Ã©tait en mÃ©moire.  Ensuite, la fonction de rappel a renvoyÃ© un vecteur de mÃ©moires correspondant Ã  tout ou partie des critÃ¨res spÃ©cifiÃ©s dans la requÃªte. <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Memory</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//Recall Score int recallScore = 1; //Memory Queryable? Array bool queryable[4] = {false, false, false, false}; //Memory Attributes std::string object; std::string task; Point location; bool reachable;</span></span></code> </pre> <br>  Les mÃ©moires consistent en un simple objet contenant plusieurs propriÃ©tÃ©s.  Ces propriÃ©tÃ©s de mÃ©moire sont considÃ©rÃ©es comme Â«associÃ©esÂ» les unes aux autres.  Chaque mÃ©moire reÃ§oit Ã©galement une valeur de Â«rappelÂ», qui est itÃ©rÃ©e chaque fois que les mÃ©moires sont mÃ©morisÃ©es par la fonction de rappel.  Chaque fois que le bot se souvient des mÃ©moires, il effectue Ã  son tour un tri en une seule passe, en commenÃ§ant par derriÃ¨re, en changeant l'ordre des mÃ©moires si le score de rappel d'une mÃ©moire plus ancienne est supÃ©rieur Ã  celui d'une nouvelle.  GrÃ¢ce Ã  cela, certaines mÃ©moires peuvent Ãªtre plus Â«importantesÂ» (avec de grandes tailles de mÃ©moire) et stockÃ©es plus longtemps dans la file d'attente.  Au fil du temps, ils seront remplacÃ©s par de nouveaux. <br><br><h3>  Files d'attente de mÃ©moire </h3><br>  J'ai Ã©galement ajoutÃ© plusieurs opÃ©rateurs surchargÃ©s Ã  cette classe afin que des comparaisons directes entre la file d'attente de mÃ©moire et la requÃªte puissent Ãªtre effectuÃ©es, en comparant Â«toutesÂ» ou Â«toutesÂ» les propriÃ©tÃ©s, de sorte que seules les propriÃ©tÃ©s spÃ©cifiÃ©es soient Ã©crasÃ©es lorsque la mÃ©moire est Ã©crasÃ©e.  GrÃ¢ce Ã  cela, nous pouvons avoir la mÃ©moire de l'objet associÃ©e Ã  un endroit, mais si nous regardons Ã  nouveau cet endroit et que l'objet n'est pas lÃ , nous pouvons mettre Ã  jour la mÃ©moire en la remplaÃ§ant par de la mÃ©moire contenant une nouvelle tuile de remplissage, en utilisant la requÃªte correspondant Ã  cet endroit . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Bot::updateMemory(Memory &amp;query, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> all, Memory &amp;memory){ <span class="hljs-comment"><span class="hljs-comment">//Loop through all existing Memories //"memories" queue is a member of Bot for(unsigned int i = 0; i &lt; memories.size(); i++){ //If all matches are required and we have all matches if(all &amp;&amp; (memories[i] == query)){ //We have a memory that needs to be updated memories[i] = memory; continue; } //If not all matches are required and any query elements are contained else if(!all &amp;&amp; (memories[i] || query)){ //When overwriting, only overwrite specified quantities memories[i] = memory; continue; } } }</span></span></code> </pre> <br>  Dans le processus de crÃ©ation du code pour ce systÃ¨me, j'ai beaucoup appris. <br><br><h2>  SystÃ¨me de tÃ¢ches </h2><br>  La nature de la boucle de jeu ou du rendu est que les mÃªmes fonctions sont rÃ©pÃ©tÃ©es dans chaque mesure, cependant, je voulais implÃ©menter un comportement non cyclique dans mes bots. <br><br>  Dans cette section, j'expliquerai deux points de vue sur la structure du systÃ¨me de tÃ¢ches conÃ§u pour contrer cet effet. <br><br><h3>  Structure ascendante </h3><br>  J'ai dÃ©cidÃ© de passer de bas en haut et de crÃ©er un ensemble Â«d'actions primitivesÂ» que les bots devraient effectuer.  Chacune de ces actions ne dure qu'un seul battement.  Avec une bonne bibliothÃ¨que de fonctions primitives, nous pouvons les combiner en actions complexes constituÃ©es de plusieurs fonctions primitives. <br><br>  Exemples de telles actions primitives: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Primitives bool wait(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool look(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool step(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool swap(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool store(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool consume(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool move(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); //Continue with secondaries here...</span></span></code> </pre> <br>  Notez que ces actions contiennent des rÃ©fÃ©rences au monde et Ã  la population, vous permettant de les modifier. <br><br><ul><li>  L'attente fait que la crÃ©ature ne fait rien dans cette boucle. </li><li>  Look analyse l'environnement et met en file d'attente de nouveaux souvenirs. </li><li>  Swap prend un objet dans la main de la crÃ©ature et le remplace par un gisant sur le sol. </li><li>  Consommer dÃ©truit l'objet dans la main de la crÃ©ature. </li><li>  Step prend le chemin calculÃ© actuel vers la destination et effectue une Ã©tape (avec un tas de vÃ©rifications d'erreur). </li><li>  ... et ainsi de suite. </li></ul><br>  Toutes les fonctions de tÃ¢che sont membres de ma classe de tÃ¢ches;  aprÃ¨s des tests rigoureux, ils ont prouvÃ© leur fiabilitÃ© et leur capacitÃ© Ã  se combiner en tÃ¢ches plus complexes. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Secondaries bool walk(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool idle(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool search(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool forage(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool take(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); //Species Masters bool Ant(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool Bee(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); };</span></span></code> </pre> <br>  Dans ces fonctions secondaires, nous construisons des fonctions en enchaÃ®nant simplement d'autres tÃ¢ches: <br><br><ul><li>  La tÃ¢che de marche n'est que quelques Ã©tapes (avec gestion des erreurs) </li><li>  La tÃ¢che de prise est la tÃ¢che de recherche et d'Ã©change (elle est nÃ©cessaire en raison du traitement de la mÃ©moire des fourmis, que j'expliquerai plus tard) </li><li>  La tÃ¢che inactive est de sÃ©lectionner un endroit au hasard et de s'y dÃ©placer (en utilisant la marche), d'attendre plusieurs cycles (en utilisant l'attente) et de rÃ©pÃ©ter ce cycle un nombre donnÃ© de fois </li><li>  ... et ainsi de suite </li></ul><br>  D'autres tÃ¢ches sont plus compliquÃ©es.  La tÃ¢che de recherche exÃ©cute une requÃªte de mÃ©moire pour rechercher les mÃ©moires de lieux contenant l'objet Â«nourritureÂ» (comestibles pour ce type de bot).  Elle tÃ©lÃ©charge ces souvenirs et les parcourt tous, Â«Ã  la rechercheÂ» de nourriture (dans le cas des fourmis, c'est de l'herbe).  S'il n'y a pas de souvenirs de nourriture, la tÃ¢che oblige la crÃ©ature Ã  parcourir le monde au hasard et Ã  regarder autour d'elle.  En regardant et en Ã©tudiant (en faisant un Â«regardÂ» avec viewRadius = 1; c'est-Ã -dire en ne regardant que la tuile en dessous), la crÃ©ature peut mettre Ã  jour sa mÃ©moire avec des informations sur son environnement, en recherchant intelligemment et dÃ©libÃ©rÃ©ment de la nourriture. <br><br>  Une tÃ¢che fourragÃ¨re plus gÃ©nÃ©ralisÃ©e consiste Ã  trouver de la nourriture, Ã  ramasser de la nourriture, Ã  inspecter (pour mettre Ã  jour la mÃ©moire et Ã  trouver de la nourriture dans le quartier), Ã  rentrer chez elle et Ã  stocker de la nourriture. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c90/df8/2d8/c90df82d8de8bcf8a9d0de594d2c2e89.gif"></div><br>  <i>Vous remarquerez peut-Ãªtre que les fourmis sortent de la fourmiliÃ¨re et cherchent de la nourriture Ã  dessein.</i>  <i>En raison de l'initialisation, le chemin initial des fourmis est dirigÃ© vers un point alÃ©atoire, car leur mÃ©moire Ã  t = 0 est vide.</i>  <i>Ensuite, ils reÃ§oivent l'ordre de ramasser de la nourriture dans la tÃ¢che de fourrage, et ils regardent Ã©galement autour de eux, s'assurant qu'il n'y a plus de nourriture.</i>  <i>De temps en temps, ils commencent Ã  errer, car ils manquent d'endroits oÃ¹ ils ont vu de la nourriture (myopie inquiÃ©tante).</i> <br><br>  Et enfin, le bot a une Â«vueÂ» qui dÃ©termine le type d'IA qui lui est attribuÃ©.  Chaque vue est associÃ©e Ã  une tÃ¢che de contrÃ´le qui dÃ©finit tout son comportement: elle est constituÃ©e d'une cascade de tÃ¢ches de plus en plus petites, facilement dÃ©terminÃ©es par un ensemble de files d'attente mÃ©moire et de tÃ¢ches primitives.  Ce sont des tÃ¢ches comme Ant et Bee. <br><br><h3>  Structure descendante </h3><br>  Si vous regardez de haut en bas, le systÃ¨me se compose d'une classe maÃ®tre de tÃ¢ches qui coordonne les tÃ¢ches de contrÃ´le et leur exÃ©cution pour chaque bot individuel sur la carte. <br><br>  Taskmaster dispose d'un vecteur de tÃ¢ches de contrÃ´le, chacune Ã©tant associÃ©e Ã  un bot.  Chaque tÃ¢che de contrÃ´le, Ã  son tour, possÃ¨de une file d'attente de sous-tÃ¢ches qui sont chargÃ©es lors de la premiÃ¨re initialisation de l'objet de tÃ¢che avec la fonction de tÃ¢che associÃ©e. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//Members std::stack&lt;Task&gt; queue; bool initFlag = true; int args[10]; bool (Task::*handle)(Garden&amp;, Population&amp;, int (&amp;)[10]); int botID; std::string name; //Constructor Task(std::string taskName, int taskBotID, bool (Task::*taskHandle)(Garden&amp;, Population&amp;, int (&amp;)[10])){ name = taskName; botID = taskBotID; handle = taskHandle; } //Launch a Task bool perform(Garden &amp;garden, Population &amp;population); //Continue with primitives here...</span></span></code> </pre> <br>  Chaque objet de tÃ¢che dans la file d'attente stocke un tableau d'arguments, qu'il transmet au gestionnaire de fonctions associÃ©.  Ces arguments dÃ©terminent le comportement de ces tÃ¢ches primitives crÃ©Ã©es de maniÃ¨re aussi gÃ©nÃ©rale que possible.  Les arguments sont passÃ©s par rÃ©fÃ©rence, afin que l'objet de tÃ¢che dans la file d'attente puisse stocker ses arguments et permettre Ã  ses sous-fonctions d'Ãªtre modifiÃ©es, vous pouvez donc implÃ©menter des choses comme des itÃ©rations pour attendre un certain nombre de ticks ou de demandes pour collecter un certain nombre d'Ã©lÃ©ments, etc.  Les sous-fonctions modifient la valeur de l'itÃ©rateur (argument [n]) de la fonction parent par rÃ©fÃ©rence et font dÃ©pendre sa condition de succÃ¨s de sa valeur. <br><br>  Dans chaque mesure, le taskmaster parcourt la liste des tÃ¢ches de contrÃ´le et les exÃ©cute en appelant leur mÃ©thode perform.  La mÃ©thode perform, Ã  son tour, examine l'Ã©lÃ©ment supÃ©rieur de la file d'attente Ã  l'intÃ©rieur de la tÃ¢che et l'exÃ©cute avec les arguments de la tÃ¢che.  Ainsi, vous pouvez descendre en cascade dans la file d'attente des tÃ¢ches, en effectuant toujours la tÃ¢che la plus Ã©levÃ©e.  Ensuite, la valeur de retour de la tÃ¢che dÃ©termine l'achÃ¨vement de la tÃ¢che. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Execute Task Function bool Task::perform(Garden &amp;garden, Population &amp;population){ //Debug Message if(debug){std::cout&lt;&lt;"Bot with ID: "&lt;&lt;botID&lt;&lt;" performing task: "&lt;&lt;name&lt;&lt;std::endl;} //Change the Name and Execute the Task population.bots[botID].task = name; return (*this.*handle)(garden, population, args); }</span></span></code> </pre> <br>  Lorsqu'une tÃ¢che primitive retourne vraie, elle a atteint son point stable, ou du moins ne doit pas Ãªtre rÃ©pÃ©tÃ©e (par exemple, l'Ã©tape retourne vrai lorsque la crÃ©ature a atteint le point final).  Autrement dit, sa condition de retour est satisfaite et il est supprimÃ© de la file d'attente afin que la tÃ¢che suivante puisse Ãªtre terminÃ©e dans la mesure suivante. <br><br>  Une tÃ¢che contenant une file d'attente de tÃ¢ches renvoie true aprÃ¨s que la file d'attente est vide.  Pour cette raison, il est possible de crÃ©er des tÃ¢ches complexes avec la structure de files d'attente et de sous-files d'attente dans lesquelles les mÃªmes fonctions sont constamment appelÃ©es, mais chaque appel itÃ¨re l'Ã©tat du jeu et l'Ã©tat de la tÃ¢che d'une Ã©tape. <br><br>  Enfin, les tÃ¢ches de contrÃ´le utilisent une structure simple: elles sont appelÃ©es Ã  chaque cycle, ne chargent la tÃ¢che que si elles sont vides et exÃ©cutent les tÃ¢ches chargÃ©es dans leur file d'attente. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Species Functions bool Task::Ant(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]){ //Initial Condition if(initFlag){ Task forage("Search for Food", botID, &amp;Task::forage); forage.args[0] = population.bots[botID].forage; //What are we looking for? queue.push(forage); initFlag = false; } //Queue Loop if(!queue.empty()){ //Get the Top Task Task newtask = queue.top(); queue.pop(); //If our new Task is not performed successfully if(!newtask.perform(garden, population)){ queue.push(newtask); return false; } //If it was successful, we leave it off return false; } //Return Case for Mastertask initFlag = true; return false; }</span></span></code> </pre> <br>  Avec l'aide de ma boucle de file d'attente (voir le code), je peux exÃ©cuter Ã  plusieurs reprises une fonction et Ã  chaque fois exÃ©cuter l'Ã©lÃ©ment supÃ©rieur de sa file d'attente, en poussant les Ã©lÃ©ments hors de lui si l'appel de leur mÃ©thode perform renvoie true. <br><br><h2>  RÃ©sultats </h2><br>  Tout cela est enveloppÃ© dans libconfig, donc les paramÃ¨tres de simulation sont trÃ¨s faciles Ã  modifier.  Vous pouvez coder de nombreuses tÃ¢ches de contrÃ´le sans problÃ¨me (j'ai crÃ©Ã© des fourmis et des abeilles), et dÃ©finir et charger de nouvelles espÃ¨ces Ã  l'aide de libconfig est Ã©tonnamment simple. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Anthill General Configuration File debug = true; //World Generation Parameters seed = 15; water = true; //Species that the simulation recognizes Species: { //Ant Species Ant: { masterTask = "Ant"; color = (0, 0, 0); viewDistance = 2; memorySize = 5; forage = 2; trail = true; fly = false; } Bee: { masterTask = "Bee"; color = (240, 210, 30); viewDistance = 4; memorySize = 30; forage = 4; trail = false; fly = true; } Worm: { masterTask = "Bee"; color = (255, 154, 171); viewDistance = 1; memorySize = 5; forage = 3; trail = true; fly = false; } } Population: ( {species = "Ant"; number = 40;}//, //{species = "Bee"; number = 12;}, //{species = "Worm"; number = 5;} )</span></span></code> </pre> <br>  Ils ont Ã©tÃ© Ã©lÃ©gamment chargÃ©s dans la simulation.  GrÃ¢ce Ã  une nouvelle recherche amÃ©liorÃ©e des chemins, je peux simuler un grand nombre de robots actifs individuels collectant de la nourriture sur un plan bidimensionnel. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c30/991/682/c309916821a8538a0dd92db88caf6b6b.gif"></div><br>  <i>Simulation de 40 fourmis ramassant de l'herbe en mÃªme temps.</i>  <i>Les chemins qu'ils crÃ©ent dans le sable sont dus au poids accru attribuÃ© Ã  la terre Â«viergeÂ».</i>  <i>Cela conduit Ã  la crÃ©ation de "routes de fourmis" caractÃ©ristiques.</i>  <i>Ils peuvent Ã©galement Ãªtre interprÃ©tÃ©s comme des phÃ©romones, mais ce serait plus comme la vÃ©ritÃ© si les fourmis Ã©changeaient effectivement des souvenirs.</i> <br><br>  La modularitÃ© de ce systÃ¨me assure la crÃ©ation rapide de nouvelles espÃ¨ces dont le comportement est dÃ©terminÃ© par une simple tÃ¢che de contrÃ´le.  Dans le code ci-dessus, vous pouvez voir que j'ai crÃ©Ã© des vers et des abeilles IA en changeant simplement leur couleur, les restrictions de recherche de chemin (ils ne peuvent pas voler), la plage de visibilitÃ© et la taille de la mÃ©moire.  En mÃªme temps, j'ai changÃ© leur comportement gÃ©nÃ©ral, car tous ces paramÃ¨tres sont utilisÃ©s par les fonctions des tÃ¢ches primitives. <br><br><h3>  DÃ©bogage des mÃ©moires Ant </h3><br>  La structure des tÃ¢ches complexes et de la mÃ©moire a conduit Ã  des difficultÃ©s imprÃ©vues et Ã  la nÃ©cessitÃ© de gÃ©rer les exceptions. <br><br>  Voici trois bugs mÃ©moire particuliÃ¨rement complexes qui m'ont fait refaire les sous-systÃ¨mes: <br><br><h4>  Fourmis, courant, cercle </h4><br>  L'un des premiers insectes que j'ai dÃ» affronter: des fourmis couraient follement le long du motif enfermÃ© dans la place Ã  la recherche d'herbe sur un sol nu.  Ce problÃ¨me est survenu car Ã  cette Ã©poque, je n'avais pas encore implÃ©mentÃ© de mise Ã  jour de la mÃ©moire.  Les fourmis avaient des souvenirs de l'emplacement de la nourriture, et dÃ¨s qu'elles ramassaient l'herbe et regardaient Ã  nouveau autour, de nouveaux souvenirs se formaient. <br><br>  Le problÃ¨me Ã©tait que la nouvelle mÃ©moire Ã©tait au mÃªme point, mais l'ancienne Ã©tait conservÃ©e.  Cela signifiait que dans le processus de recherche de nourriture, les fourmis se souvenaient et gardaient l'emplacement de la nourriture qui n'Ã©tait plus valide, mais ces anciens souvenirs ont Ã©tÃ© conservÃ©s et ont supplantÃ© de nouveaux (ils se souvenaient de cette dÃ©licieuse herbe). <br><br>  Je l'ai corrigÃ© comme suit: les donnÃ©es de l'objet sont simplement Ã©crasÃ©es dans les vieux souvenirs, si nous voyons le mÃªme endroit et que l'objet a changÃ© (par exemple, la crÃ©ature voit qu'il n'y a plus d'herbe, mais ne se souvient pas qu'il y avait de l'herbe).  Peut-Ãªtre qu'Ã  l'avenir, j'ajouterai simplement la propriÃ©tÃ© "invalide" Ã  mes souvenirs pour que les robots puissent se souvenir d'anciennes informations qui peuvent Ãªtre importantes, mais les informations qui ne sont plus valides "sont apparues" ("J'ai vu un ours ici, mais maintenant il n'y est plus"). <br><br><h4>  Les fourmis ramassent des objets sous d'autres fourmis </h4><br>  De temps en temps (surtout avec un grand nombre de fourmis et une forte densitÃ© d'herbe), deux fourmis peuvent monter sur une tuile d'herbe dans une mesure et essayer de la ramasser.  Cela signifie que la premiÃ¨re fourmi est entrÃ©e dans la tuile, a regardÃ© autour et a pris l'objet en 3 Ã©tapes.  Ã€ son tour, la deuxiÃ¨me fourmi a fait de mÃªme, juste avant de soulever l'objet, une autre fourmi l'a arrachÃ© sous son nez.  Il continua calmement ses tÃ¢ches, examinant le mÃªme environnement que l'autre fourmi dans la mesure prÃ©cÃ©dente, et traita sa ligne de mÃ©moire de la mÃªme maniÃ¨re (car Ã  ce stade, leurs souvenirs sont identiques).  Cela a conduit la deuxiÃ¨me fourmi Ã  copier le premier, Ã  ne jamais ramasser d'objets et Ã  suivre le premier, qui a fait tout le travail.  J'ai remarquÃ© cela parce que dans la simulation des cinq fourmis, seules trois Ã©taient visibles.  Il a fallu beaucoup de temps pour trouver la cause. <br><br>  J'ai rÃ©solu ce problÃ¨me en rendant la tÃ¢che d'Ã©change primitive et en crÃ©ant la tÃ¢che de prise, qui examine d'abord le sol pour voir s'il y a un objet.  Si c'est le cas, il Â«Ã©changeÂ», et sinon, il Â«attendÂ» deux mouvements pour que l'autre fourmi parte dÃ©finitivement.  Dans un cas, cette action concerne deux mesures, dans l'autre - une mesure. <br><br><h4>  Lieux inaccessibles </h4><br>  Un autre bug dÃ©sagrÃ©able qui m'a forcÃ© Ã  refaire le traitement de la mÃ©moire Ã©tait que certains endroits que la fourmi pouvait voir lui Ã©taient inaccessibles.  Ils sont survenus Ã  cause de mon placement paresseux de Â«croix d'herbeÂ» sur la terre, qui pendaient parfois au-dessus de l'eau.  Cela m'a fait gÃ©nÃ©raliser la tÃ¢che par Ã©tapes. <br><br>  Lorsqu'elles transmettaient une demande de recherche de nourriture, les fourmis avaient souvent des souvenirs d'endroits qu'elles ne pouvaient vraiment pas atteindre (elles ont vu de l'herbe au-dessus de l'eau et ont <em>follement</em> voulu la ramasser).  Si elle n'Ã©tait pas marquÃ©e dans leur mÃ©moire (par exemple, la variable boolÃ©enne Â«accessibleÂ»), alors ils ont continuÃ© Ã  s'en souvenir et Ã  Ã©crire dans la file d'attente jusqu'Ã  ce que cette action soit la seule.  Cela a provoquÃ© une inhibition sÃ©vÃ¨re, car ils ont <em>constamment effectuÃ© des opÃ©rations de recherche de chemin dans chaque mesure, essayant d'y arriver, et ont Ã©chouÃ©</em> . <br><br>  La solution consistait Ã  mettre Ã  jour la mÃ©moire dans la tÃ¢che d'Ã©tape si elle ne trouve pas le chemin d'accÃ¨s Ã  l'endroit, le marquant en mÃ©moire comme inaccessible.  De plus, la tÃ¢che de recherche interroge uniquement les lieux avec de la nourriture pour les souvenirs accessibles. <br><br><h2>  SystÃ¨me en gÃ©nÃ©ral </h2><br>  En gÃ©nÃ©ral, je veux dire - oui, je regrette d'avoir passÃ© une semaine de ma vie sur un marathon de programmation, car j'ai Ã©tÃ© inspirÃ© pour crÃ©er des bots qui font ce que je leur dis (et aussi ce qu'ils veulent faire!).  J'ai dÃ» faire quelques tours et j'ai beaucoup appris. <br><br>  Le systÃ¨me que j'ai crÃ©Ã© n'est pas fiable Ã  100% et je remarque encore des artefacts.  Par exemple, comme direction pour analyser le look, l'action est utilisÃ©e de haut en bas et de gauche Ã  droite, c'est-Ã -dire que la derniÃ¨re mÃ©moire se trouve dans le coin infÃ©rieur droit.  Lors du rappel d'informations pour rechercher des objets, cela signifie que les crÃ©atures auront tendance Ã  se dÃ©placer vers le sud-est.  Cela est particuliÃ¨rement visible dans les grandes simulations, lorsque l'herbe pousse rapidement et se plie lÃ©gÃ¨rement vers le sud-est, indÃ©pendamment des graines. <br><br><h3>  AmÃ©liorations </h3><br>  Je pense que des amÃ©liorations significatives sont nÃ©cessaires pour simuler des souvenirs plus complexes de crÃ©atures plus complexes. <br><br>  Cela inclut l'augmentation de la fiabilitÃ© des fonctions de traitement de la mÃ©moire, ainsi que l'ajout de nouvelles primitives, telles que Â«penserÂ», et des dÃ©rivÃ©s de tÃ¢ches de haut niveau, telles que Â«dÃ©ciderÂ» ou Â«rÃªverÂ».  Â«PenserÂ» peut Ãªtre une action primitive d'une demande de mÃ©moire.  Un Â«rÃªveÂ», Ã  son tour, peut consister en plusieurs appels Ã  la Â«rÃ©flexionÂ»: choisir une mÃ©moire alÃ©atoire, obtenir une propriÃ©tÃ© alÃ©atoire et la rÃ©pÃ©ter Ã  plusieurs reprises pour renforcer des thÃ¨mes communs ou des associations importantes. <br><br>  Pour l'avenir, je prÃ©vois trois ajouts spÃ©cifiques: <br><br><ul><li>  Ajouter la gestion des interruptions et la hiÃ©rarchisation des tÃ¢ches </li><li>  Ajouter une communication entre les entitÃ©s </li><li>  Ajouter une structure de groupe pour que les entitÃ©s puissent s'identifier formellement </li></ul><br>  L'interruption du traitement et la hiÃ©rarchisation des tÃ¢ches peuvent Ãªtre nÃ©cessaires pour l'interaction entre les entitÃ©s, car le bot ne peut pas continuer aveuglÃ©ment ses activitÃ©s lorsqu'il communique avec lui (il doit en quelque sorte Â«Ã©couterÂ») ou il est attaquÃ© (Â«fuirÂ» ou Â«combattreÂ» ) <br><br>  La communication entre les entitÃ©s consiste probablement en une ou deux tÃ¢ches primitives pour Ã©changer des souvenirs ou faire des requÃªtes Ã  la mÃ©moire d'autres robots (par exemple, Â«direÂ» ou Â«demanderÂ»).  De cette faÃ§on, des informations telles que l'emplacement de la nourriture ou d'autres ressources peuvent Ãªtre transmises. <br><br>  J'espÃ¨re mettre en Å“uvre ces tÃ¢ches et dresser un graphique du taux d'accumulation des ressources par un grand groupe avec et sans communication.  La population suit dÃ©jÃ  la quantitÃ© de nourriture collectÃ©e dans chaque mesure.  Il serait intÃ©ressant de montrer que le partage de souvenirs peut affecter l'efficacitÃ©. <br><br><h3>  Le futur </h3><br>  La fonction la plus importante pour simuler des communautÃ©s consistera Ã  ajouter des structures de groupe et Ã  doter ces groupes de propriÃ©tÃ©s au niveau macro, par exemple, leurs Â«objectifs et responsabilitÃ©sÂ» communs.  Cela nous donne une sorte de Â«graineÂ» Ã  partir de laquelle nous pouvons obtenir des tÃ¢ches de haut niveau qui sont dÃ©lÃ©guÃ©es dans la hiÃ©rarchie des structures de groupe Ã  des tÃ¢ches de Â«hautÂ» niveau infÃ©rieur qui affectent directement le monde.  Il vous permet Ã©galement de crÃ©er une forme de structure politique. <br><br>  Un tel systÃ¨me est tout Ã  fait autonome et la visualisation est simplement superposÃ©e au-dessus.  Il sera trÃ¨s simple de remplacer les insectes par des humanoÃ¯des, de collecter des ressources et de les stocker dans un certain endroit, afin qu'il grossisse.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La nature de la croissance de leur maison peut, par exemple, Ãªtre trÃ¨s dÃ©pendante ou complÃ¨tement indÃ©pendante des actions des robots. </font><font style="vertical-align: inherit;">DiffÃ©rentes espÃ¨ces peuvent avoir diffÃ©rentes tribus avec des caractÃ©ristiques et des tendances diffÃ©rentes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, je peux combiner ce systÃ¨me avec des gÃ©nÃ©rateurs de cartes crÃ©Ã©s prÃ©cÃ©demment (Ã©largissant la classe mondiale) pour rendre le monde plus rÃ©el.</font></font><br><br><h2>  En conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans un avenir proche, je prÃ©vois de remplacer les crÃ©atures par des personnes et de mettre en Å“uvre certaines des derniÃ¨res fonctions. </font><font style="vertical-align: inherit;">Peut-Ãªtre que je publierai le </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">code source complet</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lorsque j'amÃ©liorerai la qualitÃ© du systÃ¨me (Ã  certains endroits, le code est plutÃ´t chaotique). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attendez le prochain article. </font><font style="vertical-align: inherit;">En attendant, voici une vidÃ©o avec des abeilles Ã  la recherche de pollen dans les fleurs; </font><font style="vertical-align: inherit;">ils sont encodÃ©s en utilisant le mÃªme framework.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/332/b31/7d5/332b317d547edc53f2b2ffee6c3d4861.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai choisi cette graine car le point de dÃ©part est situÃ© sur une petite Ã®le. </font><font style="vertical-align: inherit;">Cependant, les abeilles ne sont pas programmÃ©es pour retourner dans la ruche, mais simplement collecter constamment le pollen. </font><font style="vertical-align: inherit;">Vous remarquerez peut-Ãªtre que leur champ de vision est plus Ã©levÃ© et parfois ils se dÃ©placent trÃ¨s intentionnellement vers la fleur qu'ils viennent de voir. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... et voici la fonction membre Bee Task:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Task::Bee(Garden &amp;garden, Population &amp;population, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (&amp;arguments)[<span class="hljs-number"><span class="hljs-number">10</span></span>]){ <span class="hljs-comment"><span class="hljs-comment">//Just Search for Flowers if(initFlag){ //Define our Tasks Task take("Take Food", botID, &amp;Task::take); Task eat("Eat Food", botID, &amp;Task::consume); Task search("Locate Food", botID, &amp;Task::search); search.args[0] = population.bots[botID].forage; queue.push(eat); queue.push(take); queue.push(search); initFlag = false; } //Work off our allocated queue. if(!queue.empty()){ //Get the Top Task Task newtask = queue.top(); queue.pop(); //If our new Task is not performed successfully if(!newtask.perform(garden, population)){ //Put the Task back on queue.push(newtask); } //If it was successful, we leave it off return false; } initFlag = true; return true; }</span></span></code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr443252/">https://habr.com/ru/post/fr443252/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr443242/index.html">Quarkus est un Java subatomique supersonique. Un bref aperÃ§u du cadre</a></li>
<li><a href="../fr443244/index.html">TÃ¢ches de dÃ©briefing. Beanpoisk_1</a></li>
<li><a href="../fr443246/index.html">Comment nous avons rÃ©inventÃ© le PBX IP Askozia aprÃ¨s la vente et la clÃ´ture du projet par le dÃ©veloppeur</a></li>
<li><a href="../fr443248/index.html">Protocoles de rÃ©servation transparente de PRP et HSR</a></li>
<li><a href="../fr443250/index.html">Collecteur de dÃ©chets fait maison pour OpenJDK</a></li>
<li><a href="../fr443254/index.html">Triton est le virus le plus mortel</a></li>
<li><a href="../fr443256/index.html">PowerShell, vidage de mon expÃ©rience</a></li>
<li><a href="../fr443258/index.html">Gotify - un projet open source pour dÃ©livrer des notifications et envoyer des messages au serveur</a></li>
<li><a href="../fr443260/index.html">Migrez vers Zimbra sans risquer une entreprise avec un domaine commun</a></li>
<li><a href="../fr443262/index.html">Mauvais conseil: comment rÃ©diger la documentation technique? TroisiÃ¨me partie et derniÃ¨re</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>