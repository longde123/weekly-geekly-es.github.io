<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💐 ✌🏿 👩🏻‍🤝‍👨🏿 Bots de fourmis modulaires avec mémoire 🏟️ ⏹️ 🛌🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'un des projets que j'avais longtemps rêvé de mettre en œuvre était des robots de tâches modulaires avec mémoire. Le but ultime du projet était de cr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bots de fourmis modulaires avec mémoire</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443252/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/nt/w1/te/ntw1telvkd_gywv-7drpcook6ua.gif"></div><br>  L'un des projets que j'avais longtemps rêvé de mettre en œuvre était des robots de tâches modulaires avec mémoire.  Le but ultime du projet était de créer un monde avec des créatures capables d'agir indépendamment et collectivement. <br><br>  J'avais l'habitude de programmer des générateurs de monde, donc je voulais peupler le monde avec des robots simples qui utilisent l'IA pour déterminer leur comportement et leurs interactions.  Ainsi, grâce à l'influence des acteurs sur le monde, il a été possible d'augmenter ses détails. <br><br>  J'ai déjà implémenté le système de pipeline de tâches Javascript de base (car cela m'a simplifié la vie), mais je voulais quelque chose de plus fiable et évolutif, j'ai donc écrit ce projet en C ++.  Le concours pour la mise en œuvre du jardin procédural dans la génération subreddit / r / procédurale m'a conduit à cela (d'où le sujet correspondant). <br><br>  Dans mon système, la simulation se compose de trois composants: le monde, la population et un ensemble d'actions les reliant.  Par conséquent, j'avais besoin de créer trois modèles, dont je parlerai dans cet article. <br><br>  Pour augmenter la difficulté, je voulais que les acteurs conservent des informations sur les expériences précédentes avec le monde et utilisent les connaissances sur ces interactions dans les actions futures. <br><a name="habracut"></a><br>  Lors de la création d'un modèle du monde, j'ai choisi un chemin simple et j'ai utilisé le bruit Perlin pour le placer à la surface de l'eau.  Tous les autres objets dans le monde étaient localisés de manière absolument aléatoire. <br><br>  Pour le modèle de population (et sa «mémoire»), j'ai simplement créé une classe avec plusieurs caractéristiques et coordonnées.  C'était censé être une simulation basse résolution.  La mémoire est une file d'attente, les robots sont examinés, enregistrent des informations sur leur environnement, écrivent dans la file d'attente et gèrent cette file d'attente comme une interprétation de leur mémoire. <br><br>  Pour connecter ces deux systèmes d'actions, j'ai voulu créer un cadre de tâches primitives à l'intérieur d'un système hiérarchique de files d'attente de tâches afin que les entités individuelles puissent implémenter un comportement complexe dans le monde. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/571/a8c/77b/571a8c77bb291d6802fe9c87b8aa8986.png"></div><br>  <i>Exemple de carte.</i>  <i>L'eau a pris la forme d'une rivière sans le vouloir.</i>  <i>Tous les autres éléments sont situés au hasard, y compris la fourmilière, qui dans cette graine est trop décalée vers le bord (mais la rivière est magnifique).</i> <br><br>  J'ai décidé qu'un tas de fourmis dans les feuilles de collecte d'herbe serait un bon modèle de test qui garantit la fiabilité de la mise en œuvre des fonctions de base (et du système de file d'attente des tâches dans son ensemble) et empêche les fuites de mémoire (il y en avait beaucoup). <br><br>  Je veux décrire plus en détail la structure des systèmes de tâches et de la mémoire, et montrer également comment la complexité a été créée à partir (principalement) de fonctions de base primitives.  Je veux également montrer quelques "fuites de mémoire de fourmis" amusantes que vous pouvez rencontrer lorsque les fourmis commencent à tourner follement en rond à la recherche d'herbe ou à rester immobile et à ralentir le programme. <br><br><h3>  Structure générale </h3><br>  J'ai écrit cette simulation en C ++ et utilisé SDL2 pour le rendu (j'ai déjà écrit une petite classe de présentation pour SLD2 auparavant).  J'ai également utilisé l'implémentation A * (légèrement modifiée) que j'ai trouvée sur github car <em>mon implémentation</em> était désespérément lente et je ne comprenais pas pourquoi. <br><br>  Une carte n'est qu'une grille 100 × 100 à deux couches - une couche de sol (utilisée pour rechercher des chemins) et une couche de remplissage (pour compléter l'interaction et rechercher des chemins).  La classe mondiale gère également diverses fonctions cosmétiques, telles que la croissance de l'herbe et de la végétation.  J'en parle maintenant car ce sont les seules parties qui ne seront pas décrites dans l'article. <br><br><h2>  La population </h2><br>  Les robots étaient dans une classe avec des propriétés décrivant une seule créature.  Certains d'entre eux étaient cosmétiques, d'autres influençaient l'exécution des actions (par exemple, la capacité de voler, le champ de vision, ce qu'il mange et ce que la créature peut porter). <br><br>  Les plus importantes ici étaient les valeurs auxiliaires qui déterminent le comportement.  À savoir: un vecteur contenant leur chemin actuel A *, de sorte qu'il n'a pas besoin d'être compté à chaque cycle d'horloge (cela économise du temps de calcul et vous permet de simuler plus de bots), et une file d'attente de mémoire qui définit l'interprétation des créatures de leur environnement. <br><br><h3>  File d'attente mémoire </h3><br>  Une file d'attente de mémoire est une file d'attente simple contenant un ensemble d'objets de mémoire dont la taille est limitée par une propriété de bot.  Chaque fois que de nouveaux souvenirs étaient ajoutés, ils étaient poussés vers l'avant et tout ce qui dépassait les frontières derrière était coupé.  Grâce à cela, certains souvenirs pourraient être plus «frais» que d'autres. <br><br>  Si le bot voulait rappeler des informations de la mémoire, alors il a créé un objet mémoire (demande) et l'a comparé avec ce qui était en mémoire.  Ensuite, la fonction de rappel a renvoyé un vecteur de mémoires correspondant à tout ou partie des critères spécifiés dans la requête. <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Memory</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//Recall Score int recallScore = 1; //Memory Queryable? Array bool queryable[4] = {false, false, false, false}; //Memory Attributes std::string object; std::string task; Point location; bool reachable;</span></span></code> </pre> <br>  Les mémoires consistent en un simple objet contenant plusieurs propriétés.  Ces propriétés de mémoire sont considérées comme «associées» les unes aux autres.  Chaque mémoire reçoit également une valeur de «rappel», qui est itérée chaque fois que les mémoires sont mémorisées par la fonction de rappel.  Chaque fois que le bot se souvient des mémoires, il effectue à son tour un tri en une seule passe, en commençant par derrière, en changeant l'ordre des mémoires si le score de rappel d'une mémoire plus ancienne est supérieur à celui d'une nouvelle.  Grâce à cela, certaines mémoires peuvent être plus «importantes» (avec de grandes tailles de mémoire) et stockées plus longtemps dans la file d'attente.  Au fil du temps, ils seront remplacés par de nouveaux. <br><br><h3>  Files d'attente de mémoire </h3><br>  J'ai également ajouté plusieurs opérateurs surchargés à cette classe afin que des comparaisons directes entre la file d'attente de mémoire et la requête puissent être effectuées, en comparant «toutes» ou «toutes» les propriétés, de sorte que seules les propriétés spécifiées soient écrasées lorsque la mémoire est écrasée.  Grâce à cela, nous pouvons avoir la mémoire de l'objet associée à un endroit, mais si nous regardons à nouveau cet endroit et que l'objet n'est pas là, nous pouvons mettre à jour la mémoire en la remplaçant par de la mémoire contenant une nouvelle tuile de remplissage, en utilisant la requête correspondant à cet endroit . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Bot::updateMemory(Memory &amp;query, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> all, Memory &amp;memory){ <span class="hljs-comment"><span class="hljs-comment">//Loop through all existing Memories //"memories" queue is a member of Bot for(unsigned int i = 0; i &lt; memories.size(); i++){ //If all matches are required and we have all matches if(all &amp;&amp; (memories[i] == query)){ //We have a memory that needs to be updated memories[i] = memory; continue; } //If not all matches are required and any query elements are contained else if(!all &amp;&amp; (memories[i] || query)){ //When overwriting, only overwrite specified quantities memories[i] = memory; continue; } } }</span></span></code> </pre> <br>  Dans le processus de création du code pour ce système, j'ai beaucoup appris. <br><br><h2>  Système de tâches </h2><br>  La nature de la boucle de jeu ou du rendu est que les mêmes fonctions sont répétées dans chaque mesure, cependant, je voulais implémenter un comportement non cyclique dans mes bots. <br><br>  Dans cette section, j'expliquerai deux points de vue sur la structure du système de tâches conçu pour contrer cet effet. <br><br><h3>  Structure ascendante </h3><br>  J'ai décidé de passer de bas en haut et de créer un ensemble «d'actions primitives» que les bots devraient effectuer.  Chacune de ces actions ne dure qu'un seul battement.  Avec une bonne bibliothèque de fonctions primitives, nous pouvons les combiner en actions complexes constituées de plusieurs fonctions primitives. <br><br>  Exemples de telles actions primitives: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Primitives bool wait(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool look(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool step(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool swap(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool store(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool consume(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool move(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); //Continue with secondaries here...</span></span></code> </pre> <br>  Notez que ces actions contiennent des références au monde et à la population, vous permettant de les modifier. <br><br><ul><li>  L'attente fait que la créature ne fait rien dans cette boucle. </li><li>  Look analyse l'environnement et met en file d'attente de nouveaux souvenirs. </li><li>  Swap prend un objet dans la main de la créature et le remplace par un gisant sur le sol. </li><li>  Consommer détruit l'objet dans la main de la créature. </li><li>  Step prend le chemin calculé actuel vers la destination et effectue une étape (avec un tas de vérifications d'erreur). </li><li>  ... et ainsi de suite. </li></ul><br>  Toutes les fonctions de tâche sont membres de ma classe de tâches;  après des tests rigoureux, ils ont prouvé leur fiabilité et leur capacité à se combiner en tâches plus complexes. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Secondaries bool walk(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool idle(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool search(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool forage(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool take(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); //Species Masters bool Ant(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool Bee(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); };</span></span></code> </pre> <br>  Dans ces fonctions secondaires, nous construisons des fonctions en enchaînant simplement d'autres tâches: <br><br><ul><li>  La tâche de marche n'est que quelques étapes (avec gestion des erreurs) </li><li>  La tâche de prise est la tâche de recherche et d'échange (elle est nécessaire en raison du traitement de la mémoire des fourmis, que j'expliquerai plus tard) </li><li>  La tâche inactive est de sélectionner un endroit au hasard et de s'y déplacer (en utilisant la marche), d'attendre plusieurs cycles (en utilisant l'attente) et de répéter ce cycle un nombre donné de fois </li><li>  ... et ainsi de suite </li></ul><br>  D'autres tâches sont plus compliquées.  La tâche de recherche exécute une requête de mémoire pour rechercher les mémoires de lieux contenant l'objet «nourriture» (comestibles pour ce type de bot).  Elle télécharge ces souvenirs et les parcourt tous, «à la recherche» de nourriture (dans le cas des fourmis, c'est de l'herbe).  S'il n'y a pas de souvenirs de nourriture, la tâche oblige la créature à parcourir le monde au hasard et à regarder autour d'elle.  En regardant et en étudiant (en faisant un «regard» avec viewRadius = 1; c'est-à-dire en ne regardant que la tuile en dessous), la créature peut mettre à jour sa mémoire avec des informations sur son environnement, en recherchant intelligemment et délibérément de la nourriture. <br><br>  Une tâche fourragère plus généralisée consiste à trouver de la nourriture, à ramasser de la nourriture, à inspecter (pour mettre à jour la mémoire et à trouver de la nourriture dans le quartier), à rentrer chez elle et à stocker de la nourriture. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c90/df8/2d8/c90df82d8de8bcf8a9d0de594d2c2e89.gif"></div><br>  <i>Vous remarquerez peut-être que les fourmis sortent de la fourmilière et cherchent de la nourriture à dessein.</i>  <i>En raison de l'initialisation, le chemin initial des fourmis est dirigé vers un point aléatoire, car leur mémoire à t = 0 est vide.</i>  <i>Ensuite, ils reçoivent l'ordre de ramasser de la nourriture dans la tâche de fourrage, et ils regardent également autour de eux, s'assurant qu'il n'y a plus de nourriture.</i>  <i>De temps en temps, ils commencent à errer, car ils manquent d'endroits où ils ont vu de la nourriture (myopie inquiétante).</i> <br><br>  Et enfin, le bot a une «vue» qui détermine le type d'IA qui lui est attribué.  Chaque vue est associée à une tâche de contrôle qui définit tout son comportement: elle est constituée d'une cascade de tâches de plus en plus petites, facilement déterminées par un ensemble de files d'attente mémoire et de tâches primitives.  Ce sont des tâches comme Ant et Bee. <br><br><h3>  Structure descendante </h3><br>  Si vous regardez de haut en bas, le système se compose d'une classe maître de tâches qui coordonne les tâches de contrôle et leur exécution pour chaque bot individuel sur la carte. <br><br>  Taskmaster dispose d'un vecteur de tâches de contrôle, chacune étant associée à un bot.  Chaque tâche de contrôle, à son tour, possède une file d'attente de sous-tâches qui sont chargées lors de la première initialisation de l'objet de tâche avec la fonction de tâche associée. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//Members std::stack&lt;Task&gt; queue; bool initFlag = true; int args[10]; bool (Task::*handle)(Garden&amp;, Population&amp;, int (&amp;)[10]); int botID; std::string name; //Constructor Task(std::string taskName, int taskBotID, bool (Task::*taskHandle)(Garden&amp;, Population&amp;, int (&amp;)[10])){ name = taskName; botID = taskBotID; handle = taskHandle; } //Launch a Task bool perform(Garden &amp;garden, Population &amp;population); //Continue with primitives here...</span></span></code> </pre> <br>  Chaque objet de tâche dans la file d'attente stocke un tableau d'arguments, qu'il transmet au gestionnaire de fonctions associé.  Ces arguments déterminent le comportement de ces tâches primitives créées de manière aussi générale que possible.  Les arguments sont passés par référence, afin que l'objet de tâche dans la file d'attente puisse stocker ses arguments et permettre à ses sous-fonctions d'être modifiées, vous pouvez donc implémenter des choses comme des itérations pour attendre un certain nombre de ticks ou de demandes pour collecter un certain nombre d'éléments, etc.  Les sous-fonctions modifient la valeur de l'itérateur (argument [n]) de la fonction parent par référence et font dépendre sa condition de succès de sa valeur. <br><br>  Dans chaque mesure, le taskmaster parcourt la liste des tâches de contrôle et les exécute en appelant leur méthode perform.  La méthode perform, à son tour, examine l'élément supérieur de la file d'attente à l'intérieur de la tâche et l'exécute avec les arguments de la tâche.  Ainsi, vous pouvez descendre en cascade dans la file d'attente des tâches, en effectuant toujours la tâche la plus élevée.  Ensuite, la valeur de retour de la tâche détermine l'achèvement de la tâche. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Execute Task Function bool Task::perform(Garden &amp;garden, Population &amp;population){ //Debug Message if(debug){std::cout&lt;&lt;"Bot with ID: "&lt;&lt;botID&lt;&lt;" performing task: "&lt;&lt;name&lt;&lt;std::endl;} //Change the Name and Execute the Task population.bots[botID].task = name; return (*this.*handle)(garden, population, args); }</span></span></code> </pre> <br>  Lorsqu'une tâche primitive retourne vraie, elle a atteint son point stable, ou du moins ne doit pas être répétée (par exemple, l'étape retourne vrai lorsque la créature a atteint le point final).  Autrement dit, sa condition de retour est satisfaite et il est supprimé de la file d'attente afin que la tâche suivante puisse être terminée dans la mesure suivante. <br><br>  Une tâche contenant une file d'attente de tâches renvoie true après que la file d'attente est vide.  Pour cette raison, il est possible de créer des tâches complexes avec la structure de files d'attente et de sous-files d'attente dans lesquelles les mêmes fonctions sont constamment appelées, mais chaque appel itère l'état du jeu et l'état de la tâche d'une étape. <br><br>  Enfin, les tâches de contrôle utilisent une structure simple: elles sont appelées à chaque cycle, ne chargent la tâche que si elles sont vides et exécutent les tâches chargées dans leur file d'attente. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Species Functions bool Task::Ant(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]){ //Initial Condition if(initFlag){ Task forage("Search for Food", botID, &amp;Task::forage); forage.args[0] = population.bots[botID].forage; //What are we looking for? queue.push(forage); initFlag = false; } //Queue Loop if(!queue.empty()){ //Get the Top Task Task newtask = queue.top(); queue.pop(); //If our new Task is not performed successfully if(!newtask.perform(garden, population)){ queue.push(newtask); return false; } //If it was successful, we leave it off return false; } //Return Case for Mastertask initFlag = true; return false; }</span></span></code> </pre> <br>  Avec l'aide de ma boucle de file d'attente (voir le code), je peux exécuter à plusieurs reprises une fonction et à chaque fois exécuter l'élément supérieur de sa file d'attente, en poussant les éléments hors de lui si l'appel de leur méthode perform renvoie true. <br><br><h2>  Résultats </h2><br>  Tout cela est enveloppé dans libconfig, donc les paramètres de simulation sont très faciles à modifier.  Vous pouvez coder de nombreuses tâches de contrôle sans problème (j'ai créé des fourmis et des abeilles), et définir et charger de nouvelles espèces à l'aide de libconfig est étonnamment simple. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Anthill General Configuration File debug = true; //World Generation Parameters seed = 15; water = true; //Species that the simulation recognizes Species: { //Ant Species Ant: { masterTask = "Ant"; color = (0, 0, 0); viewDistance = 2; memorySize = 5; forage = 2; trail = true; fly = false; } Bee: { masterTask = "Bee"; color = (240, 210, 30); viewDistance = 4; memorySize = 30; forage = 4; trail = false; fly = true; } Worm: { masterTask = "Bee"; color = (255, 154, 171); viewDistance = 1; memorySize = 5; forage = 3; trail = true; fly = false; } } Population: ( {species = "Ant"; number = 40;}//, //{species = "Bee"; number = 12;}, //{species = "Worm"; number = 5;} )</span></span></code> </pre> <br>  Ils ont été élégamment chargés dans la simulation.  Grâce à une nouvelle recherche améliorée des chemins, je peux simuler un grand nombre de robots actifs individuels collectant de la nourriture sur un plan bidimensionnel. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c30/991/682/c309916821a8538a0dd92db88caf6b6b.gif"></div><br>  <i>Simulation de 40 fourmis ramassant de l'herbe en même temps.</i>  <i>Les chemins qu'ils créent dans le sable sont dus au poids accru attribué à la terre «vierge».</i>  <i>Cela conduit à la création de "routes de fourmis" caractéristiques.</i>  <i>Ils peuvent également être interprétés comme des phéromones, mais ce serait plus comme la vérité si les fourmis échangeaient effectivement des souvenirs.</i> <br><br>  La modularité de ce système assure la création rapide de nouvelles espèces dont le comportement est déterminé par une simple tâche de contrôle.  Dans le code ci-dessus, vous pouvez voir que j'ai créé des vers et des abeilles IA en changeant simplement leur couleur, les restrictions de recherche de chemin (ils ne peuvent pas voler), la plage de visibilité et la taille de la mémoire.  En même temps, j'ai changé leur comportement général, car tous ces paramètres sont utilisés par les fonctions des tâches primitives. <br><br><h3>  Débogage des mémoires Ant </h3><br>  La structure des tâches complexes et de la mémoire a conduit à des difficultés imprévues et à la nécessité de gérer les exceptions. <br><br>  Voici trois bugs mémoire particulièrement complexes qui m'ont fait refaire les sous-systèmes: <br><br><h4>  Fourmis, courant, cercle </h4><br>  L'un des premiers insectes que j'ai dû affronter: des fourmis couraient follement le long du motif enfermé dans la place à la recherche d'herbe sur un sol nu.  Ce problème est survenu car à cette époque, je n'avais pas encore implémenté de mise à jour de la mémoire.  Les fourmis avaient des souvenirs de l'emplacement de la nourriture, et dès qu'elles ramassaient l'herbe et regardaient à nouveau autour, de nouveaux souvenirs se formaient. <br><br>  Le problème était que la nouvelle mémoire était au même point, mais l'ancienne était conservée.  Cela signifiait que dans le processus de recherche de nourriture, les fourmis se souvenaient et gardaient l'emplacement de la nourriture qui n'était plus valide, mais ces anciens souvenirs ont été conservés et ont supplanté de nouveaux (ils se souvenaient de cette délicieuse herbe). <br><br>  Je l'ai corrigé comme suit: les données de l'objet sont simplement écrasées dans les vieux souvenirs, si nous voyons le même endroit et que l'objet a changé (par exemple, la créature voit qu'il n'y a plus d'herbe, mais ne se souvient pas qu'il y avait de l'herbe).  Peut-être qu'à l'avenir, j'ajouterai simplement la propriété "invalide" à mes souvenirs pour que les robots puissent se souvenir d'anciennes informations qui peuvent être importantes, mais les informations qui ne sont plus valides "sont apparues" ("J'ai vu un ours ici, mais maintenant il n'y est plus"). <br><br><h4>  Les fourmis ramassent des objets sous d'autres fourmis </h4><br>  De temps en temps (surtout avec un grand nombre de fourmis et une forte densité d'herbe), deux fourmis peuvent monter sur une tuile d'herbe dans une mesure et essayer de la ramasser.  Cela signifie que la première fourmi est entrée dans la tuile, a regardé autour et a pris l'objet en 3 étapes.  À son tour, la deuxième fourmi a fait de même, juste avant de soulever l'objet, une autre fourmi l'a arraché sous son nez.  Il continua calmement ses tâches, examinant le même environnement que l'autre fourmi dans la mesure précédente, et traita sa ligne de mémoire de la même manière (car à ce stade, leurs souvenirs sont identiques).  Cela a conduit la deuxième fourmi à copier le premier, à ne jamais ramasser d'objets et à suivre le premier, qui a fait tout le travail.  J'ai remarqué cela parce que dans la simulation des cinq fourmis, seules trois étaient visibles.  Il a fallu beaucoup de temps pour trouver la cause. <br><br>  J'ai résolu ce problème en rendant la tâche d'échange primitive et en créant la tâche de prise, qui examine d'abord le sol pour voir s'il y a un objet.  Si c'est le cas, il «échange», et sinon, il «attend» deux mouvements pour que l'autre fourmi parte définitivement.  Dans un cas, cette action concerne deux mesures, dans l'autre - une mesure. <br><br><h4>  Lieux inaccessibles </h4><br>  Un autre bug désagréable qui m'a forcé à refaire le traitement de la mémoire était que certains endroits que la fourmi pouvait voir lui étaient inaccessibles.  Ils sont survenus à cause de mon placement paresseux de «croix d'herbe» sur la terre, qui pendaient parfois au-dessus de l'eau.  Cela m'a fait généraliser la tâche par étapes. <br><br>  Lorsqu'elles transmettaient une demande de recherche de nourriture, les fourmis avaient souvent des souvenirs d'endroits qu'elles ne pouvaient vraiment pas atteindre (elles ont vu de l'herbe au-dessus de l'eau et ont <em>follement</em> voulu la ramasser).  Si elle n'était pas marquée dans leur mémoire (par exemple, la variable booléenne «accessible»), alors ils ont continué à s'en souvenir et à écrire dans la file d'attente jusqu'à ce que cette action soit la seule.  Cela a provoqué une inhibition sévère, car ils ont <em>constamment effectué des opérations de recherche de chemin dans chaque mesure, essayant d'y arriver, et ont échoué</em> . <br><br>  La solution consistait à mettre à jour la mémoire dans la tâche d'étape si elle ne trouve pas le chemin d'accès à l'endroit, le marquant en mémoire comme inaccessible.  De plus, la tâche de recherche interroge uniquement les lieux avec de la nourriture pour les souvenirs accessibles. <br><br><h2>  Système en général </h2><br>  En général, je veux dire - oui, je regrette d'avoir passé une semaine de ma vie sur un marathon de programmation, car j'ai été inspiré pour créer des bots qui font ce que je leur dis (et aussi ce qu'ils veulent faire!).  J'ai dû faire quelques tours et j'ai beaucoup appris. <br><br>  Le système que j'ai créé n'est pas fiable à 100% et je remarque encore des artefacts.  Par exemple, comme direction pour analyser le look, l'action est utilisée de haut en bas et de gauche à droite, c'est-à-dire que la dernière mémoire se trouve dans le coin inférieur droit.  Lors du rappel d'informations pour rechercher des objets, cela signifie que les créatures auront tendance à se déplacer vers le sud-est.  Cela est particulièrement visible dans les grandes simulations, lorsque l'herbe pousse rapidement et se plie légèrement vers le sud-est, indépendamment des graines. <br><br><h3>  Améliorations </h3><br>  Je pense que des améliorations significatives sont nécessaires pour simuler des souvenirs plus complexes de créatures plus complexes. <br><br>  Cela inclut l'augmentation de la fiabilité des fonctions de traitement de la mémoire, ainsi que l'ajout de nouvelles primitives, telles que «penser», et des dérivés de tâches de haut niveau, telles que «décider» ou «rêver».  «Penser» peut être une action primitive d'une demande de mémoire.  Un «rêve», à son tour, peut consister en plusieurs appels à la «réflexion»: choisir une mémoire aléatoire, obtenir une propriété aléatoire et la répéter à plusieurs reprises pour renforcer des thèmes communs ou des associations importantes. <br><br>  Pour l'avenir, je prévois trois ajouts spécifiques: <br><br><ul><li>  Ajouter la gestion des interruptions et la hiérarchisation des tâches </li><li>  Ajouter une communication entre les entités </li><li>  Ajouter une structure de groupe pour que les entités puissent s'identifier formellement </li></ul><br>  L'interruption du traitement et la hiérarchisation des tâches peuvent être nécessaires pour l'interaction entre les entités, car le bot ne peut pas continuer aveuglément ses activités lorsqu'il communique avec lui (il doit en quelque sorte «écouter») ou il est attaqué («fuir» ou «combattre» ) <br><br>  La communication entre les entités consiste probablement en une ou deux tâches primitives pour échanger des souvenirs ou faire des requêtes à la mémoire d'autres robots (par exemple, «dire» ou «demander»).  De cette façon, des informations telles que l'emplacement de la nourriture ou d'autres ressources peuvent être transmises. <br><br>  J'espère mettre en œuvre ces tâches et dresser un graphique du taux d'accumulation des ressources par un grand groupe avec et sans communication.  La population suit déjà la quantité de nourriture collectée dans chaque mesure.  Il serait intéressant de montrer que le partage de souvenirs peut affecter l'efficacité. <br><br><h3>  Le futur </h3><br>  La fonction la plus importante pour simuler des communautés consistera à ajouter des structures de groupe et à doter ces groupes de propriétés au niveau macro, par exemple, leurs «objectifs et responsabilités» communs.  Cela nous donne une sorte de «graine» à partir de laquelle nous pouvons obtenir des tâches de haut niveau qui sont déléguées dans la hiérarchie des structures de groupe à des tâches de «haut» niveau inférieur qui affectent directement le monde.  Il vous permet également de créer une forme de structure politique. <br><br>  Un tel système est tout à fait autonome et la visualisation est simplement superposée au-dessus.  Il sera très simple de remplacer les insectes par des humanoïdes, de collecter des ressources et de les stocker dans un certain endroit, afin qu'il grossisse.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La nature de la croissance de leur maison peut, par exemple, être très dépendante ou complètement indépendante des actions des robots. </font><font style="vertical-align: inherit;">Différentes espèces peuvent avoir différentes tribus avec des caractéristiques et des tendances différentes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, je peux combiner ce système avec des générateurs de cartes créés précédemment (élargissant la classe mondiale) pour rendre le monde plus réel.</font></font><br><br><h2>  En conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans un avenir proche, je prévois de remplacer les créatures par des personnes et de mettre en œuvre certaines des dernières fonctions. </font><font style="vertical-align: inherit;">Peut-être que je publierai le </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">code source complet</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lorsque j'améliorerai la qualité du système (à certains endroits, le code est plutôt chaotique). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attendez le prochain article. </font><font style="vertical-align: inherit;">En attendant, voici une vidéo avec des abeilles à la recherche de pollen dans les fleurs; </font><font style="vertical-align: inherit;">ils sont encodés en utilisant le même framework.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/332/b31/7d5/332b317d547edc53f2b2ffee6c3d4861.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai choisi cette graine car le point de départ est situé sur une petite île. </font><font style="vertical-align: inherit;">Cependant, les abeilles ne sont pas programmées pour retourner dans la ruche, mais simplement collecter constamment le pollen. </font><font style="vertical-align: inherit;">Vous remarquerez peut-être que leur champ de vision est plus élevé et parfois ils se déplacent très intentionnellement vers la fleur qu'ils viennent de voir. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... et voici la fonction membre Bee Task:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Task::Bee(Garden &amp;garden, Population &amp;population, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (&amp;arguments)[<span class="hljs-number"><span class="hljs-number">10</span></span>]){ <span class="hljs-comment"><span class="hljs-comment">//Just Search for Flowers if(initFlag){ //Define our Tasks Task take("Take Food", botID, &amp;Task::take); Task eat("Eat Food", botID, &amp;Task::consume); Task search("Locate Food", botID, &amp;Task::search); search.args[0] = population.bots[botID].forage; queue.push(eat); queue.push(take); queue.push(search); initFlag = false; } //Work off our allocated queue. if(!queue.empty()){ //Get the Top Task Task newtask = queue.top(); queue.pop(); //If our new Task is not performed successfully if(!newtask.perform(garden, population)){ //Put the Task back on queue.push(newtask); } //If it was successful, we leave it off return false; } initFlag = true; return true; }</span></span></code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr443252/">https://habr.com/ru/post/fr443252/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr443242/index.html">Quarkus est un Java subatomique supersonique. Un bref aperçu du cadre</a></li>
<li><a href="../fr443244/index.html">Tâches de débriefing. Beanpoisk_1</a></li>
<li><a href="../fr443246/index.html">Comment nous avons réinventé le PBX IP Askozia après la vente et la clôture du projet par le développeur</a></li>
<li><a href="../fr443248/index.html">Protocoles de réservation transparente de PRP et HSR</a></li>
<li><a href="../fr443250/index.html">Collecteur de déchets fait maison pour OpenJDK</a></li>
<li><a href="../fr443254/index.html">Triton est le virus le plus mortel</a></li>
<li><a href="../fr443256/index.html">PowerShell, vidage de mon expérience</a></li>
<li><a href="../fr443258/index.html">Gotify - un projet open source pour délivrer des notifications et envoyer des messages au serveur</a></li>
<li><a href="../fr443260/index.html">Migrez vers Zimbra sans risquer une entreprise avec un domaine commun</a></li>
<li><a href="../fr443262/index.html">Mauvais conseil: comment rédiger la documentation technique? Troisième partie et dernière</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>