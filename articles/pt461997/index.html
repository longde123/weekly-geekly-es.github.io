<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçΩÔ∏è üé¨ üöØ Ajustando o desempenho da consulta no PostgreSQL üíÜüèº üö¥üèæ üí°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ajustando o desempenho do banco de dados - os desenvolvedores geralmente adoram ou odeiam. Gosto disso e quero compartilhar alguns dos m√©todos que use...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ajustando o desempenho da consulta no PostgreSQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461997/"><img width="40%" align="left" src="https://habrastorage.org/webt/0s/ei/zy/0seizy-vxfjf3uv8g3n_bijcwb0.jpeg">  Ajustando o desempenho do banco de dados - os desenvolvedores geralmente adoram ou odeiam.  Gosto disso e quero compartilhar alguns dos m√©todos que usei recentemente para ajustar consultas mal executadas no PostgreSQL.  Meus m√©todos n√£o s√£o exaustivos, mas sim um livro did√°tico para quem apenas se diverte com o ajuste. <br><br><h2>  Pesquise consultas lentas </h2><br>  A primeira maneira √≥bvia de iniciar o ajuste √© encontrar operadores espec√≠ficos que funcionam mal. <br><br><h3>  pg_stats_statements </h3><br>  O m√≥dulo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pg_stats_statements</a> √© um √≥timo lugar para come√ßar.  Ele apenas acompanha as estat√≠sticas de execu√ß√£o das instru√ß√µes SQL e pode ser uma maneira f√°cil de encontrar consultas ineficientes. <br><br>  Depois de instalar este m√≥dulo, uma visualiza√ß√£o do sistema chamada <i>pg_stat_statements</i> estar√° dispon√≠vel com todas as suas propriedades.  Quando ele tiver a oportunidade de coletar dados suficientes, procure consultas que tenham um valor <i>total_time</i> relativamente alto <i>.</i>  Concentre-se nesses operadores primeiro. <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_statements <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> total_time <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre> <br><div class="scrollable-table"><table><thead><tr><th>  user_id </th><th>  dbid </th><th>  queryid </th><th>  consulta </th><th>  chamadas </th><th>  total_time </th></tr></thead><tbody><tr><td>  16384 </td><td>  16385 </td><td>  2948 </td><td>  SELECT address_1 FROM endere√ßa as pessoas INNER JOIN p ON a.person_id = p.id WHERE a.state = @state_abbrev; </td><td>  39483 </td><td>  15224.670 </td></tr><tr><td>  16384 </td><td>  16385 </td><td>  924 </td><td>  SELECT person_id FROM people WHERE nome = <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">nome</a> ; </td><td>  26483 </td><td>  12225.670 </td></tr><tr><td>  16384 </td><td>  16385 </td><td>  395 </td><td>  SELECIONE _ DOS PEDIDOS ONDE EXISTE (selecione _ dos produtos em que is_featured = true) </td><td>  18583 </td><td>  224,67 </td></tr></tbody></table></div><br><a name="habracut"></a><br><h3>  auto_explain </h3><br>  O m√≥dulo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">auto_explain</a> tamb√©m <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√©</a> √∫til para encontrar consultas lentas, mas possui 2 vantagens √≥bvias: registra o plano de execu√ß√£o real e suporta a grava√ß√£o de instru√ß√µes aninhadas usando a op√ß√£o <i>log_nested_statements</i> .  Instru√ß√µes aninhadas s√£o instru√ß√µes executadas dentro de uma fun√ß√£o.  Se seu aplicativo usa muitos recursos, a auto_explain √© inestim√°vel para obter planos de execu√ß√£o detalhados. <br><br>  A op√ß√£o <i>log_min_duration</i> controla quais planos de execu√ß√£o de consulta s√£o registrados com base em quanto tempo eles s√£o executados.  Por exemplo, se voc√™ definir o valor como 1000, todos os registros que levarem mais de 1 segundo ser√£o registrados. <br><br><h2>  Ajuste do √≠ndice </h2><br>  Outra estrat√©gia importante de ajuste √© garantir que os √≠ndices sejam usados ‚Äã‚Äãcorretamente.  Como pr√©-requisito, precisamos incluir o coletor de estat√≠sticas. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O Postgres Statistics Collector</a> √© um subsistema de primeira classe que coleta todos os tipos de estat√≠sticas de desempenho √∫teis. <br><br>  Ao ativar esse coletor, voc√™ obt√©m <i>v√°rias visualiza√ß√µes pg_stat _...</i> que cont√™m todas as propriedades.  Em particular, achei isso especialmente √∫til para encontrar √≠ndices ausentes e n√£o utilizados. <br><br><h3>  √çndices ausentes </h3><br>  Os √≠ndices ausentes podem ser uma das solu√ß√µes mais f√°ceis para melhorar o desempenho da consulta.  No entanto, eles n√£o s√£o uma bala de prata e devem ser usados ‚Äã‚Äãcorretamente (mais sobre isso mais tarde).  Se voc√™ tiver o coletor de estat√≠sticas ativado, poder√° executar a seguinte consulta ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">origem</a> ). <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relname, seq_scan - idx_scan <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> too_much_seq, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> seq_scan - <span class="hljs-keyword"><span class="hljs-keyword">coalesce</span></span>(idx_scan, <span class="hljs-number"><span class="hljs-number">0</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'Missing Index?'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-string"><span class="hljs-string">'OK'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>, pg_relation_size(relname::regclass) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> rel_size, seq_scan, idx_scan <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_all_tables <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> schemaname = <span class="hljs-string"><span class="hljs-string">'public'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pg_relation_size(relname::regclass) &gt; <span class="hljs-number"><span class="hljs-number">80000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> too_much_seq <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre> <br>  A consulta localiza tabelas que t√™m mais varreduras seq√ºenciais (varreduras de √≠ndice) do que varreduras de √≠ndice - uma indica√ß√£o clara de que o √≠ndice ajudar√°.  Isso n√£o informar√° em quais colunas criar o √≠ndice, portanto, ser√° um pouco mais trabalhoso.  No entanto, saber quais tabelas precisam delas √© um bom primeiro passo. <br><br><h3>  √çndices n√£o utilizados </h3><br>  Indexar todas as entidades, certo?  Voc√™ sabia que √≠ndices n√£o utilizados podem afetar adversamente o desempenho da grava√ß√£o?  O motivo √© que, ao criar o √≠ndice do Postgres, ele fica sobrecarregado com a tarefa de atualizar esse √≠ndice ap√≥s as opera√ß√µes de grava√ß√£o (INSERT / UPDATE / DELETE).  Assim, adicionar um √≠ndice √© um ato de equil√≠brio, pois pode acelerar a leitura dos dados (se eles foram criados corretamente), mas diminuir√° a velocidade das opera√ß√µes de grava√ß√£o.  Para encontrar √≠ndices n√£o utilizados, voc√™ pode executar a seguinte consulta. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> indexrelid::regclass <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>, relid::regclass <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>, <span class="hljs-string"><span class="hljs-string">'DROP INDEX '</span></span> || indexrelid::regclass || <span class="hljs-string"><span class="hljs-string">';'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> drop_statement <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_user_indexes <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_index <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> (indexrelid) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> idx_scan = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> indisunique <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br><h3>  Nota sobre estat√≠sticas do ambiente de desenvolvimento </h3><br>  Confiar nas estat√≠sticas de um banco de dados de desenvolvimento local pode ser problem√°tico.  Idealmente, voc√™ pode obter as estat√≠sticas acima da sua m√°quina de trabalho ou ger√°-las a partir de um backup de trabalho restaurado.  Porque  Fatores ambientais podem alterar o comportamento do otimizador de consultas do Postgres.  Dois exemplos: <br><br><ul><li>  quando a m√°quina tem menos mem√≥ria, o PostgreSQL pode n√£o ser capaz de executar uma jun√ß√£o Hash, caso contr√°rio, pode e far√° mais r√°pido. </li><li>  se n√£o houver tantas linhas na tabela (como no banco de dados de desenvolvimento), o PostgresSQL pode preferir executar uma varredura seq√ºencial da tabela em vez de usar um √≠ndice dispon√≠vel.  Quando os tamanhos das tabelas s√£o pequenos, o Seq Scan pode ser mais r√°pido.  (Nota: voc√™ pode executar <pre> <code class="plaintext hljs">SET enable_seqscan = OFF</code> </pre>  em uma sess√£o para que o otimizador opte por usar √≠ndices, mesmo que as verifica√ß√µes sequenciais possam ser mais r√°pidas.  Isso √© √∫til ao trabalhar com bancos de dados de desenvolvimento que n√£o possuem muitos dados) </li></ul><br><h2>  No√ß√µes b√°sicas sobre planos de execu√ß√£o </h2><br>  Agora que voc√™ encontrou algumas consultas lentas, √© hora de come√ßar a divers√£o. <br><br><h3>  EXPLIQUE </h3><br>  O comando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">EXPLAIN</a> certamente √© necess√°rio ao configurar consultas.  Ele diz o que realmente est√° acontecendo.  Para us√°-lo, basta adicionar <i>EXPLAIN</i> √† consulta e execut√°-la.  O PostgreSQL mostrar√° o plano de execu√ß√£o que ele usou. <br><br>  Ao usar EXPLAIN para ajuste, eu recomendo sempre a op√ß√£o <i>ANALYZE</i> ( <i>EXPLAIN ANALYZE</i> ), pois ela fornece resultados mais precisos.  A op√ß√£o ANALYZE realmente executa a instru√ß√£o (em vez de apenas avali√°-la) e, em seguida, explica. <br><br>  Vamos dar um mergulho e come√ßar a entender a sa√≠da de <i>EXPLAIN</i> .  Aqui est√° um exemplo: <br><br><img src="https://habrastorage.org/webt/ee/py/sv/eepysvoeunknfcwr9meuxa9e4y4.png"><br><br><h3>  N√≥s </h3><br>  A primeira coisa a entender √© que cada bloco recuado com o ‚Äú-&gt;‚Äù anterior (junto com a linha superior) √© chamado de n√≥.  Um n√≥ √© uma unidade l√≥gica de trabalho (uma "etapa", se voc√™ preferir) com custo e lead time associados.  O custo e o tempo apresentados em cada n√≥ s√£o cumulativos e re√∫nem todos os n√≥s filhos.  Isso significa que a linha superior (n√≥) mostra o custo total e o tempo real para todo o operador.  Isso √© importante porque voc√™ pode pesquisar facilmente para determinar quais n√≥s s√£o o gargalo. <br><br><h3>  Custo </h3><br><pre> <code class="plaintext hljs">cost=146.63..148.65</code> </pre> <br>  O primeiro n√∫mero √© o custo inicial (o custo da obten√ß√£o do primeiro registro) e o segundo n√∫mero √© o custo do processamento de todo o n√≥ (custo total do in√≠cio ao fim). <br><br>  De fato, este √© o custo que as estimativas do PostgreSQL ter√£o que ser cumpridas para executar a declara√ß√£o.  Esse n√∫mero n√£o significa quanto tempo levar√° para concluir a solicita√ß√£o, embora geralmente exista um relacionamento direto necess√°rio para concluir.  O custo √© uma combina√ß√£o de 5 componentes de trabalho usados ‚Äã‚Äãpara avaliar o trabalho necess√°rio: amostragem seq√ºencial, amostragem inconsistente (aleat√≥ria), processamento de linhas, operador de processamento (fun√ß√£o) e registro do √≠ndice de processamento.  Custo √© a carga de entrada / sa√≠da e processador, e √© importante saber que o custo relativamente alto significa que o PostgresSQL acredita que ter√° que fazer mais trabalho.  O otimizador decide qual plano de execu√ß√£o usar com base no custo.  O otimizador prefere custos mais baixos. <br><br><h3>  Tempo real </h3><br><pre> <code class="plaintext hljs">actual time=55.009..55.012</code> </pre> <br>  Em milissegundos, o primeiro n√∫mero √© a hora de in√≠cio (hora de recuperar o primeiro registro) e o segundo n√∫mero √© o tempo necess√°rio para processar o n√≥ inteiro (tempo total do in√≠cio ao fim).  F√°cil de entender, certo? <br><br>  No exemplo acima, foram necess√°rios 55,009 ms para obter o primeiro registro e 55,012 ms para concluir o n√≥ inteiro. <br><br><h3>  Saiba mais sobre planos de execu√ß√£o. </h3><br>  Existem alguns artigos realmente bons para entender os resultados de EXPLAIN.  Em vez de tentar recont√°-los aqui, recomendo dedicar algum tempo para realmente entend√™-los, acessando estes 2 recursos maravilhosos: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://www.depesz.com/2013/04/16/explaining-the-unexplainable/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://wiki.postgresql.org/images/4/45/Explaining_EXPLAIN.pdf</a> </li></ul><br><h2>  Solicitar ajuste </h2><br>  Agora que voc√™ sabe quais operadores est√£o funcionando mal e pode ver seus planos de execu√ß√£o, √© hora de come√ßar a ajustar sua consulta para melhorar o desempenho.  Aqui, voc√™ faz altera√ß√µes nas suas consultas e / ou adiciona √≠ndices para tentar obter um melhor plano de execu√ß√£o.  Comece com gargalos e verifique se voc√™ pode fazer altera√ß√µes para reduzir custos e / ou lead time. <br><br><h4>  Cache de dados e nota de custo </h4><br>  Ao fazer altera√ß√µes e avaliar os planos de implementa√ß√£o, para verificar se haver√° melhorias, √© importante saber que implementa√ß√µes futuras podem depender do armazenamento em cache de dados que d√™ uma id√©ia dos melhores resultados.  Se voc√™ executar a solicita√ß√£o uma vez, fa√ßa uma corre√ß√£o e execute-a uma segunda vez, provavelmente ela ser√° executada muito mais rapidamente, mesmo que o plano de execu√ß√£o n√£o seja mais favor√°vel.  Isso ocorre porque o PostgreSQL pode armazenar em cache os dados usados ‚Äã‚Äãna primeira inicializa√ß√£o e pode us√°-los na segunda inicializa√ß√£o.  Portanto, voc√™ deve concluir as consultas pelo menos tr√™s vezes e calcular a m√©dia dos resultados para comparar os custos. <br><br>  O que aprendi pode ajudar a melhorar os planos de execu√ß√£o: <br><br><ul><li>  √çndices <br><ul><li>  Excluir varredura sequencial (Seq Scan) adicionando √≠ndices (se o tamanho da tabela n√£o for pequeno) </li><li>  Ao usar um √≠ndice de v√°rias colunas, preste aten√ß√£o na ordem em que define as colunas inclu√≠das - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mais informa√ß√µes</a> </li><li>  Tente √≠ndices muito seletivos para dados usados ‚Äã‚Äãcom freq√º√™ncia.  Isso tornar√° seu uso mais eficiente. </li></ul></li><li>  Condi√ß√£o ONDE <br><br><ul><li>  Evite CURTIR </li><li>  Evite chamadas de fun√ß√£o na cl√°usula WHERE </li><li>  Evite grandes condi√ß√µes em () </li></ul></li><li>  JOINs <br><br><ul><li>  Ao ingressar em tabelas, tente usar uma express√£o de igualdade simples na cl√°usula ON (ou seja, a.id = b.person_id).  Isso permite que voc√™ use m√©todos de associa√ß√£o mais eficientes (ou seja, Hash Join, n√£o Nested Loop Join) </li><li>  Converta subconsultas em instru√ß√µes JOIN quando poss√≠vel, pois isso geralmente permite ao otimizador entender a meta e, possivelmente, escolher o melhor plano. </li><li>  Use COMPOSTOS corretamente: voc√™ usa GROUP BY ou DISTINCT apenas porque obt√©m resultados duplicados?  Isso geralmente indica o uso inadequado de JOINs e pode resultar em custos mais altos. </li><li>  Se o plano de execu√ß√£o usar Hash Join, poder√° ser muito lento se as estimativas de tamanho da tabela estiverem incorretas.  Portanto, verifique se as estat√≠sticas da tabela est√£o corretas revisando a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">estrat√©gia de aspira√ß√£o.</a> </li><li>  Evite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">subconsultas correlatas sempre que</a> poss√≠vel;  eles podem aumentar significativamente o custo de uma solicita√ß√£o </li><li>  Use <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">EXISTS</a> ao verificar a exist√™ncia de seq√º√™ncias de caracteres com base em um crit√©rio, pois √© semelhante a um curto-circuito (interrompe o processamento quando encontra pelo menos uma correspond√™ncia) </li></ul></li><li>  Recomenda√ß√µes gerais <br><br><ul><li>  Fa√ßa mais com menos;  Processador mais r√°pido que entrada / sa√≠da (E / S) </li><li>  Use <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">express√µes de tabela comuns</a> e tabelas tempor√°rias quando precisar executar consultas encadeadas. </li><li>  Evite instru√ß√µes LOOP e prefira opera√ß√µes SET </li><li>  Evite COUNT (*), pois o PostgresSQL verifica as tabelas para isso ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">apenas para vers√µes &lt;= 9.1</a> ) </li><li>  Evite ORDER BY, DISTINCT, GROUP BY, UNION sempre que poss√≠vel, pois isso gera altos custos iniciais. </li><li>  Procure a grande diferen√ßa entre as linhas estimadas e reais na express√£o <i>EXPLAIN</i> .  Se o contador for muito diferente, as estat√≠sticas da tabela podem estar desatualizadas, e o PostgreSQL estima o custo usando estat√≠sticas imprecisas.  Por exemplo: <pre> <code class="plaintext hljs">Limit (cost=282.37..302.01 rows=93 width=22) (actual time=34.35..49.59 rows=2203 loops=1)</code> </pre>  O n√∫mero estimado de linhas era 93, e o atual - 2203. Portanto, provavelmente, esta √© uma m√° decis√£o do plano.  Voc√™ deve revisar sua <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">estrat√©gia de aspira√ß√£o</a> e garantir que ANALYZE seja executado com bastante frequ√™ncia. </li></ul></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt461997/">https://habr.com/ru/post/pt461997/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt461983/index.html">Como modificamos o produto para um cliente espec√≠fico</a></li>
<li><a href="../pt461985/index.html">Postal Technologies - como digitalizamos os correios russos</a></li>
<li><a href="../pt461989/index.html">Desenvolvimento de uma interface de jogo para v√°rias propor√ß√µes de telas</a></li>
<li><a href="../pt461993/index.html">Como se tornar um supermercado de um "designer regular"</a></li>
<li><a href="../pt461995/index.html">Como usar proxies residentes para marketing e promo√ß√£o de sites</a></li>
<li><a href="../pt461999/index.html">Outra vers√£o do ambiente de desenvolvimento WordPress (docker, wp-cli)</a></li>
<li><a href="../pt462003/index.html">Como eu postei PWA no Svelte no Google Play</a></li>
<li><a href="../pt462005/index.html">Recursos do Google PageSpeed: melhor classifica√ß√£o do site e classifica√ß√£o da pesquisa</a></li>
<li><a href="../pt462007/index.html">Desenvolvendo scripts Python robustos</a></li>
<li><a href="../pt462009/index.html">Tend√™ncias de programa√ß√£o: o que se pode esperar em 2020?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>