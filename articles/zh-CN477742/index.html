<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🤝‍👨🏽 🥗 🏒 “你好，Checkmarx！” 如何编写对Checkmarx SAST的请求并查找很酷的漏洞 🍴 🎇 👩🏻‍🔧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！ 

 在本文中，我想谈谈我们在Checkmarx SAST中创建查询的经验。 

 初次熟悉此分析器时，您可能会得到的印象是，除了搜索弱加密/哈希算法和大量误报外，它不返回任何其他内容。 但是，如果配置正确，它是一种超级强大的工具，可以查找严重的错误。 

 我们将了解Checkmarx ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>“你好，Checkmarx！” 如何编写对Checkmarx SAST的请求并查找很酷的漏洞</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dins/blog/477742/"><img src="https://habrastorage.org/webt/sh/ll/ln/shlllnc6iduoendolw26rabdugk.jpeg"><br><br> 哈Ha！ <br><br> 在本文中，我想谈谈我们在Checkmarx SAST中创建查询的经验。 <br><br> 初次熟悉此分析器时，您可能会得到的印象是，除了搜索弱加密/哈希算法和大量误报外，它不返回任何其他内容。 但是，如果配置正确，它是一种超级强大的工具，可以查找严重的错误。 <br><br> 我们将了解Checkmarx SAST查询语言的复杂性，并编写2个查询来搜索SQL注入和不安全的直接对象引用。 <br><a name="habracut"></a><br><br><h2> 参赛作品 </h2><br> 在长期搜索Checkmarx上的任何指南或文章之后，对我来说很清楚，除了正式文档之外，没有足够的有用信息。 官方文档并没有说一切都变得非常清晰易懂。 例如，我找不到任何最佳做法，如何正确组织覆盖查询，如何编写“傻瓜”查询等。是的，有关于CMx查询语言功能的文档，但这是将这些功能组合成一个查询的方法，该文档未编写。 <br><br>  Checkmarx社区缺少文章和指南，可能与该工具的高昂成本有关，因此受众不多。 或者，也许只有很少的人会费力地进行微调，并直接使用解决方案。 <br><br> 根据我的经验，我发现，更多地使用SAST来满足客户方面与各种要求有关的手续，而不是寻找真正的错误。 结果，通过这种方法，我们充其量只有很少数量的“漏洞”，几乎自动被称为“不可利用”（因为在99.9％的情况下都是这样）。 <br><br> 应当注意，Checkmarx本身正在尝试更新其查询，以使它们开箱即用地提供最佳结果。 但是CMx查询语言查询是针对“一般情况”量身定制的。 令牌的初始搜索基于名称。 例如，CMx SAST假定对数据库的所有查询将如下所示：* createQuery *或* createSQLQuery *。 但是，如果使用内部开发来处理数据库，并且以不同的方式调用查询数据库的方法（例如* driveMyQuery *），那么将跳过所有SQL方法。 例如，我们的客户对SQL DB使用定制的ORM。 在这种情况下，开箱即用的CMx查询将跳过所有SQL注入。 <br><br><h4> 缩写和定义 </h4><br>  <b>CMx</b> -Checkmarx SAST。 <br>  <b>CMxQL</b> -Checkmarx SAST查询语言 <br>  <b>令牌</b> -具有特定值的字符串是词法分析器工作的结果（也称为<b>令牌</b>化） <br><br><h3> 测试申请 </h3><br> 为了写一篇文章，我画了一些Java代码，一个小的测试应用程序。 此代码是实际系统的一小部分的近似副本。 尽管一般而言，测试应用程序的代码与任何其他HTTP后端代码并没有太大区别。 屏幕截图中将显示测试应用程序代码的关键部分。 <br><br><h4> 测试应用程序具有以下结构 </h4><br>  <i>WebRouter</i>类，用于处理传入的HTTP请求；内部处理URL的4种方法： <br><ul><li>  <i>/ getTransaction-</i>在输入处接受交易<i>ID</i> <i>并返回</i>有关其<i>的信息</i> ， <i>ID</i>将其作为字符串，并将其传递给<i>getTransactionInfo（transactionId）</i> =&gt; <i>getTransactionInfo（transactoinId）</i> -使transactionId与SQL查询连接（即获得SQL注入）; </li><li>  <i>/ getSecureTransaction-</i>在输入处接收交易<i>ID</i> ， <i>并返回</i>有关其<i>的信息</i> ， <i>ID</i>将其作为字符串并将其传递给<i>getTransactionInfoSecured（）</i> =&gt; <i>getTransactionInfoSecured（transactoinId）</i> -首先<i>将</i>字符串<i>transactionId</i>转换为Long类型，然后将其连接到SQL查询（在此示例中）如果注射未被利用）; </li><li>  <i>/ getSettings-</i>接受<i>userId</i>和<i>mailboxId作为输入</i> -并发布邮箱设置。 不验证<i>邮箱标识</i>是否属于该用户； </li><li>  <i>/ getSecureSettings-</i>还接受<i>userId</i>和<i>mailboxId作为输入</i>并显示邮箱设置。 但是，将检查<i>邮箱标识是否</i>属于该用户。 </li></ul><br><br><h2>  CMx：一般信息和基本定义 </h2><br><h3> 在开始开发查询之前 </h3><br> 查询开发是在单独的程序CxAuditor中进行的。 在CxAuditor中，您需要扫描所有代码（创建本地项目），我们将为此编写查询。 之后，您可以编写和运行新查询。 使用大型代码库，主扫描可能要花费数小时的时间和千兆字节的内存。 此后，每个请求将不会足够快地执行。 这完全不适合开发。 <br><br> 因此，您可以从项目中获取少量文件，理想情况下，可以在代码中找到一个错误，该错误要早于我们正在编写请求的类型（或将错误手动放置在此处）并仅扫描这组文件。 不必遵守项目的文件结构。 也就是说，如果您具有Java程序包A和B，并且程序包B中的类使用程序包A的类和方法，则可以将所有这些都放在一个目录中，并且CMx仍将理解关系并正确地建立文件之间的调用链（很好，或几乎总是正确的，尽管错误几乎与项目的文件结构无关）。 <br><br><h3> 基本定义 </h3><br><h4> 列表 </h4><br>  CMx中的主要数据类型。 几乎所有CMxQL函数的结果都是<i>CxList</i> 。 这是许多具有某些属性的元素。 以下将考虑对开发最有用的属性。 <br><br><h4> 结果 </h4><br>  CMxQL具有内置的变量<i>结果</i> 。 执行完整个查询后，包含<i>结果</i>变量的集合将显示为结果。 <br><br> 也就是说，任何查询的最终操作都应该是字符串<i>result = WHATEVER</i> ，例如： <br><pre><code class="actionscript hljs">result = All.FindByName(<span class="hljs-string"><span class="hljs-string">"anyname"</span></span>);</code> </pre> <br><h4> 流和代码元素 </h4><br> 根据返回值的类型，大多数CMxQL函数分为2个，返回“代码元素”的函数和返回Flow的函数。 在这两种情况下，结果都是<i>CxList</i> 。 但是对于Flow和代码元素，其内容将略有不同。 <br><ul><li>  <b>代码元素</b> -令牌-例如变量，方法调用，赋值等； </li><li>  <b>流</b> -给定令牌之间的关系。 </li></ul><br><br><h4> 全部和“子”全部 </h4><br> 每个CMxQL函数都可以在<i>All</i>集合（它包含整个扫描代码的所有标记，我们已经看到了带有<i>result</i>的示例）上执行，也可以在<i>CxList</i>集合上执行，而<i>CxList</i>集合又是通过查询中某些操作（例如查询）而获得的： <br><pre> <code class="actionscript hljs">CxList newList = CxList.New();</code> </pre> <br> 将创建一个空集合，然后我们可以使用<i>Add（）</i>方法填充元素，然后按新集合的元素进行搜索： <br><pre> <code class="actionscript hljs">CxList newFind = newList.FindByName(<span class="hljs-string"><span class="hljs-string">"narrowedScope"</span></span>);</code> </pre> <br><h4> 找到的项目的属性 </h4><br>  CxList集的每个元素都有几个属性。 分析写查询的结果时，最有用的是： <br><br><ul><li>  <b>SourceFile-</b>包含此元素的文件的名称； </li><li>  <b>源行</b> -带令牌的行号； </li><li>  <b>源名称</b> -令牌的名称。 等同于令牌，即，如果变量名为var1，则源名称= var1； </li><li>  <b>源类型</b> -令牌的类型。 例如，如果它是一个字符串，则它将是StringLiteral，如果调用了该方法，则将调用MethodInvokeExpr，等等。 </li><li>  <b>目标文件</b> </li><li>  <b>目的行；</b> </li><li>  <b>目的地名称；</b> </li><li>  <b>目标类型。</b> </li></ul><br><br> 如果结果集中的元素为Flow，则Source和Destination将有所不同；反之亦然，如果结果是代码元素，则它们将匹配。 <br><br><h2> 开始创建查询 </h2><br> 所有CMxQL功能都可以分为几种类型。 在我看来，这里可以注意到CMxQL文档的主要缺点，扩展坞中的所有功能都是按字母顺序简单描述的，而根据功能（然后仅按字母顺序）构建它们会更加方便。 <br><br><ul><li> 搜索功能-几乎所有名称为<b>FindBy *</b>和<b>GetBy *的</b> CMxQL函数； </li><li> 集上运算的功能是加，减，交，元素上的迭代等。 </li><li> 分析函数-这些基本上是<b>* ImpactdBy *</b> <b>* InfluencingOn *</b>函数。 </li></ul><br><br> 查询的基本原理是这些类型的功能的交替。 首先，使用搜索功能，我们仅通过某些属性选择我们感兴趣的令牌。 使用集合上的运算，我们可以将具有不同令牌属性的不同集合组合成一个集合，反之亦然，从集合中减去另一个集合。 然后，使用分析功能构建代码流，并尝试了解潜在漏洞是否取决于入口点的参数。 <br><br> 开始搜索的位置（通常是整个搜索路径）的选择取决于特定的代码，更确切地说，甚至取决于“文本”。 在某些情况下，从入口点搜索用户查询会很方便，在某些情况下，从“结尾”甚至中间位置开始会更方便。 所有这些都取决于特定的代码，您需要分别访问每个存储库。 <br><br><h2> 示例：搜索SQL注入 </h2><br> 搜索计划，在方括号中，我指出了集合的名称（查询中的变量）： <br><br><ol><li> 定义例外-可以立即扔出搜索范围的令牌（ <i>exclusionList</i> ）; </li><li> 确定消毒/安全检查（ <i>消毒</i> ）的位置； </li><li> 在数据库中查找所有具有查询执行的低级位置（ <i>runSuperSecureSQLQuery</i> ）; </li><li> 查找被调用方法的所有参数<i>runSuperSecureSQLQuery</i> （ <i>runSSSQParams</i> ）; </li><li> 查找数据库中查询执行位置的入口点（父方法及其参数）（ <i>entryPointsParameters</i> ）； </li><li> 查找<i>runSSSQParams</i>参数对<i>entryPoints</i>的依赖关系，而仅查找那些没有<i>清理</i>输入<i>清理的地方</i> 。 </li></ol><br><br> 结果，我们获得了带有SQL查询的低级方法，其中SQL查询的参数为： <br><br><ul><li> 取决于方法的参数； </li><li> 参数被接受为字符串； </li><li> 参数连接到请求。 </li></ul><br> 我们不会检查是否可以控制这些参数，因为 我们认为，存在一种将变量映射到查询中的机制，并且存在将数字转换为数字类型的机制，并且字符串连接始终被认为是危险的。 即使现在无法控制该行，它也可能会出现在新版本中。 <br><br><h3>  SQLi：步骤1.定义异常 </h3><br> 在例外情况下，您需要添加令牌名称可以与所需名称匹配的类或文件，因为 这些令牌将导致无效的条目。 <br><br> 例如，用于访问数据库的方法称为<i>runSuperSecureSQLquery</i> 。 我们假设内部的<i>runSuperSecureSQLquery</i>方法是安全实现的。 我们的任务是找到使用该方法本身并不安全的地方。 对于SQL注入，用户控制参数的串联位置将不是安全的位置。 安全-将参数映射到ORM结构或（例如）数字参数的地方，这是转换为相应类型的地方。 我们不需要扫描比<i>runSuperSecureSQLquery</i>更“深入”的所有代码，这意味着最好将其排除，以避免无用的查找。 <br><br> 要搜索此类异常，可以使用CMxQL函数很方便： <br><ul><li>  <b>FindByFileName（）</b> -将查找特定文件中所有标记的集合； </li><li>  <b>GetByClass（）</b> -将在给定名称的类中找到所有标记的集合。 </li></ul><br><br> 对于测试应用程序，此异常是<i>Session</i>类，其中包含<i>runSuperSecureSQLquery</i>方法的实现。 <br> 请求在<i>Session</i>类中排除代码的示例（ <i>GetByClass（）</i>方法<i>将</i>检查传递给输入的哪些标记具有CMx类型的<i>ClassDecl</i> ，并将发出该类的许多标记） <br><br><pre> <code class="java hljs">CxList exclusionList = All.GetByClass(All.FindByName(<span class="hljs-string"><span class="hljs-string">"*Session*"</span></span>)); result = exclusionList;</code> </pre> <br><br> 或者另一种方法是将代码抛出整个<i>Session.java</i>文件： <br><br><pre> <code class="java hljs">CxList exclusionList = All.FindByFileName(<span class="hljs-string"><span class="hljs-string">"*Session.java"</span></span>); result = exclusionList;</code> </pre> <br><br> 名称前的星号很重要，因为文件名包含整个路径。 <br> 现在，我们可以在下一步中从搜索范围中减去许多标记。 <br><br> 在<i>Session</i>类中搜索令牌的结果： <br><br><img src="https://habrastorage.org/webt/x3/gz/vx/x3gzvxxumbbu-th01llyjbymkoo.png"><br><br><h3>  SQLi：步骤2。确定消毒位置 </h3><br> 测试应用程序中有2种API方法（请参阅测试应用程序的简要说明）。 两种API方法之间的区别在于， <i>getTransactionInfo（）</i>将SQL查询中的transactionId参数连接起来，而<i>getTransactionInfoSecured（）</i>首先<i>将</i> transactionId <i>转换</i>为Long，然后将其作为字符串传递。 两种方法都嵌入了漏洞（参数级联）。 但是，由于在<i>getTransactionInfoSecured（）中</i>强制转换为Long，所以最后一个方法不容易受到注入的影响，因为当我们尝试传递注入（字符串）时，我们会收到Java异常。 <br><br> 在此示例中，我们将对Long的演员表视为卫生站点。 要找到这些令牌： <br><br><pre> <code class="java hljs">CxList sanitization = All.FindByName(<span class="hljs-string"><span class="hljs-string">"*Long*"</span></span>); result = sanitization;</code> </pre> <br><br> 结果示例： <br><br><img src="https://habrastorage.org/webt/hb/ms/vx/hbmsvxmjwynfncf96eyclx2ey8y.png"><br><br> 结果包括具有YP类型<i>Long</i>和<i>getValueAsLong</i>方法的令牌，这些令牌在内部<i>将</i>值<i>转换为</i> <i>Long</i>类型。 您需要仔细检查结果，以确保没有多余的东西。 <br><br><h3>  SQLi：步骤3。在数据库中查找所有具有查询执行的低级位置 </h3><br> 以下查询将使用runSuperSecureSQLQuery令牌（用于访问数据库）找到所有位置： <br><br><pre> <code class="actionscript hljs">result = All.FindByName(<span class="hljs-string"><span class="hljs-string">"*runSuperSecureSQLQuery*"</span></span>)</code> </pre> <br> 通过令牌名称runSuperSecureSQLQuery的搜索结果： <br><img src="https://habrastorage.org/webt/qm/bh/ci/qmbhci6ucl_wx3sb_9zqfkkpim8.png"><br><br> 而且，对于调用此方法的地方（ <i>Billing</i>类），将仅找到方法调用令牌（类型<i>MethodInvokeExpr</i> ），对于方法声明位置（ <i>Session</i>类），将找到所有令牌-变量。 <br><br> 我们仅过滤方法调用令牌： <br><br><pre> <code class="java hljs">CxList runSuperSecureSQLQuery = All.FindByName(<span class="hljs-string"><span class="hljs-string">"*runSuperSecureSQLQuery*"</span></span>).FindByType(typeof(MethodInvokeExpr)); result = runSuperSecureSQLQuery;</code> </pre> <br> 结果： <br><img src="https://habrastorage.org/webt/or/82/dw/or82dwxfoze-fcbko2b2mljfyus.png"><br><br> 结果，我们得到了7个位置，其中4个是对<i>runSuperSecureSQLQuery（）</i>方法（ <i>Billing</i>和<i>User</i>类）的必需调用。  2-调用<i>Session</i>类内部的runSuperSecureSQLQuery（）内部方法，还有一个是<i>add</i>方法，这是某种CMxQL搜索奇数。 只是说我不希望它出现在列表中=）正如我们在步骤1中发现的那样， <i>Session</i>类中的标记对我们来说并不有趣，因此我们将从结果中减去它们： <br><br><pre> <code class="java hljs">CxList runSuperSecureSQLQuery = All.FindByName(<span class="hljs-string"><span class="hljs-string">"*runSuperSecureSQLQuery*"</span></span>).FindByType(typeof(MethodInvokeExpr)); result = runSuperSecureSQLQuery - exclusionList;</code> </pre> <br> 我们获得对所需方法的有效调用列表： <br><br><img src="https://habrastorage.org/webt/sh/c8/ix/shc8ixcpk9wrkmdv_vzqfz5wj80.png"><br><br> 注意上一个查询中的<i>FindByType（）</i>和<i>typeof（）</i>函数。 如果<i>要按</i> CMx类型进行搜索，即按<i>CxList</i>属性“源类型”进行搜索-那么我们使用<i>typeof（源类型）</i> 。 如果要按数据类型进行搜索，则需要像字符串一样传递参数。 例如： <br><br><pre> <code class="java hljs">result = All.FindByType(<span class="hljs-string"><span class="hljs-string">"String"</span></span>);</code> </pre><br> 将找到所有类型为String的Java令牌。 <br><br><h3>  SQLi：步骤4。找到名为runSuperSecureSQLQuery的方法的所有参数 </h3><br> 为了搜索方法参数，使用CMxQL函数<i>GetParameters（）</i> ： <br><br><pre> <code class="actionscript hljs">CxList runSSSQParams = All.GetParameters(runSuperSecureSQLQuery); result = runSSSQParams;</code> </pre> <br> 结果： <br><br><img src="https://habrastorage.org/webt/s4/4h/id/s44hidweor1j61xs1dkwbewrpja.png"><br><br><h3>  SQLi：步骤5.在数据库中查找查询执行位置的入口点 </h3><br> 为此，首先获取父方法的名称，在内部是对<i>runSuperSecureSQLQuery</i>数据库的调用，然后获取其参数。 为了搜索父令牌，使用CMxQL函数<i>GetAncOfType（）</i> ： <br><br><pre> <code class="actionscript hljs">CxList entryPoints = runSuperSecureSQLQuery.GetAncOfType(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(MethodDecl)); result = entryPoints;</code> </pre> <br><br> 在此查询中，对于runSuperSecureSQLQuery集，返回所有类型为MethodDecl的父标记-这是调用堆栈中的先前方法： <br><br><img src="https://habrastorage.org/webt/we/8w/7u/we8w7ucxjxvtgzerknbgjxir8fa.png"><br><br> 为了搜索方法参数，我们还使用<i>GetParameters（）</i> ： <br><br><pre> <code class="actionscript hljs">CxList entryPointsParameters = All.GetParameters(entryPoints).FindByType(<span class="hljs-string"><span class="hljs-string">"String"</span></span>);</code> </pre> <br><br> 该查询将返回Java类型为String的<i>entryPoints</i>子集的参数： <br><br><img src="https://habrastorage.org/webt/7y/mw/tf/7ymwtfxg94oxlwggez3zhpfvcko.png"><br><br><h3>  SQLi：步骤6。查找runSSSQParams参数对entryPointsParameters的依赖关系，而仅查找那些没有消毒输入的地方 </h3><br> 在这一步中，我们使用分析功能。 以下功能用于分析流代码： <br><br><ul><li> 影响力dBy（） </li><li>  ImpactdByAndNotSanitized（） </li><li> 影响（） </li><li> 影响OnAndNotSanitized（） </li><li> 不影响dBy（） </li><li> 不影响开启（） </li></ul><br><br> 要根据<i>entryPointsParameters</i>父方法的参数查找<i>runSSSQParams</i>请求参数流，并排除卫生令牌： <br><br><pre> <code class="java hljs">CxList dataInflOnTable = runSSSQParams.InfluencedByAndNotSanitized(entryPointsParameters, sanitization);</code> </pre> <br><br> 但是，我不确定内部的<i>* AndNotSanitized</i>函数是否起到某种作用，它看起来更像是该方法只是从结果中减去已清理的集合。 也就是说，如果您这样做： <br><br><pre> <code class="java hljs">CxList dataInflOnTable = runSSSQParams.InfluencedBy(entryPointsParameters) - sanitization;</code> </pre> <br><br> 结果也一样。 虽然也许我仍然没有选择，但是仍然存在差异。 <br><br> 查询结果为我们提供了正确构造的Flow： <br><br><img src="https://habrastorage.org/webt/ru/hs/2d/ruhs2dlh7alil7njbzsf2jke9qw.png"><br><br> 通过潜在的SQL注入获得流程。 从屏幕截图可以看出，Checkmarx返回了3 Flow。 屏幕截图中的流程最短，它以一个文件和一种方法开始和结束。 下一个Flow已离开Session类。 注意源/目标。 最后一个是Session类中的另一种方法。  <i>会话</i>内的流程如下所示： <br><br><img src="https://habrastorage.org/webt/mv/o7/uu/mvo7uuu6wp_dq-ggltm8lb5m5p0.png"><br><br> 要选择一个Flow，请使用<i>ReduceFlow</i>方法<i>（CxList.ReduceFlowType flowType）</i> ，其中flowType可以是： <br><br><ul><li>  <i>CxList.ReduceFlowType.ReduceBigFlow-</i>选择最短的Flow </li><li>  <i>CxList.ReduceFlowType.ReduceSmallFlow-</i>选择最长的流 </li></ul><br><br><h3>  SQLi：查找SQL注入的最终查询 </h3><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// 1.   CxList exclusionList = All.GetByClass(All.FindByName("*Session*")); // 2.    CxList sanitization = All.FindByName("*Long*"); // 3.    runSuperSecureSQLQuery() CxList runSuperSecureSQLQuery = All.FindByName("*runSuperSecureSQLQuery*").FindByType(typeof(MethodInvokeExpr)); runSuperSecureSQLQuery -= exclusionList; // 4.     runSuperSecureSQLQuery() CxList runSSSQParams = All.GetParameters(runSuperSecureSQLQuery); // 5.   ,     runSuperSecureSQLQuery() CxList entryPoints = runSuperSecureSQLQuery.GetAncOfType(typeof(MethodDecl)); CxList entryPointsParameters = All.GetParameters(entryPoints).FindByType("String"); // 6.       (runSuperSecureSQLQuery)     CxList dataInflOnTable = runSSSQParams.InfluencedByAndNotSanitized(entryPointsParameters, sanitization); // 7.   result = dataInflOnTable.ReduceFlow(CxList.ReduceFlowType.ReduceBigFlow);</span></span></code> </pre> <br><br><h2> 示例2：搜索不安全的直接对象引用 </h2><br> 在此请求中，我们将搜索与对象一起工作的所有位置，而无需检查对象的所有者。 在这种情况下，可以对mailboxid使用不同名称的HTTP参数（我们假设这是旧式的），并且验证本身可以在不同的阶段进行：在HTTP入口API点的某个位置，在数据库请求之前的某个位置，有时在中间方法中。 <br><br> 搜索计划 <br><ol><li> 定义异常（ <i>exclusionList</i> ）； </li><li> 确定授权检查的位置（ <i>idorSanitizer</i> ）； </li><li> 查找入口点-HTTP请求主要处理的位置（ <i>webRemoteMethods</i> ）; </li><li> 只有通过入口点令牌才能找到HTTP参数的提取位置<i>mailboxid</i> （ <i>mailboxidInit</i> ）； </li><li> 查找从webRemoteMethods到中间件方法的所有调用以及这些调用的参数（ <i>middlewareMethods</i> ）; </li><li> 查找依赖于mailboxid（ <i>apiPotentialIDOR</i> ）的中间件方法； </li><li> 查找定义了中间件方法的所有位置（ <i>middlewareDecl</i> ）； </li><li> 遍历所有<i>apiPotentialIDOR</i>并仅选择其中没有对<i>mailboxid</i>对象的所有者进行验证的<i>中间件</i> <i>Decl</i> 。 </li></ol><br><br><h3>  IDOR：步骤1.识别异常 </h3><br> 在这种情况下，请排除特定文件中的所有令牌： <br><br><pre> <code class="actionscript hljs">CxList exclusionList = All.FindByFileName(<span class="hljs-string"><span class="hljs-string">"*WebMethodContext.java"</span></span>); result = exclusionList;</code> </pre> <br>  <i>WebMethodContext.java</i>包含诸如<i>getMailboxId</i>和<i>getUserId</i>之类的方法的实现，以及字符串“ mailboxid”。 由于令牌的名称将与我们搜索漏洞所需的名称一致，因此该文件将发出错误的发现。 <br><br><h3>  IDOR：步骤2。找到授权检查 </h3><br> 在测试应用程序中， <i>validateMailbox（）</i>方法用于确定请求的对象是否属于用户： <br><br><pre> <code class="actionscript hljs">CxList idorSanitizer = All.FindByName(<span class="hljs-string"><span class="hljs-string">"*validateMailbox*"</span></span>); result = idorSanitizer;</code> </pre><br> 结果： <br><br><img src="https://habrastorage.org/webt/a7/jx/3e/a7jx3eqcxzb5pwgzze9yuqbysos.png"><br><br><h3>  IDOR：步骤3。查找自定义HTTP API请求的入口点 </h3><br>  HTTP请求处理程序具有特殊的注释，使它们易于查找。 在我的情况下，这是“ WebRemote”； CMxQL函数<i>FindByCustomAttribute（）</i>用于搜索注释。 对于<i>FindByCustomAttribute（）</i> ，父标记<i>GetAncOfType（）</i>的搜索功能将返回注释下的方法： <br><br><pre> <code class="java hljs">CxList webRemoteMethods = All.FindByCustomAttribute(<span class="hljs-string"><span class="hljs-string">"WebRemote"</span></span>) .GetAncOfType(typeof(MethodDecl)); result = webRemoteMethods;</code> </pre> <br><br> 请求结果： <br><br><img src="https://habrastorage.org/webt/rc/xt/q_/rcxtq_rfostgwmdtmwrfyg-9ly4.png"><br><br><h3>  IDOR：步骤4。仅使用入口点令牌，找到mailboxid参数的HTTP提取位置 </h3><br> 要查找与HTTP Mailboxid参数的处理有关的令牌： <br><br><pre> <code class="java hljs">CxList getMailboxId = All.FindByName(<span class="hljs-string"><span class="hljs-string">"\"mailboxId\""</span></span>) + All.FindByName(<span class="hljs-string"><span class="hljs-string">"\"mid\""</span></span>) + All.FindByName(<span class="hljs-string"><span class="hljs-string">"\"boxid\""</span></span>); result = getMailboxId;</code> </pre> <br> 我们添加了3组带有3条不同的线，因为 根据传说，HTTP参数的名称在系统的不同部分可能有所不同。 <br><br> 该查询将找到将<i>mailboxid / mid / boxid</i>写为字符串（用双引号引起来）的所有位置。 但是此查询将返回很多结果tk。 这样的字符串不仅可以在提取HTTP参数的地方找到。 如果我们继续使用此集合，将会得到大量的错误发现。 <br><br> 因此，我们将仅搜索入口点的令牌（ <i>webRemoteMethods</i> ）。 要查找所有子令牌，请使用CMBQL函数<i>GetByAncs（）</i> ： <br><br><pre> <code class="java hljs">result = All.GetByAncs(webRemoteMethods);</code> </pre> <br> 该请求将返回属于标注为<i>WebRemote的</i>方法的所有令牌。 在这个阶段，我们已经可以过滤那些检查对象所有者的方法的标记。 因此，我们重写前一个查询以搜索子令牌，以便仅选择<i>WebRemote</i>方法的子令牌，而对对象所有者不进行安全检查。 为此，请使用条件循环： <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//          CxList entry_point_tokens = All.NewCxList(); //      webRemoteMethods foreach (CxList method in webRemoteMethods) { //        CxList method_tokens = All.GetByAncs(method); // ,       ,    owner if (method_tokens.FindByName(idorSanitizer).Count &gt; 0) { //  ,     , ,     } else { //  ,         entry_point_tokens.Add(method_tokens); } }</span></span></code> </pre><br> 现在，我们可以使用HTTP <i>Mailboxid</i>参数进行更准确的选择： <br><br><pre> <code class="java hljs">CxList getMailboxHTTPParams = entry_point_tokens.FindByName(<span class="hljs-string"><span class="hljs-string">"\"mailboxid\""</span></span>) + entry_point_tokens.FindByName(<span class="hljs-string"><span class="hljs-string">"\"mid\""</span></span>) + entry_point_tokens.FindByName(<span class="hljs-string"><span class="hljs-string">"\"boxid\""</span></span>); result = getMailboxHTTPParams;</code> </pre> <br> 但是，我们对检索HTTP参数的位置并不感兴趣，而对最终分配了HTTP参数值的变量不感兴趣。 因为通过变量的标记精确地搜索Flow更为可靠。 <br><br>  CMxQL函数<i>FindByInitialization（）</i>将查找给定令牌的变量初始化位置： <br><br><pre> <code class="java hljs">CxList mailboxidInit = entry_point_tokens.FindByInitialization(getMailboxHTTPParams); result = mailboxidInit;</code> </pre> <br> 结果： <br><br><img src="https://habrastorage.org/webt/cp/e7/5q/cpe75qru5pcwzikvaona3h7w67c.png"><br><br><h3>  IDOR：步骤5。查找从webRemoteMethods到中间件方法的所有调用以及这些调用的参数 </h3><br> 所谓中间件，是指代码比HTTP API请求的处理方法更深，即比用户请求的入口点更深。 例如，对于上面的屏幕截图，这些是<i>User</i>类的方法，对<i>user.getSettings（）</i>和<i>user.getSecureSettings（）的</i>调用： <br><br><pre> <code class="java hljs">CxList middlewareMethods = All.FindByShortName(<span class="hljs-string"><span class="hljs-string">"user"</span></span>).GetRightmostMember(); CxList middlewareMethodsParams = entry_point_tokens.GetParameters(middlewareMethods); result = middlewareMethodsParams;</code> </pre> <br> 首先，我们选择名称为user的所有令牌，然后使用<i>GetRightmostMember（）</i>选择中间件的调用令牌。 方法调用链中的<i>GetRightmostMember（）</i>将返回最右边的一个。 然后，使用<i>GetParameters（）</i>导出找到的方法的参数。 <br><br> 结果： <br><br><img src="https://habrastorage.org/webt/8b/mm/2a/8bmm2ad7zg-xwponufdxuocn-t0.png"><br><br><h3>  IDOR：步骤6。查找依赖于mailboxid的中间件方法 </h3><br> 流量分析使用<i>* ImpactdBy *</i>和<i>* InfluncingOn *方法</i> 。 它们之间的区别在名称上很明显。 <br><br> 例如： <br><br><pre> <code class="java hljs">All.InfluencedBy(getMailboxHTTPParams)</code> </pre> <br> 将遍历集合All并找到所有依赖于<i>getMailboxHTTPParams的</i>令牌。 <br><br> 可以用另一种方式写同样的东西： <br><br><pre> <code class="java hljs">getMailboxHTTPParams.InfluencingOn(All)</code> </pre> <br><br> 要搜索取决于<i>mailboxidInit的</i>令牌： <br><br><pre> <code class="java hljs">CxList apiPotentialIDOR = entry_point_tokens.InfluencedByAndNotSanitized(mailboxidInit, idorSanitizer); result = apiPotentialIDOR;</code> </pre><br> 结果： <br><br><img src="https://habrastorage.org/webt/xl/wa/rq/xlwarqf4bvr96xchztinpiua7h4.png"><br><br><h3>  IDOR：步骤7。查找所有位置以定义中间件方法 </h3><br> 让我们找到可在处理用户请求的地方使用的所有中间方法的定义。 为此，我们突出显示它们的公共属性，例如，在所有此类方法中，都有一个request <i>（）</i>对象创建，该对象创建为CMx类型的<i>ObjectCreateExpr</i> ： <br><br><pre> <code class="java hljs">CxList requests = (All - exclusionList).FindByType(typeof(ObjectCreateExpr)).FindByName(<span class="hljs-string"><span class="hljs-string">"*Request*"</span></span>); CxList middlewareDecl = requests.GetAncOfType(typeof(MethodDecl)); result = middlewareDecl;</code> </pre> <br><br>  <i>（全部</i> -exclusionList <i>）</i> -您可以对集合进行此减法，然后从结果中调用所需的CMxQL函数。 现在， <i>请求</i>包含名称为“ <i>请求”的</i>所有令牌以及与对象创建相对应的类型。 <br><br> 接下来，使用熟悉的<i>GetAncOfType（），</i>找到类型为<i>MethodDecl</i>的父标记。 <br><br> 结果： <br><br><img src="https://habrastorage.org/webt/pp/ie/21/ppie21nmruhnqfekmune0fa5ytu.png"><br><br><h3>  IDOR：步骤8。遍历所有apiPotentialIDOR，并仅选择其中没有对mailboxid对象的所有者进行验证的中间件Decl </h3><br> 在请求的最后部分，我们将确定直接从入口点方法中调用哪些中间件方法，而不检查谁的<i>信箱ID</i>属于谁。 然后结合Flow以更方便地分析结果。 <br><br> 我们尚未使用的新功能： <br>  <i>GetCxListByPath（）</i> -需要此函数来迭代Flow，如果不使用它，则CMx将压缩Code Element中的Flow（在第一个流节点中） <br>  <i>级联*（）</i> -将多个流合并为一个所需的许多函数 <br>  <i>FindByParameters（）</i> -通过特定参数标记查找方法 <br>  <i>GetName（）</i> -将返回带有令牌名称的字符串，如果CxList中有多个元素，则它将返回第一个。 该方法仅在迭代集合的元素时使用。 <br><br> 请求的最后一部分： <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    CxList vulns = All.NewCxList(); //   Flow  apiPotentialIDOR foreach(CxList cxFlow in apiPotentialIDOR.GetCxListByPath()) { //    Flow CxList endNode = cxFlow.GetStartAndEndNodes(CxList.GetStartEndNodesType.EndNodesOnly); //       flow (mailboxid) CxList method_call = entry_point_tokens.FindByParameters(endNode); //     CxList method_decl = middlewareDecl.FindByShortName(method_call.GetName()); //     if (method_decl.Count &gt; 0) { //       CxList _all = (All - exclusionList).GetByAncs(method_decl); //       if (_all.FindByName(idorSanitizer).Count &gt; 0) { //  ,       cxLog.WriteDebugMessage("find sanitized in method: " + method_call.GetName()); //  ,   Flow     vulns } else { //     Flow       vulns.Add(cxFlow.ConcatenatePath(method_call).ConcatenatePath(method_decl)); cxLog.WriteDebugMessage("find NOT sanitized in method: " + method_call.GetName()); } } }</span></span></code> </pre> <br><br> 结果： <br><br><img src="https://habrastorage.org/webt/_z/qs/rj/_zqsrju8bqoni7u0ksolmokizhe.png"><br><br> <i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们使用</font><i><font style="vertical-align: inherit;">CocatenatePath，</font></i><font style="vertical-align: inherit;">以便在分析所有位置时可以方便地浏览代码。</font><font style="vertical-align: inherit;">此方法将一个代码元素附加到流。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IDOR：对IDOR的最终搜索 </font></font></h3><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// 1.   CxList exclusionList = All.FindByFileName("*WebMethodContext.java"); // 2.     CxList idorSanitizer = All.FindByName("*validateMailbox*"); // 3.    –    HTTP  CxList webRemoteMethods = All.FindByCustomAttribute("WebRemote").GetAncOfType(typeof(MethodDecl)); // 4.         HTTP  mailboxid //     CxList entry_point_tokens = All.NewCxList(); foreach (CxList method in webRemoteMethods) { CxList method_tokens = All.GetByAncs(method); if (method_tokens.FindByName(idorSanitizer).Count &gt; 0) { } else { entry_point_tokens.Add(method_tokens); } } //    HTTP    -  CxList getMailboxHTTPParams = entry_point_tokens.FindByName("\"mailboxId\"") + entry_point_tokens.FindByName("\"mid\"") + entry_point_tokens.FindByName("\"boxid\""); CxList mailboxidInit = entry_point_tokens.FindByInitialization(getMailboxHTTPParams); // 5.      middleware     CxList middlewareMethods = All.FindByShortName("user").GetRightmostMember(); CxList middlewareMethodsParams = entry_point_tokens.GetParameters(middlewareMethods); // 6.  middleware ,     mailboxid CxList apiPotentialIDOR = entry_point_tokens.InfluencedByAndNotSanitized(mailboxidInit, idorSanitizer); // 7.      middleware      CxList requests = (All - exclusionList).FindByType(typeof(ObjectCreateExpr)).FindByName("*Request*"); CxList middlewareDecl = requests.GetAncOfType(typeof(MethodDecl)); // 8.    apiPotentialIDOR     middlewareDecl,      CxList vulns = All.NewCxList(); foreach(CxList cxFlow in apiPotentialIDOR.GetCxListByPath()) { CxList endNode = cxFlow.GetStartAndEndNodes(CxList.GetStartEndNodesType.EndNodesOnly); CxList method_call = entry_point_tokens.FindByParameters(endNode); CxList method_decl = middlewareDecl.FindByShortName(method_call.GetName()); if (method_decl.Count &gt; 0) { CxList _all = (All - exclusionList).GetByAncs(method_decl); if (_all.FindByName(idorSanitizer).Count &gt; 0) { cxLog.WriteDebugMessage("find sanitized in method: " + method_call.GetName()); } else { vulns.Add(cxFlow.ConcatenatePath(method_call).ConcatenatePath(method_decl)); cxLog.WriteDebugMessage("find NOT sanitized in method: " + method_call.GetName()); } } } result = vulns;</span></span></code> </pre><br><br><h2> 结论 </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Checkmarx可以轻松地将代码解析为令牌，同时确定其类型。</font><font style="vertical-align: inherit;">此外，静态分析器还可以很好地搜索令牌，例如，找到当前令牌的父令牌，查找变量的初始化，查找方法的参数等。</font><font style="vertical-align: inherit;">Flow在构建方面几乎同样出色（但有时仍然会遗漏）。</font><font style="vertical-align: inherit;">所有这些使得可以像处理任何数据库一样使用该代码，不同之处在于该代码的结构不是预定义的，您必须自己“自定义”它。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了大大减少误报的数量，请注意以下几点：</font></font><br><ul><li>     ,       (   ). </li><li>     ,    (  ). ,     «Privacy Violation»,   ,         ,    Web UI.    , ..       UI    .       TLS        XSS     . </li><li>  -    ,           (,   ). ,   XXE  ,   , -    ,   . </li><li>   false positive,   ,           CMxQL   FindBy/GetBy.         ,     (        SQL). </li><li>   false positives,    ,      ,   ,       ,   CMx,      . ,       LDAP ,      .       c LDAP-   ,   ,      . </li></ul><br><br>   how-to     «hello world»  ,        Checkmarx. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN477742/">https://habr.com/ru/post/zh-CN477742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN477732/index.html">水下导航系统的手指分类错误</a></li>
<li><a href="../zh-CN477734/index.html">使用Photos应用程序了解UICollectionViewLayout</a></li>
<li><a href="../zh-CN477736/index.html">测试人员的路径：从“手刹”到自动化</a></li>
<li><a href="../zh-CN477738/index.html">iKassa或我们如何驯服“数字收银员”</a></li>
<li><a href="../zh-CN477740/index.html">在哪里可以用眼睛观察这架望远镜？</a></li>
<li><a href="../zh-CN477744/index.html">为什么专业人士有时会创建不良的应用程序？</a></li>
<li><a href="../zh-CN477752/index.html">后端联合＃5：Shawarma-微服务，分布式系统和Kafka</a></li>
<li><a href="../zh-CN477754/index.html">与Arduino比较micro：bit。 以及如何获得微型：如果您不是英国学生，则免费获得一点？</a></li>
<li><a href="../zh-CN477756/index.html">我们如何结合两个银行CRM系统</a></li>
<li><a href="../zh-CN477758/index.html">“医生，将其从账单中删除”：我们如何在VHI中寻找非法服务</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>