<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💇🏼 💘 😀 Apa yang diketik dan cara merakit proyek C ++ 👩🏾‍💼 👪 😌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Setelah mengajukan pertanyaan ini, saya pertama-tama merumuskan persyaratan: kaku dan opsional (tetapi diinginkan) untuk sistem perakitan dan lingkung...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apa yang diketik dan cara merakit proyek C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442682/">  Setelah mengajukan pertanyaan ini, saya pertama-tama merumuskan persyaratan: kaku dan opsional (tetapi diinginkan) untuk sistem perakitan dan lingkungan pengembangan grafis. <br>  Saya ingin segera mencatat bahwa ini bukan tentang menulis kode C ++ untuk beberapa platform tertentu seperti Android atau kerangka kerja, misalnya Qt, di mana semuanya siap, baik dengan membangun dan mengedit kode, tetapi tentang kode generik yang tidak terikat pada platform tertentu atau ke kerangka kerja. <br><a name="habracut"></a><br><h3>  Umum: </h3><br><ul><li>  Gratis. </li><li>  Cross-platform (setidaknya Windows dan Linux). </li></ul><br><h3>  Membangun sistem: </h3><br><ul><li>  Satu tim untuk membangun platform yang berbeda. </li><li>  Rakitan tambahan dengan akun yang benar dari semua dependensi: file header dan komponen pihak ketiga yang digunakan untuk rakitan. </li><li>  Skrip perakitan hanya boleh berisi konfigurasi minimum yang diperlukan khusus untuk proyek tertentu.  Logika umum build seharusnya tidak berkeliaran dari script ke script, tetapi terletak di sistem build atau plugin-nya. </li><li>  Perakitan paralel bawaan. </li><li>  Dukungan untuk berbagai toolchain (setidaknya gcc, Visual C ++, Dentang). </li><li>  Kemampuan untuk mengubah toolchain dengan biaya minimal, tanpa menulis ulang seluruh skrip build. </li><li>  Opsi build yang mudah diganti: Debug dan Release. </li><li>  Ketergantungan pada beberapa alat tingkat rendah tambahan seperti make benar-benar tidak diinginkan.  Singkatnya, sistem perakitan harus mandiri. </li><li>  Integrasi sistem pembangunan dengan repositori komponen pihak ketiga seperti pkg-config atau Maven Central untuk JVM sangat diinginkan. </li><li>  Sistem build harus diperluas oleh plugins, as  prosedur perakitan untuk setiap proyek tertentu mungkin lebih rumit daripada konsep konstruksi standar (pembuatan kode, misalnya, atau perakitan beberapa gambar non-standar). </li><li>  Lebih nyaman bila skrip build adalah sejenis bahasa pemrograman tingkat tinggi atau DSL yang lebih baik.  Ini akan memungkinkan Anda untuk tidak terlalu mahal dan ekspresif mengubah perilaku konstruksi secara langsung dalam skrip. </li><li>  Ketika mengonfigurasi kompiler dan tautan dari skrip build, sangat nyaman ketika sistem menyediakan setidaknya abstraksi dasar: misalnya, saya ingin menambahkan makro - mengapa berpikir parameter baris perintah kompiler yang bertanggung jawab untuk ini?  / D pada MSVC atau -D pada gcc - biarkan sistem build menyelesaikan sendiri rincian yang tidak penting ini. </li><li>  Integrasi yang baik dengan lingkungan pengembangan grafis (IDE). </li></ul><br><h3>  IDE: </h3><br><ul><li>  Kemampuan IDE untuk "memahami" kode C ++ dengan benar.  IDE harus dapat mengindeks semua file proyek, serta semua file dan definisi header dan sistem pihak ketiga (mendefinisikan, makro). </li><li>  IDE harus menyediakan kemampuan untuk menyesuaikan perintah untuk membangun proyek, serta tempat mencari file header dan definisi. </li><li>  Seharusnya secara efektif membantu dalam mengetik kode, mis.  menawarkan opsi penyelesaian yang paling cocok, memperingatkan tentang kesalahan sintaks, dll. </li><li>  Menavigasi proyek besar harus nyaman, dan menemukan penggunaannya cepat dan mudah. </li><li>  Berikan banyak peluang untuk refactoring: penggantian nama, dll. </li><li>  Yang juga dibutuhkan adalah kemampuan untuk menghasilkan kode boilerplate - membuat kerangka kerja kelas baru, file header, dan file implementasi.  Generasi getter / setter, definisi metode, metode virtual overloading, pola implementasi murni kelas virtual (antarmuka), dll. </li><li>  Menyoroti dan mendukung tag dokumentasi kode seperti Doxygen. </li></ul><br>  Mengingat "Daftar Keinginan" ini, saya telah mempertimbangkan beberapa sistem perakitan dan lingkungan pengembangan grafis.  Ulasan singkat ini tidak dengan cara apa pun berpura-pura menjadi lengkap dan berisi penilaian subyektif saya, tetapi mungkin bagi seseorang tampaknya berguna sebagai langkah awal. <br><br>  <b>Jadikan</b> - <i>[kuno]</i> mastodon dan veteran terhormat sistem perakitan, yang semua orang masih tidak ingin pensiun, tetapi dipaksa untuk mengambil lebih banyak dan lebih banyak proyek baru.  Ini adalah alat tingkat sangat rendah dengan bahasa spesifiknya sendiri, di mana untuk spasi alih-alih tab Anda langsung terancam eksekusi di tempat.  Dengan menggunakan make, Anda dapat melakukan apa pun yang Anda inginkan - membangun kompleksitas apa pun, tetapi Anda harus membayarnya dengan upaya menulis skrip, serta tetap memperbarui.  Akan lebih mahal untuk mentransfer logika pembangunan dari proyek ke proyek.  Ada beberapa pengganti make-up modern: seperti ninja dan selai, tetapi mereka tidak mengubah esensi - ini adalah alat tingkat yang sangat rendah.  Sama seperti di assembler, Anda dapat menulis apa pun yang Anda suka, tetapi apakah itu layak? <br><br>  <b>CMake</b> - <i>[Abad Pertengahan]</i> upaya pertama untuk menjauh dari detail tingkat rendah dari merek.  Tapi, sayangnya, tidak mungkin untuk melangkah jauh - mesin di sini adalah merek yang sama dengan CMake yang menghasilkan file-file besar berdasarkan pada file teks lain dengan deskripsi build tingkat tinggi.  Qmake bekerja dengan cara yang sama.  Pendekatan ini mengingatkan saya pada fasad indah sebuah rumah kayu tua, yang dengan hati-hati dilapisi dengan plastik segar.  CMake adalah sistem yang stabil dan sudah terbukti, bahkan ada integrasi dengan Eclipse, tetapi, sayangnya, itu tidak cocok untuk saya karena bertentangan dengan persyaratan yang diuraikan di awal artikel.  Di Linux, semuanya tampak baik-baik saja, tetapi jika Anda perlu membangun proyek yang sama di bawah Windows menggunakan MSVC - dan saya lebih suka kompiler asli ke MinGW, file untuk NMake akan dihasilkan.  Yaitu  ketergantungan pada alat lain dan perintah bangun yang berbeda untuk platform lain.  Dan semua ini adalah konsekuensi dari arsitektur yang agak bengkok, ketika sebagian besar pekerjaan dilakukan oleh "pembantu" lainnya. <br><br>  <b>Semut</b> - <i>[renaisans]</i> semacam klon make untuk Jawa.  Terus terang, saya menghabiskan sedikit waktu untuk memeriksa Ant (dan juga Maven) sebagai sistem build untuk C ++.  Dan saya langsung merasa bahwa dukungan C ++ di sini murni "untuk pertunjukan" dan tidak cukup berkembang.  Terlebih lagi, bahkan dalam proyek Java, Sem sudah jarang digunakan.  Sebagai bahasa scripting (dan juga untuk Maven) XML dipilih di sini - bahasa burung keji ini :).  Fakta optimisme ini tidak menambah saya sama sekali untuk perendaman lebih lanjut dalam topik ini. <br><br>  <b>SCons</b> adalah sistem build lintas platform mandiri ( <i>era baru) yang</i> ditulis dengan Python.  SCons bekerja sama baiknya dengan Java dan C ++ build.  Ketergantungan header untuk rakitan tambahan dikerjakan dengan benar (seperti yang saya mengerti, database tertentu dibuat dengan metadata build), dan pada Windows MSVC bekerja tanpa rebana.  Bahasa skrip build adalah Python.  Sistem yang sangat baik, dan saya bahkan ingin menyelesaikan penelitian saya tentang itu, tetapi seperti yang Anda tahu, tidak ada batasan untuk kesempurnaan, dan pemeriksaan yang lebih rinci mengungkapkan beberapa kelemahan dalam terang persyaratan di atas. <br><br>  Tidak ada pengaturan abstrak untuk kompiler, jadi jika, misalnya, Anda perlu mengubah rantai alat, Anda mungkin perlu mencari tempat di skrip build untuk membuat perubahan.  Makro yang sama harus ditulis dengan kondisi bersarang - jika Windows maka lakukan, jika GCC melakukannya, dll. <br><br>  Tidak ada dukungan untuk artefak jarak jauh dan ketergantungan tingkat tinggi dari satu bangunan di atas yang lain. <br><br>  Arsitektur umum dibangun sehingga apa yang disebut pembangun yang didefinisikan pengguna ada hampir secara terpisah dan tidak ada cara untuk menggunakan logika build yang sudah ada untuk melengkapi dengan Anda sendiri melalui plug-in sederhana.  Tetapi secara keseluruhan itu adalah pilihan yang layak untuk proyek-proyek kecil. <br><br>  <b>Gradle</b> <i>[sekarang]</i> - Saya sudah memiliki pengalaman positif menggunakan proyek Gradle untuk Jawa dan Kotlin dan saya punya harapan besar untuk itu. <br><br>  Untuk bahasa JVM, Gradle memiliki konsep yang sangat nyaman untuk bekerja dengan perpustakaan yang diperlukan untuk membangun proyek (membangun dependensi): <br><br><ul><li>  Skrip mendaftarkan alamat repositori dengan artefak: maven atau ivy - misalnya.  Itu juga bisa menjadi repositori dari jenis / format lain - jika saja ada plugin untuk itu.  Ini bisa berupa repositori jarak jauh, beberapa Maven Central atau hosting pribadi Anda di suatu tempat di jaringan atau hanya perwakilan lokal di sistem file. </li><li>  Juga, di bagian khusus skrip, dependensi untuk pembangunan ditunjukkan secara langsung - daftar artefak biner yang diperlukan dengan versi. </li><li>  Sebelum membangun, Gradle mencoba menyelesaikan semua dependensi dan mencari artefak dengan versi yang diberikan di semua repositori.  Binari dimuat ke dalam cache dan secara otomatis ditambahkan ke build.  Ini sangat mudah dan saya berharap untuk C ++, mungkin mereka melakukan hal serupa. </li></ul><br>  Pada awalnya, saya memeriksa plugin "lama" untuk dukungan C ++ - `cpp` - dan kecewa - struktur skrip tidak intuitif: model, komponen, nativespec - dan beberapa jenis mishmash dari berbagai jenis biner: baik executable dan libraries semuanya dalam satu skrip.  Tidak jelas di mana harus menempatkan unit test.  Struktur ini sangat berbeda dari apa yang saya gunakan untuk Java. <br><br>  Tetapi ternyata ada juga plugin “baru” untuk dukungan C ++: `cpp-application` - untuk aplikasi,` cpp-library` untuk perpustakaan: statis dan dinamis, dan akhirnya `cpp-unit-test` untuk pengujian unit.  Dan itulah yang saya cari!  :) <br><br>  Struktur folder proyek default mirip dengan proyek Java: <br><br><ul><li>  <i>src / main / cpp</i> - folder root untuk file proyek <i>* .cpp</i> utama. </li><li>  <i>src / main / header</i> - folder untuk file header internal. </li><li>  <i>src / main / public</i> - folder untuk header diekspor - untuk perpustakaan. </li><li>  <i>src / test / cpp</i> - folder untuk file <i>* .cpp</i> dari unit uji. </li></ul><br>  Struktur seperti itu tidak kaku - selalu dapat diubah dalam skrip, tetapi tetap tidak perlu melakukan ini tanpa kebutuhan khusus, itu cukup masuk akal. <br><br>  Omong-omong, skrip build biasanya <i>build.gradle</i> , itu adalah DSL dari bahasa Groovy atau Kotlin ( <i>build.gradle.kts</i> ) untuk dipilih.  Di dalam skrip, API Gradle dan API plugin yang ditambahkan ke skrip selalu tersedia. <br><br>  Untuk perpustakaan, Anda dapat memilih jenis: statis atau dinamis (atau kumpulkan kedua opsi). <br>  Secara default, dua opsi build dikonfigurasikan: Debug ( <i>gradle assemble</i> ) dan Release ( <i>gradle assembleRelease</i> ). <br><br>  Prinsip menjalankan unit test adalah sama seperti di Jawa: tes gradle akan membangun komponen utama, kemudian tes, jika mereka berada di folder <i>src / test / cpp</i> , dan kemudian jalankan aplikasi tes. <br><br>  Definisi yang terkenal dapat diatur secara abstrak - Gradle sendiri akan menghasilkan opsi kompilator yang diperlukan.  Ada beberapa pengaturan abstrak lainnya seperti optimasi, informasi debug, dll. <br><br>  Di luar kotak, GCC, Microsoft Visual C ++, Dentang didukung. <br><br>  Sistem plug-in sangat dikembangkan, dan arsitektur ekstensi nyaman - Anda dapat mengambil logika yang sudah jadi dan menghias / memperluasnya.  Ada dua jenis plugin: dinamis, yang ditulis langsung di Groovy dan disematkan dalam skrip atau ditulis dalam Java (atau dalam bahasa lain dengan JVM) dan dikompilasi menjadi artefak biner.  Untuk plugin, ada artifactory Gradle gratis di mana siapa saja dapat memposting plugin mereka, yang akan tersedia untuk semua orang.  Yang berhasil dilakukan oleh penulis artikel ini :) tetapi lebih lanjut tentang itu nanti. <br>  Saya ingin membahas lebih rinci tentang sistem bekerja dengan komponen biner di Gradle untuk C ++: hampir sama dengan di Jawa!  Membangun dependensi bekerja hampir sama dengan yang saya jelaskan di atas. <br><br>  Ambil contoh bangunan komposit: <br><br><ul><li>  utils - folder perpustakaan </li><li>  app adalah folder dengan aplikasi yang menggunakan utils. </li><li>  settings.gradle - File Gradle untuk menggabungkan dua komponen ini ke dalam build komposit. </li></ul><br>  Dalam file <i>build.gradle</i> dari folder aplikasi, cukup untuk menulis ketergantungan berikut: <br><br><pre><code class="java hljs">dependencies { <span class="hljs-function"><span class="hljs-function">implementation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">project</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">':utils'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> }</span></span></code> </pre> <br>  Gradle akan melakukan sisanya!  Tambahkan path ke kompiler untuk mencari file header utils dan menautkan binar perpustakaan. <br><br>  Dan semua ini bekerja dengan baik baik di Linux GCC dan Windows MSVC. <br>  Membangun tambahan, tentu saja, juga berfungsi dengan baik, dan jika Anda mengubah header di utils, aplikasi akan dibangun kembali. <br><br>  Ternyata, Gradle melangkah lebih jauh dan menyadari kemampuan untuk mengunggah artefak C ++ ke Repositori Maven!  Untuk melakukan ini, gunakan plugin standar `maven-publish`. <br><br>  Dalam skrip, Anda perlu menentukan repositori tempat Anda ingin meletakkan artefak dan membuat gradle publish (atau gradle publishToMavenLocal untuk publikasi lokal).  Gradle akan menjatuhkan proyek dan <br>  lay out dalam format khusus - dengan mempertimbangkan versi, platform, arsitektur dan opsi bangun. <br><br>  File perpustakaan biner sendiri dan file header publik diletakkan - dari folder <i>src / main / public</i> . <br><br>  Jelas bahwa Anda tidak dapat mengunggah artefak C ++ ke Maven Cental - tidak akan lulus pemeriksaan sistem wajib.  Tetapi meningkatkan repositori Maven di jaringan sama sekali tidak sulit, dan Anda tidak perlu melakukan apa pun untuk repositori lokal - itu hanya folder pada disk. <br><br>  Sekarang jika Anda ingin menggunakan perpustakaan seseorang di proyek Anda, Anda dapat menulis sesuatu seperti ini di skrip build: <br><br><pre> <code class="java hljs"> repositories { maven { url = <span class="hljs-string"><span class="hljs-string">'https://akornilov.bitbucket.io/maven'</span></span> } } unitTest { dependencies { implementation <span class="hljs-string"><span class="hljs-string">'org.bitbucket.akornilov.tools:gtest:1.8.1'</span></span> } }</code> </pre><br>  Dikatakan di sini bahwa untuk pengujian unit Anda perlu menggunakan versi artefak gtest 1.8.1 dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori Maven</a> . <br><br>  By the way, ini adalah repositori yang sangat nyata di mana tes saya membangun Google Test v1.8.1 diposting, dibangun menggunakan Gradle untuk Windows dan Linux x86_64. <br><br>  Secara alami, semua pekerjaan tingkat rendah dalam mengonfigurasi kompiler dan tautan untuk bekerja dengan komponen eksternal Gradle dilakukan.  Cukuplah bagi Anda untuk menyatakan niat Anda untuk menggunakan perpustakaan ini dan itu dengan versi ini dan itu dari repositori ini dan itu. <br><br>  Untuk integrasi dengan IDE, Gradle memiliki dua plugin bawaan untuk Visual Studio dan Xcode.  Mereka bekerja dengan baik, kecuali bahwa plugin Visual Studio mengabaikan kode uji unit dari folder <i>src / test / cpp</i> dan menghasilkan proyek hanya untuk kode utama. <br><br><h3>  Sekarang saatnya berbicara tentang IDE dan bagaimana membuat mereka berteman dengan Gradle </h3><br>  <b>Eclipse CDT (2018-12R)</b> adalah produk yang matang dan berkualitas.  Jika ia berhasil mengurai proyek Anda, maka Anda beruntung - itu akan nyaman untuk diedit.  Kemungkinan besar, dia bahkan akan "memahami" jenis mobil yang paling membingungkan.  Tetapi jika tidak ... Maka ia akan dengan keras menekankan segala sesuatu dalam satu baris dengan garis putus-putus merah dan bersumpah dengan kata-kata buruk.  Misalnya, itu tidak mencerna file header standar MSVC dan Windows SDK.  Bahkan cetakan yang sama sekali tidak berbahaya digarisbawahi dengan garis putus-putus merah dan tidak dianggap sebagai sesuatu yang bermakna.  Ada juga std :: string.  Di Linux, dengan gcc asalnya, semuanya baik-baik saja.  Tetapi bahkan ketika mencoba membuatnya untuk mengindeks proyek dari saudara Android Native, masalah dimulai.  Dalam header bionik, ia point-blank menolak untuk melihat definisi size_t, dan bersama dengan semua fungsi yang menggunakannya.  Mungkin, di Windows, Anda dapat memperbaiki situasi jika alih-alih file tajuk Microsoft menyelipkannya, misalnya, Cygwin atau MinGW SDK, tetapi trik ini tidak terlalu menarik bagi saya, saya masih ingin perangkat lunak tingkat ini untuk "memakan apa yang mereka berikan," dan bukan hanya bahwa dia "mencintai". <br>  Kemungkinan untuk menavigasi, refactoring, dan menghasilkan kode templat sangat bagus, tetapi ada pertanyaan untuk penolong saat mengetik huruf: katakanlah kita mengetik beberapa karakter dari nama panjang, mengapa tidak menawarkan opsi penyelesaian?  Tidak, asisten dengan sabar menunggu sampai pengguna bisa.  atau -&gt; atau ::.  Saya harus terus menekan Ctrl + Space - mengganggu.  Di Jawa, kekurangan yang menjengkelkan ini bisa diperbaiki dengan memilih seluruh alfabet dalam CDT sebagai pemicu, tetapi saya tidak menemukan solusi sederhana. <br><br><img src="https://habrastorage.org/webt/1t/bx/ue/1tbxue1gaib5bhyo7xbofdxrapq.png"><br><br><img src="https://habrastorage.org/webt/yh/zi/vp/yhzivpjrupaijmjbfzz7qwefmaq.png"><br><br>  <b>NetBeans 8.1 / 10.0</b> - Saya dulu menggunakan IDE ini untuk Java, saya dikenang sebagai perangkat lunak yang baik dan ringan dengan semua fungsionalitas yang diperlukan.  Untuk C ++, ia memiliki plugin yang dikembangkan bukan oleh komunitas, tetapi langsung oleh NetBeans.  Untuk proyek C ++, ada ketergantungan yang cukup sulit pada make dan gcc.  Editor kode santai.  Saya tidak menemukan hal yang sangat sederhana di generator kode templat: kami menambahkan metode baru di file header kelas - Anda perlu membuat badan metode dalam file cpp - tidak tahu caranya.  Tingkat "pemahaman" kode adalah rata-rata, tampaknya ada sesuatu yang diuraikan, tetapi ada sesuatu yang tidak.  Misalnya, iterasi pada peta dengan auto-iterator sudah sulit baginya.  Dia bersumpah di makro dari Google Test.  Menyesuaikan perintah build bermasalah - pada Linux dengan gcc dan menyediakan (ini terlepas dari kenyataan bahwa sistem build lain sudah digunakan) itu akan berfungsi, pada Windows itu membutuhkan MinGW, tetapi bahkan jika itu dilakukan, ia menolak untuk membangun.  Secara umum, bekerja di NetBeans dengan C ++ adalah mungkin, tetapi saya tidak akan menyebutnya nyaman, saya mungkin perlu benar-benar mencintai lingkungan ini agar tidak memperhatikan berbagai luka. <br><br><img src="https://habrastorage.org/webt/bi/dh/h4/bidhh4mda-r7cqkqd6q9vnu4t4o.png"><br><br><img src="https://habrastorage.org/webt/ze/yp/j1/zeypj1bdofeuljkgfp9wyfdxebc.png"><br><br>  <b>KDevelop 5.3.1</b> - pernah dikandung sebagai alat pengembang untuk KDE (Linux), tetapi sekarang ada versi untuk Windows.  Ini memiliki editor kode yang cepat dan menyenangkan dengan highlight sintaks yang indah (berdasarkan Kate).  Ini tidak akan bekerja untuk merusak sistem build kiri - baginya, sistem build utama adalah CMake.  Ini toleran terhadap header MSVC dan Windows SDK, dalam hal apa pun printf dan std :: string tidak benar-benar mengarah ke kebodohan seperti Eclipse CDT.  Pembantu yang sangat cepat untuk menulis kode - ia menawarkan opsi penyelesaian yang baik segera setelah mengetik.  Ini memiliki peluang menarik untuk menghasilkan kode templat: Anda dapat menulis templat Anda sendiri dan menaruhnya online.  Saat membuat dari templat, Anda dapat terhubung ke database templat yang sudah jadi dan mengunduh yang Anda sukai.  Satu-satunya hal yang mengecewakan: templat bawaan untuk membuat kelas baru berfungsi secara bengkok di bawah Windows dan Linux.  Panduan untuk membuat kelas memiliki beberapa jendela tempat Anda dapat mengonfigurasi banyak hal: konstruktor mana yang diperlukan, anggota kelas mana, dll.  Tetapi pada tahap akhir di bawah Windows beberapa jenis kesalahan muncul pada waktunya untuk membuat teks yang tidak mungkin dan dua file h dan cpp dibuat dalam ukuran 1 byte.  Di Linux, untuk beberapa alasan, Anda tidak dapat memilih konstruktor - tab kosong, dan hanya file header yang dihasilkan dengan benar pada output.  Secara umum, penyakit pada masa kanak-kanak untuk produk yang sudah matang terlihat agak remeh. <br><br><img src="https://habrastorage.org/webt/gb/e_/dt/gbe_dtwtphcqqvxpankzo5k8oqy.png"><br><br><img src="https://habrastorage.org/webt/kp/ap/hf/kpaphf1yrtwflj68xusgqlh2ppa.png"><br><br>  <b>QtCreator 4.8.1 (edisi open source)</b> - mungkin, setelah mendengar nama ini, Anda bingung bagaimana monster ini dipenjara di sini di bawah Qt dengan kit distribusi gigabyte dengan kait.  Tapi ini adalah versi "ringan" dari lingkungan untuk proyek generik.  Kit distribusinya hanya berbobot sekitar 150 MB dan tidak membawa hal-hal khusus untuk Qt dengan itu: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">download.qt.io/official_releases/qtcreator/4.8</a> . <br>  Sebenarnya, dia dapat melakukan hampir semua yang saya tulis dalam persyaratan saya dengan cepat dan benar.  Ini mem-parsing header standar baik Windows dan Linux, mengkustomisasinya ke sistem build apa pun, menyarankan opsi penyelesaian, dengan mudah menghasilkan kelas baru, badan metode, memungkinkan refactoring dan navigasi kode.  Jika Anda hanya ingin bekerja dengan nyaman tanpa terus-menerus memikirkan cara mengatasi masalah ini atau itu, masuk akal untuk melihat QtCreator. <br><br><img src="https://habrastorage.org/webt/w-/6j/ei/w-6jeizzjkklvumkpdjl5oe_mou.png"><br><br><img src="https://habrastorage.org/webt/au/zb/ot/auzbot8u_iam14q88qjedkdmzvu.png"><br><br>  Sebenarnya, masih berbicara tentang apa yang saya tidak punya cukup di Gradle untuk sepenuhnya bekerja: integrasi dengan IDE.  Agar sistem dapat menghasilkan file proyek untuk IDE itu sendiri, di mana perintah untuk membangun proyek sudah akan ditulis, semua file sumber terdaftar, jalur diperlukan untuk mencari file header dan menentukan. <br><br>  Untuk tujuan ini, saya menulis sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">plugin untuk Gradle `cpp-ide-generator`</a> dan diterbitkan di Portal Plugin Gradle. <br><br>  Plugin hanya dapat digunakan dengan `cpp-application`,` cpp-library` dan `cpp-unit-test`. <br>  Berikut adalah contoh penggunaannya di <i>build.gradle</i> : <br><br><pre> <code class="java hljs"> plugins { id <span class="hljs-string"><span class="hljs-string">'cpp-library'</span></span> id <span class="hljs-string"><span class="hljs-string">'maven-publish'</span></span> id <span class="hljs-string"><span class="hljs-string">'cpp-unit-test'</span></span> id <span class="hljs-string"><span class="hljs-string">'org.bitbucket.akornilov.cpp-ide-generator'</span></span> version <span class="hljs-string"><span class="hljs-string">'0.3'</span></span> } library { <span class="hljs-comment"><span class="hljs-comment">// Library specific parameters } // Configuration block of plugin: ide { autoGenerate = false eclipse = true qtCreator = true netBeans = true kdevelop = true }</span></span></code> </pre><br>  Plugin mendukung integrasi dengan semua lingkungan pengembangan grafis di atas, tetapi di blok konfigurasi plugin - ide, Anda dapat menonaktifkan dukungan untuk IDE yang tidak perlu: <br><br><pre> <code class="java hljs"> kdevelop = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span></code> </pre> <br>  Jika parameter <i>autoGenerate</i> disetel ke true, file proyek untuk semua IDE yang diizinkan akan dihasilkan secara otomatis tepat saat pembuatan.  Juga, dalam mode pembuatan otomatis, file proyek akan dihapus ketika build dibersihkan: <i>gradle clean</i> . <br><br>  Generasi tambahan didukung, mis.  hanya file yang memerlukan pembaruan nyata yang akan diperbarui. <br><br>  Berikut adalah daftar tujuan yang ditambahkan plugin: <br><br><ul><li>  generateIde - menghasilkan file proyek untuk semua IDE yang diizinkan. </li><li>  cleanIde - hapus file proyek untuk semua IDE yang diizinkan. </li><li>  generateIde [name] - menghasilkan file proyek untuk IDE dengan nama yang diberikan (IDE harus diizinkan), misalnya generateIdeQtCreator. </li><li>  Nama yang tersedia: Eclipse, NetBeans, QtCreator, KDevelop. </li><li>  cleanIde [name] - hapus file proyek untuk IDE dengan nama yang diberikan, misalnya cleanIdeQtCreator. </li></ul><br>  Selama pembuatan, plugin “mengendus” build dan mengekstrak semua informasi yang diperlukan untuk membuat file proyek.  Setelah membuka proyek, semua file sumber harus terlihat di IDE, path ke semua header harus didaftarkan, dan perintah build dasar untuk mengkonfigurasi / membangun / menghapus juga harus dikonfigurasi. <br><br>  Plugin kedua yang harus saya lakukan disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">`cpp-build-tuner`</a> dan juga bekerja bersama-sama dengan cpp-application`,` cpp-library` dan `cpp-unit-test`. <br><br>  Plugin tidak memiliki pengaturan, cukup untuk mengunggahnya: <br><br><pre> <code class="java hljs"> plugins { id <span class="hljs-string"><span class="hljs-string">'cpp-library'</span></span> id <span class="hljs-string"><span class="hljs-string">'maven-publish'</span></span> id <span class="hljs-string"><span class="hljs-string">'cpp-unit-test'</span></span> id <span class="hljs-string"><span class="hljs-string">'org.bitbucket.akornilov.cpp-build-tuner'</span></span> version <span class="hljs-string"><span class="hljs-string">'0.5'</span></span> }</code> </pre><br>  Plugin melakukan manipulasi kecil dengan pengaturan rantai alat (kompiler dan tautan) untuk berbagai opsi pembuatan - Debug dan Rilis.  MSVC, gcc, Dentang didukung. <br><br>  Ini terutama berlaku untuk MSVC, karena secara default, sebagai hasil dari rilis build, Anda akan mendapatkan "tebal", bukan binar estetika dengan informasi bazhdash dan pustaka standar yang terhubung secara statis.  Saya “memata-matai” bagian dari pengaturan untuk MSVC di Visual Studio itu sendiri, yang secara default menambah proyek C ++.  Untuk gcc / CLang dan MSVC, optmizations waktu tautan termasuk dalam profil Release. <br><br>  <i>Catatan: Plugin diuji dengan versi terbaru Gradle v5.2.1 dan tidak diuji kompatibilitasnya dengan versi sebelumnya.</i> <br><br>  Kode sumber plugin, serta contoh sederhana menggunakan Gradle untuk pustaka: statis dan dinamis, serta aplikasi yang menggunakannya dapat dilihat: bitbucket.org/akornilov/tools next gradle / cpp. <br><br>  Contoh-contoh ini juga menunjukkan cara menggunakan Google Test untuk pustaka pengujian unit. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Repositori Maven dengan Google Test v1.8.1 dibangun di Gradle (tanpa mock).</a> <br><br>  <b>UPD:</b> <br><br>  Versi Windows dari <b>QtCreato yang</b> lebih tua dari <b>4.6.2</b> (dan setidaknya pada saat menulis baris ini, hingga <b>4.10</b> inklusif) telah “lupa bagaimana” untuk memahami MSVC SDK.  Semua std :: space digarisbawahi dalam warna merah dan menolak untuk mengindeks.  Oleh karena itu, saat ini, versi 4.6.2 paling cocok untuk bekerja di bawah Windows. <br><br>  Versi baru dari plugin <code>cpp-build-tuner</code> <b>v1.0</b> telah dirilis (dan <code>cpp-ide-generator</code> <b>v0.5</b> adalah perbaikan kecil). <br>  1) Menambahkan blok konfigurasi ke <code>cpp-build-tuner</code> . <br><pre> <code class="javascript hljs">buildTuner { lto = <span class="hljs-literal"><span class="hljs-literal">false</span></span> gtest = <span class="hljs-string"><span class="hljs-string">'1.8.1'</span></span> libraries { common = [<span class="hljs-string"><span class="hljs-string">'cutils.lib'</span></span>] windows = [<span class="hljs-string"><span class="hljs-string">'ole32'</span></span>, <span class="hljs-string"><span class="hljs-string">'user32'</span></span>] linux = [<span class="hljs-string"><span class="hljs-string">'pthread'</span></span>, <span class="hljs-string"><span class="hljs-string">'z'</span></span>] } libDirs.common = [<span class="hljs-string"><span class="hljs-string">'../build/debug'</span></span>, <span class="hljs-string"><span class="hljs-string">'../release'</span></span>] }</code> </pre><br>  <b>lto</b> (boolean) - Mengaktifkan atau menonaktifkan LTO untuk rilis rilis.  Diaktifkan secara default. <br><br>  <b>gtest</b> (string) - Menambahkan dukungan Google Test untuk pengujian unit.  Saat ini hanya versi 1.8.1 yang didukung untuk GCC, MinGW-W64, dan MSVC. <br><br>  <b>perpustakaan</b> (wadah) - daftar perpustakaan untuk dihubungkan.  Di dalam wadah ada tiga bidang (daftar baris): <code>common</code> - perpustakaan untuk platform apa pun, <code>windows</code> - hanya untuk Windows dan <code>linux</code> - hanya untuk Linux. <br><br>  <b>libDirs</b> (container) - daftar folder untuk mencari perpustakaan dengan linker.  Struktur wadah sama dengan daftar perpustakaan. <br><br>  2) Menambahkan kemampuan untuk menjalankan aplikasi untuk aplikasi- <code>cpp-application</code> .  Plugin menambahkan tugas tambahan ke proyek untuk ini: <code>run</code> , <code>runDebug</code> (sama seperti <code>run</code> ) dan <code>runRelease</code> .  Tugas tergantung pada <code>assemble</code> , <code>assembleDebug</code> dan <code>assembleRelease</code> masing-masing. <br>  Seperti plugin Java Application standar, Anda dapat melewatkan parameter baris perintah saat startup: <code>gradle run --args="arg1 arg2 ..."</code> . <br><br>  <b>UPD</b> <br><br>  Sehubungan dengan perubahan plugin hosting, grup diubah: <br><pre> <code class="javascript hljs">plugins { id <span class="hljs-string"><span class="hljs-string">'loggersoft.cpp-build-tuner'</span></span> version <span class="hljs-string"><span class="hljs-string">'1.1'</span></span> id <span class="hljs-string"><span class="hljs-string">'loggersoft.cpp-ide-generator'</span></span> version <span class="hljs-string"><span class="hljs-string">'0.5'</span></span> }</code> </pre><br><br>  Alamat proyek baru: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gradle-cpp.sourceforge.io</a> <br><br>  Dokumentasi: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sourceforge.net/p/gradle-cpp/wiki/cpp-build-tuner</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sourceforge.net/p/gradle-cpp/wiki/cpp-ide-generator</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id442682/">https://habr.com/ru/post/id442682/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id442672/index.html">Cara memberi umpan balik: 9 aturan</a></li>
<li><a href="../id442674/index.html">Instans Keamanan Informasi di platform attackdefense.com</a></li>
<li><a href="../id442676/index.html">Where Dreams Lead: Underground</a></li>
<li><a href="../id442678/index.html">Proyek terbesar dalam litografi stereo: kerangka raksasa dicetak pada printer 3D</a></li>
<li><a href="../id442680/index.html">Teknologi penggantian sensorik akan memungkinkan Anda untuk melihat dunia dengan bantuan suara: bagaimana neuroplastisitas otak manusia bekerja</a></li>
<li><a href="../id442684/index.html">Performa situs seimbang. Bagian 3: Konten</a></li>
<li><a href="../id442686/index.html">Tutorial DataPower</a></li>
<li><a href="../id442688/index.html">Analisis data scala - kebutuhan mendesak atau peluang yang menyenangkan?</a></li>
<li><a href="../id442690/index.html">Misi Lunar "Bereshit" - selfie di latar belakang Bumi</a></li>
<li><a href="../id442692/index.html">Blockchain tanpa perantara: cara kami mengirim sekuritas ke registri terdistribusi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>