<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸš’ ğŸ‘¨â€â¤ï¸â€ğŸ’‹â€ğŸ‘¨ ğŸ”³ Bagaimana cara menyimpan sumber daya di browser dan tidak merusak web. Laporan Yandex ğŸ“” ğŸŒ§ï¸ â›„ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Terlepas dari pertumbuhan kinerja perangkat, web menjadi semakin menuntut pada memori dan prosesor. Render yang tepat dan alokasi sumber daya yang cer...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana cara menyimpan sumber daya di browser dan tidak merusak web. Laporan Yandex</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/442456/"> Terlepas dari pertumbuhan kinerja perangkat, web menjadi semakin menuntut pada memori dan prosesor.  Render yang tepat dan alokasi sumber daya yang cerdas di seluruh tab merupakan bagian penting untuk menyelesaikan masalah ini.  Konstantin Kramlih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">PurplePowder</a> mengabdikan pidatonya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konferensi</a> "I Frontend" untuk algoritma yang meningkatkan produktivitas dan menghemat sumber daya baik dalam proyek Chromium dan di Yandex.Browser. <br><br>  Beberapa di antaranya - misalnya, teknologi Hibernate - kami telah disortir dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pos terpisah</a> .  Laporan tulang mencakup masalah secara lebih luas: tidak hanya dari sudut pandang beralih tab, tetapi juga memperhitungkan metode rendering konten, ubin dan lapisan halaman. <br><br>  Menjelang akhir, pengembang antarmuka web dapat mempelajari cara mengidentifikasi dan menyelesaikan masalah kinerja situs web. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/6OLVN_gprow" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - Nama saya Kostya, saya adalah kepala grup pengembangan komponen internal di tim Yandex.Browser.  Di Browser, saya telah melakukan hal-hal yang berbeda selama kurang lebih lima tahun: dari semua decoding di browser, dari semua video HTML5, hingga rendering, rendering, dan proses serupa lainnya. <br><br><a name="habracut"></a>  Selama satu setengah hingga dua tahun terakhir, saya telah terlibat dalam proyek yang berkaitan dengan penghematan sumber daya di browser: CPU, memori, baterai. <br><br>  Anda mengatakan - Kostya, di halaman pada tahun 2019, di mana masalah dengan sumber daya?  Anda dapat membeli perangkat apa pun yang Anda inginkan dengan sumber daya apa pun.  Tetapi jika kita beralih ke statistik Mozilla terbuka, kita akan melihat bahwa setengah dari pengguna memiliki memori 4 GB atau kurang.  Dan banyak pengguna yang memiliki satu atau dua core fisik, mereka membuat proporsi yang cukup besar dari audiens Anda.  Di dunia ini kita hidup. <br><br><img src="https://habrastorage.org/webt/vr/cx/q0/vrcxq0duik8iaocs9q0v7xbkcqs.jpeg"><br><br>  Berapa banyak dari Anda yang sering melihat tab ini?  Inilah yang terjadi dalam kasus pengguna biasa yang memiliki sedikit RAM dan komputer lama. <br><br><img src="https://habrastorage.org/webt/kd/kq/db/kdkqdbilt2lzsmz5q5p5xgizgci.jpeg"><br><br>  Apa yang harus dilakukan  Masalahnya bukan rahasia bagi siapa pun, mereka mulai aktif bertarung dengannya sekitar tiga tahun lalu.  Sejak itu, kacang secara bertahap dikencangkan dengan berbagai cara.  Mari saya tunjukkan sebuah contoh yang berkeliling Stack Overflow sekitar 2016.  Berikut ini cuplikan sederhana.  Hal ini hanya memperbarui judul dan menetapkan waktu yang telah berlalu sejak peluncuran terakhir fungsi ini.  Apa yang harus diperoleh secara ideal?  Setiap 100 ms dalam judul harus ditulis + -100.  Beruntung sekali. <br><br><img src="https://habrastorage.org/webt/eh/fs/3h/ehfs3hfvws_8dd1t_fxe29qgdui.jpeg"><br><br>  Tetapi bagaimana jika kita membuka dan melakukan ini?  Adakah yang mengalami hal ini?  Pertanyaannya adalah Stack Overflow: apa yang tidak bisa dikerjakan Cookie Clicker di tab latar belakang saya?  Ini adalah salah satu inisiatif Chromium pertama yang bertujuan mengurangi penggunaan CPU di browser.  Idenya adalah jika pengguna tidak menggunakan tab sekarang, maka dia tidak membutuhkannya sekarang - mari kita beri JS padanya. <br><br>  Peramban mencoba mempertahankan beban CPU pada tab ini sekitar 1% - mulai menjeda semua jenis penghitung waktu, eksekusi JS, dll. Ini adalah salah satu langkah pertama di masa depan yang cerah. <br><br><img src="https://habrastorage.org/webt/qf/vu/_c/qfvu_cyufv3gab9rsell45yv-6g.jpeg"><br><br>  Setelah beberapa waktu di browser, Anda akan mendapatkan situasi bahwa tab latar belakang berhenti berfungsi sama sekali.  Inilah masa depan yang cerah yang saya bicarakan.  Menurut rencana Chromium, yang mereka nyuarakan di BlinkOn terakhir, pada tahun 2020 mereka berencana untuk melakukannya: biarkan tab memuat dan jika latar belakang, itu tidak akan melakukan apa-apa.  Anda selalu harus siap untuk ini. <br><br><img src="https://habrastorage.org/webt/u2/_i/gx/u2_igx67m7vxehtknn_-juntdjs.jpeg"><br><br>  Di Yandex.Browser, kami juga menangani masalah seperti itu, tetapi menyelesaikannya dengan kurang kategoris dan tidak merusak seluruh web.  Kami menciptakan mode hemat energi yang mematikan decoding pada prosesor dan hanya menyisakan decoding pada kartu video, dan juga menurunkan FPS dan menonaktifkan beberapa animasi yang tidak diperlukan saat ini dan sebagai gantinya pengguna harus menghemat baterai.  Ini memberi kami sekitar satu jam masa pakai baterai ekstra.  Siapa pun dapat memeriksa, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diperiksa</a> . <br><br><img src="https://habrastorage.org/webt/vi/jx/kb/vijxkbmraau6ziqjhlswbz_u-t4.jpeg"><br><br>  Saya pikir beberapa orang akan mengatakan: Kostya, Anda "merusak" web, membantu beberapa pengguna, tetapi tidak membuat sesuatu yang lebih pintar.  Tambahkan hardcore!  Bagaimana cara browser menggambar halaman? <br><br><img src="https://habrastorage.org/webt/u4/2j/hy/u42jhyxml4ljdmmd6iu69azgl4g.jpeg"><br><br>  Singkatnya, konsep lapisan adalah ketika browser mencoba memecah halaman menjadi lapisan dan menggambarnya secara terpisah.  Ini dilakukan agar beberapa animasi dilakukan dan tidak memaksa untuk menggambar ulang apa yang statis.  Browser melakukan ini pada heuristik yang berbeda.  Misalnya - mencoba untuk memilih elemen video ke dalam lapisan terpisah, yang, jelas, cepat dan sering digambar ulang.  Dan jika itu ditampilkan di suatu tempat, maka Anda tidak perlu menggambar kembali semuanya di bawahnya. <br><br>  Selain itu, setiap lapisan dibagi menjadi ubin seperti itu - 256 x 256 persegi panjang. Di inspektur Anda dapat melihat sesuatu seperti ini.  Ada bingkai yang dibagi menjadi banyak ubin. <br><br><img src="https://habrastorage.org/webt/li/g7/ft/lig7ftmhfrgn3r_rlppouwefs8w.jpeg"><br><br><img src="https://habrastorage.org/webt/ip/1e/ud/ip1eudzb0uatttxq7-ydfb-aqe0.jpeg"><br><br>  Apa itu dan mengapa itu dibutuhkan?  Pertama-tama, untuk memprioritaskan rendering.  Jika kita memiliki sosis besar, yang kita semua gambar, lalu mengapa kita perlu menggambar semua ini jika sekarang pengguna hanya melihat apa yang dia miliki di ViewPort? <br><br><img src="https://habrastorage.org/webt/4q/nf/5o/4qnf5oxbb4j3ta9jfxca9urof3c.jpeg"><br><br>  Menggunakan pendekatan ini, pertama-tama kita menggambar hanya apa yang dilihat pengguna saat ini di ViewPort, lalu satu ubin di sekitar, lalu ke arah gulir.  Jika pengguna gulir ke bawah - tarik ke bawah, jika ke atas.  Semua yang lain akan ditarik hanya jika kita memiliki kuota untuk ubin ini dan kita dapat menggambarnya, setelah itu pengguna akan melihatnya.  Atau mungkin tidak pernah. <br><br><img src="https://habrastorage.org/webt/vt/vd/uw/vtvduwiv5swz_ogt7vkpwr8_rjc.jpeg"><br><br>  Ini juga banyak membantu penyandang cacat.  Misalkan pengguna membuka halaman, memilih bagian, dan kami tidak perlu menggambar semuanya.  Kami dapat meninggalkan sebagian besar rendering sebelumnya.  Kami akan menggambar ulang enam ubin di sini, dan semuanya akan baik-baik saja. <br><br><img src="https://habrastorage.org/webt/5z/4p/uw/5z4puwbbmkpqcdqbip5yh1lstew.jpeg"><br><br>  Tepat pada level ini, beberapa optimasi sangat berhasil dibuat.  Misalnya, Chromium membuat pengoptimalan sekitar tahun 2017. <br><br><img src="https://habrastorage.org/webt/vc/lk/gy/vclkgyedfjzyc5wreb-q4t52pv0.jpeg"><br><br>  Jika kami hanya memiliki rendering kecil, kami hanya melakukannya.  Lalu kursor berkedip, dan kami menggambar ulang hanya area kursor, tetapi tidak seluruh area ubin ini.  Kami sangat menghemat CPU agar tidak menggambar ulang semuanya. <br><br><img src="https://habrastorage.org/webt/ax/-a/cv/ax-acv5ypcljlc7jkheipeut6ek.jpeg"><br><br>  Ini juga membantu menghemat memori.  Apa masalahnya di sini?  Seluruh persegi panjang putih.  Bayangkan itu akan menjadi tekstur 256 oleh 256, empat byte per piksel.  Meskipun tampaknya area ini dapat dikodekan hanya dengan lima angka: koordinat, lebar, tinggi dan warna. <br><br><img src="https://habrastorage.org/webt/ho/kx/kt/hokxktfgpxja01guodvgtxdhv6q.jpeg"><br><br>  Di Chromium, optimalisasi area monokrom telah dilakukan.  Jika browser memahami bahwa tidak ada render dalam persegi panjang ini, bahwa itu sepenuhnya monokrom, tidak transparan dan memenuhi beberapa persyaratan lain, maka kami hanya memberi tahu kartu video - gambar persegi panjang putih, jangan pilih seluruh tekstur. <br><br>  Apa lagi yang bisa dioptimalkan di sini?  Jika Anda melihat ubin yang tersisa - mereka memiliki sedikit konten dan area besar warna putih.  Di Yandex.Browser, kami memikirkan hal ini dan membuat mekanisme yang kami sebut ubin adaptif. <br><br><img src="https://habrastorage.org/webt/xr/vc/9j/xrvc9j8bqm5fpslcp1jbkvjzqpy.jpeg"><br><br>  Ada satu kotak kecil, ubin.  Ada sedikit konten di tengah ubin.  Kami memilihnya dan - hanya di bawahnya - tekstur.  Segala sesuatu yang lain juga dibagi menjadi beberapa area, yang kita bicarakan kartu video: hanya menggambar putih di sini ukuran ini. <br><br><img src="https://habrastorage.org/webt/jh/ow/c7/jhowc7oh1nxm6-ofebqgzznnaya.jpeg"><br><br>  Halaman ini juga mulai menyimpan semua yang disorot dengan warna merah.  Pada halaman yang lebih kompleks, tampilannya seperti ini. <br><br><img src="https://habrastorage.org/webt/of/pu/lz/ofpulzw2yanibpfx7vrweogcsr8.jpeg"><br><br>  Penting untuk dipahami bahwa masih ada banyak lapisan dan setiap lapisan digambar seperti ini.  Di setiap lapisan, Anda dapat menghemat sejumlah memori.  Pendekatan ini memungkinkan kami untuk menghemat sekitar 40% dari memori video rata-rata untuk semua pengguna. <br><br>  Lebih hardcore!  Mereka menyimpan sedikit memori di sini, mereka â€œmenghancurkanâ€ web - mengapa tidak â€œmenghancurkanâ€ web lebih lanjut? <br><br>  Di Chromium ada sesuatu seperti kebijakan: jika pengguna tidak menggunakan tab latar belakang, jika ia meninggalkannya, maka ia tidak membutuhkannya.  Jika kita sekarang tidak memiliki memori dan browser sekarang sedang berbaring, maka mari kita ambil tab tertua yang sudah lama tidak digunakan pengguna dan bunuh.  Dia akan tetap berada di antarmuka, tetapi prosesnya tidak lagi ada, semua JS akan mati.  Apakah boleh atau tidak?  Sungguh aneh mengajukan pertanyaan semacam itu di pesta front-end dan mengharapkan jawaban selain "Apa yang kamu lakukan?" <br><br><img src="https://habrastorage.org/webt/ui/5j/nq/ui5jnqtbegu672hy2tzbfiglhrk.jpeg"><br><br>  Maka itu tidak banyak.  Berikut adalah komentar nyata dari blog Chromium: Anda merusak semua aplikasi saya untuk saya, ada semacam permainan - dan lompat, tidak memiliki status apa-apa.  Penting untuk dipahami bahwa tidak ada handler yang tidak bekerja, seolah-olah kita hanya mengeluarkan tab ini.  Pengguna kemudian kembali ke sana, dan kami memuatnya kembali dari jaringan, seolah-olah tidak ada yang terjadi. <br><br>  Kemudian pendekatan ini ditinggalkan sementara dan muncul dengan ide serius yang lebih serius.  Mereka memanggilnya membuang. <br><br><img src="https://habrastorage.org/webt/x2/7w/zq/x27wzq5kw55gtlcsduajusa3yoi.jpeg"><br><br>  Apa gunanya  Ini adalah pembunuhan tab yang sama, hanya dikendalikan.  Itu disebut kata pintar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Page Lifecycle API</a> .  Jika Anda memiliki tab, dan pengguna belum melihatnya untuk waktu yang lama, itu dapat masuk ke status beku.  Browser mengatakan melalui acara: Saya akan membekukanmu sekarang.  Setelah memproses acara, tidak ada yang dilakukan sama sekali.  Lakukan apa yang Anda butuhkan, bersiap-siaplah. <br><br>  Kemudian dapat keluar dari keadaan beku melalui acara resume, seharusnya tidak terjadi apa-apa.  Atau, jika peramban benar-benar perlu mengosongkan memori sekarang, itu hanya membutuhkan dan membunuhnya.  Tetapi jika pengguna kembali ke tab ini, kami akan memuatnya kembali dan mengatur bidang yang dibuang untuk dokumen. <br><br><img src="https://habrastorage.org/webt/8c/-i/wu/8c-iwuqbmjxvsrdksgcjwvenew4.jpeg"><br><br>  Saat ini Anda sudah dapat berlangganan ke acara ini dan menangkapnya, entah bagaimana prosesnya.  Jika tab benar-benar mati, Anda dapat memeriksa bidang yang dibuang.  Ini berarti Anda telah dipulihkan setelah dibuang.  Anda dapat memulihkan keadaan sebelumnya. <br><br><img src="https://habrastorage.org/webt/as/ny/b1/asnyb16w13ubi3k1dfi_04nicik.jpeg"><br><br>  Kami di Yandex.Browser berpikir beberapa tahun yang lalu: mengapa tidak menggunakan pendekatan kardinal yang kompleks.  Mereka memanggilnya Hibernate. <br><br><img src="https://habrastorage.org/webt/ce/7-/gn/ce7-gngt24kb9ikzc4nzdxbjspu.jpeg"><br><br>  Apa gunanya  Ada beberapa tab, beberapa jenis JS berjalan, semacam negara.  Proses terpisah dibuat untuk setiap tab: di sini video dapat diputar, di sini Anda meninggalkan sesuatu dalam formulir.  Hibernate tiba - dan tidak ada proses.  Kita semua mendapatkannya.  Tetapi jika sekarang kita beralih kembali ke tab ini, proses akan kembali dan seluruh negara akan berada di tempatnya, video akan terus diputar dari saat yang tepat, semua teks di bidang akan tetap di tempatnya. <br><br><img src="https://habrastorage.org/webt/oy/ks/ug/oyksug04glkeh-amu4dyqfrryyc.jpeg"><br><br>  Apa yang telah kita lakukan  Tiga hal paling penting hidup di dalam masing-masing renderer: V8, yang menjalankan seluruh JS, Blink, yang menyimpan seluruh DOM, dan beberapa jenis penjilidan browser, yang membantu menghubungkan semuanya bersama-sama, dengan tab dan yang lainnya. <br><br><img src="https://habrastorage.org/webt/pz/hj/h4/pzhjh4pmyn-yz5afmas6omozx6g.jpeg"><br><br>  Misalnya, pertimbangkan sampel.  Di sini kita menunggu onload terjadi, dan menambahkan elemen div baru ke pohon DOM.  Untuk browser, tampilannya seperti ini. <br><br><img src="https://habrastorage.org/webt/ic/cu/vy/iccuvyjbkmkyjhbgfb5de8uqxpc.jpeg"><br><br>  Tentu saja, ada pohon DOM, ia memiliki beberapa bidang, objek terkait, dan ada entitas seperti itu. <br><br><img src="https://habrastorage.org/webt/ng/tj/ki/ngtjkiwdv6raldvffqgnoils7ge.jpeg"><br><br>  Dalam V8, keadaan setiap node disimpan, dan node ini dikaitkan dengan objek blink melalui lapisan pengikat.  Apa yang telah kita lakukan  Kami mengambil serializer dari V8, membuat serial seluruh negara V8, menemukan semua objek terkait di Blink, menulis plus serialisator yang menyimpan seluruh pohon DOM, membuat serial, lalu menulis ke disk, dikompresi, dan dienkripsi.  Dan kami mengajarkan browser untuk memulihkan dari snapshot seperti itu kembali.  Artinya, ketika pengguna pergi ke tab seperti itu, kami memperluasnya, mendekripsi dan menunjukkannya kepada pengguna, mengembalikannya sepenuhnya.  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Posting terpisah tentang Hibernate</a> - perkiraan.) <br><br>  Saat ini, Hibernate diterbitkan untuk semua orang di stabil dan memungkinkan setiap pengguna untuk menyimpan rata-rata satu atau dua tab.  Artinya, ia memiliki rata-rata satu tab yang selalu disimpan, atau mungkin dua.  Ini menghemat memori untuk pengguna yang memiliki lebih dari 10 tab - seperti yang kami lakukan dengan Anda, tetapi kami tidak representatif. <br><br>  Saya memberi tahu bagaimana browser berusaha membantu, tetapi sekarang Anda masing-masing dapat melakukan sesuatu untuk mempercepat situs, meningkatkan kinerjanya.  Anda bisa datang dan lakukan hari ini juga. <br><br>  Pertama, Anda perlu memahami jika ada masalah memori. <br><br><img src="https://habrastorage.org/webt/xu/l4/nv/xul4nvtip2nc_mr93zrevltkmye.jpeg"><br><br>  Ada gejala-gejala tertentu: situs mulai menurun, atau memudar muncul.  Biasanya ini berarti bahwa pemulung dipicu, seluruh dunia beku dan tidak ada yang ditarik.  Atau situs itu hanya terus-menerus melambat - hal itu juga terjadi. <br><br>  Anda perlu memahami jika ada masalah.  Kami melihat apa yang terjadi dengan memori JS. <br><br><img src="https://habrastorage.org/webt/ui/g4/kz/uig4kzofjrymuq0egjmk-cdt36o.jpeg"><br><br>  Jika ia melompat bolak-balik atau tumbuh terus menerus, ini bukan gejala yang baik.  Atau tumbuh terus menerus. <br><br><img src="https://habrastorage.org/webt/dt/to/ek/dttoekpmiceh7_6693-n6vrtsjk.jpeg"><br><br>  Dalam hal ini, Anda selalu dapat mengambil snapshot melalui DevTools.  Adakah yang peduli dengan kebocoran di JS?  Jika seseorang tidak tahu, di JS sangat mungkin untuk membuat kebocoran. <br><br><img src="https://habrastorage.org/webt/da/n_/yh/dan_yhjbdvvilgwgovgzzf6tpgu.jpeg"><br><br>  Misalnya, Anda memiliki variabel global tempat Anda menambahkan node yang tidak dimasukkan ke dalam pohon.  Anda lupa tentang mereka, dan ternyata mereka memakan ratusan kilobyte, atau bahkan megabyte. <br><br><img src="https://habrastorage.org/webt/vq/au/ia/vqauia5ylxx_u0xu8arw5ycuvta.jpeg"><br><br>  Sebenarnya, tidak jelas apa yang harus dilakukan dengan node yang terpisah tersebut.  Anda dapat menariknya keluar dari pohon, dan kemudian memasukkannya kembali.  Karena biasanya keadaan gambar atau sesuatu yang lain tetap bersama mereka.  Dengan demikian, Anda dapat menemukannya dan mengatasi masalahnya. <br><br><img src="https://habrastorage.org/webt/w7/a6/cy/w7a6cyfk_5iroc0ybpdk21gym5k.jpeg"><br><br>  Anda juga dapat melihat alokasi memori pada timeline.  Jika Anda memiliki pembuangan sistematis dan tidak pernah membersihkan, ini juga pertanda buruk, saya pikir semua orang mengerti ini. <br><br><img src="https://habrastorage.org/webt/0m/ol/4w/0mol4w_xotmiebkvvheldcrnokq.jpeg"><br><br>  Dan Anda bisa bermain dengan layer pada tab Anda.  Browser umumnya bekerja dengan heuristik dalam hal ini - ia mencoba untuk memisahkan objek yang dianggapnya sering berubah menjadi lapisan yang terpisah.  Tetapi kadang-kadang itu tidak bekerja dengan baik, dan ternyata Anda memiliki banyak lapisan yang menghabiskan banyak memori.  Anda selalu dapat melihat apakah Anda memiliki situasi seperti itu, menghilangkan beberapa lapisan dan mencari tahu berapa banyak memori yang ditempati lapisan ini. <br><br><img src="https://habrastorage.org/webt/rc/w6/il/rcw6ilo68vshxkgqzq82esab_1y.jpeg"><br><br>  Lapisan masalah lainnya adalah kinerja.  setTimeout adalah ide buruk untuk animasi.  Ini tidak berfungsi seperti yang diinginkan browser untuk merender halaman.  Ini mungkin tidak berfungsi dalam fase: browser meminta bingkai, tetapi belum ada animasi, karena setTimeout tidak berfungsi.  Atau itu dapat bekerja bahkan ketika Anda tidak perlu menggambar apa pun.  Pengguna telah pergi, masih ada beberapa pekerjaan latar belakang yang tersisa, tetapi kami akan bekerja dengannya melalui setTimeout. <br><br>  Ini adalah pendekatan yang benar yang akan dipanggil kembali hanya oleh Anda ketika browser perlu menggambar halaman ini. <br><br><img src="https://habrastorage.org/webt/st/nr/dv/stnrdvev7a9sricvyvwivcufg4k.jpeg"><br><br>  Saya juga ingin mengingatkan Anda bahwa jika browser ingin menggambar 60 frame per detik, itu berarti bahwa untuk setiap frame dibutuhkan sekitar 16 ms. <br><br><img src="https://habrastorage.org/webt/zo/fy/es/zofyesewo-ck8wl-z_jlsb6u7ak.jpeg"><br><br>  Dan jika Anda menempati arus utama lebih dari 16 ms, maka Anda memiliki bingkai lompatan dijamin, yang agak tidak menyenangkan bagi pengguna: situs mulai menyentak.  Oleh karena itu, semua kerja keras dengan benar dimasukkan ke utas latar belakang, yang Anda hanya mengembalikan hasilnya. <br><br><img src="https://habrastorage.org/webt/mp/rk/ry/mprkryexbai19rd-vhbj_tlbeb4.jpeg"><br><br>  Atau pendekatan lain adalah menggunakan microtasking.  Buat antrian tugas, proses setelah beberapa waktu, sampai kuota selesai, dan biarkan browser menggambar halaman dengan tenang. <br><br><img src="https://habrastorage.org/webt/-0/jr/bn/-0jrbntves41mkelcd56bmgu6uc.jpeg"><br><br>  Secara alami, Anda dapat menambahkan lapisan baru.  Browser bekerja pada heuristik dan mencoba untuk memilih layer yang dianggap perlu.  Tetapi jika Anda tahu bahwa saat ini elemen ini akan dianimasikan, lebih baik memberi tahu browser secara eksplisit bahwa Anda perlu memilih elemen ini di lapisan yang terpisah.  Maka itu akan ditarik lebih efisien. <br><br><img src="https://habrastorage.org/webt/t9/pf/mr/t9pfmrqa0mhyszxphlkmvxafsag.jpeg"><br><br>  Pendekatan menarik terbaru - mengeluh.  Jika Anda memiliki masalah, selalu bermanfaat untuk datang dan berbicara.  Mungkin masalah ini dapat dengan mudah ditangani, dan kami akan saling membantu. <br><br>  Sedikit latar belakang.  Fitur ini sedang dikerjakan.  Kami memiliki tim halaman pengembangan mesin pencari.  Mereka memiliki metrik seperti saat memberikan cuplikan pertama.  Jika pengguna sebelumnya melihat tautan pertama yang perlu Anda klik, dan yang kemungkinan besar memberinya jawaban yang benar, maka jauh lebih baik untuk menggambarnya secepat mungkin.  Mereka datang dan bertanya apakah mungkin untuk mempercepat kali ini, karena mereka semua terjepit. <br><br>  Kami menginvestigasi, melakukan uji coba, membuat prototipe, dan ternyata kami bisa melakukan ini jika situs memberi tahu kami apa yang harus digambar terlebih dahulu.  Kami menguji dan melihat bahwa itu meningkatkan kinerja kami.  Sekarang kami sedang menguji ini dalam produksi untuk audiens kecil.  Kami melihat apa yang akan terjadi.  Tetap disini. <br><br>  Dunia tidak tinggal diam.  Pengguna mulai menginginkan lebih dan lebih banyak lagi, browser berubah, web berubah.  Ini normal.  Kami mencoba tidak hanya membuat fitur makanan, tetapi juga untuk membantu pengguna dengan segala cara yang mungkin untuk mendapatkan pengalaman terbaik dalam hal konsumsi konten.  Dan Anda selalu harus siap untuk perubahan di browser populer apa pun.  Wajar jika ada masalah - ayo, kami siap berdiskusi dan saling membantu. <br><br>  Di sini saya mengumpulkan berbagai tautan bermanfaat: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hibernasi di Yandex Browser</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tab yang dibuang di chrome</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API Siklus Hidup Halaman</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengukur Kinerja dengan Model RAIL</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penghematan Energi di Yandex.Browser</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Statistik perangkat keras uap</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Laporan Data Publik Firefox</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id442456/">https://habr.com/ru/post/id442456/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id442446/index.html">Transformasi digital pada contoh Call center bisnis apa pun</a></li>
<li><a href="../id442448/index.html">Pola konkurensi dan kesalahan disembunyikan dalam kode: Deadlock</a></li>
<li><a href="../id442450/index.html">Blockchain dan data medis: cara kerjanya</a></li>
<li><a href="../id442452/index.html">Cara masuk NodeJS agar anak laki-laki di halaman menghormati</a></li>
<li><a href="../id442454/index.html">Magic Leap berencana untuk melengkapi dunia nyata dengan lapisan digital</a></li>
<li><a href="../id442458/index.html">Jurang atau jalur buatan manusia dari pilot RPA ke implementasi di seluruh perusahaan</a></li>
<li><a href="../id442460/index.html">Membantu Penyedia Queryable memilah string interpolasi</a></li>
<li><a href="../id442462/index.html">Kesalahan umum ketika bekerja dengan PostgreSQL. Bagian 1</a></li>
<li><a href="../id442464/index.html">Bagaimana "Naga" berawak itu tumbuh</a></li>
<li><a href="../id442466/index.html">Bagaimana cara mempromosikan game tambahan? Gratis, cepat dan efisien *</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>