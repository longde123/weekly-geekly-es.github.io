<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóÉÔ∏è üë©üèø‚Äç‚öñÔ∏è üë©üèæ‚Äçüîß Plasma Cash Chain como soluci√≥n al trilema de escalabilidad de blockchain üë©üèø‚Äçüåæ üîá üÜî</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Buenas tardes, queridos lectores! 

 Este art√≠culo trata sobre la cadena de efectivo de plasma y arroja luz sobre los siguientes temas: 



- el trile...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Plasma Cash Chain como soluci√≥n al trilema de escalabilidad de blockchain</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457518/">  Buenas tardes, queridos lectores! <br><br>  Este art√≠culo trata sobre la cadena de efectivo de plasma y arroja luz sobre los siguientes temas: <br><br><ul><li>  el trilema de escalabilidad y los m√©todos para su soluci√≥n; </li><li>  estructuras de datos de la cadena secundaria y su visualizaci√≥n en la cadena ra√≠z; </li><li>  implementaci√≥n de entrada a la cadena ra√≠z; </li><li>  implementaci√≥n de la retirada de la cadena ra√≠z. </li></ul><br>  Opporty utiliz√≥ el lenguaje de programaci√≥n Javascript para implementar la cadena secundaria, as√≠ como Solidity para la cadena ra√≠z.  Se proporcionan ejemplos de c√≥digo en estos idiomas. <br><br><img src="https://habrastorage.org/webt/qd/nd/dv/qdnddvdk76wf5sy2ajwn38jp9w0.jpeg"><br><a name="habracut"></a><br>  Blockchain y la descentralizaci√≥n permiten optimizar y mejorar el trabajo de casi cualquier esfera de la vida donde se utilizan Internet y las tecnolog√≠as de la informaci√≥n.  Aumentan la fiabilidad, la eficiencia financiera y tambi√©n facilitan la digitalizaci√≥n de bienes y bienes reales. <br><br>  Los contratos inteligentes llevan la l√≥gica empresarial a las redes descentralizadas.  Esto le permite crear nuevas aplicaciones DAPP. <br><br>  La ejecuci√≥n de contratos inteligentes y la operaci√≥n r√°pida de aplicaciones con una base de datos distribuida solo puede ser posible si se cumple la condici√≥n de escalabilidad. <br><br>  Las cadenas de bloques modernas descentralizadas tienen varios inconvenientes.  El principal es la escalabilidad.  Ethereum procesa alrededor de 20 tx / s.  Esto no es suficiente en las realidades financieras modernas.  Al mismo tiempo, Ethereum tiene el mayor grado posible de protecci√≥n contra pirater√≠a y fallas en la red.  Otras criptomonedas y sistemas construidos en blockchain no tienen un grado tan alto de descentralizaci√≥n, lo que reduce la confianza en la red. <br><br><h2>  El trilema de escalabilidad </h2><br>  Existe un trilema de escalabilidad de blockchain que incluye tres componentes: <br><br><ul><li>  descentralizaci√≥n; </li><li>  seguridad </li><li>  escalabilidad </li></ul><br><h3>  Descentralizaci√≥n en el trilema </h3><br>  La descentralizaci√≥n, como su t√©rmino lo indica, refleja el grado de diversificaci√≥n de la propiedad de la actividad en la cadena de bloques, as√≠ como el grado de diversificaci√≥n de crear bloques y generar nuevas entradas en el libro mayor. <br><br>  Para mayor claridad, es necesario hablar sobre las organizaciones m√°s centralizadas.  Por lo general, se usa una base de datos simple en lugar de blockchain.  Dicha organizaci√≥n est√° dirigida por administradores especiales.  Todas las transacciones pueden cancelarse mediante intervenci√≥n manual. <br><br>  En redes totalmente descentralizadas, cada usuario puede participar en la construcci√≥n de una red. <br><br>  La consecuencia m√°s importante de la descentralizaci√≥n es que la mayor parte del valor va a la comunidad que participa en la creaci√≥n de la cadena de bloques.  No existe un equipo intermedio de gerentes que reciba todos los beneficios en lugar de aquellos que generan la estructura de la red en s√≠.  De hecho, la mayor√≠a de los proyectos criptogr√°ficos son propiedad exclusiva de sus contribuyentes o usuarios, no de los fundadores.  Obviamente, este es un modelo m√°s atractivo para quienes no son fundadores. <br><br><h3>  Seguridad en el trilema </h3><br>  Se trata de la capacidad de blockchain para resistir ataques de fuentes externas y mantener el sistema en un estado sin cambios.  La mayor√≠a de las cadenas de bloques est√°n sujetas a muchas amenazas potenciales de seguridad.  Es imprescindible conocer los vectores de ataque y las opciones de defensa m√°s comunes. <br><br>  En este caso, la descentralizaci√≥n y la seguridad van de la mano.  Cuantos m√°s nodos, menos depende la red del lado centralizado y, por lo tanto, del riesgo de tener un punto central de falla.  Sin embargo, hay muchos otros vectores de ataque que representan una amenaza para las redes descentralizadas, que incluyen: <br>  &gt; <b>50% de ataque</b> : un objeto que posee m√°s del 50% del n√∫mero total de tokens no pagados en realidad posee la red; <br>  &gt; <b>Sybil Attack</b> : el usuario puede generar muchos identificadores en el sistema para controlar efectivamente una parte importante de la propiedad y / o la toma de decisiones en la red; <br>  &gt; <b>DDoS</b> : se produce un ataque de denegaci√≥n de servicio distribuido (DDoS) cuando existe la intenci√≥n de interrumpir el tr√°fico en la red, llenando la red con transacciones maliciosas; <br>  &gt; <b>Ataque de colusi√≥n</b> : uno o m√°s objetos (o nodos) deciden unirse para realizar cualquier operaci√≥n maliciosa en la red. <br><br><h3>  Escalabilidad en el trilema </h3><br>  El grado de escalabilidad es importante porque determina el rendimiento final, en otras palabras, el l√≠mite superior del tama√±o de la red.  La pregunta m√°s importante que debe hacerse al evaluar una red es: "¬øCu√°ntos usuarios puede soportar este sistema?"  Bitcoin actualmente tiene entre 2,9 y 5,8 millones de titulares de billetera.  EOS tiene varios miles de miembros. <br><br>  La escalabilidad y la descentralizaci√≥n pueden coexistir, pero la seguridad se reduce.  Los desarrolladores eligen las plataformas que mejor se adaptan a sus necesidades.  Los usuarios hacen lo mismo.  Las opiniones de las dos partes a veces difieren.  Algunos usuarios est√°n dispuestos a sacrificar la seguridad por la escalabilidad, otros est√°n dispuestos a sacrificar la escalabilidad por la seguridad, pero el equilibrio es mucho m√°s dif√≠cil. <br><br><h2>  "Santo Grial" en la tecnolog√≠a blockchain </h2><br>  Por definici√≥n, una cadena de bloques tiene solo dos de las siguientes tres propiedades: <br><br><ul><li>  <b>Descentralizaci√≥n</b> (cada participante tiene acceso solo a recursos O ¬©, es decir, a una computadora port√°til normal o un VPS peque√±o); </li><li>  <b>Escalabilidad</b> (capacidad de procesar transacciones O (n)&gt; O ¬©); </li><li>  <b>Seguridad</b> (protecci√≥n contra intrusos que utilizan recursos O (n)). </li></ul><br><img src="https://habrastorage.org/webt/ek/zg/zr/ekzgzredr00odj5mwae4f549hzs.png"><br>  Verde: un estado equilibrado de tres condiciones. <br>  Rojo: seguridad fuerte pero descentralizaci√≥n y escalabilidad limitadas. <br>  Azul: la eficiencia es alta, pero la seguridad y la descentralizaci√≥n son limitadas. <br>  Negro: la descentralizaci√≥n es alta, pero no hay aspectos de escalabilidad y seguridad. <br>  Gris: descentralizaci√≥n total, con cualidades m√≠nimas o faltantes de seguridad y escalabilidad. <br>  Violeta: un equilibrio igual entre seguridad y escalabilidad, el rechazo de la descentralizaci√≥n. <br><br>  El "santo grial" en la tecnolog√≠a blockchain significa combinar los tres aspectos. <br>  En la mayor√≠a de los proyectos actuales que trabajan con criptomonedas, se logran dos propiedades b√°sicas: descentralizaci√≥n y seguridad.  La escalabilidad sufre. <br><br><h2>  Soluciones prometedoras al trilema </h2><br><h3>  Prueba de estaca (PoS) </h3><br>  Proof of Stake (PoS) proporciona mejoras potenciales de escalabilidad.  POS reemplaza la miner√≠a de criptomonedas basada en el sistema de Prueba de trabajo (PoW).  La elecci√≥n del validador es muy r√°pida, de manera determinista.  Al mismo tiempo, no hay costo de energ√≠a y es ecol√≥gico. <br><br><h3>  Cadenas laterales </h3><br>  En la red virtual Ethereum, existe la posibilidad de crear una red secundaria en la que el proyecto pueda procesar sus transacciones individuales y luego registrar solo los resultados iniciales y finales en la red Ethereum.  Esto reduce la carga en el EVM, pero da m√°s confianza en la gesti√≥n de la cadena lateral.  Por lo tanto, la confianza en un tercero reduce la descentralizaci√≥n. <br><br><h3>  Sharding </h3><br>  El fragmentaci√≥n divide las transacciones en piezas de datos m√°s peque√±as.  En lugar de que cada nodo individual en la red procese transacciones completas, los nodos se dividen en grupos, y estos grupos de nodos procesan ciertos datos.  M√°s tarde, durante el procesamiento, estos datos se vuelven a asimilar para el almacenamiento permanente en la cadena de bloques. <br><br><h3>  Aumentar el tama√±o del bloque </h3><br>  Litecoin y Bitcoin Cash (BCH) son "tenedores" para la cadena de bloques de Bitcoin.  Bifurcaci√≥n b√°sicamente copia una cadena de bloques.  Despu√©s de ramificarse, puede hacer cambios.  Tanto LTC como BCH aumentaron el tama√±o de cada bloque, lo que permiti√≥ almacenar m√°s transacciones por bloque, aumentando as√≠ la velocidad de procesamiento de las transacciones. <br><br><h3>  Red de rayos </h3><br>  La primera soluci√≥n de cadena lateral fue un rayo.  La idea principal de Lightning Network es que no todas las transacciones deben registrarse en la cadena de bloques, ya que esto sobrecarga la red.  Si los usuarios transfieren fondos entre s√≠ varias veces, entonces registrar cada transferencia es opcional.  Basta con abrir una especie de canal de pago y anotar los datos sobre su apertura en la cadena de bloques.  Este canal permanecer√° abierto seg√∫n sea necesario.  Cuando sea necesario cerrarlo, el resultado de todas las transacciones realizadas en este canal simplemente se escribe en la cadena de bloques.  Siguiendo esta idea, puede crear una red completa de canales para pagos.  Luego, las transacciones en blockchain se usar√°n con mucha menos frecuencia. <br><br>  Un canal de pago es solo una combinaci√≥n de varias transacciones.  Un canal puede ser cerrado por cualquiera de sus miembros.  Esta acci√≥n ser√° como abrir una caja fuerte, que le permite tomar los fondos que pertenecen a los participantes y anotar los datos de su transferencia a la cadena de bloques. <br>  Esta tecnolog√≠a se vuelve realmente poderosa cuando varios de estos canales se combinan en una red llamada The Lightning Network.  Esta red est√° especialmente construida para Bitcoin. <br><br><h3>  Red Raiden </h3><br>  Para Ethereum, la contraparte m√°s conocida de Lightning es la Red Raiden. <br>  Esta es una soluci√≥n para escalar fuera de la cadena de bloques principal.  Es compatible con la transferencia de tokens ERC-20 en canales de pago bidireccionales. <br><br>  Su arquitectura b√°sica es compleja, pero la interacci√≥n con Raiden requiere que los desarrolladores solo interact√∫en con la API para crear aplicaciones escalables en Raiden. <br><br>  Raiden est√° dise√±ado para proporcionar pagos instant√°neos y bajas comisiones, aumentar la confidencialidad de las transacciones y los micropagos.  La mayor√≠a de los canales de pago existen fuera de la red y solo ocasionalmente forman transacciones dentro de la cadena ra√≠z, lo que reduce significativamente el rendimiento de la cadena secundaria. <br><br><h2>  Soluci√≥n √≥ptima </h2><br>  Los ide√≥logos del rayo han creado un nuevo concepto de cadena infantil que resuelve los problemas de velocidad de la cadena de bloques. <br><br>  Opporty pr√°cticamente implementa el concepto de Plasma y Plasma Cash. <br><br>  Plasma es un conjunto de contratos inteligentes que se ejecutan en la parte superior de la cadena ra√≠z de Ethereum y consisten en una red de cadenas secundarias conectadas a la cadena ra√≠z en una estructura de √°rbol jer√°rquica. <br><br>  Es decir, la seguridad de la cadena ra√≠z de Ethereum se utiliza para optimizar la escalabilidad. <br><br><h2>  Plasma Cash: Opci√≥n Opporty </h2><br>  <b>Opporty utiliza la implementaci√≥n de Plasma Cash en la primera versi√≥n.</b> <br><br>  Este modelo es la implementaci√≥n de plasma m√°s efectiva en t√©rminos de escalabilidad. <br>  Plasma Cash es un sistema basado en el uso de identificadores √∫nicos para cada token en la cadena de Plasma.  Es decir, se aplica NFT y los tokens en la red reciben n√∫meros de serie √∫nicos. <br><br>  Caracter√≠sticas del efectivo de plasma: <br><br><ul><li>  Validaci√≥n fragmentada en el lado del cliente: los clientes solo necesitan monitorear su cadena de Plasma para obtener sus tokens.  Esto significa que el rendimiento de la transacci√≥n puede aumentar sin aumentar la carga de los usuarios individuales. </li><li>  Simplificaci√≥n de la salida masiva: las salidas masivas se convierten en una amenaza menor para la red, ya que el ladr√≥n debe enviar una transacci√≥n de salida por cada ficha que quiera robar. </li><li>  No hay confirmaciones bidireccionales: las transacciones ya no requieren env√≠o y confirmaci√≥n en dos pasos.  En cambio, una transacci√≥n se puede gastar tan pronto como se incluya en la cadena principal. </li></ul><br>  Desventaja <br><br>  Grandes denominaciones de tokens: dado que a cada token se le debe asignar un n√∫mero de serie, es imposible producir tokens arbitrariamente peque√±os.  Esto se debe al hecho de que en alg√∫n momento el valor de la compra del token ser√° mayor que el valor del token en s√≠. <br><br><h3>  Estructura de la transacci√≥n en Opporty Plasma Cash </h3><br>  Opporty us√≥ Javascript para implementar childchain.  Cada transacci√≥n en Opporty Plasma Cash es una estructura similar: <br><br><pre><code class="plaintext hljs">const transactionFields = [ {name: 'prevHash'}, {name: 'prevBlock', int: true, default: 0}, {name: 'tokenId', isDecimal: true}, {name: 'newOwner'}, {name: 'type'}, {name: 'signature'}, ]</code> </pre> <br>  Los elementos principales aqu√≠ son un enlace al bloque anterior prevBlock (se necesita para moverse por la cadena de bloques), el identificador de tokenId token (debe ser √∫nico) y tambi√©n newOwner, el √∫ltimo propietario del token. <br><br>  Adem√°s, para ensamblar el bloque y obtener el hash de la cadena de ra√≠z, se usa un tipo especial de √°rbol Patricia Merkle Trie.  El mismo √°rbol se usa en Ethereum.  Tiene un aspecto comprimido.  Al mismo tiempo, a√∫n puede recibir pruebas de inclusi√≥n o no inclusi√≥n de una transacci√≥n en un bloque. <br>  Firma es una firma en curvas el√≠pticas. <br><br>  Una transacci√≥n que gasta un token con un tokenId dado es v√°lida solo si est√° incluida en el √°rbol Merkle en la posici√≥n tokenId, es decir, para cada token en el √°rbol Merkle solo hay un "lugar" que gasta este token donde se permiten transacciones.  Este formato permite a los usuarios verificar el historial completo de la cadena Plasma, as√≠ como probar y refutar la propiedad de tokens espec√≠ficos. <br><br>  Para gastar un token, debe validar la cadena, verificar si faltan bloques y solo luego volver a firmar la transacci√≥n junto con todo el historial. <br><br>  El bloque es el siguiente: <br><br><pre> <code class="plaintext hljs">const blockFields = [ {name: 'prevHash'}, {name: 'blockNum', isDecimal: true}, {name: 'transactions'}, {name: 'merkleRoot'}, {name: 'time'} ]</code> </pre> <br>  En un nivel b√°sico, una cadena de bloques es simplemente una cadena de bloques con un enlace al bloque anterior.  Dicha estructura permite obtener la propiedad de inmutabilidad, es decir, no reescribir el historial.  merkleRoot hace posible escribir puntos de control en la cadena ra√≠z. <br><br>  En la cadena ra√≠z, en el nivel de contrato inteligente, se ve as√≠ (lenguaje de solidez): <br><br><pre> <code class="plaintext hljs">/* * Block structure (represents one block in a chain) */ struct Block { uint block_num; bytes32 merkle_root; uint time; /* * Transaction structure (decoded from RLP form) */ struct Transaction { bytes32 prevhash; uint prev_block; uint token_id; address new_owner; }</code> </pre><br>  La codificaci√≥n se realiza utilizando las funciones de codificaci√≥n / decodificaci√≥n - serializaci√≥n / deserializaci√≥n RLP. <br><br><h3>  Formas de ingresar al efectivo de plasma </h3><br>  Cualquiera puede depositar fondos en Plasma Cash simplemente transfiriendo √©ter a un contrato inteligente.  Como resultado, se recibir√° un token OPP en una posici√≥n espec√≠fica de tokenId. <br><br>  Aqu√≠ est√° la implementaci√≥n en Solidity: <br><br><pre> <code class="plaintext hljs">function deposit() public payable { uint token_id = uint(keccak256(msg.sender, msg.value, deposit_blk)); // token.index = deposit_blk; tokens[token_id] = msg.value; deposit_blk += 1; emit DepositAdded(msg.sender, msg.value, token_id, current_blk); }</code> </pre> <br>  Es decir, tokenId se genera como un n√∫mero aleatorio (hash).  A continuaci√≥n, se genera un evento que se escanea en la cadena secundaria. <br><br><h3>  Formas de retirarse a Plasma Cash </h3><br>  Cada persona puede retirar su token proporcionando las dos √∫ltimas transacciones en el historial de propiedad del token. <br><br>  Implementaci√≥n de salida de la cadena ra√≠z: <br><br><pre> <code class="plaintext hljs">function startExit(uint block_num, bytes tx1, bytes tx0, bytes proof1, bytes proof0) public returns (uint exit_id) { require(checkPatriciaProof(keccak256(tx1), childChain[block_num].merkle_root, proof1)); bytes32 prev_hash; uint prev_blk; uint token_id; address new_owner; (prev_hash, prev_blk, token_id, new_owner,) = getTransactionFromRLP(tx1); require(msg.sender == new_owner); require(tokens[token_id] &gt; 0); bytes32 hashPrevTx = keccak256(tx0); require(checkPatriciaProof(hashPrevTx, childChain[prev_blk].merkle_root, proof0)); require(prev_hash == hashPrevTx); Exit storage record = exitRecords[token_id]; require(record.block_num == 0); record.block_num = block_num; record.new_owner = msg.sender; record.prev_block = prev_blk; if (childChain[block_num].time &gt; block.timestamp - week) record.priority = childChain[block_num].time; else record.priority = block.timestamp - week; exits.add(record.priority); exit_ids[record.priority].push(token_id); emit ExitAdded(msg.sender, record.priority, token_id); return token_id; }</code> </pre><br>  Primero, se verifican dos transacciones.  Si el usuario actual es el propietario de la transacci√≥n, simplemente agregamos su salida a la estructura y dejamos dos semanas para la oportunidad de desafiar la salida. <br><br>  La conclusi√≥n puede ser cuestionada de tres maneras: <br><br><ul><li>  Proporcionar confirmaci√≥n de gasto en transacciones: </li></ul><br><pre> <code class="plaintext hljs">function challengeSpent(uint exit_id, uint blk_num, bytes tx1, bytes proof) public { require(checkPatriciaProof(keccak256(tx1), childChain[blk_num].merkle_root, proof)); Exit memory record = exitRecords[exit_id]; require(record.block_num &gt; 0); uint prev_block; uint token_id; (, prev_block , token_id, ) = getTransactionFromRLP(tx1); require(tokens[token_id] &gt; 0); require(prev_block == record.block_num &amp;&amp; record.block_num &lt; blk_num); require(token_id == exit_id); exit_ids[record.priority].remove(exit_id); delete exitRecords[exit_id]; emit ExitChallengedEvent(exit_id); }</code> </pre><br>  Si hay una transacci√≥n que ya est√° gastando el token que se muestra, ¬°tal retiro se cancelar√°! <br><br><ul><li>  Prueba de gastos de la transacci√≥n anterior: </li></ul><br><pre> <code class="plaintext hljs">/* * Challenge exit by providing * a proof of a transaction spending P(C) that appears before C */ function challengeDoubleSpend(uint exit_id, uint blk_num, bytes tx1, bytes proof) public { require(checkPatriciaProof(keccak256(tx1), childChain[blk_num].merkle_root, proof)); Exit memory record = exitRecords[exit_id]; require(record.block_num &gt; 0); // bytes32 prev_hash; uint prev_block; uint token_id; (, prev_block , token_id, ) = getTransactionFromRLP(tx1); require(tokens[token_id] &gt; 0); // check if token double spent require(prev_block == record.prev_block &amp;&amp; blk_num &lt; record.block_num); // require(token_id == exit_id); exit_ids[record.priority].remove(exit_id); delete exitRecords[exit_id]; emit ExitChallengedEvent(exit_id); }</code> </pre><br>  Esta es la misma verificaci√≥n que si el token se hubiera gastado antes del retiro.  Primero, verifique si hay una transacci√≥n en el hash ra√≠z.  A continuaci√≥n, eliminamos la salida si ya se ha gastado. <br><br><ul><li>  proporcionando una transacci√≥n en el historial de transacciones del token anterior. </li></ul><br>  Esta puede ser una historia incorrecta, por lo que debe confirmarla con una transacci√≥n secundaria: <br><br><pre> <code class="plaintext hljs">// */ function challengeInvalidHistory(uint exit_id, uint blk_num, bytes tx0, bytes proof) public { // check if proof is valid require(checkPatriciaProof(keccak256(tx0), childChain[blk_num].merkle_root, proof)); Exit memory record = exitRecords[exit_id]; require(record.block_num &gt; 0); bytes32 prev_hash; uint token_id; (prev_hash, , token_id, ) = getTransactionFromRLP(tx0); //require(exit_id == token_id); require(tokens[token_id] &gt; 0); // transaction should be before exit tx in history require(blk_num &lt; record.block_num - 1); challenged[exit_id] = blk_num; emit ChallengedInvalidHistory(exit_id, token_id); }</code> </pre><br>  Llamar al primer y segundo script bloquea la salida de inmediato. <br><br>  La llamada al tercer escenario se puede responder proporcionando un descendiente directo.  Debe ser igual o anterior a la transacci√≥n principal. <br><br><pre> <code class="plaintext hljs">/* * Respond to invalid history challenge by providing * the direct child of C*, which must be either equal to or before P( C ) */ function respondChallenge(uint exit_id, uint blk_num, bytes childtx, bytes proof) public { require(challenged[exit_id] &gt; 0); Exit memory record = exitRecords[exit_id]; require(record.block_num &gt; 0); require(checkPatriciaProof(keccak256(childtx), childChain[blk_num].merkle_root, proof)); // get transaction from rlpencoded form bytes32 prev_hash; uint prev_block; uint token_id; (prev_hash, prev_block, token_id, ) = getTransactionFromRLP(childtx); // if direct child if (prev_block == challenged[exit_id] ) { if (blk_num &lt;= record.prev_block &amp;&amp; token_id == exit_id ) { delete challenged[exit_id]; emit ExitRespondedEvent(exit_id); } else { exit_ids[record.priority].remove(exit_id); delete exitRecords[exit_id]; emit ExitChallengedEvent(exit_id); } } }</code> </pre><br>  Es decir, si se recibe la transacci√≥n secundaria correcta, ¬°la salida se disputa y permanece en la cola! <br>  Despu√©s de construir parte del protocolo Opporty Plasma Cash, se lleg√≥ a la siguiente conclusi√≥n: <br>  Este protocolo proporciona seguridad a trav√©s de la cadena ra√≠z Ethereum. <br><br>  Al complicar los procedimientos de entrada y salida de la cadena ra√≠z y la compresi√≥n de estado (bloques de transacci√≥n), examinamos todos los m√©todos de salida y entrada a la cadena ra√≠z, y tambi√©n investigamos las estructuras de datos b√°sicas: transacciones y bloques. <br><br>  Usando la cadena lateral basada en la red Ethereum, puede acelerar significativamente las transacciones.  Opporty recibi√≥ hasta <b>300,000</b> transacciones por segundo en un solo operador.  Esto es mucho m√°s de lo que pueden proporcionar los sistemas de pago actuales. <br><br>  A pesar de algunos problemas de disponibilidad de datos, el operador proporciona un alto nivel de estabilidad de blockchain y permite realizar transacciones comerciales internacionales efectivas. <br><br>  Plasma Cash trae un gran aumento en la escalabilidad.  Por lo tanto, Opporty usa Plasma como parte de su protocolo PoE. <br><br><h3>  Enlaces utiles </h3><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Papel blanco plasma</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Git Hub</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Descripci√≥n de casos de uso y arquitectura</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Papel de red de rayos</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/457518/">https://habr.com/ru/post/457518/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../457508/index.html">Parenting vs Machine Learning: compara una madre joven</a></li>
<li><a href="../457510/index.html">Use mcrouter para escalar memcached horizontalmente</a></li>
<li><a href="../457512/index.html">Replicaci√≥n l√≥gica entre versiones de PostgreSQL</a></li>
<li><a href="../457514/index.html">Nevanger</a></li>
<li><a href="../457516/index.html">Escribir un modelo de amenaza</a></li>
<li><a href="../457522/index.html">¬øAumentar el servicio de su lista de correo o usar soluciones preparadas? Lo que aprend√≠ durante 5 a√±os en UniSender</a></li>
<li><a href="../457524/index.html">C√°maras de profundidad: revoluci√≥n silenciosa (cuando los robots lo ver√°n) Parte 1</a></li>
<li><a href="../457526/index.html">Medios t√©cnicos como un bazar</a></li>
<li><a href="../457532/index.html">Ya es hora de formar parte de un proyecto de c√≥digo abierto</a></li>
<li><a href="../457534/index.html">Versiones certificadas: el rastrillo que elegimos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>