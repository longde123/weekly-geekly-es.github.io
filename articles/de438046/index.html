<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëçüèø üì≥ üëû Wie kann man schnell eine Million Punkte auf Spark geocodieren? üçπ üíÆ ‚òëÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In meinem vorherigen Projekt standen wir vor der Aufgabe, eine umgekehrte Geokodierung f√ºr viele Paare geografischer Koordinaten durchzuf√ºhren. Die um...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie kann man schnell eine Million Punkte auf Spark geocodieren?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438046/">  In meinem vorherigen Projekt standen wir vor der Aufgabe, eine <b>umgekehrte</b> Geokodierung f√ºr viele Paare geografischer Koordinaten durchzuf√ºhren.  Die umgekehrte Geokodierung ist eine Prozedur, bei der ein Breiten- und L√§ngengradpaar mit der Adresse oder dem Namen eines Objekts auf der Karte abgeglichen wird, zu dem der angegebene Punkt oder die angegebenen Koordinaten geh√∂ren oder in dessen N√§he er sich befindet.  Das hei√üt, wir nehmen die Koordinaten, sagen diese: @ 55.7602485,37.6170409, und wir erhalten das Ergebnis entweder "Russland, der zentrale Bundesbezirk, Moskau, Theaterplatz, so und so Haus" oder zum Beispiel "Das Bolschoi-Theater". <br><br>  Wenn sich die Adresse oder der Name am Eingang befindet und die Koordinaten am Ausgang liegen, handelt es sich bei dieser Operation um eine <b>direkte Geokodierung</b> . Wir hoffen, dass wir sp√§ter dar√ºber sprechen k√∂nnen. <br><br>  Als Eingabe hatten wir ungef√§hr 100.000 oder 200.000 Punkte an der Eingabe, die im Hadoop-Cluster als Hive-Tabelle lagen.  Dies soll den Umfang der Aufgabe verdeutlichen. <br><br>  Spark wurde schlie√ülich als Verarbeitungswerkzeug ausgew√§hlt, obwohl wir dabei sowohl MapReduce als auch Apache Crunch ausprobiert haben.  Aber dies ist eine separate Geschichte, die vielleicht ihren Beitrag verdient. <br><a name="habracut"></a><br><h2>  Einfache L√∂sung mit erschwinglichen Mitteln </h2><br>  Zun√§chst haben wir versucht, uns sozusagen dem Problem zu n√§hern.  Als Tool gab es einen ArcGIS-Server, der einen REST-Service f√ºr die umgekehrte Geokodierung bereitstellte.  Die Verwendung ist recht einfach. Dazu f√ºhren wir eine http GET-Anfrage mit der folgenden URL durch: <br><br><pre><code class="plaintext hljs">http://-url/GeocodeServer/reverseGeocode?&lt;&gt;</code> </pre> <br>  Von den vielen Parametern reicht es aus, location = x, y zu setzen (die Hauptsache ist nicht zu verwechseln, welcher von ihnen der Breitengrad und welcher der L√§ngengrad ist;).  Und jetzt haben wir bereits JSON mit den Ergebnissen: Land, Region, Stadt, Stra√üe, Hausnummer.  Beispiel aus der Dokumentation: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"address"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Match_addr"</span></span>: <span class="hljs-string"><span class="hljs-string">"Beeman's Redlands Pharmacy"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"LongLabel"</span></span>: <span class="hljs-string"><span class="hljs-string">"Beeman's Redlands Pharmacy, 255 Terracina Blvd, Redlands, CA, 92373, USA"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ShortLabel"</span></span>: <span class="hljs-string"><span class="hljs-string">"Beeman's Redlands Pharmacy"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Addr_type"</span></span>: <span class="hljs-string"><span class="hljs-string">"POI"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Type"</span></span>: <span class="hljs-string"><span class="hljs-string">"Pharmacy"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"PlaceName"</span></span>: <span class="hljs-string"><span class="hljs-string">"Beeman's Redlands Pharmacy"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"AddNum"</span></span>: <span class="hljs-string"><span class="hljs-string">"255"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Address"</span></span>: <span class="hljs-string"><span class="hljs-string">"255 Terracina Blvd"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Block"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Sector"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Neighborhood"</span></span>: <span class="hljs-string"><span class="hljs-string">"South Redlands"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"District"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"City"</span></span>: <span class="hljs-string"><span class="hljs-string">"Redlands"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"MetroArea"</span></span>: <span class="hljs-string"><span class="hljs-string">"Inland Empire"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Subregion"</span></span>: <span class="hljs-string"><span class="hljs-string">"San Bernardino County"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Region"</span></span>: <span class="hljs-string"><span class="hljs-string">"California"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Territory"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Postal"</span></span>: <span class="hljs-string"><span class="hljs-string">"92373"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"PostalExt"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"CountryCode"</span></span>: <span class="hljs-string"><span class="hljs-string">"USA"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"location"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"x"</span></span>: <span class="hljs-number"><span class="hljs-number">-117.20558993392585</span></span>, <span class="hljs-attr"><span class="hljs-attr">"y"</span></span>: <span class="hljs-number"><span class="hljs-number">34.037880040538894</span></span>, <span class="hljs-attr"><span class="hljs-attr">"spatialReference"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"wkid"</span></span>: <span class="hljs-number"><span class="hljs-number">4326</span></span>, <span class="hljs-attr"><span class="hljs-attr">"latestWkid"</span></span>: <span class="hljs-number"><span class="hljs-number">4326</span></span> } } }</code> </pre><br>  Sie k√∂nnen zus√§tzlich angeben, welche Arten von Antworten wir m√∂chten - Postanschriften oder POI (Punkt von Interesse, um Antworten wie ‚ÄûBolschoi-Theater‚Äú zu erhalten) oder ob wir beispielsweise Stra√üenkreuzungen ben√∂tigen.  Sie k√∂nnen auch den Radius angeben, innerhalb dessen ein benanntes Objekt vom angegebenen Punkt aus durchsucht wird. <br><br>  Um die Qualit√§t der Antwort schnell zu √ºberpr√ºfen, k√∂nnen Sie den Abstand zwischen dem Startpunkt in den Anforderungsparametern und dem empfangenen Punkt - Ort in der Serviceantwort sch√§tzen. <br><br>  Es scheint, dass jetzt alles gut wird.  Aber da war es.  Unsere ArcGIS-Instanz war ziemlich langsam, dem Server wurden 4 Kerne und etwa 8 Gigabyte RAM zugewiesen.  Infolgedessen konnte die Aufgabe im Cluster unsere 200.000 Punkte sehr schnell lesen, beruhte jedoch auf der REST- und ArcGIS-Leistung.  Die Geokodierung aller Punkte dauerte Stunden.  Gleichzeitig haben wir in Hadoop nur 8 Kerne und ein wenig Speicher zugewiesen. Da das Laden des ArcGIS-Servers jedoch viele Stunden lang nahezu 100% betrug, haben uns die zus√§tzlichen Ressourcen im Cluster nichts gebracht. <br><br>  ArcGIS kann keine Batch-Reverse-Geokodierungsvorg√§nge ausf√ºhren, daher wird die Anforderung f√ºr jeden Punkt einmal ausgef√ºhrt.  √úbrigens, wenn der Dienst nicht antwortet, fallen wir durch Zeit√ºberschreitung oder mit einem Fehler ab, und was damit zu tun ist, ist ein Problem mit einer nicht offensichtlichen Antwort.  Versuchen Sie es vielleicht noch einmal oder schlie√üen Sie den gesamten Vorgang ab und wiederholen Sie ihn f√ºr die Rohpunkte. <br><br><h2>  In der zweiten N√§herung f√ºhren wir den Cache ein </h2><br>  Zun√§chst stellten wir fest, dass viele Punkte in unserem Satz sich wiederholende Koordinaten haben.  Der Grund ist einfach: Offensichtlich ist die GPS-Genauigkeit nicht gut genug, damit sich die Koordinaten der zwei Meter voneinander entfernten Punkte am Ausgang unterscheiden, oder die Koordinaten, die nicht vom GPS, sondern von einer anderen Basis erhalten wurden, wurden einfach in die Quellendatenbank eingegeben.  Im Allgemeinen spielt es keine Rolle, warum dies so ist. Hauptsache, dies ist eine sehr typische Situation. Mit dem vom Service empfangenen Ergebnis-Cache k√∂nnen Sie jedes Koordinatenpaar nur einmal geocodieren.  Und wir k√∂nnen uns den Speicher f√ºr den Cache durchaus leisten. <br><br>  Tats√§chlich wurde die erste √Ñnderung des Algorithmus trivial gemacht - alle von REST erhaltenen Ergebnisse wurden dem Cache hinzugef√ºgt, und f√ºr alle Punkte wurde zuerst nach den darin enthaltenen Koordinaten gesucht.  Wir haben nicht einmal damit begonnen, einen gemeinsamen Cache f√ºr alle Spark-Prozesse zu erstellen - auf jedem Knoten des Clusters hatte er einen eigenen. <br><br>  Auf so einfache Weise konnten wir eine Beschleunigung von bis zu etwa dem Zehnfachen erzielen, was ungef√§hr der Anzahl der Koordinatenwiederholungen im urspr√ºnglichen Satz entspricht.  Es war schon akzeptabel, aber immer noch sehr langsam. <br><br>  Nun, unser Kunde sagte uns zu diesem Zeitpunkt, wenn wir die Adressen nicht schneller herausfinden k√∂nnen, k√∂nnen wir dann zumindest eine Stadt schnell identifizieren?  Und wir haben aufgenommen ... <br><br><h2>  Vereinfachte L√∂sung zur Implementierung der Geomerty-API </h2><br>  Was m√ºssen wir eine Stadt definieren?  Wir hatten die Geometrie der Regionen Russlands, die administrativ-territoriale Aufteilung, ungef√§hr auf die Bezirke der Stadt abgestimmt. <br><br>  Sie k√∂nnen diese Daten zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier nehmen</a> .  Was ist da  Dies ist eine Datenbank der Verwaltungsgrenzen der Russischen F√∂deration f√ºr Ebenen von 2 (Land) bis 9 (Stadtbezirke).  Das Format ist entweder Geojson oder CSV (w√§hrend die Geometrie selbst im wkt-Format vorliegt).  Insgesamt umfasst die Datenbank etwa 20.000 Datens√§tze. <br><br>  Eine neue vereinfachte L√∂sung des Problems sah folgenderma√üen aus: <br><br><ol><li>  Hochladen von ADT-Daten in Hive. </li><li>  F√ºr jeden Punkt mit Koordinaten suchen wir in der Tabelle der territorialen Aufteilung nach Polygonen, in die dieser Punkt eintritt. </li><li>  Sortieren Sie die gefundenen Polygone nach Ebene. </li></ol><br>  Als Ergebnis erhalten wir so etwas wie: Russland, den zentralen Bundesbezirk, Moskau, so und so einen Verwaltungsbezirk, ein Gebiet von so und so, dh eine Liste von Gebieten, zu denen unser Punkt geh√∂rt. <br><br><h3>  ADT wird geladen </h3><br>  Um CSV einfacher herunterzuladen, verwenden wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kite</a> .  Dieses Tool kann sehr gut ein Schema f√ºr Hive erstellen, das auf den Spalten√ºberschriften in CSV basiert.  Tats√§chlich besteht der Import aus drei Befehlen (von denen einer f√ºr jede Ebenendatei wiederholt wird): <br><br><pre> <code class="plaintext hljs">kite-tools csv-schema admin_level_2.csv --class al --delimiter \; &gt;adminLevel.avrs kite-tools create dataset:hive:/default/levelswkt -s adminLevel.avrs kite-tools csv-import admin_level_2.csv dataset:hive:/default/levelswkt --delimiter \; ... kite-tools csv-import admin_level_10.csv dataset:hive:/default/levelswkt --delimiter \;</code> </pre><br>  Was haben wir hier gemacht?  Das erste Team hat uns ein Avro-Schema f√ºr csv erstellt, f√ºr das wir einige Parameter des Schemas (in diesem Fall Klasse) und ein Feldtrennzeichen f√ºr CSV angegeben haben.  Als n√§chstes lohnt es sich, das erhaltene Diagramm mit Ihren Augen zu betrachten, und es ist m√∂glich, einige Korrekturen vorzunehmen, da Kite nicht alle Zeilen unserer Datei, sondern nur einige Beispiele betrachtet, sodass manchmal falsche Annahmen √ºber den Datentyp getroffen werden k√∂nnen (ich habe drei Zahlen gesehen - das habe ich entschieden numerische Spalte, und dann ging die Zeile). <br><br>  Nun, basierend auf dem Schema erstellen wir einen Datensatz (dies ist der allgemeine Begriff Kite, der Tabellen in Hive verallgemeinert, Tabellen in HBase und etwas anderes).  In diesem Fall ist die Datenbank standardm√§√üig (f√ºr Hive ist sie mit dem Schema identisch), und levelwkt ist der Name unserer Tabelle. <br><br>  Nun, die neuesten Befehle laden CSV-Dateien in unseren Datensatz hoch.  Nachdem der Download erfolgreich abgeschlossen wurde, k√∂nnen Sie die Anforderung bereits abschlie√üen: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> levelswkt;</code> </pre> <br>  irgendwo in der Farbe. <br><br><h3>  Arbeite mit Geometrie </h3><br>  F√ºr die Arbeit mit Geometrie in Java haben wir die Esri <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Java Geometry API</a> (ArcGIS-Entwickler) ausgew√§hlt.  Grunds√§tzlich war es m√∂glich, andere Frameworks zu verwenden, es gibt eine Auswahl an Open Source, zum Beispiel die weithin bekannte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JTS Topology Suite</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Geotools</a> . <br><br>  Die erste Aufgabe erm√∂glicht es uns, mit einem anderen Framework derselben Esri-Firma fertig zu werden, das als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spatial Framework f√ºr Hadoop bezeichnet</a> wird und auf dem ersten basiert.  Tats√§chlich ben√∂tigen wir das sogenannte SerDe, das Serialisierungs-Deserialisierungs-Modul f√ºr Hive, mit dem wir eine Reihe von Geojson-Dateien als Tabelle in Hive darstellen k√∂nnen, deren Spalten aus Geojson-Attributen stammen.  Und die Geometrie selbst wird zu einer weiteren Spalte (mit Bin√§rdaten).  Als Ergebnis haben wir eine Tabelle, deren eine Spalte die Geometrie einer bestimmten Region ist, und der Rest sind ihre Attribute (Name, Ebene in der ADT usw.).  Diese Tabelle steht der Spark-Anwendung zur Verf√ºgung. <br><br>  Wenn wir die Datenbank im CSV-Format laden, haben wir eine Spalte, in der die Geometrien in Textform im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WKT-</a> Format vorliegen.  In diesem Fall kann Spark zur Laufzeit mithilfe der Geometrie-API ein Geometrieobjekt erstellen. <br><br>  Wir haben uns aus einem einfachen Grund f√ºr das CSV-Format (und WKT) entschieden - wie jeder wei√ü, belegt Russland auf der Karte das Gebiet mit den Koordinaten von Tschukotka jenseits des 180-Meridians.  Das Geojson-Format hat eine Einschr√§nkung: Alle darin enthaltenen Polygone m√ºssen auf 180 Grad begrenzt sein, und diejenigen, die den 180-Meridian kreuzen, m√ºssen in zwei Teile geschnitten werden.  Als Ergebnis erhalten wir beim Importieren von Geometrie in die Geometrie-API ein Objekt, f√ºr das die Geometrie-API den Begrenzungsrahmen (umschlie√üendes Rechteck) f√ºr den russischen Rand falsch definiert.  Es stellt sich heraus, dass die Antwort -180.180 in der L√§nge ist.  Was nat√ºrlich nicht stimmt - in Wirklichkeit nimmt Russland etwa 20 bis -170 Grad ein.  Dies ist ein Geometrie-API-Problem, das heute m√∂glicherweise bereits behoben ist, aber dann mussten wir es umgehen. <br><br>  WKT hat kein solches Problem.  Sie fragen sich vielleicht, warum wir eine Bounding Box brauchen?  Dann werde ich erz√§hlen;) <br><br>  Es bleibt das sogenannte PIP-Problem zu l√∂sen, Punkt in Poligon.  Die Java-Geometrie-API kann dies erneut tun. F√ºr uns ist es einfach, eine Geometrie vom Typ Point, ein zweites Polygon (Multipoligon) f√ºr die Region und eine Methode. <br><br>  Infolgedessen sah die zweite L√∂sung und auch auf der Stirn folgenderma√üen aus: Die Spark-Anwendung l√§dt das ADT einschlie√ülich der Geometrie.  Daraus wird so etwas wie Kartenname-&gt; Geometrie erstellt (eigentlich etwas komplizierter, da die ADTs ineinander verschachtelt sind und wir nur in den unteren Ebenen suchen m√ºssen, die in der bereits gefundenen oberen Ebene enthalten sind. Infolgedessen gibt es eine Art Geometriebaum, der entsprechend der Quelle m√ºssen noch Daten erstellt werden).  Und dann erstellen wir einen Spark-Datensatz mit unseren Punkten und wenden f√ºr jeden Punkt unsere eigene UDF an, die den Eintrag des Punkts in alle Geometrien (im Baum) √ºberpr√ºft. <br><br>  Das Schreiben einer neuen Version dauert ungef√§hr einen Arbeitstag, da das Spatial Framework f√ºr Hadoop-Bundle gute Beispiele f√ºr die direkte L√∂sung der PIP-Aufgabe enthielt (allerdings mit mehreren anderen Mitteln). <br><br>  Wir fangen an und ... oh, Entsetzen, etwas wurde nicht schneller.  Schau nochmal zu.  Es ist Zeit, √ºber Optimierung nachzudenken. <br><br><h2>  Optimierte L√∂sung, QuadTree </h2><br>  Der Grund f√ºr die Bremsen liegt auf der Hand - etwa die Geometrie Russlands, d.h.  Au√üengrenzen, das sind Megabyte Geojson, ein kr√§ftiges Polygon und keines.  Wenn wir uns daran erinnern, wie das PIP-Problem gel√∂st ist, besteht eine der bekannten Methoden darin, einen Strahl von einem Punkt, etwa irgendwo oben, bis ins Unendliche zu erzeugen und zu bestimmen, an wie vielen Punkten er das Polygon schneidet.  Wenn die Anzahl der Punkte gerade ist, befindet sich der Punkt au√üerhalb des Polygons, wenn er ungerade ist, befindet er sich innerhalb. <br><br>  Hier ist eine Beschreibung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aus dem Wiki</a> . <br><br><img src="https://habrastorage.org/webt/rr/e4/pr/rre4praq1mhfcbtbekvdutvgge0.png"><br><br>  Es ist klar, dass f√ºr ein gro√ües Polygon die L√∂sung des Schnittpunktproblems so oft kompliziert ist, wie es gerade Linien in unserem Polygon gibt.  Daher ist es w√ºnschenswert, die Polygone, in die der Punkt offensichtlich nicht eintreten kann, irgendwie zu verwerfen.  Und als zus√§tzlichen Lebenshack ist es m√∂glich, den Scheck f√ºr die Einreise in die Grenzen Russlands fallen zu lassen (wenn wir wissen, dass alle Koordinaten offensichtlich darin enthalten sind). <br><br>  Daf√ºr ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Quadrantenbaum</a> f√ºr uns geeignet.  Gl√ºcklicherweise befindet sich die Implementierung alle in derselben Geometrie-API (und vielen weiteren). <br><br><img src="https://habrastorage.org/webt/8l/ie/_x/8lie_xz2j_spgusj9mqul0ratsy.png" width="400" height="400"><br><br>  Die baumbasierte L√∂sung sieht ungef√§hr so ‚Äã‚Äãaus: <br><br><ol><li>  Laden der ATD-Geometrie </li><li>  F√ºr jede Geometrie definieren wir ein umschlie√üendes Rechteck </li><li>  Wir setzen es in QuadTree, wir bekommen den Index als Antwort </li><li>  Der Index wird gespeichert </li></ol><br>  Als n√§chstes bei der Verarbeitung von Punkten: <br><br><ol><li>  Wir fragen QuadTree, welche der ihm bekannten Geometrien einen Punkt enthalten kann </li><li>  Holen Sie sich die Indizes der Geometrien </li><li>  Nur f√ºr sie √ºberpr√ºfen wir das Auftreten durch L√∂sen des PIP-Problems </li></ol><br>  Die Entwicklung dauert weitere vier Stunden.  Wir fangen wieder an und sehen, dass die Aufgabe irgendwie sehr schnell erledigt wurde.  Wir pr√ºfen - alles ist in Ordnung, die L√∂sung ist eingegangen.  Und das alles in ein paar Minuten.  QuadTree beschleunigt uns um mehrere Gr√∂√üenordnungen. <br><br><h2>  Zusammenfassung </h2><br>  Also, was haben wir am Ende?  Wir haben einen umgekehrten Geokodierungsmechanismus, der auf einem Hadoop-Cluster effektiv parallelisiert und unser anf√§ngliches Problem mit 200.000 Punkten in etwa einer Minute l√∂st.  Das hei√üt,  Wir k√∂nnen diese L√∂sung leicht auf Millionen von Punkten anwenden. <br><br>  Was sind die Einschr√§nkungen dieser L√∂sung?  Erstens die offensichtliche - sie basiert auf den uns zur Verf√ºgung stehenden ADT-Daten, die a) m√∂glicherweise nicht relevant sind, b) nur auf Russland beschr√§nkt sind. <br><br>  Und zweitens - wir k√∂nnen das Problem der umgekehrten Geokodierung f√ºr andere Objekte als geschlossene Polygone nicht l√∂sen.  Und das hei√üt - auch f√ºr die Stra√üe. <br><br><h2>  Entwicklung </h2><br>  Was kann man damit machen? <br><br>  Um die aktuellen ADT-Geometrien zu erhalten, ist es am einfachsten, sie von OpenStreetMap abzurufen.  Nat√ºrlich m√ºssen sie ein wenig arbeiten, aber das ist eine v√∂llig l√∂sbare Aufgabe.  Bei Interesse werde ich √ºber die Aufgabe sprechen, OpenStreetMap-Daten ein anderes Mal in einen Hadoop-Cluster zu laden. <br><br>  Was kann man f√ºr Stra√üen und H√§user tun?  Im Prinzip befinden sich die Stra√üen im selben OSM.  Dies sind aber keine geschlossenen Strukturen, sondern Linien.  Um festzustellen, dass der Punkt "nahe" an einer bestimmten Stra√üe liegt, m√ºssen Sie ein Polygon f√ºr die Stra√üe aus Punkten erstellen, die gleich weit davon entfernt sind, und pr√ºfen, ob er in diese Stra√üe gelangt.  Als Ergebnis stellt sich eine Art Wurst heraus ... es sieht ungef√§hr so ‚Äã‚Äãaus: <br><br><img src="https://habrastorage.org/webt/6h/ky/of/6hkyoffev4qx6a07-vlw2vluytc.png"><br><br>  Wie nah ist der Punkt?  Dies ist ein Parameter und entspricht in etwa dem Radius, in dem ArcGIS nach Objekten sucht, den ich ganz am Anfang erw√§hnt habe. <br><br>  So finden wir Stra√üen, deren Entfernung von einem Punkt weniger als eine bestimmte Grenze betr√§gt (z. B. 100 Meter).  Und je kleiner diese Grenze ist, desto schneller arbeitet der Algorithmus, aber desto wahrscheinlicher ist es, dass Sie keine einzige √úbereinstimmung finden. <br><br>  Das offensichtliche Problem ist, dass es unm√∂glich ist, diese sogenannten Puffer im Voraus zu berechnen - ihre Gr√∂√üe ist ein Parameter des Dienstes.  Sie m√ºssen im laufenden Betrieb gebaut werden, nachdem wir das gew√ºnschte Gebiet der Stadt identifiziert und aus der OSM-Basis die Stra√üen ausgew√§hlt haben, die durch dieses Gebiet f√ºhren.  Die Stra√üen k√∂nnen jedoch im Voraus ausgew√§hlt werden. <br><br>  Die H√§user, die sich in dem gefundenen Bereich befinden, bewegen sich auch nirgendwo hin, so dass ihre Liste im Voraus erstellt werden kann - aber das Betreten muss noch im Handumdrehen in Betracht gezogen werden. <br><br>  Das hei√üt, Sie m√ºssen zuerst einen Index der Form ‚ÄûStadtteil‚Äú erstellen -&gt; eine Liste von H√§usern mit Links zu Geometrien und eine √§hnliche Liste f√ºr die Liste der Stra√üen. <br><br>  Und sobald wir das Gebiet identifiziert haben, erhalten wir die Liste der H√§user und Stra√üen, bauen entlang der Stra√üen der Grenze und l√∂sen nur f√ºr sie das PIP-Problem (wahrscheinlich unter Verwendung der gleichen Optimierungen wie f√ºr die Grenzen der Regionen).  Der Quadrantenbaum f√ºr H√§user kann in diesem Fall nat√ºrlich auch im Voraus gebaut und irgendwo gespeichert werden. <br><br>  Unser Hauptziel ist es, den Rechenaufwand zu minimieren und gleichzeitig alles zu maximieren und im Voraus zu erhalten, was berechnet und gespeichert werden kann.  In diesem Fall besteht der Prozess aus einer langsamen Phase der Indexerstellung und einer zweiten Phase der Berechnung, die in der N√§he der Online-Version bereits schnell erfolgt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438046/">https://habr.com/ru/post/de438046/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438028/index.html">Sie brauchen keine Blockchain: 8 beliebte Benutzerf√§lle und warum sie nicht funktionieren</a></li>
<li><a href="../de438032/index.html">Beliebte Open Source - Teil zwei: 5 Cloud-Management-Tools</a></li>
<li><a href="../de438036/index.html">3blue1brown und MIT auf Russisch</a></li>
<li><a href="../de438038/index.html">Karriere Steroide. Echte Geschichten</a></li>
<li><a href="../de438042/index.html">Die Entwicklung des x86-Kontextwechsels unter Linux</a></li>
<li><a href="../de438050/index.html">Kalman-Filter zur Minimierung des Entropiewertes eines zuf√§lligen Fehlers mit einer nicht-Gau√üschen Verteilung</a></li>
<li><a href="../de438052/index.html">Interaktor, Betriebsmuster</a></li>
<li><a href="../de438058/index.html">"Datenanalyse in Python" in zwei Teilen</a></li>
<li><a href="../de438060/index.html">Einsch√§tzung der r√§umlichen Ausrichtung oder Wie man keine Angst vor Mahoney- und Majwik-Filtern hat</a></li>
<li><a href="../de438062/index.html">Meine Adresse ist kein Haus oder eine Stra√üe, meine Adresse ist die Sowjetunion?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>