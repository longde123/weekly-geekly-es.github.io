<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游쓇릞 鮫놾잺 游 Simple y en C ++. Conceptos b치sicos de Userver: un marco para escribir microservicios asincr칩nicos 游뛐 游녾游낕 游똀游</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Yandex.Taxi se adhiere a la arquitectura de microservicios. Con el aumento en el n칰mero de microservicios, notamos que los desarrolladores dedican muc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Simple y en C ++. Conceptos b치sicos de Userver: un marco para escribir microservicios asincr칩nicos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/474438/">  Yandex.Taxi se adhiere a la arquitectura de microservicios.  Con el aumento en el n칰mero de microservicios, notamos que los desarrolladores dedican mucho tiempo a repeticiones y problemas t칤picos, mientras que las soluciones no siempre funcionan de manera 칩ptima. <br><br>  Decidimos crear nuestro propio marco, con C ++ 17 y corutinas.  As칤 es como se ve un c칩digo t칤pico de microservicio: <br><br><pre><code class="cpp hljs">Response View::Handle(Request&amp;&amp; request, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Dependencies&amp; dependencies) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> cluster = dependencies.pg-&gt;GetCluster(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> trx = cluster-&gt;Begin(storages::postgres::ClusterHostType::kMaster); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* statement = <span class="hljs-string"><span class="hljs-string">"SELECT ok, baz FROM some WHERE id = $1 LIMIT 1"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> row = psql::Execute(trx, statement, request.id)[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!row[<span class="hljs-string"><span class="hljs-string">"ok"</span></span>].As&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;()) { LOG_DEBUG() &lt;&lt; request.id &lt;&lt; <span class="hljs-string"><span class="hljs-string">" is not OK of "</span></span> &lt;&lt; GetSomeInfoFromDb(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Response400(); } psql::Execute(trx, queries::kUpdateRules, request.foo, request.bar); trx.Commit(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Response200{row[<span class="hljs-string"><span class="hljs-string">"baz"</span></span>].As&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;()}; }</code> </pre> <br>  Y aqu칤 es por qu칠 es extremadamente efectivo y r치pido: lo contaremos debajo del corte. <br><a name="habracut"></a><br><h2>  Usuario - As칤ncrono </h2><br>  Nuestro equipo no solo est치 formado por desarrolladores experimentados de C ++: hay aprendices, desarrolladores junior e incluso personas que no est치n particularmente acostumbradas a escribir en C ++.  Por lo tanto, el dise침o del usuario se basa en la facilidad de uso.  Sin embargo, con nuestros vol칰menes y carga de datos, tampoco podemos permitirnos desperdiciar los recursos de hierro de manera ineficiente. <br><br>  Los microservicios se caracterizan por la expectativa de entrada / salida: a menudo la respuesta de un microservicio se forma a partir de varias respuestas de otros microservicios y bases de datos.  El problema de la espera eficiente de E / S se resuelve a trav칠s de m칠todos as칤ncronos y devoluciones de llamada: con operaciones asincr칩nicas, no hay necesidad de generar hilos de ejecuci칩n y, en consecuencia, no hay una gran sobrecarga para cambiar los flujos ... solo el c칩digo es bastante dif칤cil de escribir y mantener: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> View::Handle(Request&amp;&amp; request, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Dependencies&amp; dependencies, Response response) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> cluster = dependencies.pg-&gt;GetCluster(); cluster-&gt;Begin(storages::postgres::ClusterHostType::kMaster, [request = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(request), response](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; trx) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* statement = <span class="hljs-string"><span class="hljs-string">"SELECT ok, baz FROM some WHERE id = $1 LIMIT 1"</span></span>; psql::Execute(trx, statement, request.id, [request = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(request), response, trx = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(trx)](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; res) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> row = res[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!row[<span class="hljs-string"><span class="hljs-string">"ok"</span></span>].As&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (LogDebug()) { GetSomeInfoFromDb([id = request.id](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> info) { LOG_DEBUG() &lt;&lt; id &lt;&lt; <span class="hljs-string"><span class="hljs-string">" is not OK of "</span></span> &lt;&lt; info; }); } *response = Response400{}; } psql::Execute(trx, queries::kUpdateRules, request.foo, request.bar, [row = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(row), trx = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(trx), response]() { trx.Commit([row = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(row), response]() { *response = Response200{row[<span class="hljs-string"><span class="hljs-string">"baz"</span></span>].As&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;()}; }); }); }); }); }</code> </pre><br>  Y aqu칤 las pilas llenas de coroutines vienen al rescate.  El usuario del marco cree que escribe el c칩digo s칤ncrono habitual: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> row = psql::Execute(trx, queries::kGetRules, request.id)[<span class="hljs-number"><span class="hljs-number">0</span></span>];</code> </pre><br>  Sin embargo, aproximadamente lo siguiente ocurre debajo del cap칩: <br><br><ol><li>  Los paquetes TCP se generan y env칤an con una solicitud a la base de datos; </li><li>  se suspende la ejecuci칩n de la rutina, en la que la funci칩n View :: Handle se est치 ejecutando actualmente; </li><li>  le decimos al n칰cleo del sistema operativo: "" Coloque la rutina suspendida en la cola de tareas listas para su ejecuci칩n tan pronto como salgan suficientes paquetes TCP de la base de datos "; </li><li>  sin esperar el paso anterior, tomamos y lanzamos otra corutina lista para su ejecuci칩n desde la cola. </li></ol><br>  En otras palabras, la funci칩n del primer ejemplo funciona de forma as칤ncrona y est치 cerca de dicho c칩digo utilizando C ++ 20 Coroutines: <br><br><pre> <code class="cpp hljs">Response View::Handle(Request&amp;&amp; request, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Dependencies&amp; dependencies) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> cluster = dependencies.pg-&gt;GetCluster(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> trx = co_await cluster-&gt;Begin(storages::postgres::ClusterHostType::kMaster); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* statement = <span class="hljs-string"><span class="hljs-string">"SELECT ok, baz FROM some WHERE id = $1 LIMIT 1"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> row = co_await psql::Execute(trx, statement, request.id)[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!row[<span class="hljs-string"><span class="hljs-string">"ok"</span></span>].As&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;()) { LOG_DEBUG() &lt;&lt; request.id &lt;&lt; <span class="hljs-string"><span class="hljs-string">" is not OK of "</span></span> &lt;&lt; <span class="hljs-function"><span class="hljs-function">co_await </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSomeInfoFromDb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; co_return Response400{<span class="hljs-string"><span class="hljs-string">"NOT_OK"</span></span>, <span class="hljs-string"><span class="hljs-string">"Please provide different ID"</span></span>}; } co_await psql::Execute(trx, queries::kUpdateRules, request.foo, request.bar); co_await trx.Commit(); co_return Response200{row[<span class="hljs-string"><span class="hljs-string">"baz"</span></span>].As&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;()}; }</code> </pre><br>  Eso es solo que el usuario no necesita pensar en co_await y co_return, todo funciona "por s칤 solo". <br><br>  En nuestro marco, el cambio entre corutinas es m치s r치pido que llamar a std :: this_thread :: yield ().  Todo el microservicio cuesta una cantidad muy peque침a de subprocesos. <br><br>  Por el momento, userver contiene controladores asincr칩nicos: <br>  * para tomas de SO; <br>  * http y https (cliente y servidor); <br>  * PostgreSQL; <br>  * MongoDB; <br>  * Redis; <br>  * trabajar con archivos; <br>  * temporizadores; <br>  * primitivas para sincronizar y lanzar nuevas corutinas. <br><br>  El enfoque asincr칩nico anterior para resolver tareas vinculadas a E / S deber칤a ser familiar para los desarrolladores de Go.  Pero, a diferencia de Go, no obtenemos gastos de memoria y CPU del recolector de basura.  Los desarrolladores pueden usar un lenguaje m치s rico, con varios contenedores y bibliotecas de alto rendimiento, sin sufrir falta de consistencia, RAII o plantillas. <br><br><h2>  Userver - componentes </h2><br>  Por supuesto, un marco completo no es solo corutinas.  Las tareas de los desarrolladores en Taxi son extremadamente diversas, y cada una de ellas requiere su propio conjunto de herramientas para resolver.  Por lo tanto, userver tiene todo lo que necesita: <br>  * para iniciar sesi칩n; <br>  * almacenamiento en cach칠; <br>  * trabajar con varios formatos de datos; <br>  * trabajar con configuraciones y actualizar configuraciones sin reiniciar el servicio; <br>  * cerraduras distribuidas; <br>  * prueba; <br>  * autorizaci칩n y autenticaci칩n; <br>  * crear y enviar m칠tricas; <br>  * escribir manejadores REST; <br>  + generaci칩n de c칩digo y soporte de dependencia (hecho en una parte separada del marco). <br><br><h2>  Userver - generaci칩n de c칩digo </h2><br>  Volvamos a la primera l칤nea de nuestro ejemplo y veamos qu칠 se esconde detr치s de Respuesta y Solicitud: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Response </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Request&amp;&amp; request, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Dependencies&amp; dependencies)</span></span></span></span>;</code> </pre><br>  Con userver puede escribir cualquier microservicio, pero nuestros microservicios tienen el requisito de que sus API deben estar documentadas (descritas a trav칠s de esquemas swagger). <br><br>  Por ejemplo, para Handle del ejemplo, el diagrama swagger podr칤a verse as칤: <br><br><pre> <code class="json hljs">paths: /some/sample/{bar}: post: description: |     Habr. summary: | ,  -   . parameters: - in: query name: id type: string required: <span class="hljs-literal"><span class="hljs-literal">true</span></span> - in: header name: foo type: string enum: - foo<span class="hljs-number"><span class="hljs-number">1</span></span> - foo<span class="hljs-number"><span class="hljs-number">2</span></span> required: <span class="hljs-literal"><span class="hljs-literal">true</span></span> - in: path name: bar type: string required: <span class="hljs-literal"><span class="hljs-literal">true</span></span> responses: '<span class="hljs-number"><span class="hljs-number">200</span></span>': description: OK schema: type: object additionalProperties: <span class="hljs-literal"><span class="hljs-literal">false</span></span> required: - baz properties: baz: type: string '<span class="hljs-number"><span class="hljs-number">400</span></span>': $ref: '#/responses/ResponseCommonError'</code> </pre><br>  Bueno, dado que el desarrollador ya tiene un esquema con una descripci칩n de solicitudes y respuestas, 쯣or qu칠 no generar estas solicitudes y respuestas basadas en 칠l?  Al mismo tiempo, los enlaces a los archivos protobuf / flatbuffer / ... tambi칠n se pueden indicar en el esquema: la generaci칩n de c칩digo a partir de la solicitud obtendr치 todo, validar치 los datos de entrada de acuerdo con el esquema y los descompondr치 en los campos de la estructura de Respuesta.  El usuario solo necesita escribir la funcionalidad en el m칠todo Handle, sin ser distra칤do por el repetitivo con el an치lisis de solicitudes y la serializaci칩n de la respuesta. <br><br>  Al mismo tiempo, la generaci칩n de c칩digo funciona para clientes de servicio.  Puede indicar que su servicio necesita un cliente que funcione de acuerdo con dicho esquema y obtener una clase lista para usar para crear solicitudes asincr칩nicas: <br><br><pre> <code class="cpp hljs">Request req; req.id = id; req.foo = foo; req.bar = bar; dependencies.sample_client.SomeSampleBarPost(req);</code> </pre><br>  Este enfoque tiene otra ventaja: la documentaci칩n siempre actualizada.  Si un desarrollador intenta de repente usar par치metros que no est치n en la documentaci칩n, recibir치 un error de compilaci칩n. <br><br><h2>  Userver - registro </h2><br>  Nos encanta escribir registros.  Si registra solo la informaci칩n m치s importante, se ejecutar치n varios terabytes de registros por hora.  Por lo tanto, no es sorprendente que nuestro registro tenga sus propios trucos: <br>  * es as칤ncrono (por supuesto :-)); <br>  * Podemos iniciar sesi칩n sin pasar por std :: locale y std :: ostream lentos; <br>  * podemos cambiar el nivel de registro sobre la marcha (sin reiniciar el servicio); <br>  * no ejecutamos c칩digo de usuario si es necesario solo para iniciar sesi칩n. <br><br>  Por ejemplo, durante el funcionamiento normal del microservicio, el nivel de registro se establecer치 en INFO y toda la expresi칩n <br><br><pre> <code class="cpp hljs"> LOG_DEBUG() &lt;&lt; request.id &lt;&lt; <span class="hljs-string"><span class="hljs-string">" is not OK of "</span></span> &lt;&lt; GetSomeInfoFromDb();</code> </pre><br>  No se calcular치.  Incluyendo la llamada a la funci칩n de uso intensivo de recursos GetSomeInfoFromDb () no ocurrir치. <br><br>  Si de repente el servicio comienza a "enga침ar", el desarrollador siempre puede decirle al servicio en funcionamiento: "Inicie sesi칩n en modo DEPURAR".  Y en este caso las entradas "no est치 bien de" comenzar치n a aparecer en los registros, se ejecutar치 la funci칩n GetSomeInfoFromDb (). <br><br><h2>  En lugar de totales </h2><br>  En un art칤culo es imposible contar de inmediato sobre todas las caracter칤sticas y trucos.  Por lo tanto, comenzamos con una breve introducci칩n.  Escriba en los comentarios sobre qu칠 cosas del usuario le interesar칤a aprender y leer. <br><br>  Ahora estamos considerando si publicar el marco en c칩digo abierto.  Si decidimos que s칤, preparar el marco para abrir la fuente requerir치 mucho esfuerzo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/474438/">https://habr.com/ru/post/474438/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../474424/index.html">Entrenamiento combinado: qu칠 es y c칩mo funciona</a></li>
<li><a href="../474426/index.html">La serie animada "C칤rculo matem치tico"</a></li>
<li><a href="../474430/index.html">DevOpsDays Moscow: una conferencia que la comunidad hace para la comunidad</a></li>
<li><a href="../474434/index.html">Propia bot de Telegram para rastrear el tiempo de actividad de sus servidores en Python y Docker</a></li>
<li><a href="../474436/index.html">GitLab debido a la pol칤tica termina la contrataci칩n de ingenieros de Rusia y China</a></li>
<li><a href="../474440/index.html">Dificultades para calcular los ingresos de suscripciones auto-renovables en aplicaciones iOS</a></li>
<li><a href="../474442/index.html">Historia de Irish Life Extension</a></li>
<li><a href="../474444/index.html">5 proyectos de entrenamiento m치s atrevidos para el desarrollador (Layer, Squoosh, Calculator, Website Crawler, Music Player)</a></li>
<li><a href="../474448/index.html">De lo que es capaz el cerebro de un estudiante en el mundo de la inform치tica</a></li>
<li><a href="../474450/index.html">Deje de usar TTL rid칤culamente peque침o para DNS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>