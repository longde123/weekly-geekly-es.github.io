<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë≤üèΩ üë®üèæ‚ÄçüöÄ üöÄ Reserviere Konstanten und Git Hooks in C # üë®üèø‚Äçü§ù‚Äçüë®üèº ü•Ä ü§°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lass mich dir eine Geschichte erz√§hlen. Es waren einmal zwei Entwickler: Sam und Bob. Sie arbeiteten zusammen an einem Projekt, in dem sich eine Daten...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reserviere Konstanten und Git Hooks in C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485218/"><p> Lass mich dir eine Geschichte erz√§hlen.  Es waren einmal zwei Entwickler: Sam und Bob.  Sie arbeiteten zusammen an einem Projekt, in dem sich eine Datenbank befand.  Wenn der Entwickler √Ñnderungen daran vornehmen wollte, musste er eine Datei <code>stepNNN.sql</code> erstellen, wobei NNN eine bestimmte Zahl ist.  Um Konflikte dieser Nummern zwischen verschiedenen Entwicklern zu vermeiden, verwendeten sie einen einfachen Webdienst.  Jeder Entwickler musste vor dem Schreiben der SQL-Datei zu diesem Dienst gehen und eine neue Nummer f√ºr die Schrittdatei reservieren. </p><br><p>  Diesmal mussten sowohl Sam als auch Bob √Ñnderungen an der Datenbank vornehmen.  Sam ging gehorsam zum Gottesdienst und reservierte die Nummer 333. Und Bob verga√ü es zu tun.  Er hat gerade 333 f√ºr seine Schrittdatei verwendet.  Diesmal hat Bob seine √Ñnderungen als erster in das Versionskontrollsystem hochgeladen.  Als Sam zum Fluten bereit war, stellte er fest, dass die Datei <code>step333.sql</code> bereits vorhanden ist.  Er kontaktierte Bob, erkl√§rte ihm, dass die Nummer 333 f√ºr ihn reserviert sei und bat ihn, den Konflikt zu l√∂sen.  Aber Bob antwortete: </p><br><p>  - Alter, mein Code befindet sich bereits im 'Master', eine Reihe von Entwicklern verwenden ihn bereits.  Au√üerdem wurde es bereits in die Produktion abgepumpt.  Repariere einfach alles, was du brauchst. </p><br><p>  Ich hoffe du hast gemerkt was passiert ist.  Die Person, die alle Regeln befolgt hat, wurde bestraft.  Sam musste seine Dateien √§ndern, seine lokale Datenbank bearbeiten usw.  Pers√∂nlich hasse ich solche Situationen.  Mal sehen, wie wir das vermeiden k√∂nnen. </p><a name="habracut"></a><br><h2 id="osnovnaya-ideya">  Hauptidee </h2><br><p>  Wie vermeiden wir solche Dinge?  Was ist, wenn Bob seinen Code nicht eingeben konnte, ohne die entsprechende Nummer im Webdienst zu reservieren? </p><br><p>  Und das k√∂nnen wir tats√§chlich erreichen.  Wir k√∂nnen Git-Hooks verwenden, um vor jedem Commit benutzerdefinierten Code auszuf√ºhren.  Dieser Code √ºberpr√ºft alle √ºbertragenen √Ñnderungen.  Wenn sie eine neue Schrittdatei enthalten, kontaktiert der Code den Webdienst und pr√ºft, ob die Nummer der Schrittdatei f√ºr den aktuellen Entwickler reserviert ist.  Und wenn die Nummer nicht reserviert ist, verhindert der Code das Ausf√ºllen. </p><br><p>  Das ist die Hauptidee.  Kommen wir zu den Details. </p><br><h2 id="git-hooki-na-c35">  Git-Hooks in C # </h2><br><p>  Git schr√§nkt Sie nicht ein, in welchen Sprachen Sie Hooks schreiben sollten.  Als C # -Entwickler w√ºrde ich f√ºr diese Zwecke lieber das vertraute C # verwenden.  Kann ich das machen </p><br><p>  Ja, ich kann.  Die Grundidee habe ich aus <a href="https://medium.com/%40max.hamulyak/using-c-code-in-your-git-hooks-66e507c01a0f" rel="nofollow">diesem Artikel</a> von Max Hamuly√°k √ºbernommen.  Dazu m√ºssen wir das globale <a href="https://github.com/filipw/dotnet-script" rel="nofollow">Dotnet-Script-</a> Tool verwenden.  F√ºr dieses Tool ist ein .NET Core 2.1 + SDK auf dem Entwicklercomputer erforderlich.  Ich halte dies f√ºr eine vern√ºnftige Voraussetzung f√ºr diejenigen, die an der .NET-Entwicklung beteiligt sind.  Die Installation von <code>dotnet-script</code> sehr einfach: </p><br><pre> <code class="bash hljs">&gt; dotnet tool install -g dotnet-script</code> </pre> <br><p>  Jetzt k√∂nnen wir Git-Hooks in C # schreiben.  Wechseln Sie dazu in den Ordner <code>.git\hooks</code> Ihres Projekts und erstellen Sie eine <code>pre-commit</code> Datei (ohne Erweiterung): </p><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#!/usr/bin/env dotnet-script Console.WriteLine("Git hook");</span></span></code> </pre> <br><p>  Von nun an sehen Sie bei jedem <code>git commit</code> den <code>Git hook</code> Text in Ihrer Konsole. </p><br><h2 id="neskolko-obrabotchikov-na-odin-hook">  Mehrere Handler pro Haken </h2><br><p>  Nun, es wurde ein Anfang gemacht.  Jetzt k√∂nnen wir alles in die <code>pre-commit</code> Datei schreiben.  Aber ich mag diese Idee nicht wirklich. </p><br><p>  Erstens ist das Arbeiten mit einer Skriptdatei nicht sehr praktisch.  Ich w√ºrde lieber meine Lieblings-IDE mit all ihren Funktionen verwenden.  Und ich w√§re eher in der Lage, komplexen Code in mehrere Dateien aufzuteilen. </p><br><p>  Aber es gibt noch eine Sache, die ich nicht mag.  Stellen Sie sich folgende Situation vor.  Sie haben ein <code>pre-commit</code> mit einigen √úberpr√ºfungen erstellt.  Sp√§ter mussten Sie jedoch weitere Pr√ºfungen hinzuf√ºgen.  Sie m√ºssen die Datei √∂ffnen, entscheiden, wo Sie Ihren Code einf√ºgen m√∂chten, wie er mit dem alten Code interagiert usw.  Pers√∂nlich ziehe ich es vor, neuen Code zu schreiben und nicht in den alten zu graben. </p><br><p>  Besch√§ftigen wir uns nacheinander mit diesen Problemen. </p><br><h2 id="vyzov-vneshnego-koda">  Externen Code anrufen </h2><br><p>  Das werden wir tun.  Erstellen wir einen separaten Ordner (z. B. <code>gitHookAssemblies</code> ).  In diesen Ordner lege ich die .NET Core-Assembly (z. B. <code>GitHooks</code> ).  Mein Skript in der <code>pre-commit</code> Datei ruft nur eine Methode aus dieser Assembly auf. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RunHooks</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunPreCommitHook</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Git hook from assembly"</span></span>); } }</code> </pre> <br><p>  Ich kann diese Assembly in meiner bevorzugten IDE erstellen und beliebige Tools verwenden. </p><br><p>  Jetzt kann ich in die <code>pre-commit</code> Datei schreiben: </p><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#!/usr/bin/env dotnet-script #r "../../gitHookAssemblies/GitHooks.dll" GitHooks.RunHooks.RunPreCommitHook();</span></span></code> </pre> <br><p>  Gro√üartig, nicht wahr?  Jetzt kann ich nur noch √Ñnderungen in meinem <code>GitHooks</code> Build <code>GitHooks</code> .  Der <code>pre-commit</code> Dateicode wird sich niemals √§ndern.  Wenn ich eine √úberpr√ºfung hinzuf√ºgen muss, √§ndere ich den Code der <code>RunPreCommitHook</code> Methode, <code>RunPreCommitHook</code> die Assembly neu und <code>gitHookAssemblies</code> sie in den <code>gitHookAssemblies</code> Ordner ein.  Und alle! </p><br><p>  Na ja, nicht wirklich. </p><br><h2 id="borba-s-keshem">  Den Cache bek√§mpfen </h2><br><p>  Lassen Sie uns versuchen, unseren Prozess zu verfolgen.  √Ñndern Sie die Nachricht in <code>Console.WriteLine</code> in eine andere, <code>gitHookAssemblies</code> die Assembly neu und <code>gitHookAssemblies</code> das Ergebnis im Ordner <code>gitHookAssemblies</code> .  Rufen Sie danach <code>git commit</code> erneut auf.  Was werden wir sehen?  Alter Beitrag.  Unsere Ver√§nderungen haben sich nicht durchgesetzt.  Warum? </p><br><p>  Lassen Sie Ihr Projekt zur Sicherheit im Ordner <code>c:\project</code> .  Dies bedeutet, dass sich Git-Hook-Skripte im Ordner <code>c:\project\.git\hooks</code> .  Wenn Sie Windows 10 verwenden, <code>c:\Users\&lt;UserName&gt;\AppData\Local\Temp\scripts\c\project\.git\hooks\</code> .  Hier ist <code>&lt;UserName&gt;</code> der Name Ihres aktuellen Benutzers.  Was werden wir hier sehen?  Wenn wir das <code>pre-commit</code> Skript ausf√ºhren, wird in diesem Ordner eine kompilierte Version dieses Skripts erstellt.  Hier finden Sie alle Assemblys, auf die das Skript verweist (einschlie√ülich unserer <code>GitHooks.dll</code> ).  Und im <code>execution-cache</code> Unterordner finden Sie die SHA256-Datei.  Ich kann davon ausgehen, dass es den SHA256-Hash unserer <code>pre-commit</code> Datei enth√§lt.  In dem Moment, in dem wir das Skript ausf√ºhren, vergleicht die Laufzeit den aktuellen Hash der Datei mit dem gespeicherten Hash.  Wenn sie gleich sind, wird die gespeicherte Version des kompilierten Skripts verwendet. </p><br><p>  Dies bedeutet, dass √Ñnderungen an <code>GitHooks.dll</code> niemals in den Cache gelangen und niemals verwendet werden, da wir die <code>pre-commit</code> Datei niemals √§ndern. </p><br><p>  Was k√∂nnen wir in dieser Situation tun?  Reflexion wird uns helfen.  Ich werde mein Skript so umschreiben, dass es Reflection verwendet, anstatt direkt auf die <code>GitHooks</code> Assembly zu <code>GitHooks</code> .  So sieht unsere <code>pre-commit</code> Datei danach aus: </p><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#!/usr/bin/env dotnet-script #r "nuget: System.Runtime.Loader, 4.3.0" using System.IO; using System.Runtime.Loader; var hooksDirectory = Path.Combine(Environment.CurrentDirectory, "gitHookAssemblies"); var assemblyPath = Path.Combine(hooksDirectory, "GitHooks.dll"); var assembly = AssemblyLoadContext.Default.LoadFromAssemblyPath(assemblyPath); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(assembly == null) { Console.WriteLine($"Can't load assembly from '{assemblyPath}'."); } var collectorsType = assembly.GetType("GitHooks.RunHooks"); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(collectorsType == null) { Console.WriteLine("Can't find entry type."); } var method = collectorsType.GetMethod("RunPreCommitHook", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(method == null) { Console.WriteLine("Can't find method for pre-commit hooks."); } method.Invoke(null, new object[0]);</span></span></code> </pre> <br><p>  Jetzt k√∂nnen wir <code>GitHook.dll</code> in unserem <code>gitHookAssemblies</code> Ordner jederzeit aktualisieren und alle √Ñnderungen werden von demselben Skript √ºbernommen.  Das Skript selbst muss nicht mehr ge√§ndert werden. </p><br><p>  Das h√∂rt sich alles gut an, aber es gibt ein weiteres Problem, das gel√∂st werden muss, bevor Sie fortfahren.  Ich spreche von Assemblys, auf die unser Code verweist. </p><br><h2 id="ispolzuemye-sborki">  Gebrauchte Baugruppen </h2><br><p>  Alles funktioniert <code>RunHooks.RunPreCommitHook</code> , solange die <code>RunHooks.RunPreCommitHook</code> Methode die Zeichenfolge nur an die Konsole ausgibt.  Aber ehrlich gesagt ist es normalerweise nicht von Interesse, Text auf dem Bildschirm anzuzeigen.  Wir m√ºssen komplexere Dinge tun.  Und daf√ºr m√ºssen wir andere Assemblys und NuGet-Pakete verwenden.  Mal sehen, wie das geht. </p><br><p>  Ich werde <code>RunHooks.RunPreCommitHook</code> so <code>RunHooks.RunPreCommitHook</code> , dass es das <code>LibGit2Sharp</code> Paket verwendet: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunPreCommitHook</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> repo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Repository(Environment.CurrentDirectory); Console.WriteLine(repo.Info.WorkingDirectory); }</code> </pre> <br><p>  Wenn ich nun <code>git commit</code> ausf√ºhre, bekomme ich folgende Fehlermeldung: </p><br><pre> <code class="plaintext hljs">System.Reflection.TargetInvocationException: Exception has been thrown by the target of an invocation. ---&gt; System.IO.FileLoadException: Could not load file or assembly 'LibGit2Sharp, Version=0.26.0.0, Culture=neutral, PublicKeyToken=7cbde695407f0333'. General Exception (0x80131500)</code> </pre> <br><p>  Nat√ºrlich m√ºssen wir sicherstellen, dass die Assemblys, auf die wir verweisen, geladen werden.  Die Grundidee hier ist.  Ich werde den gesamten Assembler-Code, der zum Ausf√ºhren des Codes erforderlich ist, zusammen mit meiner <code>GitHooks.dll</code> in denselben <code>gitHookAssemblies</code> Ordner <code>GitHooks.dll</code> .  Um alle erforderlichen Assemblys <code>dotnet publish</code> k√∂nnen Sie den Befehl <code>dotnet publish</code> .  In unserem Fall m√ºssen wir <code>LibGit2Sharp.dll</code> und <code>git2-7ce88e6.dll</code> in diesem Ordner platzieren. </p><br><p>  Wir m√ºssen auch das <code>pre-commit</code> √§ndern.  Wir werden den folgenden Code hinzuf√ºgen: </p><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#!/usr/bin/env dotnet-script #r "nuget: System.Runtime.Loader, 4.3.0" using System.IO; using System.Runtime.Loader; var hooksDirectory = Path.Combine(Environment.CurrentDirectory, "gitHookAssemblies"); var assemblyPath = Path.Combine(hooksDirectory, "GitHooks.dll"); AssemblyLoadContext.Default.Resolving += (context, assemblyName) =&gt; { var assemblyPath = Path.Combine(hooksDirectory, $"{assemblyName.Name}.dll"); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(File.Exists(assemblyPath)) { return AssemblyLoadContext.Default.LoadFromAssemblyPath(assemblyPath); } return null; }; ...</span></span></code> </pre> <br><p>  Dieser Code versucht, alle Assemblys zu laden, die die Laufzeit nicht alleine aus dem Ordner <code>gitHookAssemblies</code> . </p><br><p>  Jetzt k√∂nnen Sie <code>git commit</code> ausf√ºhren und es wird ohne Probleme ausgef√ºhrt. </p><br><h2 id="uluchshenie-rasshiryaemosti">  Verbesserung der Erweiterbarkeit </h2><br><p>  Unsere <code>pre-commit</code> Datei ist vollst√§ndig.  Wir m√ºssen es nicht mehr √§ndern.  Wenn Sie jedoch √Ñnderungen vornehmen m√ºssen, m√ºssen wir die <code>RunHooks.RunPreCommitHook</code> Methode √§ndern.  Also haben wir das Problem auf eine andere Ebene verschoben.  Pers√∂nlich w√ºrde ich es vorziehen, eine Art Plugin-System zu haben.  Jedes Mal, wenn ich eine Aktion hinzuf√ºgen muss, bevor ich den Code ausf√ºlle, schreibe ich einfach ein neues Plugin und nichts muss ge√§ndert werden.  Wie schwer ist das zu erreichen? </p><br><p>  Gar nicht so schwer.  Lassen Sie uns <a href="https://docs.microsoft.com/en-us/dotnet/framework/mef/" rel="nofollow">MEF verwenden</a> .  So funktioniert es. </p><br><p>  Zuerst m√ºssen wir eine Schnittstelle f√ºr unsere Hook-Handler definieren: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IPreCommitHook</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Process</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IList&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; args</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre> <br><p>  Jeder Handler kann einige String-Argumente von Git erhalten.  Diese Argumente werden √ºber den Parameter <code>args</code> .  Die <code>Process</code> Methode gibt <code>true</code> wenn sie √Ñnderungen zul√§sst.  Anderenfalls wird <code>false</code> zur√ºckgegeben. </p><br><p>  √Ñhnliche Schnittstellen k√∂nnen f√ºr alle Hooks definiert werden. In diesem Artikel konzentrieren wir uns jedoch nur auf das Pre-Commit. </p><br><p>  Jetzt m√ºssen Sie eine Implementierung dieser Schnittstelle schreiben: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Export(typeof(IPreCommitHook))</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MessageHook</span></span> : <span class="hljs-title"><span class="hljs-title">IPreCommitHook</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Process</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IList&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; args</span></span></span><span class="hljs-function">)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Message hook..."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(args != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Arguments are:"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arg <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> args) { Console.WriteLine(arg); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><p>  Solche Klassen k√∂nnen auf Wunsch in verschiedenen Assemblys erstellt werden.  Es gibt buchst√§blich keine Einschr√§nkungen.  Das <code>Export</code> Attribut stammt aus dem <code>System.ComponentModel.Composition</code> NuGet-Paket. </p><br><p>  Erstellen wir au√üerdem eine <code>IPreCommitHook</code> , mit der alle mit dem <code>Export</code> Attribut gekennzeichneten <code>IPreCommitHook</code> Schnittstellenimplementierungen <code>IPreCommitHook</code> , alle ausgef√ºhrt und Informationen dar√ºber zur√ºckgegeben werden, ob alle das Ausf√ºllen zugelassen haben.  Ich habe meinen Handler in einer separaten <code>GitHooksCollector</code> Assembly <code>GitHooksCollector</code> , aber das ist nicht so wichtig: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Collectors</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PreCommitHooks</span></span> { [ImportMany(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IPreCommitHook))] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IPreCommitHook[] Hooks { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunPreCommitHooks</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IList&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; args, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> directory</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> catalog = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DirectoryCatalog(directory, <span class="hljs-string"><span class="hljs-string">"*Hooks.dll"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompositionContainer(catalog); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PreCommitHooks(); container.ComposeParts(obj); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> success = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hook <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> obj.Hooks) { success &amp;= hook.Process(args); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> success ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> <br><p>  Dieser Code verwendet auch das Paket <code>System.ComponentModel.Composition</code> NuGet.  Zuerst sagen wir, dass wir alle Assemblys <code>*Hooks.dll</code> deren Name mit der <code>*Hooks.dll</code> Vorlage im <code>directory</code> <code>*Hooks.dll</code> .  Sie k√∂nnen hier jede beliebige Vorlage verwenden.  Anschlie√üend sammeln wir alle exportierten Implementierungen der <code>IPreCommitHook</code> Schnittstelle in einem <code>PreCommitHooks</code> Objekt.  Und schlie√ülich starten wir alle Hook-Handler und sammeln das Ergebnis ihrer Ausf√ºhrung. </p><br><p>  Das Letzte, was wir tun m√ºssen, ist eine kleine √Ñnderung an der <code>pre-commit</code> Datei: </p><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#!/usr/bin/env dotnet-script #r "nuget: System.Runtime.Loader, 4.3.0" using System.IO; using System.Runtime.Loader; var hooksDirectory = Path.Combine(Environment.CurrentDirectory, "gitHookAssemblies"); var assemblyPath = Path.Combine(hooksDirectory, "GitHooksCollector.dll"); AssemblyLoadContext.Default.Resolving += (context, assemblyName) =&gt; { var assemblyPath = Path.Combine(hooksDirectory, $"{assemblyName.Name}.dll"); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(File.Exists(assemblyPath)) { return AssemblyLoadContext.Default.LoadFromAssemblyPath(assemblyPath); } return null; }; var assembly = AssemblyLoadContext.Default.LoadFromAssemblyPath(assemblyPath); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(assembly == null) { Console.WriteLine($"Can't load assembly from '{assemblyPath}'."); } var collectorsType = assembly.GetType("GitHooksCollector.Collectors"); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(collectorsType == null) { Console.WriteLine("Can't find collector's type."); } var method = collectorsType.GetMethod("RunPreCommitHooks", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(method == null) { Console.WriteLine("Can't find collector's method for pre-commit hooks."); } int exitCode = (int) method.Invoke(null, new object[] { Args, hooksDirectory }); Environment.Exit(exitCode);</span></span></code> </pre> <br><p>  Und vergessen Sie nicht, alle beteiligten Assemblys in den Ordner <code>gitHookAssemblies</code> zu legen. </p><br><p>  Ja, es war eine lange Einf√ºhrung.  Aber jetzt haben wir eine absolut zuverl√§ssige L√∂sung zum Erstellen von Git-Hook-Handlern in C #.  Wir m√ºssen <code>gitHookAssemblies</code> den Inhalt des Ordners <code>gitHookAssemblies</code> .  Seine Inhalte k√∂nnen in ein Versionskontrollsystem gestellt und so an alle Entwickler verteilt werden. </p><br><p>  In jedem Fall ist es Zeit, dass wir zu unserem urspr√ºnglichen Problem zur√ºckkehren. </p><br><h2 id="web-servis-dlya-rezervirovaniya-konstant">  Webservice f√ºr st√§ndige Reservierung </h2><br><p>  Wir wollten sicherstellen, dass Entwickler bestimmte √Ñnderungen nicht vornehmen k√∂nnen, wenn sie vergessen, die entsprechende Konstante im Webdienst zu reservieren.  Erstellen wir einen einfachen Webdienst, damit Sie damit arbeiten k√∂nnen.  Ich verwende den ASP.NET Core-Webdienst mit Windows-Authentifizierung.  Tats√§chlich gibt es jedoch verschiedene Optionen. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.AspNetCore.Authorization; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.AspNetCore.Mvc; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">ListsService.Controllers</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ListItem</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListItem</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> owner</span></span></span><span class="hljs-function">)</span></span> { Value = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Owner = owner; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T Value { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Owner { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Lists</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;ListItem&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; SqlVersions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;ListItem&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ListItem&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">@"DOMAIN\Iakimov"</span></span>) }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, List&lt;ListItem&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;&gt; AllLists = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, List&lt;ListItem&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;&gt; { {<span class="hljs-number"><span class="hljs-number">1</span></span>, SqlVersions} }; } [Authorize] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ListsController</span></span> : <span class="hljs-title"><span class="hljs-title">Controller</span></span> { [Route(<span class="hljs-string"><span class="hljs-string">"/api/lists/{listId}/ownerOf/{itemId}"</span></span>)] [HttpGet] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IActionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetOwner</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> listId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> itemId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Lists.AllLists.ContainsKey(listId)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NotFound(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item = Lists.AllLists[listId].FirstOrDefault(li =&gt; li.Value == itemId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(item == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NotFound(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Json(item.Owner); } } }</code> </pre> <br><p>  Hier habe ich zu Testzwecken die statische Klasse <code>Lists</code> als Mechanismus zum Speichern von Listen verwendet.  Jede Liste hat eine Ganzzahlkennung.  Jede Liste enth√§lt ganzzahlige Werte und Informationen zu den Personen, f√ºr die diese Werte reserviert sind.  Mit der <code>GetOwner</code> Methode der <code>GetOwner</code> Klasse k√∂nnen Sie die <code>GetOwner</code> der Person <code>GetOwner</code> , f√ºr die dieses Listenelement reserviert ist. </p><br><h2 id="proverka-sql-step-faylov">  √úberpr√ºfen von SQL-Step-Dateien </h2><br><p>  Jetzt k√∂nnen wir pr√ºfen, ob wir eine neue Step-Datei hochladen k√∂nnen oder nicht.  Angenommen, wir speichern Schrittdateien wie folgt.  Der Stammordner unseres Projekts hat ein <code>sql</code> Verzeichnis.  Darin kann jeder Entwickler einen <code>verXXX</code> Ordner erstellen, wobei <code>XXX</code> eine bestimmte Nummer ist, die zuvor f√ºr den Webdienst reserviert werden sollte.  Im <code>verXXX</code> Verzeichnis <code>verXXX</code> m√∂glicherweise eine oder mehrere <code>.sql</code> Dateien, die Anweisungen zum √Ñndern der Datenbank enthalten.  Wir werden hier nicht auf das Problem der Sicherstellung der Ausf√ºhrungsreihenfolge dieser <code>.sql</code> Dateien <code>.sql</code> .  Dies ist f√ºr unsere Diskussion nicht wichtig.  Wir m√∂chten nur Folgendes tun.  Wenn ein Entwickler versucht, eine neue Datei im <code>sql/verXXX</code> , m√ºssen wir pr√ºfen, ob die Konstante <code>XXX</code> f√ºr diesen Entwickler reserviert <code>XXX</code> . </p><br><p>  So sieht der Code f√ºr den entsprechenden Git-Hook-Handler aus: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Export(typeof(IPreCommitHook))</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SqlStepsHook</span></span> : <span class="hljs-title"><span class="hljs-title">IPreCommitHook</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Regex _expr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Regex(<span class="hljs-string"><span class="hljs-string">"\\bver(\\d+)\\b"</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Process</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IList&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> repo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Repository(Environment.CurrentDirectory); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> items = repo.RetrieveStatus() .Where(i =&gt; !i.State.HasFlag(FileStatus.Ignored)) .Where(i =&gt; i.State.HasFlag(FileStatus.NewInIndex)) .Where(i =&gt; i.FilePath.StartsWith(<span class="hljs-string"><span class="hljs-string">@"sql"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> versions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;( items .Select(i =&gt; _expr.Match(i.FilePath)) .Where(m =&gt; m.Success) .Select(m =&gt; m.Groups[<span class="hljs-number"><span class="hljs-number">1</span></span>].Value) .Select(d =&gt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.Parse(d)) ); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> version <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> versions) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ListItemOwnerChecker.DoesCurrentUserOwnListItem(<span class="hljs-number"><span class="hljs-number">1</span></span>, version)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><p>  Hier verwenden wir die <code>Repository</code> Klasse aus dem NuGet-Paket <code>LibGit2Sharp</code> .  Die Variablen <code>items</code> enth√§lt alle neuen Dateien im Git-Index, die sich im Ordner <code>sql</code> .  Sie k√∂nnen das Suchverfahren f√ºr solche Dateien verbessern, wenn Sie dies w√ºnschen.  In der Variablen <code>versions</code> sammeln wir verschiedene Konstanten <code>XXX</code> aus den <code>verXXX</code> Ordnern.  Schlie√ülich √ºberpr√ºft die <code>ListItemOwnerChecker.DoesCurrentUserOwnListItem</code> Methode, ob diese Versionen f√ºr den aktuellen Benutzer im Webdienst in Liste 1 registriert sind. </p><br><p>  Die Implementierung von <code>ListItemOwnerChecker.DoesCurrentUserOwnListItem</code> ziemlich einfach: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ListItemOwnerChecker</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetListItemOwner</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> listId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> itemId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClientHandler { UseDefaultCredentials = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(handler); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> response = client.GetAsync(<span class="hljs-string"><span class="hljs-string">$"https://localhost:44389/api/lists/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{listId}</span></span></span><span class="hljs-string">/ownerOf/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{itemId}</span></span></span><span class="hljs-string">"</span></span>) .ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) .GetAwaiter() .GetResult(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.StatusCode == System.Net.HttpStatusCode.NotFound) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> owner = response.Content .ReadAsStringAsync() .ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) .GetAwaiter() .GetResult(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> JsonConvert.DeserializeObject&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(owner); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoesCurrentUserOwnListItem</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> listId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> itemId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> owner = GetListItemOwner(listId, itemId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (owner == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"There is no item '</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{itemId}</span></span></span><span class="hljs-string">' in the list '</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{listId}</span></span></span><span class="hljs-string">' registered on the lists service."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (owner != WindowsIdentity.GetCurrent().Name) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Item '</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{itemId}</span></span></span><span class="hljs-string">' in the list '</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{listId}</span></span></span><span class="hljs-string">' registered by '</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{owner}</span></span></span><span class="hljs-string">' and you are '</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{WindowsIdentity.GetCurrent().Name}</span></span></span><span class="hljs-string">'."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><p>  Hier fragen wir den Webdienst nach der Kennung des Benutzers, der die angegebene Konstante registriert hat ( <code>GetListItemOwner</code> Methode).  Das Ergebnis wird dann mit dem Namen des aktuellen Windows-Benutzers verglichen.  Dies ist nur eine von vielen M√∂glichkeiten, diese Funktionalit√§t zu implementieren.  Beispielsweise k√∂nnen Sie den Benutzernamen oder die E-Mail-Adresse aus der Git-Konfiguration verwenden. </p><br><p>  Das ist alles.  Kompilieren Sie einfach die entsprechende Assembly und platzieren Sie sie mit all ihren Abh√§ngigkeiten im Ordner <code>gitHookAssemblies</code> .  Und alles wird automatisch funktionieren. </p><br><h2 id="proverka-znacheniy-enum">  √úberpr√ºfen von Aufz√§hlungswerten </h2><br><p>  Es ist toll!  Jetzt kann niemand mehr √Ñnderungen in die Datenbank hochladen, ohne zuvor die entsprechende Konstante im Webdienst f√ºr sich reserviert zu haben.  Eine √§hnliche Methode kann jedoch auch an anderen Orten angewendet werden, an denen eine st√§ndige Reservierung erforderlich ist. </p><br><p>  Zum Beispiel irgendwo in dem Projektcode, den Sie enum haben.  Jeder Entwickler kann neue Mitglieder mit zugewiesenen ganzzahligen Werten hinzuf√ºgen: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Constants { Val1 = <span class="hljs-number"><span class="hljs-number">1</span></span>, Val2 = <span class="hljs-number"><span class="hljs-number">2</span></span>, Val3 = <span class="hljs-number"><span class="hljs-number">3</span></span> }</code> </pre> <br><p>  Wir m√∂chten eine Kollision von Werten f√ºr Mitglieder dieser Aufz√§hlung vermeiden.  Daher ben√∂tigen wir eine Vorreservierung der entsprechenden Konstanten im Web-Service.  Wie schwierig ist es, eine solche Reservierung zu √ºberpr√ºfen? </p><br><p>  Hier ist der Code f√ºr den neuen Git-Hook-Handler: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Export(typeof(IPreCommitHook))</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ConstantValuesHook</span></span> : <span class="hljs-title"><span class="hljs-title">IPreCommitHook</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Process</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IList&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> repo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Repository(Environment.CurrentDirectory); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> constantsItem = repo.RetrieveStatus() .Staged .FirstOrDefault(i =&gt; i.FilePath == <span class="hljs-string"><span class="hljs-string">@"src/GitInteraction/Constants.cs"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (constantsItem == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!constantsItem.State.HasFlag(FileStatus.NewInIndex) &amp;&amp; !constantsItem.State.HasFlag(FileStatus.ModifiedInIndex)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> initialContent = GetInitialContent(repo, constantsItem); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> indexContent = GetIndexContent(repo, constantsItem); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> initialConstantValues = GetConstantValues(initialContent); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> indexConstantValues = GetConstantValues(indexContent); indexConstantValues.ExceptWith(initialConstantValues); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (indexConstantValues.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> version <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> indexConstantValues) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ListItemOwnerChecker.DoesCurrentUserOwnListItem(<span class="hljs-number"><span class="hljs-number">2</span></span>, version)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } ... }</code> </pre> <br><p>  Zuerst pr√ºfen wir, ob die Datei, die unsere Aufz√§hlung enth√§lt, ge√§ndert wurde.  Anschlie√üend extrahieren wir den Inhalt dieser Datei mit den <code>GetIndexContent</code> <code>GetInitialContent</code> und <code>GetIndexContent</code> aus der zuletzt hochgeladenen Version und aus dem Git-Index.  Hier ist ihre Implementierung: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInitialContent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Repository repo, StatusEntry item</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> blob = repo.Head.Tip[item.FilePath]?.Target <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Blob; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (blob == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> content = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StreamReader(blob.GetContentStream(), Encoding.UTF8); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> content.ReadToEnd(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetIndexContent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Repository repo, StatusEntry item</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id = repo.Index[item.FilePath]?.Id; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> itemBlob = repo.Lookup&lt;Blob&gt;(id); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (itemBlob == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> content = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StreamReader(itemBlob.GetContentStream(), Encoding.UTF8); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> content.ReadToEnd(); }</code> </pre> <br><p>            .     <code>GetConstantValues</code> .   <a href="https://github.com/dotnet/roslyn" rel="nofollow"><code>Roslyn</code></a>    .      NuGet- <code>Microsoft.CodeAnalysis.CSharp</code> . </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> ISet&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetConstantValues</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fileContent</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(fileContent)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tree = CSharpSyntaxTree.ParseText(fileContent); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> root = tree.GetCompilationUnitRoot(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> enumDeclaration = root .DescendantNodes() .OfType&lt;EnumDeclarationSyntax&gt;() .FirstOrDefault(e =&gt; e.Identifier.Text == <span class="hljs-string"><span class="hljs-string">"Constants"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(enumDeclaration == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> member <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumDeclaration.Members) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.TryParse(member.EqualsValue.Value.ToString(), <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)) { result.Add(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>   <code>Roslyn</code>     .   ,     ,    <code>Microsoft.CodeAnalysis.CSharp</code>  <code>3.4.0</code> .       <code>gitHookAssemblies</code> ,    ,        .      .  , <code>dotnet-script</code>    <code>Roslyn</code>   .  ,  -   <code>Microsoft.CodeAnalysis.CSharp</code>     .       <code>3.3.1</code> .           NuGet-,  . </p><br><p> , ,   <code>Process</code>   hook`,           Web-. </p><br><h2 id="napravleniya-dalneyshego-razvitiya">    </h2><br><p>  Das ist alles.      .         ,     . </p><br><ol><li><p>    <code>pre-commit</code> ,      ,      <code>.git\hooks</code>    .     <code>--template</code>  <code>git init</code> .   - : </p><br><pre> <code class="bash hljs">git config init.templatedir git_template_dir git init</code> </pre> <br><p>     <code>core.hooksPath</code>  Git,     Git 2.9   : </p><br><pre> <code class="bash hljs">git config core.hooksPath git_template_dir</code> </pre> <br><p>           . </p><br></li><li><p>        <code>dotnet-script</code> .              .NET Core,         . </p><br></li><li><p>       ,    .  ,       <code>gitHookAssemblies</code> ,    ,      . ,  <code>LibGit2Sharp</code>         .    <code>git2-7ce88e6.dll</code> ,   Win-x64.        ,     . </p><br></li><li><p>        Web-.    Windows-,      .   Web-    UI        . </p><br></li><li><p>   ,        Git hook'  .  ,      . </p><br></li></ol><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>            Git hook`   .NET.        ,            . </p><br><p>  ,      .  Viel gl√ºck </p><br><p> PS         <a href="https://github.com/yakimovim/csharp-git-hooks" rel="nofollow">GitHub</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de485218/">https://habr.com/ru/post/de485218/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de485204/index.html">Zur√ºck zum Anfang: Warum Amazon bald wieder mehr als 1 Billion US-Dollar kapitalisiert</a></li>
<li><a href="../de485206/index.html">Wie hat mich Typescript entt√§uscht und ist es das wert?</a></li>
<li><a href="../de485208/index.html">Aufbau einer fehlertoleranten IT-Infrastruktur. Teil 2. Installieren und Konfigurieren des oVirt 4.3-Clusters</a></li>
<li><a href="../de485210/index.html">Einfacher Zombie-Shooter auf Unity</a></li>
<li><a href="../de485214/index.html">CLRium Nr. 7: Praktisch. Seminar, Hausaufgaben mit Verifikation, Mentoring</a></li>
<li><a href="../de485220/index.html">Die Entwicklung der Web Application Firewall: von Firewalls zu maschinell erlernbaren cloudbasierten Sicherheitssystemen</a></li>
<li><a href="../de485222/index.html">Wie kann man mit Meinungsbildnern in China zusammenarbeiten? F√ºnf praktische Tipps</a></li>
<li><a href="../de485224/index.html">Wie f√§llt die Warenlieferung ab dem 1. Januar 2020 unter die Zollgrenze?</a></li>
<li><a href="../de485226/index.html">UI-Entwicklung: Wem kann man zuh√∂ren - sich selbst oder dem Benutzer?</a></li>
<li><a href="../de485228/index.html">Was ist aktives Lernen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>