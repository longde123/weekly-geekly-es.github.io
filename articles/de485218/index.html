<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👲🏽 👨🏾‍🚀 🚀 Reserviere Konstanten und Git Hooks in C # 👨🏿‍🤝‍👨🏼 🥀 🤡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lass mich dir eine Geschichte erzählen. Es waren einmal zwei Entwickler: Sam und Bob. Sie arbeiteten zusammen an einem Projekt, in dem sich eine Daten...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reserviere Konstanten und Git Hooks in C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485218/"><p> Lass mich dir eine Geschichte erzählen.  Es waren einmal zwei Entwickler: Sam und Bob.  Sie arbeiteten zusammen an einem Projekt, in dem sich eine Datenbank befand.  Wenn der Entwickler Änderungen daran vornehmen wollte, musste er eine Datei <code>stepNNN.sql</code> erstellen, wobei NNN eine bestimmte Zahl ist.  Um Konflikte dieser Nummern zwischen verschiedenen Entwicklern zu vermeiden, verwendeten sie einen einfachen Webdienst.  Jeder Entwickler musste vor dem Schreiben der SQL-Datei zu diesem Dienst gehen und eine neue Nummer für die Schrittdatei reservieren. </p><br><p>  Diesmal mussten sowohl Sam als auch Bob Änderungen an der Datenbank vornehmen.  Sam ging gehorsam zum Gottesdienst und reservierte die Nummer 333. Und Bob vergaß es zu tun.  Er hat gerade 333 für seine Schrittdatei verwendet.  Diesmal hat Bob seine Änderungen als erster in das Versionskontrollsystem hochgeladen.  Als Sam zum Fluten bereit war, stellte er fest, dass die Datei <code>step333.sql</code> bereits vorhanden ist.  Er kontaktierte Bob, erklärte ihm, dass die Nummer 333 für ihn reserviert sei und bat ihn, den Konflikt zu lösen.  Aber Bob antwortete: </p><br><p>  - Alter, mein Code befindet sich bereits im 'Master', eine Reihe von Entwicklern verwenden ihn bereits.  Außerdem wurde es bereits in die Produktion abgepumpt.  Repariere einfach alles, was du brauchst. </p><br><p>  Ich hoffe du hast gemerkt was passiert ist.  Die Person, die alle Regeln befolgt hat, wurde bestraft.  Sam musste seine Dateien ändern, seine lokale Datenbank bearbeiten usw.  Persönlich hasse ich solche Situationen.  Mal sehen, wie wir das vermeiden können. </p><a name="habracut"></a><br><h2 id="osnovnaya-ideya">  Hauptidee </h2><br><p>  Wie vermeiden wir solche Dinge?  Was ist, wenn Bob seinen Code nicht eingeben konnte, ohne die entsprechende Nummer im Webdienst zu reservieren? </p><br><p>  Und das können wir tatsächlich erreichen.  Wir können Git-Hooks verwenden, um vor jedem Commit benutzerdefinierten Code auszuführen.  Dieser Code überprüft alle übertragenen Änderungen.  Wenn sie eine neue Schrittdatei enthalten, kontaktiert der Code den Webdienst und prüft, ob die Nummer der Schrittdatei für den aktuellen Entwickler reserviert ist.  Und wenn die Nummer nicht reserviert ist, verhindert der Code das Ausfüllen. </p><br><p>  Das ist die Hauptidee.  Kommen wir zu den Details. </p><br><h2 id="git-hooki-na-c35">  Git-Hooks in C # </h2><br><p>  Git schränkt Sie nicht ein, in welchen Sprachen Sie Hooks schreiben sollten.  Als C # -Entwickler würde ich für diese Zwecke lieber das vertraute C # verwenden.  Kann ich das machen </p><br><p>  Ja, ich kann.  Die Grundidee habe ich aus <a href="https://medium.com/%40max.hamulyak/using-c-code-in-your-git-hooks-66e507c01a0f" rel="nofollow">diesem Artikel</a> von Max Hamulyák übernommen.  Dazu müssen wir das globale <a href="https://github.com/filipw/dotnet-script" rel="nofollow">Dotnet-Script-</a> Tool verwenden.  Für dieses Tool ist ein .NET Core 2.1 + SDK auf dem Entwicklercomputer erforderlich.  Ich halte dies für eine vernünftige Voraussetzung für diejenigen, die an der .NET-Entwicklung beteiligt sind.  Die Installation von <code>dotnet-script</code> sehr einfach: </p><br><pre> <code class="bash hljs">&gt; dotnet tool install -g dotnet-script</code> </pre> <br><p>  Jetzt können wir Git-Hooks in C # schreiben.  Wechseln Sie dazu in den Ordner <code>.git\hooks</code> Ihres Projekts und erstellen Sie eine <code>pre-commit</code> Datei (ohne Erweiterung): </p><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#!/usr/bin/env dotnet-script Console.WriteLine("Git hook");</span></span></code> </pre> <br><p>  Von nun an sehen Sie bei jedem <code>git commit</code> den <code>Git hook</code> Text in Ihrer Konsole. </p><br><h2 id="neskolko-obrabotchikov-na-odin-hook">  Mehrere Handler pro Haken </h2><br><p>  Nun, es wurde ein Anfang gemacht.  Jetzt können wir alles in die <code>pre-commit</code> Datei schreiben.  Aber ich mag diese Idee nicht wirklich. </p><br><p>  Erstens ist das Arbeiten mit einer Skriptdatei nicht sehr praktisch.  Ich würde lieber meine Lieblings-IDE mit all ihren Funktionen verwenden.  Und ich wäre eher in der Lage, komplexen Code in mehrere Dateien aufzuteilen. </p><br><p>  Aber es gibt noch eine Sache, die ich nicht mag.  Stellen Sie sich folgende Situation vor.  Sie haben ein <code>pre-commit</code> mit einigen Überprüfungen erstellt.  Später mussten Sie jedoch weitere Prüfungen hinzufügen.  Sie müssen die Datei öffnen, entscheiden, wo Sie Ihren Code einfügen möchten, wie er mit dem alten Code interagiert usw.  Persönlich ziehe ich es vor, neuen Code zu schreiben und nicht in den alten zu graben. </p><br><p>  Beschäftigen wir uns nacheinander mit diesen Problemen. </p><br><h2 id="vyzov-vneshnego-koda">  Externen Code anrufen </h2><br><p>  Das werden wir tun.  Erstellen wir einen separaten Ordner (z. B. <code>gitHookAssemblies</code> ).  In diesen Ordner lege ich die .NET Core-Assembly (z. B. <code>GitHooks</code> ).  Mein Skript in der <code>pre-commit</code> Datei ruft nur eine Methode aus dieser Assembly auf. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RunHooks</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunPreCommitHook</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Git hook from assembly"</span></span>); } }</code> </pre> <br><p>  Ich kann diese Assembly in meiner bevorzugten IDE erstellen und beliebige Tools verwenden. </p><br><p>  Jetzt kann ich in die <code>pre-commit</code> Datei schreiben: </p><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#!/usr/bin/env dotnet-script #r "../../gitHookAssemblies/GitHooks.dll" GitHooks.RunHooks.RunPreCommitHook();</span></span></code> </pre> <br><p>  Großartig, nicht wahr?  Jetzt kann ich nur noch Änderungen in meinem <code>GitHooks</code> Build <code>GitHooks</code> .  Der <code>pre-commit</code> Dateicode wird sich niemals ändern.  Wenn ich eine Überprüfung hinzufügen muss, ändere ich den Code der <code>RunPreCommitHook</code> Methode, <code>RunPreCommitHook</code> die Assembly neu und <code>gitHookAssemblies</code> sie in den <code>gitHookAssemblies</code> Ordner ein.  Und alle! </p><br><p>  Na ja, nicht wirklich. </p><br><h2 id="borba-s-keshem">  Den Cache bekämpfen </h2><br><p>  Lassen Sie uns versuchen, unseren Prozess zu verfolgen.  Ändern Sie die Nachricht in <code>Console.WriteLine</code> in eine andere, <code>gitHookAssemblies</code> die Assembly neu und <code>gitHookAssemblies</code> das Ergebnis im Ordner <code>gitHookAssemblies</code> .  Rufen Sie danach <code>git commit</code> erneut auf.  Was werden wir sehen?  Alter Beitrag.  Unsere Veränderungen haben sich nicht durchgesetzt.  Warum? </p><br><p>  Lassen Sie Ihr Projekt zur Sicherheit im Ordner <code>c:\project</code> .  Dies bedeutet, dass sich Git-Hook-Skripte im Ordner <code>c:\project\.git\hooks</code> .  Wenn Sie Windows 10 verwenden, <code>c:\Users\&lt;UserName&gt;\AppData\Local\Temp\scripts\c\project\.git\hooks\</code> .  Hier ist <code>&lt;UserName&gt;</code> der Name Ihres aktuellen Benutzers.  Was werden wir hier sehen?  Wenn wir das <code>pre-commit</code> Skript ausführen, wird in diesem Ordner eine kompilierte Version dieses Skripts erstellt.  Hier finden Sie alle Assemblys, auf die das Skript verweist (einschließlich unserer <code>GitHooks.dll</code> ).  Und im <code>execution-cache</code> Unterordner finden Sie die SHA256-Datei.  Ich kann davon ausgehen, dass es den SHA256-Hash unserer <code>pre-commit</code> Datei enthält.  In dem Moment, in dem wir das Skript ausführen, vergleicht die Laufzeit den aktuellen Hash der Datei mit dem gespeicherten Hash.  Wenn sie gleich sind, wird die gespeicherte Version des kompilierten Skripts verwendet. </p><br><p>  Dies bedeutet, dass Änderungen an <code>GitHooks.dll</code> niemals in den Cache gelangen und niemals verwendet werden, da wir die <code>pre-commit</code> Datei niemals ändern. </p><br><p>  Was können wir in dieser Situation tun?  Reflexion wird uns helfen.  Ich werde mein Skript so umschreiben, dass es Reflection verwendet, anstatt direkt auf die <code>GitHooks</code> Assembly zu <code>GitHooks</code> .  So sieht unsere <code>pre-commit</code> Datei danach aus: </p><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#!/usr/bin/env dotnet-script #r "nuget: System.Runtime.Loader, 4.3.0" using System.IO; using System.Runtime.Loader; var hooksDirectory = Path.Combine(Environment.CurrentDirectory, "gitHookAssemblies"); var assemblyPath = Path.Combine(hooksDirectory, "GitHooks.dll"); var assembly = AssemblyLoadContext.Default.LoadFromAssemblyPath(assemblyPath); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(assembly == null) { Console.WriteLine($"Can't load assembly from '{assemblyPath}'."); } var collectorsType = assembly.GetType("GitHooks.RunHooks"); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(collectorsType == null) { Console.WriteLine("Can't find entry type."); } var method = collectorsType.GetMethod("RunPreCommitHook", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(method == null) { Console.WriteLine("Can't find method for pre-commit hooks."); } method.Invoke(null, new object[0]);</span></span></code> </pre> <br><p>  Jetzt können wir <code>GitHook.dll</code> in unserem <code>gitHookAssemblies</code> Ordner jederzeit aktualisieren und alle Änderungen werden von demselben Skript übernommen.  Das Skript selbst muss nicht mehr geändert werden. </p><br><p>  Das hört sich alles gut an, aber es gibt ein weiteres Problem, das gelöst werden muss, bevor Sie fortfahren.  Ich spreche von Assemblys, auf die unser Code verweist. </p><br><h2 id="ispolzuemye-sborki">  Gebrauchte Baugruppen </h2><br><p>  Alles funktioniert <code>RunHooks.RunPreCommitHook</code> , solange die <code>RunHooks.RunPreCommitHook</code> Methode die Zeichenfolge nur an die Konsole ausgibt.  Aber ehrlich gesagt ist es normalerweise nicht von Interesse, Text auf dem Bildschirm anzuzeigen.  Wir müssen komplexere Dinge tun.  Und dafür müssen wir andere Assemblys und NuGet-Pakete verwenden.  Mal sehen, wie das geht. </p><br><p>  Ich werde <code>RunHooks.RunPreCommitHook</code> so <code>RunHooks.RunPreCommitHook</code> , dass es das <code>LibGit2Sharp</code> Paket verwendet: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunPreCommitHook</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> repo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Repository(Environment.CurrentDirectory); Console.WriteLine(repo.Info.WorkingDirectory); }</code> </pre> <br><p>  Wenn ich nun <code>git commit</code> ausführe, bekomme ich folgende Fehlermeldung: </p><br><pre> <code class="plaintext hljs">System.Reflection.TargetInvocationException: Exception has been thrown by the target of an invocation. ---&gt; System.IO.FileLoadException: Could not load file or assembly 'LibGit2Sharp, Version=0.26.0.0, Culture=neutral, PublicKeyToken=7cbde695407f0333'. General Exception (0x80131500)</code> </pre> <br><p>  Natürlich müssen wir sicherstellen, dass die Assemblys, auf die wir verweisen, geladen werden.  Die Grundidee hier ist.  Ich werde den gesamten Assembler-Code, der zum Ausführen des Codes erforderlich ist, zusammen mit meiner <code>GitHooks.dll</code> in denselben <code>gitHookAssemblies</code> Ordner <code>GitHooks.dll</code> .  Um alle erforderlichen Assemblys <code>dotnet publish</code> können Sie den Befehl <code>dotnet publish</code> .  In unserem Fall müssen wir <code>LibGit2Sharp.dll</code> und <code>git2-7ce88e6.dll</code> in diesem Ordner platzieren. </p><br><p>  Wir müssen auch das <code>pre-commit</code> ändern.  Wir werden den folgenden Code hinzufügen: </p><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#!/usr/bin/env dotnet-script #r "nuget: System.Runtime.Loader, 4.3.0" using System.IO; using System.Runtime.Loader; var hooksDirectory = Path.Combine(Environment.CurrentDirectory, "gitHookAssemblies"); var assemblyPath = Path.Combine(hooksDirectory, "GitHooks.dll"); AssemblyLoadContext.Default.Resolving += (context, assemblyName) =&gt; { var assemblyPath = Path.Combine(hooksDirectory, $"{assemblyName.Name}.dll"); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(File.Exists(assemblyPath)) { return AssemblyLoadContext.Default.LoadFromAssemblyPath(assemblyPath); } return null; }; ...</span></span></code> </pre> <br><p>  Dieser Code versucht, alle Assemblys zu laden, die die Laufzeit nicht alleine aus dem Ordner <code>gitHookAssemblies</code> . </p><br><p>  Jetzt können Sie <code>git commit</code> ausführen und es wird ohne Probleme ausgeführt. </p><br><h2 id="uluchshenie-rasshiryaemosti">  Verbesserung der Erweiterbarkeit </h2><br><p>  Unsere <code>pre-commit</code> Datei ist vollständig.  Wir müssen es nicht mehr ändern.  Wenn Sie jedoch Änderungen vornehmen müssen, müssen wir die <code>RunHooks.RunPreCommitHook</code> Methode ändern.  Also haben wir das Problem auf eine andere Ebene verschoben.  Persönlich würde ich es vorziehen, eine Art Plugin-System zu haben.  Jedes Mal, wenn ich eine Aktion hinzufügen muss, bevor ich den Code ausfülle, schreibe ich einfach ein neues Plugin und nichts muss geändert werden.  Wie schwer ist das zu erreichen? </p><br><p>  Gar nicht so schwer.  Lassen Sie uns <a href="https://docs.microsoft.com/en-us/dotnet/framework/mef/" rel="nofollow">MEF verwenden</a> .  So funktioniert es. </p><br><p>  Zuerst müssen wir eine Schnittstelle für unsere Hook-Handler definieren: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IPreCommitHook</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Process</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IList&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; args</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre> <br><p>  Jeder Handler kann einige String-Argumente von Git erhalten.  Diese Argumente werden über den Parameter <code>args</code> .  Die <code>Process</code> Methode gibt <code>true</code> wenn sie Änderungen zulässt.  Anderenfalls wird <code>false</code> zurückgegeben. </p><br><p>  Ähnliche Schnittstellen können für alle Hooks definiert werden. In diesem Artikel konzentrieren wir uns jedoch nur auf das Pre-Commit. </p><br><p>  Jetzt müssen Sie eine Implementierung dieser Schnittstelle schreiben: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Export(typeof(IPreCommitHook))</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MessageHook</span></span> : <span class="hljs-title"><span class="hljs-title">IPreCommitHook</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Process</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IList&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; args</span></span></span><span class="hljs-function">)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Message hook..."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(args != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Arguments are:"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arg <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> args) { Console.WriteLine(arg); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><p>  Solche Klassen können auf Wunsch in verschiedenen Assemblys erstellt werden.  Es gibt buchstäblich keine Einschränkungen.  Das <code>Export</code> Attribut stammt aus dem <code>System.ComponentModel.Composition</code> NuGet-Paket. </p><br><p>  Erstellen wir außerdem eine <code>IPreCommitHook</code> , mit der alle mit dem <code>Export</code> Attribut gekennzeichneten <code>IPreCommitHook</code> Schnittstellenimplementierungen <code>IPreCommitHook</code> , alle ausgeführt und Informationen darüber zurückgegeben werden, ob alle das Ausfüllen zugelassen haben.  Ich habe meinen Handler in einer separaten <code>GitHooksCollector</code> Assembly <code>GitHooksCollector</code> , aber das ist nicht so wichtig: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Collectors</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PreCommitHooks</span></span> { [ImportMany(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IPreCommitHook))] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IPreCommitHook[] Hooks { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunPreCommitHooks</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IList&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; args, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> directory</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> catalog = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DirectoryCatalog(directory, <span class="hljs-string"><span class="hljs-string">"*Hooks.dll"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompositionContainer(catalog); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PreCommitHooks(); container.ComposeParts(obj); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> success = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hook <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> obj.Hooks) { success &amp;= hook.Process(args); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> success ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> <br><p>  Dieser Code verwendet auch das Paket <code>System.ComponentModel.Composition</code> NuGet.  Zuerst sagen wir, dass wir alle Assemblys <code>*Hooks.dll</code> deren Name mit der <code>*Hooks.dll</code> Vorlage im <code>directory</code> <code>*Hooks.dll</code> .  Sie können hier jede beliebige Vorlage verwenden.  Anschließend sammeln wir alle exportierten Implementierungen der <code>IPreCommitHook</code> Schnittstelle in einem <code>PreCommitHooks</code> Objekt.  Und schließlich starten wir alle Hook-Handler und sammeln das Ergebnis ihrer Ausführung. </p><br><p>  Das Letzte, was wir tun müssen, ist eine kleine Änderung an der <code>pre-commit</code> Datei: </p><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#!/usr/bin/env dotnet-script #r "nuget: System.Runtime.Loader, 4.3.0" using System.IO; using System.Runtime.Loader; var hooksDirectory = Path.Combine(Environment.CurrentDirectory, "gitHookAssemblies"); var assemblyPath = Path.Combine(hooksDirectory, "GitHooksCollector.dll"); AssemblyLoadContext.Default.Resolving += (context, assemblyName) =&gt; { var assemblyPath = Path.Combine(hooksDirectory, $"{assemblyName.Name}.dll"); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(File.Exists(assemblyPath)) { return AssemblyLoadContext.Default.LoadFromAssemblyPath(assemblyPath); } return null; }; var assembly = AssemblyLoadContext.Default.LoadFromAssemblyPath(assemblyPath); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(assembly == null) { Console.WriteLine($"Can't load assembly from '{assemblyPath}'."); } var collectorsType = assembly.GetType("GitHooksCollector.Collectors"); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(collectorsType == null) { Console.WriteLine("Can't find collector's type."); } var method = collectorsType.GetMethod("RunPreCommitHooks", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(method == null) { Console.WriteLine("Can't find collector's method for pre-commit hooks."); } int exitCode = (int) method.Invoke(null, new object[] { Args, hooksDirectory }); Environment.Exit(exitCode);</span></span></code> </pre> <br><p>  Und vergessen Sie nicht, alle beteiligten Assemblys in den Ordner <code>gitHookAssemblies</code> zu legen. </p><br><p>  Ja, es war eine lange Einführung.  Aber jetzt haben wir eine absolut zuverlässige Lösung zum Erstellen von Git-Hook-Handlern in C #.  Wir müssen <code>gitHookAssemblies</code> den Inhalt des Ordners <code>gitHookAssemblies</code> .  Seine Inhalte können in ein Versionskontrollsystem gestellt und so an alle Entwickler verteilt werden. </p><br><p>  In jedem Fall ist es Zeit, dass wir zu unserem ursprünglichen Problem zurückkehren. </p><br><h2 id="web-servis-dlya-rezervirovaniya-konstant">  Webservice für ständige Reservierung </h2><br><p>  Wir wollten sicherstellen, dass Entwickler bestimmte Änderungen nicht vornehmen können, wenn sie vergessen, die entsprechende Konstante im Webdienst zu reservieren.  Erstellen wir einen einfachen Webdienst, damit Sie damit arbeiten können.  Ich verwende den ASP.NET Core-Webdienst mit Windows-Authentifizierung.  Tatsächlich gibt es jedoch verschiedene Optionen. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.AspNetCore.Authorization; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.AspNetCore.Mvc; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">ListsService.Controllers</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ListItem</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListItem</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> owner</span></span></span><span class="hljs-function">)</span></span> { Value = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Owner = owner; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T Value { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Owner { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Lists</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;ListItem&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; SqlVersions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;ListItem&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ListItem&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">@"DOMAIN\Iakimov"</span></span>) }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, List&lt;ListItem&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;&gt; AllLists = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, List&lt;ListItem&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;&gt; { {<span class="hljs-number"><span class="hljs-number">1</span></span>, SqlVersions} }; } [Authorize] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ListsController</span></span> : <span class="hljs-title"><span class="hljs-title">Controller</span></span> { [Route(<span class="hljs-string"><span class="hljs-string">"/api/lists/{listId}/ownerOf/{itemId}"</span></span>)] [HttpGet] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IActionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetOwner</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> listId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> itemId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Lists.AllLists.ContainsKey(listId)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NotFound(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item = Lists.AllLists[listId].FirstOrDefault(li =&gt; li.Value == itemId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(item == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NotFound(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Json(item.Owner); } } }</code> </pre> <br><p>  Hier habe ich zu Testzwecken die statische Klasse <code>Lists</code> als Mechanismus zum Speichern von Listen verwendet.  Jede Liste hat eine Ganzzahlkennung.  Jede Liste enthält ganzzahlige Werte und Informationen zu den Personen, für die diese Werte reserviert sind.  Mit der <code>GetOwner</code> Methode der <code>GetOwner</code> Klasse können Sie die <code>GetOwner</code> der Person <code>GetOwner</code> , für die dieses Listenelement reserviert ist. </p><br><h2 id="proverka-sql-step-faylov">  Überprüfen von SQL-Step-Dateien </h2><br><p>  Jetzt können wir prüfen, ob wir eine neue Step-Datei hochladen können oder nicht.  Angenommen, wir speichern Schrittdateien wie folgt.  Der Stammordner unseres Projekts hat ein <code>sql</code> Verzeichnis.  Darin kann jeder Entwickler einen <code>verXXX</code> Ordner erstellen, wobei <code>XXX</code> eine bestimmte Nummer ist, die zuvor für den Webdienst reserviert werden sollte.  Im <code>verXXX</code> Verzeichnis <code>verXXX</code> möglicherweise eine oder mehrere <code>.sql</code> Dateien, die Anweisungen zum Ändern der Datenbank enthalten.  Wir werden hier nicht auf das Problem der Sicherstellung der Ausführungsreihenfolge dieser <code>.sql</code> Dateien <code>.sql</code> .  Dies ist für unsere Diskussion nicht wichtig.  Wir möchten nur Folgendes tun.  Wenn ein Entwickler versucht, eine neue Datei im <code>sql/verXXX</code> , müssen wir prüfen, ob die Konstante <code>XXX</code> für diesen Entwickler reserviert <code>XXX</code> . </p><br><p>  So sieht der Code für den entsprechenden Git-Hook-Handler aus: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Export(typeof(IPreCommitHook))</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SqlStepsHook</span></span> : <span class="hljs-title"><span class="hljs-title">IPreCommitHook</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Regex _expr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Regex(<span class="hljs-string"><span class="hljs-string">"\\bver(\\d+)\\b"</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Process</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IList&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> repo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Repository(Environment.CurrentDirectory); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> items = repo.RetrieveStatus() .Where(i =&gt; !i.State.HasFlag(FileStatus.Ignored)) .Where(i =&gt; i.State.HasFlag(FileStatus.NewInIndex)) .Where(i =&gt; i.FilePath.StartsWith(<span class="hljs-string"><span class="hljs-string">@"sql"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> versions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;( items .Select(i =&gt; _expr.Match(i.FilePath)) .Where(m =&gt; m.Success) .Select(m =&gt; m.Groups[<span class="hljs-number"><span class="hljs-number">1</span></span>].Value) .Select(d =&gt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.Parse(d)) ); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> version <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> versions) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ListItemOwnerChecker.DoesCurrentUserOwnListItem(<span class="hljs-number"><span class="hljs-number">1</span></span>, version)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><p>  Hier verwenden wir die <code>Repository</code> Klasse aus dem NuGet-Paket <code>LibGit2Sharp</code> .  Die Variablen <code>items</code> enthält alle neuen Dateien im Git-Index, die sich im Ordner <code>sql</code> .  Sie können das Suchverfahren für solche Dateien verbessern, wenn Sie dies wünschen.  In der Variablen <code>versions</code> sammeln wir verschiedene Konstanten <code>XXX</code> aus den <code>verXXX</code> Ordnern.  Schließlich überprüft die <code>ListItemOwnerChecker.DoesCurrentUserOwnListItem</code> Methode, ob diese Versionen für den aktuellen Benutzer im Webdienst in Liste 1 registriert sind. </p><br><p>  Die Implementierung von <code>ListItemOwnerChecker.DoesCurrentUserOwnListItem</code> ziemlich einfach: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ListItemOwnerChecker</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetListItemOwner</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> listId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> itemId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClientHandler { UseDefaultCredentials = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(handler); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> response = client.GetAsync(<span class="hljs-string"><span class="hljs-string">$"https://localhost:44389/api/lists/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{listId}</span></span></span><span class="hljs-string">/ownerOf/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{itemId}</span></span></span><span class="hljs-string">"</span></span>) .ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) .GetAwaiter() .GetResult(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.StatusCode == System.Net.HttpStatusCode.NotFound) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> owner = response.Content .ReadAsStringAsync() .ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) .GetAwaiter() .GetResult(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> JsonConvert.DeserializeObject&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(owner); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoesCurrentUserOwnListItem</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> listId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> itemId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> owner = GetListItemOwner(listId, itemId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (owner == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"There is no item '</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{itemId}</span></span></span><span class="hljs-string">' in the list '</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{listId}</span></span></span><span class="hljs-string">' registered on the lists service."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (owner != WindowsIdentity.GetCurrent().Name) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Item '</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{itemId}</span></span></span><span class="hljs-string">' in the list '</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{listId}</span></span></span><span class="hljs-string">' registered by '</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{owner}</span></span></span><span class="hljs-string">' and you are '</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{WindowsIdentity.GetCurrent().Name}</span></span></span><span class="hljs-string">'."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><p>  Hier fragen wir den Webdienst nach der Kennung des Benutzers, der die angegebene Konstante registriert hat ( <code>GetListItemOwner</code> Methode).  Das Ergebnis wird dann mit dem Namen des aktuellen Windows-Benutzers verglichen.  Dies ist nur eine von vielen Möglichkeiten, diese Funktionalität zu implementieren.  Beispielsweise können Sie den Benutzernamen oder die E-Mail-Adresse aus der Git-Konfiguration verwenden. </p><br><p>  Das ist alles.  Kompilieren Sie einfach die entsprechende Assembly und platzieren Sie sie mit all ihren Abhängigkeiten im Ordner <code>gitHookAssemblies</code> .  Und alles wird automatisch funktionieren. </p><br><h2 id="proverka-znacheniy-enum">  Überprüfen von Aufzählungswerten </h2><br><p>  Es ist toll!  Jetzt kann niemand mehr Änderungen in die Datenbank hochladen, ohne zuvor die entsprechende Konstante im Webdienst für sich reserviert zu haben.  Eine ähnliche Methode kann jedoch auch an anderen Orten angewendet werden, an denen eine ständige Reservierung erforderlich ist. </p><br><p>  Zum Beispiel irgendwo in dem Projektcode, den Sie enum haben.  Jeder Entwickler kann neue Mitglieder mit zugewiesenen ganzzahligen Werten hinzufügen: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Constants { Val1 = <span class="hljs-number"><span class="hljs-number">1</span></span>, Val2 = <span class="hljs-number"><span class="hljs-number">2</span></span>, Val3 = <span class="hljs-number"><span class="hljs-number">3</span></span> }</code> </pre> <br><p>  Wir möchten eine Kollision von Werten für Mitglieder dieser Aufzählung vermeiden.  Daher benötigen wir eine Vorreservierung der entsprechenden Konstanten im Web-Service.  Wie schwierig ist es, eine solche Reservierung zu überprüfen? </p><br><p>  Hier ist der Code für den neuen Git-Hook-Handler: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Export(typeof(IPreCommitHook))</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ConstantValuesHook</span></span> : <span class="hljs-title"><span class="hljs-title">IPreCommitHook</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Process</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IList&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> repo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Repository(Environment.CurrentDirectory); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> constantsItem = repo.RetrieveStatus() .Staged .FirstOrDefault(i =&gt; i.FilePath == <span class="hljs-string"><span class="hljs-string">@"src/GitInteraction/Constants.cs"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (constantsItem == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!constantsItem.State.HasFlag(FileStatus.NewInIndex) &amp;&amp; !constantsItem.State.HasFlag(FileStatus.ModifiedInIndex)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> initialContent = GetInitialContent(repo, constantsItem); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> indexContent = GetIndexContent(repo, constantsItem); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> initialConstantValues = GetConstantValues(initialContent); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> indexConstantValues = GetConstantValues(indexContent); indexConstantValues.ExceptWith(initialConstantValues); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (indexConstantValues.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> version <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> indexConstantValues) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ListItemOwnerChecker.DoesCurrentUserOwnListItem(<span class="hljs-number"><span class="hljs-number">2</span></span>, version)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } ... }</code> </pre> <br><p>  Zuerst prüfen wir, ob die Datei, die unsere Aufzählung enthält, geändert wurde.  Anschließend extrahieren wir den Inhalt dieser Datei mit den <code>GetIndexContent</code> <code>GetInitialContent</code> und <code>GetIndexContent</code> aus der zuletzt hochgeladenen Version und aus dem Git-Index.  Hier ist ihre Implementierung: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInitialContent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Repository repo, StatusEntry item</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> blob = repo.Head.Tip[item.FilePath]?.Target <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Blob; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (blob == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> content = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StreamReader(blob.GetContentStream(), Encoding.UTF8); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> content.ReadToEnd(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetIndexContent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Repository repo, StatusEntry item</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id = repo.Index[item.FilePath]?.Id; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> itemBlob = repo.Lookup&lt;Blob&gt;(id); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (itemBlob == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> content = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StreamReader(itemBlob.GetContentStream(), Encoding.UTF8); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> content.ReadToEnd(); }</code> </pre> <br><p>            .     <code>GetConstantValues</code> .   <a href="https://github.com/dotnet/roslyn" rel="nofollow"><code>Roslyn</code></a>    .      NuGet- <code>Microsoft.CodeAnalysis.CSharp</code> . </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> ISet&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetConstantValues</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fileContent</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(fileContent)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tree = CSharpSyntaxTree.ParseText(fileContent); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> root = tree.GetCompilationUnitRoot(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> enumDeclaration = root .DescendantNodes() .OfType&lt;EnumDeclarationSyntax&gt;() .FirstOrDefault(e =&gt; e.Identifier.Text == <span class="hljs-string"><span class="hljs-string">"Constants"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(enumDeclaration == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> member <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumDeclaration.Members) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.TryParse(member.EqualsValue.Value.ToString(), <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)) { result.Add(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>   <code>Roslyn</code>     .   ,     ,    <code>Microsoft.CodeAnalysis.CSharp</code>  <code>3.4.0</code> .       <code>gitHookAssemblies</code> ,    ,        .      .  , <code>dotnet-script</code>    <code>Roslyn</code>   .  ,  -   <code>Microsoft.CodeAnalysis.CSharp</code>     .       <code>3.3.1</code> .           NuGet-,  . </p><br><p> , ,   <code>Process</code>   hook`,           Web-. </p><br><h2 id="napravleniya-dalneyshego-razvitiya">    </h2><br><p>  Das ist alles.      .         ,     . </p><br><ol><li><p>    <code>pre-commit</code> ,      ,      <code>.git\hooks</code>    .     <code>--template</code>  <code>git init</code> .   - : </p><br><pre> <code class="bash hljs">git config init.templatedir git_template_dir git init</code> </pre> <br><p>     <code>core.hooksPath</code>  Git,     Git 2.9   : </p><br><pre> <code class="bash hljs">git config core.hooksPath git_template_dir</code> </pre> <br><p>           . </p><br></li><li><p>        <code>dotnet-script</code> .              .NET Core,         . </p><br></li><li><p>       ,    .  ,       <code>gitHookAssemblies</code> ,    ,      . ,  <code>LibGit2Sharp</code>         .    <code>git2-7ce88e6.dll</code> ,   Win-x64.        ,     . </p><br></li><li><p>        Web-.    Windows-,      .   Web-    UI        . </p><br></li><li><p>   ,        Git hook'  .  ,      . </p><br></li></ol><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>            Git hook`   .NET.        ,            . </p><br><p>  ,      .  Viel glück </p><br><p> PS         <a href="https://github.com/yakimovim/csharp-git-hooks" rel="nofollow">GitHub</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de485218/">https://habr.com/ru/post/de485218/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de485204/index.html">Zurück zum Anfang: Warum Amazon bald wieder mehr als 1 Billion US-Dollar kapitalisiert</a></li>
<li><a href="../de485206/index.html">Wie hat mich Typescript enttäuscht und ist es das wert?</a></li>
<li><a href="../de485208/index.html">Aufbau einer fehlertoleranten IT-Infrastruktur. Teil 2. Installieren und Konfigurieren des oVirt 4.3-Clusters</a></li>
<li><a href="../de485210/index.html">Einfacher Zombie-Shooter auf Unity</a></li>
<li><a href="../de485214/index.html">CLRium Nr. 7: Praktisch. Seminar, Hausaufgaben mit Verifikation, Mentoring</a></li>
<li><a href="../de485220/index.html">Die Entwicklung der Web Application Firewall: von Firewalls zu maschinell erlernbaren cloudbasierten Sicherheitssystemen</a></li>
<li><a href="../de485222/index.html">Wie kann man mit Meinungsbildnern in China zusammenarbeiten? Fünf praktische Tipps</a></li>
<li><a href="../de485224/index.html">Wie fällt die Warenlieferung ab dem 1. Januar 2020 unter die Zollgrenze?</a></li>
<li><a href="../de485226/index.html">UI-Entwicklung: Wem kann man zuhören - sich selbst oder dem Benutzer?</a></li>
<li><a href="../de485228/index.html">Was ist aktives Lernen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>