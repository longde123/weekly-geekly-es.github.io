<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👇🏻 🧛🏽 ♂️ Kategori Ekspresi dalam C ++ 🎅🏾 🐾 👩🏾‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kategori ekspresi, seperti nilai dan nilai , lebih banyak berhubungan dengan konsep-konsep teoretis dasar C ++ daripada aspek praktis penggunaannya. U...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kategori Ekspresi dalam C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441742/"><p>  Kategori ekspresi, seperti <strong>nilai</strong> dan <strong>nilai</strong> , lebih banyak berhubungan dengan konsep-konsep teoretis dasar C ++ daripada aspek praktis penggunaannya.  Untuk alasan ini, banyak programmer bahkan berpengalaman memiliki gagasan yang kabur tentang apa yang mereka maksudkan.  Dalam artikel ini saya akan mencoba menjelaskan arti dari istilah-istilah ini sesederhana mungkin, menipiskan teori dengan contoh-contoh praktis.  Saya akan segera melakukan reservasi: artikel ini tidak berpura-pura memberikan deskripsi yang paling lengkap dan ketat tentang kategori ekspresi, untuk detail saya sarankan menghubungi sumber secara langsung: standar bahasa C ++. </p><a name="habracut"></a><br><blockquote>  Artikel ini akan mengandung cukup banyak istilah bahasa Inggris, ini disebabkan oleh kenyataan bahwa beberapa dari mereka sulit diterjemahkan ke dalam bahasa Rusia, sementara yang lain diterjemahkan dalam sumber yang berbeda dengan cara yang berbeda.  Oleh karena itu, saya akan sering menunjukkan istilah-istilah bahasa Inggris, menyoroti mereka <em>dalam huruf miring</em> . </blockquote><br><h2 id="nemnogo-istorii">  Sedikit sejarah </h2><br><p>  Istilah <strong>lvalue</strong> dan <strong>rvalue</strong> muncul kembali dalam C. Perlu dicatat bahwa kebingungan diletakkan pada terminologi awalnya, karena mereka merujuk pada ekspresi, dan bukan pada nilai.  Secara historis, <strong>nilai</strong> adalah apa yang bisa tersisa dari operator penugasan, dan nilai adalah apa yang hanya bisa <em>benar</em> . </p><br><pre><code class="plaintext hljs">lvalue = rvalue;</code> </pre> <br><p>  Namun, definisi semacam itu agak menyederhanakan dan mengubah esensi.  Standar C89 mendefinisikan <strong>nilai</strong> sebagai <em>pelacak objek</em> , mis.  Objek dengan lokasi memori yang dapat diidentifikasi.  Dengan demikian, segala sesuatu yang tidak sesuai dengan definisi ini dimasukkan dalam kategori nilai. </p><br><h2 id="byarn-speshit-na-pomosch">  Bjarn bergegas untuk menyelamatkan </h2><br><p>  Dalam C ++, terminologi kategori ekspresi telah berkembang cukup kuat, terutama setelah adopsi Standar C ++ 11, yang memperkenalkan konsep tautan nilai dan <em>memindahkan semantik</em> .  Sejarah munculnya terminologi baru secara menarik dijelaskan dalam artikel Straustrup's <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"New" Value Terminology</a> . </p><br><p>  Terminologi baru dan lebih ketat didasarkan pada 2 properti: </p><br><ul><li>  keberadaan identitas ( <em>identitas</em> ) - yaitu, beberapa parameter yang dapat dipahami apakah dua ekspresi merujuk ke entitas yang sama atau tidak (misalnya, alamat dalam memori); </li><li>  kemampuan untuk bergerak ( <em>dapat dipindahkan dari</em> ) - mendukung semantik gerakan. </li></ul><br><p>  Ekspresi yang mengekspresikan identitas digeneralisasi di bawah istilah <strong>glvalue</strong> ( <em>nilai yang digeneralisasi</em> ), ekspresi roaming disebut <strong>rvalue</strong> .  Kombinasi dari dua properti ini telah mengidentifikasi 3 kategori utama ekspresi: </p><br><table><thead><tr><th></th><th>  Punya identitas </th><th>  Tanpa identitas </th></tr></thead><tbody><tr><td>  <strong>Tidak bisa dipindahkan</strong> </td><td>  lvalue </td><td>  - </td></tr><tr><td>  <strong>Bisa dipindahkan</strong> </td><td>  nilai x </td><td>  nilai awal </td></tr></tbody></table><br><p>  Bahkan, Standar C ++ 17 memperkenalkan konsep <em>penyalinan salinan</em> - situasi formalisasi di mana kompiler dapat dan harus menghindari menyalin dan memindahkan objek.  Dalam hal ini, nilai <strong>awal mungkin</strong> tidak perlu dipindahkan.  Detail dan contoh dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Namun, ini tidak mempengaruhi pemahaman tentang skema umum kategori ekspresi. </p><br><p>  Dalam Standar C ++ modern, struktur kategori disajikan dalam bentuk skema seperti itu: </p><br><p><img src="https://habrastorage.org/webt/2r/ut/w5/2rutw544jnidqrhi4cgwnc848xg.png" alt="gambar"></p><br><p>  Mari kita periksa secara umum sifat-sifat kategori, serta ekspresi bahasa yang termasuk dalam masing-masing kategori.  Saya segera mencatat bahwa daftar ekspresi di bawah ini untuk setiap kategori tidak dapat dianggap lengkap, untuk informasi yang lebih akurat dan terperinci, lihat langsung ke Standar C ++. </p><br><h2 id="glvalue">  nilai glv </h2><br><p>  Ekspresi dalam kategori <strong>glvalue</strong> memiliki properti berikut: </p><br><ul><li>  dapat secara implisit dikonversi ke nilai <strong>awal</strong> ; </li><li>  dapat bersifat polimorfik, yaitu, bagi mereka konsep tipe statis dan dinamis masuk akal; </li><li>  tidak dapat bertipe <strong>void</strong> - ini secara langsung mengikuti dari properti yang memiliki identitas, karena untuk ekspresi tipe <strong>batal</strong> tidak ada parameter yang akan membedakannya satu sama lain; </li><li>  dapat memiliki <em>jenis yang tidak lengkap</em> , misalnya, dalam bentuk <em>pernyataan maju</em> (jika diizinkan untuk ekspresi tertentu). </li></ul><br><h2 id="rvalue">  nilai </h2><br><p>  Ekspresi dalam kategori nilai memiliki properti berikut: </p><br><ul><li>  Anda tidak bisa mendapatkan alamat nilai di memori - ini secara langsung mengikuti dari kurangnya properti identitas; </li><li>  tidak dapat berada di sebelah kiri pernyataan penugasan atau gabungan tugas; </li><li>  dapat digunakan untuk menginisialisasi tautan <strong>nilai</strong> konstan atau tautan nilai, sedangkan masa pakai objek meluas hingga masa pakai tautan; </li><li>  jika digunakan sebagai argumen ketika memanggil fungsi yang memiliki 2 versi overload: satu menerima tautan <strong>nilai</strong> konstan dan yang lainnya tautan nilai, maka versi yang menerima tautan nilai dipilih.  Properti inilah yang digunakan untuk mengimplementasikan <em>semantik gerakan</em> : </li></ul><br><pre> <code class="plaintext hljs">class A { public: A() = default; A(const A&amp;) { std::cout &lt;&lt; "A::A(const A&amp;)\n"; } A(A&amp;&amp;) { std::cout &lt;&lt; "A::A(A&amp;&amp;)\n"; } }; ......... A a; A b(a); //  A(const A&amp;) A c(std::move(a)); //  A(A&amp;&amp;)</code> </pre> <br><blockquote>  Secara teknis, A&amp;&amp; adalah nilai <strong>tambah</strong> dan dapat digunakan untuk menginisialisasi referensi <strong>nilai</strong> konstan dan referensi nilai.  Namun berkat properti ini, tidak ada ambiguitas, opsi konstruktor diterima yang menerima referensi nilai. </blockquote><br><h2 id="lvalue">  lvalue </h2><br><p>  Properti: </p><br><ul><li>  semua properti <strong>glvalue</strong> (lihat di atas); </li><li>  Anda dapat mengambil alamatnya (menggunakan operator unary bawaan <code>&amp;</code> ); </li><li>  nilai yang dapat dimodifikasi dapat berada di sisi kiri operator penugasan atau operator penugasan majemuk; </li><li>  dapat digunakan untuk menginisialisasi referensi ke <strong>nilai</strong> (baik konstan dan non-konstan). </li></ul><br><p>  Ekspresi berikut termasuk dalam kategori <strong>nilai</strong> : </p><br><ul><li>  nama variabel, fungsi, atau bidang kelas jenis apa pun.  Bahkan jika variabel adalah referensi nilai, nama variabel ini dalam ekspresi adalah <strong>nilai</strong> ; </li></ul><br><pre> <code class="plaintext hljs">void func() {} ......... auto* func_ptr = &amp;func; // :     auto&amp; func_ref = func; // :     int&amp;&amp; rrn = int(123); auto* pn = &amp;rrn; // :    auto&amp; rn = rrn; // :  lvalue-</code> </pre> <br><ul><li>  memanggil fungsi atau operator kelebihan beban yang mengembalikan referensi <strong>nilai</strong> , atau ekspresi konversi ke jenis referensi <strong>nilai</strong> ; </li><li>  operator penugasan built-in, operator penugasan majemuk ( <code>=</code> , <code>+=</code> , <code>/=</code> , dll.), pra-kenaikan dan pra-penambah bawaan ( <code>++a</code> , <code>--b</code> ), operator dereference pointer bawaan ( <code>*p</code> ); </li><li>  built-in operator akses oleh indeks ( <code>a[n]</code> atau <code>n[a]</code> ), ketika salah satu operan adalah <strong>lvalue</strong> array; </li><li>  memanggil fungsi atau pernyataan kelebihan beban yang mengembalikan referensi nilai ke fungsi; </li><li>  string literal seperti <code>"Hello, world!"</code>  . </li></ul><br><blockquote>  Sebuah string literal berbeda dari semua literal lainnya dalam C ++ tepatnya dalam arti bahwa itu adalah <strong>nilai</strong> (meskipun tidak dapat diubah).  Misalnya, Anda bisa mendapatkan alamatnya: </blockquote><br><pre> <code class="plaintext hljs">auto* p = &amp;”Hello, world!”; //   ,   </code> </pre> <br><h2 id="prvalue">  nilai awal </h2><br><p>  Properti: </p><br><ul><li>  semua nilai properti (lihat di atas); </li><li>  tidak boleh polimorfik: tipe ekspresi statis dan dinamis selalu bertepatan; </li><li>  tidak boleh dari tipe yang tidak lengkap (kecuali untuk tipe <strong>void</strong> , ini akan dibahas di bawah); </li><li>  tidak dapat memiliki tipe abstrak atau menjadi array elemen dari tipe abstrak. </li></ul><br><p>  Ekspresi berikut termasuk dalam kategori nilai <strong>awal</strong> : </p><br><ul><li>  literal (kecuali string), misalnya <code>42</code> , <code>true</code> atau <code>nullptr</code> ; </li><li>  panggilan fungsi atau operator kelebihan beban yang mengembalikan non-referensi ( <code>str.substr(1, 2)</code> , <code>str1 + str2</code> , <code>it++</code> ) atau ekspresi konversi ke tipe non-referensi (misalnya, <code>static_cast&lt;double&gt;(x)</code> , <code>std::string{}</code> , <code>(int)42</code> ); </li><li>  built-in post-increment dan post-decrement ( <code>a++</code> , <code>b--</code> ), operasi matematika built-in ( <code>a + b</code> , <code>a % b</code> , <code>a &amp; b</code> , <code>a &lt;&lt; b</code> , dll.), operasi logis bawaan ( <code>a &amp;&amp; b</code> , <code>a || b</code> <code>!a</code> , dll.), operasi perbandingan ( <code>a &lt; b</code> , <code>a == b</code> , <code>a &gt;= b</code> , dll.), operasi bawaan untuk mengambil alamat ( <code>&amp;a</code> ); </li><li>  penunjuk <strong>ini</strong> ; </li><li>  daftar barang; </li><li>  parameter template atipikal, jika bukan kelas; </li><li>  ekspresi lambda, misalnya <code>[](int x){ return x * x; }</code>  <code>[](int x){ return x * x; }</code> . </li></ul><br><h2 id="xvalue">  nilai x </h2><br><p>  Properti: </p><br><ul><li>  semua nilai properti (lihat di atas); </li><li>  semua properti <strong>glvalue</strong> (lihat di atas). </li></ul><br><p>  Contoh ekspresi <strong>xvalue</strong> : </p><br><ul><li>  memanggil fungsi atau operator <strong>bawaan</strong> yang mengembalikan referensi nilai, misalnya <em>std :: move (x)</em> ; </li></ul><br><blockquote>  dan pada kenyataannya, untuk hasil memanggil <em>std :: move (),</em> Anda tidak bisa mendapatkan alamat di memori atau menginisialisasi tautan ke sana, tetapi pada saat yang sama, ungkapan ini bisa berupa polimorfik: </blockquote><br><pre> <code class="plaintext hljs">struct XA { virtual void f() { std::cout &lt;&lt; "XA::f()\n"; } }; struct XB : public XA { virtual void f() { std::cout &lt;&lt; "XB::f()\n"; } }; XA&amp;&amp; xa = XB(); auto* p = &amp;std::move(xa); //  auto&amp; r = std::move(xa); //  std::move(xa).f(); //  “XB::f()”</code> </pre> <br><ul><li>  built-in operator akses oleh indeks ( <code>a[n]</code> atau <code>n[a]</code> ) ketika salah satu operan adalah array nilai. </li></ul><br><h2 id="nekotorye-osobye-sluchai">  Beberapa kasus khusus </h2><br><h3 id="operator-zapyataya">  Operator koma </h3><br><p>  Untuk operator koma bawaan, kategori ekspresi selalu cocok dengan kategori ekspresi operan kedua. </p><br><pre> <code class="plaintext hljs">int n = 0; auto* pn = &amp;(1, n); // lvalue auto&amp; rn = (1, n); // lvalue 1, n = 2; // lvalue auto* pt = &amp;(1, int(123)); // , rvalue auto&amp; rt = (1, int(123)); // , rvalue</code> </pre> <br><h2 id="vyrazheniya-tipa-void">  Ekspresi kosong </h2><br><p>  Panggilan ke fungsi yang mengembalikan <strong>void</strong> , mengetik ekspresi konversi menjadi <strong>void</strong> , dan melempar pengecualian dianggap <strong>sebagai</strong> ekspresi nilai awal, tetapi mereka tidak dapat digunakan untuk menginisialisasi referensi atau sebagai argumen untuk fungsi. </p><br><h2 id="ternarnyy-operator-sravneniya">  Operator perbandingan ternary </h2><br><p>  Definisi kategori ekspresi <code>a ? b : c</code>  <code>a ? b : c</code> - kasusnya nontrivial, semuanya tergantung pada kategori argumen kedua dan ketiga ( <code>b</code> dan <code>c</code> ): </p><br><ul><li>  jika <code>b</code> atau <code>c</code> bertipe <strong>batal</strong> , maka kategori dan tipe seluruh ekspresi berhubungan dengan kategori dan tipe argumen lainnya.  Jika kedua argumen bertipe <strong>batal</strong> , maka hasilnya adalah nilai <strong>awal dari</strong> tipe <strong>batal</strong> ; </li><li>  jika <code>b</code> dan <code>c</code> adalah <strong>glvalue dari</strong> tipe yang sama, maka hasilnya adalah <strong>glvalue dari</strong> tipe yang sama; </li><li>  dalam kasus lain, hasilnya adalah nilai awal. </li></ul><br><p>  Untuk operator ternary, sejumlah aturan didefinisikan sesuai dengan konversi tersirat yang dapat diterapkan pada argumen b dan c, tetapi ini agak di luar <strong><em>cakupan artikel, jika</em></strong> Anda tertarik, saya sarankan <strong><em>merujuk ke bagian Operator Bersyarat [expr.cond]</em></strong> dari Standar. </p><br><pre> <code class="plaintext hljs">int n = 1; int v = (1 &gt; 2) ? throw 1 : n; // lvalue, .. throw   void,    n ((1 &lt; 2) ? n : v) = 2; //  lvalue,  ,   ((1 &lt; 2) ? n : int(123)) = 2; //   , ..    prvalue</code> </pre> <br><h2 id="obrascheniya-k-polyam-i-metodam-klassov-i-struktur">  Referensi ke bidang dan metode kelas dan struktur </h2><br><p>  Untuk ekspresi bentuk <code>am</code> dan <code>p-&gt;m</code> (di sini kita berbicara tentang operator bawaan <code>-&gt;</code> ), aturan berikut ini berlaku: </p><br><ul><li>  jika <code>m</code> adalah elemen enumerasi atau metode kelas non-statis, maka seluruh ekspresi dianggap sebagai nilai <strong>awal</strong> (meskipun tautan tidak dapat diinisialisasi dengan ekspresi seperti itu); </li><li>  jika <code>a</code> adalah nilai dan <code>m</code> adalah bidang non-statis dari tipe non-referensi, maka seluruh ekspresi termasuk dalam kategori nilai <strong>x</strong> ; </li><li>  kalau tidak, itu adalah <strong>nilai</strong> . </li></ul><br><p>  Untuk pointer ke anggota kelas ( <code>a.*mp</code> dan <code>p-&gt;*mp</code> ), aturannya serupa: </p><br><ul><li>  jika <code>mp</code> adalah pointer ke metode kelas, maka seluruh ekspresi dianggap sebagai <strong>nilai</strong> ; </li><li>  jika <code>a</code> adalah nilai, dan <code>mp</code> adalah penunjuk ke bidang data, maka seluruh ekspresi merujuk ke nilai <strong>x</strong> ; </li><li>  kalau tidak, itu adalah <strong>nilai</strong> . </li></ul><br><h2 id="bitovye-polya">  Bidang bit </h2><br><p>  Bidang bit adalah alat yang mudah digunakan untuk pemrograman tingkat rendah, namun implementasinya agak berada di luar struktur umum kategori ekspresi.  Misalnya, panggilan ke bidang bit tampaknya merupakan <strong>nilai tinggi</strong> , <strong>karena</strong> mungkin ada di sisi kiri operator penugasan.  Pada saat yang sama, itu tidak akan berfungsi untuk mengambil alamat bidang bit atau menginisialisasi tautan yang tidak konstan oleh mereka.  Anda dapat menginisialisasi referensi konstan ke bidang bit, tetapi salinan sementara objek akan dibuat: </p><br><blockquote>  <strong><em>Bidang-bit [class.bit]</em></strong> <br>  <em>Jika penginisialisasi untuk referensi tipe const T &amp; adalah nilai yang merujuk ke bidang-bit, referensi terikat ke sementara yang diinisialisasi untuk menyimpan nilai bidang-bit;</em>  <em>referensi tidak terikat ke bidang bit secara langsung.</em> </blockquote><br><pre> <code class="plaintext hljs">struct BF { int f:3; }; BF b; bf = 1; // OK auto* pb = &amp;b.f; //  auto&amp; rb = bf; // </code> </pre> <br><h2 id="vmesto-zaklyucheniya">  Alih-alih sebuah kesimpulan </h2><br><p>  Seperti yang saya sebutkan dalam pendahuluan, uraian di atas tidak mengklaim lengkap, tetapi hanya memberikan gambaran umum tentang kategori ekspresi.  Pandangan ini akan memberikan pemahaman yang sedikit lebih baik dari paragraf Standar dan pesan kesalahan kompiler. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id441742/">https://habr.com/ru/post/id441742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id441728/index.html">Menyimpulkan kontes online untuk game Blotto</a></li>
<li><a href="../id441732/index.html">Catatan Biorobot</a></li>
<li><a href="../id441736/index.html">Otomatis konversi file kata ke format lain</a></li>
<li><a href="../id441738/index.html">Dasar-Dasar Termoakustik</a></li>
<li><a href="../id441740/index.html">Habra megarating: artikel terbaik dan statistik Habr selama 12 tahun. Bagian 1/2</a></li>
<li><a href="../id441744/index.html">Mendapatkan tautan ke profil Vk dari hasil SearchFace menggunakan Python (tapi ini tidak akurat)</a></li>
<li><a href="../id441750/index.html">Proyek di CodeFest: Bagaimana seorang manajer dapat bertahan di dunia yang selalu berubah?</a></li>
<li><a href="../id441752/index.html">ZTE menunjukkan jam tangan smartphone α</a></li>
<li><a href="../id441754/index.html">Kisah sukses Kubernetes dalam produksi. Bagian 10: Reddit</a></li>
<li><a href="../id441756/index.html">Untuk platform Rusia PC industri, mereka mengambil prosesor Baikal-T1 dan Alt OS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>