<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕹️ 🍸 🕳️ Patche mich, wenn du kannst: wie wir die Produktion debuggen. Teil 1 🧛🏼 👩🏿‍🤝‍👨🏻 ⏬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="UPD: Der zweite Teil des Artikels ist fertig . 

 Hallo Habr! Ich heiße Alexander Izmailov. Bei Badoo leite ich ein Team von Release-Ingenieuren. Ich ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Patche mich, wenn du kannst: wie wir die Produktion debuggen. Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/413503/">  <b>UPD: Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zweite Teil des Artikels</a> ist fertig <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.</a></b> <br><br>  Hallo Habr!  Ich heiße Alexander Izmailov.  Bei Badoo leite ich ein Team von Release-Ingenieuren.  Ich weiß, dass Sie in vielen Unternehmen Codeänderungen an eine speziell geschulte Person senden können, die sie sich ansieht und dort hinzufügt, wo sie sollten (zum Beispiel passiert genau dies mit Git-Code).  Und ich möchte darüber sprechen, wie wir diesen Prozess mit uns automatisiert haben. <br><br>  Meine Geschichte wird aus zwei Teilen bestehen.  In diesem Teil werde ich darüber sprechen, was wir mit dem neuen System erreichen wollten, wie es in seiner ersten Version aussah und warum wir es am Ende wiederholen mussten.  Im zweiten Teil werden wir über den Prozess der Neugestaltung des Systems und über die unerwarteten Boni sprechen, die es uns gebracht hat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kz/rx/oo/kzrxooelulor2_oeeddmmd-o7xg.png" height="500"></div><br>  Bild: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quelle</a> <br><a name="habracut"></a><br>  Es war einmal in unserem Unternehmen, dass jeder seine Änderungen direkt an der Hauptniederlassung vornehmen und sie mit eigenen Händen auslegen konnte.  Zu diesem Zweck haben wir ein spezielles MSCP-Dienstprogramm geschrieben, das sehr primitiv funktioniert: Es hat die Änderungen von einem Computer auf einen anderen kopiert und die erforderlichen Rechte festgelegt. <br><br>  Im Laufe der Zeit wuchs das Unternehmen - und wir mussten über die Automatisierung von Prozessen nachdenken, einschließlich des Prozesses, kleine Änderungen vorzunehmen.  So kamen wir auf die Idee, ein Patch-System zu erstellen.  Zunächst wollten wir, dass jeder Entwickler seine Änderungen an Git senden und auf Servern auslegen kann.  Unsererseits forderten wir, dass ein anderer Entwickler die Änderungen überprüft und sie mit der Aufgabe unseres Bug-Tracking-Systems verknüpft (wir verwenden Jira). <br><br><div class="spoiler">  <b class="spoiler_title">Patch Collector 6000</b> <div class="spoiler_text">  Ich muss sagen, dass diese Anforderungen nicht alle Entwickler angesprochen haben.  Es schien uns, dass es keine Sache ist, ein paar Minuten für die Erstellung einer Aufgabe aufzuwenden, aber für uns würde dies eine bewusstere Verwendung des Systems bedeuten.  Aber die Entwickler begannen sich zu widersetzen und argumentierten, dass das Auslegen der Änderungen um ein Vielfaches weniger Zeit in Anspruch nimmt als das Erstellen eines neuen Tickets.  Infolgedessen haben wir immer noch "universelle" Aufgaben, an die Hunderte von Patches angehängt sind. <br><br>  Darüber hinaus wurde das System mit dem Ziel konzipiert, dringende Probleme zu beheben, und es kann schwierig sein, um drei Uhr morgens einen Prüfer für einen Patch zu finden. <br></div></div><br><h2>  Was brauchen wir </h2><br>  <s>Ja, nur ein Licht im Fenster ...</s> Unser Problem könnte bedingt in zwei Teile unterteilt werden: Wir brauchten eine Möglichkeit, Änderungen am Repository zu akzeptieren und diese Änderungen zu planen. <br><br>  Wir haben die erste Frage schnell genug entschieden: Wir haben ein Formular erstellt, an das wir unsere Änderungen anhängen und die Details (Prüfer und Aufgabe) angeben müssen. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kl/yk/gt/klykgtwk7gjwahm7bittw-jrf58.png" height="500"></div><br><br>  Auf der zweiten Seite können Sie die Änderungen sehen, ablehnen oder akzeptieren. <br><br><img src="https://habrastorage.org/webt/dd/2k/s8/dd2ks86twqszir9vu7jsaiu6cym.png"><br><br>  Nach der Bestätigung fielen die Änderungen in den Master. <br><br>  Zweite Frage: Wie können diese Änderungen schnell an Server übermittelt werden?  Heutzutage verwenden viele die kontinuierliche Integration, und es könnte die Arbeit gut machen, wenn unsere „ehrlichen“ Builds und Layouts nicht so viel Zeit in Anspruch nehmen würden. <br><br><h3>  Faire Versammlung </h3><br>  Unsere Montage war schon immer ziemlich kompliziert.  Das allgemeine Prinzip war folgendes: In einem separaten Verzeichnis haben wir die Dateien so angeordnet, wie sie sich auf den Zielservern befinden würden.  Dann haben wir diesen Status in einem Snapshot (Snapshot des Dateisystems) gespeichert und angelegt. <br><br>  Wir haben den PHP-Code in das Verzeichnis gestellt, das wir unverändert aus dem Repository entnommen haben, und die generierten Dateien (z. B. Vorlagen und Übersetzungen) hinzugefügt.  Wir haben die Statik separat angelegt.  Dies ist ein ziemlich komplizierter Prozess, und Sie können ihm einen ganzen Artikel widmen. Als Ergebnis hatten wir eine Versionsübersicht, um Dateilinks für Benutzer zu generieren, die zusammen mit dem Hauptcode abgereist sind. <br><br>  Als nächstes musste der Status des Verzeichnisses irgendwo gespeichert werden.  Zu diesem Zweck haben wir ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blockgerät verwendet</a> , das wir als Schleife bezeichnet haben.  Das gesamte Verzeichnis wurde auf ein leeres Gerät kopiert, das dann archiviert und an separate „Hauptserver“ geliefert wurde.  Von diesen Servern haben wir im Verlauf des Layouts Archive genommen.  Jedes Archiv hatte eine Größe von 200 MB, und beim Auspacken wogen die Loops 1 GB.  Wir haben ungefähr fünf Minuten gebraucht, um ohne statische Aufladung zu bauen. <br><br><h3>  Faires Layout </h3><br>  Zuerst mussten wir das Archiv an die Zielserver liefern.  Wir haben Tausende von ihnen, daher war die Lieferfrage für uns immer ein großes Problem: Wir haben mehrere Plattformen (Rechenzentren) und auf den „dicksten“ tausend Servern einen Code.  Bei dem Versuch, eine bessere Leistung (minimale Zeit und Ressourcen) zu erzielen, haben wir verschiedene Methoden ausprobiert: von einem einfachen SCP bis zu Torrents.  Am Ende haben wir uns für UFTP entschieden.  Die Methode war schnell (bei gutem Wetter - eine Minute), aber leider nicht problemlos.  In regelmäßigen Abständen brach etwas zusammen und wir mussten zu den Admins und Networkern laufen. <br><br>  Nachdem sich das Archiv (irgendwie) auf den Servern befunden hat, muss es entpackt werden, was ebenfalls nicht kostenlos ist.  Dieses Verfahren scheint besonders teuer zu sein, wenn Sie sich daran erinnern, dass es tausende Male ausgeführt wird, wenn auch parallel auf verschiedenen Maschinen. <br><br><h3>  Keine Montage </h3><br>  Das ehrliche Posten von Änderungen nahm also viel Zeit in Anspruch, und die Liefergeschwindigkeit war für das Patch-System sehr wichtig, da davon ausgegangen wurde, dass sie verwendet werden würden, wenn etwas nicht mehr funktioniert.  Daher kehrten wir zu der Idee zurück, MSCP zu verwenden: schnell und einfach zu implementieren.  Nachdem die Änderungen im Assistenten angezeigt wurden, konnten die geänderten Dateien auf einer separaten Seite nacheinander zerlegt werden. <br><br><img src="https://habrastorage.org/webt/6v/xr/zh/6vxrzhjqovb_itqx7g8caopp5zq.png"><br><br><h2>  Es lebt </h2><br>  Das System funktioniert.  Trotz einiger Unzufriedenheit mit den kleinen Dingen konnten die Entwickler ihre Arbeit erledigen, und dafür brauchten sie keinen Zugriff auf den Master oder auf die Server. <br><br>  Aber natürlich hatten wir bei dieser Layoutmethode Probleme.  Einige waren vorhersehbar, andere haben wir sogar irgendwie entschieden.  Die meisten davon betrafen die parallele Bearbeitung von Dateien. <br><br><h3>  Ein Patch für mehrere Dateien </h3><br>  Ein Beispiel für ein vorhersehbares Problem.  Neue Dateien wurden der Reihe nach angelegt.  Was tun, wenn Sie mehrere Dateien ändern müssen und die Änderungen damit zusammenhängen?  Zum Beispiel möchte ich eine neue Methode in eine Datei einfügen und sie sofort in anderen verwenden.  Solange es keinen Loopback mit Methoden gibt (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gegenseitige Rekursion</a> ), reicht es aus, sich die richtige Reihenfolge des Dateilayouts zu merken. <br><br><div class="spoiler">  <b class="spoiler_title">Ehrliche Entscheidung</b> <div class="spoiler_text">  Um das Problem zu lösen, mussten wir mehrere Dateien atomar ersetzen.  Bei einer einzelnen Datei ist die Lösung bekannt: Sie müssen die Dateioperation umbenennen.  Angenommen, wir haben eine Datei F und müssen deren Inhalt ersetzen.  Erstellen Sie dazu eine TMP-Datei, schreiben Sie die erforderlichen Informationen hinein und benennen Sie TMP F um. <br><br>  Lassen Sie uns die Aufgabe komplizieren.  Angenommen, wir haben ein Verzeichnis D und müssen dessen Inhalt ersetzen.  Der Umbenennungsvorgang hilft uns nicht, da er ein nicht leeres Verzeichnis nicht ersetzen kann.  Es gibt jedoch eine Problemumgehung: Sie können das D-Verzeichnis vorab durch einen sogenannten symbolischen Link (Symlink) ersetzen.  Dann liegt der Inhalt selbst an einer anderen Stelle, beispielsweise im Verzeichnis D_1, und D ist eine Verknüpfung zu D_1.  In dem Moment, in dem ein Austausch erforderlich ist, wird der neue Inhalt in das Verzeichnis D_2 geschrieben, zu dem ein neuer TMP-Link erstellt wird.  Jetzt funktioniert das Umbenennen von TMP D, da dieser Vorgang auf Links angewendet werden kann. <br><br>  Diese Lösung sieht angemessen aus: Sie können das gesamte Verzeichnis mit dem Code ändern, alte Dateien kopieren und neue darüber schreiben.  Das Problem ist, dass das Kopieren des gesamten Codes lang und teuer ist.  Sie können nur das Unterverzeichnis ersetzen, in dem sich die Dateien geändert haben, aber dann müssen alle Unterverzeichnisse mit dem Code Links sein, da wir das gefüllte Verzeichnis während des Layoutprozesses nicht durch irgendetwas ersetzen können.  Diese Lösung sieht nicht nur sehr kompliziert aus - Sie müssen auch einige Einschränkungen hinzufügen, damit die beiden Prozesse nicht gleichzeitig dasselbe Verzeichnis oder Verzeichnis und seine Unterverzeichnisse ändern können. <br></div></div><br>  Infolgedessen konnten wir keine technische Lösung finden, aber wir haben herausgefunden, wie wir das Leben ein wenig vereinfachen können: Wir haben das Layout mehrerer Dateien mit einer Aktion in der Benutzeroberfläche erstellt.  Der Entwickler hat das Layout der Dateien festgelegt und vom System bereitgestellt. <br><br><h3>  Mehrere Patches pro Datei </h3><br>  Es ist schwieriger, wenn es eine Datei gibt und es mehrere Entwickler gibt, die sie ändern möchten.  Wir haben den ersten Patch angewendet, ihn aber nicht zerlegt.  Zu diesem Zeitpunkt kommt der zweite Patch an und wird aufgefordert, ihn zu zerlegen.  Was zu tun ist?  Noch interessanter, wenn der zweite Patch angewendet wird und wir in diesem Moment gebeten werden, den ersten zu zerlegen. <br><br>  Wahrscheinlich müssen wir klarstellen, dass wir immer nur die neueste Version des Assistenten bereitgestellt haben.  Andernfalls können andere Probleme auftreten.  Legen Sie beispielsweise die alte Version über die neue. <br><br>  Wir haben keine wirklich gute Lösung für dieses Problem gefunden.  Wir haben den Entwicklern den Unterschied zwischen dem, was sie angelegt haben, und dem, was sich zu einem bestimmten Zeitpunkt auf den Maschinen befindet, gezeigt, aber dies hat nicht immer funktioniert.  Zum Beispiel könnte es viele Änderungen geben, und der Entwickler könnte es eilig haben oder einfach nur faul sein (alles kann passieren). <br><br><h3>  Viele Patches, und jeder ändert die gleichen Dateien </h3><br>  Dies ist die schlechteste Option, auf die Sie nicht einmal eingehen möchten.  Wenn die Änderungen mehrerer Entwickler mehrere derselben Dateien betrafen, konnte unser Patch-System nicht besonders helfen - es blieb auf die Aufmerksamkeit der Entwickler und ihre Fähigkeit, miteinander zu kommunizieren, angewiesen.  Theoretisch ist es jedoch durchaus möglich, "Fisch" zu erhalten, wenn in einer beliebigen Reihenfolge des Layouts irgendwann auf dem Server teilweise fehlerhafter Code vorhanden ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n-/qn/fs/n-qnfsbv6myxc8d7oav-yhyitu4.png"></div><br>  Bild: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quelle</a> <br><br><h3>  Eisenprobleme </h3><br>  Ein weiteres Problem trat auf, als aus irgendeinem Grund einer der Server nicht mehr verfügbar war.  Wir hatten einen Mechanismus zum Ausschließen solcher Server aus dem Layout, der recht gut funktionierte.  Schwierigkeiten traten nach ihrer Rückkehr zum Dienst auf.  Tatsache ist, dass die Versionen von Konfigurationen und Code auf funktionierenden Servern bei uns überprüft werden (es gibt eine ganze Überwachungsabteilung!) Und wir stellen sicher, dass alle Versionen auf dem neuesten Stand sind, wenn der Server wieder in Betrieb ist.  Wir hatten jedoch keine Versionierung für Patches - wir haben nur neue Dateien in den aktuellen Code kopiert. <br><br>  Wir haben keine genaue Methode zur Versionierung der zerlegten Patches gefunden, aber wir haben versucht, das Problem durch Problemumgehungen zu lösen.  Beispiel: rsync von einem benachbarten Computer am Ende des Layoutprozesses.  Aber irgendwie konnten wir es irgendwie nicht überprüfen. <br><br>  Wir haben verschiedene Lösungen für dieses Problem durchgearbeitet, z. B. wollten wir Patches auch auf den "Hauptservern" anwenden (es ist wichtig zu bedenken, dass wir die gepackte Version bereitstellen, dh wir müssen den Patch anwenden und die Version zurückpacken), aber die Implementierung war ziemlich schwierig. <br><br><h2>  Ein Löffel Honig </h2><br>  Neben den Problemen gab es aber auch positive Aspekte. <br><br>  Erstens haben die Entwickler schnell herausgefunden, dass Sie mithilfe des Patch-Systems nicht nur Probleme beheben, sondern manchmal auch neue Funktionen hochladen können, beispielsweise wenn Sie diese dringend benötigen.  Wie in jedem Unternehmen haben wir höhere Gewalt.  Wenn wir jedoch früher einen außergewöhnlichen Build erstellen mussten, von dem Tester und Release-Ingenieure abgelenkt waren, konnte der Entwickler jetzt einige Änderungen selbst zerlegen. <br><br>  Zweitens wurde eine spezielle Person mit Rechten nicht mehr benötigt, um etwas zu reparieren.  Jeder Entwickler selbst könnte seine Änderungen veröffentlichen.  Dies ist jedoch noch nicht alles: Builds sind im Allgemeinen einfacher geworden. Jetzt wurden die Probleme in kritische und solche unterteilt, die mithilfe von Patches behoben werden können.  Dies ermöglichte es, weniger häufig zurückzusetzen und schneller zu entscheiden, ob wir erfolgreich waren. <br><br>  Einfach ausgedrückt, wir mochten das System und gewannen an Popularität.  Wir haben weiter versucht, es zu verbessern, aber mit den beschriebenen Problemen mussten wir noch ein paar Jahre leben.  Und wie wir sie entschieden haben, wie das System jetzt funktioniert und wie wir die Neujahrsfeiertage während des Aktualisierungsprozesses fast beendet haben, werde ich im zweiten Teil des Artikels erzählen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de413503/">https://habr.com/ru/post/de413503/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de413491/index.html">Food Design Digest, Mai 2018</a></li>
<li><a href="../de413493/index.html">Public Key-Infrastruktur (Fortsetzung): Zertifizierungsstelle basierend auf OpenSSL und SQLite3</a></li>
<li><a href="../de413495/index.html">Schnelle Bereitstellung oder Bereitstellung des Frontends in 15 Minuten</a></li>
<li><a href="../de413499/index.html">Eröffnung eines gemeinsamen Masterstudiengangs bei JetBrains und ITMO</a></li>
<li><a href="../de413501/index.html">Das mit React verbrachte Jahr: Schlussfolgerungen und Empfehlungen</a></li>
<li><a href="../de413505/index.html">2 Freikarten für den In-Memory Computing Summit Europe</a></li>
<li><a href="../de413511/index.html">Auswahl eines 3D-Scanners für die Industrie. Maxim Zhuravlev. Bericht auf der Top 3D Expo 2018</a></li>
<li><a href="../de413513/index.html">"Vergessene" Kommunikationsstandards: WiMAX, CDMA, ALOHAnet und andere</a></li>
<li><a href="../de413515/index.html">Doh in Bildern</a></li>
<li><a href="../de413517/index.html">Was ist das IT-Produktivitätsparadoxon und wie hilft die Cloud, es zu lösen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>