<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÖüèæ ‚õπüèæ ü§Ø Convers√£o de malha poligonal em s√≥lido B-Rep: detalhes de algoritmo e amostras de c√≥digo C ++ ü§õüèø ‚òéÔ∏è üö∂üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A representa√ß√£o de limite (B-rep) √© o principal m√©todo de representa√ß√£o de objetos modelados na maioria dos n√∫cleos geom√©tricos, incluindo nosso n√∫cle...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Convers√£o de malha poligonal em s√≥lido B-Rep: detalhes de algoritmo e amostras de c√≥digo C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465237/">  A representa√ß√£o de limite (B-rep) √© o principal m√©todo de representa√ß√£o de objetos modelados na maioria dos n√∫cleos geom√©tricos, incluindo nosso n√∫cleo C3D Modeler.  Os principais algoritmos que editam modelos, como aplicar opera√ß√µes de filete, executar opera√ß√µes de corte e obter proje√ß√µes planas, exigem a precis√£o de representa√ß√µes B-rep.  A crescente variedade de dados 3D em formatos poligonais torna a tarefa de transforma√ß√£o de modelo de pol√≠gonos em representa√ß√£o de limites cada vez mais relevante.  Como resultado, desenvolvemos um novo SDK, o C3D B-Shaper, que faz parte do nosso C3D Toolkit. <br><br><img src="https://habrastorage.org/webt/jt/2y/jv/jt2yjvnxfahxck-a1poawxfx8vc.png" alt="imagem"><br><a name="habracut"></a><br>  Usar um algoritmo de triangula√ß√£o (conhecido como mosaico) na representa√ß√£o dos limites de um modelo √© relativamente f√°cil.  A constru√ß√£o de representa√ß√µes poligonais (em mosaico) √© √∫til para fins de visualiza√ß√£o e para c√°lculos geom√©tricos. <br><br>  A transforma√ß√£o reversa - da representa√ß√£o poligonal para B-rep - enfrenta, no entanto, uma s√©rie de quest√µes relacionadas √† complexidade no reconhecimento de diferentes tipos de superf√≠cies, incluindo as de forma livre.  Al√©m disso, h√° o problema de ru√≠do nos modelos poligonais que aparecem normalmente como resultado da digitaliza√ß√£o em 3D. <br><br>  O processo geral pelo qual o C3D B-Shaper transforma os modelos dos formatos poligonal em B-rep consiste em tr√™s est√°gios: segmenta√ß√£o, reconstru√ß√£o de superf√≠cies e constru√ß√£o do modelo b-rep.  O processo de transforma√ß√£o √© iterativo: se por algum motivo os usu√°rios n√£o estiverem satisfeitos com os resultados, as corre√ß√µes poder√£o ser feitas durante os est√°gios de segmenta√ß√£o e reconstru√ß√£o da superf√≠cie. <br><br><img src="https://habrastorage.org/webt/qx/wf/jp/qxwfjpqgfavnukkhjusspnjdzjg.png" alt="imagem"><br>  <i>Transformando uma representa√ß√£o poligonal em um rep-B</i> <br><br>  Antes de iniciar o processo de transforma√ß√£o b-rep, no entanto, melhoramos a qualidade da malha poligonal de origem aplicando as seguintes corre√ß√µes: coordene as dire√ß√µes dos normais nos pol√≠gonos adjacentes;  eliminar furos;  e aplique algoritmos de suaviza√ß√£o a fontes de malha ruidosas, se houver. <br><br><h1>  <font color="#00B2FF">Segmenta√ß√£o do modelo poligonal</font> </h1><br>  O primeiro est√°gio da transforma√ß√£o √© segmentar o modelo poligonal.  Classificamos o pol√≠gono da malha em subconjuntos (segmentos).  As informa√ß√µes sobre as normais em cada v√©rtice da malha possibilitam realizar uma segmenta√ß√£o de primeira ordem e realizar a divis√£o inicial da malha, al√©m de classificar as √°reas como planas ou altamente curvas.  A divis√£o inicial da malha √© baseada na defini√ß√£o de arestas "afiadas".  Essas s√£o as arestas entre dois pol√≠gonos triangulares em que o √¢ngulo entre suas normais m√©dias excede um valor predefinido. <br><br>  Uma segmenta√ß√£o de segunda ordem analisa a malha com base em sua curvatura principal, suficiente para classificar superf√≠cies elementares.  Ao calcular curvaturas em v√©rtices de malha, usamos os resultados do trabalho de Meyer (Mark Meyer, Mathieu Desbrun, Peter Schroder e Alan H. Barr, "Operadores de Geometria Diferencial Discreta para 2 Manifolds Triangulares", Visualiza√ß√£o e Matem√°tica III, 2003) na defini√ß√£o de um operador diferencial discreto para regi√µes trianguladas: um conjunto de v√©rtices adjacentes (relacionados a um determinado v√©rtice por uma aresta) √© considerado para cada v√©rtice inicial da malha.  Em seguida, um operador discreto <i>K</i> √© calculado para o v√©rtice.  Com base no operador, as curvaturas normais, m√©dias <i>K <sub>H</sub></i> e Gaussian <i>K <sub>G</sub></i> s√£o definidas no v√©rtice da malha. <br><br><img src="https://habrastorage.org/webt/rz/ni/kf/rznikfmo-7jumijuvqo4pjgmurs.png" alt="imagem"><br>  <i>Definindo operadores diferenciais discretos para regi√µes trianguladas</i> <br><br>  Dessa forma, o tensor da curvatura √© calculado para cada v√©rtice da malha, a partir do qual os valores da curvatura principal <i>K <sub>1</sub></i> e <i>K <sub>2</sub></i> e as dire√ß√µes da curvatura principal s√£o extra√≠dos. <br><br>  Os v√©rtices da malha s√£o classificados pelos valores de suas principais curvaturas <i>K <sub>1</sub></i> e <i>K <sub>2</sub></i> e depois s√£o calculados para eles.  O algoritmo de classifica√ß√£o de v√©rtices √© baseado em m√©dias k, isto √©, minimizando o desvio total quadr√°tico dos pontos de agrupamento em rela√ß√£o aos centros dos agrupamentos.  A sa√≠da resultante do algoritmo cont√©m um v√©rtice de malha associado a um cluster <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi><mi>i</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.569ex" height="2.057ex" viewBox="0 -780.1 1106 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/465237/&amp;usg=ALkJrhheflG877TTU1lyCo1dcho6-Um-sA#MJMATHI-43" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/465237/&amp;usg=ALkJrhheflG877TTU1lyCo1dcho6-Um-sA#MJMATHI-69" x="760" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>C</mi><mi>i</mi></math></span></span><script type="math/tex" id="MathJax-Element-1"> Ci </script>  e um par de curvaturas (centro de cluster - L. Guillaume, "Segmenta√ß√£o de malha triangular baseada em tensor de curvatura com retifica√ß√£o de limites", Proceedings Computer Graphics International (CGI), 2004). <br><br><img src="https://habrastorage.org/webt/rr/sf/zg/rrsfzgnpnkdjbk6tkaj2huigmno.png" alt="imagem"><br>  <i>Classifica√ß√£o de v√©rtices de malha poligonal no espa√ßo da curvatura</i> <br><br>  Quando terminamos de classificar os v√©rtices da malha poligonal, passamos a classificar os pol√≠gonos.  Para iniciar esse procedimento, escolhemos um pol√≠gono triangular cuja curvatura pode ser considerada totalmente definida.  √â aquele cujos tr√™s v√©rtices est√£o em um √∫nico cluster ou possui dois v√©rtices em uma aresta afiada.  O pol√≠gono √© rotulado como um novo segmento e se torna o ponto de partida para um procedimento recursivo que expande o segmento: para cada pol√≠gono triangular, os pol√≠gonos adjacentes s√£o considerados desde que a borda entre eles n√£o seja "n√≠tida".  Quando um v√©rtice de pol√≠gono adjacente, oposto a uma aresta comum, est√° em uma aresta aguda ou pertence ao mesmo cluster, o pol√≠gono √© adicionado ao segmento.  O processo √© repetido at√© que todos os pol√≠gonos que comp√µem a malha se foram. <br><br><img src="https://habrastorage.org/webt/dm/19/to/dm19tosiw5tu-_p97ufs380khyy.png" alt="imagem"><br>  <i>Segmenta√ß√£o de malha poligonal</i> <br><br>  Ap√≥s a conclus√£o do procedimento de cria√ß√£o de segmento, outro algoritmo une segmentos adjacentes para eliminar a segmenta√ß√£o excessiva da malha. <br><br><h1>  <font color="#00B2FF">Reconhecimento de tipo de superf√≠cie</font> </h1><br>  O segundo est√°gio √© o reconhecimento de superf√≠cie.  Cada segmento deve ser aproximado por uma superf√≠cie com uma precis√£o determinada pelo sistema ou pelos usu√°rios. <br><br>  Em primeiro lugar, os principais valores de curvatura dos segmentos s√£o usados ‚Äã‚Äãpara determinar se √© poss√≠vel descrever a forma do segmento por uma das seguintes superf√≠cies elementares: <br><br><ul><li>  Plano: <i>k <sub>1</sub></i> = <i>k <sub>2</sub></i> = 0 </li><li>  Esfera: <i>k <sub>1</sub></i> = <i>k <sub>2</sub></i> = <i>K</i> &gt; 0 </li><li>  Cilindro: <i>k <sub>1</sub></i> = <i>K</i> &gt; 0, <i>k <sub>2</sub></i> = 0 </li><li>  Cone: <i>k <sub>1</sub></i> ‚àà [ <i>a</i> , <i>b</i> ], <i>k <sub>2</sub></i> = 0 </li><li>  Tor√≥ide: <i>k <sub>1</sub></i> = <i>K</i> , <i>k <sub>2</sub></i> ‚àà [ <i>a</i> , <i>b</i> ] </li></ul><br>  Para criar superf√≠cies elementares, ajustamos objetos geom√©tricos simples em conjuntos de pontos usando o algoritmo apropriado.  Por exemplo, para ajustar um c√≠rculo e uma esfera a um conjunto de pontos, √© usado o m√©todo dos m√≠nimos quadrados;  para ajustar um plano, a an√°lise de componentes principais √© usada.  O sistema garante que cada superf√≠cie reconstru√≠da esteja relacionada a um segmento dentro de uma precis√£o predefinida de reconhecimento. <br><br>  A figura abaixo ilustra superf√≠cies reconhecidas por cor: os planos s√£o mostrados em azul, os cilindros s√£o em vermelho, as esferas em verde, os cones em amarelo e os tor√≥ides em violeta. <br><br><img src="https://habrastorage.org/webt/az/z_/jh/azz_jhkz6xkn0ffe8z95dhrfzum.png" alt="imagem"><br>  <i>Malha poligonal de origem (esquerda) e malha segmentada (direita) com segmentos de superf√≠cie reconhecidos</i> <br><br>  Se nenhuma superf√≠cie elementar √© capaz de descrever o segmento, o sistema tenta reconhecer uma superf√≠cie de extrus√£o ou uma superf√≠cie de revolu√ß√£o. <br><br>  Quando o sistema finalmente falha em encontrar uma superf√≠cie anal√≠tica para descrever a forma do segmento, uma superf√≠cie NURBS √© criada para ele. <br><br><h1>  <font color="#00B2FF">Cria√ß√£o de modelo B-rep</font> </h1><br>  O est√°gio final da transforma√ß√£o √© criar o modelo B-rep com base na segmenta√ß√£o e nos dados de superf√≠cie reconstru√≠dos.  Um gr√°fico de adjac√™ncia √© criado a partir das regi√µes segmentadas para representar a topologia do modelo e forma a base para a cria√ß√£o do modelo B-rep resultante.  Os modelos B-rep s√£o montados em um modo totalmente autom√°tico, em contraste com os est√°gios anteriores: <br><br><ul><li>  As arestas B-rep s√£o criadas a partir de curvas de interse√ß√£o de superf√≠cies reconstru√≠das adjacentes </li><li>  As faces B-rep s√£o constru√≠das por superf√≠cies reconhecidas delimitadas e arestas B-rep </li></ul><br>  No entanto, nem sempre √© poss√≠vel criar um shell com a topologia correta.  Por exemplo, considere duas superf√≠cies como um cilindro e um plano que s√£o quase tangentes um ao outro no espa√ßo.  Devido √† toler√¢ncia especificada para as superf√≠cies reconstru√≠das, elas podem n√£o se cruzar.  Como resultado, o shell criado pode ter defeitos.  Os usu√°rios podem eliminar defeitos corrigindo os par√¢metros da superf√≠cie. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/UPasZTasOps" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h1>  <font color="#00B2FF">Tipos de modelos poligonais</font> </h1><br>  Existem in√∫meras fontes de modelos poligonais dispon√≠veis on-line: <br><br><ul><li>  Cat√°logos e bancos de dados on-line oferecem modelos 3D em formatos poligonais como STL, VRML e OBJ do 3D Warehouse, Cults 3D e assim por diante </li><li>  Arquivos resultantes da digitaliza√ß√£o 3D </li><li>  Sa√≠da da otimiza√ß√£o topol√≥gica de modelos usando algoritmos CAE </li></ul><br>  Os modelos poligonais dessas fontes podem ser divididos em dois grupos: modelos que foram triangulados (em malha) a partir de objetos B-rep e todos os outros modelos.  Um par de caracter√≠sticas espec√≠ficas para o primeiro grupo √© a aus√™ncia de ru√≠do de malha poligonal e o dom√≠nio das superf√≠cies anal√≠ticas.  Isso significa que os modelos do primeiro grupo podem ser facilmente transformados em b-reps no modo totalmente automatizado ou com o m√≠nimo esfor√ßo do usu√°rio. <br><br>  As malhas poligonais dos modelos no segundo grupo t√™m ru√≠do, cont√™m superf√≠cies org√¢nicas e, portanto, s√£o mais propensas a exigir a participa√ß√£o interativa dos usu√°rios. <br><br>  Assim, fornecemos dois modos de opera√ß√£o do C3D B-Shape, totalmente autom√°ticos e interativos.  Os usu√°rios podem alternar entre os modos de reconhecimento e gerenciar os tipos de superf√≠cie durante o processo de reconstru√ß√£o.  A sele√ß√£o de um modo pode depender da finalidade de realizar a transforma√ß√£o: os usu√°rios podem √†s vezes desconsiderar a conectividade topol√≥gica do shell resultante ou sua corre√ß√£o geral.  Geralmente, esse √© o caso ao otimizar a exibi√ß√£o em aplicativos BIM, nos quais os usu√°rios est√£o adicionando elementos internos personalizados ao modelo de arquitetura. <br><br>  Por outro lado, as tarefas de engenharia reversa requerem a c√≥pia mais precisa poss√≠vel dos modelos de origem, para que o modelo resultante tenha uma topologia correta.  Portanto, √© necess√°rio predefinir a precis√£o da, por exemplo, coaxialidade dos cilindros ou a tang√™ncia de duas superf√≠cies.  Nestes casos, a participa√ß√£o dos usu√°rios no processo de transforma√ß√£o √© crucial. <br><br>  A transforma√ß√£o autom√°tica do C3D B-Shaper emprega as seguintes fun√ß√µes que usam como dados de entrada as configura√ß√µes de malha e transforma√ß√£o de origem: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">MbResultType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertMeshToShell</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( MbMesh &amp; mesh, MbFaceShell *&amp; shell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MbMeshProcessorValues &amp; params )</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">MbResultType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertCollectionToShell</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( MbCollection &amp; collection, MbFaceShell *&amp; shell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MbMeshProcessorValues &amp; params )</span></span></span></span>;</code> </pre> <br>  Uma das configura√ß√µes de transforma√ß√£o √© um valor de precis√£o de reconhecimento que define a toler√¢ncia m√°xima para dist√¢ncias entre v√©rtices de segmento e superf√≠cies reconhecidas.  A precis√£o pode ser absoluta ou relativa.  Ao usar a precis√£o relativa, os desvios das faces dos corpos de malha s√£o medidos em rela√ß√£o ao tamanho do modelo. <br><br>  A classe de interface MbMesh Processor oferece op√ß√µes avan√ßadas para gerenciar a segmenta√ß√£o e reconhecimento de superf√≠cies: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MbMeshProcessor</span></span></span><span class="hljs-class"> {</span></span> .. <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// Mesh rectification. void SetUseMeshSmoothing( bool useSmoothing ); // Mesh segmentation management. const MbCollection &amp; GetSegmentedMesh(); MbResultType SegmentMesh( bool createSurfaces = true ); void ResetSegmentation(); void UniteSegments( size_t firstSegmentIdx, size_t secondSegmentIdx ); MbResultType SegmentMeshBySeparators( const std::vector&lt;std::vector&lt;uint&gt;&gt; &amp; sep ); // Surface recognition management. void FitSurfaceToSegment( size_t idxSegment ); void FitSurfaceToSegment( size_t idxSegment, MbeSpaceType surfaceType ); const MbSurface * GetSegmentSurface( size_t idxSegment ) const; // B-rep shell construction. MbResultType CreateBRepShell( MbFaceShell *&amp; pShell ); .. }</span></span></code> </pre> <br>  Por exemplo, para corrigir os resultados da segmenta√ß√£o autom√°tica, o C3D B-Shaper oferece ferramentas para mesclar e dividir segmentos e assim por diante.  Os usu√°rios podem ajustar superf√≠cies de tipos espec√≠ficos no segmento selecionado, bem como modificar os par√¢metros de superf√≠cies reconhecidas. <br><br><h1>  <font color="#00B2FF">Sum√°rio</font> </h1><br>  O resultado dos algoritmos de transforma√ß√£o do C3D B-Shaper √© ilustrado pelas figuras abaixo, nas quais um modelo 3D complexo √© transformado com sucesso de sua representa√ß√£o de malha poligonal em um s√≥lido de representa√ß√£o de limite. <br><br><img src="https://habrastorage.org/webt/om/i7/zw/omi7zwcrrc3qzdvyfkvzphvsyra.png" alt="imagem"><br><br><img src="https://habrastorage.org/webt/is/zt/nw/isztnwvohh4t9nzgj4pusg9awek.png" alt="imagem"><br>  <i>Malha poligonal (esquerda) e modelo B-rep (direita) convertidos com o B-Shaper C3D</i> <br><br>  Nosso objetivo √© criar um poderoso SDK para transformar modelos de poligonal em B-rep, e assim o desenvolvimento do C3D B-Shaper continua.  Algumas das coisas em que estamos trabalhando incluem o avan√ßo dos algoritmos de segmenta√ß√£o autom√°tica, o desenvolvimento de ferramentas para edi√ß√£o de segmenta√ß√£o, o aprimoramento da constru√ß√£o de superf√≠cies NURBS de forma livre e a melhoria da qualidade dos conjuntos de shell B-rep. <br><br>  Os clientes que usam o kernel geom√©trico C3D tamb√©m s√£o um fator que impulsiona o desenvolvimento do C3D B-Shaper. <br><br>  Os desenvolvedores s√£o convidados a testar o C3D B-Shaper como parte do C3D Toolkit ou como um componente independente. <br><br> <a href="" rel="nofollow"><img src="https://habrastorage.org/webt/k8/za/vg/k8zavgo-xihodwssql3y-aqlmam.jpeg"></a>  Por Andrey Tumanin, L√≠der de Desenvolvimento de Software da C3D Labs </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt465237/">https://habr.com/ru/post/pt465237/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt465217/index.html">Acronis True Image 2020: Novos esquemas de replica√ß√£o e prote√ß√£o aprimorada</a></li>
<li><a href="../pt465221/index.html">Como os registros em 1C podem parecer na presen√ßa de OOP</a></li>
<li><a href="../pt465223/index.html">Como fazer uso pr√°tico da seguran√ßa do papel ou por que precisamos de conformidade com 152-–§–ó e PCI DSS em uma nuvem</a></li>
<li><a href="../pt465227/index.html">Realidade Aumentada no Varejo Online</a></li>
<li><a href="../pt465229/index.html">"Consultor +": mudan√ßa no fluxo de material. Fontes, estilos, alinhamento de texto com python</a></li>
<li><a href="../pt465239/index.html">Venha e pegue livros em ingl√™s</a></li>
<li><a href="../pt465241/index.html">Meu s√©timo dia com o Haiku: listagem, varredura, rede</a></li>
<li><a href="../pt465245/index.html">Veja a interface "atrav√©s dos olhos do designer": sobre a intera√ß√£o do front-end com o designer</a></li>
<li><a href="../pt465247/index.html">Angular No√ß√µes b√°sicas sobre @Input, @Output e EventEmitter</a></li>
<li><a href="../pt465249/index.html">Palestra de Richard Stallman no Polit√©cnico de Moscou. Agosto 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>