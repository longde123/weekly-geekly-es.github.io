<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüöí ‚úîÔ∏è ‚ôªÔ∏è ref locaux et ref renvoie en C #: pi√®ges de performance üß¶ ü§î üåæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="D√®s le d√©but, C # a pris en charge le passage d'arguments par valeur ou par r√©f√©rence. Mais avant la version 7, le compilateur C # ne supportait qu'un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ref locaux et ref renvoie en C #: pi√®ges de performance</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/423061/">  D√®s le d√©but, C # a pris en charge le passage d'arguments par valeur ou par r√©f√©rence.  Mais avant la version 7, le compilateur C # ne supportait qu'une seule fa√ßon de renvoyer une valeur √† partir d'une m√©thode (ou d'une propri√©t√©) - retour par valeur.  En C # 7, la situation a chang√© avec l'introduction de deux nouvelles fonctionnalit√©s: ref return et ref local.  En savoir plus sur eux et leurs performances - sous la coupe. <br><br><img src="https://habrastorage.org/webt/gi/7e/dd/gi7eddufiqnmiqtmtby4nrkxclw.jpeg"><a name="habracut"></a><br><br><h2>  Raisons </h2><br>  Il existe de nombreuses diff√©rences entre les tableaux et les autres collections en termes d'ex√©cution de langage commun.  D√®s le d√©but, les baies prises en charge par CLR peuvent √™tre consid√©r√©es comme des fonctionnalit√©s int√©gr√©es.  L'environnement CLR et le compilateur JIT peuvent fonctionner avec des tableaux, et ils ont √©galement une autre fonctionnalit√©: l'indexeur de tableaux renvoie des √©l√©ments par r√©f√©rence, et non par valeur. <br><br>  Pour le d√©montrer, nous devrons nous tourner vers la m√©thode interdite - utilisez le type de valeur mutable: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Mutable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _x; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Mutable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span> =&gt; _x = x; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> X =&gt; _x; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IncrementX</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _x++; } } [Test] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckMutability</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ma = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] {<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mutable(<span class="hljs-number"><span class="hljs-number">1</span></span>)}; ma[<span class="hljs-number"><span class="hljs-number">0</span></span>].IncrementX(); <span class="hljs-comment"><span class="hljs-comment">// X has been changed! Assert.That(ma[0].X, Is.EqualTo(2)); var ml = new List&lt;Mutable&gt; {new Mutable(1)}; ml[0].IncrementX(); // X hasn't been changed! Assert.That(ml[0].X, Is.EqualTo(1)); }</span></span></code> </pre> <br>  Les tests r√©ussiront car l'indexeur de tableaux est tr√®s diff√©rent de l'indexeur de listes. <br><br>  Le compilateur C # donne une instruction sp√©ciale √† l'indexeur de tableau - ldelema, qui renvoie un lien g√©r√© vers un √©l√©ment de ce tableau.  Essentiellement, un indexeur de tableau renvoie un √©l√©ment par r√©f√©rence.  Cependant, List ne peut pas se comporter de la m√™me mani√®re, car en C # il n'√©tait pas possible * de renvoyer un alias d'√©tat interne.  Par cons√©quent, l'indexeur List retourne un √©l√©ment par valeur, c'est-√†-dire qu'il renvoie une copie de cet √©l√©ment. <br><br>  * Comme nous le verrons bient√¥t, l'indexeur List ne peut toujours pas renvoyer un √©l√©ment par r√©f√©rence. <br><br>  Cela signifie que ma [0] .IncrementX () appelle la m√©thode qui modifie le premier √©l√©ment du tableau, tandis que ml [0] .IncrementX () appelle la m√©thode qui modifie la copie de l'√©l√©ment sans affecter la liste d'origine. <br><br><h2>  Valeurs de retour et variables locales de r√©f√©rence: principes de base </h2><br>  La signification de ces fonctions est tr√®s simple: d√©clarer la valeur de r√©f√©rence retourn√©e vous permet de renvoyer l'alias d'une variable existante, et la variable locale de r√©f√©rence peut stocker un tel alias. <br><br>  1. Un exemple simple: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefLocalsAndRefReturnsBasics</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] array = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// Capture an alias to the first element into a local ref int first = ref array[0]; first = 42; Assert.That(array[0], Is.EqualTo(42)); // Local function that returns the first element by ref ref int GetByRef(int[] a) =&gt; ref a[0]; // Weird syntax: the result of a function call is assignable GetByRef(array) = -1; Assert.That(array[0], Is.EqualTo(-1)); }</span></span></code> </pre> <br>  2. Valeurs de r√©f√©rence retourn√©es et modificateur en lecture seule <br><br>  La valeur de r√©f√©rence renvoy√©e peut renvoyer l'alias du champ d'instance, et √† partir de la version 7.2 de C #, vous pouvez renvoyer l'alias sans pouvoir √©crire dans l'objet correspondant √† l'aide du modificateur ref readonly: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EncapsulationWentWrong</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Guid _guid; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _x; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EncapsulationWentWrong</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span> =&gt; _x = x; <span class="hljs-comment"><span class="hljs-comment">// Return an alias to the private field. No encapsulation any more. public ref int X =&gt; ref _x; // Return a readonly alias to the private field. public ref readonly Guid Guid =&gt; ref _guid; } [Test] public void NoEncapsulation() { var instance = new EncapsulationWentWrong(42); instance.X++; Assert.That(instance.X, Is.EqualTo(43)); // Cannot assign to property 'EncapsulationWentWrong.Guid' because it is a readonly variable // instance.Guid = Guid.Empty; }</span></span></code> </pre> <br><ul><li>  Les m√©thodes et propri√©t√©s peuvent renvoyer un ¬´alias¬ª de l'√©tat interne.  Dans ce cas, la m√©thode de t√¢che ne doit pas √™tre d√©finie pour la propri√©t√©. </li><li>  Le retour par r√©f√©rence interrompt l'encapsulation, car le client acquiert un contr√¥le total sur l'√©tat interne de l'objet. </li><li>  Le retour via un lien en lecture seule √©vite de copier inutilement des types de valeur, tout en ne permettant pas au client de modifier l'√©tat interne. </li><li>  Les liens en lecture seule peuvent √™tre utilis√©s pour les types de r√©f√©rence, bien que cela n'ait pas beaucoup de sens dans les cas non standard. </li></ul><br>  3. Restrictions existantes.  Renvoyer un alias peut √™tre dangereux: l'utilisation d'un alias pour une variable plac√©e sur la pile une fois la m√©thode termin√©e provoquera le plantage de l'application.  Pour rendre cette fonction s√ªre, le compilateur C # applique diverses restrictions: <br><br><ul><li>  Impossible de renvoyer le lien vers la variable locale. </li><li>  Impossible de renvoyer une r√©f√©rence √† cela dans les structures. </li><li>  Vous pouvez renvoyer un lien vers une variable situ√©e sur le tas (par exemple, vers un membre de la classe). </li><li>  Vous pouvez renvoyer un lien vers les param√®tres ref / out. </li></ul><br>  Pour plus d'informations, nous vous recommandons de consulter l'excellente publication <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Safe to return rules for ref Returns</a> .  L'auteur de l'article, Vladimir Sadov, est le cr√©ateur de la fonction de r√©f√©rence de retour pour le compilateur C #. <br><br>  Maintenant que nous avons une id√©e g√©n√©rale des valeurs de r√©f√©rence renvoy√©es et des variables locales r√©f√©renc√©es, regardons comment elles peuvent √™tre utilis√©es. <br><br><h2>  Utilisation de valeurs de r√©f√©rence retourn√©es dans les indexeurs </h2><br>  Pour tester l'effet de ces fonctions sur les performances, nous allons cr√©er une collection immuable unique appel√©e NaiveImmutableList &lt;T&gt; et la comparer avec T [] et List pour les structures de diff√©rentes tailles (4, 16, 32 et 48). <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">NaiveImmutableList</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _length; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> T[] _data; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NaiveImmutableList</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">params</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T[] data</span></span></span><span class="hljs-function">)</span></span> =&gt; (_data, _length) = (data, data.Length); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> T <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idx] <span class="hljs-comment"><span class="hljs-comment">// R# 2017.3.2 is completely confused with this syntax! // =&gt; ref (idx &gt;= _length ? ref Throw() : ref _data[idx]); { get { // Extracting 'throw' statement into a different // method helps the jitter to inline a property access. if ((uint)idx &gt;= (uint)_length) ThrowIndexOutOfRangeException(); return ref _data[idx]; } } private static void ThrowIndexOutOfRangeException() =&gt; throw new IndexOutOfRangeException(); } struct LargeStruct_48 { public int N { get; } private readonly long l1, l2, l3, l4, l5; public LargeStruct_48(int n) : this() =&gt; N = n; } // Other structs like LargeStruct_16, LargeStruct_32 etc</span></span></code> </pre> <br>  Un test de performance est effectu√© pour toutes les collections et additionne toutes les valeurs de propri√©t√© N pour chaque √©l√©ment: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elementsCount = <span class="hljs-number"><span class="hljs-number">100</span></span>_000; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> LargeStruct_48[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateArray_48</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; Enumerable.Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, elementsCount).Select(v =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LargeStruct_48(v)).ToArray(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> LargeStruct_48[] _array48 = CreateArray_48(); [BenchmarkCategory(<span class="hljs-string"><span class="hljs-string">"BigStruct_48"</span></span>)] [Benchmark(Baseline = <span class="hljs-literal"><span class="hljs-literal">true</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestArray_48</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Using elementsCound but not array.Length to force the bounds check // on each iteration. for (int i = 0; i &lt; elementsCount; i++) { result = _array48[i].N; } return result; }</span></span></code> </pre> <br>  Les r√©sultats sont les suivants: <br><br><img src="https://habrastorage.org/webt/2k/5t/6i/2k5t6iq-egji_4h7wp8zgizndws.png"><br><br>  Apparemment, quelque chose ne va pas!  Les performances de notre collection NaiveImmutableList &lt;T&gt; sont les m√™mes que celles de la liste.  Que s'est-il pass√©? <br><br><h2>  Valeurs de retour avec modificateur en lecture seule: comment cela fonctionne </h2><br>  Comme vous pouvez le voir, l'indexeur NaiveImmutableList &lt;T&gt; renvoie un lien en lecture seule √† l'aide du modificateur ref readonly.  Cela est pleinement justifi√©, car nous voulons limiter la capacit√© des clients √† modifier l'√©tat sous-jacent d'une collection immuable.  Cependant, les structures que nous utilisons dans le test de performances ne sont pas seulement lisibles. <br><br>  Ce test nous aidera √† comprendre le comportement de base: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckMutabilityForNaiveImmutableList</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ml = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NaiveImmutableList&lt;Mutable&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mutable(<span class="hljs-number"><span class="hljs-number">1</span></span>)); ml[<span class="hljs-number"><span class="hljs-number">0</span></span>].IncrementX(); <span class="hljs-comment"><span class="hljs-comment">// X has been changed, right? Assert.That(ml[0].X, Is.EqualTo(2)); }</span></span></code> </pre> <br>  Le test a √©chou√©!  Mais pourquoi?  Parce que la structure des ¬´liens en lecture seule¬ª est similaire √† la structure des modificateurs et des champs en lecture seule en ce qui concerne les structures: le compilateur g√©n√®re une copie de protection chaque fois qu'un √©l√©ment de structure est utilis√©.  Cela signifie que ml [0].  cr√©e toujours une copie du premier √©l√©ment, mais cela n'est pas fait par l'indexeur: la copie est cr√©√©e au point d'appel. <br><br>  Ce comportement est en fait logique.  Le compilateur C # prend en charge le passage d'arguments par valeur, par r√©f√©rence et par ¬´lien en lecture seule¬ª √† l'aide du modificateur in (pour plus de d√©tails, voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le modificateur in et les structures en lecture seule en C #</a> (¬´Le modificateur in et les structures en lecture seule en C # ")).  Maintenant, le compilateur prend en charge trois fa√ßons diff√©rentes de renvoyer une valeur √† partir d'une m√©thode: par valeur, par r√©f√©rence et par lien en lecture seule. <br><br>  Les liens en lecture seule sont tellement similaires aux liens r√©guliers que le compilateur utilise le m√™me InAttribute pour distinguer leurs valeurs de retour: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _n; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">ref</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">readonly</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ByReadonlyRef</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> _n;</code> </pre> <br>  Dans ce cas, la m√©thode ByReadonlyRef se compile efficacement en: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">InAttribute</span></span>] [<span class="hljs-keyword"><span class="hljs-keyword">return</span></span>: IsReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* ByReadonlyRef() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._n; }</code> </pre> <br>  La similitude entre le modificateur in et le lien en lecture seule signifie que ces fonctions ne sont pas tr√®s adapt√©es aux structures r√©guli√®res et peuvent entra√Æner des probl√®mes de performances.  Prenons un exemple: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> BigStruct { <span class="hljs-comment"><span class="hljs-comment">// Other fields public int X { get; } public int Y { get; } } private BigStruct _bigStruct; public ref readonly BigStruct GetBigStructByRef() =&gt; ref _bigStruct; ref readonly var bigStruct = ref GetBigStructByRef(); int result = bigStruct.X + bigStruct.Y;</span></span></code> </pre> <br>  Outre la syntaxe inhabituelle lors de la d√©claration d'une variable pour bigStruct, le code semble correct.  L'objectif est clair: BigStruct revient par r√©f√©rence pour des raisons de performances.  Malheureusement, √©tant donn√© que la structure BigStruct est accessible en √©criture, une copie de protection est cr√©√©e √† chaque acc√®s √† l'√©l√©ment. <br><br><h2>  Utilisation de valeurs de r√©f√©rence renvoy√©es dans les indexeurs.  Tentative num√©ro 2 </h2><br>  Essayons le m√™me ensemble de tests pour des structures en lecture seule de diff√©rentes tailles: <br><br><img src="https://habrastorage.org/webt/8s/u5/je/8su5je3fe_-dhpjlf4f1bpeqoug.png"><br><br>  Maintenant, les r√©sultats ont beaucoup plus de sens.  Le temps de traitement continue d'augmenter pour les grandes structures, mais cela est attendu, car le traitement de plus de 100 000 structures plus grandes prend plus de temps.  Mais maintenant le runtime pour NaiveimmutableList &lt;T&gt; est tr√®s proche du temps T [] et bien meilleur que dans le cas de List. <br><br><h2>  Conclusion </h2><br><ul><li>  Les valeurs de r√©f√©rence renvoy√©es doivent √™tre trait√©es avec soin car elles peuvent rompre l'encapsulation. </li><li>  Les valeurs de r√©f√©rence retourn√©es avec le modificateur en lecture seule ne sont efficaces que pour les structures en lecture seule.  Dans le cas de structures conventionnelles, des probl√®mes de performances peuvent survenir. </li><li>  Lorsque vous travaillez avec des structures inscriptibles, les valeurs de r√©f√©rence renvoy√©es avec le modificateur en lecture seule cr√©ent une copie de protection chaque fois que la variable est utilis√©e, ce qui peut entra√Æner des probl√®mes de performances. </li></ul><br>  Les valeurs de r√©f√©rence retourn√©es et les variables locales r√©f√©renc√©es sont des fonctions utiles pour les cr√©ateurs de biblioth√®ques et les d√©veloppeurs de code d'infrastructure.  Cependant, ils sont tr√®s dangereux √† utiliser dans le code de la biblioth√®que: pour utiliser une collection qui renvoie efficacement des √©l√©ments √† l'aide d'un lien en lecture seule, chaque utilisateur de la biblioth√®que doit se souvenir: un lien en lecture seule vers une structure accessible en √©criture cr√©e une copie de protection ¬´au point d'appel ".  Dans le meilleur des cas, cela annulera une √©ventuelle augmentation de la productivit√©, et dans le pire des cas, cela entra√Ænera une grave d√©t√©rioration si, en m√™me temps, un grand nombre de demandes sont adress√©es √† une variable locale de r√©f√©rence, en lecture seule. <br><br>  Les liens PS en lecture seule appara√Ætront dans BCL.  Les m√©thodes ref en lecture seule pour acc√©der aux √©l√©ments des collections immuables ont √©t√© pr√©sent√©es dans la demande suivante pour incorporer les modifications dans le r√©f√©rentiel corefx ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Impl√©mentation de la proposition d'API ItemRef</a> (¬´Proposition d'inclure l'API ItemRef¬ª)).  Par cons√©quent, il est tr√®s important que tout le monde comprenne les caract√©ristiques de l'utilisation de ces fonctions et comment et quand elles doivent √™tre appliqu√©es. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr423061/">https://habr.com/ru/post/fr423061/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr423051/index.html">La lutte pour les ressources, partie 1: les bases des groupes de contr√¥le</a></li>
<li><a href="../fr423053/index.html">Structurer et lire uniquement: comment √©viter la d√©gradation des performances</a></li>
<li><a href="../fr423055/index.html">Analystes de Wall Street: ¬´Apple nous a fait manger nos chapeaux¬ª</a></li>
<li><a href="../fr423057/index.html">Python refuse √©galement partiellement les termes ma√Ætre / esclave</a></li>
<li><a href="../fr423059/index.html">Mieux qu'ils ne le disent: trois √©l√©ments essentiels pour que le prochain MacBook devienne l'un des meilleurs ordinateurs portables d'Apple</a></li>
<li><a href="../fr423063/index.html">Epson WorkForce Pro: Chroniques de la fa√ßon dont une impression de bureau √† jet d'encre ¬´a tir√© une couverture¬ª d'un laser et ce qu'elle est devenue aujourd'hui</a></li>
<li><a href="../fr423065/index.html">Un expert de Positive Technologies a d√©couvert la possibilit√© de divulguer des cl√©s de chiffrement dans Intel ME</a></li>
<li><a href="../fr423067/index.html">Outils de d√©veloppement Python de Microsoft. Pour commencer</a></li>
<li><a href="../fr423069/index.html">√âv√©nement sp√©cial Apple, septembre 2018 [archives de traduction de texte]</a></li>
<li><a href="../fr423071/index.html">Je n'ai pas peur de ton NDA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>