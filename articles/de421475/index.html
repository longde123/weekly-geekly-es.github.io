<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>▫️ 🌓 🕴🏾 OutOfLine - In-Memory-Muster für leistungsstarke C ++ - Anwendungen 👩‍🎨 😙 🧚🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Während meiner Arbeit bei Headlands Technologies hatte ich das Glück, mehrere Dienstprogramme zu schreiben, um die Erstellung von Hochleistungs-C ++ -...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OutOfLine - In-Memory-Muster für leistungsstarke C ++ - Anwendungen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421475/"><p> Während meiner Arbeit bei Headlands Technologies hatte ich das Glück, mehrere Dienstprogramme zu schreiben, um die Erstellung von Hochleistungs-C ++ - Code zu vereinfachen.  Dieser Artikel bietet einen allgemeinen Überblick über eines dieser Dienstprogramme, <a href=""><code>OutOfLine</code></a> . </p><a name="habracut"></a><br><p>  Beginnen wir mit einem anschaulichen Beispiel.  Angenommen, Sie haben ein System, das eine große Anzahl von Dateisystemobjekten verarbeitet.  Dies können normale Dateien sein, die als UNIX-Sockets oder Pipes bezeichnet werden.  Aus irgendeinem Grund öffnen Sie beim Start viele Dateideskriptoren, arbeiten dann intensiv mit ihnen und schließen am Ende die Deskriptoren und löschen Links zu Dateien (ca. Die Spur bedeutet die Funktion zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufheben der</a> Verknüpfung). </p><br><p>  Die ursprüngliche (vereinfachte) Version könnte folgendermaßen aussehen: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnlinkingFD</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> path; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd; UnlinkingFD(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; p) : path(p) { fd = open(p.c_str(), O_RDWR, <span class="hljs-number"><span class="hljs-number">0</span></span>); } ~UnlinkingFD() { close(fd); unlink(path.c_str()); } UnlinkingFD(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UnlinkingFD&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; };</code> </pre> <br><p>  Und das ist ein gutes, logisch solides Design.  Es basiert auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RAII</a> , um den Deskriptor automatisch freizugeben und den Link zu entfernen.  Sie können ein großes Array solcher Objekte erstellen, mit ihnen arbeiten. Wenn das Array nicht mehr existiert, löschen die Objekte selbst alles, was im Prozess benötigt wurde. </p><br><p>  Aber was ist mit der Leistung?  Angenommen, <code>fd</code> sehr oft verwendet und <code>path</code> nur beim Löschen eines Objekts.  Jetzt besteht das Array aus Objekten mit einer Größe von 40 Bytes, aber oft werden nur 4 Bytes verwendet.  Dies bedeutet, dass mehr Fehler im Cache auftreten, da Sie 90% der Daten „überspringen“ müssen. </p><br><p>  Eine der häufigsten Lösungen für dieses Problem ist der Übergang von einem Array von Strukturen zu einer Array-Struktur.  Dies bietet die gewünschte Leistung, jedoch auf Kosten des Verzichts auf RAII.  Gibt es eine Option, die die Vorteile beider Ansätze kombiniert? </p><br><p>  Ein einfacher Kompromiss wäre, <code>std::string</code> Größe von 32 Bytes durch <code>std::unique_ptr&lt;std::string&gt;</code> zu ersetzen, dessen Größe nur 8 Bytes beträgt.  Dadurch wird die Größe unseres Objekts von 40 Byte auf 16 Byte reduziert, was eine großartige Leistung ist.  Diese Lösung verliert jedoch immer noch die Verwendung mehrerer Arrays. </p><br><p>  <code>OutOfLine</code> ist ein Tool, mit dem Sie ohne Verwendung von RAII selten verwendete (kalte) Felder vollständig außerhalb des Objekts verschieben können.  OutOfLine wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CRTP-</a> Basisklasse verwendet, daher muss das erste Argument für die Vorlage eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">untergeordnete</a> Klasse sein.  Das zweite Argument ist der Typ selten verwendeter (kalter) Daten, der einem häufig verwendeten (Haupt-) Objekt zugeordnet ist. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnlinkingFD</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> OutOfLine&lt;UnlinkingFD, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd; UnlinkingFD(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; p) : OutOfLine&lt;UnlinkingFD, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(p) { fd = open(p.c_str(), O_RDWR, <span class="hljs-number"><span class="hljs-number">0</span></span>); } ~UnlinkingFD(); UnlinkingFD(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UnlinkingFD&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; };</code> </pre> <br><p>  Wie ist diese Klasse? </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FastData</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ColdData</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OutOfLine</span></span></span><span class="hljs-class"> {</span></span></code> </pre> <br><p>  Die grundlegende Implementierungsidee besteht darin, einen globalen assoziativen Container zu verwenden, der Zeiger auf Hauptobjekte und Zeiger auf Objekte abbildet, die kalte Daten enthalten. </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;OutOfLine <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;ColdData&gt;&gt; global_map_;</code> </pre> <br><p>  <code>OutOfLine</code> kann mit jeder Art von kalten Daten verwendet werden, von denen eine Instanz automatisch erstellt und dem Hauptobjekt zugeordnet wird. </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgs</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">explicit</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OutOfLine</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgs</span></span></span><span class="hljs-class">&amp;&amp;... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">) {</span></span> global_map_[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>] = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;ColdData&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TArgs&gt;(args)...); }</code> </pre> <br><p>  Das Entfernen des Hauptobjekts beinhaltet das automatische Entfernen des zugehörigen kalten Objekts: </p><br><pre> <code class="cpp hljs"> ~OutOfLine() { global_map_.erase(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br><p>  Beim Verschieben (Konstruktor verschieben / Zuweisungsoperator verschieben) des Hauptobjekts wird das entsprechende kalte Objekt automatisch dem neuen Hauptnachfolgeobjekt zugeordnet.  Daher sollten Sie nicht auf die kalten Daten eines verschobenen Objekts zugreifen. </p><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OutOfLine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OutOfLine&amp;&amp; other)</span></span></span><span class="hljs-function"> </span></span>{ *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = other; } OutOfLine&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(OutOfLine&amp;&amp; other) { global_map_[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>] = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(global_map_[&amp;other]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br><p>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">obigen</a> Implementierungsbeispiel wird OutOfLine der Einfachheit halber nicht kopierbar gemacht.  Bei Bedarf lassen sich Kopiervorgänge einfach hinzufügen. Sie müssen lediglich eine Kopie eines kalten Objekts erstellen und verknüpfen. </p><br><pre> <code class="cpp hljs">OutOfLine(OutOfLine <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; OutOfLine&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(OutOfLine <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>;</code> </pre> <br><p>  Damit dies wirklich nützlich ist, wäre es schön, Zugriff auf kalte Daten zu haben.  Beim Erben von <code>OutOfLine</code> erhält <code>OutOfLine</code> Klasse die konstanten und nicht konstanten Methoden von <code>cold()</code> : </p><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-function">ColdData&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cold</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *global_map_[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]; } <span class="hljs-function"><span class="hljs-function">ColdData </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function">&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cold</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *global_map_[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]; }</code> </pre> <br><p>  Sie geben die entsprechende Art der Referenz auf kalte Daten zurück. </p><br><p>  Das ist fast alles.  Diese <code>UnlinkingFD</code> Option ist 4 Byte groß, bietet einen <code>UnlinkingFD</code> Zugriff auf das <code>fd</code> Feld und behält die Vorteile von RAII bei.  Alle Arbeiten im Zusammenhang mit dem Lebenszyklus eines Objekts sind vollständig automatisiert.  Wenn sich das häufig verwendete Hauptobjekt bewegt, werden selten verwendete kalte Daten mit verschoben.  Wenn das Hauptobjekt gelöscht wird, wird auch das entsprechende kalte Objekt gelöscht. </p><br><p>  Manchmal werden Ihre Daten jedoch verschworen, um Ihr Leben zu verkomplizieren - und Sie sind mit einer Situation konfrontiert, in der zuerst Basisdaten erstellt werden müssen.  Sie werden beispielsweise benötigt, um kalte Daten zu erstellen.  Es ist erforderlich, Objekte in umgekehrter Reihenfolge zu <code>OutOfLine</code> Angeboten von <code>OutOfLine</code> zu erstellen.  In solchen Fällen ist eine Sicherung hilfreich, um die Reihenfolge der Initialisierung und De-Initialisierung zu steuern. </p><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TwoPhaseInit</span></span></span><span class="hljs-class"> {</span></span>}; OutOfLine(TwoPhaseInit){} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgs</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">init_cold_data</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgs</span></span></span><span class="hljs-class">&amp;&amp;... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">) {</span></span> global_map_.find(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)-&gt;second = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;ColdData&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TArgs&gt;(args)...); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">release_cold_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ global_map_[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>].reset(); }</code> </pre> <br><p>  Dies ist ein weiterer <code>OutOfLine</code> Konstruktor, der in <code>OutOfLine</code> Klassen verwendet werden kann und ein Tag vom Typ <code>TwoPhaseInit</code> akzeptiert.  Wenn Sie <code>OutOfLine</code> auf diese Weise erstellen, werden die kalten Daten nicht initialisiert und das Objekt bleibt zur Hälfte konstruiert.  Um die zweiphasige Konstruktion <code>init_cold_data</code> , müssen Sie die Methode <code>init_cold_data</code> (indem Sie die Argumente übergeben, die zum Erstellen eines Objekts vom Typ <code>ColdData</code> ).  Denken Sie daran, dass Sie <code>.cold()</code> für ein Objekt aufrufen <code>.cold()</code> dessen kalte Daten noch nicht initialisiert wurden.  Analog können kalte Daten vorzeitig gelöscht werden, bevor der <code>~OutOfLine</code> Destruktor ausgeführt wird, indem <code>~OutOfLine</code> wird. </p><br><pre> <code class="cpp hljs">}; <span class="hljs-comment"><span class="hljs-comment">// end of class OutOfLine</span></span></code> </pre> <br><p>  Jetzt ist alles.  Was geben uns diese 29 Codezeilen?  Sie sind ein weiterer möglicher Kompromiss zwischen Leistung und Benutzerfreundlichkeit.  In Fällen, in denen Sie ein Objekt haben, von dem einige Mitglieder viel häufiger als andere verwendet werden, kann <code>OutOfLine</code> als <code>OutOfLine</code> Methode zur Optimierung des Caches dienen, wodurch der Zugriff auf selten verwendete Daten erheblich verlangsamt wird. </p><br><p>  Wir konnten diese Technik an mehreren Stellen anwenden - häufig müssen intensiv genutzte Arbeitsdaten durch zusätzliche Metadaten ergänzt werden, die am Ende der Arbeit in seltenen oder unerwarteten Situationen erforderlich sind.  Ob es sich um Informationen über die Benutzer handelt, die die Verbindung hergestellt haben, über das Handelsterminal, von dem die Bestellung kam, oder über das Handle des Hardwarebeschleunigers, der Austauschdaten verarbeitet - <code>OutOfLine</code> hält den Cache sauber, wenn Sie sich im kritischen Teil der Berechnungen befinden (kritischer Pfad). </p><br><p>  Ich habe einen <a href="">Test</a> vorbereitet <a href="">,</a> damit Sie den Unterschied sehen und bewerten können. </p><br><table><thead><tr><th>  Das Skript </th><th>  Zeit (ns) </th></tr></thead><tbody><tr><td>  Kalte Daten im Hauptobjekt (Erstversion) </td><td>  34684547 </td></tr><tr><td>  Kalte Daten vollständig gelöscht (Best-Case-Szenario) </td><td>  2938327 </td></tr><tr><td>  OutOfLine verwenden </td><td>  2947645 </td></tr></tbody></table><br><p>  Ich habe ungefähr <code>OutOfLine</code> Beschleunigung bei der Verwendung von <code>OutOfLine</code> .  Dieser Test soll <code>OutOfLine</code> das Potenzial von <code>OutOfLine</code> , zeigt aber auch, wie stark die Cache-Optimierung einen erheblichen Einfluss auf die Leistung haben kann, genau wie <code>OutOfLine</code> es <code>OutOfLine</code> ermöglicht, diese Optimierung zu erhalten.  Wenn Sie den Cache frei von selten verwendeten Daten halten, können Sie den Rest des Codes komplex, messbar und umfassend verbessern.  Wie immer bei der Optimierung vertrauen Vertrauensmessungen mehr als Annahmen, dennoch hoffe ich, dass <code>OutOfLine</code> sich als nützliches Werkzeug in Ihrer Sammlung von Dienstprogrammen <code>OutOfLine</code> wird. </p><br><h2 id="primechanie-ot-perevodchika">  <em>Anmerkung des Übersetzers</em> </h2><br><p>  <em>Der im Artikel bereitgestellte Code dient zur Veranschaulichung der Idee und ist nicht repräsentativ für den Produktionscode.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de421475/">https://habr.com/ru/post/de421475/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de421465/index.html">Mobile DevOps in der Praxis</a></li>
<li><a href="../de421467/index.html">Entwicklung eines Roboters zum Sammeln von Golfbällen</a></li>
<li><a href="../de421469/index.html">Telegramm stimmte zu, IP-Adressen und Nummern einiger Benutzer an die Sonderdienste [aber nicht auf Russisch] zu übertragen</a></li>
<li><a href="../de421471/index.html">Ad Exchange Server - im Gegensatz zu anderen</a></li>
<li><a href="../de421473/index.html">Was sind Coroutinen in Kotlin?</a></li>
<li><a href="../de421477/index.html">Was ist in der Datei .ssh / unknown_hosts geschrieben?</a></li>
<li><a href="../de421481/index.html">Mikrofone, Screenshots und lokales Video: Wie das Voximplant Web SDK Medien in einem Browser steuert</a></li>
<li><a href="../de421485/index.html">Wichtiger Hinweis für Benutzer von Gitlab Pages</a></li>
<li><a href="../de421487/index.html">Stärkung des technischen Supports - 6 geheime Möglichkeiten</a></li>
<li><a href="../de421489/index.html">Grunzen aber geben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>