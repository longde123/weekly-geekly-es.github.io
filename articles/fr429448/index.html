<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôèüèª üèë ‚ôãÔ∏è Nous √©crivons le chargeur FPGA dans LabVIEW. 2e partie ü§õüèΩ üçõ üõµ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="T√©l√©chargez la configuration sur FPGA via USB ou d√©montez FTDI MPSSE 
 Nous √©crivons le chargeur FPGA dans LabVIEW. Partie 1 


 Dans le premier artic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous √©crivons le chargeur FPGA dans LabVIEW. 2e partie</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429448/"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">T√©l√©chargez la configuration sur FPGA via USB ou d√©montez FTDI MPSSE</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nous √©crivons le chargeur FPGA dans LabVIEW.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> </p><br><img src="https://habrastorage.org/webt/2m/nu/6l/2mnu6ljkhtj-pydr_chsebgpp_i.jpeg"><br><br>  Dans le premier article, nous avons test√© l'algorithme de chargement sur le bon vieux C, dans le deuxi√®me article, nous avons compris comment organiser un programme dans LabVIEW et impl√©menter une interface utilisateur simple.  Cette fois, nous nous familiariserons avec les nouvelles m√©thodes de travail dans LabVIEW, analyserons les caract√©ristiques de la gestion des erreurs et terminerons le projet: nous impl√©mentons le protocole de chargement du fichier de configuration dans le FPGA. <a name="habracut"></a><br><br><h2 id="obrabotka-oshibok">  Gestion des erreurs </h2><br><p> Ouvrez le code source, analysez la fonction MPSSE_open.  Malgr√© la simplicit√© algorithmique (les fonctions sont appel√©es les unes apr√®s les autres), de nombreux √©l√©ments de l'API D2XX doivent √™tre import√©s: <code>FT_ResetDevice</code> , <code>FT_Purge</code> , <code>FT_SetUSBParameters</code> , <code>FT_SetChars</code> , <code>FT_SetTimeouts</code> , <code>FT_SetLatencyTimer</code> , <code>FT_SetFlowControl</code> , <code>FT_SetBitMode</code>  Comme indiqu√© dans l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article pr√©c√©dent</a> , l'importation de fonctions est effectu√©e √† l'aide du n≈ìud <code>Call library Function</code> .  Ce n≈ìud poss√®de des terminaux d√©di√©s pour le contr√¥le des erreurs.  LabVIEW a une r√®gle simple: tous les <abbr title="Appliance virtuelle">VIs</abbr> doivent suivre les erreurs et signaler les erreurs renvoy√©es par les terminaux d'erreur.  La plupart des VIs int√©gr√©s la suivent strictement.  J'esp√®re que tout le monde comprend √† quel point il est important de contr√¥ler et de g√©rer les erreurs, en particulier au stade du d√©bogage, mais il y a une autre raison pour laquelle c'est si important qui n'est pas √©vident pour les programmeurs "classiques".  LabVIEW n'a pas de s√©quence stricte de p√©riph√©riques dans le diagramme: le p√©riph√©rique est ex√©cut√© lorsque les donn√©es sont pr√™tes √† ses entr√©es.  Si les donn√©es de la sortie d'un VI sont transf√©r√©es vers l'entr√©e d'un autre VI, alors il est clair qu'au d√©but le premier VI fonctionnera, seulement apr√®s le second.  Mais que faire s'il n'y a pas de transfert de donn√©es et que les VIs effectuent des actions ind√©pendantes?  Bien s√ªr, vous pouvez utiliser la lourde "Flat Sequence Structure", mais il est beaucoup plus pratique de connecter les appareils les uns aux autres par un flux d'erreurs. </p><br><p>  Lors de l'importation de fonctions D2XX, nous rencontrons deux types d'erreurs.  Le premier - il s'agit d'une erreur d'importation directe - renvoie le bloc <code>Call library Function</code> lui-m√™me.  La seconde est une erreur de la biblioth√®que elle-m√™me; elle est renvoy√©e par presque toutes les fonctions via <code>FT_STATUS</code> .  Toutes les valeurs possibles sont d√©crites comme enum dans le fichier d'en-t√™te ftd2xx.h.  Bien qu'il soit suffisant de savoir que la valeur <code>FT_OK</code> est l'absence d'erreur et que toutes les autres valeurs sont des codes d'erreur, je voudrais suivre non seulement le fait de l'erreur elle-m√™me, mais aussi quelle erreur s'est produite et o√π exactement elle s'est produite. </p><br><p>  Dans LabVIEW, les donn√©es d'erreur sont propag√©es via <code>error</code> clusters d' <code>error</code> .  Il s'agit d'un type de donn√©es d√©di√© sp√©cial; LabVIEW poss√®de de nombreux VIs et fonctions pour travailler avec.  Le cluster d'erreur se compose de trois √©l√©ments: une variable logique - affiche l'√©tat, un nombre entier sign√© - un code d'erreur, une cha√Æne - la source de l'erreur.  L'√©tat indique si une erreur s'est produite, le code d'erreur d√©termine son type et est utilis√© par des VIs sp√©ciaux pour g√©n√©rer un rapport.  La ligne donne une id√©e plus d√©taill√©e de l'endroit exact o√π l'erreur s'est produite.  LabVIEW a accept√© que si le statut est <code>TRUE</code> , alors c'est une erreur, si le statut est <code>FALSE</code> , mais le code n'est pas nul et la ligne de description n'est pas vide, alors c'est un <em>avertissement</em> , si le statut est <code>FALSE</code> , le code est nul et la ligne est vide - il n'y a pas d'erreur. </p><br><img src="https://habrastorage.org/webt/pm/ku/gv/pmkugvhr1yzt6uarss9lfnmthuc.png"><br><br><p>  LabVIEW contient une base de donn√©es interne dans laquelle chaque code d'erreur est associ√© √† sa description.  Pour chaque type d'erreur, une plage sp√©ciale de valeurs de code est allou√©e.  Par exemple, pour les erreurs li√©es au fonctionnement du r√©seau, plusieurs plages sont allou√©es: de ‚Äì2147467263 √† ‚Äì1967390460, de 61 √† 65, de 116 √† 118 et 122, 1101, 1114, 1115, 1132 √† 1134, de 1139 √† 1143 et de 1178 √† 1185 Pour les erreurs d√©finies par l'utilisateur, deux plages sont r√©serv√©es de ‚Äì8999 √† ‚Äì8000 et de 5000 √† 9999. √Ä partir de ces plages, nous pouvons choisir des valeurs pour les codes d'erreur de la biblioth√®que D2XX. </p><br><p>  Cr√©ons un VI qui re√ßoit le statut de la fonction D2XX en entr√©e et convertit ce statut en un cluster d'erreur LabVIEW.  La plupart des fonctions et VIs de LabVIEW, ayant re√ßu le statut <code>TRUE</code> √† l'entr√©e <code>Error In</code> , n'ex√©cutent pas leur code, mais transmettent les informations d' <code>Error Out</code> terminal <code>Error Out</code> .  Cela vous permet de transf√©rer efficacement des informations sur la source tout au long de la cha√Æne vers le gestionnaire d'erreurs, √©liminant ainsi l'ex√©cution de code en mode d'urgence.  Il est souhaitable que nos VIs se comportent de la m√™me mani√®re. </p><br><p>  Organisons la liste des statuts D2XX sous forme d' <code>enum</code> et pla√ßons-la dans un type distinct (dans l'article pr√©c√©dent, nous l'avons fait avec les types FTDI). </p><br><div class="spoiler">  <b class="spoiler_title">√©num√©ration FT_Status</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/mb/bp/kp/mbbpkpzguefjrdg2p4l2n7-rpg0.png"></div></div><br><p>  Nous enregistrons le nouveau VI sous le nom FT_error.vi.  Nous ajoutons deux clusters <code>Error In</code> et <code>Error Out</code> panneau avant, vous pouvez les trouver dans le panneau "Array, Matrix &amp; Cluster".  Nous les connectons aux bornes du panneau de connexion dans les coins inf√©rieur gauche et inf√©rieur droit, respectivement, comme d√©j√† mentionn√© dans l'article pr√©c√©dent, c'est l'emplacement des bornes de flux d'erreur adopt√©es par LabVIEW.  Nous ajoutons la structure <code>Case</code> au diagramme, donnons le cluster <code>Error In</code> √† l'entr√©e du <code>Case selector</code> , apr√®s quoi la structure <code>Case</code> change de couleur et divise deux sous-diagrammes: "No Error" - couleur verte et "Error" - couleur rouge.  √Ä l'int√©rieur du cas d'erreur, nous transf√©rons le cluster d'erreurs du terminal de s√©lection directement au tunnel de sortie sur la bordure droite.  Et dans le cas vert, nous ajoutons un autre <code>Case</code> , selon le statut, il d√©terminera s'il faut cr√©er une erreur (le statut n'est pas √©gal √† FT_OK), ou le laisser tel quel: ignorer le cluster d'erreur d'entr√©e pour quitter sans changer. </p><br><p>  Afin de convertir techniquement le code d'erreur en cluster, vous pouvez utiliser le VI VI <code>Error Cluster From Error Code VI</code> .  Ce sous- <abbr title="Sous instrument virtuel. Il est un sous-auteur">VI</abbr> ajoute une cha√Æne d'appels √† la description de l'erreur, afin que nous puissions d√©terminer non seulement <strong>ce qui</strong> s'est produit, mais aussi <strong>o√π</strong> cela s'est produit. </p><br><p>  Pour s√©lectionner le texte correspondant √† l'√©tat d'entr√©e (FT_Status), utilisez le bloc de propri√©t√©s: s√©lectionnez "RingText.Text".  Le texte d'erreur est envoy√© √† l'entr√©e du <code>error message</code> d' <code>Error Cluster From Error Code VI</code> . <br>  N'oubliez pas de dessiner une ic√¥ne "parlante". </p><br><div class="spoiler">  <b class="spoiler_title">FT_error.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/xx/xw/ub/xxxwubdzodjs1jfaywcbjamsrtg.png"><br>  <em>Tableau de bord avant (avant)</em> </p><br><p><img src="https://habrastorage.org/webt/ja/wu/te/jawuteahiriyixrjpcgbm91esjo.png"><br>  <em>Sch√©ma fonctionnel.</em>  <em>Erreur d'entr√©e</em> </p><br><p><img src="https://habrastorage.org/webt/yd/qf/lp/ydqflp1m-zexy_zvvdx8drixu9e.png"><br>  <em>Sch√©ma fonctionnel.</em>  <em>Il n'y a pas d'erreur √† l'entr√©e et l'√©tat est FT_OK</em> </p><br><p><img src="https://habrastorage.org/webt/1h/wp/7m/1hwp7mcprzgv3mf9oz3jenbco4q.png"><br>  <em>Sch√©ma fonctionnel.</em>  <em>Il n'y a pas d'erreur √† l'entr√©e, mais l'√©tat est diff√©rent de FT_OK</em> </p><br></div></div><br><p>  Pour tester FT_error, vous pouvez cr√©er un VI vide, y ajouter le VI cr√©√© et voir comment la valeur changera au d√©marrage si diff√©rents statuts sont appliqu√©s. </p><br><div class="spoiler">  <b class="spoiler_title">Test FT_error.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/rn/_r/be/rn_rbewvlb--au_hi3nosghkjmk.png"><br>  <em>Panneau avant (avant) de l'appareil</em> </p><br><p><img src="https://habrastorage.org/webt/ju/44/fz/ju44fzmyx2aly2-fraydjrkyffg.png"><br>  <em>Sch√©ma fonctionnel</em> </p></div></div><br><p>  Maintenant, apr√®s tout appel de fonction de l'API D2XX, nous utiliserons SubVI FT_error.vi.  Un groupe d'erreurs passera par tous les VIs de la hi√©rarchie des appels. </p><br><p>  Dans les VIs de niveau sup√©rieur, nous devons d√©cider quoi faire avec l'erreur d√©tect√©e: vous pouvez afficher un message dans la bo√Æte de dialogue, l'√©crire dans le fichier de rapport, l'ignorer ou simplement mettre fin √† l'application ¬´en silence¬ª.  La bo√Æte de dialogue est le moyen le plus simple et le plus populaire de signaler des erreurs.  C'est √©galement pratique pour un programmeur d√©butant, car il n'y a rien √† faire.  Dans chaque VI, le mode de <strong>gestion automatique des erreurs</strong> est activ√© par d√©faut ( <strong>Activer la gestion automatique des erreurs</strong> , situ√© dans la cat√©gorie Ex√©cution du menu Propri√©t√©s du VI).  Cela fonctionne comme ceci: si dans un n≈ìud, le terminal de sortie <code>Error Out</code> n'est connect√© nulle part et qu'une erreur se produit dans ce n≈ìud, LabVIEW met en pause l'application et affiche une bo√Æte de dialogue.  Si la borne de <code>Error Out</code> du n≈ìud est connect√©e, le flux d'erreur se propage comme programm√© et aucune action suppl√©mentaire ne se produit.  Cependant, la fen√™tre de message peut √™tre appel√©e par programme, pour cela, vous devez utiliser les VIs <code>General Error Handler</code> et <code>Simple Error Handler</code> (situ√©s dans le panneau Dialog &amp; User Interface).  Dans ce cas, nous pouvons utiliser les informations d'erreur pour terminer le programme.  Dans un diagramme, cela ressemble √† ceci: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/u9/8y/_p/u98y_paluq1jtgm2gylcaceydgs.png"></a> <br>  <em>Image cliquable</em> </p><br><p>  Lorsqu'une erreur se produit, le programme sera suspendu, une fen√™tre de rapport appara√Ætra, apr√®s avoir ferm√© la fen√™tre, le programme se fermera correctement. </p><br><div class="spoiler">  <b class="spoiler_title">Fen√™tre de rapport</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/9g/mh/lc/9gmhlc7e8mf-2uqzheifbdtgdek.png"></p></div></div><br><h2 id="otkryt-i-zakryt-ftdi">  Ouvrir et fermer FTDI </h2><br><p>  Revenons donc √† la fonction <code>MPSSE_open</code> .  Cr√©ez un nouveau <abbr title="Instrument virtuel">VI</abbr> .  Tout d'abord, ajoutez les terminaux pour le flux d'erreur.  Ajoutez une structure de s√©lection et s√©lectionnez Entr√©e d' <code>Error In</code> dans le s√©lecteur.  Dans le cas vert, nous importons les fonctions dans l'ordre et avec les param√®tres comme dans le prototype Sishny.  Tous les n≈ìuds du n≈ìud de <code>Call Library Function Node</code> connect√©s en cha√Æne par un flux d'erreur.  Dans le cas rouge √† travers le tunnel, nous connectons <code>Error In</code> avec la borne de sortie de l'erreur. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/4p/qq/zx/4pqqzxgwcgsbb-jcvepvyaj6jam.png"></a> <br>  <em>Image cliquable</em> </p><br><p><img src="https://habrastorage.org/webt/5z/uq/k6/5zuqk6hmya20zgu9ddnciwgj5a0.png"><br>  <em>VI MPSSE_open.vi</em> </p><br><p>  Une ligne avec la description de FTDI ( <code>Description</code> ) est fournie √† l'entr√©e de SubVI, √† la sortie se trouve <code>Handle</code> et une puce FTDI initialis√©e en mode MPSSE. </p><br><p>  Cr√©ons un VP qui finit de travailler avec FTDI et vous pouvez d√©j√† v√©rifier les performances sur le mat√©riel. </p><br><div class="spoiler">  <b class="spoiler_title">FT_Close.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/1e/te/g3/1eteg3uh0t2t16y9yho_kxjbufe.png"><br>  <em>Sch√©ma fonctionnel</em> </p><br><p><img src="https://habrastorage.org/webt/ki/ez/tt/kiezttogb-2n4zl1qe893hfc55w.png"><br>  <em>Face avant</em> </p></div></div><br><p>  Dans l'article pr√©c√©dent, pour le d√©bogage de l'interface, nous avons cr√©√© le stub VI SP_FT_MPSSE_FPGA.vi, il est maintenant temps de le remplir.  Ajoutez MPSSE_open.vi et FT_Close.vi √† son diagramme.  √Ä ce stade, il est assez difficile d'√©valuer si l'initialisation √©tait correcte, cependant, une valeur <code>Handle</code> non nulle √† la sortie de MPSSE_open.vi et l'absence d'erreur nous en dira beaucoup. </p><br><p><img src="https://habrastorage.org/webt/ci/rn/q5/cirnq5ik2_g5p-wbz3cmfcxzquo.png"><br>  <em>Organigramme SP_FT_MPSSE_FPGA.vi</em> </p><br><p>  Pour voir la valeur de <code>Handle</code> vous pouvez utiliser la "fen√™tre de surveillance de sonde".  Il s'agit d'un outil de d√©bogage pratique qui vous permet d'afficher la valeur des donn√©es sur n'importe quel (presque n'importe quel) fil pendant l'ex√©cution de l'appareil.  Afin de placer l'√©chantillon sur la ligne, vous devez s√©lectionner "Sonde" dans le menu contextuel de cette ligne.  La fen√™tre "Probe Watch Window" s'ouvre et un num√©ro avec le num√©ro d'√©chantillon appara√Æt sur la ligne.  Dans l'image ci-dessus, c'est "3". </p><br><div class="spoiler">  <b class="spoiler_title">Fen√™tre de surveillance de sonde</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/yq/qv/u_/yqqvu_pkihohde2in-uy7sttt-i.png"><br>  <em>Sur la ligne Handle, la valeur 698389336</em> </p></div></div><br><p>  Super!  Nous d√©marrons les VIs de niveau sup√©rieur, connectons la carte de d√©bogage √† l'ordinateur.  Une description de la puce FTDI connect√©e appara√Æt dans la liste "S√©lectionner un appareil", cliquez sur le bouton "Programmer" et ... rien ne se passe.  La valeur <code>Handle</code> n'est apparue que dans la fen√™tre "Probe Watch".  Et c'est bien. </p><br><p>  Nous √©teignons la carte, la liste des appareils est effac√©e.  Cliquez sur "Programme".  C'est l√† que la fen√™tre de rapport d'erreur appara√Æt. </p><br><div class="spoiler">  <b class="spoiler_title">Fen√™tre de rapport</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/9g/mh/lc/9gmhlc7e8mf-2uqzheifbdtgdek.png"></p></div></div><br><p>  Apr√®s avoir cliqu√© sur le bouton "Continuer", le VI termine son travail. </p><br><p>  Il est interdit d'appuyer sur le bouton si aucun appareil n'est trouv√©.  Nous modifions le gestionnaire d'√©v√©nements "Timeout".  Permettez-moi de vous rappeler que les puces FTDI connect√©es √† un PC sont analys√©es deux fois par seconde, si elles sont d√©tect√©es et peuvent √™tre utilis√©es pour programmer des FPGA, leurs descripteurs sont ajout√©s √† la <code>Devices list</code> via la propri√©t√© <code>Strings[]</code> .  Nous cr√©ons la propri√©t√© <code>Disabled</code> pour "Programming", et si aucun p√©riph√©rique appropri√© n'est trouv√©, puis √©teignez et assombrissez le bouton. </p><br><div class="spoiler">  <b class="spoiler_title">D√©lai d'expiration du cas</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/wx/nf/5n/wxnf5n-ttwqqrsmbtydmttzcghw.png"></a> <br>  <em>Image cliquable</em> </p></div></div><br><h2 id="osvaivaem-gpio">  Ma√Ætriser GPIO </h2><br><p>  Une fois MPSSE activ√©, son utilisation s'effectue via le soi-disant "code d'op√©ration", et seuls <code>FT_Write</code> , <code>FT_Read</code> et <code>FT_Queue</code> sont utilis√©s √† partir des fonctions API <code>FT_Write</code> (pour conna√Ætre l'√©tat de la m√©moire tampon du r√©cepteur).  Nous cr√©ons le VI correspondant le long de la piste que nous avons cr√©√©e: FT_Write.vi, FT_Read.vi, FT_Queue.vi. </p><br><div class="spoiler">  <b class="spoiler_title">Un peu de routine</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/tw/or/ku/tworkua4o2qj3bntqoer1jb4o0u.png"><br>  <em>FT_Write.vi</em> </p><br><p><img src="https://habrastorage.org/webt/8k/pm/4s/8kpm4sdeaqgzlsctp-106wvtdz0.png"><br>  <em>Sch√©ma fonctionnel.</em>  <em>FT_Write.vi</em> </p><br><p><img src="https://habrastorage.org/webt/i0/px/18/i0px189plvqpokb3sijjuxtxbei.png"><br>  <em>FT_Read.vi</em> </p><br><p><img src="https://habrastorage.org/webt/ku/hm/xw/kuhmxw1j66symp05f0ergjkriag.png"><br>  <em>Sch√©ma fonctionnel.</em>  <em>FT_Read.vi</em> </p><br><p><img src="https://habrastorage.org/webt/bf/2s/q_/bf2sq_t4uinirm94vmh-ugkzqzy.png"><br>  <em>FT_Queue.vi</em> </p><br><p><img src="https://habrastorage.org/webt/5p/zm/dv/5pzmdvtnhtdq0ivxzfs0t32nfjk.png"><br>  <em>Sch√©ma fonctionnel.</em>  <em>FT_Queue.vi</em> </p></div></div><br><p>  √Ä partir de ces trois briques, nous pr√©sentons les VIs pour lire le port parall√®le et y √©crire.  La valeur est commod√©ment repr√©sent√©e sous la forme d'un tableau de variables bool√©ennes. </p><br><div class="spoiler">  <b class="spoiler_title">MPSSE_Set_LByte.vi et MPSSE_Get_LByte.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/oy/uh/8l/oyuh8lrdyniwp6ub2pvgwrxtlvw.png"><br>  <em>MPSSE_Set_LByte.vi</em> </p><br><p><img src="https://habrastorage.org/webt/g4/ab/u-/g4abu-lurodnce0udnamj1ftsjm.png"><br>  <em>Sch√©ma fonctionnel.</em>  <em>MPSSE_Set_LByte.vi</em> </p><br><p><img src="https://habrastorage.org/webt/7g/s9/5d/7gs95ddkb8pg9fjzt-s0vflzes4.png"><br>  <em>MPSSE_Get_LByte.vi</em> </p><br><p><img src="https://habrastorage.org/webt/ki/dm/n_/kidmn_ewfihbrokreabs90538p0.png"><br>  <em>Sch√©ma fonctionnel.</em>  <em>MPSSE_Get_LByte.vi</em> </p><br><p>  J'avoue que j'√©tais paresseux pour cr√©er une liste nomm√©e pour tous les op-codes, alors je les ai laiss√©s sous la forme de num√©ros magiques. </p></div></div><br><p>  Comme indiqu√© dans le tout premier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> , le protocole d'amor√ßage FPGA s√©rie passif n'est rien de plus qu'un SPI avec une manipulation de drapeau suppl√©mentaire.  Cinq branches au total sont utilis√©es: les <em>lignes DCLK</em> , <em>DATA [0]</em> , <em>nCONFIG</em> doivent √™tre configur√©es comme sorties, les <em>lignes</em> <em>nSTATUS</em> , <em>CONF_DONE</em> comme entr√©es. </p><br><div class="spoiler">  <b class="spoiler_title">Brochage de la disposition du tableau</b> <div class="spoiler_text"><table><thead><tr><th>  Broche FPGA </th><th>  Nom de broche </th><th>  Pin </th><th>  MPSSE </th><th>  Direction </th><th>  d√©faut </th></tr></thead><tbody><tr><td>  DCLK </td><td>  BDBUS0 </td><td>  38 </td><td>  TCK / SK </td><td>  Out </td><td>  0 </td></tr><tr><td>  DONN√âES [0] </td><td>  BDBUS1 </td><td>  39 </td><td>  TDI / DO </td><td>  Out </td><td>  1 </td></tr><tr><td>  nCONFIG </td><td>  BDBUS2 </td><td>  40 </td><td>  TDO / DI </td><td>  Out </td><td>  1 </td></tr><tr><td>  nSTATUS </td><td>  BDBUS3 </td><td>  41 </td><td>  TMS / CS </td><td>  Dans </td><td>  1 </td></tr><tr><td>  CONF_DONE </td><td>  BDBUS4 </td><td>  43 </td><td>  GPIOL0 </td><td>  Dans </td><td>  1 </td></tr></tbody></table></div></div><br><p>  Nous avons besoin d'un VP qui peut changer la valeur de la jambe s√©lectionn√©e sans affecter toutes les autres.  Tout d'abord, cr√©ez <code>Enum</code> avec les num√©ros de s√©rie des jambes dans le port, enregistrez-le sous "Strict Type Def" dans le fichier SP_LBYTE_BITS.ctl.  Nous cr√©ons un nouveau VI, ajoutons les terminaux de flux d'erreurs familiers.  Nous lisons la valeur actuelle du port parall√®le √† l'aide de MPSSE_Get_LByte.vi, utilisons la fonction <code>Replace Array Subset</code> pour modifier le bit souhait√© et r√©√©crivons la valeur sur le port (MPSSE_Set_LByte.vi). </p><br><div class="spoiler">  <b class="spoiler_title">SP_Set_Flag.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/y7/d3/ap/y7d3aps-9ima93quyatag0ggkui.png"><br>  <em>SP_Set_Flag.vi</em> </p><br><p><img src="https://habrastorage.org/webt/jn/ae/h4/jnaeh4ewehebgcba9fstkxnxa4o.png"><br>  <em>Sch√©ma fonctionnel.</em>  <em>SP_Set_Flag.vi</em> </p><br><p><img src="https://habrastorage.org/webt/ud/mt/jx/udmtjxpekkcskrmisie8t2h4hfw.png"><br>  <em>Enum SP_LBYTE_BITS.ctl</em> </p></div></div><br><p>  Pour commencer la configuration, le MPSSE doit g√©n√©rer une transition basse √† haute sur la ligne <em>nCONFIG</em> .  D√®s que le FPGA est pr√™t √† recevoir des donn√©es, il formera un niveau √©lev√© sur la ligne <em>nSTATUS</em> .  A ce stade, tout est pr√™t pour l'exp√©rience en fer.  Sur le sch√©ma fonctionnel SP_FT_MPSSE_FPGA.v nous ajoutons la ligne de contr√¥le <em>nCONFIG</em> - apr√®s l'initialisation du MPSSE nous donnons un niveau bas, puis haut.  Apr√®s chaque op√©ration (pour le d√©bogage), nous lisons l'√©tat des jambes de port. </p><br><div class="spoiler">  <b class="spoiler_title">SP_FT_MPSSE_FPGA.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/5q/8g/u1/5q8gu1k9oezxomhdblxqyjbxxas.png"><br>  <em>Au d√©marrage</em> </p><br><p><img src="https://habrastorage.org/webt/nj/qv/bv/njqvbvi3dibaezauuqh4t2thdo8.png"><br>  <em>Sch√©ma fonctionnel</em> </p></div></div><br><p>  En g√©n√©ral, lors du lancement du VI, il est clair que le FPGA r√©pond √† la transition sur la ligne <em>nCONFIG</em> - z√©ro est d√©fini sur la branche <em>nSTATUS</em> , puis un.  Mais il ne sera pas superflu de surveiller cela avec un oscilloscope.  Presque tout oscilloscope √† deux canaux avec d√©clenchement par d√©clenchement (veille) convient.  Canal <strong>A</strong> (piste bleue) Je mets dans le point de contr√¥le du circuit <em>nCONFIG</em> , canal <strong>B</strong> (piste rouge) - cha√Æne <em>nSTATUS</em> .  Le d√©clencheur est r√©gl√© sur le front descendant du canal <strong>A.</strong> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/ca/b9/ti/cab9tizq5kpbnbguzew2avmi_je.png"></a> <br>  <em>L'image est cliquable.</em>  <em>Avec les d√©tails!</em> </p><br><h2 id="rabota-s-faylom">  Travailler avec un fichier </h2><br><p>  FPGA est pr√™t √† accepter le fichier de configuration.  Sommes-nous pr√™ts √† transf√©rer le fichier sur le FPGA? </p><br><p>  LabVIEW contient un ensemble complet d'outils pour travailler avec des fichiers.  Je ne peux pas dire que la fonctionnalit√© est suffisante pour absolument toute la gamme des t√¢ches, cependant, les op√©rations de base telles que la <em>lecture</em> et l' <em>√©criture</em> sont effectu√©es facilement et agr√©ablement.  Le jeu de base de VIs pour travailler avec des fichiers se trouve dans le panneau "File I / O".  Pour r√©soudre le probl√®me, vous devez ouvrir le fichier de configuration, √©valuer sa taille (nous devons savoir combien d'octets envoyer le FPGA), le lire et le fermer.  Tout est simple et l'un apr√®s l'autre.  Nous utilisons les <code>refnum</code> <code>Open/Create/Replace File</code> , <code>Get File Size</code> , <code>Read from Binary File</code> , <code>Close File</code> , les combiner avec la cha√Æne de flux d'erreurs et <code>refnum</code> - un num√©ro, tel qu'un descripteur de fichier, est cr√©√© lorsque le fichier est ouvert et doit √™tre transf√©r√© √† l'entr√©e d'autres VIs travaillant avec ce fichier. </p><br><p>  Jusqu'√† pr√©sent, nous n'avons nulle part o√π disposer des donn√©es lues, mais si vous voulez vraiment v√©rifier l'op√©rabilit√© de la cha√Æne, vous pouvez cr√©er un indicateur de type <code>String</code> et le configurer un peu.  Dans le menu contextuel, activez l'option "Affichage hexad√©cimal", activez la barre de d√©filement verticale (√âl√©ments visibles -&gt; Barre de d√©filement verticale) et apr√®s le lancement, nous observons le contenu du fichier de configuration binaire. </p><br><div class="spoiler">  <b class="spoiler_title">SP_FT_MPSSE_FPGA.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/7w/r8/dy/7wr8dyzaxomkxwmqioien0rn2om.png"><br>  <em>Face avant</em>  <em>Nous regardons le contenu du fichier</em> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/qf/8l/vv/qf8lvvjj6xtwo_be0aiu-3aa2co.png"></a> <br>  <em>Sch√©ma fonctionnel.</em>  <em>Karinka cliquable</em> </p></div></div><br><p>  Deux lignes de code parall√®les ind√©pendantes form√©es sur le diagramme du VI, par cons√©quent, des cha√Ænes d'erreur distinctes sont utilis√©es pour elles.  Afin de r√©duire les flux parall√®les dans un terminal <code>Error Out</code> , la fonction <code>Merge Errors</code> est utilis√©e.  Cette fonction recherche les erreurs d'entr√©e de haut en bas (oui, il peut y avoir plus de deux terminaux d'entr√©e, elle est √©tir√©e par la souris) et retourne le premier qu'elle trouve.  S'il n'y a pas d'erreur, il renvoie le premier message d'avertissement.  S'il n'y a pas d'avertissement, il n'y a pas d'erreur sur la sortie.  Il est important de noter que l'ordre de connexion des entr√©es <code>Merge Errors</code> d√©termine la priorit√© des erreurs, et si une erreur se produit dans deux cha√Ænes √† la fois, l'erreur inf√©rieure sera ignor√©e.  Cela doit √™tre trait√© avec soin. </p><br><p>  Si nous essayons d'appuyer sur le bouton "Programme" dans le VI de niveau sup√©rieur sans s√©lectionner de fichier, l'entr√©e SP_FT_MPSSE_FPGA.vi recevra un chemin vide, ce qui provoquera l'erreur "Erreur 1430. LabVIEW: (Hex 0x596) Le chemin est vide ou relatif. Vous devez utiliser un chemin absolu. "  Comme le dit mon ami d'enfance: "Bagatelles, c'est quelque chose de mondain!"  Et cette erreur n'est pas du tout une erreur, mais l'inattention de l'utilisateur.  Nous n'arr√™terons pas le programme et ne le jurerons qu'avec une fen√™tre avec une croix rouge, nous supprimons simplement l'erreur avec ce code du flux et dans la bo√Æte de dialogue, nous recommandons √† l'utilisateur de d√©cider du fichier.  Pour filtrer l'erreur, utilisez le VI "Effacer les erreurs" de la palette "Bo√Æte de dialogue et interface utilisateur".  Pour afficher le message - "Bo√Æte de dialogue √† un bouton". </p><br><p><img src="https://habrastorage.org/webt/o2/nf/bm/o2nfbmdreh3hdppvxsabj7hsgt4.png"></p><br><div class="spoiler">  <b class="spoiler_title">Sch√©ma fonctionnel</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/-6/ik/cp/-6ikcptiqxx7uloza1v2g5y6wdo.png"></a> <br>  <em>Image cliquable</em> </p></div></div><br><h2 id="zagruzka-konfiguracii">  T√©l√©charger la configuration </h2><br><p>  Pour le transfert de donn√©es s√©rie, le processeur MPSSE doit envoyer l'op-code 0x18, les arguments de commande seront la longueur de la s√©quence transmise (deux octets, en commen√ßant par le plus bas), et la s√©quence de donn√©es elle-m√™me.  La longueur est cod√©e moins un.  Envoyons le bloc de donn√©es en tant que VI MPSSE_send. </p><br><div class="spoiler">  <b class="spoiler_title">MPSSE_Send.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/my/du/hi/myduhilu9cbsm8f3j_ceduagppq.png"><br>  <em>MPSSE_Send.vi</em> </p><br><p><img src="https://habrastorage.org/webt/fv/13/9m/fv139mrjy-t8l8cz-u82btswts8.png"><br>  <em>Sch√©ma fonctionnel</em> </p></div></div><br><p>  La taille du tampon d'entr√©e ( <code>Array Size</code> ) est convertie en un type √† double octet <code>U16</code> , nous soustrayons un, √©changeons les octets bas et hauts ( <code>Swap Bytes</code> ) - vous devez envoyer la longueur en commen√ßant par la plus basse et convertir le nombre √† deux octets en un tableau √† un octet ( <code>Type Cast</code> ). </p><br><p>  La fonction <code>Type Cast</code> m√©rite une attention particuli√®re.  Il s'agit d'un tel convertisseur de type universel, dont l'ing√©niosit√© est parfois tr√®s surprenante.  Bref, alors: </p><br><p><img src="https://habrastorage.org/webt/k9/qp/0t/k9qp0tiyjs2ajjgisnhbfuaonpe.png"><br>  <em>Visuellement pour le programmeur</em> </p><br><p>  Cependant, il ne s'agit pas simplement de convertir des donn√©es dans un type diff√©rent, c'est √©galement une interpr√©tation heuristique.  Cette fonction vous permet d'effectuer une conversion entre des types de donn√©es incompatibles, tandis que la fonction n'h√©site pas √† aligner les donn√©es d'entr√©e et m√™me √† supprimer les parties "suppl√©mentaires".  Si le type de donn√©es demand√© n√©cessite plus de m√©moire que les donn√©es d'entr√©e, la fonction allouera la quantit√© manquante.  Pour un d√©veloppeur novice, LabVIEW <code>Type Cast</code> peut devenir une bou√©e de sauvetage, mais en grandissant, il vaut mieux refuser un tel convertisseur - il est tr√®s cach√© aux yeux et peut devenir une source d'erreurs inattendues.  Il est pr√©f√©rable d'utiliser des m√©thodes de conversion plus explicites, telles que <code>Coerce To Type</code> . </p><br><p>  Lors de l'initialisation du processeur MPSSE, nous avons d√©fini la taille maximale autoris√©e du tampon pour le transfert de donn√©es √† 65536 octets, nous devons donc diviser le fichier de configuration en fragments dont la taille ne d√©passe pas la taille sp√©cifi√©e.  Nous utiliserons la fonction <code>Array Subset</code> , cette fonction s√©lectionne un sous-tableau dans le tableau en commen√ßant par l'√©l√©ment d' <code>index</code> et une longue <code>length</code> .  Nous allons le casser dans une boucle <code>While</code> , nous augmenterons chaque it√©ration de l'index de 65536, entre les it√©rations nous passerons la valeur √† travers le registre √† d√©calage.  D√®s qu'il n'est pas possible de pincer 65536 octets du tableau principal, nous prenons tout ce qui reste, l'envoyons et arr√™tons le cycle. </p><br><p>  Selon le protocole de t√©l√©chargement, une fois toutes les donn√©es transf√©r√©es, deux impulsions d'horloge suppl√©mentaires doivent √™tre appliqu√©es pour d√©marrer l'initialisation du FPGA.  Pour ce faire, apr√®s la boucle, nous envoyons un autre octet "vide". </p><br><div class="spoiler">  <b class="spoiler_title">SP_FT_MPSSE_FPGA.vi</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/vp/y4/wr/vpy4wrsts1szqayvnquvjtb2nzw.png"></a> <br>  <em>Image cliquable</em> </p></div></div><br><p>  Afin de comprendre le succ√®s du firmware, nous consid√©rons les drapeaux, et si <em>CONF_DONE est</em> d√©fini sur un, nous <em>signalons</em> au VI de niveau sup√©rieur que tout est OK. </p><br><p>  Le programme est termin√©.  Il reste √† s'assurer que le FPGA clignote correctement et que la carte clignote joyeusement avec des LED. </p><br><h2 id="pro-imenovanie-vp">  √Ä propos de VP Naming </h2><br><p>     ,             ,       LabVIEW, ,      SubVI.              .        : </p><br><ul><li>    ‚Äî  ,     FTDI,           API D2XX.            "FT",  FT_Close.vi  FT_Read.vi. </li><li>   ‚Äî     MPSSE.        "MPSSE". : MPSSE_open.vi, MPSSE_Set_LByte.vi, MPSSE_Get_LByte.vi. </li><li>   ‚Äî    "Passive Serial"  MPSSE.     "S". , SP_FT_MPSSE_FPGA.vi ( ,   )  SP_LBYTE_BITS.ctl. </li><li>  .   .    , . </li></ul><br><p>     ( ),             .          <em>subVI</em> . </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  ,     ,           . </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/ff/i0/fq/ffi0fqqs7gbi3aczbucvusrw2qi.jpeg"></p></div></div><br><p>         ,        LabVIEW,        .    ,     ,        ,         (    ).         . </p><br><h2 id="materialy-po-teme">  Mat√©riel connexe </h2><br><ol><li>  . LabVIEW:  .  Per.  de l'anglais  .  .‚Äì .: <br>  , 2008 ‚Äì 400 .: . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">labview_mpsse</a> .   . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">   </a> .    </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Software Application Development D2XX Programmer's Guide</a> .   API D2XX. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr429448/">https://habr.com/ru/post/fr429448/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es436938/index.html">Guix es el sistema operativo m√°s avanzado.</a></li>
<li><a href="../fr429420/index.html">La PlayStation Classic utilise l'√©mulateur PCSX ReARMed pour le fonctionnement, pas de solutions propri√©taires</a></li>
<li><a href="../fr429422/index.html">UHCI, ou le tout premier USB</a></li>
<li><a href="../fr429424/index.html">Robotaxi de Daimler et Bosch appara√Ætra en Californie</a></li>
<li><a href="../fr429426/index.html">Exportation de QGIS et de tuiles</a></li>
<li><a href="../fr429450/index.html">Techniques de programmation g√©n√©ralis√©es dans Rust: comment nous avons traduit Exonum de Iron en actix-web</a></li>
<li><a href="../fr429452/index.html">Le Pentagone a commenc√© √† d√©classifier les logiciels malveillants d'autres personnes</a></li>
<li><a href="../fr429456/index.html">D√©j√† une histoire: o√π la culture startup a-t-elle commenc√© dans les ann√©es 30</a></li>
<li><a href="../fr429458/index.html">Comment j'ai fait des animations du syst√®me solaire pour un fils de deuxi√®me ann√©e</a></li>
<li><a href="../fr429460/index.html">R√©sum√© du rapport ¬´Que savons-nous des microservices¬ª (HL2018, Avito, Vadim Madison)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>