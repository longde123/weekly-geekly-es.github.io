<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💂 🚑 👨‍🎨 Sistem pekerjaan. Tinjauan dari sisi lain 👔 🏅 ✊🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam versi baru unity pada 2018, mereka akhirnya secara resmi menambahkan sistem komponen Entity baru , atau ECS singkatnya, yang memungkinkan Anda u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sistem pekerjaan. Tinjauan dari sisi lain</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420829/">  Dalam versi baru <b>unity pada</b> 2018, mereka akhirnya secara resmi menambahkan <b>sistem komponen Entity</b> baru <b>,</b> atau <b>ECS</b> singkatnya, yang memungkinkan Anda untuk hanya bekerja dengan data mereka alih-alih pekerjaan biasa dengan komponen objek. <br><br>  Sistem tugas tambahan menawarkan Anda untuk menggunakan daya komputasi paralel untuk meningkatkan kinerja kode Anda. <br><a name="habracut"></a><br>  Bersama-sama, kedua sistem baru ini ( <b>ECS</b> dan <b>Sistem Pekerjaan</b> ) menawarkan tingkat pemrosesan data yang baru. <br><br>  Khususnya, dalam artikel ini saya tidak akan menganalisis seluruh sistem <b>ECS</b> , yang saat ini tersedia sebagai seperangkat alat yang dapat diunduh secara terpisah dalam <b>kesatuan</b> , tetapi hanya akan mempertimbangkan sistem tugas dan bagaimana hal itu dapat digunakan di luar paket <b>ECS</b> . <br><br><h3>  Sistem baru </h3><br>  Awalnya, <b>persatuan</b> digunakan untuk dapat menggunakan komputasi multi-threaded, tetapi semua ini harus dibuat oleh pengembang sendiri, untuk menyelesaikan masalah sendiri dan untuk mengatasi perangkap.  Dan jika sebelumnya perlu untuk bekerja secara langsung dengan hal-hal seperti membuat utas, menutup utas, sinkronisasi, sekarang semua pekerjaan ini jatuh di pundak mesin, dan pengembang sendiri hanya perlu membuat tugas dan menyelesaikannya. <br><br><h3>  Tugasnya </h3><br>  Untuk melakukan perhitungan dalam sistem baru, perlu untuk menggunakan tugas yang merupakan objek yang terdiri dari metode dan data untuk perhitungan. <br><br>  Seperti data lainnya dalam sistem <b>ECS</b> , tugas dalam <b>Sistem Pekerjaan</b> juga direpresentasikan sebagai struktur yang mewarisi salah satu dari tiga antarmuka. <br><br><h4>  Ijob </h4><br>  Antarmuka tugas paling sederhana yang berisi satu metode <b>Jalankan</b> yang tidak mengambil apa pun dalam bentuk parameter dan tidak mengembalikan apa pun. <br><br>  Tugas itu sendiri terlihat seperti ini: <br><br><div class="spoiler">  <b class="spoiler_title">Ijob</b> <div class="spoiler_text"><pre><code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct JobStruct : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() {} }</code> </pre> <br></div></div><br>  Dalam metode <b>Jalankan</b> , Anda dapat melakukan perhitungan yang diperlukan. <br><br><h4>  IJobParallelFor </h4><br>  Antarmuka lain dengan metode <b>Jalankan yang</b> sama, yang pada gilirannya sudah menerima <b>indeks</b> parameter numerik. <br><br><div class="spoiler">  <b class="spoiler_title">IJobParallelFor</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct JobStruct : IJobParallelFor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index) {} }</code> </pre> <br></div></div><br>  Antarmuka <b>IJobParallelFor</b> ini, tidak seperti antarmuka <b>IJob</b> , menawarkan untuk mengeksekusi tugas beberapa kali dan tidak hanya mengeksekusi, tetapi memecah eksekusi ini menjadi blok yang akan didistribusikan di antara utas. <br><br>  <i>Tidak jelas</i>  <i>Jangan khawatir tentang ini, saya akan memberi tahu Anda lebih banyak.</i> <br><br><h4>  IJobParallelForTransform </h4><br>  Dan antarmuka khusus terakhir, yang, seperti namanya, dirancang untuk bekerja dengan transformasi objek.  Ini juga berisi metode <b>Execute</b> , dengan <b>indeks</b> parameter numerik dan parameter <b>TransformAccess di</b> mana posisi, ukuran dan rotasi transformasi berada. <br><br><div class="spoiler">  <b class="spoiler_title">IJobParallelForTransform</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct JobStruct : IJobParallelForTransform { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index, TransformAccess transform) {} }</code> </pre> <br></div></div><br>  Karena kenyataan bahwa Anda tidak dapat bekerja dengan objek <b>kesatuan</b> secara langsung dalam tugas, antarmuka ini hanya dapat memproses transformasi data sebagai struktur <b>TransformAccess yang</b> terpisah. <br><br>  Selesai, sekarang Anda tahu bagaimana struktur tugas dibuat, Anda dapat melanjutkan untuk berlatih. <br><br><h3>  Penyelesaian tugas </h3><br>  Mari kita membuat tugas sederhana yang diwarisi dari antarmuka <b>IJob</b> dan menyelesaikannya.  Untuk ini, kita memerlukan skrip <b>MonoBehaviour</b> sederhana dan struktur tugas itu sendiri. <br><br><div class="spoiler">  <b class="spoiler_title">Testjob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() {} }</code> </pre> <br></div></div><br>  Sekarang letakkan skrip ini pada beberapa objek di tempat kejadian.  Dalam skrip yang sama ( <b>TestJob</b> ) di bawah ini kami akan menulis struktur tugas dan jangan lupa untuk mengimpor perpustakaan yang diperlukan. <br><br><div class="spoiler">  <b class="spoiler_title">Pekerjaan sederhana</b> <div class="spoiler_text"><pre> <code class="actionscript hljs">using Unity.Jobs; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Hello parallel world!"</span></span>); } }</code> </pre> <br></div></div><br>  Dalam metode <b>Execute</b> , misalnya, cetak garis sederhana ke konsol. <br><br>  Sekarang mari kita beralih ke metode <b>Mulai</b> skrip <b>TestJob</b> , di mana kita akan membuat turunan tugas dan kemudian menjalankannya. <br><br><div class="spoiler">  <b class="spoiler_title">Testjob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.Schedule().Complete(); } }</code> </pre> <br></div></div><br>  Jika Anda melakukan semuanya seperti pada contoh, maka setelah memulai gim Anda akan mendapatkan pesan sederhana ke konsol seperti pada gambar. <br><br><img src="https://lh6.googleusercontent.com/QQeMBMeZy0HVw0r_D5Q_cH4k6Zzt-HAC6uev1O4pR--mOh96C2TQvw5DTH1X3ZPE7LORJ4wdV5kyKjGiJzVWLFm-HBi8HzSP4-DlbrYa65eRV1RF672uwsLsZvrCKtF5CdaGJ5tj" alt="gambar"><br><br>  Apa yang terjadi di sini: setelah memanggil metode <b>Jadwal</b> , penjadwal menempatkan tugas di pegangan dan sekarang dapat diselesaikan dengan memanggil metode <b>Lengkap</b> . <br><br>  Ini adalah contoh tugas yang hanya mencetak teks ke konsol.  Untuk tugas untuk melakukan komputasi paralel apa pun, perlu mengisinya dengan data. <br><br><h3>  Data dalam tugas </h3><br>  Seperti dalam sistem <b>ECS</b> , dalam tugas tidak ada akses ke objek <b>kesatuan</b> , Anda tidak bisa memasukkan <b>GameObject</b> ke dalam tugas dan mengubah namanya di sana.  Yang dapat Anda lakukan adalah mentransfer beberapa parameter objek terpisah ke tugas, mengubah parameter ini, dan setelah menyelesaikan tugas, menerapkan perubahan ini kembali ke objek. <br><br>  Ada beberapa batasan untuk data dalam tugas itu sendiri: pertama, itu harus struktur, dan kedua, itu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak</a> boleh tipe data yang dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dikonversi</a> , yaitu, Anda tidak bisa meneruskan <b>boolean</b> atau <b>string yang sama</b> ke tugas. <br><br><div class="spoiler">  <b class="spoiler_title">Pekerjaan sederhana</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float a, b; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() { float result = a + b; Debug.Log(result); } }</code> </pre> <br></div></div><br>  Dan kondisi utama: data yang tidak tertutup dalam wadah hanya dapat diakses di dalam tugas! <br><br><h3>  Wadah </h3><br>  Saat bekerja dengan komputasi multi-utas, ada kebutuhan untuk bertukar data antar utas.  Agar dapat mentransfer data ke dalamnya dan membacanya kembali di sistem tugas, untuk tujuan ini ada wadah.  Wadah-wadah ini disajikan dalam bentuk struktur biasa dan saya bekerja berdasarkan prinsip jembatan yang dengannya data dasar disinkronkan di antara aliran. <br><br>  Ada beberapa jenis wadah: <br>  <b>NativeArray</b> .  Jenis wadah yang paling sederhana dan paling sering digunakan disajikan sebagai array sederhana dengan ukuran tetap. <br>  <b>NativeSlice</b> .  Wadah lain - array, seperti yang jelas dari terjemahan, dirancang untuk memotong NativeArray menjadi beberapa bagian. <br><br>  Ini adalah dua wadah utama yang tersedia tanpa menghubungkan sistem <b>ECS</b> .  Dalam versi yang lebih maju, ada beberapa jenis wadah. <br><br>  <b>NativeList</b> .  Ini adalah daftar data reguler. <br>  <b>NativeHashMap</b> .  Analog kamus dengan kunci dan nilai. <br>  <b>NativeMultiHashMap</b> .  <b>NativeHashMap yang</b> sama dengan hanya beberapa nilai di bawah satu kunci. <br>  <b>NativeQueue</b>  Daftar antrian data. <br><br>  Karena kita bekerja tanpa menghubungkan sistem <b>ECS</b> , hanya <b>NativeArray</b> dan <b>NativeSlice</b> yang tersedia untuk <b>kita</b> . <br><br>  Sebelum melanjutkan ke bagian praktis, perlu untuk menganalisis poin yang paling penting - penciptaan instance. <br><br><h3>  Buat Kontainer </h3><br>  Seperti yang saya katakan sebelumnya, kontainer ini mewakili jembatan di mana data disinkronkan di antara utas.  Sistem tugas membuka jembatan ini sebelum mulai bekerja dan menutupnya setelah selesai.  Proses pembukaan disebut " <i>alokasi</i> " ( <b>Alokasi</b> ) atau <i>"alokasi memori"</i> , proses penutupan disebut " <i>pelepasan sumber daya</i> " ( <b>Buang</b> ). <br><br>  Alokasi inilah yang menentukan berapa lama tugas dapat menggunakan data dalam wadah - dengan kata lain, berapa lama jembatan akan terbuka. <br><br>  Untuk lebih memahami kedua proses ini, mari kita lihat gambar di bawah ini. <br><br><img src="https://lh4.googleusercontent.com/6yL2x_ynGZj1C1ukkQlfDZuYKzlvJ4ceAYU9Zyb40xwDzuASeUNB__Od067_3xZkYANEOPl84JoKLyqTPn4hrvQNogbksb7akoQvcWjDLg2yyUJY9eF37uj7TO0YkOL3cQyMsXPu" alt="gambar"><br><br>  Bagian bawah menunjukkan siklus hidup utas utama (utas <b>utama</b> ), yang dihitung dalam jumlah frame, pada frame pertama, kami membuat utas paralel lain ( <b>utas baru)</b> yang ada untuk sejumlah frame tertentu dan kemudian ditutup dengan aman. <br>  Di <b>utas baru yang</b> sama tugas dengan wadah tiba. <br><br>  Sekarang lihat bagian atas gambar. <br><br><img src="https://lh5.googleusercontent.com/1IZ_CMZhX4JfBWBLEuAijf1st_6e7p96EncPomR_jLNhQVbJDvS_o_-gf1emw3glwEGt8y3xXARp4xJJ9qu0WjYTH4asrblwul2rHa_SqQiLzrTTOoDJ5DlomcPBP8qkfCI3w9R8" alt="gambar"><br><br>  <b>Alokasi</b> bilah putih menunjukkan masa pakai wadah.  Dalam bingkai pertama, wadah <i>dialokasikan</i> - jembatan dibuka, sampai saat ini wadah tidak ada, setelah semua perhitungan dalam tugas selesai, wadah dibebaskan dari memori dan pada frame ke-9 jembatan ditutup. <br><br>  Juga pada strip ini ( <b>Alokasi</b> ) ada segmen waktu ( <b>Temp</b> , <b>TempJob</b> dan <b>Presistent</b> ), masing-masing segmen ini menunjukkan perkiraan masa pakai wadah. <br><br>  Mengapa segmen ini diperlukan !?  Faktanya adalah bahwa eksekusi suatu tugas berdasarkan durasi dapat berbeda, kita dapat mengeksekusinya secara langsung dalam metode yang sama dengan yang kita buat, atau kita dapat memperpanjang waktu eksekusi tugas jika cukup rumit, dan segmen-segmen ini menunjukkan seberapa mendesak dan berapa lama tugas dapat menggunakan data dalam wadah. <br><br>  <i>Jika masih belum jelas, saya akan menganalisis setiap jenis alokasi menggunakan contoh.</i> <br><br>  Sekarang kita dapat beralih ke bagian praktis membuat wadah, untuk ini kita kembali ke metode <b>Mulai</b> skrip <b>TestJob</b> dan membuat contoh baru wadah <b>NativeArray</b> dan jangan lupa untuk menghubungkan perpustakaan yang diperlukan. <br><br><h3>  Temp </h3><br><div class="spoiler">  <b class="spoiler_title">Testjob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs">using Unity.Jobs; using Unity.Collections; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); } }</code> </pre> <br></div></div><br>  Untuk membuat instance wadah baru, Anda harus menentukan ukuran dan jenis alokasi dalam konstruktornya.  Contoh ini menggunakan tipe <b>Temp</b> , karena tugas akan dilakukan hanya dalam metode <b>Mulai</b> . <br><br>  Sekarang inisialisasi variabel array yang sama persis dalam struktur tugas <b>SimpleJob</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Pekerjaan sederhana</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;int&gt; array; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() {} }</code> </pre> <br></div></div><br>  Selesai  Sekarang Anda dapat membuat tugas itu sendiri dan mengirimkan contoh array ke sana. <br><br><div class="spoiler">  <b class="spoiler_title">Mulai</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = array; }</code> </pre> <br></div></div><br>  Untuk menjalankan tugas kali ini, kami akan menggunakan pegangan <b>JobHandle</b> untuk mendapatkannya dengan memanggil metode <b>Jadwal yang</b> sama. <br><br><div class="spoiler">  <b class="spoiler_title">Mulai</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = array; JobHandle handle = job.Schedule(); }</code> </pre> <br></div></div><br>  Sekarang Anda dapat memanggil metode <b>Lengkap</b> pada pegangannya dan memeriksa apakah tugas tersebut selesai untuk menampilkan teks di konsol. <br><br><div class="spoiler">  <b class="spoiler_title">Mulai</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = array; JobHandle handle = job.Schedule(); handle.Complete(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handle.IsCompleted) print(<span class="hljs-string"><span class="hljs-string">" "</span></span>); }</code> </pre> <br></div></div><br>  Jika Anda menjalankan tugas dalam formulir ini, maka setelah memulai permainan Anda akan mendapatkan kesalahan merah besar yang mengatakan bahwa Anda tidak melepaskan wadah array dari sumber setelah tugas selesai. <br><br>  Sesuatu seperti itu. <br><br><img src="https://lh3.googleusercontent.com/EewKhLiPm0_qidpB0-YnlUfbTcIlzOhPw_OXgJqcmm-m9MpAaq96PHSc-FlN7GNArl9JkThBUZEGM9YFIHR5BkkMRUBwTAM6awQAEYGOw45i31irFlXtkT7peTOmjFfoEq_ASONA" alt="gambar"><br><br>  Untuk menghindarinya, panggil metode <b>Buang</b> di wadah setelah menyelesaikan tugas. <br><br><div class="spoiler">  <b class="spoiler_title">Mulai</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = array; JobHandle handle = job.Schedule(); handle.Complete(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handle.IsCompleted) print(<span class="hljs-string"><span class="hljs-string">"Complete"</span></span>); array.Dispose(); }</code> </pre> <br></div></div><br>  Maka Anda dapat memulai kembali dengan aman. <br>  Tetapi tugas itu tidak melakukan apa-apa!  - lalu tambahkan beberapa tindakan untuk itu. <br><br><div class="spoiler">  <b class="spoiler_title">Pekerjaan sederhana</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;int&gt; array; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.Length; i++) { array[i] = i * i; } } }</code> </pre> <br></div></div><br>  Dalam metode <b>Execute</b> , saya mengalikan indeks setiap elemen array sendiri dan menulisnya kembali ke array <b>array</b> untuk mencetak hasilnya ke konsol dalam metode <b>Start</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Mulai</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = array; JobHandle handle = job.Schedule(); handle.Complete(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handle.IsCompleted) print(job.array[job.array.Length - <span class="hljs-number"><span class="hljs-number">1</span></span>]); array.Dispose(); }</code> </pre> <br></div></div><br><blockquote>  Apa yang akan menjadi hasil di konsol jika kita mencetak elemen terakhir dari kuadrat? </blockquote><br>  Ini adalah bagaimana Anda dapat membuat wadah, menaruhnya dalam tugas dan melakukan tindakan pada wadah tersebut. <br><br>  Ini adalah contoh menggunakan tipe alokasi <b>Temp</b> , yang menyiratkan menyelesaikan tugas dalam satu bingkai.  Jenis ini paling baik digunakan ketika Anda perlu melakukan perhitungan dengan cepat tanpa memuat utas utama, tetapi Anda harus berhati-hati jika tugasnya terlalu rumit atau jika akan ada banyak, kendur dapat terjadi, dalam hal ini lebih baik menggunakan jenis <b>TempJob,</b> yang akan saya analisis nanti. <br><br><h3>  Tempjob </h3><br>  Dalam contoh ini, saya akan sedikit <b>mengubah</b> struktur tugas <b>SimpleJob</b> dan mewarisinya dari antarmuka <b>IJobParallelFor</b> lainnya. <br><br><div class="spoiler">  <b class="spoiler_title">Pekerjaan sederhana</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJobParallelFor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Vector2&gt; array; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index) {} }</code> </pre> <br></div></div><br>  Juga, karena tugas akan berjalan lebih lama dari satu bingkai, kami akan mengeksekusi dan mengumpulkan hasil tugas dalam berbagai metode <b>Sedar</b> dan <b>Mulai</b> yang disajikan dalam bentuk coroutine.  Untuk melakukan ini, ubah penampilan kelas <b>TestJob sedikit</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Testjob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NativeArray&lt;Vector2&gt; array; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> JobHandle handle; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() {} IEnumerator Start() {} }</code> </pre> <br></div></div><br>  Dalam metode <b>Sedarlah</b> , kita akan membuat tugas dan wadah vektor, dan dalam metode <b>Mulai</b> , output data yang diterima dan sumber daya rilis. <br><br><div class="spoiler">  <b class="spoiler_title">Bangun</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">100</span></span>, Allocator.TempJob); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array; }</code> </pre> <br></div></div><br>  Di sini sekali lagi, wadah <b>array</b> dibuat dengan jenis alokasi <b>TempJob</b> , setelah itu kami membuat tugas dan menanganinya dengan memanggil metode <b>Jadwal</b> dengan perubahan kecil. <br><br><div class="spoiler">  <b class="spoiler_title">Bangun</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">100</span></span>, Allocator.TempJob); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle = job.Schedule(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) }</code> </pre> <br></div></div><br>  Parameter pertama dalam metode <b>Jadwal</b> menunjukkan berapa kali tugas akan dieksekusi, berikut adalah jumlah yang sama dengan ukuran array <b>array</b> . <br>  Parameter kedua menunjukkan berapa banyak blok untuk berbagi tugas. <br><br>  <i>Blok apa lagi?</i> <br>  Sebelumnya, untuk menyelesaikan tugas, utas hanya memanggil metode <b>Eksekusi</b> sekali, sekarang perlu memanggil metode ini 100 kali, sehingga penjadwal membagi 100 kali repetisi ini ke dalam blok yang didistribusikan di antara utas agar tidak memuat utas terpisah.  Dalam contoh, seratus pengulangan akan dibagi menjadi 5 blok, masing-masing 20 pengulangan, yaitu, penjadwal mungkin akan mendistribusikan 5 blok ini ke dalam 5 utas, di mana setiap utas akan memanggil metode <b>Jalankan</b> 20 kali.  Dalam praktiknya, tentu saja, bukan fakta bahwa penjadwal akan melakukan hal itu, semuanya tergantung pada beban kerja sistem, jadi mungkin semua 100 pengulangan akan terjadi dalam satu utas. <br><br>  Sekarang Anda dapat memanggil metode <b>Lengkap</b> pada gagang tugas. <br><br><div class="spoiler">  <b class="spoiler_title">Bangun</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">100</span></span>, Allocator.TempJob); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle = job.Schedule(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.Complete(); }</code> </pre> <br></div></div><br>  Di <b>Mulai</b> coroutine, kami akan memeriksa pelaksanaan tugas dan kemudian kami akan membersihkan wadah. <br><br><div class="spoiler">  <b class="spoiler_title">Mulai</b> <div class="spoiler_text"><pre> <code class="actionscript hljs">IEnumerator Start() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.isCompleted == <span class="hljs-literal"><span class="hljs-literal">false</span></span>){ yield <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForEndOfFrame(); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array.Dispose(); }</code> </pre> <br></div></div><br>  Sekarang mari kita beralih ke tindakan dalam tugas itu sendiri. <br><br><div class="spoiler">  <b class="spoiler_title">Pekerjaan sederhana</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJobParallelFor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Vector2&gt; array; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index) { float x = index; float y = index; Vector2 vector = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(x * x, y * y / (y * <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array[index] = vector; } }</code> </pre> <br></div></div><br>  Setelah menyelesaikan tugas dalam metode <b>Mulai</b> , tampilkan semua elemen array di konsol. <br><br><div class="spoiler">  <b class="spoiler_title">Mulai</b> <div class="spoiler_text"><pre> <code class="actionscript hljs">IEnumerator Start() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.IsCompleted == <span class="hljs-literal"><span class="hljs-literal">false</span></span>){ yield <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForEndOfFrame(); } foreach(Vector2 vector <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array) { print(vector); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array.Dispose(); }</code> </pre> <br></div></div><br>  Selesai, Anda bisa berlari dan melihat hasilnya. <br><br>  Untuk memahami perbedaan antara <b>IJob</b> dan <b>IJobParallelFor,</b> lihat gambar di bawah ini. <br>  Sebagai contoh, <b>IJob</b> juga dapat menggunakan loop sederhana <b>untuk</b> melakukan perhitungan beberapa kali, tetapi dalam kasus apa pun, utas hanya dapat memanggil metode <b>Jalankan</b> sekali selama seluruh durasi tugas - ini adalah cara membuat satu orang melakukan ratusan tindakan yang sama secara berturut-turut. <br><br><img src="https://lh3.googleusercontent.com/qUadSqRojz1W8kiqtm-xgi-TYeJ9IlVh38o0MrG0mTWnU3j0qTjtTOWa8pkPc0kjPQcTKoqOJtNl6E4Olb5MKCNgUhrsAXGujN0flm_YVoFfEVS9kCCjFOucANAw74Kjq2W_Zzho" alt="gambar"><br><br>  <b>IJobParallelFor</b> menawarkan tidak hanya untuk mengeksekusi tugas dalam satu utas beberapa kali, tetapi juga untuk mendistribusikan repetisi ini di antara utas lainnya. <br><br><img src="https://lh5.googleusercontent.com/-5ggH4tUKWvhz6I8UUi2eGzqY_B_QqA1PA_298vp89xg4v2yC3wn3N9D8TlVOMwWuDM593H_Aw9WZOU-_esyT7vyL4MM17bZaevfiOiYSEUb0I1oT2Fi3cXbBtoc9SuMYIhVnMc7" alt="gambar"><br><br>  Secara umum, jenis alokasi <b>TempJob sangat</b> cocok untuk sebagian besar tugas yang dilakukan pada beberapa bingkai. <br><br>  Tetapi bagaimana jika Anda perlu menyimpan data bahkan setelah menyelesaikan tugas, bagaimana jika setelah menerima hasil Anda tidak perlu menghancurkannya segera.  Untuk ini, perlu menggunakan jenis alokasi <b>Persistent</b> , yang menyiratkan pelepasan sumber daya kemudian " <i>bila perlu!"</i>  . <br><br><h3>  Gigih </h3><br>  <b>Mari kita</b> kembali ke kelas <b>TestJob</b> dan mengubahnya.  Sekarang kita akan membuat tugas dalam metode <b>OnEnable</b> , memeriksa pelaksanaannya dalam metode <b>Pembaruan</b> dan membersihkan sumber daya dalam metode <b>OnDisable</b> . <br>  Dalam contoh, kita akan memindahkan objek dalam metode <b>Pembaruan</b> , untuk menghitung lintasan kita akan menggunakan dua wadah vektor - <b>inputArray</b> di mana kita akan meletakkan posisi saat ini dan <b>outputArray</b> dari mana kita akan menerima hasilnya. <br><br><div class="spoiler">  <b class="spoiler_title">Testjob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NativeArray&lt;Vector2&gt; inputArray; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NativeArray&lt;Vector2&gt; outputArray; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> JobHandle handle; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnEnable() {} <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Update() {} <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDisable() {} }</code> </pre> <br></div></div><br>  <b>Kami</b> juga <b>akan</b> sedikit <b>memodifikasi</b> struktur tugas <b>SimpleJob</b> dengan mewarisinya dari antarmuka <b>IJob</b> untuk menjalankannya sekali. <br><br><div class="spoiler">  <b class="spoiler_title">Pekerjaan sederhana</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() {} }</code> </pre> <br></div></div><br>  Dalam tugas itu sendiri, kita juga akan mengkhianati dua wadah vektor, satu vektor posisi dan delta numerik, yang akan memindahkan objek ke target. <br><br><div class="spoiler">  <b class="spoiler_title">Pekerjaan sederhana</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { [ReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Vector2&gt; inputArray; [WriteOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Vector2&gt; outputArray; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 position; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float delta; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() {} }</code> </pre> <br></div></div><br>  Atribut <b>ReadOnly</b> dan <b>WriteOnly</b> menunjukkan batasan aliran pada tindakan yang terkait dengan data di dalam wadah.  <b>ReadOnly</b> menawarkan stream hanya untuk membaca data dari container, atribut <b>WriteOnly</b> , sebaliknya, memungkinkan stream untuk hanya menulis data ke container.  Jika Anda perlu melakukan dua tindakan ini sekaligus dengan satu wadah, maka Anda tidak perlu menandainya dengan atribut sama sekali. <br><br>  Mari kita <b>beralih</b> ke metode <b>OnEnable</b> dari kelas <b>TestJob di</b> mana kontainer akan diinisialisasi. <br><br><div class="spoiler">  <b class="spoiler_title">Dapat dipertahankan</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnEnable() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>, Allocator.Persistent); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>, Allocator.Persistent); }</code> </pre> <br></div></div><br>  Dimensi wadah akan tunggal karena perlu untuk mengirim dan menerima parameter hanya sekali.  Jenis alokasi akan <b>Persisten</b> . <br>  Dalam metode <b>OnDisable</b> , <b>kami</b> akan merilis sumber daya wadah. <br><br><div class="spoiler">  <b class="spoiler_title">Dapat ditolak</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDisable() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray.Dispose(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray.Dispose(); }</code> </pre> <br></div></div><br>  Mari kita buat metode <b>CreateJob</b> terpisah di mana kita akan membuat tugas dengan pegangannya dan di sana kita akan mengisinya dengan data. <br><br><div class="spoiler">  <b class="spoiler_title">Buat Pekerjaan</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CreateJob() { SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.delta = Time.deltaTime; Vector2 position = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.transform.position; job.position = position; Vector2 newPosition = position + Vector2.right; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray[<span class="hljs-number"><span class="hljs-number">0</span></span>] = newPosition; job.inputArray = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray; job.outputArray = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle = job.Schedule(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.Complete(); }</code> </pre> <br></div></div><br>  <i>Sebenarnya, <b>inputArray</b> tidak benar-benar diperlukan di sini, karena dimungkinkan untuk mentransfer vektor arah hanya ke tugas, tetapi saya pikir akan lebih baik untuk memahami mengapa atribut <b>ReadOnly</b> dan <b>WriteOnly</b> ini diperlukan sama sekali.</i> <br><br>  Dalam metode <b>Pembaruan</b> , kami akan memeriksa apakah tugas sudah selesai, setelah itu kami menerapkan hasil yang diperoleh ke objek mengubah dan menjalankannya lagi. <br><br><div class="spoiler">  <b class="spoiler_title">Perbarui</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Update() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.IsCompleted) { Vector2 newPosition = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.transform.position = newPosition; CreateJob(); } }</code> </pre> <br></div></div><br>  Sebelum memulai, kita akan sedikit mengubah metode <b>OnEnable</b> sehingga tugas dibuat segera setelah wadah diinisialisasi. <br><br><div class="spoiler">  <b class="spoiler_title">Dapat dipertahankan</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnEnable() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>, Allocator.Persistent); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>, Allocator.Persistent); CreateJob(); }</code> </pre> <br></div></div><br>  Selesai, sekarang Anda bisa pergi ke tugas itu sendiri dan melakukan perhitungan yang diperlukan dalam metode <b>Execute</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Jalankan</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() { Vector2 newPosition = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray[<span class="hljs-number"><span class="hljs-number">0</span></span>]; newPosition = Vector2.Lerp(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position, newPosition, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.delta); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray[<span class="hljs-number"><span class="hljs-number">0</span></span>] = newPosition; }</code> </pre> <br></div></div><br>  Untuk melihat hasil kerja, Anda bisa melempar skrip <b>TestJob</b> pada beberapa objek dan menjalankan game. <br><br>  Sebagai contoh, sprite saya secara bertahap bergeser ke kanan. <br><br><div class="spoiler">  <b class="spoiler_title">Animasi</b> <div class="spoiler_text"><img src="https://lh3.googleusercontent.com/YCf68msYSI0w6ARjOAeAWsPPhpPOrXC-3jWTfqtlnu1pS1xa9m6FCjTD3DdvcvWi5KSEh_-q6X2yUf62j1FOgSU6d0plX603FOQiydF-yLRQFvbd2YBY-mp8I5p5V4cQH9t7SKPR" alt="gambar"><br></div></div><br>  Secara umum, jenis alokasi <b>Persistent sangat</b> bagus untuk wadah yang dapat digunakan kembali yang tidak perlu dihancurkan dan dibuat ulang setiap saat. <br><br>  <i>Jadi tipe apa yang digunakan !?</i> <br>  Tipe <b>Temp</b> paling baik digunakan untuk melakukan perhitungan dengan cepat, tetapi jika tugasnya terlalu kompleks dan besar, slack dapat terjadi. <br>  Tipe <b>TempJob sangat</b> bagus untuk bekerja dengan objek <b>kesatuan</b> , jadi Anda bisa mengubah parameter objek dan menerapkannya, misalnya, di bingkai berikutnya. <br>  Jenis <b>Persistent</b> dapat digunakan ketika kecepatan tidak penting bagi Anda, tetapi Anda hanya perlu terus-menerus menghitung beberapa jenis data di samping, misalnya, memproses data melalui jaringan, atau pekerjaan AI. <br><br><div class="spoiler">  <b class="spoiler_title">Tidak Valid dan Tidak Ada</b> <div class="spoiler_text">  <i>Ada dua jenis alokasi yang <b>tidak valid</b> dan <b>Tidak Ada</b> , tetapi mereka lebih dibutuhkan untuk debugging, dan tidak berpartisipasi dalam pekerjaan.</i> <br></div></div><br><br><h3>  Penanganan pekerjaan </h3><br>  Secara terpisah, ada baiknya untuk menganalisis kemampuan dari tugas menangani, karena selain memeriksa proses pelaksanaan tugas, pegangan kecil ini masih dapat membuat seluruh jaringan tugas melalui dependensi (meskipun saya lebih suka menyebutnya antrian lebih). <br><br>  Misalnya, jika Anda perlu melakukan dua tugas dalam urutan tertentu, maka untuk ini Anda hanya perlu melampirkan gagang satu tugas ke gagang yang lain. <br><br>  Itu terlihat seperti ini. <br><br><img src="https://lh3.googleusercontent.com/K62BSMljveR8lED8wCuCUCuLN6zyNlXS8RQybQuztrT_FMalHHSP7oMGIDf6xUcjXAMqRG3njvHIJ4FPL_tU1uSZr5XQDmCOPyM_YJye2i_z58lIPAkflcia511L2ILI72In61aT" alt="gambar"><br><br>  Setiap individu menangani awalnya berisi tugasnya sendiri, tetapi ketika digabungkan, kami mendapatkan pegangan baru dengan dua tugas. <br><br><div class="spoiler">  <b class="spoiler_title">Mulai</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { Job jobA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Job(); JobHandle handleA = jobA.Schedule(); Job jobB = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Job(); JobHandle handleB = jobB.Schedule(); JobHandle result = JobHandle.CombineDependecies(handleA, handleB); result.Complete(); }</code> </pre> <br></div></div><br>  Atau begitulah. <br><br><div class="spoiler">  <b class="spoiler_title">Mulai</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { JobHandle handle; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { Job job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Job(); handle = job.Schedule(handle); } handle.Complete(); }</code> </pre> <br></div></div><br>  Urutan eksekusi disimpan dan penjadwal tidak akan memulai tugas berikutnya sampai yakin dengan yang sebelumnya, tetapi penting untuk diingat bahwa properti <b>pegangan</b> IsCompleted akan menunggu semua tugas di dalamnya untuk menyelesaikan. <br><br><h2>  Kesimpulan </h2><br><h3>  Wadah </h3><br><ol><li>  Saat bekerja dengan data dalam wadah, jangan lupa bahwa ini adalah struktur, jadi setiap penimpaan data dalam wadah tidak mengubahnya, tetapi membuatnya lagi. </li><li>  <i>Apa yang terjadi jika Anda mengatur jenis alokasi Temp dan tidak menghapus sumber daya setelah tugas selesai?</i>  Kesalahannya. </li><li>  <i>Bisakah saya membuat wadah sendiri?</i>  Ada kemungkinan bahwa persatuan tersebut menjelaskan secara terperinci proses pembuatan wadah khusus di sini, tetapi lebih baik untuk berpikir beberapa kali: apakah itu layak, mungkin akan ada cukup wadah biasa!? </li></ol><br><h4>  Keamanan! </h4><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data statis.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jangan mencoba menggunakan data statis dalam suatu tugas ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acak</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan lain-lain), akses apa pun ke data statis akan melanggar keamanan sistem. Sebenarnya, saat ini Anda dapat mengakses data statis, tetapi hanya jika Anda yakin mereka tidak berubah selama pekerjaan - yaitu, mereka benar-benar statis dan hanya-baca. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kapan harus menggunakan sistem tugas?</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Semua contoh yang diberikan di sini dalam artikel ini hanya bersyarat, dan menunjukkan cara bekerja dengan sistem ini, dan bukan kapan menggunakannya. Sistem tugas dapat digunakan tanpa </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ECS,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda perlu memahami bahwa sistem juga menghabiskan sumber daya di tempat kerja dan bahwa untuk alasan apa pun segera menulis tugas, membuat tumpukan kontainer tidak ada gunanya - semuanya akan menjadi lebih buruk. Misalnya, menghitung ulang larik dengan ukuran 10 ribu elemen tidak akan benar - ini akan membutuhkan lebih banyak waktu untuk penjadwal untuk bekerja, tetapi menghitung ulang semua poligon terran besar atau bahkan menghasilkannya adalah solusi yang tepat, Anda dapat memecah terran menjadi tugas dan memproses masing-masing dalam aliran terpisah. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara umum, jika Anda terus-menerus terlibat dalam perhitungan kompleks dalam proyek dan terus-menerus mencari peluang baru untuk membuat proses ini kurang intensif sumber daya, maka </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sistem Pekerjaan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inilah yang Anda butuhkan. </font><font style="vertical-align: inherit;">Jika Anda terus-menerus bekerja dengan perhitungan kompleks yang tidak dapat dipisahkan dari objek dan ingin kode Anda bekerja lebih cepat dan didukung pada sebagian besar platform, maka </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ECS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pasti akan membantu Anda dengan ini. </font><font style="vertical-align: inherit;">Jika Anda membuat proyek hanya untuk </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WebGL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> maka ini bukan untuk Anda, saat ini </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sistem Pekerjaan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tidak mendukung bekerja di browser, meskipun ini bukan masalah untuk unitecs, tetapi untuk pengembang browser itu sendiri. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://www.google.com/url%3Fq%3D"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sumber dengan semua contoh</font></font></a> <cut></cut></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id420829/">https://habr.com/ru/post/id420829/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id420815/index.html">Bagaimana "decoding the digital world" meledakkan aula: 10 laporan teratas DotNext 2018 Piter</a></li>
<li><a href="../id420819/index.html">10 alat Python teratas untuk pembelajaran mesin dan ilmu data</a></li>
<li><a href="../id420821/index.html">Aturan 10: 1 dalam pemrograman dan penulisan</a></li>
<li><a href="../id420825/index.html">Hari ini akan menjadi pertandingan pertama antara OpenAI dan profesional Dota 2 (orang menang). Kami memahami cara kerja bot</a></li>
<li><a href="../id420827/index.html">Buat proyek pakar sederhana menggunakan Java EE + WildFly10 + JPA (Hibernate) + Postgresql + EJB + IntelliJ IDEA</a></li>
<li><a href="../id420831/index.html">Perangkat untuk penerbitan cookie "Cook 3000"</a></li>
<li><a href="../id420833/index.html">Kesalahan monetisasi aplikasi utama [dan cara memperbaikinya]</a></li>
<li><a href="../id420837/index.html">Menguji array RAID perangkat lunak untuk perangkat NVMe menggunakan metodologi SNIA</a></li>
<li><a href="../id420841/index.html">Perbaikan terbaru pra-rumah sakit atau "Hei Sombong! Di mana kesalahan saya? "</a></li>
<li><a href="../id420843/index.html">7 September, Yekaterinburg - pertemuan untuk pengembang .NET</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>