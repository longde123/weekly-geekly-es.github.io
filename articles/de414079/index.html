<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛶 🍥 ℹ️ Funktionen der Arbeit und des internen Geräts express.js 🛕 👨🏿‍🔧 👨‍👧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Sie für die Plattform node.js entwickelt haben, haben Sie wahrscheinlich von express.js gehört . Dies ist eines der beliebtesten Frameworks für d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Funktionen der Arbeit und des internen Geräts express.js</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/414079/"> Wenn Sie für die Plattform node.js entwickelt haben, haben Sie wahrscheinlich von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">express.js gehört</a> .  Dies ist eines der beliebtesten Frameworks für die Erstellung von Webanwendungen für Knoten. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/bs/np/1r/bsnp1rphnfiib_l1tjzaauvcs48.jpeg"></a> <br><br>  Der Autor des Materials, dessen Übersetzung wir heute veröffentlichen, bietet an, die Merkmale der internen Struktur des Express-Frameworks durch Analyse seines Quellcodes und Berücksichtigung eines Beispiels seiner Verwendung zu untersuchen.  Er glaubt, dass die Untersuchung der Mechanismen, die den beliebten Open-Source-Bibliotheken zugrunde liegen, zu einem tieferen Verständnis dieser Mechanismen beiträgt, den Vorhang des „Geheimnisses“ von ihnen entfernt und dazu beiträgt, bessere Anwendungen auf der Grundlage dieser Mechanismen zu erstellen. <br><a name="habracut"></a><br>  Es kann zweckmäßig sein, den Express-Quellcode beim Lesen dieses Materials griffbereit zu halten.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Diese Version wird</a> hier verwendet.  Sie können diesen Artikel lesen, ohne den Express-Code zu öffnen, da hier gegebenenfalls Codefragmente dieser Bibliothek angegeben werden.  An den Stellen, an denen der Code abgekürzt ist, werden Kommentare der Form <code>// ...</code> <br><br><h2>  <font color="#3AC1EF">Ein grundlegendes Beispiel für die Verwendung von Express</font> </h2><br>  Schauen wir uns zunächst die „Hallo Welt!“ An, die bei der Entwicklung neuer Computertechnologien traditionell ist - ein Beispiel.  Es ist auf der offiziellen Website des Frameworks zu finden und dient als Ausgangspunkt für unsere Forschung. <br><br><pre> <code class="hljs coffeescript">const express = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'express'</span></span>) const app = express() app.get(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req, res)</span></span></span><span class="hljs-function"> =&gt;</span></span> res.send(<span class="hljs-string"><span class="hljs-string">'Hello World!'</span></span>)) app.listen(<span class="hljs-number"><span class="hljs-number">3000</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Example app listening on port 3000!'</span></span>))</code> </pre> <br>  Dieser Code startet einen neuen HTTP-Server an Port 3000 und sendet eine <code>Hello World!</code>  auf Anfragen, die auf dem <code>GET /</code> Route empfangen wurden.  Wenn Sie nicht auf Details eingehen, können wir vier Phasen des Geschehens unterscheiden, die wir analysieren können: <br><br><ol><li>  Erstellen Sie eine neue Express-Anwendung. </li><li>  Erstellen Sie eine neue Route. </li><li>  Starten des HTTP-Servers unter der angegebenen Portnummer. </li><li>  Verarbeitung eingehender Anfragen an den Server. </li></ol><br><h2>  <font color="#3AC1EF">Erstellen einer neuen Expressanwendung</font> </h2><br>  Mit dem Befehl <code>var app = express()</code> können Sie eine neue Express-Anwendung erstellen.  Die Funktion <code>createApplication</code> aus der <a href="">Datei lib / express.js</a> ist die standardmäßig exportierte Funktion. Wir greifen darauf zu, indem wir die Funktion <code>express()</code> aufrufen.  Hier sind einige wichtige Dinge, auf die Sie achten sollten: <br><br><pre> <code class="hljs powershell">// ... var mixin = require(<span class="hljs-string"><span class="hljs-string">'merge-descriptors'</span></span>); var proto = require(<span class="hljs-string"><span class="hljs-string">'./application'</span></span>); // ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createApplication</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { //    ,     . //     : `function(req, res, next)` var app = function(req, res, next) {   app.handle(req, res, next); }; // ... //  `mixin`    `proto`  `app` //     -  `get`,     . mixin(app, proto, false); // ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> app; }</code> </pre> <br>  Das von dieser Funktion zurückgegebene <code>app</code> Objekt ist eines der in unserem Anwendungscode verwendeten Objekte.  Die <code>app.get</code> Methode <code>app.get</code> mithilfe der <code>mixin</code> Funktion der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Merge-Descriptors-</a> Bibliothek hinzugefügt, die für die Zuweisung der in <code>proto</code> deklarierten <code>app</code> Methoden verantwortlich ist.  Das <code>proto</code> Objekt selbst wird aus <a href="">lib / application.js</a> importiert. <br><br><h2>  <font color="#3AC1EF">Erstellen Sie eine neue Route</font> </h2><br>  Schauen wir uns nun den <a href="">Code an</a> , der für die Erstellung der <code>app.get</code> Methode aus unserem Beispiel verantwortlich ist. <br><br><pre> <code class="hljs powershell">var slice = Array.prototype.slice; // ... /** *   `.VERB(...)` `router.VERB(...)`. */ // `methods`    HTTP, (  [<span class="hljs-string"><span class="hljs-string">'get'</span></span>,<span class="hljs-string"><span class="hljs-string">'post'</span></span>,<span class="hljs-type"><span class="hljs-type">...</span></span>]) methods.forEach(function(method){ //    app.get app[<span class="hljs-type"><span class="hljs-type">method</span></span>] = function(path){   //     //          var route = this._router.route(path);   //        route[<span class="hljs-type"><span class="hljs-type">method</span></span>].apply(route, slice.call(arguments, <span class="hljs-number"><span class="hljs-number">1</span></span>));   //   `app`,          <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this; }; });</code> </pre> <br>  Es ist interessant festzustellen, dass zusätzlich zu den semantischen Merkmalen alle Methoden, die HTTP-Aktionen implementieren, wie z. B. <code>app.get</code> , <code>app.post</code> , <code>app.put</code> und dergleichen, hinsichtlich der Funktionalität als gleich angesehen werden können.  Wenn Sie den obigen Code vereinfachen und ihn auf die Implementierung nur einer <code>get</code> Methode reduzieren, erhalten Sie Folgendes: <br><br><pre> <code class="hljs sql">app.get = function(path, <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>){ // ... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> route = this._router.route(<span class="hljs-keyword"><span class="hljs-keyword">path</span></span>); route.get(<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this }</code> </pre> <br>  Obwohl die obige Funktion 2 Argumente hat, ähnelt sie der Funktion <code>app[method] = function(path){...}</code> .  Das zweite Argument, <code>handler</code> , wird durch Aufrufen von <code>slice.call(arguments, 1)</code> . <br><br>  Kurz gesagt, <code>app.&lt;method&gt;</code> speichert die Route nur im Anwendungsrouter mithilfe ihrer Routenmethode und übergibt den <code>handler</code> an <code>route.&lt;method&gt;</code> . <br><br>  Die Router-Methode <code>route()</code> ist in <a href="">lib / router / index.js deklariert</a> : <br><br><pre> <code class="hljs pgsql">// proto -     `_router` proto.route = <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> route(<span class="hljs-type"><span class="hljs-type">path</span></span>) { var route = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Route(<span class="hljs-type"><span class="hljs-type">path</span></span>); var layer = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Layer(<span class="hljs-type"><span class="hljs-type">path</span></span>, {   sensitive: this.caseSensitive,   <span class="hljs-keyword"><span class="hljs-keyword">strict</span></span>: this.<span class="hljs-keyword"><span class="hljs-keyword">strict</span></span>,   <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> }, route.dispatch.bind(route)); layer.route = route; this.stack.push(layer); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> route; };</code> </pre> <br>  Es überrascht nicht, dass die Deklaration der <code>route.get</code> Methode in <a href="">lib / router / route.js</a> der Deklaration von <code>app.get</code> : <br><br><pre> <code class="hljs powershell">methods.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(method)</span></span></span></span> { Route.prototype[<span class="hljs-type"><span class="hljs-type">method</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {   // `flatten`   ,  [<span class="hljs-number"><span class="hljs-number">1</span></span>,[<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>]],      var handles = flatten(slice.call(arguments));   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; handles.length; i++) {     var handle = handles[<span class="hljs-type"><span class="hljs-type">i</span></span>];         // ...     //   ,  ,    Layer,     //            var layer = Layer(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, {}, handle);     // ...     this.stack.push(layer);   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this; }; });</code> </pre> <br>  Jede Route kann mehrere Handler haben. Auf der Grundlage jedes Handlers wird eine Variable vom Typ <code>Layer</code> , bei der es sich um eine Datenverarbeitungsschicht handelt, die dann auf den Stapel gelangt. <br><br><h2>  <font color="#3AC1EF">Ebenenobjekte</font> </h2><br>  Sowohl <code>_router</code> als auch <code>route</code> verwenden Objekte vom Typ <code>Layer</code> .  Um die Essenz eines solchen Objekts zu verstehen, schauen wir uns seinen <a href="">Konstruktor an</a> : <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Layer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(path, options, fn)</span></span></span></span> { // ... this.handle = fn; this.regexp = pathRegexp(path, this.keys = [], opts); // ... }</code> </pre> <br>  Beim Erstellen von Objekten vom Typ <code>Layer</code> sie einen Pfad, bestimmte Parameter und eine Funktion.  Bei unserem Router handelt es sich bei dieser Funktion um <code>route.dispatch</code> (wir werden im Folgenden näher darauf <code>route.dispatch</code> Im Allgemeinen dient sie dazu, eine Anforderung an eine separate Route zu senden).  Im Fall der Route selbst ist diese Funktion eine Handlerfunktion, die im Code unseres Beispiels deklariert ist. <br><br>  Jedes Objekt vom Typ <code>Layer</code> verfügt über eine <a href="">handle_request-</a> Methode, die für die Ausführung der Funktion verantwortlich ist, die bei der Initialisierung des Objekts übergeben wurde. <br><br>  Erinnern Sie sich daran, was beim Erstellen einer Route mit der Methode <code>app.get</code> passiert: <br><br><ol><li>  Eine Route wird im Router der Anwendung ( <code>this._router</code> ) erstellt. </li><li>  Die <code>dispatch</code> wird als Handlermethode des entsprechenden <code>Layer</code> Objekts zugewiesen, und dieses Objekt wird auf den Router-Stack verschoben. </li><li>  Der Anforderungshandler wird als Handlermethode an das <code>Layer</code> Objekt übergeben, und dieses Objekt wird auf den Routenstapel übertragen. </li></ol><br>  Infolgedessen werden alle Handler in der <code>app</code> Instanz in Form von Objekten des Layertyps gespeichert, die sich im Routenstapel befinden und deren <code>dispatch</code> <code>Layer</code> im Router-Stack zugewiesen sind: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a9/e8c/5b0/4a9e8c5b056ef1e8ce1e36503ab8c0f0.png"></div><br>  <i><font color="#999999">Layer-Objekte auf dem Router-Stack und dem Route-Stack</font></i> <br><br>  Eingehende HTTP-Anfragen werden gemäß dieser Logik verarbeitet.  Wir werden unten darüber sprechen. <br><br><h2>  <font color="#3AC1EF">Start des HTTP-Servers</font> </h2><br>  Nach dem Konfigurieren der Routen müssen Sie den Server starten.  In unserem Beispiel wenden wir uns der Methode <code>app.listen</code> und übergeben ihr die Portnummer und die Rückruffunktion als Argumente.  Um die Funktionen dieser Methode zu verstehen, können wir auf die Datei <a href="">lib / application.js</a> verweisen: <br><br><pre> <code class="hljs pgsql">app.<span class="hljs-keyword"><span class="hljs-keyword">listen</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">listen</span></span>() { var <span class="hljs-keyword"><span class="hljs-keyword">server</span></span> = http.createServer(this); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">server</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">listen</span></span>.apply(<span class="hljs-keyword"><span class="hljs-keyword">server</span></span>, arguments); };</code> </pre> <br>  <code>app.listen</code> nur ein Wrapper um <code>http.createServer</code> .  Eine solche Sichtweise ist sinnvoll, denn wenn Sie sich an das erinnern, worüber wir am Anfang gesprochen haben, ist die <code>app</code> nur eine Funktion mit der Signaturfunktion <code>function(req, res, next) {...}</code> , die mit den für <code>http.createServer</code> erforderlichen Argumenten kompatibel ist <code>http.createServer</code> (die Signatur dieser Methode ist <code>function (req, res) {...}</code> ). <br><br>  Nachdem wir erkannt haben, dass am Ende alles, was express.js uns gibt, auf einen sehr intelligenten Funktionshandler reduziert werden kann, sieht das Framework nicht mehr so ​​kompliziert und mysteriös aus wie zuvor. <br><br><h2>  <font color="#3AC1EF">HTTP-Anforderungsverarbeitung</font> </h2><br>  Nachdem wir wissen, dass die <code>app</code> nur ein Anforderungshandler ist, folgen wir dem Pfad, den eine HTTP-Anforderung in einer Expressanwendung übergibt.  Dieser Weg führt zu dem von uns deklarierten Handler. <br><br>  Zunächst geht die Anforderung an die Funktion <code>createApplication</code> ( <a href="">lib / express.js</a> ): <br><br><pre> <code class="hljs matlab">var app = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req, res, next)</span></span></span><span class="hljs-function"> {   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">app</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req, res, next)</span></span></span><span class="hljs-function">; };</span></span></code> </pre> <br>  Dann geht es zur <code>app.handle</code> Methode ( <a href="">lib / application.js</a> ): <br><br><pre> <code class="hljs powershell">app.handle = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req, res, callback)</span></span></span></span> { // `this._router` -  ,    ,  `app.get` var router = this._router; // ... //     `handle` router.handle(req, res, done); };</code> </pre> <br>  Die <code>router.handle</code> Methode <code>router.handle</code> in <a href="">lib / router / index.js deklariert</a> : <br><br><pre> <code class="hljs lua">proto.handle = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req, res, out)</span></span></span></span> { var self = this; //... // self.stack -  ,      // Layer (  ) var stack = self.stack; // ... <span class="hljs-built_in"><span class="hljs-built_in">next</span></span>(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span></span> {   // ...   //        var <span class="hljs-built_in"><span class="hljs-built_in">path</span></span> = getPathname(req);   // ...   var layer;   var <span class="hljs-built_in"><span class="hljs-built_in">match</span></span>;   var route;   <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">match</span></span> !== <span class="hljs-literal"><span class="hljs-literal">true</span></span> &amp;&amp; idx &lt; stack.length) {     layer = stack[idx++];     <span class="hljs-built_in"><span class="hljs-built_in">match</span></span> = matchLayer(layer, <span class="hljs-built_in"><span class="hljs-built_in">path</span></span>);     route = layer.route;     // ...     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">match</span></span> !== <span class="hljs-literal"><span class="hljs-literal">true</span></span>) {       continue;     }     // ...      HTTP,       }  // ...      // process_params    ,          self.process_params(layer, paramcalled, req, res, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span></span> {     // ...     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (route) {       //       `layer.handle_request`       //         `<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>`       //  ,   `<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>`     ,              //  ,   `<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>`   ,            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> layer.handle_request(req, res, <span class="hljs-built_in"><span class="hljs-built_in">next</span></span>);     }     // ...   }); } };</code> </pre> <br>  <code>router.handle</code> gesagt, die Funktion <code>router.handle</code> durchläuft alle Ebenen auf dem Stapel, bis eine gefunden wird, die dem in der Anforderung angegebenen Pfad entspricht.  Anschließend wird die Layer-Methode <code>handle_request</code> aufgerufen, die die vordefinierte <code>handle_request</code> ausführt.  Diese Handlerfunktion ist eine <code>dispatch</code> , die in <a href="">lib / route / route.js deklariert ist</a> : <br><br><pre> <code class="hljs powershell">Route.prototype.dispatch = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispatch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req, res, done)</span></span></span></span> { var stack = this.stack; // ... next(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span></span> {   // ...   var layer = stack[<span class="hljs-type"><span class="hljs-type">idx</span></span>++];   // ...    layer.handle_request(req, res, next);   // ... } };</code> </pre> <br>  Genau wie im Fall des Routers werden während der Verarbeitung jeder Route die Layer dieser Route aufgelistet und ihre <code>handle_request</code> Methoden, die die Layer-Handler-Methoden ausführen, <code>handle_request</code> .  In unserem Fall ist dies ein Anforderungshandler, der im Anwendungscode deklariert ist. <br><br>  Hier fällt schließlich die HTTP-Anfrage in den Codebereich unserer Anwendung. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/afb/0d1/5fb/afb0d15fbe71236ed615f88fe61bf062.png"></div><br>  <i><font color="#999999">Pfad in Express-Anwendung anfordern</font></i> <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Hier haben wir nur die grundlegenden Mechanismen der Bibliothek express.js untersucht, die für den Betrieb des Webservers verantwortlich sind. Diese Bibliothek verfügt jedoch auch über viele andere Funktionen.  Wir haben nicht bei den Überprüfungen angehalten, die die Anforderungen durchlaufen, bevor sie die Handler erreichen, und wir haben nicht über die Hilfsmethoden gesprochen, die bei der Arbeit mit den Variablen <code>res</code> und <code>req</code> verfügbar sind.  Und schließlich haben wir keine der mächtigsten Funktionen von Express angesprochen.  Es besteht in der Verwendung von Middleware, mit der nahezu jedes Problem gelöst werden kann - von der Analyse von Anforderungen bis zur Implementierung eines vollständigen Authentifizierungssystems. <br><br>  Wir hoffen, dieses Material hat Ihnen geholfen, die Hauptfunktionen des Express-Geräts zu verstehen, und jetzt können Sie bei Bedarf alles andere verstehen, indem Sie die Teile des Quellcodes dieser Bibliothek, die Sie interessieren, unabhängig analysieren. <br><br>  <b>Liebe Leser!</b>  Verwenden Sie express.js? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de414079/">https://habr.com/ru/post/de414079/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de414065/index.html">Das beste chinesische Smartphone "bis zu 10 Tausend Rubel" mit AliExpress gegen Xiaomi Redmi 5</a></li>
<li><a href="../de414067/index.html">Starten Sie das mobile Retargeting mit Anpassen: Einstellungen, Berichte und Links</a></li>
<li><a href="../de414069/index.html">Drohnenbeschränkungen während der FIFA Fussball-Weltmeisterschaft 2018 (FIFA 2018)</a></li>
<li><a href="../de414071/index.html">Von der Überwachung bis zum Incident Management. Bericht vom DevOps Moscow Meetup</a></li>
<li><a href="../de414073/index.html">Migration von jQuery zu Vue.js.</a></li>
<li><a href="../de414081/index.html">Chatbot-Entwicklung für Facebook Messenger auf node.js</a></li>
<li><a href="../de414083/index.html">Sommer Mitap Apache Ignite in St. Petersburg</a></li>
<li><a href="../de414085/index.html">Wie man Proben für das Unified Biometric System erstellt und warum es gefährlich sein kann</a></li>
<li><a href="../de414087/index.html">Automatisieren Sie es sofort oder wie Unternehmen heute online arbeiten können</a></li>
<li><a href="../de414089/index.html">Telegrammsperre durch Entscheidung des Moskauer Stadtgerichts bestätigt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>