<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📨 🚄 🕴🏽 Dans un certain royaume, pas dans un état «naissant». Rapport Yandex 🐚 🕎 ⛎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Spring est un puissant framework Java open source. J'ai décidé de vous dire pour quelles tâches le backend Spring est utile et quels sont ses avantage...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dans un certain royaume, pas dans un état «naissant». Rapport Yandex</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/478788/">  Spring est un puissant framework Java open source.  J'ai décidé de vous dire pour quelles tâches le backend Spring est utile et quels sont ses avantages et ses inconvénients par rapport aux autres bibliothèques: Guice et Dagger 2. Envisagez l'injection de dépendances et l'inversion de contrôle - vous apprendrez comment commencer à étudier ces principes. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/RrmrfoWDu5M" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - Bonjour à tous, je m'appelle Cyril.  Aujourd'hui, je vais parler de l'injection de dépendance. <br><a name="habracut"></a><br>  Nous allons commencer par le nom de mon rapport.  "Dans un certain royaume, pas dans un état" naissant "."  Nous parlerons, bien sûr, du printemps, mais je veux aussi regarder tout ce qui est en dehors de lui.  De quoi parlerons-nous précisément? <br><br><img src="https://habrastorage.org/webt/cq/li/gv/cqligvmc0hnuu56z8mgqjjnoebo.jpeg"><br><br>  Je vais faire une petite digression - vous dire sur quoi je travaille, quel est mon projet, pourquoi nous utilisons l'injection de dépendance.  Ensuite, je vais vous dire de quoi il s'agit, comparer l'inversion de contrôle et l'injection de dépendances, et parler de son implémentation dans les trois bibliothèques les plus célèbres. <br><br>  Je travaille dans l'équipe Yandex.Tracker.  Nous fabriquons un analogue d'épicerie de Jira ou Trello.  [...] Nous avons décidé de fabriquer notre propre produit, qui était d'abord interne.  Maintenant, nous le vendons.  Chacun de vous peut entrer, créer son propre tracker et effectuer des tâches, par exemple pédagogiques ou professionnelles. <br><br>  Regardons l'interface.  Dans les exemples, j'utiliserai certains termes de ma région.  Nous allons essayer de créer un ticket et regarder les commentaires que d'autres collègues me laisseront dedans. <br><br>  Pour commencer, qu'est-ce que l'injection de dépendance en général?  C'est un modèle de programmation qui répond au vieil adage américain, au principe hollywoodien: "Ne nous appelez pas, nous vous appellerons nous-mêmes."  Les dépendances elles-mêmes viennent à nous.  Il s'agit principalement d'un modèle, pas d'une bibliothèque.  Par conséquent, en principe, un tel modèle est commun presque partout.  Vous pourriez même dire que toutes les applications utilisent l'injection de dépendance d'une manière ou d'une autre. <br><br><img src="https://habrastorage.org/webt/wz/cj/8h/wzcj8hmirm_url9gghidooms19y.jpeg"><br><br>  Voyons comment vous pouvez proposer vous-même l'injection de dépendance si nous partons de zéro.  Supposons que j'ai décidé de développer une classe si petite dans laquelle je vais créer un ticket via notre API.  Par exemple, créez une instance de la classe TrackerApi.  Il a une méthode createTicket dans laquelle nous enverrons mon e-mail.  Nous créerons un ticket sous mon compte avec le nom: "Préparer un rapport pour Java Meetup". <br><br><img src="https://habrastorage.org/webt/sp/dn/md/spdnmdmw57qzfgfdfjtwqwijtiq.jpeg"><br><br>  Voyons l'implémentation de TrackerApi.  Ici, par exemple, nous pouvons le faire: créer une instance httpClient.  En termes simples, nous allons créer un objet à travers lequel nous irons à l'API.  A travers cet objet, nous appellerons la méthode execute dessus. <br><br><img src="https://habrastorage.org/webt/x4/2a/iy/x42aiy9l2baljluoanesiq04gay.jpeg"><br><br>  Par exemple, un personnalisé.  J'ai écrit du code externe de ces classes, et il l'utilisera quelque chose comme ça.  Je crée un nouveau TicketCreator et j'appelle la méthode createTicket dessus. <br><br><img src="https://habrastorage.org/webt/g8/al/li/g8allib-7c35r0iulwej8fjgmzu.jpeg"><br><br>  Il y a un problème ici - chaque fois que nous créons un ticket, nous recréerons et recréerons httpClient, bien qu'en général, cela ne soit pas nécessaire.  httpClients est très sérieux à créer. <br><br><img src="https://habrastorage.org/webt/eh/pc/o3/ehpco32zfcarfgwgabxumx6deuo.jpeg"><br><br>  Essayons de le faire.  Ici vous pouvez voir le tout premier exemple d'Injection de dépendances dans notre code.  Faites attention à ce que nous avons fait.  Nous avons retiré notre variable dans le champ et l'avons remplie dans le constructeur.  Le fait que nous le remplissions dans le constructeur signifie que les dépendances nous viennent.  Il s'agit de la première injection de dépendance. <br><br><img src="https://habrastorage.org/webt/x0/qw/2r/x0qw2rjibtfionm8och8p4fgxsm.jpeg"><br><br>  Nous avons transféré la responsabilité aux utilisateurs du code, nous devons donc maintenant créer un httpClient, en le transmettant, par exemple, à TicketCreator. <br><br><img src="https://habrastorage.org/webt/x0/qw/2r/x0qw2rjibtfionm8och8p4fgxsm.jpeg"><br><br>  Ce n'est pas non plus très bon ici, car maintenant, en appelant cette méthode, nous allons à nouveau créer httpClient à chaque fois. <br><br><img src="https://habrastorage.org/webt/tk/ib/zn/tkibznrpcl80hnoqg7qccgvl0em.jpeg"><br><br>  Par conséquent, nous l'emportons à nouveau sur le terrain.  Et ici, en passant, il y a un exemple non évident d'injection de dépendance.  Nous pouvons dire que nous créons toujours des billets sous moi (ou sous quelqu'un d'autre).  Nous créerons chaque objet TicketCreator distinct sous différents utilisateurs. <br><br>  Par exemple, celui-ci créera sous moi lorsque nous le créerons.  Et la ligne que nous passons au constructeur est également l'injection de dépendance. <br><br><img src="https://habrastorage.org/webt/jl/uq/nb/jluqnb4_2lburqy9jwo3u2hsrg8.jpeg"><br><br>  Comment allons-nous faire maintenant?  Créez une nouvelle instance de TrackerTicketCreator et appelez la méthode.  Maintenant, nous pouvons même créer une sorte de méthode personnalisée qui créera un ticket avec du texte personnalisé pour nous.  Par exemple, créez un ticket "Embaucher un nouveau stagiaire". <br><br><img src="https://habrastorage.org/webt/zr/un/hp/zrunhp6rgmmvg55w5djkz9z1clo.jpeg"><br><br>  Essayons maintenant de voir à quoi ressemblerait notre code si nous voulions lire les commentaires dans ce ticket de la même manière, sous moi.  Il s'agit du même code.  Nous appellerions la méthode getComments sur ce ticket. <br><br><img src="https://habrastorage.org/webt/qs/hs/ek/qshsek9l2xmb9xskiryj-m6rtzm.jpeg"><br><br>  À quoi ressemblerait-il?  Si nous prenons et dupliquons cette fonctionnalité dans un lecteur de commentaires, nous dupliquons la création de httpClient.  Cela ne nous convient pas.  Nous voulons nous en débarrasser. <br><br><img src="https://habrastorage.org/webt/tb/cq/ot/tbcqotqdzrcfxgzfzsba-e9us54.jpeg"><br><br>  Bon.  Passons maintenant tous ces paramètres en injection de dépendance, en tant que paramètres de constructeur. <br><br><img src="https://habrastorage.org/webt/qu/po/9k/qupo9kqigu94hoyo5tpcssyoxzg.jpeg"><br><br>  Quel est le problème ici?  Nous avons tout ignoré, mais dans le code utilisateur, nous écrivons maintenant «passe-partout».  Il s'agit d'une sorte de code inutile qu'un utilisateur doit généralement écrire pour effectuer une action relativement petite en termes de logique.  Ici, nous devrons constamment créer httpClient, une API pour celui-ci et sélectionner les e-mails des utilisateurs.  Chaque utilisateur de TicketCreator devra le faire lui-même.  Ce n'est pas ok.  Nous allons maintenant essayer de voir à quoi il ressemblera dans les bibliothèques lorsque nous essaierons de l'éviter. <br><br>  Maintenant, dévions un peu et regardons ce qu'est l'inversion de contrôle, car beaucoup y associent l'injection de dépendance. <br><br><img src="https://habrastorage.org/webt/h9/kj/xc/h9kjxcwtgvzwilwyikkiydksznm.jpeg"><br><br>  Inversion of Control est un principe de programmation dans lequel les objets que nous utilisons ne sont pas créés par nous.  Nous n'affectons pas du tout leur cycle de vie.  En règle générale, l'entité qui crée ces objets est appelée conteneur IoC.  Beaucoup d'entre vous ont entendu parler du printemps ici.  La documentation de Spring indique que les IoC sont également appelées injection de dépendance.  Ils croient que c'est la même chose. <br><br><img src="https://habrastorage.org/webt/fb/ue/oi/fbueoiomwpuhzlrkq3j9acynvcy.jpeg"><br><br>  Quels sont les principes de base?  Les objets sont créés non pas par le code d'application, mais par un conteneur IoC.  En tant qu'utilisateurs de la bibliothèque, nous ne faisons rien, tout nous vient tout seul.  Bien sûr, l'IoC est relative.  Le conteneur IoC lui-même crée ces objets, ce qui ne lui est plus applicable.  Vous pourriez penser que l'IoC implémente non seulement les bibliothèques DI.  Les bibliothèques Java bien connues Servlets et Akka Actors, qui sont maintenant utilisées dans Scala et dans le code Java. <br><br><img src="https://habrastorage.org/webt/mg/cj/qu/mgcjqu4qucgjz1w27guicfvgji8.jpeg"><br><br>  Parlons des bibliothèques.  De manière générale, de nombreuses bibliothèques ont déjà été écrites pour Java et Kotlin.  Je vais énumérer les principaux: <br><br>  - Spring, un super cadre.  Sa partie principale est l'injection de dépendance ou, comme on dit, l'inversion de contrôle. <br>  - Guice est une bibliothèque qui a été écrite approximativement entre le deuxième et le troisième printemps lorsque Spring est passé du XML à la description du code.  Autrement dit, quand le printemps n'était pas encore si beau. <br>  - Dagger est ce que les gens utilisent généralement sur Android. <br><br>  Essayons de réécrire notre exemple sur Spring. <br><br><img src="https://habrastorage.org/webt/n-/tq/bl/n-tqblihbupgiumevmkyjad7wnc.jpeg"><br><br>  Nous avions notre TrackerApi.  Je n'ai pas inclus l'utilisateur ici pour faire court.  Supposons que nous essayions dans l'injection de dépendances de faire pour httpClient.  Pour ce faire, nous devons le déclarer avec une annotation.  <a href="https://habr.com/ru/users/component/" class="user_link">Le composant</a> , la classe entière, et en particulier le constructeur, sont déclarés avec l'annotation <a href="https://habr.com/ru/users/autowired/" class="user_link">Autowired</a> .  Qu'est-ce que cela signifie pour le printemps? <br><br><img src="https://habrastorage.org/webt/qj/ef/i8/qjefi88q9vtuab9n16-rchaphzw.jpeg"><br><br>  Nous avons une telle configuration dans le code, elle est indiquée par l'annotation <a href="https://habr.com/ru/users/component/" class="user_link">Component</a> Scan.  Cela signifie que nous allons essayer de parcourir l'arborescence entière de nos classes dans le package dans lequel il est contenu.  Et plus à l'intérieur des terres, nous essaierons de trouver toutes les classes marquées dans l'annotation <a href="https://habr.com/ru/users/component/" class="user_link">Component</a> . <br><br><img src="https://habrastorage.org/webt/n-/tq/bl/n-tqblihbupgiumevmkyjad7wnc.jpeg"><br><br>  Ces composants tomberont dans le conteneur IoC.  Il est important pour nous que tout tombe pour nous.  Nous ne marquons que ce que nous voulons annoncer.  Pour que quelque chose nous arrive, nous devons le déclarer en utilisant l'annotation <a href="https://habr.com/ru/users/autowired/" class="user_link">Autowired</a> dans le constructeur. <br><br><img src="https://habrastorage.org/webt/ym/hq/le/ymhqlevva5gqgnoieckrw6ymm2k.jpeg"><br><br>  TicketCreator nous marquons exactement de la même manière. <br><br><img src="https://habrastorage.org/webt/xk/fa/i_/xkfai_wibiwgnp1lpuzfi9fhbcs.jpeg"><br><br>  Et CommentReader aussi. <br><br><img src="https://habrastorage.org/webt/qj/ef/i8/qjefi88q9vtuab9n16-rchaphzw.jpeg"><br><br>  Revenons maintenant à la configuration.  Comme nous l'avons dit, Component Scan mettra tout dans un conteneur IoC.  Mais il y a un point, la méthode dite d'usine.  Nous avons la méthode httpClient, que nous ne créons pas en tant que classe, car httpClient nous vient de la bibliothèque.  Il ne comprend pas ce qu'est Spring, etc. Nous allons le créer directement dans la configuration.  Pour ce faire, nous écrivons une méthode qui le construit généralement une fois et la marquons avec l'annotation Bean. <br><br><img src="https://habrastorage.org/webt/br/ba/rf/brbarflmwiprwpmlknhdqpl5muc.jpeg"><br><br>  Quels sont les avantages et les inconvénients?  Le principal avantage - le printemps est très commun dans le monde.  Le prochain plus et moins est la numérisation automatique.  Nous ne devons pas déclarer explicitement nulle part que nous voulons ajouter un conteneur à IoC en plus des annotations sur les classes elles-mêmes.  Assez d'annotations.  Et le moins est exactement le même: si, au contraire, nous voulons contrôler cela, alors Spring ne nous le fournit pas.  À moins que nous ne puissions dire dans notre équipe: «Non, nous ne le ferons pas.  Nous devons clairement prescrire quelque chose quelque part.  Seulement dans la configuration, comme nous l'avons fait avec les haricots. <br><br>  De plus, à cause de cela, un démarrage lent se produit.  Lorsque l'application démarre, Spring doit parcourir toutes ces classes et déterminer ce qu'il faut mettre dans le conteneur IoC.  Cela le ralentit.  Le plus gros inconvénient du printemps, il me semble, est l'arbre de dépendance.  Il n'est pas vérifié au stade de la compilation.  Lorsque Spring démarre à un moment donné, il doit comprendre si j'ai une telle dépendance à l'intérieur.  S'il s'avère plus tard qu'il ne se trouve pas dans l'arborescence des dépendances, vous obtiendrez une erreur lors de l'exécution.  Et nous, en Java, ne voulons pas d'erreur d'exécution.  Nous voulons que le code soit compilé pour nous.  Cela signifie que cela fonctionne. <br><br><img src="https://habrastorage.org/webt/nk/2l/6x/nk2l6x7k1fc6-undofdq53ppj8i.jpeg"><br><br>  Jetons un coup d'œil à Guice.  Il s'agit d'une bibliothèque qui, comme je l'ai dit, a été créée entre le deuxième et le troisième printemps.  La beauté que nous avons vue ne l'était pas.  Il y avait XML.  Pour résoudre ce problème, et a été écrit par Guice.  Et ici, vous pouvez voir que, contrairement à la configuration, nous écrivons un module.  Dans ce document, nous déclarons explicitement quelles classes nous voulons mettre dans ce module: TrackerAPI, TrackerTicketCreator et tous les autres bacs.  Un analogue de l'annotation Bean ici est Provides, qui crée httpClient de la même manière. <br><br><img src="https://habrastorage.org/webt/tf/wc/hn/tfwchnamip5ovyhno-7j_9twrae.jpeg"><br><br>  Nous devons déclarer chacun de ces beans.  Nous citerons un exemple de <a href="https://habr.com/ru/users/singleton/" class="user_link">Singleton</a> .  Mais spécifiquement, <a href="https://habr.com/ru/users/singleton/" class="user_link">Singleton</a> dira qu'un tel bean sera créé exactement une fois.  Nous ne le recréerons pas constamment.  Et <a href="https://habr.com/ru/users/inject/" class="user_link">Inject</a> , respectivement, est un analogue d' <a href="https://habr.com/ru/users/autowired/" class="user_link">Autowired</a> . <br><br><img src="https://habrastorage.org/webt/32/i9/-5/32i9-5iuc58qvzmpiahf_3odv6k.jpeg"><br><br>  Une petite tablette avec ce qui appartient. <br><br><img src="https://habrastorage.org/webt/ny/5o/i4/ny5oi43in62gaprwj4ym5tvuxh8.jpeg"><br><br>  Quels sont les avantages et les inconvénients?  Pour: c'est plus simple, il me semble, et compréhensible que la version XML de Spring.  Démarrage plus rapide.  Et voici le contre: il nécessite une déclaration explicite des beans utilisés.  Nous aurions dû écrire Bean.  Mais d'un autre côté, c'est un plus, comme nous l'avons déjà dit.  Ceci est une image miroir de ce que Spring a.  Bien sûr, c'est moins courant que le printemps.  C'est son inconvénient naturel.  Et il y a exactement le même problème - l'arbre de dépendance n'est pas vérifié au stade de la compilation. <br><br>  Lorsque les gars ont commencé à utiliser Guice pour Android, ils ont réalisé qu'ils manquaient toujours de vitesse de lancement.  Par conséquent, ils ont décidé d'écrire un cadre d'injection de dépendances plus simple et plus primitif qui leur permettra de démarrer rapidement l'application, car pour Android, c'est très important. <br><br><img src="https://habrastorage.org/webt/5x/sp/l7/5xspl7f9z-2xoy22flag9sgrdzy.jpeg"><br><br>  Ici, la terminologie est la même.  Dagger a exactement les mêmes modules que Guice.  Mais ils sont déjà marqués d'annotations, pas comme dans le cas de l'héritage de la classe.  Par conséquent, le principe est maintenu. <br><br>  Le seul inconvénient est que nous devons toujours indiquer explicitement dans le module comment les beans sont créés.  Dans Guice, nous pourrions donner la création de beans à l'intérieur du bean lui-même.  Nous n’avions pas à dire à quel type de dépendances nous devions nous adresser.  Et ici, nous devons le dire explicitement. <br><br><img src="https://habrastorage.org/webt/tu/q7/f8/tuq7f8jjaj-ouvsw1faz8e_8wgm.jpeg"><br><br>  Dans Dagger, parce que vous ne voulez pas faire de saisie trop manuelle, il y a le concept de composant.  Un composant est quelque chose qui lie des modules lorsque nous voulons déclarer un bac d'un module afin qu'il puisse être pris dans un autre module.  C'est un concept différent.  Un bean d'un module peut «injecter» un bean d'un autre module à l'aide d'un composant. <br><br><img src="https://habrastorage.org/webt/16/sn/41/16sn412k1exgnqbuil1mogbtpom.jpeg"><br><br>  Voici à peu près la même plaque récapitulative - ce qui a changé ou n'a pas changé dans le cas d'Inject ou de modules. <br><br><img src="https://habrastorage.org/webt/pm/v1/ur/pmv1urcl1djm48azfby8ux6uqbs.jpeg"><br><br>  Quels en sont les avantages?  C'est encore plus simple que Guice.  Le lancement est encore plus rapide que Guice.  Et cela ne deviendra probablement plus plus rapide, car Dagger a complètement abandonné la réflexion.  C'est exactement la partie de la bibliothèque en Java qui est chargée de regarder l'état d'un objet, sa classe et ses méthodes.  Autrement dit, obtenez l'état en cours d'exécution.  Par conséquent, il n'utilise pas de réflexion.  Il ne va pas et n'analyse pas les dépendances de qui que ce soit.  Mais à cause de cela, il commence très rapidement. <br><br>  Comment le fait-il?  Utilisation de la génération de code. <br><br><img src="https://habrastorage.org/webt/tu/q7/f8/tuq7f8jjaj-ouvsw1faz8e_8wgm.jpeg"><br><br>  Si nous regardons en arrière, nous verrons le composant d'interface.  Nous n'avons implémenté aucune implémentation de cette interface, Dagger le fait pour nous.  Et il sera possible d'utiliser davantage l'interface dans l'application. <br><br><img src="https://habrastorage.org/webt/pm/v1/ur/pmv1urcl1djm48azfby8ux6uqbs.jpeg"><br><br>  Naturellement, il est très courant dans le monde Android en raison de cette vitesse.  L'arbre des dépendances est vérifié immédiatement lors de la compilation, car il n'y a rien que nous vérifierons différemment lors de l'exécution. <br><br>  Quels sont les inconvénients?  Il a moins d'opportunités.  Il est plus verbeux que Guice et Spring. <br><br><img src="https://habrastorage.org/webt/cx/m8/ng/cxm8ngienchgjtm4yc1m7uo26bo.jpeg"><br><br>  Au sein de ces bibliothèques, une initiative a vu le jour en Java - le soi-disant JSR-330.  JSR est une demande de modification de la spécification de langue ou de la compléter avec quelques bibliothèques supplémentaires.  Une telle norme a été proposée sur la base de Guice, et des annotations d' <a href="https://habr.com/ru/users/inject/" class="user_link">injection</a> ont été ajoutées à cette bibliothèque.  En conséquence, Spring et Guice l'appuient. <br><br>  Quelles conclusions peut-on en tirer?  Java a beaucoup de bibliothèques différentes pour DI.  Et vous devez comprendre pourquoi nous en prenons un spécifique.  Si nous prenons Android, alors il n'y a déjà pas le choix, nous utilisons Dagger.  Si nous allons dans le monde du backend, nous cherchons déjà ce qui nous convient le mieux.  Et pour la première étude de Dependency Injection, il me semble que Guice est meilleur que Spring.  Il n'y a rien de superflu là-dedans.  Vous pouvez voir comment cela fonctionne, sentir. <br><br>  Pour une étude plus approfondie, je vous suggère de vous familiariser avec la documentation de toutes ces bibliothèques et la composition de JSR: <br>  - <a href="https://spring.io/">Printemps</a> <br>  - <a href="https://github.com/google/guice/">Guice</a> <br>  - <a href="https://github.com/google/dagger">Dague 2</a> <br>  - <a href="https://github.com/javax-inject/javax-inject">JSR-330</a> <br><br>  Je vous remercie! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr478788/">https://habr.com/ru/post/fr478788/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr478760/index.html">L'enfer "zéro" et comment s'en sortir</a></li>
<li><a href="../fr478764/index.html">Erreurs JavaScript: correction, traitement, réparation</a></li>
<li><a href="../fr478766/index.html">Personnaliser le mappage des contrôleurs Spring MVC</a></li>
<li><a href="../fr478772/index.html">Texture convolutionnelle</a></li>
<li><a href="../fr478774/index.html">Ambiance du Nouvel An d'Arduino et de bâtons</a></li>
<li><a href="../fr478790/index.html">Julia et la sémantique de distribution</a></li>
<li><a href="../fr478796/index.html">Premier cycle aux États-Unis: un moyen non conventionnel d'atteindre les meilleures écoles secondaires</a></li>
<li><a href="../fr478798/index.html">Le graphène, qui ne pouvait toujours pas</a></li>
<li><a href="../fr478802/index.html">Réact-admin et framework de repos django</a></li>
<li><a href="../fr478812/index.html">Développer un hexapode à partir de zéro (partie 6) - transition vers l'impression 3D</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>