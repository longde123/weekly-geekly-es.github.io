<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚒 🐚 🕋 Migración perfecta (casi) entre las principales versiones de PostgreSQL utilizando replicación lógica 🧓🏾 🥀 ▫️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En True Engineering, en un proyecto, ha surgido la necesidad de cambiar la versión de PostgreSQL de 9.6 a 11.1. 

 Por qué La base de datos del proyec...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Migración perfecta (casi) entre las principales versiones de PostgreSQL utilizando replicación lógica</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/true_engineering/blog/437318/">  En True Engineering, en un proyecto, ha surgido la necesidad de cambiar la versión de PostgreSQL de 9.6 a 11.1. <br><br>  Por qué  La base de datos del proyecto ya tiene un tamaño de 1,5 Tb y está creciendo.  El rendimiento es uno de los principales requisitos del sistema.  Y la estructura de datos en sí misma está evolucionando: se agregan nuevas columnas, se cambian las existentes.  La nueva versión de Postgres ha aprendido cómo trabajar de manera eficiente con la adición de nuevas columnas con un valor predeterminado, por lo que no hay necesidad de cercar muletas personalizadas a nivel de aplicación.  Incluso en la nueva versión, se agregaron varias formas nuevas de particionar tablas, lo que también es extremadamente útil en condiciones de una gran cantidad de datos. <br><br>  Entonces, se decide, estamos migrando.  Por supuesto, puede generar una nueva versión del servidor PostgreSQL en paralelo con el anterior, detener la aplicación, usar dump / restore (o pg_upgrade) para mover la base de datos y reiniciar la aplicación.  Esta solución no nos convenía debido al gran tamaño de la base, además, la aplicación funciona en modo de combate, y solo quedan unos minutos para el tiempo de inactividad. <br><br>  Por lo tanto, decidimos probar la migración usando la replicación lógica en PostgreSQL usando un complemento de terceros llamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pglogical</a> . <br><br>  En el proceso de "prueba", nos encontramos con documentación muy fragmentaria sobre este proceso (y en ruso no lo es en absoluto), así como algunas trampas y matices obvios.  En este artículo, queremos presentar nuestra experiencia en forma de tutorial. <br><br><img src="https://habrastorage.org/webt/cp/i7/oi/cpi7oixtsenmioqdrcyyotgagyk.png"><br><br>  <b>TL; DR</b> <br><br><ul><li>  Todo resultó (no sin muletas, un artículo sobre ellos). </li><li>  Puede migrar dentro de la versión PostgreSQL de 9.4 a 11.x, de cualquier versión a cualquiera, hacia abajo o hacia arriba. </li><li>  El tiempo de inactividad es igual al tiempo que le toma a su aplicación volver a conectarse al nuevo servidor de base de datos (en nuestro caso, fue un reinicio de toda la aplicación, pero en la naturaleza, obviamente, "posibles opciones"). </li></ul><a name="habracut"></a><br><h3>  ¿Por qué no nos quedaba la solución de "frente"? </h3><br>  Como ya dijimos, la salida más fácil es elevar la nueva versión del servidor PostgreSQL en paralelo con la anterior, detener la aplicación, usar dump / restore (o pg_upgrade) para mover la base de datos e iniciar la aplicación nuevamente.  Para bases de datos de pequeño volumen, en principio, esta es una opción bastante adecuada (o, en el caso general, el volumen no es importante cuando tiene la opción de tiempo de inactividad de la aplicación durante el período de "transfusión" de la base de datos del servidor antiguo al nuevo, sin importar cuánto tiempo sea este tiempo).  Pero en nuestro caso, la base de datos ocupa aproximadamente 1,5 Tb en el disco, y moverla no es cuestión de minutos, sino de varias horas.  La aplicación, a su vez, funciona en modo de combate, y realmente quería evitar el tiempo de inactividad durante más de un par de minutos. <br><br>  También contra esta opción estaba el hecho de que usamos la replicación Maestro-Esclavo y no podemos apagar el servidor Esclavo del flujo de trabajo de manera segura.  Por lo tanto, para cambiar la aplicación de la versión anterior de PostgreSQL a la nueva después de la migración del servidor maestro, sería necesario preparar un nuevo servidor esclavo antes de iniciar la aplicación.  Y esto es unas pocas horas más de tiempo de inactividad hasta que se crea el Esclavo (aunque mucho menos que la migración del Maestro). <br><br>  Por lo tanto, decidimos probar la migración usando la replicación lógica en PostgreSQL usando un complemento de terceros llamado pglogical. <br><br><h3>  Información general </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pglogical</a> es un sistema de replicación lógica que utiliza decodificación lógica nativa en PostgreSQL e implementado como una extensión de PostgreSQL.  Le permite configurar la replicación selectiva utilizando el modelo de suscripción / publicación.  No requiere la creación de disparadores en la base de datos o el uso de utilidades externas para la replicación. <br><br>  La extensión funciona en cualquier versión de PostgreSQL, comenzando desde 9.4 (ya que la Decodificación lógica apareció por primera vez en 9.4), y le permite migrar entre cualquier versión compatible de PostgreSQL en cualquier dirección. <br><br>  Configurar manualmente la replicación usando pglogical manualmente no es muy trivial, aunque en principio es bastante posible.  Afortunadamente, hay un programa de utilidad de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">terceros</a> para automatizar el proceso de configuración, que utilizaremos. <br><br><h3>  Memo de espacio en disco </h3><br>  Como planeamos actualizar la nueva versión de PostgreSQL en los mismos servidores en paralelo con la anterior, los requisitos de disco para la base de datos en los servidores Maestro y Esclavo se duplican.  Parece que esto es obvio, pero ... Solo cuide suficiente espacio libre antes de comenzar la replicación para no lamentar los años gastados sin rumbo. <br><br>  En nuestro caso, se requirieron modificaciones en la base de datos, más el formato de almacenamiento durante la migración entre 9.6 y 11 "swells" no a favor de la última versión, por lo que el espacio en disco no tuvo que incrementarse en 2, sino en aproximadamente 2.2 veces.  Alabado sea LVM, esto se puede hacer en el proceso de migración sobre la marcha. <br><br>  En general, cuídalo. <br><br><h3>  Instalar PostgreSQL 11 en Master </h3><br><blockquote>  Nota: Utilizamos Oracle Linux, y todo lo siguiente se agudizará para esta distribución.  Es posible que otras distribuciones de Linux requieran una pequeña revisión con un archivo, pero es poco probable que sea significativo. </blockquote><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   yum install https://download.postgresql.org/pub/repos/yum/11/redhat/rhel-7-x86_64/pgdg-oraclelinux11-11-2.noarch.rpm #   postgresql11 yum install postgresql11 postgresql11-devel postgresql11-server postgresql11-contrib #   /usr/pgsql-11/bin/postgresql-11-setup initdb</span></span></code> </pre> <br>  El antiguo datadir se encuentra en <b>/var/lib/pgsql/9.6/data</b> , el nuevo, respectivamente, está en <b>/ var / lib / pgsql / 11 / data</b> <br><br>  Copie la configuración de acceso ( <b>pg_hba.conf</b> ) y la configuración del servidor ( <b>postgresql.conf</b> ) de 9.6 a 11. <br><br>  Para ejecutar dos servidores PostgreSQL en la misma máquina, en la configuración de configuración <b>postgresql.conf</b> 11, cambie el puerto a 15432 (puerto = 15432). <br><br>  Aquí debe pensar detenidamente qué más debe hacer en la nueva versión de PostgreSQL específicamente en su caso, para que comience con su <b>postgresql.conf</b> (y su aplicación eventualmente podría funcionar con él).  En nuestro caso, fue necesario instalar las extensiones PostgreSQL que usamos en la nueva versión.  Esto está más allá del alcance del artículo, solo haga que el nuevo PostgreSQL se inicie, funcione y se adapte completamente a usted :) <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  ,  ,  shared libraries, whatever... # .... #  systemctl enable postgresql-11 systemctl start postgresql-11</span></span></code> </pre> <br>  Buscamos en <b>/ var / lib / pgsql / 11 / data / pg_log /</b> .  ¿Está todo bien?  Continuamos! <br><br><h3>  Instalar y configurar pgrepup </h3><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  python yum install python yum install python2-pip #  pgrepup pip install pgrepup #   pgrepup config</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/zg/xz/9o/zgxz9oct5l-qglkxyeyrqejh4we.png"><br><br>  Matices: <br><br><ol><li>  Como <b>propietario de la aplicación,</b> especificamos el usuario bajo el cual se ejecutan los servidores PostgreSQL. </li><li>  Para <b>Base de datos,</b> especifique <b>template1</b> . </li><li>  <b>Nombre de usuario</b> y <b>contraseña</b> : datos para acceso de superusuario.  En nuestro caso, el método de <b>confianza</b> se especificó en <b>pg_hba.conf</b> para las conexiones locales del usuario de <b>postgres</b> , por lo que puede especificar una contraseña arbitraria. </li></ol><br><h3>  Configurar replicación </h3><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   pgrepup check</span></span></code> </pre><br>  Obtenemos la salida de una lista de muchos parámetros que deben configurarse según sea necesario. <br><br>  Resultados de verificación de ejemplo: <br><br><img src="https://habrastorage.org/webt/h3/wu/zm/h3wuzmcevo7idf-xlyrz3ae8av8.png"><br><br><img src="https://habrastorage.org/webt/58/zh/bb/58zhbbubdbfvzzgat051bviywqy.png"><br><br>  Todos los errores durante la verificación deberán ser eliminados.  En la configuración de ambos servidores se debe establecer <b>wal_level = LOGICAL</b> (para que funcione la decodificación lógica), la configuración necesaria para el motor de replicación (número de slots y <b>wal_senders</b> ).  Las sugerencias de la utilidad pgrepup son bastante informativas; las preguntas no deberían surgir en la mayoría de los puntos. <br><br>  Realizamos todas las configuraciones necesarias que pgrepup solicita. <br><br>  En ambos archivos <b>pg_hba.conf</b> agregamos permisos para el usuario que realizará la replicación, todo en el indicador pgrepup: <br><br><pre> <code class="bash hljs">host replication pgrepup_replication 127.0.0.1/32 md5 host all pgrepup_replication 127.0.0.1/32 md5</code> </pre> <br><h3>  Agregar claves primarias </h3><br>  Para que la replicación funcione, se debe definir una clave primaria en todas las tablas. <br><br>  En nuestro caso, PK no estaba en todas partes, por lo tanto, en el momento de la replicación, debe agregarlo y, al final de la replicación, si es necesario, eliminarlo. <br><br>  Una lista de tablas sin PK, entre otras cosas, produce la <code>pgrepup check</code> .  Para todas las tablas de esta lista, debe agregar una clave principal de la manera que más le convenga.  En nuestro caso, fue algo como: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> %s <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> temporary_pk <span class="hljs-type"><span class="hljs-type">BIGSERIAL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span></code> </pre> <br>  La utilidad pgrepup tiene un comando incorporado para llevar a cabo esta operación ( <code>pgrepup fix</code> ), y cuando se usa, incluso se da a entender que, tras una replicación exitosa, estas columnas temporales se eliminarán automáticamente.  Pero, desafortunadamente, esta funcionalidad era tan ilusoria y encantadora con errores en grandes bases que decidimos no usarla, sino hacer esta operación manualmente ya que nos sentimos cómodos. <br><br><h3>  Instalar extensión pglogical </h3><br>  Las instrucciones para instalar la extensión se pueden encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> .  La extensión debe estar instalada en ambos servidores. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#       curl https://access.2ndquadrant.com/api/repository/dl/default/release/9.6/rpm | bash curl https://access.2ndquadrant.com/api/repository/dl/default/release/11/rpm | bash #   yum install postgresql96-pglogical postgresql11-pglogical</span></span></code> </pre> <br>  Agregue la carga de la biblioteca en <b>postgresql.conf de</b> ambos servidores: <br><br><pre> <code class="bash hljs">shared_preload_libraries = <span class="hljs-string"><span class="hljs-string">'pglogical'</span></span></code> </pre> <br><h3>  Instalar la extensión pgl_ddl_deploy </h3><br>  Esta es una extensión auxiliar que utiliza pgrepup para la replicación lógica DDL. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#      git clone https://github.com/enova/pgl_ddl_deploy.git #       PATH=/usr/pgsql-9.6/bin/:$PATH USE_PGXS=1 make USE_PGXS=1 make install make clean #       PATH=/usr/pgsql-11/bin/:$PATH make CLANG=true make install</span></span></code> </pre> <br>  Agregue la carga de la biblioteca en <b>postgresql.conf de</b> ambos servidores: <br><br><pre> <code class="bash hljs">shared_preload_libraries = <span class="hljs-string"><span class="hljs-string">'pglogical,pgl_ddl_deploy'</span></span></code> </pre> <br><h3>  Comprobación de cambios </h3><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   postgresql systemctl restart postgresql-11</span></span></code> </pre> <br>  Ahora, utilizando la <code>pgrepup check</code> , debe asegurarse de que todo esté bien con el servidor de destino y que todos los comentarios sobre el servidor de destino se hayan eliminado por completo. <br><br>  Si todo está bien, puede reiniciar el servidor anterior.  Aquí debe pensar cómo reaccionará su aplicación ante el reinicio del servidor de base de datos, tal vez debería detenerlo primero. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  systemctl restart postgresql-9.6 #  pgrepup check</span></span></code> </pre> <br>  Ahora en la salida del comando, todos los elementos deben estar marcados como OK. <br><br>  Parece que puedes comenzar la migración, pero ... <br><br><h3>  Corregir errores de pgrepup </h3><br>  Hay varios errores en la versión actual de pgrepup que hacen imposible la migración.  Se enviaron solicitudes de extracción, pero desafortunadamente, se ignoran, por lo que deberá realizar correcciones manualmente. <br><br>  Vamos a la carpeta de instalación de pgrepup (nuestro caso es <b>/usr/lib/python2.7/site-packages/pgrepup/commands/</b> ). <br><br>  Hazlo una vez.  En cada archivo <b>* .py</b> , agregue los <code>**kwargs</code> faltantes en la descripción de la función.  Una imagen es mejor que mil palabras: <br><br><img src="https://habrastorage.org/webt/l3/zc/uo/l3zcuo2exe8lq_0u3gwv_nq8jty.png"><br><br>  Comprométete <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . <br><br>  Hacer dos.  En <b>setup.py</b> hacemos una búsqueda de "sh -c", dos entradas, todos los comandos de shell de varias líneas deben hacerse de una sola línea. <br><br>  Comprométete <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . <br><br><h3>  Comience la migración </h3><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  pgrepup setup</span></span></code> </pre> <br>  Con este comando, pgrepup prepara ambos servidores para iniciar la replicación, crea un usuario, configura pglogical y transfiere el esquema de la base de datos. <br><br><img src="https://habrastorage.org/webt/ww/km/jd/wwkmjdmmpmwyvgbdqyktohnhmmy.png"><br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   pgrepup start</span></span></code> </pre> <br>  Él dijo: "¡Vamos!"  y agitó su mano: <br><br><img src="https://habrastorage.org/webt/3k/xc/_r/3kxc_rgde-t7q6yuhtvwkol5acs.png"><br><br>  La replicación se está ejecutando.  La situación actual se puede ver usando el <code>pgrepup status</code> : <br><br><img src="https://habrastorage.org/webt/ig/gs/wb/iggswbqldii-c6cd5a1y7qyqawu.png"><br><br>  Aquí vemos que dos bases de datos ya se han movido y la replicación está en progreso, y una todavía está en proceso de moverse.  Ahora solo queda tomar café y esperar hasta que se bombee todo el volumen de la base de datos original. <br><br>  En el camino, puede mirar más profundamente en la fachada de pgrepup y ver qué sucede debajo del capó.  Para las mentes inquisitivas, aquí hay una lista de consultas como punto de partida: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_replication_origin_status <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> remote_lsn <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> *,pg_xlog_location_diff(s.sent_location,s.replay_location) byte_lag <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_replication s; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> query <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> application_name=<span class="hljs-string"><span class="hljs-string">'subscription_copy'</span></span></code> </pre> <br>  Teniendo mucho café (en el servidor de prueba al escribir este artículo, la migración de ~ 700Gb de datos duró alrededor de un día), finalmente vemos la siguiente imagen: <br><br><img src="https://habrastorage.org/webt/ep/2e/q2/ep2eq2c_mtywxboftk4ocb0e_1c.png"><br><br>  Y eso significa que es hora de preparar un nuevo Esclavo. <br><br><h3>  Instalar PostgreSQL 11 en Slave </h3><br>  Aquí todo es simple y de acuerdo con el libro de texto, sin matices. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   yum install https://download.postgresql.org/pub/repos/yum/11/redhat/rhel-7-x86_64/pgdg-oraclelinux11-11-2.noarch.rpm #  postgresql 11 yum install postgresql11 postgresql11-devel postgresql11-server postgresql11-contrib #      su - postgres pg_basebackup -h db-master.hostname -p 15432 -D /var/lib/pgsql/11/data/ -R -P -U replication -X stream -c fast</span></span></code> </pre> <br>  Copie la configuración de acceso ( <b>pg_hba.conf</b> ) y la configuración del servidor ( <b>postgresql.conf</b> ) de 9.6 a 11. En la configuración de la versión <b>postgresql.conf</b> 11, cambie el puerto a 15432 (puerto = 15432) <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  systemctl enable postgresql-11 systemctl start postgresql-11</span></span></code> </pre> <br><pre> <code class="pgsql hljs">#     Master <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> *,pg_wal_lsn_diff(s.sent_lsn,s.replay_lsn) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> byte_lag <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_replication s; #     Slave <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> now()-pg_last_xact_replay_timestamp();</code> </pre><br><h3>  Subtotales </h3><br>  Después de todos estos procedimientos, obtenemos este complicado esquema de replicación: <br><br><img src="https://habrastorage.org/webt/70/ns/ej/70nsejcslxlccih_yktvesptqjg.png"><br><br>  Aquí, como verificación final (y, al final, es simplemente hermosa), puede hacer alguna ACTUALIZACIÓN en la base de datos maestra 9.6 y ver cómo se replica en los otros tres servidores. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c0/c42/89e/7c0c4289e8a00b100f58ce751bd9209e.png" alt="imagen"><br><br><h3>  Cambiar la aplicación a la nueva versión de PostgreSQL </h3><br>  Hasta ahora, nuestra aplicación no ha sospechado nada sobre la nueva versión de PostgreSQL, es hora de solucionarlo.  Las opciones aquí dependen fundamentalmente de solo dos cosas: <br>  ¿Superará los nuevos servicios en los mismos puertos en los que trabajaban los antiguos, <br>  y si su aplicación requiere un reinicio al reiniciar el servidor de bases de datos. <br><br>  Por diversión, responderemos ambas preguntas "sí" y procederemos. <br><br>  Paramos la aplicación. <br><br><pre> <code class="pgsql hljs"># ,   , : <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity;</code> </pre> <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#    #       sequences. pgrepup stop</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/cz/hc/2t/czhc2t8k6pjk-6ivvilidj5k9xq.png"><br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#      pgrepup uninstall</span></span></code> </pre><br><img src="https://habrastorage.org/webt/2w/ud/dq/2wuddqovqbninwwz9rx9fia8psa.png"><br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  master: #    systemctl disable postgresql-9.6 #   ,  ,  . systemctl stop postgresql-9.6 systemctl stop postgresql-11 #  slave: #    systemctl disable postgresql-9.6 #   ,  ,  . systemctl stop postgresql-9.6 systemctl stop postgresql-11</span></span></code> </pre> <br>  Devolvemos el puerto estándar en la configuración <b>postgresql.conf</b> de la nueva versión a Master and Slave. <br><br>  En el nuevo Slave, también cambiamos el puerto al estándar en <b>recovery.conf</b> . <br><br>  En el camino, hay una sugerencia de pecado para cambiar aún más el puerto en la versión antigua inactiva: <br>  Exponemos el puerto no estándar en <b>postgresql.conf de la</b> versión anterior a Master y Slave. <br>  En el viejo Slave, también cambiamos el puerto a uno no estándar en <b>recovery.conf</b> . <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   master systemctl enable postgresql-11 systemctl start postgresql-11 #   slave: systemctl enable postgresql-11 systemctl start postgresql-11</span></span></code> </pre> <br>  Revisa los registros. <br><br>  Verifique el estado de replicación en el maestro. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> *,pg_wal_lsn_diff(s.sent_lsn,s.replay_lsn) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> byte_lag <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_replication s;</code> </pre> <br>  Lanzamos la aplicación.  Estamos felices por media hora. <br><br>  <b>Y finalmente, literatura útil sobre el tema:</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pglogical</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Instrucciones de instalación para pglogical</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentos lógicos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Actualización de PostgreSQL de 9.4 a 10.3 con pglogical</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pgrepup - actualiza PostgreSQL usando replicación lógica</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pgrepup - PostgreSQL REPlicate y UPgrade</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Actualización de PostgreSQL de 9.6 a 10 con un tiempo de inactividad mínimo utilizando pglogical</a> </li></ul><br>  Buena suerte </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/437318/">https://habr.com/ru/post/437318/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../437308/index.html">Ciclo de lecciones de SDL 2.0: Lección 4 - Manejo de eventos</a></li>
<li><a href="../437310/index.html">CSS Gradient Borders</a></li>
<li><a href="../437312/index.html">Implementación de una recarga en caliente de código C ++ en Linux y macOS: profundizando</a></li>
<li><a href="../437314/index.html">Enigma italiano: máquinas criptográficas OMI</a></li>
<li><a href="../437316/index.html">El Internet Development Institute ha nombrado sitios que pueden estar desconectados de RuNet desde el 1 de febrero</a></li>
<li><a href="../437320/index.html">Índice de desarrollo de la esfera mediática 2018: estancamiento de la televisión, mayor confianza en los medios informales</a></li>
<li><a href="../437322/index.html">El estado participa en BigDate</a></li>
<li><a href="../437324/index.html">Beso sangriento: propiedades de vasorelajación de la saliva de los murciélagos vampiros</a></li>
<li><a href="../437326/index.html">Sobre el tema de la multiplicación, extracción de raíz cuadrada, sustitución de importaciones y la empresa Milander</a></li>
<li><a href="../437330/index.html">devleads - habla sobre el agotamiento</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>