<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👃🏾 🚿 👰🏾 Hyperledger Fabric Pengembangan dan Pengujian Kontrak Pintar 🧗🏻 🏪 ➰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hyperledger Fabric (HLF) adalah platform sumber terbuka yang menggunakan teknologi leded ledger (DLT), yang dirancang untuk mengembangkan aplikasi yan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hyperledger Fabric Pengembangan dan Pengujian Kontrak Pintar</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426705/"><p>  Hyperledger Fabric (HLF) adalah platform sumber terbuka yang menggunakan teknologi leded ledger (DLT), yang dirancang untuk mengembangkan aplikasi yang bekerja di lingkungan jaringan bisnis yang dibuat dan dikendalikan oleh konsorsium organisasi menggunakan aturan izin. </p><br><p>  Platform ini mendukung kontrak pintar, dalam istilah HLF - kode rantai yang dibuat dalam bahasa umum seperti Golang, JavaScript, Java, tidak seperti, misalnya, Ethereum, yang menggunakan fungsionalitas terbatas yang berorientasi kontrak dan fungsionalitas Bahasa soliditas (LLL, Viper, dll.). </p><br><p><img src="https://habrastorage.org/webt/w4/em/ps/w4empss606_8k1h8tvkcmfim4c8.png"></p><br><p>  Pengembangan dan pengujian kode rantai, karena kebutuhan untuk menggunakan sejumlah besar komponen jaringan blockchain, dapat menjadi proses yang agak panjang dengan waktu yang dihabiskan untuk menguji perubahan.  Artikel ini membahas pendekatan pengembangan cepat dan pengujian kontrak pintar HLF Golang menggunakan perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CCKit</a> . </p><a name="habracut"></a><br><h2 id="prilozhenie-na-baze-hlf">  Aplikasi berbasis HLF </h2><br><p>  Dari sudut pandang pengembang, aplikasi blockchain terdiri dari dua bagian utama: </p><br><ul><li>  <strong>On-chain</strong> - kontrak pintar (program) yang beroperasi di lingkungan terisolasi dari jaringan blockchain yang menentukan aturan untuk membuat dan komposisi atribut transaksi.  Dalam kontrak pintar, tindakan utama adalah membaca, memperbarui, dan menghapus data dari keadaan jaringan blockchain.  Harus ditekankan bahwa menghapus data dari keadaan meninggalkan informasi bahwa data ini ada. </li><li>  <strong>Off-chain</strong> adalah aplikasi (misalnya, API) yang berinteraksi dengan lingkungan blockchain melalui SDK.  Interaksi dipahami sebagai panggilan fungsi kontrak pintar dan pemantauan peristiwa kontrak pintar - peristiwa eksternal dapat menyebabkan perubahan data dalam kontrak pintar, sementara peristiwa dalam kontrak pintar dapat memicu tindakan dalam sistem eksternal. </li></ul><br><p>  Data biasanya dibaca melalui simpul jaringan blockchain "home".  Untuk merekam data, aplikasi mengirimkan permintaan ke node organisasi yang berpartisipasi dalam "kebijakan persetujuan" dari kontrak pintar tertentu. </p><br><p>  Untuk mengembangkan kode off-chain (API, dll.), SDK khusus digunakan yang merangkum interaksi dengan node blockchain, mengumpulkan tanggapan, dll.  Untuk HLF, ada implementasi SDK untuk Go ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2</a> ), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Node.Js</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Java</a> </p><br><h2 id="komponenty-hyperledger-fabric">  Komponen Kain Hyperledger </h2><br><h3 id="kanal">  Saluran </h3><br><p>  Saluran adalah subnet node yang terpisah yang mendukung rantai blok terisolasi (buku besar), serta status saat ini (nilai kunci) rantai blok ( <em>negara dunia</em> ) yang digunakan untuk mengoperasikan kontrak pintar.  Sebuah host dapat memiliki akses ke sejumlah saluran yang berubah-ubah. </p><br><h3 id="tranzakciya">  Transaksi </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Transaksi di Hyperledger Fabric</a> adalah pembaruan atom dari keadaan rantai blok, hasil dari eksekusi metode chaincode.  Suatu transaksi terdiri dari permintaan untuk memanggil metode chaincode dengan beberapa argumen (Proposal Transaksi) yang ditandatangani oleh node panggilan dan serangkaian respons (Respon Proposal Transaksi) dari node di mana transaksi itu “dikonfirmasi” (Endorsement).  Respons berisi informasi tentang pasangan nilai kunci yang berubah dari status rantai blok <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Baca-Tulis</a> dan informasi layanan (tanda tangan dan sertifikat node yang mengkonfirmasikan transaksi).  Karena  rantai blok saluran individu dipisahkan secara fisik, transaksi hanya dapat dilakukan dalam konteks satu saluran. </p><br><p>  Platform blockchain "klasik", seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bitcoin</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ethereum</a> , menggunakan siklus transaksi Pemesanan-Eksekusi yang dilakukan oleh semua node, yang membatasi skalabilitas jaringan blockchain. </p><br><p><img src="https://habrastorage.org/webt/ad/-b/ud/ad-budtoazz80tcc2vcgmzyahve.png"></p><br><p>  Hyperledger Fabric menggunakan eksekusi transaksi dan arsitektur distribusi yang memiliki 3 operasi utama: </p><br><ul><li><p>  Eksekusi ( <strong>eksekusi</strong> ) - penciptaan oleh kontrak pintar yang berjalan pada satu atau beberapa node jaringan, transaksi - perubahan atom dalam keadaan registri terdistribusi ( <em>dukungan</em> ) </p><br></li><li><p>  Memesan - memesan dan mengelompokkan transaksi ke dalam blok oleh layanan <em>pemesan</em> khusus menggunakan algoritma konsensus pluggable. </p><br></li><li><p>  Validasi - verifikasi oleh node jaringan transaksi yang berasal dari <em>pemesan</em> sebelum menempatkan informasi dari mereka dalam salinan registri terdistribusi </p><br></li></ul><br><p><img src="https://habrastorage.org/webt/xw/ss/xj/xwssxjcfyfmsydsfnyl4oey_coe.png"></p><br><p>  Pendekatan ini memungkinkan Anda untuk melakukan fase eksekusi transaksi sebelum memasuki jaringan blockchain, serta secara horizontal skala operasi node jaringan. </p><br><h3 id="cheynkod">  Kode rantai </h3><br><p>  Chaincode, yang juga bisa disebut kontrak pintar, adalah program yang ditulis dalam Golang, JavaScript (HLF 1.1+) atau Java (HLF 1.3+), yang mendefinisikan aturan untuk membuat transaksi yang mengubah keadaan rantai blok.  Program ini dijalankan secara bersamaan pada beberapa node independen dari jaringan terdistribusi dari blockchain node, yang menciptakan lingkungan netral untuk pelaksanaan kontrak pintar dengan merekonsiliasi hasil program pada semua node yang diperlukan untuk "konfirmasi" transaksi. </p><br><p>  Kode harus mengimplementasikan antarmuka yang terdiri dari metode: </p><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Chaincode <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Init is called during Instantiate transaction Init(stub ChaincodeStubInterface) pb.Response // Invoke is called to update or query the ledger Invoke(stub ChaincodeStubInterface) pb.Response }</span></span></code> </pre> <br><ul><li>  Metode <strong>Init</strong> dipanggil berdasarkan instantiasi atau peningkatan kode.  Metode ini melakukan inisialisasi yang diperlukan dari keadaan kode kode.  Penting untuk membedakan dalam kode metode apakah panggilan itu merupakan instantiasi atau upgrade, sehingga secara tidak sengaja Anda tidak menginisialisasi (mereset) data yang telah menerima keadaan tidak nol selama pengoperasian kode kode. </li><li>  Metode <strong>Invoke</strong> dipanggil ketika fungsi kode apa pun diakses.  Metode ini berfungsi dengan status kontrak pintar. </li></ul><br><p>  Chaincode diinstal pada rekan-rekan jaringan blockchain.  Pada tingkat sistem, setiap instance kode sesuai dengan wadah buruh pelabuhan yang terpasang pada node jaringan tertentu, yang melakukan pengiriman panggilan ke eksekusi kode. <br>  Tidak seperti kontrak pintar Ethereum, logika rantai dapat diperbarui, tetapi ini mengharuskan semua node yang meng-host kode kode menginstal versi yang diperbarui. </p><br><p>  Menanggapi panggilan ke fungsi chaincode dari luar melalui SDK, chaincode menciptakan perubahan dalam status rantai blok ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Set Baca-Tulis</a> ), serta acara.  Chaincode mengacu pada saluran tertentu dan dapat mengubah data hanya dalam satu saluran.  Pada saat yang sama, jika host tempat kode diinstal juga memiliki akses ke saluran lain, dalam logika kode dapat membaca data dari saluran ini. </p><br><p>  Kode rantai khusus untuk mengelola berbagai aspek pengoperasian jaringan blockchain disebut kode rantai sistem. </p><br><h3 id="politika-odobreniya-endorsement-policy">  Kebijakan Pengesahan </h3><br><p>  Kebijakan persetujuan mendefinisikan aturan konsensus di tingkat transaksi yang dihasilkan oleh kode rantai tertentu.  Kebijakan menetapkan aturan yang menentukan node saluran mana yang harus melakukan transaksi.  Untuk melakukan ini, setiap node yang ditentukan dalam kebijakan persetujuan harus menjalankan metode chaining (langkah "Execute"), melakukan "simulasi", setelah itu hasil yang ditandatangani akan dikumpulkan dan diverifikasi oleh SDK yang memulai transaksi (semua hasil simulasi harus identik, tanda tangan semua node yang diperlukan oleh kebijakan harus ada).  Selanjutnya, SDK mengirimkan transaksi ke <em>pemesan</em> , setelah semua node yang memiliki akses ke saluran akan menerima transaksi melalui <em>pemesan</em> dan melakukan langkah "Validasi".  Penting untuk menekankan bahwa tidak semua node saluran harus berpartisipasi dalam langkah "Jalankan". </p><br><p>  Kebijakan persetujuan ditentukan pada saat instantiate atau peningkatan kode.  Dalam versi 1.3, menjadi mungkin untuk menetapkan kebijakan tidak hanya pada tingkat kode rantai, tetapi juga pada tingkat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kunci dukungan</a> individu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berbasis negara</a> .  Contoh kebijakan persetujuan: </p><br><ul><li>  Node A, B, C, D </li><li>  Sebagian besar saluran node </li><li>  Setidaknya 3 node dari A, B, C, D, E, F </li></ul><br><h3 id="sobytie">  Acara </h3><br><p>  Suatu peristiwa adalah kumpulan data bernama yang memungkinkan Anda untuk mempublikasikan "feed pembaruan" dari keadaan rantai blockchain.  Set atribut event menentukan chaincode. </p><br><h2 id="infrastruktura-seti">  Infrastruktur jaringan </h2><br><h3 id="uzel-seti-peer">  Tuan rumah (Peer) </h3><br><p>  Host terhubung ke sejumlah saluran yang sewenang-wenang yang memiliki hak akses.  Tuan rumah memelihara versinya dari rantai blok dan keadaan rantai blok, dan juga menyediakan lingkungan untuk menjalankan kode rantai.  Jika host bukan bagian dari kebijakan persetujuan, maka itu tidak harus diatur dengan kode rantai. </p><br><p>  Pada tingkat perangkat lunak host, status rantai blok saat ini (negara dunia) dapat disimpan di LevelDB atau di CouchDB.  Keuntungan CouchDB adalah dukungannya untuk kueri kaya menggunakan sintaksis MongoDB. </p><br><h3 id="orderer">  Pemesan </h3><br><p>  Layanan manajemen transaksi menerima transaksi yang ditandatangani sebagai input dan memastikan bahwa transaksi didistribusikan di seluruh node jaringan dalam urutan yang benar. </p><br><p>  Pemesan tidak menjalankan kontrak pintar dan tidak mengandung rantai blok dan status rantai blok.  Saat ini (1.3) ada dua implementasi dari <em>orderer</em> - <em>solo</em> pengembangan dan versi berdasarkan Kafka yang memberikan toleransi kesalahan kerusakan.  Implementasi <em>orderer yang</em> mendukung resistensi terhadap perilaku yang salah dari sebagian kecil peserta (toleransi kesalahan Bizantium) diharapkan pada akhir 2018. </p><br><h3 id="servis-identifikacii-membership-services">  Layanan Identitas </h3><br><p>  Dalam jaringan Hyperledger Fabric, semua anggota memiliki identitas yang diketahui anggota lain (identitas).  Untuk identifikasi, infrastruktur kunci publik (PKI) digunakan, di mana sertifikat X.509 dibuat untuk organisasi, elemen infrastruktur (simpul, pemesan), aplikasi, dan pengguna akhir.  Akibatnya, akses untuk membaca dan memodifikasi data dapat dikendalikan oleh aturan akses di tingkat jaringan, pada satu saluran, atau dalam logika kontrak pintar.  Dalam jaringan blockchain yang sama, beberapa layanan identifikasi dari berbagai jenis dapat bekerja secara bersamaan. </p><br><h1 id="realizaciya-cheynkoda">  Implementasi kode kode </h1><br><p>  Chaincode dapat dianggap sebagai objek yang memiliki metode yang menerapkan logika bisnis tertentu.  Tidak seperti OOP klasik, chaincode tidak dapat memiliki bidang atribut.  Untuk bekerja dengan keadaan, penyimpanan yang disediakan oleh platform blockchain HLF, lapisan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ChaincodeStubInterface digunakan</a> , yang diteruskan ketika metode <em>Init</em> dan <em>Invoke</em> dipanggil.  Ini memberikan kemampuan untuk menerima argumen panggilan fungsi dan membuat perubahan pada status rantai blok: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ChaincodeStubInterface <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { <span class="hljs-comment"><span class="hljs-comment">// GetArgs returns the arguments intended for the chaincode Init and Invoke GetArgs() [][]byte // InvokeChaincode locally calls the specified chaincode InvokeChaincode(chaincodeName string, args [][]byte, channel string) pb.Response // GetState returns the value of the specified `key` from the ledger. GetState(key string) ([]byte, error) // PutState puts the specified `key` and `value` into the transaction's writeset as a data-write proposal. PutState(key string, value []byte) error // DelState records the specified `key` to be deleted in the writeset of the transaction proposal. DelState(key string) error // GetStateByRange returns a range iterator over a set of keys in the ledger. GetStateByRange(startKey, endKey string) (StateQueryIteratorInterface, error) // CreateCompositeKey combines the given `attributes` to form a composite key. CreateCompositeKey(objectType string, attributes []string) (string, error) // GetCreator returns `SignatureHeader.Creator` (eg an identity of the agent (or user) submitting the transaction. GetCreator() ([]byte, error) // and many more methods }</span></span></code> </pre> <br><p>  Dalam kontrak pintar Ethereum yang dikembangkan pada Solidity, setiap metode memiliki fungsi publik.  Dalam rantai kode Fabric Hyperledger di metode <em>Init</em> dan <em>Invoke</em> menggunakan fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ChaincodeStubInterface</a> .  <em>GetArgs ()</em> bisa mendapatkan argumen pemanggilan fungsi dalam bentuk array byte array, sedangkan elemen pertama array saat memanggil <em>Invoke</em> berisi nama fungsi kode kode.  Karena  Meminta metode chaincode apa pun melewati metode Invoke, kita dapat mengatakan bahwa ini adalah implementasi dari pola pengontrol depan. </p><br><p>  Sebagai contoh, jika kita mempertimbangkan implementasi antarmuka Ethereum standar untuk token <a href="">ERC-20</a> , kontrak pintar harus menerapkan metode: </p><br><ul><li>  totalSuplai () </li><li>  balanceOf (address _owner) </li><li>  transfer (alamat _to, uint256 _ nilai) </li></ul><br><p>  dan lain-lain. Dalam kasus implementasi HLF, <em>kode</em> fungsi <em>Invoke</em> harus mampu menangani kasus-kasus di mana argumen pertama untuk <em>memanggil</em> Panggilan berisi nama metode yang diharapkan (misalnya, "totalSuplai" atau "balanceOf").  Contoh penerapan standar ERC-20 dapat dilihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><h2 id="primery-cheynkodov">  Contoh Chaincode </h2><br><p>  Selain dokumentasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hyperledger Fabric</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ada</a> beberapa contoh kode rantai: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aplikasi asuransi Blockchain (2018)</a> </li><li>  <a href="">Kelereng</a> </li><li>  <a href="">Demo sewa mobil (2017)</a> s </li></ul><br><p>  Implementasi kode rantai dalam contoh-contoh ini agak bertele-tele dan mengandung banyak logika berulang untuk memilih fungsi routing yang disebut), memeriksa jumlah argumen, dan: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *SimpleChaincode)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stub shim.ChaincodeStubInterface)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pb</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Response</span></span></span></span> { function, args := stub.GetFunctionAndParameters() fmt.Println(<span class="hljs-string"><span class="hljs-string">"invoke is running "</span></span> + function) <span class="hljs-comment"><span class="hljs-comment">// Handle different functions if function == "initMarble" { //create a new marble return t.initMarble(stub, args) } else if function == "transferMarble" { //change owner of a specific marble return t.transferMarble(stub, args) } else if function == "readMarble" { //read a marble return t.readMarble(stub, args) } else ...</span></span></code> </pre><br><p>  Pengorganisasian kode semacam itu menyebabkan kemunduran dalam keterbacaan kode dan kemungkinan kesalahan, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> , ketika Anda hanya lupa untuk menguraikan data input.  Presentasi tentang rencana pengembangan HLF menyebutkan revisi pendekatan untuk pengembangan kode rantai, khususnya pengenalan anotasi dalam kode rantai Java, dll., Namun, rencana tersebut berkaitan dengan versi yang diharapkan hanya pada 2019.  Pengalaman mengembangkan kontrak pintar telah mengarah pada kesimpulan bahwa mengembangkan dan menguji kode rantai akan lebih mudah jika Anda memilih fungsi dasar di perpustakaan yang terpisah. </p><br><h1 id="cckit---biblioteka-dlya-razrabotki-i-testirovaniya-cheynkodov">  CCKit - perpustakaan untuk mengembangkan dan menguji kode rantai </h1><br><p>  Perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CCKit</a> merangkum praktik mengembangkan dan menguji kode rantai.  Sebagai bagian dari pengembangan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ekstensi</a> chaincode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">,</a> pustaka OpenZeppelin ekstensi untuk kontrak pintar Ethereum digunakan sebagai contoh.  CCKit menggunakan solusi arsitektur berikut: </p><br><h2 id="marshrutizaciya-routing-obrascheniy-k-funkciyam-smart-kontrakta">  Mengalihkan panggilan ke fungsi kontrak pintar </h2><br><p>  Routing mengacu pada algoritma yang digunakan aplikasi merespons permintaan klien.  Pendekatan ini digunakan, misalnya, di hampir semua kerangka kerja http.  Router menggunakan aturan tertentu untuk mengikat permintaan dan penangan permintaan.  Sehubungan dengan chaincode, ini untuk mengasosiasikan nama fungsi chaincode dengan fungsi handler. </p><br><p>  Dalam contoh terbaru dari kontrak pintar, misalnya, di <a href="">Aplikasi Asuransi</a> , ini menggunakan pemetaan antara nama fungsi chaincode dan fungsi dalam kode Golang dari formulir: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bcFunctions = <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(shim.ChaincodeStubInterface, []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pb</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Response</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Insurance Peer "contract_type_ls": listContractTypes, "contract_type_create": createContractType, ... "theft_claim_process": processTheftClaim, }</span></span></code> </pre> <br><p>  Router CCKit menggunakan pendekatan yang mirip dengan router http, serta kemampuan untuk menggunakan konteks permintaan untuk fungsi chaincode dan fungsi middleware </p><br><h2 id="kontekst-obrascheniya-k-funkcii-cheynkoda">  Konteks panggilan ke fungsi kode </h2><br><p>  Mirip dengan konteks permintaan http, yang biasanya memiliki akses ke parameter permintaan http, router CCKit menggunakan konteks panggilan ke fungsi <a href="">kontrak pintar</a> , yang merupakan abstraksi di atas <em>shim.ChaincodeStubInterface</em> .  Konteksnya bisa menjadi satu-satunya argumen bagi penangan fungsi chaining, melaluinya, penangan bisa mendapatkan argumen pemanggilan fungsi, serta akses ke fungsi tambahan untuk bekerja dengan keadaan kontrak pintar (Negara), menciptakan jawaban (Respons), dll. </p><br><pre> <code class="go hljs">Context <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Stub() shim.ChaincodeStubInterface Client() (cid.ClientIdentity, error) Response() Response Logger() *shim.ChaincodeLogger Path() <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> State() State Time() (time.Time, error) Args() InterfaceMap Arg(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} ArgString(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ArgBytes(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> SetArg(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) Get(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} Set(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) SetEvent(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) error }</code> </pre> <br><p>  Karena  Konteks adalah antarmuka, dalam kode rantai tertentu dapat diperluas. </p><br><h2 id="funkcii-promezhutochnoy-obrabotki-middleware">  Fungsi Middleware </h2><br><p>  Fungsi pemrosesan antara (middleware) dipanggil sebelum panggilan dari pawang metode kode, memiliki akses ke konteks panggilan ke metode kode dan ke fungsi menengah berikutnya atau langsung ke pawang metode berikutnya (berikutnya).  Middleware dapat digunakan untuk: </p><br><ul><li>  mengonversi data input (dalam contoh di bawah ini. <em>String</em> dan <em>p.Struct</em> adalah middleware) </li><li>  pembatasan akses ke fungsi (misalnya, <em>pemilik. Hanya</em> ) </li><li>  penyelesaian siklus pemrosesan permintaan </li><li>  memanggil fungsi pemrosesan antara berikutnya dari stack </li></ul><br><h2 id="konvertaciya-struktur-dannyh">  Konversi struktur data </h2><br><p>  Antarmuka chaincode mengasumsikan bahwa array array byte disediakan untuk input, masing-masing elemen yang merupakan atribut dari fungsi chaincode.  Untuk mencegah pembuatan data manual dari array byte ke tipe data golang (int, string, struktur, array) dari argumen pemanggilan fungsi di setiap handler dari fungsi chaining, tipe data yang diharapkan ditetapkan pada saat membuat aturan routing pada router CCKit dan tipe tersebut dikonversi secara otomatis .  Pada contoh <em>berikut ini</em> , fungsi <em>carGet</em> mengharapkan argumen tipe string, dan fungsi <em>carRegister mengharapkan</em> struktur <em>CarPayload</em> .  Argumen ini juga dinamai, yang memungkinkan pawang untuk mendapatkan nilainya dari konteks dengan nama.  Contoh dari pawang akan diberikan di bawah ini.  Protobuf juga dapat digunakan untuk menggambarkan skema data chaining. </p><br><pre> <code class="go hljs">r.Group(<span class="hljs-string"><span class="hljs-string">`car`</span></span>). Query(<span class="hljs-string"><span class="hljs-string">`List`</span></span>, cars). <span class="hljs-comment"><span class="hljs-comment">// chain code method name is carList Query(`Get`, car, p.String(`id`)). // chain code method name is carGet, method has 1 string argument "id" Invoke(`Register`, carRegister, p.Struct(`car`, &amp;CarPayload{}), // 1 struct argument owner.Only) // allow access to method only for chaincode owner (authority)</span></span></code> </pre> <br><p>  Juga, konversi otomatis (marshalling) digunakan saat menulis data ke status kontrak pintar dan saat membuat acara (tipe golang diserialisasi ke dalam array byte) </p><br><h2 id="sredstva-otladki-i-loggirovaniya-cheynkodov">  Alat untuk debugging dan mencatat kode rantai </h2><br><p>  Untuk men-debug kode, Anda dapat menggunakan ekstensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">debug</a> , yang menerapkan metode kontrak pintar yang akan memungkinkan Anda memeriksa keberadaan kunci dalam status kontrak pintar, serta membaca / mengubah / menghapus nilai dengan kunci secara langsung. </p><br><p>  Untuk masuk dalam konteks panggilan ke fungsi chaincode, metode Log () dapat digunakan, yang mengembalikan instance dari logger yang digunakan dalam HLF. </p><br><h2 id="metody-upravleniya-dostupa-k-metodam-smart-kontrakta">  Metode kontrak pintar metode kontrol akses </h2><br><p>  Sebagai bagian dari ekstensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pemilik</a> , primitif dasar untuk menyimpan informasi tentang pemilik kode rantai yang dipakai dan pengubah akses (middleware) untuk metode kontrak pintar diimplementasikan. </p><br><h2 id="sredstva-testirovaniya-smart-kontraktov">  Alat Pengujian Kontrak Cerdas </h2><br><p>  Menyebarkan jaringan blockchain, menginstal dan menginisialisasi kode rantai adalah pengaturan yang agak rumit dan prosedur yang panjang.  Waktu untuk menginstal ulang / meningkatkan kode kontrak pintar dapat dikurangi dengan menggunakan mode DEV dari kontrak pintar, namun, proses memperbarui kode masih akan lambat. </p><br><p>  Paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">shim</a> berisi implementasi <a href="">MockStub</a> , yang membungkus panggilan ke kode untuk kode, mensimulasikan operasinya di lingkungan blockchain HLF.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menggunakan MockStub</a> memungkinkan Anda untuk mendapatkan hasil tes hampir secara instan dan memungkinkan Anda untuk mengurangi waktu pengembangan.  Jika kami mempertimbangkan skema umum pengoperasian kode dalam HLF, MockStub pada dasarnya menggantikan SDK, memungkinkan Anda untuk melakukan panggilan ke fungsi kode, dan mensimulasikan lingkungan untuk memulai kode pada host. </p><br><p><img src="https://habrastorage.org/webt/3y/ed/z2/3yedz22nfldc41jmcnpjqyto3x0.png"></p><br><p>  MockStub dari pengiriman HLF berisi implementasi hampir semua metode antarmuka <em>shim.ChaincodeStubInterface</em> , namun, dalam versi saat ini (1.3), tidak memiliki implementasi beberapa metode penting, seperti GetCreator.  Karena  kode rantai dapat menggunakan metode ini untuk mendapatkan sertifikat pencipta transaksi untuk kontrol akses, untuk cakupan maksimum dalam tes, kemampuan untuk memiliki rintisan metode ini penting. </p><br><p>  Pustaka CCKit berisi versi diperpanjang <a href="">MockStub</a> , yang berisi implementasi metode yang hilang, serta metode untuk bekerja dengan saluran acara, dll. </p><br><h2 id="primer-cheynkoda">  Contoh Chaincode </h2><br><p>  Misalnya, mari kita buat kode rantai sederhana untuk menyimpan informasi tentang mobil yang terdaftar </p><br><h3 id="model-dannyh">  Model data </h3><br><p>  Keadaan kode kode adalah penyimpanan nilai kunci, di mana kuncinya adalah string, nilainya adalah array byte.  Praktik dasarnya adalah menyimpan instance struktur data golang yang diononisasi sebagai nilai.  Dengan demikian, untuk bekerja dengan data dalam chaincode, setelah membaca dari negara bagian, Anda perlu menghapus array byte. </p><br><p>  Untuk merekam tentang mobil, kami akan menggunakan set atribut berikut: </p><br><ul><li>  Identifier (nomor mobil) </li><li>  Model mobil </li><li>  Informasi Pemilik Kendaraan </li><li>  Informasi waktu perubahan data </li></ul><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Car struct for chaincode state type Car struct { Id string Title string Owner string UpdatedAt time.Time // set by chaincode method }</span></span></code> </pre> <br><p>  Untuk mentransfer data ke chaincode, buat struktur terpisah yang hanya berisi bidang yang berasal dari luar chaincode: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// CarPayload chaincode method argument type CarPayload struct { Id string Title string Owner string }</span></span></code> </pre> <br><h3 id="rabota-s-klyuchami">  Bekerja dengan kunci </h3><br><p>  Rekam kunci dalam keadaan kontrak pintar adalah string.  Ini juga mendukung kemampuan untuk membuat kunci komposit di mana bagian-bagian kunci dipisahkan oleh byte nol ( <em>U + 0000</em> ) </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCompositeKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(objectType </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, attributes []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span></code> </pre> <br><p>  Di <em>CCKit,</em> fungsi bekerja dengan keadaan kontrak pintar dapat secara otomatis membuat kunci untuk catatan jika struktur yang ditransfer mendukung antarmuka <em>Keyer</em> </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Keyer interface for entity containing logic of its key creation type Keyer interface { Key() ([]string, error) }</span></span></code> </pre> <br><p>  Untuk merekam mobil, fungsi pembuatan kunci adalah sebagai berikut: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CarEntity = <span class="hljs-string"><span class="hljs-string">`CAR`</span></span> <span class="hljs-comment"><span class="hljs-comment">// Key for car entry in chaincode state func (c Car) Key() ([]string, error) { return []string{CarEntity, c.Id}, nil }</span></span></code> </pre> <br><h3 id="deklaraciya-funkciy-smart-kontrakta-marshrutizaciya">  Deklarasi fungsi kontrak pintar (perutean) </h3><br><p>  Dalam metode konstruktor dari kode rantai, kita dapat mendefinisikan fungsi kode rantai dan argumennya.  Akan ada 3 fungsi dalam kode registrasi mobil </p><br><ul><li>  carList, mengembalikan susunan struktur Mobil </li><li>  carGet, menerima pengenal mobil dan mengembalikan struktur Mobil </li><li>  carRegister, menerima contoh serial dari struktur CarPayload dan mengembalikan hasil registrasi.  Akses ke metode ini hanya dimungkinkan bagi pemilik chaincode, yang disimpan menggunakan middleware dari paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pemilik</a> </li></ul><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">New</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">router</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Chaincode</span></span></span></span> { r := router.New(<span class="hljs-string"><span class="hljs-string">`cars`</span></span>) <span class="hljs-comment"><span class="hljs-comment">// also initialized logger with "cars" prefix r.Init(invokeInit) r.Group(`car`). Query(`List`, queryCars). // chain code method name is carList Query(`Get`, queryCar, p.String(`id`)). // chain code method name is carGet, method has 1 string argument "id" Invoke(`Register`, invokeCarRegister, p.Struct(`car`, &amp;CarPayload{}), // 1 struct argument owner.Only) // allow access to method only for chaincode owner (authority) return router.NewChaincode(r) }</span></span></code> </pre> <br><p>  Contoh di atas menggunakan struktur <a href="">Chaincode</a> di mana pemrosesan metode <em>Init</em> dan <em>Invoke</em> didelegasikan ke router: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> router <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"github.com/hyperledger/fabric/core/chaincode/shim"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/hyperledger/fabric/protos/peer"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// Chaincode default chaincode implementation with router type Chaincode struct { router *Group } // NewChaincode new default chaincode implementation func NewChaincode(r *Group) *Chaincode { return &amp;Chaincode{r} } //======== Base methods ==================================== // // Init initializes chain code - sets chaincode "owner" func (cc *Chaincode) Init(stub shim.ChaincodeStubInterface) peer.Response { // delegate handling to router return cc.router.HandleInit(stub) } // Invoke - entry point for chain code invocations func (cc *Chaincode) Invoke(stub shim.ChaincodeStubInterface) peer.Response { // delegate handling to router return cc.router.Handle(stub) }</span></span></code> </pre> <br><p>  Menggunakan router dan struktur Chaincode dasar memungkinkan penggunaan kembali fungsi handler.  Misalnya, untuk menerapkan chaincode tanpa memeriksa akses ke fungsi <code>carRegister</code> , <code>carRegister</code> akan cukup untuk membuat <a href="">metode konstruktor</a> baru </p><br><h3 id="realizaciya-funkciy-smart-kontrakta">  Implementasi fungsi kontrak pintar </h3><br><p>  Fungsi Golang - penangan fungsi kontrak pintar di router <strong>CCKit</strong> dapat terdiri dari tiga jenis: </p><br><ul><li>  <em>StubHandlerFunc</em> - antarmuka penangan standar, menerima <em>shim.ChaincodeStubInterface</em> , mengembalikan <em>rekan</em> respons <em>standar.Response</em> </li><li>  <em>ContextHandlerFunc</em> - mengambil konteks dan mengembalikan <em>peer.Response</em> </li><li>  <em>HandlerFunc</em> - mengambil konteks, mengembalikan antarmuka dan kesalahan.  Array byte dapat dikembalikan atau jenis golang apa pun yang secara otomatis dikonversi ke array byte berdasarkan <em>peer.Response</em> dibuat.  Status respons adalah <em>shim.Ok</em> atau <em>shim.Error</em> , tergantung pada kesalahan yang diteruskan. </li></ul><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// StubHandlerFunc acts as raw chaincode invoke method, accepts stub and returns peer.Response StubHandlerFunc func(shim.ChaincodeStubInterface) peer.Response // ContextHandlerFunc use stub context as input parameter ContextHandlerFunc func(Context) peer.Response // HandlerFunc returns result as interface and error, this is converted to peer.Response via response.Create HandlerFunc func(Context) (interface{}, error)</span></span></code> </pre> <br><p>   ,   ,           (   CarPayload) <br>    State ,                      (      ) </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// car get info chaincode method handler func car(c router.Context) (interface{}, error) { return c.State().Get( // get state entry Key(c.ArgString(`id`)), // by composite key using CarKeyPrefix and car.Id &amp;Car{}) // and unmarshal from []byte to Car struct } // cars car list chaincode method handler func cars(c router.Context) (interface{}, error) { return c.State().List( CarKeyPrefix, // get list of state entries of type CarKeyPrefix &amp;Car{}) // unmarshal from []byte and append to []Car slice } // carRegister car register chaincode method handler func carRegister(c router.Context) (interface{}, error) { // arg name defined in router method definition p := c.Arg(`car`).(CarPayload) t, _ := c.Time() // tx time car := &amp;Car{ // data for chaincode state Id: p.Id, Title: p.Title, Owner: p.Owner, UpdatedAt: t, } return car, // peer.Response payload will be json serialized car data c.State().Insert( //put json serialized data to state Key(car.Id), // create composite key using CarKeyPrefix and car.Id car) }</span></span></code> </pre> <br><h3 id="testy-smart-kontrakta">  - </h3><br><p>    -       —        ,     .      BDD – Behavior Driven Development,          . </p><br><p>  , , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- Ethereum</a>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ganache-cli</a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">truffle</a> .   golang -  Mockstub. </p><br><h3 id="primer-testa">   </h3><br><p>    ,     .     <a href=""></a> . </p><br><p>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ginkgo</a> ,     Go,      <code>go test</code> .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gomega</a>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">expect</a> ,    ,     . </p><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"testing"</span></span> . <span class="hljs-string"><span class="hljs-string">"github.com/onsi/ginkgo"</span></span> . <span class="hljs-string"><span class="hljs-string">"github.com/onsi/gomega"</span></span> examplecert <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/examples/cert"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/extensions/owner"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/identity"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/state"</span></span> testcc <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/testing"</span></span> expectcc <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/testing/expect"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestCars</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { RegisterFailHandler(Fail) RunSpecs(t, <span class="hljs-string"><span class="hljs-string">"Cars Suite"</span></span>) }</code> </pre> <br><p>      ,   <em>CarPayload</em> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Payloads = []*Car{{ Id: <span class="hljs-string"><span class="hljs-string">`A777MP77`</span></span>, Title: <span class="hljs-string"><span class="hljs-string">`VAZ`</span></span>, Owner: <span class="hljs-string"><span class="hljs-string">`victor`</span></span>, }, { Id: <span class="hljs-string"><span class="hljs-string">`O888OO77`</span></span>, Title: <span class="hljs-string"><span class="hljs-string">`YOMOBIL`</span></span>, Owner: <span class="hljs-string"><span class="hljs-string">`alexander`</span></span>, }, { Id: <span class="hljs-string"><span class="hljs-string">`O222OO177`</span></span>, Title: <span class="hljs-string"><span class="hljs-string">`Lambo`</span></span>, Owner: <span class="hljs-string"><span class="hljs-string">`hodl`</span></span>, }}</code> </pre> <br><p>     MockStub   Cars. </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//Create chaincode mock cc := testcc.NewMockStub(`cars`, New())</span></span></code> </pre> <br><p>  Karena   cars      ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> . </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// load actor certificates actors, err := identity.ActorsFromPemFile(`SOME_MSP`, map[string]string{ `authority`: `s7techlab.pem`, `someone`: `victor-nosov.pem`}, examplecert.Content)</span></span></code> </pre> <br><p>   <em>BeforeSuite</em>    <em>Car</em>      <em>authority</em>     <em>Init</em>    .  ,    <em>Cars</em>   Init       <em>Init</em> ,    . </p><br><pre> <code class="go hljs">BeforeSuite(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// init chaincode expectcc.ResponseOk(cc.From(actors[`authority`]).Init()) // init chaincode from authority })</span></span></code> </pre> <br><p>          . ,          <em>CarRegister</em> ,              . </p><br><pre> <code class="go hljs">It(<span class="hljs-string"><span class="hljs-string">"Allow authority to add information about car"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//invoke chaincode method from authority actor expectcc.ResponseOk(cc.From(actors[`authority`]).Invoke(`carRegister`, Payloads[0])) }) It("Disallow non authority to add information about car", func() { //invoke chaincode method from non authority actor expectcc.ResponseError( cc.From(actors[`someone`]).Invoke(`carRegister`, Payloads[0]), owner.ErrOwnerOnly) // expect "only owner" error })</span></span></code> </pre> <br><p>             : </p><br><pre> <code class="go hljs">It(<span class="hljs-string"><span class="hljs-string">"Disallow authority to add duplicate information about car"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { expectcc.ResponseError( cc.From(actors[<span class="hljs-string"><span class="hljs-string">`authority`</span></span>]).Invoke(<span class="hljs-string"><span class="hljs-string">`carRegister`</span></span>, Payloads[<span class="hljs-number"><span class="hljs-number">0</span></span>]), state.ErrKeyAlreadyExists) <span class="hljs-comment"><span class="hljs-comment">//expect car id already exists })</span></span></code> </pre> <br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><p> - HLF        Go, Java, JavaScript, ,    , -  (Solidity)     /   -.      /       . </p><br><p>    HLF  ,  ,      (     .).  Hypeledger Fabric        , ..     . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id426705/">https://habr.com/ru/post/id426705/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id426695/index.html">Kamera visi mesin untuk penggemar. Bagaimana cara menggunakan kamera untuk navigasi offline?</a></li>
<li><a href="../id426697/index.html">Bekerja dengan perangkat LibUsb dari bawah Android</a></li>
<li><a href="../id426699/index.html">Pengujian Python dengan pytest. Sederhana, Cepat, Efisien, dan Dapat diskalakan. Kata Pengantar dan Pengantar</a></li>
<li><a href="../id426701/index.html">Flutter - tampilan baru pada pengembangan lintas platform</a></li>
<li><a href="../id426703/index.html">Apa yang menarik dari DataVizDay di Minsk</a></li>
<li><a href="../id426707/index.html">Sistem persetujuan. Bagaimana kami menemukan sepeda</a></li>
<li><a href="../id426709/index.html">Pengatur waktu JavaScript: semua yang perlu Anda ketahui</a></li>
<li><a href="../id426713/index.html">Intel Xeon W-3175X: 28 core untuk rumah</a></li>
<li><a href="../id426717/index.html">Ilusi Tipuan: Ilusi Optik Visual Berbasis Peramalan Retro</a></li>
<li><a href="../id426719/index.html">Hackathon pada Ilmu Data dalam SIBUR: bagaimana itu</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>