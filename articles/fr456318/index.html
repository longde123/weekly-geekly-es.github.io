<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌐 🚴🏻 🍹 Bases du pointeur du débutant ㊙️ 👩🏾‍💻 🚉</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Présentation 
 Aujourd'hui, en raison de l'amélioration et de la réduction des coûts de la technologie, la quantité de mémoire et de puissance de trai...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bases du pointeur du débutant</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456318/"><h2>  Présentation </h2><br>  Aujourd'hui, en raison de l'amélioration et de la réduction des coûts de la technologie, la quantité de mémoire et de puissance de traitement augmente régulièrement. <br><br>  Selon la loi de Moore: <br><blockquote>  Le nombre de transistors placés sur une puce de circuit intégré double tous les 24 mois. </blockquote>  Il est à noter que deux paramètres sont modifiés: <br><br><ul><li>  Nombre de transistors </li><li>  Dimensions du module </li></ul><br>  Les mêmes principes sont projetés sur la quantité de RAM (DRAM). <br><br>  Maintenant, le problème de la mémoire n'est pas aigu, car la quantité de mémoire au cours des 10 dernières années a augmenté de 16 fois par dé. <br><a name="habracut"></a><br>  La plupart des langages de programmation de haut niveau (PL) sont déjà «prêts à l'emploi» masquant le travail avec la mémoire du programmeur.  Et, puisque cette question dormait, une nouvelle caste de programmeurs apparaît qui ne comprend pas <s>ou ne veut pas comprendre</s> comment fonctionne le travail avec la mémoire. <br><br>  Dans cette rubrique, nous considérerons les principaux points de l'utilisation de la mémoire en utilisant l'exemple du langage C ++, car il s'agit de l'un des rares langages impératifs qui prend en charge le travail direct avec la mémoire et prend en charge la POO. <br><br><h2>  À quoi sert l'informatique? </h2><br><blockquote>  Il convient de mentionner ici, cet article est conçu pour les personnes qui commencent tout juste leur chemin en C ++ ou veulent simplement avoir une idée de la mémoire dynamique. </blockquote><br>  Au moment de l'exécution, tout programme se réserve un morceau de mémoire dans la DRAM.  Tous les autres espaces libres DRAM sont appelés <u>«tas»</u> («tas» en anglais).  L'allocation de mémoire pendant l'exécution pour les besoins du programme se produit précisément à partir du tas et s'appelle l'allocation de mémoire dynamique. <br><br>  Tout le problème est que si vous ne vous occupez pas de nettoyer la mémoire allouée lorsqu'elle n'est plus nécessaire, une soi-disant fuite de mémoire peut se produire, dans laquelle votre système <u>(programme)</u> se bloque simplement.  Semblable à une voiture qui a calé au milieu de la route parce que quelqu'un a oublié de faire le plein à temps. <br><br><div class="spoiler">  <b class="spoiler_title">Ce que vous devez déjà savoir</b> <div class="spoiler_text">  La plupart des PL modernes sont équipés de collecteurs d'ordures et se vident d'eux-mêmes. <br>  Cependant, C ++ s'est imposé comme l'une des API les plus performantes, en partie parce que tout le travail avec de la mémoire se fait manuellement. <br></div></div><br><br><h2>  nouveau et supprimer </h2><br>  L'allocation de mémoire peut être statique et dynamique.  L'allocation statique de mémoire est appelée une allocation unique de mémoire lors de la compilation du programme, et la quantité de mémoire statique ne change pas au moment de l'exécution.  Un exemple classique est la déclaration d'une variable entière ou d'un tableau.  Mais que faire si le programmeur ne sait pas à l'avance combien d'éléments sont nécessaires dans le conteneur? <br>  L'utilisation de la mémoire dynamique est conseillée lorsqu'il est nécessaire d'organiser l'allocation de mémoire pour les besoins du programme selon les besoins. <br>  Le <i>nouvel</i> opérateur est responsable de l'allocation de mémoire dynamique en C ++, et <i>delete</i> est responsable de son effacement. <br>  Le <i>nouvel</i> opérateur renvoie le résultat de son opération un pointeur sur une nouvelle instance de la classe. <br>  La syntaxe est la suivante: <br><br>  |  <b>pointeur de type de données (T1)</b> |  * |  <b>nom du pointeur</b> | = <i>nouveau</i> |  <b>type T1</b> |; <br><br>  Après le <i>nouvel</i> opérateur, vous pouvez utiliser le constructeur, par exemple, pour initialiser les champs de la classe. <br>  Il convient de noter que la même fuite de mémoire se produit exactement lorsque le programmeur perd le contrôle de son allocation. <br><blockquote>  Il est important de se rappeler: <br>  Si vous avez oublié de vider la mémoire dynamique des éléments inutiles «dépensés», tôt ou tard, un moment critique viendra où il ne sera plus possible de retirer la mémoire. </blockquote><br>  Un exemple d'allocation de mémoire et de son nettoyage: <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> main{ <span class="hljs-comment"><span class="hljs-comment">// ,       new int *ptr = new int(); //   cout&lt;&lt;*ptr&lt;&lt;endl; // ,     delete ptr; //  delete     ,         return 0; }</span></span></code> </pre> <br><br>  Cet article ne traitera pas des pointeurs dits «intelligents», car le sujet est très étendu, mais, en bref: «Les pointeurs intelligents automatisent partiellement le processus d'effacement de la mémoire pour le programmeur». <br><br><h2>  Pointeurs </h2><br>  Les pointeurs sont chargés de travailler avec la mémoire dynamique en C ++.  C'est un sujet à partir duquel l'appétit gâte les débutants. <br><br>  Vous pouvez déclarer un pointeur à l'aide de l'opérateur <b>*</b> .  Par défaut, il pointera vers une région aléatoire de la mémoire.  Afin que nous puissions accéder à la zone de mémoire dont nous avons besoin, nous devons passer un lien (opérateur <b>&amp;</b> ) à la variable souhaitée. <br><br>  Le pointeur lui-même est simplement l'adresse d'une cellule mémoire, et pour accéder aux données stockées dans cette cellule, il faut le déréférencer. <br><h3>  Retraite importante </h3><br><blockquote>  Si vous essayez d'afficher le pointeur sans déréférencer, alors au lieu de la valeur de la zone mémoire vers laquelle il pointe, l'adresse de cette zone mémoire est affichée. <br>  Pour déréférencer un pointeur, placez simplement l'opérateur <b>*</b> devant son nom. </blockquote><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ,          int* pNum= new int(1) ; cout&lt;&lt;*pNum&lt;&lt;endl; //    ,        ,       (   int   ) pNum++; cout&lt;&lt;*pNum&lt;&lt;endl; // ,         return 0; }</span></span></code> </pre><br><img src="https://habrastorage.org/webt/ka/bg/0k/kabg0kkojm0kefvksto7cye60ps.png"><br><br>  En regardant de tels exemples, je voudrais demander: "Pourquoi est-ce même nécessaire si vous pouvez dériver immédiatement une variable?" <br><br>  Un autre exemple: <br><br>  Nous avons une classe de programmeurs qui décrit les membres d'une équipe de programmeurs qui <s>ne connaissent pas les pointeurs.</s> <br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Programmers</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Programmers(){} Programmers(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iWeight, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iAge){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;weight = iWeight; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;age = iAge; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> weight; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> age; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     Programmers int size = 9; Programmers *prog [size]; //  Programmers Programmers *ptr = nullptr; //     Programmers       //          for (int i =0;i&lt;size;i++) { ptr=new Programmers(i+100,i); prog[i]=ptr; } return 0; }</span></span></code> </pre> <br>  De cette façon, la mémoire peut être manipulée à notre guise.  Et c'est pourquoi, lorsque vous travaillez avec la mémoire, vous pouvez "vous tirer une balle dans le pied".  Il convient de noter que travailler avec le pointeur est beaucoup plus rapide, car la valeur elle-même n'est pas copiée, mais seul un lien vers une adresse spécifique lui est attribué. <br><br>  Soit dit en passant, un tel mot <b>-</b> clé populaire fournit un pointeur vers l'objet de classe actuel.  <s>Ces pointeurs sont partout.</s> <br><br>  <b>Un exemple de pointeur au quotidien:</b> <br><br>  Imaginez une situation lorsque vous commandez un plat dans un restaurant.  Pour passer une commande, il vous suffit de pointer le plat dans le menu et vous serez prêt.  De la même manière, les autres visiteurs du restaurant indiquent l'élément souhaité dans le menu.  Ainsi, chaque ligne du menu est un pointeur sur la fonction de cuisson d'un plat, et ce pointeur a été créé au stade de la conception de ce menu lui-même. <br><br><div class="spoiler">  <b class="spoiler_title">Exemple de pointeur de fonction</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      void Chicken(){ cout&lt;&lt;"Wait 5 min...Chicken is cooking"&lt;&lt;endl; } void JustWater(){ cout&lt;&lt;"Take your water"&lt;&lt;endl; } int main() { //    void   void (*ptr)(); ptr = Chicken; ptr(); ptr=JustWater; ptr(); return 0; }</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/ja/kn/0p/jakn0pthuo6au9wx9w_uqlfbd00.png"><br></div></div><br>  Retour à nos programmeurs.  Supposons maintenant que nous ayons besoin de prendre les champs de la classe dans la section <b>privée</b> , comme il sied au principe d'encapsulation de la POO, puis nous devons obtenir pour obtenir un accès en lecture à ces champs.  Mais imaginez que nous n'avons pas 2 champs, mais 100, et pour cela nous devons écrire notre propre accesseur pour chacun? <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text">  Bien sûr que non, je ne comprends même pas pourquoi vous avez ouvert ce becquet. <br></div></div><br>  Pour ce faire, nous allons faire un «accesseur» de type void et lui passer des arguments par référence.  Le passage d'un argument par référence signifie que la valeur de l'argument n'est pas copiée, mais seule l'adresse de l'argument réel est transmise.  Ainsi, lors de la modification de la valeur d'un tel argument, les données de la cellule mémoire de l'argument actuel changeront également. <br>  Cela affecte également les performances globales, car le passage d'un argument par référence est plus rapide que le passage par la valeur.  Et cela sans parler des grandes collections d'éléments. <br><br>  Par exemple, la méthode <i>getParams à l'</i> intérieur changera les arguments entrants et ils changeront leurs valeurs, y compris dans la portée, d'où elles ont été appelées. <br>  Un pointeur nous aidera à naviguer dans le tableau.  De la théorie des structures de données, nous savons qu'un tableau est une région continue de mémoire dont les éléments sont disposés les uns après les autres. <br>  Cela signifie que si vous modifiez la valeur du pointeur en nombre d'octets que l'élément occupe dans le tableau, vous pouvez atteindre chaque élément jusqu'à ce que le pointeur dépasse les limites du tableau. <br>  Créez un autre pointeur qui pointera vers le premier élément du tableau des <u>programmeurs</u> . <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Programmers</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Programmers(){} Programmers(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iWeight, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iAge){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;weight = iWeight; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;age = iAge; } <span class="hljs-comment"><span class="hljs-comment">//    ,   main     void getParams(int &amp;w, int &amp;a){ w=weight; a=age; } private: int weight; int age; }; int main() { int size = 9; Programmers *prog [size]; Programmers *ptr=nullptr; for (int i =0;i&lt;size;i++) { ptr=new Programmers(i+100,i); prog[i]=ptr; } int w,a; int count = 9; //    //        Programmers **iter = prog; for (int i=0;i&lt;count;i++) { ptr = *iter++; ptr-&gt;getParams(w,a); if(*(iter-1) != nullptr){ delete *(iter-1); ptr = nullptr; } cout&lt;&lt;w&lt;&lt;"\t"&lt;&lt;a&lt;&lt;endl; } return 0; }</span></span></code> </pre><br><img src="https://habrastorage.org/webt/6q/9v/pi/6q9vpiibfo8zddb4znzbfkqcvuu.png"><br><br>  Dans cet exemple, je veux vous transmettre l'essence du fait que lorsque vous modifiez la valeur de l'adresse du pointeur, vous pouvez accéder à une autre zone de mémoire. <br><br>  Structures de données telles que listes, vecteurs, etc.  basé sur des pointeurs, et donc appelé structures de données dynamiques.  Et pour les parcourir, il est plus correct d'utiliser des itérateurs.  Un itérateur est un pointeur sur un élément de la structure de données et donne accès à l'élément du conteneur. <br><br><h3>  En conclusion </h3><br>  Ayant compris le sujet des pointeurs, travailler avec la mémoire devient une partie agréable de la programmation et, dans l'ensemble, une compréhension détaillée du fonctionnement de la machine avec la mémoire et de sa gestion apparaît.  Dans un sens, il y a une philosophie derrière le concept même de «travailler avec la mémoire».  Au bout de vos doigts, vous modifiez la charge sur les plaques de même très petits condensateurs. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr456318/">https://habr.com/ru/post/fr456318/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr456302/index.html">Pourquoi préférons-nous CSS (- variable) à SASS ($ variable)?</a></li>
<li><a href="../fr456304/index.html">Comment publier l'utilitaire de console sur PyPI en 1 minute</a></li>
<li><a href="../fr456306/index.html">Les technologies de la microélectronique sur les doigts: la loi de Moore, les mouvements de marketing et pourquoi les nanomètres ne sont plus les mêmes aujourd'hui. 3e partie</a></li>
<li><a href="../fr456310/index.html">Logistique de l'action pour la collecte sélective des matières recyclables</a></li>
<li><a href="../fr456316/index.html">Frontend Weekly Digest (10-16 juin 2019)</a></li>
<li><a href="../fr456320/index.html">Le condensé de matières fraîches du monde du front-end de la dernière semaine n ° 369 (10-16 juin 2019)</a></li>
<li><a href="../fr456322/index.html">Comment tirer le meilleur parti de la conférence. Instruction pour les plus petits</a></li>
<li><a href="../fr456332/index.html">PHP Digest n ° 158 (3-17 juin 2019)</a></li>
<li><a href="../fr456334/index.html">Immortalité méritée: des jeux qui ne vous ont pas ennuyés</a></li>
<li><a href="../fr456336/index.html">11 conseils pour utiliser Redux lors du développement d'applications React</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>