<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥝 👩‍🎤 👩🏼‍🚀 Ceph. Anatomie de catastrophe 💠 👩🏾‍🌾 🏌️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ceph est un stockage d'objets conçu pour aider à créer un cluster de basculement. Pourtant, des échecs se produisent. Tous ceux qui travaillent avec C...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ceph. Anatomie de catastrophe</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/431536/">  Ceph est un stockage d'objets conçu pour aider à créer un cluster de basculement.  Pourtant, des échecs se produisent.  Tous ceux qui travaillent avec Ceph connaissent la légende de CloudMouse ou Rosreestr.  Malheureusement, il n'est pas habituel de partager avec nous une expérience négative, les causes des échecs sont le plus souvent étouffées et ne permettent pas aux générations futures d'apprendre des erreurs des autres. <br><br>  Eh bien, mettons en place un cluster de test, mais proche du vrai, et analysons la catastrophe par os.  Nous mesurerons tous les baisses de performances, trouverons les fuites de mémoire et analyserons le processus de récupération du service.  Et tout cela sous la direction d'Artemy Kapitula, qui a passé près d'un an à étudier les pièges, a fait échouer les performances du cluster à zéro et la latence ne pas atteindre des valeurs indécentes.  Et j'ai un graphique rouge, ce qui est bien mieux. <br><img src="https://habrastorage.org/webt/c8/nr/1a/c8nr1akew1kjleodu5trq_ow3oy.png"><br><br>  Ensuite, vous trouverez une version vidéo et texte de l'un des meilleurs rapports de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DevOpsConf Russia</a> 2018. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/_fWYUl2QsoI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><br>  <strong>À propos du conférencier:</strong> Artemy Kapitula architecte système RCNTEC.  La société propose des solutions de téléphonie IP (collaboration, organisation d'un bureau à distance, systèmes de stockage définis par logiciel et systèmes de gestion / distribution d'énergie).  L'entreprise travaille principalement dans le secteur des entreprises, elle n'est donc pas très connue sur le marché DevOps.  Néanmoins, une certaine expérience a été accumulée avec Ceph, qui dans de nombreux projets est utilisé comme élément de base de l'infrastructure de stockage. <br><br>  <strong>Ceph est un référentiel défini par logiciel avec de nombreux composants logiciels.</strong> <br><img src="https://habrastorage.org/webt/dw/ow/hm/dwowhmqvjfugd0u-ljhhz3fy2ji.png"><br><br>  Dans le diagramme: <br><br><ul><li>  Le niveau supérieur est le réseau de cluster interne par lequel le cluster lui-même communique; </li><li>  Le niveau inférieur - en fait Ceph - est un ensemble de démons internes de Ceph (MON, MDS et OSD) qui stockent les données. </li></ul><br>  En règle générale, toutes les données sont répliquées. Dans le diagramme, j'ai délibérément sélectionné trois groupes, chacun avec trois OSD, et chacun de ces groupes contient généralement une réplique de données.  En conséquence, les données sont stockées en trois copies. <br><br>  Un réseau de cluster de niveau supérieur est le réseau par lequel les clients Ceph accèdent aux données.  Grâce à lui, les clients communiquent avec le moniteur, avec MDS (qui en a besoin) et avec OSD.  Chaque client fonctionne avec chaque OSD et avec chaque moniteur indépendamment.  Par conséquent, le <strong>système est dépourvu d'un seul point de défaillance</strong> , ce qui est très agréable. <br><br><h2>  Les clients <br></h2><br>  ● Clients S3 <br><br>  S3 est une API pour HTTP.  Les clients S3 fonctionnent via HTTP et se connectent aux composants Ceph Rados Gateway (RGW).  Ils communiquent presque toujours avec un composant via un réseau dédié.  Ce réseau (je l'ai appelé réseau S3) utilise uniquement HTTP, les exceptions sont rares. <br><br>  ● Hyperviseur avec machines virtuelles <br><br>  Ce groupe de clients est souvent utilisé.  Ils travaillent avec des moniteurs et avec OSD, d'où ils reçoivent des informations générales sur l'état du cluster et la distribution des données.  Pour les données, ces clients accèdent directement aux démons OSD via le réseau public du cluster. <br><br>  ● Clients RBD <br><br>  Il existe également des hôtes physiques de métaux BR, qui sont généralement Linux.  Ce sont des clients RBD et accèdent aux images stockées dans un cluster Ceph (images de disque de machine virtuelle). <br><br>  ● Clients CephFS <br><br>  Le quatrième groupe de clients, qui ne sont pas encore nombreux mais qui suscitent un intérêt croissant, sont les clients du système de fichiers de cluster CephFS.  Le système de cluster CephFS peut être monté simultanément à partir de nombreux nœuds, et tous les nœuds ont accès aux mêmes données, en travaillant avec chaque OSD.  Autrement dit, il n'y a pas de passerelles en tant que telles (Samba, NFS et autres).  Le problème est qu'un tel client ne peut être que Linux et une version assez moderne. <br><img src="https://habrastorage.org/webt/fw/nm/xc/fwnmxcaiig0yy6tkofrljqri3ck.png"><br><br>  Notre entreprise travaille sur le marché des entreprises, et là, la balle est dirigée par ESXi, HyperV et autres.  En conséquence, le cluster Ceph, qui est en quelque sorte utilisé dans le secteur des entreprises, est nécessaire pour soutenir les techniques appropriées.  Ce n'était pas suffisant pour nous à Ceph, nous avons donc dû affiner et étendre le cluster Ceph avec nos composants, en fait construire quelque chose de plus que Ceph, notre propre plate-forme de stockage de données. <br><br>  De plus, les clients du secteur des entreprises ne sont pas sous Linux, mais la plupart d'entre eux Windows, parfois Mac OS, ne peuvent pas accéder au cluster Ceph eux-mêmes.  Ils doivent passer par une sorte de passerelles, qui dans ce cas deviennent des goulots d'étranglement. <br><br>  Nous avons dû ajouter tous ces composants et nous avons obtenu un cluster légèrement plus large. <br><img src="https://habrastorage.org/webt/p2/tg/j2/p2tgj2qtpzrzsnst5bophkclywi.png"><br><br>  Nous avons deux composants centraux: le <strong>groupe SCSI Gateways</strong> , qui permet d'accéder aux données d'un cluster Ceph via FibreChannel ou iSCSI.  Ces composants sont utilisés pour connecter HyperV et ESXi à un cluster Ceph.  Les clients PROXMOX travaillent toujours à leur manière - via RBD. <br><br>  Nous ne laissons pas les clients de fichiers directement dans le réseau de cluster; plusieurs passerelles tolérantes aux pannes leur sont allouées.  Chaque passerelle permet d'accéder au système de cluster de fichiers via NFS, AFP ou SMB.  En conséquence, presque tous les clients, que ce soit Linux, FreeBSD ou non seulement un client, un serveur (OS X, Windows), ont accès à CephFS. <br><br>  Pour gérer tout cela, nous avons dû développer notre propre orchestre Ceph et tous nos composants, qui y sont nombreux.  Mais en parler maintenant n'a aucun sens, car c'est notre développement.  La plupart seront probablement intéressés par le Ceph «nu» lui-même. <br><br>  Ceph est beaucoup utilisé là où, et parfois des pannes se produisent.  Certes, tous ceux qui travaillent avec Ceph connaissent la légende de CloudMouse.  C'est une terrible légende urbaine, mais tout n'est pas si mal qu'il n'y paraît.  Il y a un nouveau conte de fées sur Rosreestr.  Ceph tournait partout, et partout il échouait.  Quelque part, cela s'est terminé fatalement, quelque part a réussi à éliminer rapidement les conséquences. <br><br>  Malheureusement, il n'est pas habituel pour nous de partager des expériences négatives, tout le monde essaie de cacher les informations pertinentes.  Les entreprises étrangères sont un peu plus ouvertes, en particulier, DigitalOcean (un fournisseur bien connu qui distribue des machines virtuelles) a également subi une défaillance Ceph pendant presque une journée, c'était le 1er avril - une journée merveilleuse!  Ils ont publié certains des rapports, un court journal ci-dessous. <br><img src="https://habrastorage.org/webt/qo/sb/ds/qosbdsczlkvzh-zqsfvid86er5u.png"><br><br>  Les problèmes ont commencé à 7 heures du matin, à 11 heures, ils ont compris ce qui se passait et ont commencé à éliminer l'échec.  Pour ce faire, ils ont alloué deux commandes: l'une pour une raison quelconque a parcouru les serveurs et y a installé de la mémoire, et la seconde pour une raison quelconque a démarré manuellement un serveur après l'autre et surveillé attentivement tous les serveurs.  Pourquoi?  Nous sommes tous habitués à tout allumé en un seul clic. <br><br>  <em>Que se passe-t-il fondamentalement dans un système distribué lorsqu'il est effectivement construit et fonctionne presque à la limite de ses capacités?</em> <br><br>  Pour répondre à cette question, nous devons examiner comment fonctionne le cluster Ceph et comment la panne se produit. <br><img src="https://habrastorage.org/webt/ln/ks/rd/lnksrda1mb-lmfbymyacym1f8aw.png"><br><br><h2>  Scénario d'échec de Ceph <br></h2><br>  Au début, le cluster fonctionne bien, tout va bien.  Ensuite, quelque chose se produit, après quoi les démons OSD, où les données sont stockées, perdent le contact avec les composants centraux du cluster (moniteurs).  À ce stade, un délai d'attente se produit et l'ensemble du cluster obtient un enjeu.  Le cluster reste un moment jusqu'à ce qu'il se rende compte que quelque chose ne va pas avec lui, et ensuite il corrige ses connaissances internes.  Après cela, le service client est restauré dans une certaine mesure et le cluster fonctionne à nouveau en mode dégradé.  Et le plus drôle, c'est que cela fonctionne plus rapidement qu'en mode normal - c'est un fait étonnant. <br><br>  Ensuite, nous éliminons l'échec.  Supposons que nous perdions de l'énergie, le rack a été complètement coupé.  Les électriciens sont venus en courant, ils ont tous restauré, ils ont fourni l'électricité, les serveurs allumés et <strong>le plaisir commence</strong> . <br><br><blockquote>  Tout le monde est habitué au fait que lorsqu'un serveur tombe en panne, tout devient mauvais, et lorsque nous allumons le serveur, tout devient bon.  Tout est complètement faux ici. <br></blockquote><br>  Le cluster s'arrête pratiquement, effectue la synchronisation principale, puis commence une récupération douce et lente, revenant progressivement au mode normal. <br><img src="https://habrastorage.org/webt/ml/r_/i3/mlr_i3llw-lsdaybp4vbedxeuhi.png"><br><br>  Ci-dessus, un graphique des performances du cluster Ceph au fur et à mesure de la défaillance.  Veuillez noter qu'ici, les intervalles dont nous avons parlé sont tracés très clairement: <br><br><ul><li>  Fonctionnement normal jusqu'à environ 70 secondes; </li><li>  Échec d'une minute à environ 130 secondes; </li><li>  Un plateau nettement supérieur au fonctionnement normal est l'œuvre de clusters dégradés; </li><li>  Ensuite, nous activons le nœud manquant - il s'agit d'un cluster de formation, il n'y a que 3 serveurs et 15 SSD.  Nous démarrons le serveur quelque part environ 260 secondes. </li><li>  Le serveur s'est allumé, est entré dans le cluster - IOPS'y est tombé. </li></ul><br>  Essayons de comprendre ce qui s'est réellement passé là-bas.  La première chose qui nous intéresse est une baisse au tout début du graphique. <br><br><h3>  Échec de l'OSD <br></h3><br>  Prenons un exemple de cluster avec trois racks, plusieurs nœuds dans chacun.  Si le rack gauche tombe en panne, tous les démons OSD (pas les hôtes!) Se pinglent avec des messages Ceph à un certain intervalle.  En cas de perte de plusieurs messages, un message est envoyé au moniteur: "Je, OSD tel ou tel, ne peux pas atteindre l'OSD tel ou tel." <br><img src="https://habrastorage.org/webt/zh/1s/ge/zh1sge1ljlclxjmgfygxpyyyc8i.png"><br><br>  Dans ce cas, les messages sont généralement regroupés par hôtes, c'est-à-dire que si deux messages provenant d'OSD différents arrivent sur le même hôte, ils sont combinés en un seul message.  Par conséquent, si l'OSD 11 et l'OSD 12 indiquent qu'ils ne peuvent pas atteindre l'OSD 1, cela sera interprété comme l'hôte 11 se plaignant de l'OSD 1. Lorsque l'OSD 21 et l'OSD 22 ont été signalés, il est interprété comme l'hôte 21 insatisfait de l'OSD 1 Après quoi le moniteur considère que l'OSD 1 est à l'état bas et informe tous les membres du cluster (en changeant la carte OSD), le travail se poursuit en mode dégradé. <br><img src="https://habrastorage.org/webt/uu/-c/1w/uu-c1wnwflbqk6ueyumhohtlvjy.png"><br><br>  Voici donc notre cluster et notre rack défaillant (hôte 5 et hôte 6).  Nous activons l'hôte 5 et l'hôte 6, au fur et à mesure que la puissance est apparue, et ... <br><br><h3>  Comportement interne de Ceph <br></h3><br>  Et maintenant, la partie la plus intéressante est que nous commençons la <strong>synchronisation initiale des données</strong> .  Comme il existe de nombreuses répliques, elles doivent être synchrones et être dans la même version.  En cours de démarrage du démarrage OSD: <br><br><ul><li>  OSD lit les versions disponibles, l'historique disponible (pg_log - pour déterminer les versions actuelles des objets). </li><li>  Après quoi, il détermine sur quel OSD les dernières versions des objets dégradés (missing_loc) sont activées et lesquelles sont derrière. </li><li>  Lorsque les versions antérieures sont stockées, une synchronisation est nécessaire et de nouvelles versions peuvent être utilisées comme référence pour lire et écrire des données. </li></ul><br>  Une histoire est utilisée qui est collectée à partir de tous les OSD, et cette histoire peut être beaucoup;  l'emplacement réel de l'ensemble d'objets dans le cluster où se trouvent les versions correspondantes est déterminé.  Combien d'objets sont dans le cluster, combien d'enregistrements sont obtenus, si le cluster est resté longtemps en mode dégradé, alors l'histoire est longue. <br><br>  <strong>À titre de comparaison: la</strong> taille typique d'un objet lorsque nous travaillons avec une image RBD est de 4 Mo.  Lorsque nous travaillons en effacement codé - 1 Mo.  Si nous avons un disque de 10 To, nous obtenons un million d'objets mégaoctets sur le disque.  Si nous avons 10 disques sur le serveur, alors il y a déjà 10 millions d'objets, s'il y a 32 disques (nous construisons un cluster efficace, nous avons une allocation serrée), alors 32 millions d'objets doivent être conservés en mémoire.  De plus, en fait, les informations sur chaque objet sont stockées en plusieurs copies, car chaque copie indique qu'à cet endroit, elle se trouve dans cette version, et dans celle-ci - dans celle-ci. <br><br>  Il s'avère qu'une énorme quantité de données, qui se trouve dans la RAM: <br><br><ul><li>  plus il y a d'objets, plus l'histoire de missing_loc est grande; </li><li>  plus PG - plus pg_log et carte OSD; </li></ul><br>  en plus: <br><br><ul><li>  plus la taille du disque est grande; </li><li>  plus la densité est élevée (le nombre de disques dans chaque serveur); </li><li>  plus la charge sur le cluster est élevée et plus votre cluster est rapide; </li><li>  plus l'OSD est arrêté (en mode hors ligne); </li></ul><br>  en d'autres termes, <strong>plus le cluster que nous avons construit est raide et plus la partie du cluster ne répond plus, plus il faudra de RAM au démarrage</strong> . <br><br><h2>  Les optimisations extrêmes sont à l'origine de tout mal <br></h2><br><blockquote>  <em>"... et le MOO noir vient aux mauvais garçons et filles la nuit et tue tous les processus à gauche et à droite"</em> <br><br>  Légende du sysadmin de la ville <br></blockquote><br>  Ainsi, la RAM nécessite beaucoup, la consommation de mémoire augmente (nous avons commencé tout de suite dans un tiers du cluster) et le système peut en théorie passer en SWAP, si vous l'avez créé bien sûr.  Je pense que beaucoup de gens pensent que SWAP est mauvais et qu’ils ne le créent pas: «Pourquoi?  Nous avons beaucoup de mémoire! »  Mais ce n'est pas la bonne approche. <br><br>  Si le fichier SWAP n'a pas été créé à l'avance, car il a été décidé que Linux fonctionnerait plus efficacement, tôt ou tard, cela se produirait par manque de mémoire (OOM-killer). Et pas le fait qu'il tue celui qui a mangé toute la mémoire, non celui qui a été le premier malchanceux.  Nous savons ce qu'est un endroit optimiste - nous demandons un souvenir, ils nous le promettent, nous disons: "Maintenant, donnez-nous-en un", en réponse: "Mais non!"  - et tueur de mémoire. <br><br>  Il s'agit d'un travail Linux normal, sauf s'il est configuré dans la zone de mémoire virtuelle. <br><br>  Le processus sort du tueur de mémoire et tombe rapidement et sans pitié.  De plus, aucun autre processus qu'il est décédé ne sait.  Il n'a pas eu le temps d'informer quiconque de quoi que ce soit, ils l'ont simplement licencié. <br><br>  Ensuite, bien sûr, le processus va redémarrer - nous avons systemd, il lance également, si nécessaire, les OSD qui sont tombés.  Les OSD tombés commencent et ... une réaction en chaîne commence. <br><img src="https://habrastorage.org/webt/9p/s8/4z/9ps84zkjtmuamxyllkcgffsgxkq.png"><br><br>  Dans notre cas, nous avons commencé OSD 8 et OSD 9, ils ont commencé à tout écraser, mais pas de chance OSD 0 et OSD 5. Un tueur en mémoire a volé vers eux et les a mis fin.  Ils ont redémarré - ils ont lu leurs données, ont commencé à synchroniser et à écraser le reste.  Trois autres malchanceux (OSD 9, OSD 4 et OSD 7).  Ces trois ont redémarré, ont commencé à faire pression sur l'ensemble du cluster, le pack suivant n'a pas eu de chance. <br><br>  <strong>Le cluster commence à s'effondrer littéralement sous nos yeux</strong> .  La dégradation se produit très rapidement, et ce «très rapide» s'exprime généralement en minutes, maximum dizaines de minutes.  Si vous avez 30 nœuds (10 nœuds par rack) et coupez le rack en raison d'une panne de courant - après 6 minutes, la moitié du cluster se trouve. <br><br>  Donc, nous obtenons quelque chose comme ce qui suit. <br><img src="https://habrastorage.org/webt/1b/hq/bu/1bhqburpjt74vwnpbgqn5ehdhh0.png"><br><br>  Sur presque tous les serveurs, nous avons un OSD défectueux.  Et si c'est sur chaque serveur, c'est-à-dire dans chaque domaine de défaillance que nous avons pour l'OSD défaillant, alors la <strong>plupart de nos données ne sont pas disponibles</strong> .  Toute demande est bloquée - pour écrire, pour lire - cela ne fait aucune différence.  C’est tout!  Nous nous sommes levés. <br><br>  Que faire dans une telle situation?  Plus précisément, <strong>que fallait-il faire</strong> ? <br><br>  <strong>Réponse:</strong> Ne démarrez pas le cluster immédiatement, c'est-à-dire l'ensemble du rack, mais élevez soigneusement un démon chacun. <br><br>  Mais nous ne le savions pas.  Nous avons commencé tout de suite et avons obtenu ce que nous avons obtenu.  Dans ce cas, nous avons lancé l'un des quatre démons (8, 9, 10, 11), la consommation mémoire augmentera d'environ 20%.  En règle générale, nous faisons un tel bond.  Ensuite, la consommation de mémoire commence à diminuer, car certaines des structures utilisées pour contenir les informations sur la façon dont le cluster s'est dégradé quittent.  Autrement dit, une partie des groupes de placement est revenue à son état normal, et tout ce qui est nécessaire pour maintenir l'état dégradé est libéré - <strong>en théorie, il est libéré</strong> . <br><br>  Voyons un exemple.  Le code C à gauche et à droite est presque identique, la différence ne concerne que les constantes. <br><img src="https://habrastorage.org/webt/sy/1j/u0/sy1ju0rfqjg507jxvk_4wax9_o4.png"><br><br>  Ces deux exemples demandent une quantité de mémoire différente du système: <br><br><ul><li>  gauche - 2 048 morceaux de 1 Mo chacun; </li><li>  à droite - 2097152 pièces de 1 kilo-octet. </li></ul><br>  Ensuite, les deux exemples nous attendent pour les photographier en haut.  Et après avoir appuyé sur ENTER, ils libèrent de la mémoire - tout sauf le dernier morceau.  C'est très important - la dernière pièce reste.  Et encore une fois, ils attendent que nous les photographions. <br><br>  Voici ce qui s'est réellement passé. <br><img src="https://habrastorage.org/webt/zx/ah/ug/zxahugrdasantcktho7dbu-tnes.png"><br><br><ul><li>  Tout d'abord, les deux processus ont démarré et ont mangé la mémoire.  Sonne comme la vérité - 2 Go RSS. </li><li>  Appuyez sur ENTER et soyez surpris.  Le premier programme qui s'est démarqué en gros morceaux a rendu la mémoire.  Mais le deuxième programme n'est pas revenu. </li></ul><br>  La raison pour laquelle cela s'est produit réside dans le malloc Linux. <br><br>  Si nous demandons de la mémoire en gros morceaux, elle est émise à l'aide du mécanisme mmap anonyme, qui est donné à l'espace d'adressage du processeur, d'où la mémoire nous est ensuite coupée.  Lorsque nous faisons free (), la mémoire est libérée et les pages sont retournées au cache de pages (système). <br><br>  Si nous allouons de la mémoire en petits morceaux, nous faisons sbrk ().  sbrk () déplace le pointeur vers la queue du tas; en théorie, la queue décalée peut être renvoyée en renvoyant des pages de mémoire au système si la mémoire n'est pas utilisée. <br><br>  Regardez maintenant l'illustration.  Nous avions de nombreux enregistrements dans l'histoire de la localisation des objets dégradés, puis la session utilisateur - un objet à longue durée de vie.  Nous nous sommes synchronisés et toutes les structures supplémentaires ont disparu, mais l'objet à longue durée de vie est resté et nous ne pouvons pas reculer sbrk (). <br><img src="https://habrastorage.org/webt/06/wf/eg/06wfegwyvu0ibae8xjlwizrwteo.png"><br><br>  Nous avons encore beaucoup d'espace inutilisé qui pourrait être libéré si nous avions SWAP.  Mais nous sommes intelligents - nous avons désactivé SWAP. <br><br>  Bien sûr, alors une partie de la mémoire du début du tas sera utilisée, mais ce n'est qu'une partie, et un reste très important sera occupé. <br><br>  Que faire dans une telle situation?  La réponse est ci-dessous. <br><br><h3>  Lancement contrôlé <br></h3><br><ul><li>  Nous démarrons un démon OSD. </li><li>  On attend pendant qu'il est synchronisé, on vérifie les budgets mémoire. </li><li>  Si nous comprenons que nous survivrons au début du prochain démon, nous commençons le suivant. </li><li>  Sinon, redémarrez rapidement le démon qui a pris le plus de mémoire.  Il a pu baisser pendant un court instant, il n'a pas beaucoup d'histoire, il manque des locs et d'autres choses, donc il va manger moins de mémoire, le budget mémoire augmentera légèrement. </li><li>  Nous courons autour du cluster, le contrôlons et levons progressivement tout. </li><li>  Nous vérifions s'il est possible de passer au prochain OSD, allez-y. </li></ul><br>  DigitalOcean a en fait accompli ceci: <br>  <em>"Notre équipe Datacenter effectue des augmentations de mémoire tandis qu'une autre équipe continue lentement à mettre en place des nœuds tout en gérant manuellement le budget de mémoire de chaque hôte."</em> <br><img src="https://habrastorage.org/webt/nr/yg/a1/nryga17av_ez5yj0mt3lm5grkk0.png"><br><br>  Revenons à notre configuration et à notre situation actuelle.  Nous avons maintenant un cluster effondré après une réaction en chaîne de tueur en mémoire.  Nous interdisons le redémarrage automatique de l'OSD dans le domaine rouge, et un par un, nous démarrons les nœuds à partir des domaines bleus.  Parce que <strong>notre première tâche est toujours de restaurer le service</strong> , sans comprendre pourquoi cela s'est produit.  Nous comprendrons plus tard, lorsque nous rétablirons le service.  En fonctionnement, c'est toujours le cas. <br><br>  Nous amenons le cluster à l'état cible afin de restaurer le service, puis nous commençons à exécuter un OSD après l'autre selon notre méthodologie.  Nous regardons le premier, si nécessaire, redémarrez les autres pour ajuster le budget mémoire, le suivant - 9, 10, 11 - et le cluster semble être synchronisé et prêt à démarrer la maintenance. <br><br>  Le problème est de savoir comment la <strong>maintenance en écriture</strong> est effectuée <strong>dans Ceph</strong> . <br><img src="https://habrastorage.org/webt/hl/rp/ek/hlrpekm0rvjgrjwl11zgdklwecc.png"><br><br>  Nous avons 3 répliques: un OSD maître et deux esclaves pour cela.  Nous allons préciser que le maître / esclave de chaque groupe de placement a le sien, mais chacun a un maître et deux esclaves. <br><br>  L'opération d'écriture ou de lecture incombe au maître.  Lors de la lecture, si le maître a la bonne version, il la remettra au client.  L'enregistrement est un peu plus compliqué, l'enregistrement doit être répété sur toutes les répliques.  Par conséquent, lorsque le client écrit 64 Ko dans OSD 0, les mêmes 64 Ko dans notre exemple vont à OSD 5 et OSD 8. <br><br>  Mais le fait est que notre OSD 8 est très dégradé, car nous avons redémarré de nombreux processus. <br><img src="https://habrastorage.org/webt/es/_z/fr/es_zfrsvdaq8a7f_rgn7hcakpi4.png"><br><br>  Étant donné que dans Ceph, tout changement est une transition d'une version à l'autre, sur OSD 0 et OSD 5, nous aurons une nouvelle version, sur OSD 8 - l'ancienne.  ,   ,    ( 64 )    OSD 8   —   4  ( ).     4   OSD 0,   OSD 8,  ,    .       ,      64 . <br><br>    —  . <br><img src="https://habrastorage.org/webt/ch/uc/l_/chucl_b0vhoi-jvuhl3xokm26qg.png"><br><br>   : <br><br><ul><li>    4   1 ,  1000 /  1 . </li><li>   4  ( )  22 ,  45 /. </li></ul><br> ,      ,       ,        ,         . <br><br>      —     . <br><img src="https://habrastorage.org/webt/it/0p/34/it0p34kbqfs3u9hvyhmextflvqc.png"><br><br>    4   22 ,  22 ,   1    4   .   45          SSD,       1  — <strong>   45 </strong> . <br><br>       ,    . <br><br><h2>    <br></h2><br><br><ul><li>   <strong> </strong> ,    — (45+1) / 2 = <strong>23 .</strong> </li><li>   <strong>75% </strong> ,  (45 * 3 + 1) / 4 = <strong>34 </strong> . </li><li>  90% —(45 * 9 + 1) / 10 = 41  —  40  ,   . </li></ul><br>     Ceph,      .                 ,     ,    ,     . <br><br>      Ceph       . <br><img src="https://habrastorage.org/webt/ng/jj/od/ngjjodzmfd4n6kes71g4n6pg7os.png"><br><br><ol><li>     —   :  , ,  ,  ,    . <br></li><li>  — latency.   latency  ,   .      100%    (    ,          ). Latency  60     ,       . <br></li></ol><br><img src="https://habrastorage.org/webt/z3/pb/ob/z3pbobkev0bfszscnwgprpop3xe.png"><br><br>       ,       .  10 ,   1 200 /,    300      ,    ,   .  10 SSD —   300   ,   — ,  - 300   . <br><br><blockquote>    ,     . <br></blockquote><br>  ,     .       900 / (  SSD).     2 500   128    ( , ESXi  HyperV     128 ).      degraded,   225   .     file store,   object store,         ( ),    110   ,     - . <br><br> SSD  110    — ! <br><br> <strong>   ?</strong> <br><br> <strong> 1:</strong>     — <b>   </b> . <br><img src="https://habrastorage.org/webt/ls/ib/rh/lsibrhcfnucjiox9f8gzxbk1cc8.png"><br><br>    :   ;   PG; <br>       . <br><br>    : <br><br><ul><li>    ,  45  —   . </li><li>     (     . ),   14 . </li><li>    ,  8  (  10% PG). </li></ul><br>   <strong>  ,  </strong> ,       , ,  ,     . <br><br> <strong> 2:</strong>   — <b>  </b> (order, objectsize)  . <br><br>     , , ,   4   2  1 .      ,     ,   .  Dans ce cas: <br><br><ul><li>     ; </li><li>     (latency)     . </li></ul><br>     : <br><br><ul><li>    ; </li><li>     ; </li><li>   —        .     4 ,   . </li></ul><br>        (32  ) —      ! <br><br> <strong> 3:</strong>    —  <b> Ceph</b> . <br><br>     ,   -,  <strong> Ceph</strong> .                  ,      ,      .     . <br><img src="https://habrastorage.org/webt/c8/nr/1a/c8nr1akew1kjleodu5trq_ow3oy.png"><br><br>     ,   — Latency.  —  ,  — . Latency      30% ,       ,      . <br><br>  Community     ,     preproduction .     ,     .      ,   . <br><br><h1>  Conclusion <br></h1><br>      -  ,     .        ,   Ceph    - ,  ,    . <br><br> ● <strong>   -  </strong> . <br>     ,     .  ,  <strong>     </strong> .       .  ,         ,    production.  ,       ,     ,    DigitalOcean  ,   .   ,  ,    ,  . <br><br>   ,        ,        .    ,  : «    !  ?!»     ,  ,     .   ,      : ,   ,    down time. <br><br> ● <strong>    (OSD).</strong> <br>  ,       ,     —     , ,  -      ,   . <strong>     OSD —    —   </strong> .    ,     . <br><br> ● <strong>  .</strong> <br>        OSD       . <strong>   ,   </strong> .  ,     ,     ,   . <br><br> ● <strong>  RAM   OSD.</strong> <br><br> ● <strong>  SWAP.</strong> <br>   SWAP    Ceph' ,    Linux' .         . <br><br> ● <strong>    .</strong> <br>         100%,    10%. ,    ,      ,   . <br><br> ● <strong>        RBD      Rados Getway.</strong> <br>  ,         . <strong>   SWAP —    .</strong> ,    SWAP  —    , ,  ,    ,     . <br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cet article est une transcription de l'un des meilleurs rapports de DevOpsConf Russia. </font><font style="vertical-align: inherit;">Bientôt, nous ouvrirons la vidéo et publierons dans une version texte à quel point les sujets sont intéressants. </font><font style="vertical-align: inherit;">Abonnez-vous ici sur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">youtube</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou dans la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">newsletter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> si vous ne voulez pas manquer de tels documents utiles et être au courant des nouvelles de DevOps.</font></font><br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr431536/">https://habr.com/ru/post/fr431536/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr431526/index.html">Influence corrompue: comment la Stasi a défendu l'Allemagne de l'Est contre les jeux vidéo</a></li>
<li><a href="../fr431528/index.html">Un mystérieux génie mathématique et un écrivain promeuvent une solution au problème de permutation</a></li>
<li><a href="../fr431530/index.html">Leçon ouverte "Android Material Design: aperçu de la mise à jour"</a></li>
<li><a href="../fr431532/index.html">Memristors constitués de pièces de 2 nm d'épaisseur</a></li>
<li><a href="../fr431534/index.html">Identités des problèmes parmi les développeurs</a></li>
<li><a href="../fr431538/index.html">Case Rate & Goods et Mobio: augmentation progressive de tous les indicateurs</a></li>
<li><a href="../fr431540/index.html">Packages et gestionnaires de packages pour k8s</a></li>
<li><a href="../fr431542/index.html">Développement et maintenance efficaces des rôles Ansible</a></li>
<li><a href="../fr431544/index.html">Portez DevOps aux masses</a></li>
<li><a href="../fr431546/index.html">Pourquoi disons-nous OK?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>