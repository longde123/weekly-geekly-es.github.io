<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏬ 🈹 🥩 Code réseau Age of Empires: 1 500 archers par modem à 28,8 kbps 🤵🏿 🧘🏽 👨🏻‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Note du traducteur: cet article a déjà 17 ans, et il n'est intéressant que d'un point de vue historique. Il est intéressant d'apprendre comment les dé...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Code réseau Age of Empires: 1 500 archers par modem à 28,8 kbps</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417703/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eaa/c7f/fd7/eaac7ffd7c6a997f72a9cdd4cf67e982.png" alt="image"></div><br>  <i>Note du traducteur: cet article a déjà 17 ans, et il n'est intéressant que d'un point de vue historique.</i>  <i>Il est intéressant d'apprendre comment les développeurs ont réussi à réaliser un jeu en ligne fluide à l'ère des modems 28,8k et des premiers Pentiums.</i> <br><br>  Cet article décrit l'architecture et l'implémentation, ainsi que quelques leçons tirées de la création du code multi-utilisateurs (réseau) pour les jeux <em>Age of Empires 1 et 2</em> .  Il décrit également les approches d'architecture de réseau actuelles et futures utilisées par Ensemble Studios dans leurs moteurs de jeu. <br><br><h2>  Age of Empires multijoueur: exigences de structure </h2><br>  Au début des travaux sur le code multijoueur <em>Age of Empires</em> en 1996, nous nous sommes fixés des objectifs très spécifiques nécessaires à la mise en place du gameplay requis. <br><a name="habracut"></a><br><ul><li>  Des batailles historiques à grande échelle et épiques avec de nombreuses unités militaires différentes </li><li>  Prise en charge de jusqu'à 8 joueurs en mode multijoueur </li><li>  Simulation de jeu fluide sur LAN, via une connexion directe par modem et sur Internet </li><li>  Prise en charge de la plate-forme cible: Pentium 90 avec 16 Mo de RAM et un modem à 28,8 kbps </li><li>  Le système de communication doit fonctionner avec le moteur existant (Génie) </li><li>  Stable 15 images par seconde sur les machines avec une configuration minimale </li></ul><br>  Le moteur Genie était déjà prêt et le gameplay en mode mono-utilisateur a commencé à prendre ses formes.  Le moteur Genie est un moteur de boucle de jeu à un seul filetage en deux dimensions.  Les sprites sont rendus en 256 couleurs dans un monde composé de tuiles.  Les cartes générées aléatoirement sont remplies de milliers d'objets: des arbres pouvant être coupés aux gazelles au galop.  Répartition approximative (après optimisation) du temps d'exécution des tâches du moteur: 30% pour le rendu des graphiques, 30% pour l'IA et la recherche de chemins, 30% pour l'exécution des simulations et des tâches officielles. <br><br>  Déjà à un stade assez précoce, le moteur était relativement stable et les communications multi-utilisateurs devaient fonctionner avec du code prêt à l'emploi sans qu'il soit nécessaire de modifier considérablement l'architecture (de travail) existante. <br><br>  Pour compliquer la tâche, le temps nécessaire pour terminer chaque étape de simulation pouvait varier considérablement: le temps de rendu dépendait du fait que l'utilisateur regardait les unités, faisait défiler ou regardait la zone inexplorée, et les longs trajets ou la planification stratégique de l'IA affectaient considérablement le temps d'exécution du mouvement de jeu. : les oscillations étaient jusqu'à 200 ms. <br><br>  De brefs calculs ont montré que le transfert d'un petit ensemble de données sur les unités et les tentatives de les mettre à jour en temps réel limitent considérablement le nombre d'unités et d'objets avec lesquels le joueur peut interagir.  Si vous transférez simplement les coordonnées X et Y, l'état, l'action, la direction de la vue et les dégâts, alors dans le jeu, il ne peut y avoir plus de 250 unités mobiles. <br><br>  Nous voulions que les joueurs puissent détruire les villes grecques avec des catapultes, des archers et des guerriers, tout en menant des sièges avec des trirèmes de la mer.  De toute évidence, nous avions besoin d'une autre approche. <br><br><h2>  Simulations simultanées </h2><br>  Au lieu de transmettre l'état de chaque unité du jeu, nous avons voulu effectuer des simulations absolument identiques sur chaque machine, en passant chacune le même jeu de commandes donné par les joueurs en même temps.  Les ordinateurs des joueurs, en substance, devaient synchroniser le gameplay dans les meilleures traditions des films de guerre, permettant aux joueurs d'émettre des commandes, puis de les exécuter de la même manière et en même temps, garantissant l'identité des jeux. <br><br>  Initialement, une synchronisation aussi délicate était difficile à mettre en œuvre, mais en conséquence, elle apportait des avantages inattendus dans d'autres domaines. <br><br>  <strong>Amélioration de base du modèle</strong> <br><br>  Au niveau conceptuel le plus simple, la mise en œuvre de simulations simultanées semble très facile.  Dans certains jeux qui utilisent des simulations avec une étape fixe (étape de verrouillage) et des timings constants, cela peut même être tout à fait possible. <br><br>  Étant donné qu'avec cette approche, il devrait prendre la responsabilité de déplacer simultanément des centaines ou des milliers d'objets, le système doit rester viable même avec des fluctuations de retard de 20 à 1000 millisecondes et gérer les changements lors du traitement de la trame. <br><br>  L'envoi des commandes des joueurs, la confirmation de tous les messages, puis leur traitement avant de passer au mouvement suivant serait un cauchemar du point de vue du processus de jeu, avec une attente constante et un échange lent des équipes.  Nous avions besoin d'un schéma qui pourrait continuer à traiter le jeu en parallèle avec l'arrière-plan en attendant la fin du processus d'échange de données. <br><br>  Mark [Terrano] a utilisé un système pour marquer les commandes qui devraient être exécutées à travers deux «mouvements d'échange de données» à l'avenir (les mouvements d'échange de données dans <em>AoE</em> étaient séparés des cadres de rendu eux-mêmes). <br><br>  C'est-à-dire que les commandes données pendant le cours 1000 sont affectées pour être exécutées pendant le cours 1002 (voir figure 1).  Au cours de 1001, les commandes données au cours de 0 999 sont exécutées, ce qui nous a permis de recevoir, de confirmer et de préparer des messages à traiter, tandis que le jeu a continué à dessiner des animations et à effectuer des simulations. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/01d/163/10f/01d16310f6b5958701fbde3e8480790a.jpg"></div><br>  <i>Figure 1. Balisage des commandes à exécuter via deux «mouvements d'échange de données».</i> <br><br>  Habituellement, les mouvements prenaient 200 ms, et les équipes étaient envoyées pendant ce tour.  Après 200 ms, le mouvement s'est arrêté et un nouveau mouvement a commencé.  À chaque instant de la partie, les équipes ont été traitées en un coup, reçues et enregistrées pour le coup suivant, puis envoyées pour exécution deux coups plus tard. <br><br><h2>  "Contrôle de vitesse" </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc5/133/4b0/fc51334b03798cffa22b0a18938e9ce3.jpg"></div><br>  <i>Figure 2. Contrôle de vitesse.</i> <br><br>  Étant donné que les simulations doivent toujours avoir exactement la même entrée, un jeu ne peut pas fonctionner plus vite que la machine la plus lente ne parvient à traiter l'échange de données, à effectuer un déplacement et à envoyer de nouvelles commandes.  Nous avons appelé le système qui modifie la durée du coup pour maintenir des animations et un gameplay fluides dans des conditions de délai d'échange de données et de vitesse de traitement variables «Speed ​​Control». <br><br>  Le gameplay peut être ressenti comme un "freinage" pour deux raisons: si la fréquence d'images d'une machine chute (ou si elle est inférieure aux autres), les autres machines traitent leurs commandes, rendent tout au temps imparti et, par conséquent, elles doivent attendre le prochain mouvement.  Dans ce cas, toute pause devient immédiatement perceptible.  De plus, le jeu est ralenti par un retard dans l'échange de données - les joueurs doivent attendre que la machine reçoive suffisamment de données pour terminer le mouvement. <br><br>  Chaque client a calculé la fréquence d'images considérée comme constamment réalisable, qui a été calculée en faisant la moyenne du temps de traitement de plusieurs images.  Étant donné que cette valeur change pendant le jeu en fonction de la portée, du nombre d'unités, de la taille de la carte et d'autres facteurs, elle a été transmise dans chaque message concernant la fin du mouvement. <br><br>  De plus, chaque client a également mesuré le «temps de ping» entre lui et les autres clients et vice versa.  Il a également envoyé le ping moyen au client le plus long dans un message sur la fin du déplacement (au total, 2 octets ont été utilisés pour contrôler la vitesse). <br><br>  À chaque déplacement, la machine désignée par l'hôte a analysé les messages d'achèvement, calculé la fréquence d'images nécessaire et la correction du retard dans la transmission des données sur Internet.  L'hôte a ensuite envoyé une nouvelle fréquence d'images et la durée de l'échange de données.  Les figures 3 à 5 montrent comment le flux d'échange de données a été divisé dans différentes conditions. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/34d/ce4/48d/34dce448d5683dd1e449b7d2cf25d505.jpg"></div><br>  <i>Figure 3. Flux d'échange de données typique.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b9/6b4/1a8/3b96b41a83ee28f6d94164f87f8a8df6.jpg"></div><br>  <i>Figure 4. Transmission de données à latence élevée sur Internet à vitesse normale de la machine.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/645/4d5/bd1/6454d5bd11e1ca0b16971e8a3e27cf9f.jpg"></div><br>  <i>Figure 5. Faible vitesse de la machine avec un délai de transfert de données normal.</i> <br><br>  La "progression de l'échange de données", qui était approximativement égale au temps de ping pour l'aller-retour pour le message, était divisée par le nombre de trames de simulation que la machine la plus lente pouvait effectuer en moyenne pendant cette période. <br><br>  La durée de l'échange de données a été pondérée, de sorte qu'elle pourrait rapidement augmenter en fonction des changements dans la latence de la transmission de données sur Internet et diminuer lentement jusqu'à la meilleure vitesse moyenne qui peut être constamment maintenue.  Habituellement, le jeu a ralenti et ralenti uniquement aux moments des pires pics - le délai de transmission des commandes a augmenté, mais est resté fluide (et n'a augmenté que de quelques millisecondes par tour), car le jeu a progressivement réduit les retards à la meilleure vitesse possible.  Cela a créé la plus grande fluidité possible du gameplay, tout en offrant un ajustement aux conditions changeantes. <br><br><h2>  Livraison garantie </h2><br>  UDP a été utilisé dans la couche réseau et chaque client a été impliqué dans la commande des commandes, la reconnaissance des pertes et la retransmission.  Chaque message utilisait une paire d'octets, indiquant le cours pour lequel l'exécution des commandes était prévue et le numéro de série du message.  Si un message a été reçu après le déplacement, il a été rejeté et les messages entrants ont été enregistrés pour exécution.  En raison de la nature de l'UDP, Mark a utilisé le principe suivant lors de la réception de messages: «En cas de doute, vous devriez considérer le message perdu.  Si des messages sont reçus dans le désordre, le destinataire envoie immédiatement une demande de retransmission des messages perdus.  Si l'accusé de réception est reçu plus tard que l'heure prévue, l'expéditeur envoie simplement à nouveau le message, sans attendre un signal de sa perte. " <br><br><h2>  Avantages cachés </h2><br>  Étant donné que les résultats calculés par le jeu dépendaient de tous les utilisateurs effectuant des simulations identiques, il était incroyablement difficile pour un client (ou un flux de données client) de pirater et de tricher.  Toute simulation effectuée différemment a été marquée comme «désynchronisée» et le jeu s'est arrêté.  Il était toujours possible de tricher localement pour la divulgation d'informations, mais ces fuites étaient relativement facilement corrigées dans les correctifs et révisions ultérieurs.  La sécurité est devenue notre plus grande victoire. <br><br><h2>  Problèmes cachés </h2><br>  Au début, il peut sembler que la même exécution de deux instances du même code est facile à implémenter, mais ce n'est pas le cas.  Aux toutes premières étapes du projet, Tim Znamenachek, chef de produit Microsoft, a déclaré à Mark: «Chaque projet a un bogue persistant qui n'abandonne pas jusqu'à la fin.  Je pense que dans notre cas, ce sera désynchronisé. »  Et il avait raison.  Les difficultés de détection des erreurs de synchronisation se sont multipliées à chaque petit changement.  Le cerf, dont la position est légèrement différente lors de la création d'une carte aléatoire, se déplacera un peu différemment, et quelques minutes plus tard, le chasseur se déplacera légèrement ou manquera une lance, à la suite du retour à la maison sans viande.  Par conséquent, ce qui semblait parfois n'être qu'une différence dans les sommes de contrôle de la quantité de nourriture avait des raisons très difficiles à suivre. <br><br>  Bien que nous ayons vérifié le monde, les objets, recherché des chemins, visé et tous les autres systèmes avec des sommes de contrôle, il y avait toujours quelque chose que nous ne pouvions pas prendre en compte.  D'énormes volumes (50 Mo chacun) de suivi des messages et de vidages d'objets du monde ont rendu le problème encore plus compliqué.  Une partie des difficultés était d'ordre conceptuel - les programmeurs n'étaient pas habitués à écrire du code utilisant le même nombre d'appels de générateur de nombres aléatoires dans une simulation (oui, des nombres aléatoires étaient également générés et synchronisés). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d29/1c3/690/d291c3690fef6c18cc65aec724dafe31.png" alt="image"></div><br><h2>  Leçons apprises </h2><br>  Lors du développement de la partie réseau d' <em>Age of Empires,</em> nous avons reçu plusieurs leçons qui peuvent être appliquées au développement de tout système multi-utilisateur de jeu. <br><br>  <strong><em>Apprenez à votre utilisateur.</em></strong>  L'étude de l'utilisateur est l'étape la plus importante pour comprendre ses attentes concernant la vitesse du multijoueur, les freins perçus et les retards dans la transmission des commandes.  Chaque genre est individuel et vous devez comprendre ce qui convient à votre style de jeu et à votre gestion. <br><br>  Dans les premières étapes du processus de développement, Mark et le concepteur principal ont retardé l'échange de données (ce prototype a été révisé plusieurs fois au cours du processus de développement).  Puisqu'ils jouaient à un jeu en solo, il était très facile de simuler différents niveaux de retards de transfert d'équipe et d'obtenir des commentaires des joueurs («le contrôle semble bon / lent / tremblant / tout simplement horrible»). <br><br>  Pour les jeux du genre RTS, les retards de transmission des commandes de 250 millisecondes ne sont même pas perceptibles, à 250-500 ms le gameplay est assez jouable, et les freins deviennent perceptibles à 500 ms et plus.  Il est également intéressant de noter que les joueurs sont habitués au "rythme du jeu" et à l'attente mentale d'un délai entre les clics de souris et les réactions des unités.  Une réponse différée constante était meilleure que des sauts dans les délais de transmission des commandes (par exemple, de 80 à 500 ms) - dans ce cas, des retards constants de 500 ms étaient perçus comme jouables, et les changements modifiables semblaient "nerveux" et compliquaient le jeu. <br><br>  Cela a obligé les programmeurs à concentrer leurs efforts sur la fluidité - il vaut mieux choisir une durée de course plus longue et être sûr que tout sera fluide et constant que d'effectuer les opérations le plus rapidement possible, face à des ralentissements réguliers.  Tous les changements de vitesse doivent être progressifs et le taux de croissance doit être aussi faible que possible. <br><br>  Nous avons également mesuré les besoins de l'utilisateur pour le système - généralement, ils donnaient des commandes (déplacer, attaquer, couper des arbres) environ toutes les secondes et demie à deux secondes, parfois avec des pics de 3-4 équipes par seconde lors de batailles acharnées.  Comme les actions actives dans notre jeu sont en constante augmentation, les exigences les plus élevées pour l'échange de données surviennent au milieu et vers la fin du jeu. <br><br>  Si vous prenez le temps d'étudier le comportement des utilisateurs, vous remarquerez d'autres fonctionnalités de leur jeu, ce qui vous aidera à configurer le jeu en réseau.  Dans <em>AoE</em> pendant les attaques, les utilisateurs ont rapidement cliqué sur la souris (cliquer-cliquer-cliquer-cliquer - avancer-avancer-avancer-avancer!), Ce qui a entraîné d'énormes pics dans le nombre de commandes émises.  En outre, ils ont envoyé de grands groupes d'unités qui doivent ouvrir la voie - ainsi que d'énormes pics dans les exigences de transmission de données sur le réseau.  Un simple filtre, coupant les commandes répétées à un moment donné, a considérablement réduit l'impact négatif de ce comportement. <br><br>  En général, la surveillance des utilisateurs vous permettra de: <br><br><ul><li>  Découvrez les attentes des utilisateurs concernant les retards de jeu </li><li>  Aspects multijoueurs prototypes aux premiers stades de développement </li><li>  Découvrez les comportements préjudiciables à la vitesse du mode multi-utilisateur. </li></ul><br>  <strong><em>La mesure est la chose la plus importante.</em></strong>  Si vous introduisez des mesures dans les premières étapes du travail, vous apprendrez des choses incroyables sur votre système d'échange de données.  Rendez les métriques lisibles pour les testeurs et utilisez-les pour comprendre ce qui se passe à l'intérieur du moteur réseau. <br><br>  Leçon: Une partie du problème avec l'échange de données dans AoE est survenue lorsque Mark a déduit les mesures trop tôt et n'a pas vérifié les niveaux de message (longueur et fréquence) après avoir préparé le code final.  Des choses inattendues comme des courses aléatoires entre les IA, des chemins difficiles à calculer et des packages de commandes mal structurés peuvent causer d'énormes problèmes de performances, même lorsque le système fonctionne bien. <br><br>  Faire en sorte que le système informe les testeurs et les développeurs de ce qui semble être un excès de conditions aux limites - les programmeurs et les testeurs verront dans le processus de développement quelles tâches chargent le système;  cela résoudra les problèmes aux premiers stades de leur apparition. <br><br>  Prenez le temps d'expliquer aux testeurs comment fonctionne le système d'échange de données, montrez-leur et expliquez-leur les mesures - vous serez peut-être surpris qu'ils remarqueront quand d'étranges défaillances se produisent inévitablement dans le code réseau. <br><br>  En général, les métriques doivent avoir les propriétés suivantes: <br><br><ul><li>  Soyez lisible et compréhensible par les testeurs </li><li>  Indiquez les goulots d'étranglement, les freins et les problèmes </li><li>  Peu d'impact sur l'exécution et constamment lancé. </li></ul><br>  <strong><em>Formation des développeurs.</em></strong>  Il est très difficile d'apprendre aux programmeurs habitués à créer des applications mono-utilisateur à réfléchir à la séparation entre donner, recevoir et traiter une commande.  Il est facile d'oublier que vous pouvez demander quelque chose qui ne s'est pas produit ou ce qui pourrait arriver quelques secondes après l'émission de la commande.  L'exactitude des commandes doit être vérifiée à l'envoi et à la réception. <br><br>  Dans un modèle synchrone, les programmeurs doivent également tenir compte du fait qu'à l'intérieur de la simulation, le code ne devrait dépendre d'aucun facteur local (comme la disponibilité de temps libre, des équipements spéciaux ou des paramètres différents).  L'exécution du code sur toutes les machines doit correspondre.  Par exemple, la présence de sons aléatoires du terrain dans une simulation peut entraîner des comportements de jeu différents. <br><br>  <strong><em>Autres leçons.</em></strong>  Cela devrait être le bon sens habituel - mais si vous dépendez d'un réseau tiers (dans notre cas, c'est DirectPlay), alors écrivez une application de test indépendante confirmant que lorsque les propriétaires réclament une «livraison garantie», les messages obtiennent vraiment cet «ordre de paquet garanti» en fait il y en a, et que le produit n'a pas de goulots d'étranglement cachés ou de comportement étrange lors du traitement des données transmises dans votre jeu. <br><br>  Préparez-vous à créer des applications de simulation et des simulateurs de tests de résistance.  Au final, nous avons créé trois applications de test minimales différentes utilisées pour étudier les problèmes individuels et importants: les inondations de connexion, les problèmes de connexions simultanées lors de la sélection des opposants et les packages garantis perdus. <br><br>  Testez avec des modems (et, avec un peu de chance, avec des simulateurs de modem) le plus tôt possible;  Poursuivez les tests de modem (aussi douloureux que cela puisse être) tout au long du processus de développement.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après tout, les problèmes sont difficiles à isoler (quelle est la raison de la forte diminution de la vitesse - le fournisseur, le jeu, le logiciel de communication, le modem, le service de recherche rival pour une correspondance ou autre chose?), Et les utilisateurs ne veulent pas s'embêter avec des connexions à distance lentes, s'habituer à des vitesses LAN instantanées . </font><font style="vertical-align: inherit;">Il est essentiel de tester les connexions par modem avec la même persistance que pour les jeux LAN multi-joueurs.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f4b/f84/6f8/f4bf846f89de72b3374179b174094cc8.jpg" alt="image"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Améliorations pour </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Age of Empires 2</font></font></em> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Age of Empires 2: The Age of Kings,</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous avons ajouté des fonctionnalités multi-utilisateurs telles que l'enregistrement de jeux, le transfert de fichiers et le suivi constant des statistiques sur le site Web de The Zone. Nous avons également amélioré les systèmes multijoueurs tels que l'intégration DirectPlay et le contrôle de vitesse pour faire face aux bugs et problèmes de vitesse identifiés après la sortie d' </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Age of Empires</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La fonction d'enregistrement de jeux était l'une de ces choses qui ont été à l'origine inventées pour le débogage, et en conséquence est devenue une «fonctionnalité» à part entière du jeu. Les jeux enregistrés sont incroyablement populaires sur les sites de fans. Ils permettent aux joueurs de partager des stratégies et de les analyser, de voir des batailles célèbres et d'apprendre les jeux auxquels ils ont participé. L'enregistrement de jeux est devenu un outil de débogage inestimable. Étant donné que notre simulation est déterministe et que les jeux enregistrés sont synchrones dans le même sens que le multijoueur, l'enregistrement de jeux nous a fourni un excellent moyen de jouer aux bugs, car à chaque fois, il était garanti de jouer de la même manière. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notre intégration avec le service de recherche de rival (matchmaking) de The Zone a été limitée dans </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Age of Empires pour</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> simplement lancer le jeu. Dans </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Age of Kings</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous l'avons élargi, ce qui nous a permis de contrôler les paramètres de lancement et de fournir des rapports constants sur les statistiques. </font><font style="vertical-align: inherit;">Cela a permis aux joueurs de mieux trouver les jeux qui les intéressaient, car ils pouvaient voir les paramètres du niveau de matchmaking, et ne pas attendre que les paramètres du jeu s'affichent sur l'écran des paramètres du jeu. </font><font style="vertical-align: inherit;">Dans le backend, nous avons mis en place des statistiques de reporting et de suivi constantes. </font><font style="vertical-align: inherit;">Nous avons fourni à The Zone une structure commune qui a été remplie et transférée au serveur à la fin du jeu. </font><font style="vertical-align: inherit;">Les données de cette structure ont été utilisées pour créer des évaluations d'utilisateurs et les afficher sur le site Web de The Zone.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b89/ec7/ef8/b89ec7ef8b25272c8d6e35e6b1593f7d.jpg" alt="image"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Multijoueur RTS3: tâches </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RTS3 est le nom de code du jeu de stratégie de nouvelle génération Ensemble </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(environ Per: le jeu est sorti sous le nom Age of Mythology)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">La structure RTS3 est créée sur la base de la formule réussie utilisée dans la série de jeux Age of Empires, avec l'ajout de nombreuses nouvelles fonctionnalités et exigences pour le mode multi-utilisateurs.</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basé sur l'ensemble des fonctionnalités d' </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Age of Empires 1</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Exigences obligatoires telles que jouer sur Internet, des cartes grandes et variées, des milliers d'unités gérées.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3D: RTS3 est un jeu entièrement en trois dimensions avec des animations interpolées et des positions et des rotations d'unités non discrètes. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plus de joueurs - prise en charge de plus de huit joueurs. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Prise en charge TCP / IP: Notre objectif principal est une connexion Internet TCP / IP à 56 / kbps. </font></font></li><li>    —     ,      NAT. </li></ul><br>      RTS3         ,    <em>Age of Empires 1</em>  <em>2</em> —   —    RTS3       .  <em>AOE/AOK</em>         DirectPlay,   RTS3     ,        . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La transition vers un monde entièrement en trois dimensions signifie que nous devons être plus attentifs aux problèmes de fréquence d'images et de fluidité globale de la simulation en mode multi-utilisateur. Cependant, cela signifie également que le temps de mise à jour de la situation de simulation et la fréquence d'images seront encore plus sujets à la variabilité, et que nous devrons consacrer plus de temps au rendu. Dans le moteur Genie, les rotations des unités étaient discrètes et les animations étaient liées à la fréquence d'images dans BANG! une rotation d'unité arbitraire et une animation fluide sont possibles, c'est-à-dire que visuellement le jeu sera beaucoup plus sensible à l'influence des retards et des sauts dans la fréquence de mise à jour. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finaliser </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Age of Kings</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous voulions nous attaquer à ces domaines critiques où une conception réfléchie et l'utilisation d'outils réduiraient considérablement le temps de débogage. </font><font style="vertical-align: inherit;">Nous avons également réalisé à quel point le processus de test itératif est important dans la conception de nos jeux, une priorité élevée a donc été accordée à la conclusion la plus rapide possible du jeu en ligne.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Architecture de communication RTS3 </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/66a/92d/4a9/66a92d4a984730fcf03a9a392945afb7.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 6. Architecture réseau orientée objet stricte de RTS3. </font></font></i> <br><br> <strong><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Approche orientée objet. </font></font></em></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'architecture réseau de RTS3 est fortement orientée objet (voir figure 6). </font><font style="vertical-align: inherit;">Les exigences de prise en charge pour diverses configurations de réseau vous permettent de tirer parti de l'approche OO, abstraite des spécificités de la plate-forme, du protocole et de la topologie qui sous-tendent un ensemble d'objets et de systèmes généralisés.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les versions spécifiques au protocole et à la topologie des objets réseau contiennent le moins de code possible. La fonctionnalité principale de ces objets est abondante dans les objets parents de haut niveau. Pour implémenter le nouveau protocole, nous avons développé uniquement les objets réseau qui avaient besoin d'un code spécifique au protocole (par exemple, pour le client et la session, qui devraient agir légèrement différemment selon le protocole). Aucun autre objet système (tel que Channels, TimeSync, etc.) n'a nécessité de modifications, car ils n'avaient une interface avec le client et la session que via leurs interfaces abstraites de haut niveau. </font></font><br><br> <strong><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Topologie d'égal à égal.</font></font></em></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le moteur Genie prend en charge une topologie de réseau d'égal à égal dans laquelle tous les clients d'une session se connectent les uns aux autres dans une configuration en étoile. </font><font style="vertical-align: inherit;">Dans RTS3, nous avons continué à utiliser cette topologie, car lorsqu'elle est implémentée avec un modèle de simulation synchrone, elle présente des avantages inhérents. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La topologie d'égal à égal implique l'utilisation d'une configuration en étoile pour les clients connectés dans une session (figure 7). </font><font style="vertical-align: inherit;">Autrement dit, chaque client est connecté à tous les autres clients. </font><font style="vertical-align: inherit;">Le même schéma a été utilisé aux </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">âges 1</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f35/d91/d21/f35d91d21ae3a744d54db202a3710ed4.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 7. Configuration en étoile des clients homologues dans une session. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avantages de pair à pair:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Diminution de la latence due au schéma de messagerie client à client au lieu de client-serveur-client. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Il n'y a pas de lien faible central - si le client (même l'hôte) se déconnecte de la session, le jeu peut continuer. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inconvénients de pair à pair: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Composés plus actifs dans le système (somme de n = 0 à k-1 (n)), c'est-à-dire plus de maillons faibles potentiels et des retards probables plus élevés. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L'incapacité à prendre en charge certaines configurations NAT dans un tel schéma. </font></font></li></ul><br> <strong><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Net.lib.</font></font></em></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lors du développement de l'architecture d'échange de données RTS3, notre objectif était de créer un système spécialement conçu pour les jeux stratégiques, mais en même temps, nous voulions créer un système pouvant être utilisé pour nos outils internes, ainsi que de l'étendre pour prendre en charge les futurs jeux. Pour atteindre cet objectif, nous avons créé une architecture multicouche qui prend en charge les objets de niveau jeu tels que le client et la session, mais prend également en charge les objets de transport de bas niveau tels que les liens et les adresses réseau.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/abf/0cc/057/abf0cc057404cbf9c580d39155c9aff9.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 8. Quatre couches de services dans notre modèle de réseau.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> RTS3 est basé sur notre moteur BANG! une nouvelle génération qui utilise une architecture modulaire avec des bibliothèques de composants telles que le son, le rendu et la mise en réseau. Le sous-système réseau est intégré ici en tant que composant, mais est connecté au moteur BANG! (ainsi qu'avec divers outils internes). Notre modèle de réseau est divisé en quatre couches de service, qui ne sont pas, mais pas complètement, similaires au modèle de réseau OSI utilisé dans le jeu (voir la figure 8). </font></font><br><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chaussettes niveau 1</font></font></u> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le premier niveau, Socks, fournit une API fondamentale de niveau socket en C. Elle est abstraite pour créer un ensemble générique de procédures réseau de bas niveau pour de nombreux systèmes d'exploitation. L'interface ressemble à l'interface de socket Berkeley. La couche Socks est principalement utilisée par les couches supérieures de la bibliothèque réseau et n'est pas vraiment destinée à être utilisée par le code d'application. </font></font><br><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link, Level 2</font></font></u> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Level 2, Link, fournit des services de couche transport. Les objets à ce niveau, tels que Link, Listener, NetworkAddress et Packet, sont des éléments utiles nécessaires pour établir une connexion et envoyer des messages par-dessus (voir la figure 9).</font></font><br><br><ul><li> <strong>Packet ():</strong>      —  ,    / (    )     . </li><li> <strong>Link ():</strong>      .       ,           .  send  receive  ,    ,      void*. </li><li> <strong>Listener ():</strong>  .           . </li><li> <strong>Data stream ( ):</strong>        , , ,   . </li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Net Address:</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> entité d'adressage réseau indépendante du protocole.</font></font></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ping: Une</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> classe de ping simple. </font><font style="vertical-align: inherit;">Signale un retard de réseau présent lors de la communication avec la liaison.</font></font></li><li><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a4/8a3/f76/0a48a3f7672c524404eab911ebd7d062.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 9. Niveau de liaison.</font></font></i> </li></ul><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Niveau multijoueur 3</font></font></u> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le niveau multijoueur est le niveau le plus élevé d'objets et de procédures présents dans l'API net.lib. </font><font style="vertical-align: inherit;">Il s'agit de la couche avec laquelle RTS3 interagit lors de la collecte d'objets de niveau inférieur, tels que des liens et de leur conversion en concepts / objets plus utiles - clients, sessions, etc. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les objets les plus intéressants de la bibliothèque du réseau BANG! </font><font style="vertical-align: inherit;">sont ceux qui sont au niveau multijoueur. </font><font style="vertical-align: inherit;">Ici, l'API fournit un ensemble d'objets avec lesquels le niveau de jeu peut interagir, mais fournit une implémentation indépendante de l'approche du jeu.</font></font><br><br><ul><li> <strong>Client ():</strong>      .       ()     (  ).    ,    . </li><li> <strong>Session ():</strong>  ,   ,  ,    .       .        host()  join(),    ,   ,     .       / ,           . </li><li> <strong>Channel  Ordered Channel:</strong>        .              .      TimeSync,            . </li><li> <strong>Shared Data:</strong>        .        ,     ,                . </li><li> <strong>Time Sync:</strong>           . </li></ul><br> <u>Game Communications,  4</u> <br><br>      RTS3.    ,       ,     .               ,       ,    . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ac/d8a/f3b/0acd8af3b2f9d73984b7afda314f0e6e.jpg" alt="image"></div><br><h2>      </h2><br>  <strong><em>Système de synchronisation amélioré.</em></strong>  Aucune des équipes de développement d' <em>Age of Empires</em> n'a pu dire que nous n'avons pas besoin de meilleurs outils de synchronisation.  Comme dans tout projet, lors de l'analyse du processus de développement dans l'autopsie, il s'avère que la plupart du temps a été consacré à certains domaines, mais cela pourrait être beaucoup moins si nous les abordions à l'avance.  Au début du développement de RTS3, le débogage de la synchronisation était en tête de liste de ces domaines. <br><br>  Le système de suivi de synchronisation RTS3 vise principalement à reconnaître rapidement les bogues de synchronisation.  Les autres priorités étaient la simplification de l'utilisation, la capacité de traiter arbitrairement de grandes quantités de données synchronisées transmises par le système, la possibilité de compiler complètement le code de synchronisation dans la version finale, et enfin, la possibilité de changer complètement la configuration de test en changeant les variables au lieu de recompiler complètement. <br><br>  La vérification de la synchronisation dans RTS3 est effectuée à l'aide de deux ensembles de macros: <br><br> <code>#define syncRandCode(userinfo) <br> gSync-&gt;addCodeSync(cRandSync, userinfo, __FILE__, __LINE__) <br></code> <br><br> <code>#define syncRandData(userinfo, <br> v) gSync-&gt;addDataSync(cRandSync, v, userinfo, __FILE__, __LINE__)</code> <br> <br>  Ces deux macros reçoivent le paramètre de chaîne userinfo, qui est le nom ou l'indication d'un élément synchronisé spécifique.  Par exemple, un appel de synchronisation pourrait ressembler à ceci: <br><br> <code>syncRandCode("syncing the random seed", seed);</code> <br> <br>  <em><strong>Commandes de console synchrones et variables de configuration.</strong></em>  Comme tout développeur de mod <em>Quake</em> peut le confirmer, les commandes de la console et les variables de configuration sont très importantes pour le processus de développement.  Les commandes de la console sont de simples appels de fonction effectués à l'aide du fichier de configuration de lancement, de la console en jeu ou de l'interface utilisateur, qui invoquent des fonctionnalités de jeu arbitraires.  Les variables de configuration sont des types de données nommés fournis via les fonctions simples get, set, define et toggle, que nous utilisons pour toutes sortes de tests et de définition des paramètres de configuration. <br><br>  Paul a créé des versions compatibles multijoueurs de nos systèmes de commande de console et des configurations variables.  Avec leur aide, nous pouvons facilement transformer une variable de configuration régulière (par exemple, enableCheating) en une variable de configuration multijoueur en ajoutant un indicateur à la définition de la variable de configuration.  Si ce drapeau est activé, la variable de configuration est transférée dans le jeu multijoueur et les décisions synchronisées dans le jeu (par exemple, sur la possibilité de transfert gratuit de ressources) peuvent être basées sur sa valeur.  Les commandes de console du multijoueur ont un principe similaire - les appels aux commandes de console du multijoueur sont transmis sur le réseau et sont exécutés de manière synchrone sur toutes les machines clientes. <br><br>  En utilisant ces deux outils, les développeurs peuvent utiliser le système multijoueur sans écrire de code.  Ils peuvent rapidement ajouter de nouveaux outils de test et de configuration et les intégrer facilement dans un environnement en réseau. <br><br><h2>  Pour résumer </h2><br>  La simulation synchronisée et le modèle pair à pair ont été utilisés avec succès dans la série de jeux Age of Empires.  Malgré l'importance cruciale d'investir du temps dans la création d'outils et de technologies pour résoudre les principaux problèmes de cette approche (tels que la synchronisation et les métriques de réseau), la viabilité de cette architecture dans le genre de stratégies en temps réel a été prouvée par l'expérience.  Les améliorations ultérieures que nous avons apportées à RTS3 ont conduit au fait que le gameplay multijoueur est presque impossible à distinguer du mode solo, même dans les conditions les plus terribles de connexions réseau. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr417703/">https://habr.com/ru/post/fr417703/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr417689/index.html">Mobio s'entretient avec le PDG d'Appnext sur le marché du CPI et les tendances des applications mobiles</a></li>
<li><a href="../fr417691/index.html">Notre étagère est un programmeur C #. Et vous?</a></li>
<li><a href="../fr417697/index.html">Éditeur d'images simple sur VueJS</a></li>
<li><a href="../fr417699/index.html">Western Digital ferme une autre usine de disques durs en raison de la baisse de la demande</a></li>
<li><a href="../fr417701/index.html">Des scripts simples à l'application client-serveur à faire soi-même sur WCF: pourquoi j'aime travailler en CM</a></li>
<li><a href="../fr417705/index.html">Comment un fabricant de cartes graphiques affecte la rentabilité de l'exploitation de GPU</a></li>
<li><a href="../fr417707/index.html">CSS-in-JS - mythes et réalité (composants de style comme exemple)</a></li>
<li><a href="../fr417709/index.html">Où et comment les développeurs évaluent-ils leurs employeurs? Services d'évaluation d'entreprises dans le secteur informatique</a></li>
<li><a href="../fr417711/index.html">Que lire sur Swift en russe?</a></li>
<li><a href="../fr417715/index.html">Au revoir Google Maps</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>