<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍞 👩🏽‍🏫 🎋 Incorporación defectuosa de funciones en Go 👲🏿 💪🏿 👨🏼‍🎨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¿El código que se muestra a continuación es equivalente en rendimiento? 


// (A). HasPrefix . return strings.HasPrefix(s, "#") // (B). HasPrefix. ret...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Incorporación defectuosa de funciones en Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438636/"><p><img src="https://habrastorage.org/webt/lm/rt/rk/lmrtrkww5knurdsaznutrksterk.jpeg"></p><br><p>  ¿El código que se muestra a continuación es equivalente en rendimiento? </p><br><pre><code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// (A).  HasPrefix  . return strings.HasPrefix(s, "#") // (B).    HasPrefix. return len(s) &gt;= len("#") &amp;&amp; s[:len("#")] == "#"</span></span></code> </pre> <br><p>  La respuesta es <strong>no</strong> . </p><br><p>  Para detalles y explicaciones, pregunto bajo cat. </p><a name="habracut"></a><br><hr><br><p>  Buen día, antes de abrir el tema, me gustaría presentarme. <br>  Mi nombre es Iskander y de vez en cuando envío confirmaciones al repositorio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">golang / go</a> . </p><br><img src="https://habrastorage.org/webt/ls/jy/t3/lsjyt3z-jg1l5dx2nlecj17lbks.png" alt="imagen" align="left"><br><p>  Solía ​​hacer esto en nombre del equipo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Intel Go</a> , pero nuestros caminos divergieron y ahora soy un colaborador independiente.  Recientemente he estado trabajando en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">vk</a> en el equipo de infraestructura. </p><br><p>  En mi tiempo libre hago diferentes herramientas para Go, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">go-critical</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">go-consistente</a> .  También <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dibujo topos</a> . </p><br><p><br></p><br><h1 id="measure-it">  ¡Mídelo! </h1><br><p>  Proceda inmediatamente a la comparación y describa el punto de referencia: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> benchmark <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"strings"</span></span> <span class="hljs-string"><span class="hljs-string">"testing"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = <span class="hljs-string"><span class="hljs-string">"#string"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkHasPrefixCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { _ = strings.HasPrefix(s, <span class="hljs-string"><span class="hljs-string">"#"</span></span>) _ = strings.HasPrefix(s, <span class="hljs-string"><span class="hljs-string">"x"</span></span>) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkHasPrefixInlined</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { _ = <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(s) &gt;= <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(<span class="hljs-string"><span class="hljs-string">"#"</span></span>) &amp;&amp; s[:<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(<span class="hljs-string"><span class="hljs-string">"#"</span></span>)] == <span class="hljs-string"><span class="hljs-string">"#"</span></span> _ = <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(s) &gt;= <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(<span class="hljs-string"><span class="hljs-string">"x"</span></span>) &amp;&amp; s[:<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(<span class="hljs-string"><span class="hljs-string">"x"</span></span>)] == <span class="hljs-string"><span class="hljs-string">"x"</span></span> } }</code> </pre> <br><p>  En lugar de recomendarte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">benchstat</a> , te mostraré <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">benchrun</a> . </p><br><p>  Con un comando, podemos ejecutar ambos puntos de referencia y obtener una comparación: </p><br><pre> <code class="bash hljs">go-benchrun HasPrefixCall HasPrefixInlined -v -count=10 . Benchstat results: name old time/op new time/op delta HasPrefixCall-8 9.15ns ± 1% 0.36ns ± 3% -96.09% (p=0.000 n=10+9)</code> </pre> <br><p>  La opción con incrustación manual es mucho más rápida que el código que se obtuvo al incrustar el cuerpo de la función con el compilador.  Tratemos de descubrir por qué sucede esto. </p><br><h1 id="stringshasprefix">  strings.HasPrefix </h1><br><p>  Recordemos la implementación de <code>strings.HasPrefix</code> . <code>strings.HasPrefix</code> : </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// HasPrefix tests whether the string s begins with prefix. func HasPrefix(s, prefix string) bool { return len(s) &gt;= len(prefix) &amp;&amp; s[0:len(prefix)] == prefix }</span></span></code> </pre> <br><p>  La función <code>HasPrefix</code> integrada por el compilador. <br>  Puede verificar esto de la siguiente manera: </p><br><pre> <code class="bash hljs">go build -gcflags=<span class="hljs-string"><span class="hljs-string">'-m=2'</span></span> strings 2&gt;&amp;1 | grep <span class="hljs-string"><span class="hljs-string">'can inline HasPrefix'</span></span></code> </pre> <br><p>  Para llamar a <code>strings.HasPrefix</code> de la opción <code>(A)</code> obtenemos el siguiente código de máquina: </p><br><pre> <code class="plaintext hljs"> MOVQ (TLS), CX CMPQ SP, 16(CX) JLS more_stack fn_body: SUBQ $40, SP MOVQ BP, 32(SP) LEAQ 32(SP), BP XCHGL AX, AX MOVQ s+56(SP), AX CMPQ AX, $1 JGE compare_strings XORL AX, AX MOVB AL, ~ret1+64(SP) MOVQ 32(SP), BP ADDQ $40, SP return: RET compare_strings: MOVQ s+48(SP), AX MOVQ AX, (SP) LEAQ go.string."#"(SB), AX MOVQ AX, 8(SP) MOVQ $1, 16(SP) CALL runtime.memequal(SB) MOVBLZX 24(SP), AX JMP return more_stack: CALL runtime.morestack_noctxt(SB) JMP fn_body</code> </pre> <br><p>  Ignora el hecho de que el código parece fideos. </p><br><p>  A qué debe prestar atención: </p><br><ul><li>  <code>strings.HasPrefix</code> realmente se insertó, no hay llamada. </li><li>  Para comparar cadenas, se <code>runtime.memequal</code> . </li></ul><br><p>  Pero, ¿qué se genera entonces para la versión incorporada manualmente, el código del ejemplo <code>(B)</code> ? </p><br><pre> <code class="plaintext hljs"> MOVQ s+16(SP), AX CMPQ AX, $1 JLT different_length MOVQ s+8(SP), AX CMPB (AX), $35 // 35 -   "#" SETEQ AL return: MOVB AL, "".~ret1+24(SP) RET different_length: XORL AX, AX JMP 22</code> </pre> <br><p>  Y aquí el compilador no genera una llamada a <code>runtime.memequal</code> y se compara directamente un solo carácter.  Idealmente, debería haber hecho lo mismo para la primera opción. </p><br><p>  Observamos el lado débil del optimizador Go y lo analizaremos. </p><br><h1 id="optimizacii-konstantnyh-vyrazheniy">  Optimización de expresión constante </h1><br><p>  La razón por la que se pueden optimizar las <code>strings.HasPrefix(s, "#")</code> llamadas. <code>strings.HasPrefix(s, "#")</code> es porque el argumento prefijo es una constante.  Conocemos su longitud y contenido.  No tiene sentido llamar a <code>runtime.memequal</code> para cadenas cortas, es más rápido hacer una comparación de caracteres "en su lugar", evitando una llamada adicional. </p><br><p>  Como sabe, los compiladores generalmente tienen al menos dos partes: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">interfaz del</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">compilador</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">backend del compilador</a> .  El primero funciona con una vista de nivel superior, el segundo está más cerca de la máquina y la vista intermedia se verá como una secuencia de instrucciones.  Varias versiones de Go ya han utilizado la representación <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SSA</a> para optimizaciones en la parte del compilador del backend. </p><br><p>  El plegado constante, como <code>{10*2 =&gt; 20}</code> , se implementa en el backend.  En general, la mayoría de las operaciones asociadas con la reducción del costo computacional de las expresiones se encuentran en esta parte del compilador.  Pero hay excepciones. </p><br><p>  Una excepción es la optimización de las comparaciones de cadenas constantes.  Cuando el compilador ve una comparación de cadena (o subcadena) en la que uno o ambos operandos son constantes, se genera un código más eficiente que una llamada a <code>runtime.memequal</code> . </p><br><p>  Puede ver el código fuente responsable de esto en el archivo <a href="">cmd / compile / internal / gc / walk.go: 3362</a> . </p><br><p>  La incorporación de funciones ocurre antes de que se inicien estas optimizaciones, pero también en la parte frontend del compilador. </p><br><p>  ¿Parecería que de todos modos no permite que esta optimización funcione en nuestro caso? </p><br><h1 id="kak-go-vstraivaet-vyzovy-funkciy">  Cómo ir incrusta llamadas de función </h1><br><p>  Así es como ocurrirá la incrustación: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//    : return strings.HasPrefix(s, "#") //  : func HasPrefix(s, prefix string) bool //    : _s, _prefix := s, "#" return len(s) &gt;= len(prefix) &amp;&amp; s[:len(prefix)] == prefix</span></span></code> </pre> <br><p>  Al incorporar funciones, el compilador asigna argumentos a variables temporales, lo que rompe las optimizaciones, ya que el algoritmo en <a href="">walk.go</a> no ve constantes, sino argumentos con variables.  Ese es el problema </p><br><p>  Por cierto, esto no interfiere con las optimizaciones de backend que la SSA tiene a su disposición.  Pero hay otros problemas allí, por ejemplo, la incapacidad de restaurar construcciones de lenguaje de alto nivel para su comparación efectiva (el trabajo para eliminar este inconveniente ha sido "planificado" durante varios años). </p><br><h1 id="eschyo-odin-primer-escape-analysis">  Otro ejemplo: análisis de escape </h1><br><p>  Imagine una función que es importante para asignar un búfer temporal en la pila: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">businessLogic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { buf := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>) <span class="hljs-comment"><span class="hljs-comment">// buf    //    . return nil }</span></span></code> </pre> <br><p>  Como <code>buf</code> no se "escapa", el compilador podrá asignar estos 16 bytes en la pila, sin asignación en el montón.  Nuevamente, todo gracias al valor constante al llamar a <code>make</code> .  Para asignar memoria en la pila, es importante que sepamos el tamaño requerido, que formará parte del marco asignado a la llamada a la función. </p><br><p>  Supongamos que en el futuro quisiéramos asignar búferes temporales de diferentes tamaños y encapsular cierta lógica en los métodos.  Introdujimos una nueva abstracción y decidimos usar el nuevo tipo <code>tmpBuf</code> .  La función de diseño es extremadamente simple: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newTmpBuf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sizeHint </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmpBuf</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tmpBuf{buf: <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, sizeHint)} }</code> </pre> <br><p>  Adaptando el ejemplo original: </p><br><pre> <code class="diff hljs">func businessLogic() error { - buf := make([]byte, 0, 16) + buf := newTmpBuf(16) // buf    //    . return nil }</code> </pre> <br><p>  El constructor estará incrustado, pero la asignación ahora siempre estará en el montón, por la misma razón que los argumentos se pasan a través de variables temporales.  El análisis de escape verá <code>make([]byte, 0, _sizeHint)</code> que no cae dentro de sus patrones de reconocimiento para <code>make</code> llamadas optimizadas. </p><br><p>  Si tuviéramos "todo como personas", el problema no existiría, después de incorporar el <code>newTmpBuf</code> constructor <code>newTmpBuf</code> sería claro que el tamaño aún se conoce en la etapa de compilación. </p><br><p>  Esto molesta casi más que la situación al comparar cadenas. </p><br><h1 id="gorizonty-go-113">  Horizons Go 1.13 </h1><br><p>  La situación puede corregirse fácilmente y ya envié la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primera parte de la decisión</a> . </p><br><img src="https://habrastorage.org/webt/uv/gv/16/uvgv16e70jy6qdip9wju_vqzvog.png" alt="imagen" align="left"><br><p>  Si cree que el problema descrito en el artículo realmente necesita una solución, coloque un pulgar hacia arriba en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">problema correspondiente</a> . </p><br><p></p><hr><br><br><p>  Mi posición es que incrustar código con sus manos solo porque funciona más rápido en la versión actual de Go está mal.  Es necesario corregir este defecto en el optimizador, al menos hasta el punto en que los ejemplos descritos anteriormente funcionen sin regresiones de rendimiento inesperadas. </p><br><p>  Si todo va según lo planeado, esta optimización se incluirá en la versión Go 1.13. </p><br><p>  Gracias por su atencion </p><br><h1 id="dopolnenie-predlozhennoe-reshenie">  Adición: solución propuesta </h1><br><p>  Esta sección es para los más valientes, aquellos que no están cansados ​​de leer. </p><br><p>  Entonces, tenemos varios lugares que funcionan peor cuando se usan variables en lugar de sus valores directamente.  La solución propuesta es introducir una nueva función en la interfaz de la parte del compilador, que le permite obtener el último valor enlazado por nombre.  Después de eso, en cada optimización que espera un valor constante, no se rinda cuando se detecte una variable, sino que reciba este estado previamente guardado. </p><br><p>  La firma de nuestra nueva característica podría verse así: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getConstValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n *Node)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Node</span></span></span></span></code> </pre> <br><p>  La definición de <code>Node</code> se puede encontrar en el archivo <a href="">syntax.go</a> . </p><br><p>  Cada definición de variable tiene una etiqueta <code>Node</code> con una etiqueta <code>ONAME</code> .  Dentro de <code>Node.Name.Defn</code> mayoría de estas variables tienen un valor de inicialización. </p><br><p>  Si <code>Node</code> ya <code>Node</code> un literal, no necesita hacer nada y solo devolvemos <code>n</code> .  Si esto es <code>ONAME</code> (variable), puede intentar extraer el mismo valor de inicialización de <code>n.Name.Defn</code> . </p><br><p>  Pero, ¿qué pasa con las modificaciones entre declarar y leer una variable para la que llamamos <code>getConstValue</code> ?  Si nos limitamos a las variables de solo lectura, entonces no hay problema.  La interfaz de Go ya tiene indicadores de nodo especiales que marcan nombres similares.  Si la variable ha sido modificada, <code>getConstValue</code> no devolverá un valor de inicialización. </p><br><p>  Los programadores, como regla, no modifican los argumentos de entrada de los tipos numéricos y de cadena, y esto hace posible cubrir un número bastante grande de casos con este algoritmo primitivo. </p><br><p>  Ahora estamos listos para considerar la implementación: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getConstValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n *Node)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Node</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//    ONAME    definition. if n.Op != ONAME || n.Name.Defn == nil { return n } //   ,     . // ,    ,     //      escape analysis' . maybeModified := n.Assigned() || n.Name.Defn.Assigned() || n.Addrtaken() if maybeModified { return n } // OAS - Node  . // n.Name.Defn.Left -  LHS. // n.Name.Defn.Right -  RHS. // consttype(v)     . //   CTxxx,      . if n.Name.Defn.Op == OAS { v := n.Name.Defn.Right if v != nil &amp;&amp; consttype(v) != CTxxx { return v } } return n }</span></span></code> </pre> <br><p>  Así es como cambia el código, que depende de las constantes: </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">- i := indexconst(r) + i := indexconst(getConstValue(r))</span></span></code> </pre> <br><p>  Genial, e incluso funciona: </p><br><pre> <code class="go hljs">n := <span class="hljs-number"><span class="hljs-number">10</span></span> xs := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, n) <span class="hljs-comment"><span class="hljs-comment">//     !</span></span></code> </pre> <br><p>  Antes de este cambio, el análisis de escape no podía obtener el valor de <code>10</code> a <code>n</code> , razón por la cual asumí la necesidad de colocar <code>xs</code> en el montón. </p><br><p>  El código anterior es sintácticamente similar a la situación observada durante la incrustación.  <code>n</code> puede ser una variable temporal que se agrega cuando se pasa el argumento. </p><br><p>  Lamentablemente, hay matices. </p><br><p>  Resolvimos el problema para las variables locales introducidas a través de <a href="">OAS</a> , pero Go inicializa las variables para las funciones <a href="">integradas a</a> través de <a href="">OAS2</a> .  Debido a esto, necesitamos un segundo cambio que amplíe la función <code>getConstValue</code> y modifique ligeramente el código del inliner en sí, porque, entre otras cosas, <code>OAS2</code> no tiene un campo <code>Defn</code> adecuado. </p><br><p>  Eso fueron malas noticias.  Buenas noticias: el canal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">#gocontributing</a> apareció en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">holgura del idioma ruso</a> , donde puedes compartir tus ideas y planes, hacer preguntas y discutir todo lo relacionado con la participación en el desarrollo de Go. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/438636/">https://habr.com/ru/post/438636/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../438626/index.html">El resumen de materiales interesantes para el desarrollador móvil # 284 (28 de enero - 3 de febrero)</a></li>
<li><a href="../438628/index.html">Notificación de estado de cambio de componente de estado compartido</a></li>
<li><a href="../438630/index.html">Google+ Sic transit gloria mundi ...</a></li>
<li><a href="../438632/index.html">Hardcore 2D RPG Gamedev Diaries, vol.0 - INTRO, o "Cómo llegué aquí"</a></li>
<li><a href="../438634/index.html">En las oficinas, hace demasiado calor o demasiado frío: ¿hay una mejor manera de ajustar la temperatura?</a></li>
<li><a href="../438638/index.html">Analizamos el protocolo de mensajes de buscapersonas POCSAG, parte 2</a></li>
<li><a href="../438640/index.html">Moneda electrónica abierta de alta velocidad</a></li>
<li><a href="../438642/index.html">Los fundamentos de la programación reactiva con RxJS</a></li>
<li><a href="../438644/index.html">La seguridad de los algoritmos de aprendizaje automático. Protección y prueba de modelos con Python</a></li>
<li><a href="../438646/index.html">Acerca de la creación de imágenes estéreo económicas en los dedos (estereograma, anaglifo, estereoscopio)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>