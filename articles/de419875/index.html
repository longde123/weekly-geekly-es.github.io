<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÜí üôÜüèΩ üë®‚Äçüë®‚Äçüë¶ Noch einmal √ºber Verz√∂gerungen im Quellcode des FPGA-Projekts oder eine einfache Frage f√ºr ein Interview f√ºr einen FPGA-Entwicklerjob ‚ôÇÔ∏è üõÇ „ÄΩÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor einiger Zeit entstand w√§hrend einer Diskussion in Begleitung professioneller FPGA-Entwickler eine Diskussion √ºber das Bestehen eines Interviews. W...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Noch einmal √ºber Verz√∂gerungen im Quellcode des FPGA-Projekts oder eine einfache Frage f√ºr ein Interview f√ºr einen FPGA-Entwicklerjob</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419875/"><img src="https://habrastorage.org/webt/z6/f-/6r/z6f-6rzaupd6oxldcxbx5dkz0ew.png"><br><br>  Vor einiger Zeit entstand w√§hrend einer Diskussion in Begleitung professioneller FPGA-Entwickler eine Diskussion √ºber das Bestehen eines Interviews.  Welche Fragen werden dort gestellt und was k√∂nnte gestellt werden?  Ich schlug zwei Fragen vor: <br><br><ol><li>  Geben Sie ein Beispiel f√ºr einen synchronen Code ohne Verz√∂gerungen, der beim Modellieren und Arbeiten in realen Ger√§ten zu unterschiedlichen Ergebnissen f√ºhrt </li><li>  Korrigieren Sie diesen Code mit Verz√∂gerungen. </li></ol><br>  Nach dieser Frage folgte eine lebhafte Diskussion, weshalb ich mich entschied, dieses Thema genauer zu betrachten. <br><a name="habracut"></a><br>  Ich habe dieses Problem bereits im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Artikel</a> ein wenig angesprochen.  Jetzt genauer.  Hier ist ein Beispieltext: <br><br><pre><code class="vhdl hljs"><span class="hljs-keyword"><span class="hljs-keyword">library</span></span> IEEE; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> IEEE.STD_LOGIC_1164.<span class="hljs-keyword"><span class="hljs-keyword">all</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">entity</span></span> delta_delay <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> delta_delay; <span class="hljs-keyword"><span class="hljs-keyword">architecture</span></span> delta_delay <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> delta_delay <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">signal</span></span> clk1 : <span class="hljs-built_in"><span class="hljs-built_in">std_logic</span></span>:=<span class="hljs-string"><span class="hljs-string">'0'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">signal</span></span> clk2 : <span class="hljs-built_in"><span class="hljs-built_in">std_logic</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> clk3 : <span class="hljs-built_in"><span class="hljs-built_in">std_logic</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> clk1; <span class="hljs-comment"><span class="hljs-comment">--    clk1 signal a : std_logic; signal b : std_logic; signal c : std_logic; signal d : std_logic; begin ---    --- clk1 &lt;= not clk1 after 5 ns; pr_a: process begin a &lt;= '0' after 1 ns; wait until rising_edge( clk1 ); wait until rising_edge( clk1 ); a &lt;= '1' after 1 ns; wait until rising_edge( clk1 ); wait until rising_edge( clk1 ); wait until rising_edge( clk1 ); wait until rising_edge( clk1 ); end process; ---   -    --- clk2 &lt;= clk1; --    ,        ---  1 -     --- b &lt;= a when rising_edge( clk1 ); c &lt;= b when rising_edge( clk1 ); d &lt;= b when rising_edge( clk2 ); ---  2 -     --- -- --clk2 &lt;= clk1; --b &lt;= a after 1 ns when rising_edge( clk1 ); --c &lt;= b after 1 ns when rising_edge( clk1 ); --d &lt;= b after 1 ns when rising_edge( clk2 ); ---  3 -          alias --- --b &lt;= a when rising_edge( clk1 ); --c &lt;= b when rising_edge( clk1 ); --d &lt;= b when rising_edge( clk3 ); end delta_delay;</span></span></code> </pre> <br>  Der Einfachheit halber wird der gesamte Code in einer Komponente platziert. <br><br>  Die Signale <b>clk1</b> und <b>a</b> sind <b>Testbelichtungssignale</b> .  <b>clk1</b> ist eine Taktfrequenz von 100 MHz, Signal <b>a</b> h√§lt zwei Taktzyklen bei 0 und vier Taktzyklen bei 1. Das Signal <b>a</b> wird mit einer Verz√∂gerung von 1 nc relativ zur ansteigenden Flanke von <b>clk1 erzeugt</b> .  Diese beiden Signale reichen aus, um das Problem zu beschreiben. <br><br>  Verschiedene synthetisierte Codeoptionen k√∂nnen unkommentiert und modelliert werden. <br>  Betrachten Sie die erste Option, dies ist ein synthetisierter Code ohne Verz√∂gerung und unter Verwendung der Neuzuweisung der Taktfrequenz. <br><br>  Hier sind die Simulationsergebnisse f√ºr Option 1: <br><br><img src="https://habrastorage.org/webt/34/ew/l_/34ewl_wuqjudvf6ehn6gw5cf164.png"><br><br>  Das Diagramm zeigt visuell, dass die Taktsignale <b>clk1</b> und <b>clk2</b> zusammenfallen, aber tats√§chlich ist <b>clk2</b> relativ zu <b>clk1</b> um den Wert der Delta-Verz√∂gerung verz√∂gert.  Das Signal <b>c</b> verz√∂gert das Signal <b>b</b> um einen Taktzyklus.  Das ist richtig.  Das Signal <b>d</b> muss jedoch mit dem Signal <b>c</b> √ºbereinstimmen, dies geschieht jedoch nicht.  Es funktioniert fr√ºher. <br><br>  Erinnern wir uns, was Delta-Verz√∂gerung ist.  Dies ist ein grundlegendes Konzept, das auf der Arbeit von Ereignissimulatoren basiert, die wir bei der Modellierung von Logikschaltungen verwenden. <br><br>  Der Simulator hat das Konzept der Modellzeit.  Alle Ereignisse im System sind an diese Modellzeit gebunden.  Schauen wir uns die Bildung der Taktfrequenz an: <br><br><pre> <code class="vhdl hljs">clk1 &lt;= <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> clk1 <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> ns;</code> </pre> <br>  Angenommen, wir modellieren jetzt nur <b>clk1</b> , es gibt keine anderen Signale. <br>  Zum anf√§nglichen Zeitpunkt ist <b>clk1</b> 0, dies wird gesetzt, wenn das Signal deklariert wird.  Der Simulator sieht eine Anforderung zum Invertieren des Signals.  Das Schl√ºsselwort after enth√§lt Anweisungen zum Zuweisen eines neuen Werts in 5 ns relativ zur aktuellen Modellzeit.  Der Simulator sieht dies und notiert, dass zum Zeitpunkt 5 ns der Wert von <b>clk1 1 sein</b> wird. Dies ist zwar eine Modellzukunft, kann sich aber √ºbrigens noch √§ndern.  Als n√§chstes scannt der Simulator die verbleibenden Signale.  Der Simulator sieht, dass f√ºr einen bestimmten Moment in der Modellzeit alles erledigt ist und er den n√§chsten Moment berechnen kann.  Es stellt sich die Frage: Was ist der n√§chste Moment?  Grunds√§tzlich sind verschiedene Optionen m√∂glich.  Zum Beispiel hat Simulink einen Modus mit fester Tonh√∂he.  In diesem Fall erh√∂ht sich die Modellzeit um einen gewissen Betrag und die Berechnungen werden fortgesetzt. <br><br>  Digitale Schaltungssimulationssysteme machen das anders.  Sie fahren mit dem n√§chsten Ereignis fort, das sie bereits in Zukunft auf ihrer Achse der Modellzeit platziert haben.  In diesem Fall sind es 5 ns.  Der Simulator <b>erkennt,</b> dass sich <b>clk1</b> ge√§ndert hat, und berechnet einen neuen Wert daf√ºr. Er ist 0, der ebenfalls mit einer Verz√∂gerung von 5 ns auf der Zeitachse platziert wird.  Das hei√üt,  es wird 10 ns sein.  Der Vorgang wird also fortgesetzt, bis die angegebene Simulationszeit endet. <br><br>  F√ºgen wir nun die Signale <b>a</b> und <b>b hinzu</b> . <br><br>  Das Signal <b>a</b> wird dabei zugewiesen.  F√ºr Signal <b>b</b> wird die bedingte Konstruktion verwendet;  Die Funktion running_edge ( <b>clk1</b> ) analysiert <b>clk1</b> und gibt <b>true</b> zur√ºck <b>,</b> wenn die Front fest ist, d. H.  Der vorherige Wert ist 0 und der aktuelle Wert ist 1. <br><br>  Zur <b>Modellzeit von</b> 5 ns <b>√§ndert</b> sich <b>clk1</b> .  Es wird gleich 1 und f√ºr den Moment von 10 ns wird ein Ereignis erstellt, bei dem es auf 0 gesetzt wird. Dies ist jedoch sp√§ter.  W√§hrend wir uns noch im Moment von 5 ns befinden, setzen wir die Berechnungen fort.  Der Simulator geht zur Leitung <pre> <code class="vhdl hljs">b&lt;=a <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> rising_edge(clk1);</code> </pre>  Da es eine Funktion gibt, die von <b>clk1</b> abh√§ngt <b>,</b> berechnet der Simulator den Wert der Funktion, stellt fest, dass sie true zur√ºckgibt, und weist sie zu <pre> <code class="vhdl hljs">b&lt;=a;</code> </pre> <br><br>  Hier beginnt der interessanteste Teil - wenn es notwendig ist, den Wert von <b>b</b> zu √§ndern.  Es scheint notwendig, es jetzt zu diesem Zeitpunkt zu √§ndern.  Wir haben aber parallele Prozesse.  Vielleicht brauchen wir noch den Wert von <b>b</b> , um andere Signale zu berechnen.  Und hier kommt das Konzept der Delta-Verz√∂gerung.  Dies ist der Mindestwert, um den sich die Modellzeit verschiebt.  Dieser Wert hat nicht einmal die Dimension der Zeit.  Dies ist nur ein Delta.  Aber es kann viele von ihnen geben.  Und so sehr, dass der Simulator einfach versehentlich anh√§lt oder einfriert. <br>  Daher wird f√ºr den Moment 5 ns + 1 ein neuer Wert von <b>b</b> eingestellt (1 ist die erste Delta-Verz√∂gerung).  Der Simulator sieht, dass f√ºr den Moment 5 ns bereits nichts zu berechnen ist, und geht zum n√§chsten Moment √ºber, und dies ist 5 ns + 1;  In diesem Moment funktioniert Rising_edge (ckl1) nicht.  Und der Wert von b wird auf 1 gesetzt. Danach geht der Simulator auf den Moment 10 nc. <br><br>  F√ºgen wir nun die Signale <b>c</b> , <b>d hinzu</b> und sehen, warum sie unterschiedlich sind. <br>  Es ist am besten, den Moment der Modellzeit von 25 ns unter Ber√ºcksichtigung von Delta-Verz√∂gerungen zu ber√ºcksichtigen <br><br><table><tbody><tr><th>  Delta </th><th>  clk1 </th><th>  clk2 </th><th>  re (clk1) </th><th>  re (clk2) </th><th>  b </th><th>  c </th><th>  d </th></tr><tr><th>  0 </th><th>  1 </th><th>  0 </th><th>  wahr </th><th>  falsch </th><th>  0 </th><th>  0 </th><th>  0 </th></tr><tr><th>  1 </th><th>  1 </th><th>  1 </th><th>  falsch </th><th>  wahr </th><th>  1 </th><th>  0 </th><th>  0 </th></tr><tr><th>  2 </th><th>  1 </th><th>  0 </th><th>  falsch </th><th>  falsch </th><th>  1 </th><th>  0 </th><th>  1 </th></tr></tbody></table><br>  Hinweis: Re-Rising_edge <br><br>  Die Tabelle zeigt, dass zum Zeitpunkt des Ausl√∂sens der Funktion ascend_edge ( <b>clk2</b> ) der Wert von <b>b</b> bereits 1 ist. Daher wird er dem Signal <b>d</b> zugewiesen. <br><br>  Basierend auf dem gesunden Menschenverstand ist dies nicht das Verhalten, das wir vom Code erwartet haben.  Schlie√ülich haben wir einfach das Signal <b>clk1</b> zu <b>clk2</b> neu <b>zugewiesen</b> und erwartet, dass die Signale <b>c</b> und <b>d</b> gleich sind.  Nach der Logik des Simulators ist dies jedoch nicht der Fall.  Dies ist eine <b>PRINCIPAL-</b> Funktion.  Diese Funktion muss den Entwicklern von FPGA-Projekten nat√ºrlich bekannt sein, daher ist dies eine gute und notwendige Frage f√ºr ein Interview. <br><br>  Was wird w√§hrend der Synthese passieren?  Aber der Synthesizer wird dem gesunden Menschenverstand folgen, er wird die Signale <b>clk2</b> und <b>clk1 zu</b> einem Signal machen und daher werden auch <b>c</b> und <b>d</b> gleich sein.  Und mit bestimmten Synthesizer-Einstellungen werden sie auch zu einem Signal kombiniert. <br><br>  Dies ist nur dann der Fall, wenn das Modellieren und Arbeiten in realen Ger√§ten zu unterschiedlichen Ergebnissen f√ºhrt.  Ich m√∂chte darauf hinweisen, dass der Grund f√ºr die unterschiedlichen Ergebnisse die unterschiedliche Logik von Simulator und Synthesizer ist.  Dies ist ein grundlegender Unterschied.  Dies hat nichts mit zeitlichen Einschr√§nkungen zu tun.  Und wenn Ihr Projekt im Modell und im B√ºgeleisen unterschiedliche Ergebnisse zeigt, √ºberpr√ºfen Sie, ob sich dort m√∂glicherweise ein solches Design eingeschlichen hat <br><br><pre> <code class="vhdl hljs">clk2 &lt;= clk1</code> </pre> <br>  Die zweite Frage besteht nun darin, diesen Code mit Verz√∂gerungen zu beheben. <br>  Dies ist Option 2. Sie kann unkommentiert und modelliert werden. <br>  Hier ist das Ergebnis. <br><br><img src="https://habrastorage.org/webt/vu/4z/t0/vu4zt0pe3gxnpav3vje3kwoi_ye.png"><br><br>  Das Ergebnis ist korrekt.  Was ist passiert?  Lassen Sie uns noch einmal eine Tabelle f√ºr ein Intervall von 25 - 36 ns erstellen <br><table><tbody><tr><th>  Zeit </th><th>  Delta </th><th>  clk1 </th><th>  clk2 </th><th>  re (clk1) </th><th>  re (clk2) </th><th>  b </th><th>  c </th><th>  d </th></tr><tr><th>  25 </th><th>  0 </th><th>  1 </th><th>  0 </th><th>  wahr </th><th>  falsch </th><th>  0 </th><th>  0 </th><th>  0 </th></tr><tr><th>  25 </th><th>  1 </th><th>  1 </th><th>  1 </th><th>  falsch </th><th>  wahr </th><th>  0 </th><th>  0 </th><th>  0 </th></tr><tr><th>  26 </th><th>  0 </th><th>  1 </th><th>  1 </th><th>  falsch </th><th>  falsch </th><th>  1 </th><th>  0 </th><th>  0 </th></tr><tr><th>  35 </th><th>  0 </th><th>  1 </th><th>  0 </th><th>  wahr </th><th>  falsch </th><th>  1 </th><th>  0 </th><th>  0 </th></tr><tr><th>  35 </th><th>  1 </th><th>  1 </th><th>  1 </th><th>  falsch </th><th>  wahr </th><th>  1 </th><th>  0 </th><th>  0 </th></tr><tr><th>  36 </th><th>  0 </th><th>  1 </th><th>  1 </th><th>  falsch </th><th>  falsch </th><th>  1 </th><th>  1 </th><th>  1 </th></tr></tbody></table><br>  Es ist ersichtlich, dass sich der Wert von <b>b</b> in den Momenten der Fronten <b>clk1</b> , <b>clk2</b> nicht √§ndert.  Eine Verz√∂gerung von 1 ns dauert in dem Moment, in dem sich das Signal √ºber die Flankenantwortzone hinaus √§ndert.  Dieser Code kommt der Realit√§t n√§her.  In einer realen Schaltung gibt es einige Zeit, bis der Trigger ausgel√∂st wird und sich das Signal ausbreitet.  Diese Zeit sollte k√ºrzer sein als die Periode der Taktfrequenz. Tats√§chlich ist dies das, was der Tracer tut, und dies ist, was die Zeitanalyse √ºberpr√ºft. <br><br>  Die Fehlerursache ist die Neuzuweisung des Taktsignals durch die √ºbliche Zuordnung, bei der eine Delta-Verz√∂gerung auftritt.  Die VHDL-Sprache verf√ºgt jedoch √ºber ein Alias-Konstrukt.  Auf diese Weise k√∂nnen Sie einen anderen Namen f√ºr das Signal erhalten.  Hier ist die Ank√ºndigung: <br><br><pre> <code class="vhdl hljs"><span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> clk3 : <span class="hljs-built_in"><span class="hljs-built_in">std_logic</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> clk1;</code> </pre> <br>  Im Beispieltext k√∂nnen Sie Option 3 auskommentieren - sie funktioniert ordnungsgem√§√ü. <br><br>  Dieses Beispiel ist in VHDL geschrieben.  Vielleicht ist das nur das Problem dieser Sprache?  Aber hier sind die gleichen Optionen in Verilog. <br><br><div class="spoiler">  <b class="spoiler_title">Versteckter Text</b> <div class="spoiler_text"><pre> <code class="hljs delphi">`timescale <span class="hljs-number"><span class="hljs-number">1</span></span> ns / <span class="hljs-number"><span class="hljs-number">1</span></span> ps module delta_delay_2 (); reg clk1 = <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">'b0; reg clk2; wire clk3; reg a = 1'</span></span>b0; reg b; reg c; reg d; initial <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> forever clk1 = <span class="hljs-string"><span class="hljs-string">#5</span></span> ~clk1; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> initial <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">repeat</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-string"><span class="hljs-string">#20</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">'b1; #60 a = 1'</span></span>b0; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-comment"><span class="hljs-comment">//   -    --- always @(clk1) clk2 &lt;= clk1; //  1 -     always @(posedge clk2) d &lt;= b; always @(posedge clk1) begin c &lt;= b; b &lt;= a; end //  2 -     //always @(posedge clk1) b = #1 a; // //always @(posedge clk1) c = #1 b; // //always @(posedge clk2) d = #1 b; //  3 -     //      assign //assign clk3 = clk1; // //always @(posedge clk3) d &lt;= b; // //always @(posedge clk1) //begin // c &lt;= b; // b &lt;= a; //end endmodule</span></span></code> </pre><br><br></div></div><br><ul><li>  Option 1 - keine Verz√∂gerung.  Es funktioniert nicht richtig. </li><li>  Option 2 - mit Verz√∂gerungen.  Es funktioniert richtig. </li><li>  Option 3 - Neuzuweisung per Kabel.  Es funktioniert richtig. </li></ul><br>  Verilog hat das Konzept von reg und wire.  In diesem Fall sieht die Neuzuweisung des Taktsignals √ºber Draht nat√ºrlicher aus.  Dies ist analog zu einer Aliaszuweisung in VHDL.  Dies entlastet das Problem etwas, aber Sie m√ºssen dies noch wissen. <br>  Verilog hat auch das Konzept der blockierenden und nicht blockierenden Zuweisung.  Die Signalzuordnung <b>b</b> und <b>c</b> kann auf andere Weise geschrieben werden: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">always</span></span> @(posedge clk1) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> c = b; b = a; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Und Sie k√∂nnen dies tun: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">always</span></span> @(posedge clk1) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> b = a; c = b; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Abh√§ngig von der Reihenfolge der Zeilen ist das Ergebnis unterschiedlich. <br><br>  Um auf das Thema des Interviews zur√ºckzukommen, m√∂chte ich noch einmal betonen, dass diese Fragen dazu dienen, das Wesentliche des Problems zu verstehen.  Und aus dem Verst√§ndnis des Problems kann man verschiedene Schlussfolgerungen ziehen, zum Beispiel, welcher Codestil verwendet werden soll.  Pers√∂nlich verwende ich immer die Verz√∂gerungszuweisung. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispieldateien finden Sie hier.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de419875/">https://habr.com/ru/post/de419875/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de419865/index.html">So schreiben Sie versehentlich eine Web-GUI f√ºr Haproxy</a></li>
<li><a href="../de419867/index.html">Sechs weitere Mythen √ºber die Blockchain, wo sie noch angewendet wird</a></li>
<li><a href="../de419869/index.html">Die KI-Revolution wird nicht von Droiden, sondern von Toastern durchgef√ºhrt</a></li>
<li><a href="../de419871/index.html">Wie Google versucht, eine zensierte Suchmaschine f√ºr China zu entwickeln</a></li>
<li><a href="../de419873/index.html">Testen nur mit √∂ffentlichen Methoden ist schlecht</a></li>
<li><a href="../de419877/index.html">Wie wir wieder ‚ÄûSmart Home‚Äú erfunden haben</a></li>
<li><a href="../de419879/index.html">PWA ist einfach. Hallo Joomla</a></li>
<li><a href="../de419883/index.html">Holen Sie sich den Unterschied zwischen Bin√§rdateien mit vcdiff</a></li>
<li><a href="../de419885/index.html">√úbersetzung von Andrew Un's Buch, Leidenschaft f√ºr maschinelles Lernen, Kapitel 15-19</a></li>
<li><a href="../de419893/index.html">So f√ºhren Sie Benutzersuchen auf Github mit VanillaJS durch</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>