<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍦 🤽🏻 🚵🏻 Écriture du proxy inverse Grafana sur Go 🚧 👨🏿‍💻 🤱</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je voulais vraiment nommer l'article «Proxy-service on Go en 3 lignes», mais je suis au-dessus. 


 En fait, c'est que la logique principale peut teni...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Écriture du proxy inverse Grafana sur Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ispsystem/blog/480446/"><p><img src="https://habrastorage.org/webt/u_/7z/hb/u_7zhbnc2fqmavgkimjqnbt_mcy.png"></p><br><p>  Je voulais vraiment nommer l'article «Proxy-service on Go en 3 lignes», mais je suis au-dessus. </p><br><p>  En fait, c'est que la logique principale peut tenir sur trois lignes.  Pour les impatients et ceux qui veulent voir l'essence: </p><br><pre><code class="go hljs">proxy := httputil.NewSingleHostReverseProxy(url) r.Header.Set(header, value) proxy.ServeHTTP(w, r)</code> </pre> <br><p>  Under the cat est une histoire plus détaillée pour les nouveaux arrivants dans la langue Golang et ceux qui ont besoin de créer un proxy inverse dans les plus brefs délais. </p><br><p>  Voyons pourquoi un service proxy est nécessaire, comment l'implémenter et ce qui se trouve sous le capot de la bibliothèque standard. </p><a name="habracut"></a><br><h2 id="obratnyy-proksi">  Proxy inverse </h2><br><p>  <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D0%25B1%25D1%2580%25D0%25B0%25D1%2582%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25BA%25D1%2581%25D0%25B8">Un</a> proxy inverse est un type de serveur proxy qui reçoit une demande d'un client, la redirige vers un ou plusieurs serveurs et retransmet la réponse. </p><br><p>  Une caractéristique distinctive du proxy inverse est qu'il est le point d'entrée pour connecter l'utilisateur aux serveurs avec lesquels le proxy lui-même est connecté par la logique métier.  Il détermine vers quels serveurs la demande du client sera envoyée.  La logique de construction d'un réseau derrière le proxy reste cachée à l'utilisateur. </p><br><p><img src="https://habrastorage.org/webt/gr/v7/h0/grv7h0y6ednzlip-31n2bvvmdti.png"><br>  <em>Proxy inverse</em> </p><br><p>  À titre de comparaison, un proxy ordinaire connecte ses clients à n'importe quel serveur dont ils ont besoin.  Dans ce cas, le proxy est devant l'utilisateur et n'est qu'un intermédiaire dans l'exécution de la demande. </p><br><p><img src="https://habrastorage.org/webt/ts/in/_m/tsin_mlkn8_o_yxo_4eb3mmnht4.png"><br>  <em>Proxy normal (proxy direct)</em> </p><br><p>  <strong>Pourquoi utiliser</strong> <br>  Le concept de proxy inverse peut être appliqué dans diverses situations: <br>  - équilibrage de charge, <br>  - Tests A / B <br>  - mise en cache des ressources, <br>  - compression des données de demande, <br>  - filtrage du trafic, <br>  - autorisation. </p><br><p>  Bien entendu, la portée ne se limite pas à ces six points.  Le fait de la possibilité de traiter la demande avant et après procuration donne beaucoup de place à la créativité.  Dans cet article, nous discuterons de l'utilisation du proxy inverse pour l'autorisation. </p><br><h2 id="zadacha">  Défi </h2><br><p>  Nous développons un panneau de contrôle de virtualisation VMmanager 6. Un beau jour, nous avons décidé de donner aux utilisateurs plus de liberté dans la surveillance et la visualisation de ces clusters.  À ces fins, ils ont choisi <a href="https://grafana.com/">Grafana</a> . </p><br><p>  Pour que Grafana fonctionne avec nos données, il a fallu configurer l'autorisation.  Ce n'est pas difficile à faire, sinon pour trois «mais». </p><br><ol><li>  Nous avons déjà un point d'entrée unique - un service d'autorisation. </li><li>  Nous ne voulons pas démarrer et autoriser des utilisateurs dans Grafana. </li><li>  Nous ne voulons pas donner aux utilisateurs un accès direct à Grafana. </li></ol><br><p>  Pour respecter les conditions, nous avons décidé de mettre Grafana sur le réseau interne et d'écrire un proxy inverse.  Il vérifiera les droits dans le service d'autorisation et ce n'est qu'après avoir transféré la demande à Grafana. </p><br><h2 id="ideya">  Idée </h2><br><p>  L'idée principale est de transférer la responsabilité de l'autorisation dans Grafana au serveur proxy inverse ( <a href="https://grafana.com/docs/auth/auth-proxy/">documentation officielle</a> ).  Grafana acceptera toute demande autorisée si elle contient un en-tête spécifique.  Avant de remplacer cette rubrique, nous devons nous assurer que l'utilisateur actuel a le droit de travailler avec Grafana. </p><br><p><img src="https://habrastorage.org/webt/ug/2e/ty/ug2etyp6pa5pz0j7batplzwjmbm.png"><br>  <em>Chaîne d'appels "Grafana-proxy, ou aller-retour"</em> </p><br><h2 id="realizaciya">  Implémentation </h2><br><p>  La fonction principale est assez standard.  Nous démarrons le serveur http, qui acceptera les connexions sur le port 4000 et traitera toute adresse «/» avec laquelle la connexion aura lieu. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, handlerProxy) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":4000"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } }</code> </pre> <br><p>  La majeure partie du travail se produit dans le gestionnaire de demandes. </p><br><div class="spoiler">  <b class="spoiler_title">[code complet sous coupe]</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handlerProxy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { fmt.Println(r.URL.Host) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> strings.HasPrefix(r.URL.String(), <span class="hljs-string"><span class="hljs-string">"/api"</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//     } url, err := url.Parse(fmt.Sprintf("http://%s/", grafanaHost)) if err != nil { SendJSONError(w, err.Error()) return } proxy := httputil.NewSingleHostReverseProxy(url) fmt.Println(r.URL.Host) r.Header.Set(grafanaHeader, grafanaUser) proxy.ServeHTTP(w, r) }</span></span></code> </pre> </div></div><br><p>  Passons en revue les paramètres.  Les principales variables de l'exemple que je mets en constantes: </p><br><pre> <code class="go hljs">grafanaUser = <span class="hljs-string"><span class="hljs-string">"admin"</span></span> <span class="hljs-comment"><span class="hljs-comment">//,      grafanaHost = "grafana:3000" //  grafana grafanaHeader = "X-GRAFANA-AUTH" //Header,     </span></span></code> </pre> <br><p>  Par exemple, cela suffit; en pratique, vous devrez peut-être prédéfinir ces valeurs.  Vous pouvez leur passer des proxys en tant que paramètres de ligne de commande, puis utiliser des <a href="https://golang.org/pkg/flag/">indicateurs</a> ou des packages plus avancés pour les analyser.  L'environnement de conteneur utilise également souvent des variables d'environnement pour configurer les services, <a href="https://gobyexample.com/environment-variables">os.Getenv</a> vous aidera tout au long du processus. </p><br><p>  Vient ensuite le contrôle d'autorisation: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> strings.HasPrefix(r.URL.String(), <span class="hljs-string"><span class="hljs-string">"/api"</span></span>) { err := CheckRights(r.Header) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { SendJSONError(w, err.Error()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } }</code> </pre> <br><p>  Si la demande est envoyée à grafana.host/api, nous vérifions les droits de l'utilisateur actuel à utiliser Grafana.  La vérification est nécessaire pour que pour chaque requête GET d'un script JS ou d'une icône PNG ne dérange pas le point d'autorisation.  Nous procurons des contenus statiques sans vérification supplémentaire.  Pour ce faire, nous transmettons la carte avec les en-têtes qui contiennent la session utilisateur au service d'autorisation.  Cela peut être une demande GET régulière.  Le dispositif de service d'autorisation n'a pas d'importance ici.  Si les données d'autorisation ne conviennent pas, fermez la connexion en renvoyant une erreur. </p><br><p>  Après les vérifications, nous formons l'objet du chemin de base: </p><br><pre> <code class="go hljs">url, err := url.Parse(fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"http://%s/"</span></span>, grafanaHost))</code> </pre> <br><p>  En utilisant le package <a href="httputil/">httputil</a> standard, qui étend le package http, nous formons l'objet ReverseProxy. </p><br><pre> <code class="go hljs">proxy := httputil.NewSingleHostReverseProxy(url)</code> </pre> <br><p>  ReverseProxy est un gestionnaire de demandes qui acceptera une demande entrante, l'enverra à Grafana et transmettra la réponse au client. </p><br><p>  Il transmettra toutes les demandes à l'adresse «chemin de base + URL demandée».  Si l'utilisateur est arrivé à l'adresse proxy: 4000 / api / quelque chose, sa demande sera transformée en grafana: 3000 / api / quelque chose, où <em>grafana: 3000</em> est le chemin de base transmis à NewSingleHostReverseProxy et <em>/ api / quelque chose</em> est la demande entrante. </p><br><p>  Ajoutez l'en-tête d'autorisation pour Grafana et appelez la méthode ServeHTTP, qui effectuera l'essentiel du traitement des demandes. </p><br><pre> <code class="go hljs">r.Header.Set(grafanaHeader, grafanaUser) proxy.ServeHTTP(w, r)</code> </pre> <br><p>  Sous le capot, ServeHTTP fait un peu de travail, par exemple, traite l'en-tête X-Forwarded-For ou la réponse du serveur 101 à un changement de protocole.  Le travail principal de la méthode consiste à envoyer une demande à une adresse composite et à transférer la réponse reçue à ResponseWriter. </p><br><p><img src="https://habrastorage.org/webt/xv/wd/1m/xvwd1mvdn4fomd2s9kjw6iev4ws.png"><br>  <em>Résultat</em> </p><br><p>  Tout le code <a href="https://github.com/460s/grafana_proxy">est disponible sur github</a> . </p><br><h1 id="proverka">  Vérifier </h1><br><p>  Émulez notre système à l'aide de Docker.  Créons deux conteneurs - proxy et Grafana dans un même réseau.  Nous ne créerons pas de point d'autorisation, nous pensons qu'il répond toujours par l'affirmative.  Le conteneur Grafana ne sera pas disponible hors ligne, le conteneur proxy est disponible sur un port spécifique. </p><br><p>  Créez un réseau: </p><br><pre> <code class="bash hljs">docker network create --driver=bridge --subnet=192.168.0.0/16 gnet</code> </pre> <br><p>  Soulevez le conteneur Grafana avec le mode d'autorisation configuré via l'en-tête: </p><br><pre> <code class="bash hljs">docker run -d --name=grafana --network=gnet -e <span class="hljs-string"><span class="hljs-string">"GF_AUTH_PROXY_ENABLED=true"</span></span> -e <span class="hljs-string"><span class="hljs-string">"GF_AUTH_PROXY_HEADER_NAME=X-GRAFANA-AUTH"</span></span> grafana/grafana</code> </pre> <br><p>  Veuillez noter qu'il s'agit d'une configuration de démonstration et non finale.  Au minimum, vous devez définir un mot de passe administrateur et interdire l'enregistrement automatique des utilisateurs. </p><br><p>  Relevez le proxy inverse: </p><br><pre> <code class="bash hljs">docker run -d --name proxy -p 4000:4000 --network=gnet grafana_proxy:latest</code> </pre> <br><p>  Dans le navigateur, accédez à localhost: 4000. </p><br><p>  Super, nous avons un Grafana autorisé devant nous. </p><br><p>  Dockerfile pour la construction d'un conteneur avec un proxy et des instructions plus détaillées sur le levage des conteneurs sont sur <a href="https://github.com/460s/grafana_proxy">github</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr480446/">https://habr.com/ru/post/fr480446/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr480430/index.html">Fonctionnement du codec vidéo. Partie 2. Quoi, pourquoi, comment</a></li>
<li><a href="../fr480432/index.html">Le problème du premier visualiseur ou la difficile conversion des flux vidéo WebRTC en HLS</a></li>
<li><a href="../fr480438/index.html">Événements numériques à Moscou du 16 au 22 décembre</a></li>
<li><a href="../fr480440/index.html">Événements numériques à Saint-Pétersbourg du 16 au 22 décembre</a></li>
<li><a href="../fr480444/index.html">Détective Habra: 24 heures de la vie de 24 publications</a></li>
<li><a href="../fr480452/index.html">OWASP Moscow Meetup # 9: Records de performance</a></li>
<li><a href="../fr480454/index.html">Hack The Box - Smasher2 Procédure pas à pas Flacon, WAF et LPE via des pilotes pwn</a></li>
<li><a href="../fr480458/index.html">Regardez "Cell of time"</a></li>
<li><a href="../fr480460/index.html">Solution fondamentale d'un système d'équations linéaires. Vue latérale</a></li>
<li><a href="../fr480462/index.html">Comment j'ai débattu d'une liste doublement liée pour O (1)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>