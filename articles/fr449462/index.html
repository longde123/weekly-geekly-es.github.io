<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê∑ üëï üòª Utilisation des m√©canismes de jetons cryptographiques PKCS # 11 dans les langages de script üï§ üë∂üèª üôÜüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans ses commentaires sur l' article ¬´Un utilitaire multiplateforme anglophone pour visualiser les certificats x509 qualifi√©s en russe¬ª, Pas a not√© tr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Utilisation des m√©canismes de jetons cryptographiques PKCS # 11 dans les langages de script</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449462/"><img src="https://habrastorage.org/webt/zf/pt/t6/zfptt6z2xd1tfn_xoovblv2gpuk.png" align="left">  Dans ses commentaires sur l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> ¬´Un utilitaire multiplateforme anglophone pour visualiser les certificats x509 qualifi√©s en russe¬ª, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Pas a</a> not√© tr√®s correctement les jetons PKCS # 11 qu'ils ¬´peuvent tous se compter eux-m√™mes¬ª.  Oui, les jetons sont en fait des ordinateurs cryptographiques.  Et il est naturel de vouloir utiliser ces ordinateurs dans des langages de script, que ce soit Python, Perl ou Ruby.  Nous avons d√©j√† envisag√© l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">utilisation des jetons PKCS # 11</a> avec prise en charge de la cryptographie russe en Python pour la signature et le cryptage de documents, afin de cr√©er une demande de certificat: <br><a name="habracut"></a><br><img src="https://habrastorage.org/getpro/habr/post_images/fad/2c8/cc8/fad2c8cc898827d22442885cc9513afd.png" alt="image"><br><br>  Ici, nous continuons la discussion sur le langage Tcl.  Dans l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> pr√©c√©dent, lorsque nous avons examin√© l'affichage et la validation des certificats stock√©s sur les jetons / cartes √† puce PKCS # 11, nous avons utilis√© le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">package TclPKCS11 version 0.9.9</a> pour y acc√©der (certificats).  Comme d√©j√† indiqu√©, malheureusement, le package a √©t√© d√©velopp√© pour la cryptographie RSA et en tenant compte de la norme PKCS # 11 v.2.20.  Aujourd'hui, la norme PKCS # 11 v.2.40 est d√©j√† utilis√©e et c'est le comit√© technique de cryptographie TK-26 qui s'en guide, √©mettant des recommandations pour les fabricants nationaux de jetons / cartes √† puce qui prennent en charge la cryptographie russe.  Et avec tout cela dit, un nouveau package <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TclPKCS11 version 1.0.1 est apparu</a> .  Nous r√©serverons imm√©diatement que toutes les interfaces cryptographiques pour RSA dans la nouvelle version du package TclPKCS11 v.10.1 sont enregistr√©es.  La biblioth√®que de packages est √©crite en langage C. <br><br>  Alors, quoi de neuf dans le package?  Tout d'abord, une commande a √©t√© ajout√©e qui vous permet d'obtenir une liste des m√©canismes cryptographiques pris en charge par le jeton connect√©: <br><br><pre><code class="plaintext hljs">::pki::pkcs11::listmechs &lt;handl&gt; &lt;slotid&gt;</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voici</a> comment obtenir une liste des emplacements avec des jetons connect√©s (proc√©dure - proc :: slots_with_token): <br><br><pre> <code class="plaintext hljs">proc ::slots_with_token {handle} { set slots [pki::pkcs11::listslots $handle] # puts "Slots: $slots" array set listtok [] foreach slotinfo $slots { set slotid [lindex $slotinfo 0] set slotlabel [lindex $slotinfo 1] set slotflags [lindex $slotinfo 2] if {[lsearch -exact $slotflags TOKEN_PRESENT] != -1} { set listtok($slotid) $slotlabel } } #     parray listtok return [array get listtok] }</code> </pre> <br>  Prenez un script simple: <br><br><pre> <code class="plaintext hljs">#!/usr/bin/tclsh lappend auto_path . package require pki::pkcs11 #      RuToken set lib "/usr/local/lib64/librtpkcs11ecp_2.0.so" &lt;source lang="bash"&gt;set handle [pki::pkcs11::loadmodule $lib] #    #       set labslot [::slots_with_token $handle] if {[llength $labslot] == 0} { puts "     " exit } set slotid 0 set lmech [pki::pkcs11::listmechs $handle $slotid] set i 0 foreach mm $lmech { #   if {[string first "GOSTR3410" $mm] != -1} { puts -nonewline "[lindex $mm 0] " if {$i == 2} {puts "";set i 0} else { incr i} } } puts "\n" exit</code> </pre> <br>  Ce script vous permet d'obtenir une liste des m√©canismes de cryptographie GOSTR3410 pris en charge sur les jetons de la famille RuToken.  Pour commencer, prenons, comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Pas l'a</a> √©crit dans l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> , ¬´Rutoken Light aim√© par toutes sortes d'EDO¬ª: <br><br><pre> <code class="plaintext hljs">$ tclsh TEST_for_HABR.tcl listtok(0) = ruToken Lite 0 {ruToken Lite } $</code> </pre> <br>  Et naturellement, il s'av√®re qu'il ne soutient aucun mezanisme GOST, ce qui devait √™tre prouv√©.  Nous prenons un autre jeton Rutoken EDS: <br><br><pre> <code class="plaintext hljs">$ tclsh TEST_for_HABR.tcl listtok(0) = ruToken ECP } 0 {ruToken ECP } CKM_GOSTR3410_KEY_PAIR_GEN CKM_GOSTR3410 CKM_GOSTR3410_DERIVE CKM_GOSTR3410_WITH_GOSTR3411 $</code> </pre> <br>  Oui, ce jeton prend en charge la cryptographie russe, mais uniquement la signature de GOST R 34.10-2001, qui est presque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">hors d'usage</a> .  Mais si vous prenez le jeton Rutoken EDS-2.0, alors tout ira bien, il prend en charge GOST R 34.10-2012 avec des cl√©s de 256 et 512 bits: <br><br><pre> <code class="plaintext hljs">$ tclsh TEST_for_HABR.tcl listtok(0) = RuTokenECP20 0 {RuTokenECP20 } CKM_GOSTR3410_KEY_PAIR_GEN CKM_GOSTR3410 CKM_GOSTR3410_DERIVE CKM_GOSTR3410_512_KEY_PAIR_GEN CKM_GOSTR3410_512 CKM_GOSTR3410_12_DERIVE CKM_GOSTR3410_WITH_GOSTR3411 CKM_GOSTR3410_WITH_GOSTR3411_12_256 CKM_GOS TR3410_WITH_GOSTR3411_12_512 $</code> </pre><br><img src="https://habrastorage.org/webt/1y/za/nm/1yzanmwujk76deyqsdqgw8kge3u.png" align="left">  Si nous avons parl√© de la prise en charge de la cryptographie russe, y compris des algorithmes de cryptage des sauterelles et du magma, avec l'un ou l'autre jeton, alors il est le plus pleinement pris en charge par les logiciels et les jetons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cloud</a> , et cela est naturel: <br><br><pre> <code class="plaintext hljs">$ tclsh TEST_for_HABR.tcl listtok(0) = LS11SW2016_LIN_64 0 {LS11SW2016_LIN_64 }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Liste des m√©canismes</b> <div class="spoiler_text">  CKM_GOSTR3410_KEY_PAIR_GEN <br>  CKM_GOSTR3410_512_KEY_PAIR_GEN <br>  CKM_GOSTR3410 <br>  CKM_GOSTR3410_512 <br>  CKM_GOSTR3410_WITH_GOSTR3411 <br>  CKM_GOSTR3410_WITH_GOSTR3411_12_256 <br>  CKM_GOSTR3410_WITH_GOSTR3411_12_512 <br>  CKM_GOSTR3410_DERIVE <br>  CKM_GOSTR3410_12_DERIVE <br>  CKM_GOSR3410_2012_VKO_256 <br>  CKM_GOSR3410_2012_VKO_512 <br>  CKM_KDF_4357 <br>  CKM_KDF_GOSTR3411_2012_256 <br>  CKM_KDF_TREE_GOSTR3411_2012_256 <br>  CKM_GOSTR3410_KEY_WRAP <br>  CKM_GOSTR3410_PUBLIC_KEY_DERIVE <br>  CKM_LISSI_GOSTR3410_PUBLIC_KEY_DERIVE <br>  CKM_GOST_GENERIC_SECRET_KEY_GEN <br>  CKM_GOST_CIPHER_KEY_GEN <br>  CKM_GOST_CIPHER_ECB <br>  CKM_GOST_CIPHER_CBC <br>  CKM_GOST_CIPHER_CTR <br>  CKM_GOST_CIPHER_OFB <br>  CKM_GOST_CIPHER_CFB <br>  CKM_GOST_CIPHER_OMAC <br>  CKM_GOST_CIPHER_KEY_WRAP <br>  CKM_GOST_CIPHER_ACPKM_CTR <br>  CKM_GOST_CIPHER_ACPKM_OMAC <br>  CKM_GOST28147_KEY_GEN <br>  CKM_GOST28147 <br>  CKM_GOST28147_KEY_WRAP <br>  CKM_GOST28147_PKCS8_KEY_WRAP <br>  CKM_GOST_CIPHER_PKCS8_KEY_WRAP <br>  CKM_GOST28147_ECB <br>  CKM_GOST28147_CNT <br>  CKM_GOST28147_MAC <br>  CKM_KUZNYECHIK_KEY_GEN <br>  CKM_KUZNYECHIK_ECB <br>  CKM_KUZNYECHIK_CBC <br>  CKM_KUZNYECHIK_CTR <br>  CKM_KUZNYECHIK_OFB <br>  CKM_KUZNYECHIK_CFB <br>  CKM_KUZNYECHIK_OMAC <br>  CKM_KUZNYECHIK_KEY_WRAP <br>  CKM_KUZNYECHIK_ACPKM_CTR <br>  CKM_KUZNYECHIK_ACPKM_OMAC <br>  CKM_MAGMA_KEY_GEN <br>  CKM_MAGMA_ECB <br>  CKM_MAGMA_CBC <br>  CKM_MAGMA_CTR <br>  CKM_MAGMA_OFB <br>  CKM_MAGMA_CFB <br>  CKM_MAGMA_OMAC <br>  CKM_MAGMA_KEY_WRAP <br>  CKM_MAGMA_ACPKM_CTR <br>  CKM_MAGMA_ACPKM_OMAC <br>  CKM_GOSTR3411 <br>  CKM_GOSTR3411_12_256 <br>  CKM_GOSTR3411_12_512 <br>  CKM_GOSTR3411_HMAC <br>  CKM_GOSTR3411_12_256_HMAC <br>  CKM_GOSTR3411_12_512_HMAC <br>  CKM_PKCS5_PBKD2 <br>  CKM_PBA_GOSTR3411_WITH_GOSTR3411_HMAC <br>  CKM_TLS_GOST_KEY_AND_MAC_DERIVE <br>  CKM_TLS_GOST_PRE_MASTER_KEY_GEN <br>  CKM_TLS_GOST_MASTER_KEY_DERIVE <br>  CKM_TLS_GOST_PRF <br>  CKM_TLS_GOST_PRF_2012_256 <br>  CKM_TLS_GOST_PRF_2012_512 <br>  CKM_TLS12_MASTER_KEY_DERIVE <br>  CKM_TLS12_KEY_AND_MAC_DERIVE <br>  CKM_TLS_MAC <br>  CKM_TLS_KDF <br>  CKM_TLS_TREE_GOSTR3411_2012_256 <br>  CKM_EXTRACT_KEY_FROM_KEY <br>  CKM_SHA_1 <br>  CKM_MD5 <br></div></div><br><pre> <code class="plaintext hljs">$</code> </pre> <br>  Nous passons √† la prochaine nouvelle fonctionnalit√© ajout√©e au package: <br><br><pre> <code class="plaintext hljs">set listcertsder [pki::pkcs11::listcertsder $handle $slotid]</code> </pre> <br>  Cette fonction renvoie une liste de certificats stock√©s par aucun jeton.  La question se pose naturellement, mais en quoi diff√®re-t-elle de la fonction existante pki :: pkcs11 :: listcerts? <br><br>  Tout d'abord, la nouvelle fonction n'utilise pas le package :: pki.  L'un des √©l√©ments renvoy√©s est l'√©l√©ment cert_der, qui contient le certificat complet.  Cela est pratique, par exemple, lors de l'exportation d'un certificat ou de la r√©ception de son empreinte digitale.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Auparavant, je</a> devais r√©cup√©rer le certificat complet √† partir du certificat tbs et de sa signature.  Une liste compl√®te des articles retourn√©s pour chaque certificat est clairement visible lors de l'impression du contenu d'un certificat: <br><br><pre> <code class="plaintext hljs">. . . array set derc [[pki::pkcs11::listcertsder $handle $slotid] 0] parray derc derc(cert_der) = 3082064a ‚Ä¶ derc(pkcs11_handle) = pkcsmod0 derc(pkcs11_id) = 5882d64386211cf3a8367d2f87659f9330e5605d derc(pkcs11_label) = Thenderbird-60   derc(pkcs11_slotid) = 0 derc(type) = pkcs11 . . .</code> </pre> <br>  L'√©l√©ment pkcs11_id stocke l'attribut CKA_ID la valeur du hachage SHA-1 de la cl√© publique.  L'√©l√©ment cert_der est le CKA_VALUE du certificat, pkcs11_label est CKA_LABEL. <br><br>  L'√©l√©ment pkcs11_id (CKA_ID dans la terminologie de la norme PKCS # 11) est, avec la biblioth√®que pkcs11_handle, et l'identificateur d'emplacement avec le jeton pkcs11_slotid un √©l√©ment cl√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pour acc√©der aux</a> cl√©s et certificats stock√©s sur les jetons. <br><br>  Donc, si nous voulons changer le label (pkcs11_label) du certificat ou des cl√©s, nous ex√©cutons une commande du formulaire: <br><br><pre> <code class="plaintext hljs">pki::pkcs11::rname &lt;cert|key|all&gt; &lt;  &gt;</code> </pre> <br>  Pour supprimer un certificat ou des cl√©s d'un jeton, une commande du formulaire est ex√©cut√©e: <br><br><pre> <code class="plaintext hljs">pki::pkcs11::delete &lt;cert|key|all&gt; &lt;  &gt;</code> </pre> <br>  La liste des √©l√©ments cl√©s peut √™tre form√©e comme suit: <br><br><pre> <code class="plaintext hljs">set listparam {} lappend listparam pkcs11_handle lappend listparam $handle lappend listparam pkcs11_slotid lappend listparam $pkcs11_slotid lappend listparam pkcs11_id lappend listparam $pkcs11_id</code> </pre> <br>  etc. <br>  L'appel de fonction dans ce cas ressemble √† ceci (nous allons supprimer le certificat et les cl√©s qui lui sont associ√©es): <br><br><pre> <code class="plaintext hljs">pki::pkcs11::delete all $listparam</code> </pre> <br>  Le lecteur a probablement d√©j√† devin√© que cette liste peut √™tre arrang√©e comme un dictionnaire dict: <br><br><pre> <code class="plaintext hljs">set listparam [dict create pkcs11_handle $pkcs11_handle] dict set listparam pkcs11_slotid $pkcs11_slotid) dict set listparam pkcs11_id $pkcs11_id</code> </pre> <br>  Il existe d'autres fa√ßons, par exemple, via un tableau. <br><br>  Encore une fois, nous notons que les √©l√©ments pkcs11_handle et pkcs11_slotid doivent toujours √™tre pr√©sents dans la liste des √©l√©ments cl√©s, qui identifient de mani√®re unique le jeton connect√©.  Le reste de la composition est d√©termin√© par une fonction sp√©cifique. <br><br>  La fonction suivante est utilis√©e pour installer le certificat sur le jeton: <br><br><pre> <code class="plaintext hljs">set pkcs11_id_cert [::pki::pkcs11::importcert &lt;cert_der_hex&gt; &lt;  &gt;</code> </pre> <br>  La fonction renvoie la valeur CKA_ID en hexad√©cimal.  La liste des param√®tres cl√©s d√©termine le jeton sur lequel le certificat sera situ√©: <br><br><pre> <code class="plaintext hljs">{pkcs11_handle &lt;handle&gt; pkcs11_slotid &lt;slotid&gt;}</code> </pre><br>  Ensuite, notre calcul de hachage.  Aujourd'hui, dans la cryptographie russe, trois types de fonctions de hachage sont utilis√©s: <br>  - GOST R 34.11-94 <br>  - GOST R 34 .11-2012 avec une valeur de hachage de 256 bits (stribog256) <br>  - GOST R 34 .11-2012 avec une valeur de hachage de 512 bits (stribog512) <br>  Pour d√©terminer quel hachage prend en charge le jeton, nous avons la fonction pki :: pkcs11 :: listmechs. <br><br>  La fonction de calcul du hachage a la forme suivante: <br><br><pre> <code class="plaintext hljs">set &lt;&gt; [pki::pkcs11::digest &lt;gostr3411|stribog256|stribog512|sha1&gt; &lt;  &gt; &lt;  &gt;]</code> </pre> <br>  Notez que le r√©sultat du calcul du calcul est pr√©sent√© en hexad√©cimal: <br><pre> <code class="plaintext hljs">. . . set listparam [dict create pkcs11_handle $pkcs11_handle] dict set listparam pkcs11_slotid $pkcs11_slotid set res_hex [pki::pkcs11::digest stribog256 0123456789 $listparam] puts $res_hex 086f2776f33aae96b9a616416b9d1fe9a049951d766709dbe00888852c9cc021</code> </pre><br>  Pour la v√©rification, prenons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">openssl avec le support de la cryptographie russe</a> : <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -n <span class="hljs-string"><span class="hljs-string">"0123456789"</span></span>|/usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/lirssl_csp_64/bin/lirssl_s tatic dgst -md_gost12_256 (stdin)= 086f2776f33aae96b9a616416b9d1fe9a0499 51d766709dbe00888852c9 cc021 $</code> </pre> <br>  Comme vous pouvez le voir, le r√©sultat est identique. <br><br>  Pour v√©rifier une signature √©lectronique, qu'il s'agisse d'un certificat ou d'une liste de certificats r√©voqu√©s ou d'un document sign√© dans un format, nous n'avons maintenant besoin que de la fonction de v√©rification de signature: <br><br><pre> <code class="plaintext hljs">set result [pki::pkcs11::verify &lt; &gt; &lt; &gt; &lt;  &gt;]]</code> </pre> <br>  Si la signature a r√©ussi la v√©rification, 1 est renvoy√©, sinon 0. Pour v√©rifier la signature √©lectronique, la signature du document elle-m√™me, le hachage du document, d√©termin√© par le type de signature, et la cl√© publique avec laquelle la signature a √©t√© cr√©√©e, avec tous les param√®tres (valeur, type et param√®tres), sont requis. .  Toutes les informations sur la cl√© sous la forme de la structure publickeyinfo asn1 doivent √™tre incluses dans la liste des √©l√©ments cl√©s: <br><blockquote>  lpkar (pkcs11_handle) = pkcsmod0 <br>  lpkar (pkcs11_slotid) = 0 <br>  lpkar (pubkeyinfo) = 301f06082a85030701010101301306072a85030202240 <br>  006082a8503070101020203430004407d9306687af5a8e63af4b09443ed2e03794be <br>  10eba6627bf5fb3da1bb474a3507d2ce2cd24b63c727a02521897d1dd6edbdc7084d <br>  8886a39289c3f81bdf2e179 </blockquote>  La structure de la cl√© publique ASN1 est issue du certificat du signataire: <br><br><pre> <code class="plaintext hljs">proc ::pki::x509::parse_cert_pubkeyinfo {cert_hex} { array set ret [list] set wholething [binary format H* $cert_hex] ::asn::asnGetSequence wholething cert ::asn::asnPeekByte cert peek_tag if {$peek_tag != 0x02} { # Version number is optional, if missing assumed to be value of 0 ::asn::asnGetContext cert - asn_version ::asn::asnGetInteger asn_version ret(version) } ::asn::asnGetBigInteger cert ret(serial_number) ::asn::asnGetSequence cert data_signature_algo_seq ::asn::asnGetObjectIdentifier data_signature_algo_seq ret(data_signature_algo) ::asn::asnGetSequence cert issuer ::asn::asnGetSequence cert validity ::asn::asnGetUTCTime validity ret(notBefore) ::asn::asnGetUTCTime validity ret(notAfter) ::asn::asnGetSequence cert subject ::asn::asnGetSequence cert pubkeyinfo binary scan $pubkeyinfo H* ret(pubkeyinfo) return $ret(pubkeyinfo) }</code> </pre> <br>  Le texte du script permettant de v√©rifier la signature √©lectronique des certificats d'un fichier se trouve <div class="spoiler">  <b class="spoiler_title">ici</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#! /usr/bin/env tclsh package require pki lappend auto_path . package require pki::pkcs11 #     PKCS#11 #set pkcs11_module "/usr/local/lib/libcackey.so" #set pkcs11_module "/usr/local/lib64/librtpkcs11ecp_2.0.so" set pkcs11_module "/usr/local/lib64/libls11sw2016.so" puts "Connect the Token and press Enter" gets stdin yes set handle [pki::pkcs11::loadmodule $pkcs11_module] set slots [pki::pkcs11::listslots $handle] foreach slotinfo $slots { set slotid [lindex $slotinfo 0] set slotlabel [lindex $slotinfo 1] set slotflags [lindex $slotinfo 2] if {[lsearch -exact $slotflags TOKEN_PRESENT] != -1} { set token_slotlabel $slotlabel set token_slotid $slotid #    break } } # PEM  DER proc ::cert_to_der {data} { if {[string first "-----BEGIN CERTIFICATE-----" $data] != -1} { set data [string map {"\r\n" "\n"} $data] } array set parsed_cert [::pki::_parse_pem $data "-----BEGIN CERTIFICATE-----" "-----END CERTIFICATE-----"] if {[string range $parsed_cert(data) 0 0 ] == "0" } { #   DER- "0" == 0x30 set asnblock $parsed_cert(data) } else { set asnblock "" } return $asnblock } proc usage {use error} { puts "Copyright(C) Orlov Vladimir (http://soft.lissi.ru) 2019" if {$use == 1} { puts $error puts "Usage:\nverify_cert_with_pkcs11 &lt;file with certificate&gt; \[&lt;file with CA certificate&gt;\]\n" } } set countcert [llength $argv] if { $countcert &lt; 1 || $countcert &gt; 2 } { usage 1 "Bad usage!" exit } set file [lindex $argv 0] if {![file exists $file]} { usage 1 "File $file not exist" exit } #  cert_user puts "Loading user certificate: $file" set fd [open $file] chan configure $fd -translation binary set cert_user [read $fd] close $fd if {$cert_user == "" } { usage 1 "Bad file with certificate user: $file" exit } set cert_user [cert_to_der $cert_user] if {$cert_user == ""} { puts "User certificate bad" exit } catch {array set cert_parse [::pki::x509::parse_cert $cert_user]} if {![info exists cert_parse]} { puts "User certificate bad" exit } #parray cert_parse if {$countcert == 1} { if {$cert_parse(issuer) != $cert_parse(subject)} { puts "Bad usage: not self signed certificate" } else { set cert_CA $cert_user } } else { set fileca [lindex $argv 1] if {![file exists $fileca]} { usage 1 "File $fileca not exist" exit } #  cert_CA puts "Loading CA certificate: $fileca" set fd [open $fileca] chan configure $fd -translation binary set cert_CA [read $fd] close $fd if {$cert_CA == "" } { usage 1 "Bad file with certificate CA=$fileca" exit } set cert_CA [cert_to_der $cert_CA] if {$cert_CA == ""} { puts "CA certificate bad" exit } } foreach slotinfo $slots { set slotid [lindex $slotinfo 0] set slotlabel [lindex $slotinfo 1] set slotflags [lindex $slotinfo 2] if {[lsearch -exact $slotflags TOKEN_PRESENT] != -1} { set token_slotlabel $slotlabel set token_slotid $slotid } } #    #array set cert_parse_CA [::pki::x509::parse_cert $cert_CA] catch {array set cert_parse_CA [::pki::x509::parse_cert $cert_CA]} #array set cert_parse_CA [::pki::x509::parse_cert $cert_CA_256] #array set cert_parse_CA [::pki::x509::parse_cert $CA_12_512] if {![info exists cert_parse_CA]} { puts "CA certificate bad" exit } ############################### set aa [dict create pkcs11_handle $handle pkcs11_slotid $token_slotid] set tbs_cert [binary format H* $cert_parse(cert)] #puts "SIGN_ALGO1=$cert_parse(signature_algo)" catch {set signature_algo_number [::pki::_oid_name_to_number $cert_parse(signature_algo)]} if {![info exists signature_algo_number]} { set signature_algo_number $cert_parse(signature_algo) } #puts "SIGN_ALGO=$signature_algo_number" switch -- $signature_algo_number { "1.2.643.2.2.3" - "1 2 643 2 2 3" { # "GOST R 34.10-2001 with GOST R 34.11-94" set digest_algo "gostr3411" } "1.2.643.7.1.1.3.2" - "1 2 643 7 1 1 3 2" { # "GOST R 34.10-2012-256 with GOSTR 34.11-2012-256" set digest_algo "stribog256" } "1.2.643.7.1.1.3.3" - "1 2 643 7 1 1 3 3" { # "GOST R 34.10-2012-512 with GOSTR 34.11-2012-512" set digest_algo "stribog512" } default { puts "  :$signature_algo_number" exit } } #   tbs-!!!! set digest_hex [pki::pkcs11::digest $digest_algo $tbs_cert $aa] puts "digest_hex=$digest_hex" puts [string length $digest_hex] # asn-   #    binary scan $cert_CA H* cert_CA_hex array set infopk [pki::pkcs11::pubkeyinfo $cert_CA_hex [list pkcs11_handle $handle pkcs11_slotid $token_slotid]] parray infopk set lpk [dict create pkcs11_handle $handle pkcs11_slotid $token_slotid] # pybkeyinfo     lappend lpk "pubkeyinfo" #lappend lpk $pubinfo lappend lpk $infopk(pubkeyinfo) array set lpkar $lpk parray lpkar puts "Enter PIN user for you token \"$token_slotlabel\":" #set password "01234567" gets stdin password if { [pki::pkcs11::login $handle $token_slotid $password] == 0 } { puts "Bad password" exit } if {[catch {set verify [pki::pkcs11::verify $digest_hex $cert_parse(signature) $lpk]} res] } { puts $res exit } if {$verify != 1} { puts "BAD SIGNATURE=$verify" } else { puts "SIGNATURE OK=$verify" } puts "!" exit</code> </pre> <br></div></div><br>  Enregistrez le script dans un fichier et essayez de l'ex√©cuter: <br><br><pre> <code class="bash hljs">$./verify_cert_with_pkcs11.tcl Copyright(C) Orlov Vladimir (http://museum.lissi-crypto.ru/) Usage: verify_cert_with_pkcs11 &lt;file with certificate&gt; &lt;file with CA certificate&gt; $</code> </pre> <br>  On se demande, qu'en est-il des certificats sur le token?  Tout d'abord, nous avons r√©solu le probl√®me de l'utilisation des machines cryptographiques PKCS # 11.  Nous les avons utilis√©s.  Et pour diffuser un certificat avec un jeton, il existe une fonction du package pki :: pkcs11 :: listcertsder, qui vous permet de s√©lectionner le certificat souhait√© et de le v√©rifier.  Cela peut √™tre consid√©r√© comme un devoir. <br><br>  L'apparition de la nouvelle version du package TclPKCS11v.1.0.1 a permis d'affiner l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">utilitaire de visualisation des</a> certificats <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">en</a> ajoutant les fonctions d'importation d'un certificat pour un jeton, de suppression de certificats et de cl√©s associ√©es d'un jeton, de modification des √©tiquettes des certificats et des cl√©s, etc.: <br><br><img src="https://habrastorage.org/webt/tn/7x/e8/tn7xe89tddtvfw0r6vmtqe2oeaa.png"><br><br>  La fonctionnalit√© la plus importante ajout√©e est la v√©rification de la signature num√©rique du certificat: <br><br><img src="https://habrastorage.org/webt/v8/sf/sr/v8sfsrp3tyghuwkyvseltrdtrsy.png"><br><br>  Le lecteur attentif a correctement not√© que rien n'a √©t√© dit sur la g√©n√©ration de la paire de cl√©s.  Cette fonctionnalit√© est √©galement ajout√©e au package TclPKCS11: <br><br><pre> <code class="plaintext hljs">array set genkey [pki::pkcs11::keypair &lt; &gt; &lt;&gt; &lt;  &gt;]</code> </pre> <br>  La fa√ßon dont les fonctions du package TclPKCS11 sont utilis√©es, bien s√ªr, peut √™tre trouv√©e dans le code source de l'utilitaire. <br><br>  La fonction de g√©n√©ration d'une paire de cl√©s sera discut√©e en d√©tail dans l'article suivant, lorsque l'utilitaire cr√©era une demande de certificat qualifi√© avec la g√©n√©ration d'une paire de cl√©s sur le jeton PKCS # 11, le m√©canisme permettant d'obtenir un certificat dans un centre de certification ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CA</a> ) et de l'importer dans un jeton: <br><br><img src="https://habrastorage.org/webt/zn/c4/zu/znc4zukmmtywwnpo4ycwze4zseo.png"><br><br>  Dans le m√™me article, la fonction de signature d'un document sera consid√©r√©e.  Ce sera le dernier article de cette s√©rie.  Ensuite, une s√©rie d'articles est pr√©vue sur la prise en charge de la cryptographie russe dans le langage de script Ruby, qui est d√©sormais √† la mode.  A tr√®s bient√¥t! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr449462/">https://habr.com/ru/post/fr449462/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr449450/index.html">Svelte 3: Repenser la r√©activit√©</a></li>
<li><a href="../fr449452/index.html">Les d√©veloppeurs Web √©crivent du code non s√©curis√© par d√©faut</a></li>
<li><a href="../fr449454/index.html">Comment Microsoft Kaizala permet aux chemins de fer indiens de r√©unir 3 millions d'employ√©s des soins de sant√©</a></li>
<li><a href="../fr449458/index.html">La mise √† jour de Windows 10 ¬´Mise √† jour de mai 2019¬ª ne sera pas install√©e lorsque ... les lecteurs USB et les cartes m√©moire sont connect√©s au PC</a></li>
<li><a href="../fr449460/index.html">Museum DataArt. Le manipulateur souris d'informations graphiques</a></li>
<li><a href="../fr449464/index.html">Widget vk.com sans demande d√©finit un compteur de mail.ru sur le site</a></li>
<li><a href="../fr449466/index.html">Pauses dans les jeux HTML5</a></li>
<li><a href="../fr449468/index.html">Comment le "piratage √©thique" du fabricant de logiciels de jeu s'est transform√© en cauchemar complet</a></li>
<li><a href="../fr449472/index.html">Cataclysm Dark Days Ahead, analyse statique et bagels</a></li>
<li><a href="../fr449476/index.html">Un nouveau type de stockage SSD r√©duira la consommation d'√©nergie dans le centre de donn√©es - comment cela fonctionne</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>