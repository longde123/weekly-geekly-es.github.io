<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😺 🖐🏽 👩🏿‍🤝‍👨🏾 تعظيم الاستفادة من النماذج ثلاثية الأبعاد لمشهد اللعبة 🚠 💂 🍾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="تكمل هذه المقالة سلسلة من المنشورات من Krasnodar studio Plarium حول جوانب مختلفة من العمل مع النماذج ثلاثية الأبعاد في الوحدة. المقالات السابقة: "ميزا...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>تعظيم الاستفادة من النماذج ثلاثية الأبعاد لمشهد اللعبة</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/plarium/blog/484792/" style=";text-align:right;direction:rtl">  تكمل هذه المقالة سلسلة من المنشورات من Krasnodar studio Plarium حول جوانب مختلفة من العمل مع النماذج ثلاثية الأبعاد في الوحدة.  المقالات السابقة: <a href="https://habr.com/ru/company/plarium/blog/440690/">"ميزات العمل مع Mesh in Unity"</a> ، و <a href="https://habr.com/ru/company/plarium/blog/443870/">"Unity: التحرير الإجرائي لـ Mesh"</a> ، و <a href="https://habr.com/ru/company/plarium/blog/447820/">"استيراد النماذج ثلاثية الأبعاد إلى Unit و pitfalls"</a> ، و <a href="https://habr.com/ru/company/plarium/blog/451794/">"المسافة البادئة للبيكسل في مسح الملمس"</a> . <br><br>  قبل عامين تقريبًا ، كتبنا <a href="https://habr.com/ru/company/plarium/blog/348494/">مقالة</a> تحدثنا فيها عن خيار تحسين هندسة الأبعاد الثلاثية في مشهد ما مع فرض قيود على زاوية الكاميرا وتدوير الكائنات المقابلة.  لم يتدفق الكثير منذ ذلك الحين ، ولكن الفرصة لتحسين الحل ، والنظر في طرق مختلفة والتجسس على الآخرين يطارد عقول المطورين.  في هذه المقالة ، سنصف نسخة محسّنة من الخوارزمية استنادًا إلى الرسم المضلع ، ونتحدث أيضًا عن محاولات نقل جزء من هذا العمل إلى حزمة ثلاثية الأبعاد. <br><br><img src="https://habrastorage.org/webt/jl/v-/pz/jlv-pzi5qagnnmqhgkqaddzo1uo.jpeg"><a name="habracut"></a><br><br><h3 style=";text-align:right;direction:rtl">  المحاصيل في المشهد </h3><br>  لقد سبق أن نظرنا في المبدأ الأساسي لهذه الخوارزمية في المقالة أعلاه: نحن نطفئ جميع التأثيرات والكائنات الشفافة ونرسم المضلعات غير المعالجة بلون واحد ، ونعالجها بألوان مختلفة ، ونعرضها ونستخرج النتيجة.  في الإصدار القديم ، تم رسمها بحيث يكون كل شيء أسود زائداً عن الحاجة ، وكان هناك مثلث واحد فقط باللون الأحمر. <br><br>  <a href="https://habr.com/ru/company/plarium/blog/348494/">في التعليقات</a> على هذه المقالة ، أشار أحد القراء إلى إمكانية تحسين الخوارزمية من خلال إنشاء مراسلات فردية بين مجموعة المضلعات ومجموعة من الأرقام الفريدة.  عندها سيكون من الممكن معالجة أكثر من مثلث بنفس الطريقة.  النظر في هذا الخيار. <br><br>  في هذه الحالة ، وكذلك في المرة الأخيرة ، من المفترض أن يكون بعض التدريب المسبق مرتبطًا بتعطيل كل كائنات الصفير على المسرح والأشياء المضمونة بعدم التأثير على رؤية النموذج المستهدف.  تتم معالجة طرق عرض الكاميرا بشكل مستقل تقريبًا ؛ فهي متصلة فقط عن طريق مخزن مؤقت مشترك للمضلعات المرئية.  بالإضافة إلى ذلك ، يتم إجراء معالجة مسبقة للهندسة لكل زاوية ، يتم خلالها تحويل المضلعات التي يتم إرجاعها إلى الكاميرا ( <b>الخلفية</b> ).  يتم ذلك لأنه في مرحلة معينة من الخوارزمية يتم إنشاء شبكة مؤقتة بعدد كبير من الرؤوس أكبر من الرؤوس الأصلية.  يمكن أن يتجاوز هذا الرقم بسهولة الحد الأقصى البالغ 65535 ، والذي سيتطلب إيماءات إضافية في الحسابات وسيؤدي إلى انخفاض الأداء.  في أي حال ، سيتم حذف هذه المضلعات ، لأن لونها لن يسقط في الإطار.  ومع ذلك ، نظرًا لحقيقة أن كل مثلث يحتمل أن يؤدي إلى ثلاثة رؤوس قمامة ، فإن التخلص من المضلعات غير الضرورية مقدمًا يسهل المرحلة الرئيسية من الخوارزمية ويقلل من تكاليف الذاكرة. <br><br>  فليكن هناك نموذج ثلاثي الأبعاد ، يتم تمثيل شكله الهندسي بشبكة.  لطلاء مضلع محدد بلون فريد ، تحتاج إلى رسم كل رؤوسه في هذا اللون.  نظرًا لأنه في الحالة العامة يمكن أن ينتمي رأس واحد إلى مضلعات مختلفة ، فلن يكون من الممكن حل المشكلة بشكل مباشر.  بغض النظر عن كيفية تلوين أي قمة ، عند التقديم ، سوف يتسلل لونه إلى جميع المثلثات التي تمتلكها ، وفقًا لخوارزمية الاستيفاء الموجودة على جانب بطاقة الفيديو. <br><br><img src="https://habrastorage.org/webt/ay/td/qo/aytdqo0ah1fzsl7pcasymag9rf8.jpeg"><br>  <i>مثال على الاستيفاء اللوني عند عرض المضلعات ذات الرؤوس الشائعة</i> <br><br>  لذلك ، من الضروري تقسيم الشبكة بطريقة ما إلى مضلعات مستقلة منفصلة ، مع الحفاظ على طوبولوجيا وهندسة الكائن.  القول المأثور.  نقوم بتحويل صفائف المثلثات والرؤوس بحيث يتم إنشاء كل رأس مثلث 3 فريد ، يتم تحديد موقعه بواسطة القمم المقابلة للشبكة الأصلية.  تجدر الإشارة إلى أنه في الحالة العامة ، سيكون لهذه الشبكة عدد أكبر بكثير من الرؤوس مقارنة بالأصل.  وإذا تجاوز هذا الرقم 65 535 ، فعند إنشاء الشبكة ، يجب عليك تحديد تنسيق الفهرسة المناسب. <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">قم بتحويل الشبكة الأصلية إلى شبكة ذات رؤوس فريدة لكل مضلع</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Mesh </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNotSmoothMesh</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Mesh origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> oVertices = origin.vertices; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> oTriangles = origin.triangles; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3[oTriangles.Length]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> triangles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[oTriangles.Length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; triangles.Length; i++) { vertices[i] = oVertices[oTriangles[i]]; triangles[i] = i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mesh() { indexFormat = vertices.Length &gt; <span class="hljs-number"><span class="hljs-number">65535</span></span> ? IndexFormat.UInt32 : IndexFormat.UInt16, vertices = vertices, triangles = triangles }; }</code> </pre> <br></div></div><br>  أنت الآن بحاجة إلى تعيين المضلعات في هذه الشبكة بحيث أنه بعد عملية التقديم ، كان من الممكن تحديد أي مضلع على الشاشة.  كما ذكرنا سابقًا ، نولد ألوانًا فريدة للمضلعات ونرسم كل ثلاثة رؤوس في اللون المقابل.  والنتيجة هي شبكة جديدة ، والتي أطلقنا عليها <b>شبكة بايت الملونة</b> . <br><br><img src="https://habrastorage.org/webt/jl/l0/co/jll0coliukddunmhl5kizfzwpzq.jpeg"><br>  <i><b>شبكة البايت الملونة</b></i> <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">تلوين شبكي ينتمي فيه كل رأس إلى مضلع واحد فقط</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ColorizePolygons</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Mesh mesh</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pColors = ColorsOfPolygons(mesh); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> colors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color[mesh.vertexCount]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; colors.Length; i++) { colors[i] = pColors[i / <span class="hljs-number"><span class="hljs-number">3</span></span>]; } mesh.colors = colors; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Color[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetColorsOfPolygons</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Mesh mesh</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> colors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color[mesh.triangles.Length / <span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; colors.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> color = Int2Color(i);<span class="hljs-comment"><span class="hljs-comment">//         ,     Color2Int //      ,       int     Color32 colors[i] = color; } return colors; }</span></span></code> </pre> <br></div></div><br>  تذكر التلوين.  حان الوقت لتقديم.  نقوم بتنفيذ عرض ثلاثي الأبعاد لجميع زوايا الكاميرا ، وعند معالجة كل منها ، نقوم بتجديد المخزن المؤقت لمؤشرات المضلعات الفريدة التي تم اكتشاف ألوانها في الإطار.  بالنسبة إلى وقت إجراء العمليات الحسابية للكاميرا ، يلزمك إيقاف تشغيل الحواف المضادة لتجنب ظهور ألوان جديدة نظرًا لاستيفاء وحدات البكسل المجاورة. <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">قراءة وتخزين الألوان من زوايا الكاميرا المختلفة</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// CameraTransform —         //      SetCameraTransform private static HashSet&lt;Color&gt; GetVisibleColors(Camera camera, CameraTransform[] cameraTransforms) { var renderTexture = new RenderTexture(1920, 1080, 24);//for example var rtRect = new Rect(0, 0, renderTexture.width, renderTexture.height); var frame = new Texture2D(renderTexture.width, renderTexture.height, TextureFormat.RGB24, false);//    -  RGB24   ,    RGBA32 var visibleColorsSet = new HashSet&lt;Color&gt;(); foreach (var cameraTransform in cameraTransforms) { SetCameraTransform(camera, cameraTransform); CreateScreenShot(camera, renderTexture, frame, rtRect); visibleColorsSet.UnionWith(GetTextureColors(frame)); } return visibleColorsSet; } public static void SetCameraTransform(Camera camera, CameraTransform camTransform) { camera.transform.position = camTransform.Position; camera.transform.rotation = camTransform.Rotation; camera.fieldOfView = camTransform.FieldOfView; camera.orthographic = camTransform.IsOrthographic; camera.nearClipPlane = camTransform.NearClippingPlane; camera.farClipPlane = camTransform.FarClippingPlane; } private static HashSet&lt;Color&gt; GetTextureColors(Texture2D texture) { return new HashSet&lt;Color&gt;(texture.GetPixels()); } private static void CreateScreenShot(Camera cam, RenderTexture renderTexture, Texture2D screenShot, Rect renderTextureRect) { cam.targetTexture = renderTexture; cam.Render(); RenderTexture.active = cam.targetTexture; screenShot.ReadPixels(renderTextureRect, 0, 0); RenderTexture.active = null; cam.targetTexture = null; } }</span></span></code> </pre> <br></div></div><br>  تجدر الإشارة إلى أنه نظرًا للتقدير ، قد لا يتم عرض بعض المثلثات نظرًا لصغر حجم إسقاطها على الشاشة بشكل خاص ، وليس بسبب وجود شيء يتداخل بينهما أو يتم تشغيلهما على الجانب الخطأ.  قمنا بتطبيق نسخة محافظة من الخوارزمية.  في هذه الحالة ، يتم حساب <b>AABB الخاص</b> بإسقاط المثلث على الشاشة ، وإذا كان أحد جوانبها على الأقل أقل من جانب texel في الصورة ، فسيتم وضع علامة على هذا المضلع على أنه مرئي.  يحمي هذا الأسلوب من القطع الأثرية عند تشغيل الخوارزمية بدقة أقل من دقة شاشة الجهاز الهدف.  إذا تجاهلت المضلعات الصغيرة ، فستكون النتيجة مقبولة أيضًا بشرط أن تكون دقة ملمس التجسيد المستخدمة أعلى من دقة شاشات الأجهزة المقصودة. <br><br>  قمنا بتطبيق خوارزمية الاقتصاص هذه في <b>Unity ونستخدمها</b> لتحسين الكائنات الثابتة التي توجد نماذجها في المشهد أكثر من مرة في المواضع المختلفة.  هذا هو المشهد بشكل أساسي: الأحجار ، الأشجار ، التماثيل ، المزهريات ، وما إلى ذلك التي تشير إلى المباني الجاهزة المستخدمة في كثير من الأحيان.  نود تحسين مثل هذه الكائنات في وقت مبكر ، في مرحلة الخلق في حزمة ثلاثية الأبعاد ، ولكن من يدري في أي من الوهمية التي يطرحها مصمم المستوى يريد وضع الشمعدانات المفضلة لديه. <br><br>  يؤدي تقليل مجموعة الكائنات من نفس النوع باستخدام هذه الأداة إلى تقليل حجم المشهد ، حيث أنه أثناء <b>التجميع الثابت ،</b> يتم نسخ بيانات الشبكة <b>الجاهزة السابقة</b> في أي حال من المرات بقدر تمثيل الكائنات المرسومة النشطة مع هذه الشبكة في المشهد.  تحرر طريقتنا أيضًا مساحة في أطالس الملمس ، مثل <b>خريطة الإضاءة</b> .  نحن نستخدم المساحة المحفوظة لزيادة تفاصيل تلك الأجزاء من النماذج التي نجت من التنظيف. <br><br><h3 style=";text-align:right;direction:rtl">  3D المحاصيل </h3><br>  ومع ذلك ، من الأفضل أن يتمكن الفنان من قطع كل ما هو غير ضروري في محرره ، مما يقلل من عدد مراحل إعداد المحتوى.  هذا له ما يبرره عندما يتم استخدام النموذج في مشهد واحد فقط مع دوران محدد مسبقا بالنسبة للكاميرا.  في السابق ، غالبًا ما كانت الكائنات التي يتم تحويلها إلى المستخدم من جانب واحد يتم تبسيطها يدويًا قبل الاندماج في المشروع.  من المهم الإشارة إلى أن تنفيذ هذا التبسيط برمجيًا في <b>الوحدة يعد</b> أكثر صعوبة نظرًا لتعقيد تطوير التغليف <b>بالأشعة فوق البنفسجية</b> ، لذا فإن التشغيل التلقائي في مرحلة الحزمة ثلاثية الأبعاد يجعل الحياة في بعض الأحيان أسهل للفنان. <br><br>  تعتبر <b>Blender</b> إحدى أدوات العمل مع النماذج ثلاثية الأبعاد في شركتنا.  لقد صعدنا فيه.  يبدو أن مثل هذا البرنامج "للبالغين" ، مثل <b>Blender</b> ، يجب أن يكون له وظائف مماثلة.  ومع ذلك ، اتضح أنه لا ينبغي.  اضطررت إلى رؤية دراجتي الخاصة. <br><br>  كانت الفكرة الأولى هي استخدام أداة التحديد المألوفة - كرر جزءًا أساسيًا من العمل اليدوي للفنان لزاوية كاميرا واحدة: حدد المضلعات المرئية ، التحديد العكسي ، الحذف.  كانت الخطة كما يلي: حرك الكاميرا ، حدد إسقاط <b>AABB</b> للطراز في كل موضع ، ثم اطلب نتيجة اختيار المضلعات في المنطقة المقابلة لـ <b>AABB</b> ، واحصل على اتحاد مجموعة المضلعات في العرض الحالي مع السابق ، وحذف المضلعات غير المحددة في النهاية. <br><br>  ومع ذلك ، أثناء تنفيذ البرنامج النصي ، تم العثور على عيب كبير من حيث المهمة.  <a href="https://blender.stackexchange.com/questions/43886/why-wont-lasso-or-box-select-select-all-of-the-faces-in-the-region/93482">تفقد</a> أدوات التحديد في <b>Blender (تحديد المستطيل وحدد الدائرة)</b> <a href="https://blender.stackexchange.com/questions/43886/why-wont-lasso-or-box-select-select-all-of-the-faces-in-the-region/93482">الدقة</a> مع زيادة عدد العناصر المحددة لكل وحدة مساحة من الشاشة (تظل بعض المضلعات غير محددة) ، مما يجعل استخدامها في أدوات التشغيل الآلي لدينا مستحيلًا.  حقيقة مثيرة للاهتمام: في نفس <b>3ds ماكس</b> لم يلاحظ مثل هذه المشكلة. <br><br><img src="https://habrastorage.org/webt/ai/rr/bf/airrbf1enz0jfiucjtrhrbzv8bw.jpeg"><br>  <i>تسليط الضوء من بعيد في <b>Blender</b></i> <br><br><img src="https://habrastorage.org/webt/gt/vy/mh/gtvymh56yk7vp5lrwsvuav4fjqq.jpeg"><br>  <i>نتيجة الاختيار</i> <br><br>  كانت المحاولة التالية تهدف إلى حل المشكلة في الجبهة: لقد أرسلنا أشعة من الكاميرا عبر كل بكسل من منفذ العرض ونظرنا في المضلعات التي كانت أول من يتقاطع مع شعاع واحد على الأقل.  لم نكن نأمل نتائج دقيقة مع هذا النهج ، لكن الأمر يستحق المحاولة.  والنتيجة واضحة: إنتاجية منخفضة للغاية عند المعالجة على <b>وحدة المعالجة المركزية</b> أو نفس الثقوب بعدد صغير من الأشعة. <br><br>  ومع ذلك ، قطعنا موطئ قدم لتنفيذ نهج أكثر تقدما.  كانت الفكرة هي تحديد عدد معين من النقاط العشوائية على كل مضلع ثم إرسال أشعة من الكاميرا في اتجاهها.  لقد نجح هذا النهج جيدًا ، لكن كان لدينا بعض حالات الخطوط الحدودية: تم قطع المضلعات أيضًا ، حيث كانت الزاوية بين الحزمة والعادي لها تساوي تقريبًا π / 2.  وبالتالي ، عند تكبير الكاميرا بسبب تشوهات المنظور ، يمكن فتح مناطق القطع. <br><br>  كانت هذه الطريقة ، في رأي الفنانين ، عدوانية للغاية ، لذلك قررنا التركيز على <b>اقتصاص الأوجه الخلفية</b> فقط. <br><br><h3 style=";text-align:right;direction:rtl">  استنتاج </h3><br>  ليس سراً أن الموقف الدقيق لموارد الجهاز عند إنشاء الألعاب هو العامل الأكثر أهمية الذي يؤثر على جودة المنتج النهائي.  هذا ينطبق بشكل خاص على المنصات المحمولة ، مزاجي للاستخدام النشط لذاكرة الوصول العشوائي.  يتيح لك تقليل عدد المضلعات ملء مساحة الأطالس الملمسية بشكل أكثر فاعلية وتقليل الحمل الحسابي بشكل طفيف. <br><br>  أيضًا ، لا تنسَ تكلفة ساعات العمل وتكلفة الأخطاء عند استخدام الأدوات المذكورة أعلاه وما شابه ذلك.  النهج المقترح يفترض وجود خط أنابيب يعمل بشكل جيد لعمل قسم الفن ، وخاصة الموظفين المشاركين في دمج النماذج في المشروع. <br><br>  وبالتالي ، بعد أن تمت مناقشة الشروط والأدوات في هذه المقالة ، فإننا نلتزم بالقواعد التالية.  إذا كان من المفترض أن النموذج الذي تم إنشاؤه سيتم تشغيله دائمًا من جانب واحد للمستخدم ، وأيضًا إذا كان التداخل بين بعض أجزاء النموذج من قِبل الآخرين ضئيلًا جدًا ، يستخدم الفنان <b>أداة</b> القطع <b>الخلفية</b> في المحرر ثلاثي الأبعاد ، ويتحقق من الصحة <b>ويستمر</b> في تطوير التغليف <b>UV-</b> .  إذا كان النموذج غالبًا ما يستخدم في مواضع مختلفة أو بهندسة أكثر تعقيدًا ، فبعد الاستيراد في المشروع ، نقوم بتشغيل الخوارزمية الموضحة في الجزء الأول من المقالة ، ونقوم بمعالجة جميع الكائنات الساكنة في المشهد معها. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar484792/">https://habr.com/ru/post/ar484792/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar484776/index.html">الأحداث الرقمية في سان بطرسبرج من 21 إلى 26 يناير</a></li>
<li><a href="../ar484778/index.html">Intel Parallel Studio XE 2020: كل التوفيق للمطورين</a></li>
<li><a href="../ar484782/index.html">Blazor Client Side Store على الإنترنت: الجزء 2 - CI / CD</a></li>
<li><a href="../ar484788/index.html">المزيد من الميزات لنظامك: التكامل الهاتفي و CRM / ERP / مكتب المساعدة. ماذا وكيف ولماذا؟</a></li>
<li><a href="../ar484790/index.html">قصة كيف ، بسبب خيار واحد على خادم ويندوز ، تباطأت مواقعنا</a></li>
<li><a href="../ar484796/index.html">كيف حصلت على شهادة OSWE؟</a></li>
<li><a href="../ar484798/index.html">لماذا فرز سريع بطيئة حقا؟ طريقة فرز صفيف جديدة</a></li>
<li><a href="../ar484800/index.html">مايكروسوفت تطبيق المفتش المصدر رمز محلل</a></li>
<li><a href="../ar484802/index.html">وضع التدمير الذاتي: تحلل الكبسولة بالمنظار بسبب الضوء</a></li>
<li><a href="../ar484804/index.html">ماذا تشفير في نظام الشركات؟ ولماذا هذا؟</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>