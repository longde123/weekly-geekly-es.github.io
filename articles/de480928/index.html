<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò§ üëºüèº üë©üèª‚Äçüî¨ Apache Hadoop Code Qualit√§t: Produktion VS Test üßìüèª üò™ üòù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Um qualitativ hochwertigen Produktionscode zu erhalten, reicht es nicht aus, nur eine maximale Testabdeckung bereitzustellen. Zweifellos m√ºssen der Ha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apache Hadoop Code Qualit√§t: Produktion VS Test</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/480928/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c48/f76/cf1/c48f76cf15c8138ce1d944918b1dcc07.png" alt="Abbildung 1"></div><br>  Um qualitativ hochwertigen Produktionscode zu erhalten, reicht es nicht aus, nur eine maximale Testabdeckung bereitzustellen.  Zweifellos m√ºssen der Hauptprojektcode und die Tests in einem vollkommen zusammenh√§ngenden Tandem zusammenarbeiten, um hohe Ergebnisse zu erzielen.  Daher m√ºssen Sie den Tests genau so viel Aufmerksamkeit schenken wie dem Hauptcode.  Das Schreiben eines guten Tests ist der Schl√ºssel, um eine Regression in der Produktion zu erkennen.  Um zu zeigen, wie wichtig es ist, dass Fehler in Tests nicht schlechter sind als in der Produktion, werden wir die n√§chste Analyse der Warnungen des statischen Analysators PVS-Studio in Betracht ziehen.  Ziel: Apache Hadoop. <br><a name="habracut"></a><br><h2>  √úber das Projekt </h2><br>  Diejenigen, die sich einst f√ºr Big Data interessierten, haben wahrscheinlich schon von einem Projekt wie <a href="https://hadoop.apache.org/">Apache Hadoop</a> geh√∂rt oder mit ihm gearbeitet.  Kurz gesagt, Hadoop ist ein Framework, das als Grundlage f√ºr das Erstellen und Arbeiten mit Big Data-Systemen verwendet werden kann. <br><br>  Hadoop besteht aus vier Hauptmodulen, die jeweils eine bestimmte Aufgabe erf√ºllen, die f√ºr ein Big-Data-Analysesystem erforderlich ist: <br><br><ul><li>  Hadoop gemeinsam </li><li>  Mapreduce </li><li>  Hadoop Distributed File System (verteiltes Hadoop-Dateisystem) </li><li>  Garn </li></ul><br>  Es gibt jedoch viele Materialien, mit denen Sie sich im Internet vertraut machen k√∂nnen. <br><br><h2>  √úber die √úberpr√ºfung </h2><br>  Wie in der <a href="https://www.viva64.com/ru/m/0044/">Dokumentation gezeigt</a> , kann PVS-Studio auf verschiedene Arten in das Projekt integriert werden: <br><br><ul><li>  mit Maven Plugin; </li><li>  Gradle Plugin verwenden; </li><li>  Verwenden von IntellJ IDEA </li><li>  Verwenden Sie den Analysator direkt. </li></ul><br>  Hadoop wurde auf der Basis des Maven-Build-Systems erstellt, so dass bei der √úberpr√ºfung keine Schwierigkeiten auftraten. <br><br>  Nachdem das Skript aus der Dokumentation integriert und eines von pom.xml leicht angepasst wurde (es gab Module in den Abh√§ngigkeiten, die nicht vorhanden waren), ging die Analyse! <br><br>  Nach der Analyse, bei der Auswahl der interessantesten Warnungen, stellte ich fest, dass sowohl im Produktionscode als auch in den Tests die gleiche Anzahl von Warnungen vorhanden war.  Normalerweise denke ich nicht √ºber das Ausl√∂sen des Analysators nach, das auf Tests f√§llt.  Aber als ich sie aufteilte, konnte ich die Warnungen aus der Kategorie "Tests", die hinter meiner Aufmerksamkeit lagen, nicht verfehlen.  ‚ÄûWarum nicht?‚Äú, Dachte ich, denn Fehler in Tests haben auch Konsequenzen.  Sie k√∂nnen zu fehlerhaften oder teilweisen Tests oder sogar zu Unsinn f√ºhren (nur zur Schau, damit sie immer gr√ºn sind). <br><br>  Nachdem Sie die interessantesten Warnungen gesammelt und nach Code (Produktion, Test) und den vier Hauptmodulen von Hadoop unterteilt haben, m√∂chte ich Sie auf eine Analyse der Funktionsweise des Analyseger√§ts aufmerksam machen. <br><br><h2>  Produktionscode </h2><br><h3>  Hadoop gemeinsam </h3><br>  <a href="https://www.viva64.com/ru/w/v6033/">V6033</a> Ein Artikel mit demselben Schl√ºssel 'KDC_BIND_ADDRESS' wurde bereits hinzugef√ºgt.  MiniKdc.java (163), MiniKdc.java (162) <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MiniKdc</span></span></span><span class="hljs-class"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Set&lt;String&gt; PROPERTIES = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;String&gt;(); .... <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { PROPERTIES.add(ORG_NAME); PROPERTIES.add(ORG_DOMAIN); PROPERTIES.add(KDC_BIND_ADDRESS); PROPERTIES.add(KDC_BIND_ADDRESS); <span class="hljs-comment"><span class="hljs-comment">// &lt;= PROPERTIES.add(KDC_PORT); PROPERTIES.add(INSTANCE); .... } .... }</span></span></code> </pre> <br>  Ein zweimaliger Mehrwert f√ºr ein <i>HashSet</i> ist ein h√§ufiger Fehler beim √úberpr√ºfen von Projekten.  Tats√§chlich wird der zweite Zusatz ignoriert.  Nun, wenn diese Vervielf√§ltigung ein absurder Zufall ist.  Was aber, wenn es wirklich bedeutete, einen weiteren Wert hinzuzuf√ºgen? <br><br><h3>  Mapreduce </h3><br>  <a href="https://www.viva64.com/ru/w/v6072/">V6072</a> Es wurden zwei √§hnliche Codefragmente gefunden.  M√∂glicherweise ist dies ein Tippfehler, und die Variable 'localFiles' sollte anstelle von 'localArchives' verwendet werden.  LocalDistributedCacheManager.java (183), LocalDistributedCacheManager.java (178), LocalDistributedCacheManager.java (176), LocalDistributedCacheManager.java (181) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JobConf conf, JobID jobId)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">// Update the configuration object with localized data. if (!localArchives.isEmpty()) { conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils .arrayToString(localArchives.toArray(new String[localArchives // &lt;= .size()]))); } if (!localFiles.isEmpty()) { conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils .arrayToString(localFiles.toArray(new String[localArchives // &lt;= .size()]))); } .... }</span></span></code> </pre> <br>  Diagnose V6072 macht manchmal sehr interessante Ergebnisse.  Bei der Diagnose geht es im Wesentlichen darum, nach denselben Codefragmenttypen zu suchen, die durch Kopieren und Ersetzen von ein oder zwei Variablen erhalten wurden. Gleichzeitig wurden einige der Variablen jedoch ‚Äûuntersch√§tzt‚Äú. <br><br>  Der obige Code demonstriert dies.  Im ersten Block werden Aktionen mit der Variablen <i>localArchives ausgef√ºhrt</i> , im n√§chsten Block desselben Typs mit <i>localFiles</i> .  Wenn Sie diesen Code gewissenhaft studieren und ihn nicht schnell durchgehen, wie dies bei der <i>Code√ºberpr√ºfung</i> h√§ufig der Fall ist, <i>notieren</i> Sie sich die Stelle, an der Sie vergessen haben, die Variable <i>localArchives</i> zu ersetzen. <br><br>  Ein solches Versehen k√∂nnte zu folgendem Szenario f√ºhren: <br><br><ul><li>  Angenommen, wir haben <i>localArchives</i> (Gr√∂√üe = 4) und <i>localFiles</i> (Gr√∂√üe = 2). </li><li>  Beim Erstellen des Arrays <i>localFiles.toArray (neuer String [localArchives.size ()])</i> werden die letzten beiden Elemente als <i>null</i> (["pathToFile1", "pathToFile2", null, null]); </li><li>  Danach gibt <i>org.apache.hadoop.util.StringUtils.arrayToString</i> eine Zeichenfolgendarstellung unseres Arrays zur√ºck, in der die letzten Dateinamen als "null" dargestellt werden ("pathToFile1, pathToFile2, null, null" <i>)</i> ; </li><li>  All dies wird weitergegeben, und wer wei√ü, welche Pr√ºfungen es f√ºr solche F√§lle gibt =). </li></ul><br>  <a href="https://www.viva64.com/ru/w/v6007/">V6007</a> Ausdruck 'children.size ()&gt; 0' ist immer wahr.  Queue.java (347) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isHierarchySameAs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Queue newState)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (children == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || children.size() == <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(children.size() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... } .... }</code> </pre> <br>  Aufgrund der Tatsache, dass die √úberpr√ºfung der Anzahl der Elemente bei 0 separat erfolgt, ergibt eine weitere √úberpr√ºfung von <i>children.size ()&gt; 0</i> immer true. <br><br><h3>  HDFS </h3><br>  <a href="https://www.viva64.com/ru/w/v6001/">V6001</a> Links und rechts vom Operator '%' gibt es identische Unterausdr√ºcke 'this.bucketSize'.  RollingWindow.java (79) <br><br><pre> <code class="java hljs"> RollingWindow(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> windowLenMs, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numBuckets) { buckets = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bucket[numBuckets]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numBuckets; i++) { buckets[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bucket(); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.windowLenMs = windowLenMs; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bucketSize = windowLenMs / numBuckets; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bucketSize % bucketSize != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= throw new IllegalArgumentException( "The bucket size in the rolling window is not integer: windowLenMs= " + windowLenMs + " numBuckets= " + numBuckets); } }</span></span></code> </pre> <br>  Dieser Mangel liegt darin, dass die Variable in sich selbst unterteilt ist.  Infolgedessen wird die Pr√ºfung auf Multiplizit√§t immer bestanden, und im Falle falscher Eingabedaten ( <i>windowLenMs</i> , <i>numBuckets</i> ) wird die Ausnahme nicht ausgel√∂st. <br><br><h3>  Garn </h3><br>  <a href="https://www.viva64.com/ru/w/v6067/">V6067</a> Zwei oder mehr <a href="https://www.viva64.com/ru/w/v6067/">Fallzweige</a> f√ºhren die gleichen Aktionen aus.  TimelineEntityV2Converter.java (386), TimelineEntityV2Converter.java (389) <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ApplicationReport </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToApplicationReport</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TimelineEntity entity)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (metrics != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> vcoreSeconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> memorySeconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> preemptedVcoreSeconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> preemptedMemorySeconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (TimelineMetric metric : metrics) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (metric.getId()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ApplicationMetricsConstants.APP_CPU_METRICS: vcoreSeconds = getAverageValue(metric.getValues().values()); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ApplicationMetricsConstants.APP_MEM_METRICS: memorySeconds = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ApplicationMetricsConstants.APP_MEM_PREEMPT_METRICS: preemptedVcoreSeconds = ....; <span class="hljs-comment"><span class="hljs-comment">// &lt;= break; case ApplicationMetricsConstants.APP_CPU_PREEMPT_METRICS: preemptedVcoreSeconds = ....; // &lt;= break; default: // Should not happen.. break; } } .... } .... }</span></span></code> </pre> <br>  In zwei <i>F√§llen</i> werden dieselben Codefragmente verzweigt.  Das passiert die ganze Zeit!  In der √ºberwiegenden Anzahl von F√§llen handelt es sich nicht um einen echten Fehler, sondern nur um eine Gelegenheit, √ºber das Umgestalten von <i>Switches</i> nachzudenken.  Aber nicht f√ºr den fraglichen Fall.  Wiederholende Codefragmente legen den Wert der Variablen <i>preemptedVcoreSeconds fest</i> .  Wenn Sie auf die Namen aller Variablen und Konstanten achten, k√∂nnen Sie zu dem Schluss kommen, dass im Fall von <i>metric.getId () == APP_MEM_PREEMPT_METRICS</i> der Wert der Variablen <i>preemptedMemorySeconds festgelegt</i> werden sollte und nicht <i>preemptedVcoreSeconds</i> .  In diesem Zusammenhang bleibt preemptedMemorySeconds nach Ausf√ºhrung der Anweisung 'switch' immer auf 0, und der Wert von <i>preemptedVcoreSeconds ist</i> m√∂glicherweise falsch. <br><br>  <a href="https://www.viva64.com/ru/w/v6046/">V6046</a> Falsches Format.  Eine andere Anzahl von Formatelementen wird erwartet.  Nicht verwendete Argumente: 2. AbstractSchedulerPlanFollower.java (186) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">synchronizePlan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Plan plan, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shouldReplan)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { setQueueEntitlement(planQueueName, ....); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (YarnException e) { LOG.warn(<span class="hljs-string"><span class="hljs-string">"Exception while trying to size reservation for plan: {}"</span></span>, currResId, planQueueName, e); } .... }</code> </pre> <br>  Nicht verwendete Variable <i>planQueueName</i> bei der Protokollierung.  Hier haben sie entweder zu viel kopiert oder die Formatzeichenfolge nicht ge√§ndert.  Trotzdem neige ich zum guten alten und manchmal schlechten Kopieren und Einf√ºgen. <br><br><h2>  Code testen </h2><br><h3>  Hadoop gemeinsam </h3><br>  <a href="https://www.viva64.com/ru/w/v6072/">V6072</a> Es wurden zwei √§hnliche Codefragmente gefunden.  M√∂glicherweise ist dies ein Tippfehler, und die Variable 'allSecretsB' sollte anstelle von 'allSecretsA' verwendet werden.  TestZKSignerSecretProvider.java (316), TestZKSignerSecretProvider.java (309), TestZKSignerSecretProvider.java (306), TestZKSignerSecretProvider.java (313) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testMultiple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> order)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ .... currentSecretA = secretProviderA.getCurrentSecret(); allSecretsA = secretProviderA.getAllSecrets(); Assert.assertArrayEquals(secretA2, currentSecretA); Assert.assertEquals(<span class="hljs-number"><span class="hljs-number">2</span></span>, allSecretsA.length); <span class="hljs-comment"><span class="hljs-comment">// &lt;= Assert.assertArrayEquals(secretA2, allSecretsA[0]); Assert.assertArrayEquals(secretA1, allSecretsA[1]); currentSecretB = secretProviderB.getCurrentSecret(); allSecretsB = secretProviderB.getAllSecrets(); Assert.assertArrayEquals(secretA2, currentSecretB); Assert.assertEquals(2, allSecretsA.length); // &lt;= Assert.assertArrayEquals(secretA2, allSecretsB[0]); Assert.assertArrayEquals(secretA1, allSecretsB[1]); .... }</span></span></code> </pre> <br>  Und wieder V6072.  Achten Sie auf die Variablen <i>allSecretsA</i> und <i>allSecretsB</i> . <br><br>  <a href="https://www.viva64.com/ru/w/v6043/">V6043</a> Betrachten Sie den Operator 'f√ºr'.  Anfangs- und Endwert des Iterators sind gleich.  TestTFile.java (235) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readPrepWithUnknownLength</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Scanner scanner, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = start; i &lt; start; i++) { String key = String.format(localFormatter, i); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] read = readKey(scanner); assertTrue(<span class="hljs-string"><span class="hljs-string">"keys not equal"</span></span>, Arrays.equals(key.getBytes(), read)); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { read = readValue(scanner); assertTrue(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException ie) { <span class="hljs-comment"><span class="hljs-comment">// should have thrown exception } String value = "value" + key; read = readLongValue(scanner, value.getBytes().length); assertTrue("values nto equal", Arrays.equals(read, value.getBytes())); scanner.advance(); } return (start + n); }</span></span></code> </pre> <br>  Ein Test, der immer gr√ºn ist?  =).  Der Body der Schleife, der Teil des Tests ist, wird niemals ausgef√ºhrt.  Dies liegt daran, dass die Start- und Endwerte des Z√§hlers in der <i>for-</i> Anweisung √ºbereinstimmen.  Infolgedessen gibt die Bedingung <i>i &lt;start</i> sofort false aus, was zu diesem Verhalten f√ºhrt.  Ich habe die Datei mit den Tests durchgesehen und bin zu dem Schluss gekommen, dass im Zustand der Schleife <i>i &lt;(start + n) geschrieben werden muss</i> . <br><br><h3>  Mapreduce </h3><br>  a href = " <a href="https://www.viva64.com/ru/w/v6007/">www.viva64.com/de/w/v6007</a> "&gt; V6007 Der Ausdruck 'byteAm &lt;0' ist immer falsch.  DataWriter.java (322) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">GenerateOutput </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeSegment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> byteAm, OutputStream out)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> headerLen = getHeaderLength(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (byteAm &lt; headerLen) { <span class="hljs-comment"><span class="hljs-comment">// not enough bytes to write even the header return new GenerateOutput(0, 0); } // adjust for header length byteAm -= headerLen; if (byteAm &lt; 0) { // &lt;= byteAm = 0; } .... }</span></span></code> </pre> <br>  Die Bedingung <i>byteAm &lt;0 ist</i> immer falsch.  Um das zu verstehen, gehen wir den obigen Code durch.  Wenn die Testausf√ºhrung die Operation <i>byteAm - = headerLen erreicht</i> , bedeutet dies, dass es <i>byteAm&gt; = headerLen gibt</i> .  Ab hier ist der Wert von <i>byteAm</i> nach der Subtraktion niemals negativ.  Welches war erforderlich, um zu beweisen. <br><br><h3>  HDFS </h3><br>  <a href="https://www.viva64.com/ru/w/v6072/">V6072</a> Es wurden zwei √§hnliche Codefragmente gefunden.  M√∂glicherweise ist dies ein Tippfehler, und die Variable 'normalFile' sollte anstelle von 'normalDir' verwendet werden.  TestWebHDFS.java (625), TestWebHDFS.java (615), TestWebHDFS.java (614), TestWebHDFS.java (624) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testWebHdfsErasureCodingFiles</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Path normalDir = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Path(<span class="hljs-string"><span class="hljs-string">"/dir"</span></span>); dfs.mkdirs(normalDir); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Path normalFile = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Path(normalDir, <span class="hljs-string"><span class="hljs-string">"file.log"</span></span>); .... <span class="hljs-comment"><span class="hljs-comment">// logic block #1 FileStatus expectedNormalDirStatus = dfs.getFileStatus(normalDir); FileStatus actualNormalDirStatus = webHdfs.getFileStatus(normalDir); // &lt;= Assert.assertEquals(expectedNormalDirStatus.isErasureCoded(), actualNormalDirStatus.isErasureCoded()); ContractTestUtils.assertNotErasureCoded(dfs, normalDir); assertTrue(normalDir + " should have erasure coding unset in " + ....); // logic block #2 FileStatus expectedNormalFileStatus = dfs.getFileStatus(normalFile); FileStatus actualNormalFileStatus = webHdfs.getFileStatus(normalDir); // &lt;= Assert.assertEquals(expectedNormalFileStatus.isErasureCoded(), actualNormalFileStatus.isErasureCoded()); ContractTestUtils.assertNotErasureCoded(dfs, normalFile); assertTrue( normalFile + " should have erasure coding unset in " + ....); }</span></span></code> </pre> <br>  Glauben Sie es nicht, und wieder V6072!  <i>Folgen Sie</i> <i>einfach den Variablen</i> <i>normalDir</i> und <i>normalFile</i> <br><br>  <a href="https://www.viva64.com/ru/w/v6027/">V6027</a> Variablen werden durch Aufruf derselben Funktion initialisiert.  Es ist wahrscheinlich ein Fehler oder nicht optimierter Code.  TestDFSAdmin.java (883), TestDFSAdmin.java (879) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verifyNodesAndCorruptBlocks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numDn, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numLiveDn, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numCorruptBlocks, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numCorruptECBlockGroups, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DFSClient client, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Long highestPriorityLowRedundancyReplicatedBlocks, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Long highestPriorityLowRedundancyECBlocks)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* init vars */</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String expectedCorruptedECBlockGroupsStr = String.format( <span class="hljs-string"><span class="hljs-string">"Block groups with corrupt internal blocks: %d"</span></span>, numCorruptECBlockGroups); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String highestPriorityLowRedundancyReplicatedBlocksStr = String.format( <span class="hljs-string"><span class="hljs-string">"\tLow redundancy blocks with highest priority "</span></span> + <span class="hljs-string"><span class="hljs-string">"to recover: %d"</span></span>, highestPriorityLowRedundancyReplicatedBlocks); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String highestPriorityLowRedundancyECBlocksStr = String.format( <span class="hljs-string"><span class="hljs-string">"\tLow redundancy blocks with highest priority "</span></span> + <span class="hljs-string"><span class="hljs-string">"to recover: %d"</span></span>, highestPriorityLowRedundancyReplicatedBlocks); .... }</code> </pre> <br>  In diesem Fragment werden die Variablen <i>highestPriorityLowRedundancyReplicatedBlocksStr</i> und <i>highestPriorityLowRedundancyECBlocksStr</i> mit denselben Werten initialisiert.  Oft sollte es sein, aber nicht in dieser Situation.  Die Variablennamen hier sind lang und √§hnlich, daher wundert es mich nicht, dass beim Kopieren und Einf√ºgen keine entsprechenden √Ñnderungen vorgenommen wurden.  Um die Situation zu korrigieren, m√ºssen Sie beim Initialisieren der Variablen <i>highestPriorityLowRedundancyECBlocksStr</i> den Eingabeparameter <i>highestPriorityLowRedundancyECBlocks verwenden</i> .  Dar√ºber hinaus m√ºssen Sie h√∂chstwahrscheinlich die Formatzeichenfolge noch korrigieren. <br><br>  <a href="https://www.viva64.com/ru/w/v6019/">V6019</a> Nicht erreichbarer Code erkannt.  M√∂glicherweise liegt ein Fehler vor.  TestReplaceDatanodeFailureReplication.java (222) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verifyFileContent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., SlowWriter[] slowwriters)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ LOG.info(<span class="hljs-string"><span class="hljs-string">"Verify the file"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; slowwriters.length; i++) { LOG.info(slowwriters[i].filepath + ....); FSDataInputStream in = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { in = fs.open(slowwriters[i].filepath); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>, x;; j++) { x = in.read(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((x) != -<span class="hljs-number"><span class="hljs-number">1</span></span>) { Assert.assertEquals(j, x); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { IOUtils.closeStream(in); } } }</code> </pre> <br>  Der Analysator schw√∂rt, dass das √Ñndern des <i>i ++ -</i> Z√§hlers in der Schleife nicht m√∂glich ist.  Dies bedeutet, dass in einer <i>for-</i> Schleife <i>(int i = 0; i &lt;slowwriters.length; i ++) {....}</i> nicht mehr als eine Iteration ausgef√ºhrt wird.  Finden wir heraus warum.  In der ersten Iteration verkn√ºpfen wir den Stream zum weiteren Lesen mit der Datei, die den <i>Slowwritern [0]</i> entspricht.  Durch die <i>for-</i> Schleife <i>(int j = 0, x ;; j ++)</i> lesen <i>wir</i> den Inhalt der Datei byteweise, wobei: <br><br><ul><li>  Wenn wir etwas <i>passendes</i> lesen, vergleichen <i>wir</i> das gelesene Byte √ºber <i>assertEquals</i> mit dem aktuellen Wert des Z√§hlers <i>j</i> (wenn die √úberpr√ºfung nicht erfolgreich ist, verlassen wir den Test mit fail). </li><li>  Wenn die Datei den Test bestanden hat und wir das Ende der Datei erreicht haben (read -1), verlassen wir die Methode. </li></ul><br>  <i>Unabh√§ngig davon</i> , was beim √úberpr√ºfen von <i>Slowwritern [0]</i> geschieht, kommt es daher nicht zur √úberpr√ºfung der folgenden Elemente.  H√∂chstwahrscheinlich sollte <i>break</i> anstelle von <i>return verwendet werden</i> . <br><br><h3>  Garn </h3><br>  <a href="https://www.viva64.com/ru/w/v6019/">V6019</a> Nicht erreichbarer Code erkannt.  M√∂glicherweise liegt ein Fehler vor.  TestNodeManager.java (176) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testCreationOfNodeLabelsProviderService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InterruptedException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { Assert.fail(<span class="hljs-string"><span class="hljs-string">"Exception caught"</span></span>); e.printStackTrace(); } }</code> </pre> <br>  In diesem <i>Fall</i> wird die <i>Stapelverfolgung</i> niemals gedruckt, wenn eine Ausnahme auftritt, da die <i>Assert.fail-</i> Methode den Test unterbricht.  Wenn gen√ºgend Meldungen vorliegen, dass die Ausnahme abgefangen wurde, muss der Stacktrace'a-Druck entfernt werden, um Verwirrung zu vermeiden.  Wenn Drucken erforderlich ist, m√ºssen Sie sie nur austauschen. <br><br>  Es gibt viele solcher Orte: <ul><li>  V6019 Nicht erreichbarer Code erkannt.  M√∂glicherweise liegt ein Fehler vor.  TestResourceTrackerService.java (928) </li><li>  V6019 Nicht erreichbarer Code erkannt.  M√∂glicherweise liegt ein Fehler vor.  TestResourceTrackerService.java (737) </li><li>  V6019 Nicht erreichbarer Code erkannt.  M√∂glicherweise liegt ein Fehler vor.  TestResourceTrackerService.java (685) </li><li>  .... </li></ul><br>  <a href="https://www.viva64.com/ru/w/v6072/">V6072</a> Es wurden zwei √§hnliche Codefragmente gefunden.  M√∂glicherweise ist dies ein Tippfehler, und die Variable 'publicCache' sollte anstelle von 'usercache' verwendet werden.  TestResourceLocalizationService.java (315), TestResourceLocalizationService.java (309), TestResourceLocalizationService.java (307), TestResourceLocalizationService.java (313) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testDirectoryCleanupOnNewlyCreatedStateStore</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException, URISyntaxException </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">// verify directory creation for (Path p : localDirs) { p = new Path((new URI(p.toString())).getPath()); // logic block #1 Path usercache = new Path(p, ContainerLocalizer.USERCACHE); verify(spylfs).rename(eq(usercache), any(Path.class), any()); // &lt;= verify(spylfs).mkdir(eq(usercache), ....); // logic block #2 Path publicCache = new Path(p, ContainerLocalizer.FILECACHE); verify(spylfs).rename(eq(usercache), any(Path.class), any()); // &lt;= verify(spylfs).mkdir(eq(publicCache), ....); .... } .... }</span></span></code> </pre> <br>  Und zum Schluss nochmal V6072 =).  Variablen, um sich mit einem verd√§chtigen Fragment vertraut zu machen: <i>usercache</i> und <i>publiccache</i> . <br><br><h2>  Fazit </h2><br>  W√§hrend der Entwicklung werden Hunderttausende von Codezeilen geschrieben.  Wenn der Produktionscode versucht, Fehler, M√§ngel und M√§ngel zu beseitigen (der Entwickler testet seinen eigenen Code, f√ºhrt eine Code√ºberpr√ºfung durch und vieles mehr), sind die Tests dem eindeutig unterlegen.  Fehler in Tests k√∂nnen sich leise hinter einem "gr√ºnen H√§kchen" verstecken.  Und wie Sie aus der heutigen Analyse von Warnungen verstehen, ist ein erfolgreich bestandener Test keineswegs immer ein garantierter Test. <br><br>  Bei der √úberpr√ºfung der Apache Hadoop-Codebasis hat die statische Analyse gezeigt, dass nicht nur der Code in der Produktion ben√∂tigt wird, sondern auch Tests, die auch bei der Entwicklung eine wichtige Rolle spielen. <br><br>  Wenn Sie also Wert auf die Qualit√§t Ihres Codes und Ihrer Testbasis legen, empfehle ich Ihnen, sich mit statischen Analysen zu befassen.  Und der erste Bewerber f√ºr den Test, den ich vorschlage, <a href="https://www.viva64.com/ru/pvs-studio-download/">PVS-Studio</a> auszuprobieren. <br><br><p> <a href="https://habr.com/en/company/pvs-studio/blog/480918/"><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br>  Wenn Sie diesen Artikel mit einem englischsprachigen Publikum teilen m√∂chten, verwenden Sie bitte den Link zur √úbersetzung: Maxim Stefanov.  <a href="https://habr.com/en/company/pvs-studio/blog/480918/">Apache Hadoop Code Qualit√§t: Produktion VS Test</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de480928/">https://habr.com/ru/post/de480928/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de480918/index.html">Apache Hadoop Code Qualit√§t: Produktion VS Test</a></li>
<li><a href="../de480920/index.html">Test von TP-Link Switches mit Long Range PoE. Und ein bisschen √ºber Upgrades alter Modelle</a></li>
<li><a href="../de480922/index.html">Evgeny Usvitsky: ‚ÄûJeder auf der Welt wei√ü, wo er Geodaten frei bekommen kann - nur in OSM‚Äú</a></li>
<li><a href="../de480924/index.html">Wie und warum haben die Macher des Remakes von MediEvil den Kult-Boss des Spiels neu gestaltet</a></li>
<li><a href="../de480926/index.html">Wahrscheinlichkeitstheorie f√ºr physikalisch genaues Rendern</a></li>
<li><a href="../de480930/index.html">Gib alles ein</a></li>
<li><a href="../de480936/index.html">Schnelle Konvertierung von UPPER_CASE nach camelCase</a></li>
<li><a href="../de480938/index.html">Kryptow√§hrung aus Sicht russischer Richter</a></li>
<li><a href="../de480940/index.html">F√ºhren Sie einen browser√ºbergreifenden UI-Test mit Cucumber und Selenoid in Gitlab CI mit Allure-Bericht aus</a></li>
<li><a href="../de480944/index.html">Top 5 Trends im E-Mail-Marketing im Jahr 2020</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>