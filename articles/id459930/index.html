<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📭 👩🏽‍⚕️ 👨🏻‍⚖️ Otomasi impor Python 😖 🐙 🧟</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Untuk  Setelah 

import math import os.path import requests # 100500 other imports print(math.pi) print(os.path.join('my', 'path')) print(requests.get...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Otomasi impor Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459930/"><div class="scrollable-table"><table><tbody><tr><th>  Untuk </th><th>  Setelah </th></tr><tr><td><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> math <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-comment"><span class="hljs-comment"># 100500 other imports print(math.pi) print(os.path.join('my', 'path')) print(requests.get)</span></span></code> </pre> </td><td><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> smart_imports smart_imports.all() print(math.pi) print(os_path.join(<span class="hljs-string"><span class="hljs-string">'my'</span></span>, <span class="hljs-string"><span class="hljs-string">'path'</span></span>)) print(requests.get)</code> </pre></td></tr></tbody></table></div>  Kebetulan bahwa sejak 2012 saya telah mengembangkan browser open source, menjadi satu-satunya programmer.  Dengan Python dengan sendirinya.  Peramban bukanlah hal yang termudah, sekarang di bagian utama proyek ini terdapat lebih dari 1000 modul dan lebih dari 120.000 baris kode Python.  Secara total, ini akan menjadi satu setengah kali lebih banyak dengan proyek satelit. <br><br>  Pada titik tertentu, saya bosan mengotak-atik lantai impor di awal setiap file, dan saya memutuskan untuk menangani masalah ini untuk selamanya.  Jadi perpustakaan <b>smart_import</b> lahir ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pypi</a> ). <br><br>  Idenya cukup sederhana.  Setiap proyek kompleks pada akhirnya membentuk perjanjiannya sendiri untuk menamai semuanya.  <b>Jika perjanjian ini diubah menjadi aturan yang lebih formal, maka setiap entitas dapat diimpor secara otomatis dengan nama variabel yang terkait dengannya.</b> <br><br>  Misalnya, Anda tidak perlu menulis <code>import math</code> untuk mengakses <code>math.pi</code> - kita <code>math.pi</code> dapat memahami bahwa dalam hal ini <code>math</code> adalah modul perpustakaan standar. <br><br>  Impor pintar mendukung Python&gt; = 3.5. Perpustakaan sepenuhnya dicakup oleh tes, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cakupan&gt; 95%</a> .  Saya sudah menggunakannya sendiri selama satu tahun sekarang. <br><br>  Untuk detailnya, saya mengundang Anda ke Cat. <br><a name="habracut"></a><br><h2>  Bagaimana cara kerjanya secara umum? </h2><br>  Jadi, kode dari gambar header berfungsi sebagai berikut: <br><br><ol><li>  Selama panggilan ke <code>smart_imports.all()</code> perpustakaan membangun <abbr title="Pohon sintaksis abstrak">AST dari</abbr> modul dari mana panggilan itu dibuat; </li><li>  Temukan variabel yang tidak diinisialisasi; </li><li>  Kami menjalankan nama masing-masing variabel melalui urutan aturan yang mencoba menemukan modul (atau atribut modul) yang diperlukan untuk impor berdasarkan nama.  Jika aturan telah menemukan entitas yang diperlukan, aturan berikut ini tidak dicentang. </li><li>  Modul yang ditemukan dimuat, diinisialisasi dan ditempatkan di namespace global (atau atribut yang diperlukan dari modul ini ditempatkan di sana). </li></ol><br>  Variabel yang tidak diinisialisasi dicari di seluruh kode, termasuk sintaks baru. <br><br>  Impor otomatis diaktifkan hanya untuk komponen proyek yang secara eksplisit memanggil <code>smart_imoprts.all()</code> .  Selain itu, penggunaan impor pintar tidak melarang penggunaan impor konvensional.  Ini memungkinkan Anda untuk mengimplementasikan perpustakaan secara bertahap, serta menyelesaikan dependensi siklik yang rumit. <br><br>  Pembaca yang teliti akan memperhatikan bahwa modul AST dibangun dua kali: <br><br><ul><li>  CPython membangunnya untuk pertama kali selama impor modul; </li><li>  Kali kedua smart_import membangunnya saat panggilan ke <code>smart_imports.all()</code> . </li></ul><br>  AST benar-benar dapat dibangun hanya sekali (untuk ini Anda perlu mengintegrasikan ke dalam proses impor modul menggunakan kait impor diimplementasikan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PEP-0302</a> , tetapi solusi ini memperlambat impor. <br><br><div class="spoiler">  <b class="spoiler_title">Mengapa menurut Anda begitu?</b> <div class="spoiler_text">  Membandingkan kinerja dua implementasi (dengan dan tanpa kait), saya sampai pada kesimpulan bahwa ketika mengimpor modul, CPython membangun AST dalam struktur data internal (C-shh).  Mengubahnya ke struktur data Python lebih mahal daripada membangun pohon dari sumber menggunakan modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ast</a> . <br></div></div><br>  Tentu saja, AST dari setiap modul dibangun dan dianalisis hanya sekali per peluncuran. <br><br><h2>  Aturan Impor Default </h2><br>  Perpustakaan dapat digunakan tanpa konfigurasi tambahan.  Secara default, itu mengimpor modul sesuai dengan aturan berikut: <br><br><ol><li>  Secara kebetulan, nama itu mencari modul di sebelah yang sekarang (di direktori yang sama). </li><li>  Periksa modul perpustakaan standar: <br><ul><li>  dengan pencocokan tepat nama untuk paket tingkat atas; </li><li>  untuk paket dan modul bersarang, periksa nama majemuk, ganti titik dengan garis bawah.  Misalnya, <code>os.path</code> akan diimpor jika variabel <code>os_path</code> . </li></ul></li><li>  Dengan pencocokan nama yang tepat, ia mencari paket pihak ketiga yang diinstal.  Misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">permintaan</a> paket terkenal. </li></ol><br><h2>  Performa </h2><br>  Impor pintar tidak memengaruhi kinerja program, tetapi meningkatkan waktu yang diperlukan untuk memulai. <br><br>  Karena pembangunan kembali AST, waktu lari pertama meningkat sekitar 1,5-2 kali.  Untuk proyek kecil ini tidak signifikan.  Dalam proyek-proyek besar, waktu start-up menderita dari struktur ketergantungan antara modul daripada dari waktu impor modul tertentu. <br><br>  <s>Ketika</s> impor pintar menjadi populer, saya menulis ulang pekerjaan dari AST ke C - ini akan secara signifikan mengurangi biaya startup. <br><br>  Untuk mempercepat pemuatan, hasil pemrosesan modul AST dapat di-cache pada sistem file.  Caching diaktifkan di konfigurasi.  Tentu saja, cache dinonaktifkan ketika Anda mengubah sumbernya. <br><br>  Waktu start-up dipengaruhi oleh daftar aturan pencarian modul dan urutannya.  Karena beberapa aturan menggunakan fungsionalitas Python standar untuk mencari modul.  Anda dapat mengecualikan pengeluaran ini dengan secara eksplisit menunjukkan korespondensi nama dan modul menggunakan aturan "Nama Khusus" (lihat di bawah). <br><br><h2>  Konfigurasi </h2><br>  Konfigurasi default telah dijelaskan sebelumnya.  Seharusnya cukup untuk bekerja dengan perpustakaan standar dalam proyek-proyek kecil. <br><br><div class="spoiler">  <b class="spoiler_title">Konfigurasi default</b> <div class="spoiler_text"><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"cache_dir"</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">"rules"</span></span>: [{<span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"rule_local_modules"</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"rule_stdlib"</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"rule_predefined_names"</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"rule_global_modules"</span></span>}] }</code> </pre> <br></div></div><br>  Jika perlu, konfigurasi yang lebih kompleks dapat diletakkan pada sistem file. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh konfigurasi kompleks</a> (dari browser). <br><br>  Selama panggilan ke <code>smart_import.all()</code> perpustakaan menentukan posisi modul panggilan pada sistem file dan mulai mencari file <code>smart_imports.json</code> dalam arah dari direktori saat ini ke root.  Jika file tersebut ditemukan, itu dianggap sebagai konfigurasi untuk modul saat ini. <br><br>  Anda dapat menggunakan beberapa konfigurasi berbeda (menempatkannya di direktori yang berbeda). <br><br>  Tidak ada banyak opsi konfigurasi sekarang: <br><br><pre> <code class="json hljs">{ //     AST. //     null —   . <span class="hljs-attr"><span class="hljs-attr">"cache_dir"</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>|<span class="hljs-string"><span class="hljs-string">"string"</span></span>, //       . <span class="hljs-attr"><span class="hljs-attr">"rules"</span></span>: [] }</code> </pre> <br><h2>  Aturan Impor </h2><br>  Urutan menentukan aturan dalam konfigurasi menentukan urutan aplikasi mereka.  Aturan pertama yang berfungsi menghentikan pencarian lebih lanjut untuk impor. <br><br>  Dalam contoh-contoh konfigurasi, aturan rule_predefined_names akan sering muncul di <code>rule_predefined_names</code> , perlu bahwa fungsi bawaan (misalnya, <code>print</code> ) dikenali dengan benar. <br><br><h3>  Aturan 1: Nama yang Ditentukan sebelumnya </h3><br>  Aturan ini memungkinkan Anda untuk mengabaikan nama yang telah ditentukan seperti <code>__file__</code> dan fungsi <code>__file__</code> seperti <code>print</code> . <br><br><div class="spoiler">  <b class="spoiler_title">Contoh</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># : # { # "rules": [{"type": "rule_predefined_names"}] # } import smart_imports smart_imports.all() #        __file__ #        print(__file__)</span></span></code> </pre> </div></div><br><h3>  Aturan 2: Modul Lokal </h3><br>  Cek apakah ada modul dengan nama yang ditentukan di sebelah modul saat ini (di direktori yang sama).  Jika ada, impor saja. <br><br><div class="spoiler">  <b class="spoiler_title">Contoh</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># : # { # "rules": [{"type": "rule_predefined_names"}, # {"type": "rule_local_modules"}] # } # #    : # # my_package # |-- __init__.py # |-- a.py # |-- b.py # b.py import smart_imports smart_imports.all() #    "a.py" print(a)</span></span></code> </pre> </div></div><br><h3>  Aturan 3: Modul Global </h3><br>  Mencoba mengimpor modul secara langsung dengan nama.  Misalnya, modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">permintaan</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Contoh</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># : # { # "rules": [{"type": "rule_predefined_names"}, # {"type": "rule_global_modules"}] # } # #    # # pip install requests import smart_imports smart_imports.all() #    requests print(requests.get('http://example.com'))</span></span></code> </pre> </div></div><br><h3>  Aturan 4: Nama Khusus </h3><br>  Sesuai dengan nama modul tertentu atau atributnya.  Kepatuhan ditunjukkan dalam aturan konfigurasi. <br><br><div class="spoiler">  <b class="spoiler_title">Contoh</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># : # { # "rules": [{"type": "rule_predefined_names"}, # {"type": "rule_custom", # "variables": {"my_import_module": {"module": "os.path"}, # "my_import_attribute": {"module": "random", "attribute": "seed"}}}] # } import smart_imports smart_imports.all() #       #        print(my_import_module) print(my_import_attribute)</span></span></code> </pre> </div></div><br><h3>  Aturan 5: Modul Standar </h3><br>  Periksa apakah namanya adalah modul perpustakaan standar.  Misalnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">matematika</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">os.path</a> yang berubah menjadi <code>os_path</code> . <br><br>  Ini bekerja lebih cepat daripada aturan untuk mengimpor modul global, karena memeriksa keberadaan modul pada daftar yang di-cache.  Daftar untuk setiap versi Python berasal dari sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/jackmaney/python-stdlib-list</a> <br><br><div class="spoiler">  <b class="spoiler_title">Contoh</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># : # { # "rules": [{"type": "rule_predefined_names"}, # {"type": "rule_stdlib"}] # } import smart_imports smart_imports.all() print(math.pi)</span></span></code> </pre> </div></div><br><h3>  Aturan 6: Impor dengan Awalan </h3><br>  Mengimpor modul dengan nama, dari paket yang terkait dengan awalannya.  Lebih mudah digunakan ketika Anda memiliki beberapa paket yang digunakan di seluruh kode.  Sebagai contoh, modul paket <code>utils</code> dapat diakses dengan awalan <code>utils_</code> . <br><br><div class="spoiler">  <b class="spoiler_title">Contoh</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># : # { # "rules": [{"type": "rule_predefined_names"}, # {"type": "rule_prefix", # "prefixes": [{"prefix": "utils_", "module": "my_package.utils"}]}] # } # #    : # # my_package # |-- __init__.py # |-- utils # |-- |-- __init__ # |-- |-- a.py # |-- |-- b.py # |-- subpackage # |-- |-- __init__ # |-- |-- c.py # c.py import smart_imports smart_imports.all() print(utils_a) print(utils_b)</span></span></code> </pre> </div></div><br><h3>  Aturan 7: Modul dari paket induk </h3><br>  Jika Anda memiliki sub paket dengan nama yang sama di berbagai bagian proyek (misalnya, <code>tests</code> atau <code>migrations</code> ), Anda dapat memperbolehkan mereka mencari modul untuk diimpor dengan nama dalam paket induk. <br><br><div class="spoiler">  <b class="spoiler_title">Contoh</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># : # { # "rules": [{"type": "rule_predefined_names"}, # {"type": "rule_local_modules_from_parent", # "suffixes": [".tests"]}] # } # #    : # # my_package # |-- __init__.py # |-- a.py # |-- tests # |-- |-- __init__ # |-- |-- b.py # b.py import smart_imports smart_imports.all() print(a)</span></span></code> </pre> </div></div><br><h3>  Aturan 8: Mengikat paket lain </h3><br>  Untuk modul dari paket tertentu, ini memungkinkan pencarian impor dengan nama dalam paket lain (ditentukan dalam konfigurasi).  Dalam kasus saya, aturan ini bermanfaat untuk kasus-kasus ketika saya tidak ingin memperluas pekerjaan aturan sebelumnya (Modul dari paket induk) ke seluruh proyek. <br><br><div class="spoiler">  <b class="spoiler_title">Contoh</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># : # { # "rules": [{"type": "rule_predefined_names"}, # {"type": "rule_local_modules_from_namespace", # "map": {"my_package.subpackage_1": ["my_package.subpackage_2"]}}] # } # #    : # # my_package # |-- __init__.py # |-- subpackage_1 # |-- |-- __init__ # |-- |-- a.py # |-- subpackage_2 # |-- |-- __init__ # |-- |-- b.py # a.py import smart_imports smart_imports.all() print(b)</span></span></code> </pre> </div></div><br><h3>  Menambahkan Aturan Anda Sendiri </h3><br>  Menambahkan aturan Anda sendiri cukup sederhana: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kami mewarisi</a> dari kelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">smart_imports.rules.BaseRule</a> . </li><li>  Kami menyadari logika yang diperlukan. </li><li>  Daftarkan aturan menggunakan metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">smart_imports.rules.register</a> </li><li>  Tambahkan aturan ke konfigurasi. </li><li>  ??? </li><li>  Untung </li></ol><br>  Contoh dapat ditemukan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">implementasi aturan saat ini.</a> <br><br><h2>  Untung </h2><br>  Daftar impor multiline di awal setiap sumber telah hilang. <br><br>  Jumlah baris menurun.  Sebelum browser beralih ke impor cerdas, ada 6688 baris yang bertanggung jawab untuk mengimpor.  Setelah transisi, 2084 tetap (dua baris smart_import per file + 130 impor, dipanggil secara eksplisit dari fungsi dan tempat yang serupa). <br><br>  Bonus yang bagus adalah standarisasi nama dalam proyek.  Kode menjadi lebih mudah dibaca dan lebih mudah untuk ditulis.  Tidak perlu memikirkan nama-nama entitas yang diimpor - ada beberapa aturan yang jelas yang mudah diikuti. <br><br><h2>  Rencana pengembangan </h2><br>  Saya suka ide mendefinisikan properti kode dengan nama variabel, jadi saya akan mencoba mengembangkannya baik dalam impor pintar maupun dalam proyek lain. <br><br>  Mengenai impor cerdas, saya berencana: <br><br><ol><li>  Tambahkan dukungan untuk versi Python baru. </li><li>  Jelajahi kemungkinan mengandalkan praktik komunitas saat ini pada jenis anotasi kode. </li><li>  Jelajahi kemungkinan membuat impor malas. </li><li>  Terapkan utilitas untuk pembuatan otomatis konfigurasi dari kode sumber dan refactoring sumber untuk menggunakan smart_import. </li><li>  Tulis ulang bagian dari kode C untuk mempercepat pekerjaan dengan AST. </li><li>  Untuk mengembangkan integrasi dengan linter dan IDE jika mereka memiliki masalah dengan analisis kode tanpa impor eksplisit. </li></ol><br>  Selain itu, saya tertarik dengan pendapat Anda tentang perilaku default perpustakaan dan aturan impor. <br><br>  Terima kasih telah mengatasi lembaran teks ini :-D </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id459930/">https://habr.com/ru/post/id459930/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id459914/index.html">SQL Index Manager - alat gratis untuk mendefrag dan mempertahankan indeks</a></li>
<li><a href="../id459918/index.html">Pemecahan masalah dengan pwnable.kr 03 - bof. Buffer overflow pada stack</a></li>
<li><a href="../id459922/index.html">Menghapus kebisingan frekuensi tinggi dari sinyal sensor getaran selama diagnostik getaran bantalan</a></li>
<li><a href="../id459924/index.html">Siklus Pengujian Reaksi Penuh. Laporan Auto.ru</a></li>
<li><a href="../id459928/index.html">Jalur siswa ke pengembangan aplikasi seluler</a></li>
<li><a href="../id459934/index.html">Intisari materi menarik untuk pengembang ponsel # 306 (pada 8-14 Juli)</a></li>
<li><a href="../id459936/index.html">9 trik lagi untuk bekerja dengan Visual Studio</a></li>
<li><a href="../id459948/index.html">Menerapkan awan volumetrik yang benar secara fisik seperti di Horizon Zero Dawn</a></li>
<li><a href="../id459952/index.html">Sedikit pengalaman tentang cadangan & penyimpanan</a></li>
<li><a href="../id459954/index.html">Mengapa salah satu perusahaan IT terbesar bergabung dengan CNCF - dana pengembangan infrastruktur cloud</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>