<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüî¨ üññüèΩ üßùüèº Criando Tower Defense na Unity: Cen√°rios e Ondas de Inimigos üë®‚Äçüë©‚Äçüëß‚Äçüëß üëãüèº ü§©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[ A primeira , segunda , terceira e quarta partes do tutorial] 



- Suporte para inimigos de tamanhos pequeno, m√©dio e grande. 
- Crie cen√°rios de jo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Criando Tower Defense na Unity: Cen√°rios e Ondas de Inimigos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466855/">  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A primeira</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">segunda</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">terceira</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">quarta</a> partes do tutorial] <br><br><ul><li>  Suporte para inimigos de tamanhos pequeno, m√©dio e grande. </li><li>  Crie cen√°rios de jogos com v√°rias ondas de inimigos. </li><li>  Separa√ß√£o de configura√ß√£o de ativos e estado de jogo. </li><li>  Iniciar, pausar, vencer, derrotar e acelerar o jogo. </li><li>  Crie cen√°rios repetidamente intermin√°veis. </li></ul><br>  Esta √© a quinta parte de uma s√©rie de tutoriais sobre como criar um jogo simples de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">defesa de torre</a> .  Nele, aprenderemos como criar cen√°rios de jogo que geram ondas de v√°rios inimigos. <br><br>  O tutorial foi criado no Unity 2018.4.6f1. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b12/6aa/945/b126aa94582cc44651853c3ee69be82b.jpg" width="512" height="256"></div><br>  <i>Est√° ficando bem confort√°vel.</i> <br><a name="habracut"></a><br><h2>  Mais inimigos </h2><br>  N√£o √© muito interessante criar sempre o mesmo cubo azul.  O primeiro passo para suportar cen√°rios de jogo mais interessantes ser√° o suporte a v√°rios tipos de inimigos. <br><br><h3>  Configura√ß√µes inimigas </h3><br>  Existem muitas maneiras de tornar os inimigos √∫nicos, mas n√£o vamos complicar: os classificamos como pequenos, m√©dios e grandes.  Para marc√°-los, crie uma enumera√ß√£o <code>EnemyType</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> EnemyType { Small, Medium, Large }</code> </pre> <br>  Mude o <code>EnemyFactory</code> para que ele suporte todos os tr√™s tipos de inimigos em vez de um.  Para todos os tr√™s inimigos, os mesmos campos de configura√ß√£o s√£o necess√°rios; portanto, adicionamos a classe aninhada <code>EnemyConfig</code> contendo todos eles e, em seguida, adicionamos tr√™s campos de configura√ß√£o desse tipo √† f√°brica.  Como essa classe √© usada apenas para configura√ß√£o e n√£o a usaremos em nenhum outro lugar, voc√™ pode simplesmente tornar seus campos p√∫blicos para que a f√°brica possa acess√°-los.  <code>EnemyConfig</code> pr√≥prio <code>EnemyConfig</code> n√£o precisa ser p√∫blico. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemyFactory</span></span> : <span class="hljs-title"><span class="hljs-title">GameObjectFactory</span></span> { [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemyConfig</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Enemy prefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; [FloatRangeSlider(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">2f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> FloatRange scale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatRange(<span class="hljs-number"><span class="hljs-number">1f</span></span>); [FloatRangeSlider(<span class="hljs-number"><span class="hljs-number">0.2f</span></span>, <span class="hljs-number"><span class="hljs-number">5f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> FloatRange speed = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatRange(<span class="hljs-number"><span class="hljs-number">1f</span></span>); [FloatRangeSlider(<span class="hljs-number"><span class="hljs-number">-0.4f</span></span>, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> FloatRange pathOffset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatRange(<span class="hljs-number"><span class="hljs-number">0f</span></span>); } [SerializeField] EnemyConfig small = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, medium = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, large = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; ‚Ä¶ }</code> </pre> <br>  Vamos tamb√©m tornar a sa√∫de personaliz√°vel para cada inimigo, porque √© l√≥gico que inimigos grandes tenham mais que inimigos pequenos. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">FloatRangeSlider(10f, 1000f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> FloatRange health = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatRange(<span class="hljs-number"><span class="hljs-number">100f</span></span>);</code> </pre> <br>  Adicione um par√¢metro de tipo a <code>Get</code> para obter um tipo de inimigo espec√≠fico e o tipo padr√£o ser√° m√©dio.  Usaremos o tipo para obter a configura√ß√£o correta, para a qual um m√©todo separado √© √∫til, e depois criar e inicializar o inimigo como antes, somente com o argumento de integridade adicionado. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">EnemyConfig </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetConfig</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EnemyType type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EnemyType.Small: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> small; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EnemyType.Medium: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> medium; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EnemyType.Large: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> large; } Debug.Assert(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"Unsupported enemy type!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Enemy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EnemyType type = EnemyType.Medium</span></span></span><span class="hljs-function">)</span></span> { EnemyConfig config = GetConfig(type); Enemy instance = CreateGameObjectInstance(config.prefab); instance.OriginFactory = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; instance.Initialize( config.scale.RandomValueInRange, config.speed.RandomValueInRange, config.pathOffset.RandomValueInRange, config.health.RandomValueInRange ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; }</code> </pre> <br>  Adicione o par√¢metro necess√°rio health ao <code>Enemy.Initialize</code> e use-o para definir a sa√∫de em vez de determin√°-la pelo tamanho do inimigo. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathOffset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> health </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Health = health; }</code> </pre> <br><h3>  Criamos o design de diferentes inimigos </h3><br>  Voc√™ pode escolher qual ser√° o design dos tr√™s inimigos, mas no tutorial tentarei obter o m√°ximo de simplicidade.  Dupliquei o pr√©-fabricado original do inimigo e o usei para todos os tr√™s tamanhos, alterando apenas o material: amarelo para pequeno, azul para m√©dio e vermelho para grande.  N√£o alterei a escala do cubo pr√©-fabricado, mas usei a configura√ß√£o de escala de f√°brica para definir as dimens√µes.  Al√©m disso, dependendo do tamanho, aumentei a sa√∫de deles e reduzi a velocidade. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd7/070/231/bd707023151022e921c5b6956bb20c02.png" width="320" height="348"></div><br>  <i>F√°brica para inimigos cubos de tr√™s tamanhos.</i> <br><br>  A maneira mais r√°pida √© fazer com que todos os tr√™s tipos apare√ßam no jogo, alterando <code>Game.SpawnEnemy</code> para que ele obtenha um tipo aleat√≥rio de inimigo em vez do meio. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnEnemy</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile spawnPoint = board.GetSpawnPoint(Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, board.SpawnPointCount)); Enemy enemy = enemyFactory.Get((EnemyType)(Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>))); enemy.SpawnOn(spawnPoint); enemies.Add(enemy); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/537/73b/b92/53773bb9299a8ec9c56b485718049e5b.png" width="230" height="230"></div><br>  <i>Inimigos de diferentes tipos.</i> <br><br><h3>  V√°rias f√°bricas </h3><br>  Agora a f√°brica de inimigos define muitos tr√™s inimigos.  A f√°brica existente cria cubos de tr√™s tamanhos, mas nada nos impede de fazer outra f√°brica que cria outra coisa, por exemplo, esferas de tr√™s tamanhos.  Podemos mudar os inimigos criados nomeando outra f√°brica no jogo, mudando para um t√≥pico diferente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65f/7e5/330/65f7e5330945ea654f1caef579fe567f.png" width="230" height="230"></div><br>  <i>Inimigos esf√©ricos.</i> <br><br><h2>  Ondas de inimigos </h2><br>  O segundo passo na cria√ß√£o de cen√°rios de jogo ser√° a rejei√ß√£o de gerar inimigos com uma frequ√™ncia constante.  Os inimigos devem ser criados em ondas sucessivas at√© o script terminar ou o jogador perder. <br><br><h3>  Sequ√™ncias de cria√ß√£o </h3><br>  Uma onda de inimigos consiste em um grupo de inimigos criados um ap√≥s o outro at√© que a onda seja conclu√≠da.  Uma onda pode conter diferentes tipos de inimigos, e o atraso entre sua cria√ß√£o pode variar.  Para n√£o complicar a implementa√ß√£o, come√ßaremos com uma simples sequ√™ncia de cria√ß√£o que cria o mesmo tipo de inimigos com uma frequ√™ncia constante.  Ent√£o a onda ser√° apenas uma lista dessas seq√º√™ncias. <br><br>  Para configurar cada sequ√™ncia, crie uma classe <code>EnemySpawnSequence</code> .  Como √© bastante complicado, coloque-o em um arquivo separado.  A sequ√™ncia deve saber qual f√°brica usar, que tipo de inimigo criar, seu n√∫mero e frequ√™ncia.  Para simplificar a configura√ß√£o, faremos uma pausa no √∫ltimo par√¢metro, que determina quanto tempo deve passar antes de criar o pr√≥ximo inimigo.  Observe que essa abordagem permite que voc√™ use v√°rias f√°bricas inimigas na onda. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemySpawnSequence</span></span> { [SerializeField] EnemyFactory factory = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; [SerializeField] EnemyType type = EnemyType.Medium; [SerializeField, Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> amount = <span class="hljs-number"><span class="hljs-number">1</span></span>; [SerializeField, Range(<span class="hljs-number"><span class="hljs-number">0.1f</span></span>, <span class="hljs-number"><span class="hljs-number">10f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cooldown = <span class="hljs-number"><span class="hljs-number">1f</span></span>; }</code> </pre> <br><h3>  As ondas </h3><br>  Uma onda √© uma matriz simples de sequ√™ncias de cria√ß√£o de inimigos.  Crie um tipo de <code>EnemyWave</code> EnemyWave para ele que comece com uma sequ√™ncia padr√£o. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [CreateAssetMenu] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemyWave</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { [SerializeField] EnemySpawnSequence[] spawnSequences = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EnemySpawnSequence() }; }</code> </pre> <br>  Agora podemos criar ondas de inimigos.  Por exemplo, criei uma onda que gera um grupo de inimigos c√∫bicos, come√ßando com dez pequenos, com uma frequ√™ncia de dois por segundo.  Eles s√£o seguidos por cinco m√©dias, criadas uma vez por segundo e, finalmente, um grande inimigo com uma pausa de cinco segundos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b16/af3/47f/b16af347f057760db35703515642db89.png" width="320" height="376"></div><br>  <i>Uma onda de cubos crescentes.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Posso adicionar um atraso entre as sequ√™ncias?</b> <div class="spoiler_text">  Voc√™ pode implement√°-lo indiretamente.  Por exemplo, insira um atraso de quatro segundos entre cubos pequenos e m√©dios, reduza o n√∫mero de cubos pequenos em um e insira a sequ√™ncia de um cubo pequeno com uma pausa de quatro segundos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/59b/ff4/3f9/59bff43f9a71002c0bd562f270b755ea.png" width="320" height="272"></div><br>  <i>Atraso de quatro segundos entre cubos pequenos e m√©dios.</i> </div></div><br><h3>  Cen√°rios </h3><br>  O cen√°rio de jogo √© criado a partir de uma sequ√™ncia de ondas.  Para isso, crie um <code>GameScenario</code> ativo <code>GameScenario</code> com uma √∫nica matriz de ondas e use-o para criar o cen√°rio. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [CreateAssetMenu] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameScenario</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { [SerializeField] EnemyWave[] waves = {}; }</code> </pre> <br>  Por exemplo, criei um cen√°rio com duas ondas de inimigos pequeno-m√©dio-grande (MSC), primeiro com cubos e depois com esferas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/796/df0/73b/796df073b24d092d35093b6e56b8be79.png" width="320" height="142"></div><br>  <i>Cen√°rio com duas vagas de MSC.</i> <br><br><h3>  Movimento de sequ√™ncia </h3><br>  Os tipos de ativos s√£o usados ‚Äã‚Äãpara criar scripts, mas, como s√£o ativos, eles devem conter dados que n√£o mudam durante o jogo.  No entanto, para avan√ßar no cen√°rio, precisamos de alguma forma rastrear seu status.  Uma maneira √© duplicar o ativo usado no jogo para que o duplicado rastreie sua condi√ß√£o.  Mas n√£o precisamos duplicar todo o ativo, apenas o estado e os links s√£o suficientes.  Ent√£o, vamos criar uma classe <code>State</code> separada, primeiro para <code>EnemySpawnSequence</code> .  Como se aplica apenas a uma sequ√™ncia, n√≥s a aninhamos.  Ela √© v√°lida apenas quando tem uma refer√™ncia a uma sequ√™ncia, portanto, forneceremos um m√©todo construtor com um par√¢metro de sequ√™ncia. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/18c/752/4fd/18c7524fdac87c062a6c683bbdee1866.png" width="315" height="50"></div><br>  <i>Um tipo de estado aninhado que se refere √† sua sequ√™ncia.</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemySpawnSequence</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">State</span></span> { EnemySpawnSequence sequence; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EnemySpawnSequence sequence</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.sequence = sequence; } } }</code> </pre> <br>  Quando queremos come√ßar a avan√ßar em sequ√™ncia, precisamos de uma nova inst√¢ncia do estado para isso.  Adicione sequ√™ncias ao m√©todo <code>Begin</code> , que constr√≥i e retorna o estado.  Gra√ßas a isso, todo mundo que ligar para <code>Begin</code> ser√° respons√°vel por corresponder ao estado, e a pr√≥pria sequ√™ncia permanecer√° sem estado.  At√© ser√° poss√≠vel avan√ßar em paralelo v√°rias vezes na mesma sequ√™ncia. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemySpawnSequence</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Begin</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> State(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">State</span></span> { ‚Ä¶ } }</code> </pre> <br>  Para que o estado sobreviva ap√≥s reinicializa√ß√µes a quente, voc√™ precisa torn√°-lo serializ√°vel. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">System.Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">State</span></span> { ‚Ä¶ }</code> </pre> <br>  A desvantagem dessa abordagem √© que toda vez que executamos uma sequ√™ncia, precisamos criar um novo objeto de estado.  Podemos evitar a aloca√ß√£o de mem√≥ria, tornando-a uma estrutura em vez de uma classe.  Isso √© normal desde que a condi√ß√£o permane√ßa pequena.  Lembre-se de que estado √© um tipo de valor.  Quando √© transferido, √© copiado, ent√£o acompanhe-o em um s√≥ lugar. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">System.Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> State { ‚Ä¶ }</code> </pre> <br>  O estado da sequ√™ncia consiste em apenas dois aspectos: o n√∫mero de inimigos gerados e o progresso do tempo de pausa.  Adicionamos o m√©todo <code>Progress</code> , que aumenta o valor da pausa pelo delta do tempo e o redefine quando o valor configurado √© atingido, semelhante ao que acontece com o tempo de gera√ß√£o no <code>Game.Update</code> .  Aumentaremos a contagem de inimigos toda vez que isso acontecer.  Al√©m disso, o valor da pausa deve come√ßar com o valor m√°ximo para que a sequ√™ncia crie inimigos sem pausa no in√≠cio. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cooldown; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EnemySpawnSequence sequence</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.sequence = sequence; count = <span class="hljs-number"><span class="hljs-number">0</span></span>; cooldown = sequence.cooldown; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { cooldown += Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (cooldown &gt;= sequence.cooldown) { cooldown -= sequence.cooldown; count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50c/aba/5e5/50caba5e50d89e05a6cb9a631feb1c6d.png" width="315" height="74"></div><br>  <i>O estado cont√©m apenas os dados necess√°rios.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Posso acessar EnemySpawnSequence.cooldown do State?</b> <div class="spoiler_text">  Sim, porque <code>State</code> est√° definido no mesmo escopo.  Portanto, os tipos aninhados conhecem os membros particulares dos tipos que os cont√™m. </div></div><br>  O progresso deve continuar at√© que o n√∫mero desejado de inimigos seja criado e a pausa termine.  Neste ponto, o <code>Progress</code> deve relatar a conclus√£o, mas provavelmente saltaremos um pouco acima do valor.  Portanto, neste momento, devemos retornar o tempo extra para us√°-lo com anteced√™ncia na sequ√™ncia a seguir.  Para que isso funcione, √© necess√°rio transformar o delta do tempo em um par√¢metro.  Tamb√©m precisamos indicar que ainda n√£o terminamos, e isso pode ser realizado retornando um valor negativo. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> deltaTime</span></span></span><span class="hljs-function">)</span></span> { cooldown += deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (cooldown &gt;= sequence.cooldown) { cooldown -= sequence.cooldown; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt;= sequence.amount) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cooldown; } count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1f</span></span>; }</code> </pre> <br><h3>  Crie inimigos em qualquer lugar </h3><br>  Para que sequ√™ncias gerem inimigos, precisamos converter <code>Game.SpawnEnemy</code> para outro m√©todo est√°tico p√∫blico. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnEnemy</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EnemyFactory factory, EnemyType type</span></span></span><span class="hljs-function">)</span></span> { GameTile spawnPoint = instance.board.GetSpawnPoint( Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, instance.board.SpawnPointCount) ); Enemy enemy = factory.Get(type); enemy.SpawnOn(spawnPoint); instance.enemies.Add(enemy); }</code> </pre> <br>  Como o pr√≥prio <code>Game</code> n√£o gerar√° mais inimigos, podemos remover a f√°brica, a velocidade de cria√ß√£o, o processo de promo√ß√£o da cria√ß√£o e o c√≥digo de cria√ß√£o de inimigos do <code>Update</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { }</code> </pre> <br>  Chamaremos <code>Game.SpawnEnemy</code> em <code>EnemySpawnSequence.State.Progress</code> depois de aumentar a contagem de inimigos. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> deltaTime</span></span></span><span class="hljs-function">)</span></span> { cooldown += deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (cooldown &gt;= sequence.cooldown) { ‚Ä¶ count += <span class="hljs-number"><span class="hljs-number">1</span></span>; Game.SpawnEnemy(sequence.factory, sequence.type); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1f</span></span>; }</code> </pre> <br><h3>  Avan√ßo da onda </h3><br>  Vamos seguir a mesma abordagem para mover-se ao longo de uma sequ√™ncia, como ao longo de uma onda inteira.  Vamos dar ao <code>EnemyWave</code> seu pr√≥prio m√©todo <code>Begin</code> , que retorna uma nova inst√¢ncia da estrutura <code>State</code> aninhada.  Nesse caso, o estado cont√©m o √≠ndice de ondas e o estado da sequ√™ncia ativa, que inicializamos com o in√≠cio da primeira sequ√™ncia. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9eb/9f8/bc7/9eb9f8bc7769dd0c65624802ac2a97b8.png" width="315" height="128"></div><br>  <i>Um estado de onda contendo o estado de uma sequ√™ncia.</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemyWave</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { [SerializeField] EnemySpawnSequence[] spawnSequences = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EnemySpawnSequence() }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Begin</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> State(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> State { EnemyWave wave; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index; EnemySpawnSequence.State sequence; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EnemyWave wave</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wave = wave; index = <span class="hljs-number"><span class="hljs-number">0</span></span>; Debug.Assert(wave.spawnSequences.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Empty wave!"</span></span>); sequence = wave.spawnSequences[<span class="hljs-number"><span class="hljs-number">0</span></span>].Begin(); } } }</code> </pre> <br>  Tamb√©m adicionamos o m√©todo <code>EnemyWave.State</code> <code>Progress</code> , que usa a mesma abordagem de antes, com pequenas altera√ß√µes.  Come√ßamos movendo-se ao longo da sequ√™ncia ativa e substituindo o delta do tempo pelo resultado dessa chamada.  Enquanto resta tempo, passamos para a pr√≥xima sequ√™ncia, se for acessada, e realizamos progresso nela.  Se n√£o houver seq√º√™ncias restantes, retornamos o tempo restante;  caso contr√°rio, retorne um valor negativo. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> deltaTime</span></span></span><span class="hljs-function">)</span></span> { deltaTime = sequence.Progress(deltaTime); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (deltaTime &gt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++index &gt;= wave.spawnSequences.Length) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> deltaTime; } sequence = wave.spawnSequences[index].Begin(); deltaTime = sequence.Progress(deltaTime); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1f</span></span>; }</code> </pre> <br><h3>  Promo√ß√£o de scripts </h3><br>  Adicione <code>GameScenario</code> o mesmo processamento.  Nesse caso, o estado cont√©m o √≠ndice da onda e o estado da onda ativa. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameScenario</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { [SerializeField] EnemyWave[] waves = {}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Begin</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> State(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> State { GameScenario scenario; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index; EnemyWave.State wave; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameScenario scenario</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scenario = scenario; index = <span class="hljs-number"><span class="hljs-number">0</span></span>; Debug.Assert(scenario.waves.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Empty scenario!"</span></span>); wave = scenario.waves[<span class="hljs-number"><span class="hljs-number">0</span></span>].Begin(); } } }</code> </pre> <br>  Como estamos no n√≠vel superior, o m√©todo <code>Progress</code> n√£o requer um par√¢metro e voc√™ pode usar <code>Time.deltaTime</code> diretamente.  N√£o precisamos retornar o tempo restante, mas precisamos mostrar se o script foi conclu√≠do.  Retornaremos <code>false</code> ap√≥s o final da √∫ltima onda e <code>true</code> para mostrar que o script ainda est√° ativo. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> deltaTime = wave.Progress(Time.deltaTime); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (deltaTime &gt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++index &gt;= scenario.waves.Length) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } wave = scenario.waves[index].Begin(); deltaTime = wave.Progress(deltaTime); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3>  Execu√ß√£o de script </h3><br>  Para reproduzir um script de <code>Game</code> , voc√™ precisa de um campo de configura√ß√£o de script e rastreamento de seu status.  Apenas rodaremos o script em Despertar e <code>Update</code> at√© que o status do resto do jogo seja atualizado. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameScenario scenario = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; GameScenario.State activeScenario; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { board.Initialize(boardSize, tileContentFactory); board.ShowGrid = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; activeScenario = scenario.Begin(); } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ activeScenario.Progress(); enemies.GameUpdate(); Physics.SyncTransforms(); board.GameUpdate(); nonEnemies.GameUpdate(); }</code> </pre> <br>  Agora, o script configurado ser√° iniciado no in√≠cio do jogo.  A promo√ß√£o ser√° realizada at√© a conclus√£o e, depois disso, nada acontece. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mk/x0/uf/mkx0ufxshpgvy29wjr_nxdmneu4.gif"></div><br>  <i>Duas ondas aceleraram 10 vezes.</i> <br><br><h2>  In√≠cio e fim dos jogos </h2><br>  Podemos reproduzir um cen√°rio, mas ap√≥s a conclus√£o, novos inimigos n√£o aparecer√£o.  Para o jogo continuar, precisamos possibilitar o in√≠cio de um novo cen√°rio, manualmente, ou porque o jogador perdeu / venceu.  Voc√™ tamb√©m pode implementar uma escolha de v√°rios cen√°rios, mas neste tutorial n√£o iremos consider√°-lo. <br><br><h3>  O come√ßo de um novo jogo </h3><br>  Idealmente, precisamos da oportunidade de iniciar um novo jogo a qualquer momento.  Para fazer isso, voc√™ precisa redefinir o estado atual de todo o jogo, ou seja, teremos que redefinir muitos objetos.  Primeiro, adicione um m√©todo <code>Clear</code> ao <code>GameBehaviorCollection</code> que utiliza todos os seus comportamentos. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; behaviors.Count; i++) { behaviors[i].Recycle(); } behaviors.Clear(); }</code> </pre> <br>  Isso sugere que todos os comportamentos podem ser descartados, mas at√© agora esse n√£o √© o caso.  Para fazer isso funcionar, adicione <code>GameBehavior</code> m√©todo abstrato de <code>Recycle</code> ao <code>GameBehavior</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Recycle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>;</code> </pre> <br>  O m√©todo <code>Recycle</code> da classe <code>WarEntity</code> deve substitu√≠-lo explicitamente. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Recycle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { originFactory.Reclaim(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  <code>Enemy</code> ainda n√£o possui um m√©todo de <code>Recycle</code> , ent√£o adicione-o.  Tudo o que ele precisa fazer √© for√ßar a f√°brica a devolv√™-lo.  Em seguida, ligamos para a <code>Recycle</code> onde quer que acessemos diretamente a f√°brica. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Health &lt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>) { Recycle(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } progress += Time.deltaTime * progressFactor; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (progress &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tileTo == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Recycle(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } ‚Ä¶ } ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Recycle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { OriginFactory.Reclaim(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  <code>GameBoard</code> tamb√©m precisa ser redefinido, portanto, vamos dar o m√©todo <code>Clear</code> , que esvazia todos os blocos, redefine todos os pontos de cria√ß√£o e atualiza o conte√∫do e, em seguida, define os pontos inicial e final padr√£o.  Ent√£o, em vez de repetir o c√≥digo, podemos chamar <code>Clear</code> no final de <code>Initialize</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector2Int size, GameTileContentFactory contentFactory </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++, i++) { ‚Ä¶ } } Clear(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.Content = contentFactory.Get(GameTileContentType.Empty); } spawnPoints.Clear(); updatingContent.Clear(); ToggleDestination(tiles[tiles.Length / <span class="hljs-number"><span class="hljs-number">2</span></span>]); ToggleSpawnPoint(tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>]); }</code> </pre> <br>  Agora podemos adicionar o m√©todo <code>BeginNewGame</code> ao <code>Game</code> , despejar inimigos, outros objetos e o campo e iniciar um novo script. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BeginNewGame</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { enemies.Clear(); nonEnemies.Clear(); board.Clear(); activeScenario = scenario.Begin(); }</code> </pre> <br>  Chamaremos esse m√©todo no <code>Update</code> se voc√™ pressionar B antes de passar para o script. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.B)) { BeginNewGame(); } activeScenario.Progress(); ‚Ä¶ }</code> </pre> <br><h3>  Perdendo </h3><br>  O objetivo do jogo √© derrotar todos os inimigos antes que um certo n√∫mero deles atinja o ponto final.  O n√∫mero de inimigos necess√°rios para desencadear a condi√ß√£o de derrota depende da sa√∫de inicial do jogador, para a qual adicionaremos um campo de configura√ß√£o ao <code>Game</code> .  Como contamos inimigos, usaremos inteiro, n√£o flutuante. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(0, 100)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> startingPlayerHealth = <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f3/9c5/11a/4f39c511ab9d362b1cc7e55610a317aa.png" width="320" height="38"></div><br>  <i>Inicialmente, um jogador tem 10 de vida.</i> <br><br>  No caso de Awake ou no in√≠cio de um novo jogo, atribu√≠mos o valor inicial √† sa√∫de atual do jogador. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> playerHealth; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { playerHealth = startingPlayerHealth; ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BeginNewGame</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { playerHealth = startingPlayerHealth; ‚Ä¶ }</code> </pre> <br>  Adicione um m√©todo p√∫blico <code>EnemyReachedDestination</code> est√°tico <code>EnemyReachedDestination</code> que os inimigos possam dizer ao <code>Game</code> que atingiram o ponto final.  Quando isso acontecer, reduza a sa√∫de do jogador. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnemyReachedDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { instance.playerHealth -= <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  Chame esse m√©todo no <code>Enemy.GameUpdate</code> no momento apropriado. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tileTo == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Game.EnemyReachedDestination(); Recycle(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Agora podemos verificar a condi√ß√£o de derrota no <code>Game.Update</code> .  Se a sa√∫de do jogador for igual ou menor que zero, a condi√ß√£o de derrota ser√° acionada.  Simplesmente registramos essas informa√ß√µes e iniciamos imediatamente um novo jogo antes de avan√ßar.  Mas faremos isso apenas com uma sa√∫de inicial positiva.  Isso nos permite usar 0 como sa√∫de inicial, tornando imposs√≠vel a perda.  Portanto, ser√° conveniente testar os scripts. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (playerHealth &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; startingPlayerHealth &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Defeat!"</span></span>); BeginNewGame(); } activeScenario.Progress();</code> </pre> <br><h3>  Vit√≥ria </h3><br>  Uma alternativa √† derrota √© a vit√≥ria, que √© alcan√ßada no final do cen√°rio, se o jogador ainda estiver vivo.  Ou seja, quando o resultado do <code>GameScenario.Progess</code> √© <code>false</code> , exibimos uma mensagem de vit√≥ria no log, iniciamos um novo jogo e seguimos imediatamente. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (playerHealth &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Defeat!"</span></span>); BeginNewGame(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!activeScenario.Progress()) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Victory!"</span></span>); BeginNewGame(); activeScenario.Progress(); }</code> </pre> <br>  No entanto, a vit√≥ria ocorrer√° ap√≥s o final da √∫ltima pausa, mesmo se ainda houver inimigos em campo.  Precisamos adiar a vit√≥ria at√© que todos os inimigos desapare√ßam, o que pode ser realizado verificando se a cole√ß√£o de inimigos est√° vazia.  Assumimos que ele tenha a propriedade <code>IsEmpty</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!activeScenario.Progress() &amp;&amp; enemies.IsEmpty) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Victory!"</span></span>); BeginNewGame(); activeScenario.Progress(); }</code> </pre> <br>  Adicione a propriedade desejada ao <code>GameBehaviorCollection</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsEmpty =&gt; behaviors.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><h3>  Controle de tempo </h3><br>  Vamos tamb√©m implementar o recurso de gerenciamento de tempo, isso ajudar√° nos testes e geralmente √© uma fun√ß√£o de jogabilidade.  Para come√ßar, deixe <code>Game.Update</code> procurar uma barra de espa√ßo e use esse evento para ativar / desativar as pausas no jogo.  Isso pode ser feito alternando os valores <code>Time.timeScale</code> entre zero e um.  Isso n√£o mudar√° a l√≥gica do jogo, mas far√° com que todos os objetos congelem no lugar.  Ou voc√™ pode usar um valor muito pequeno em vez de 0, por exemplo, 0,01, para criar uma c√¢mera extremamente lenta. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> pausedTimeScale = <span class="hljs-number"><span class="hljs-number">0f</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.Space)) { Time.timeScale = Time.timeScale &gt; pausedTimeScale ? pausedTimeScale : <span class="hljs-number"><span class="hljs-number">1f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.B)) { BeginNewGame(); } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em segundo lugar, adicionaremos </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a velocidade do jogo </font><font style="vertical-align: inherit;">ao </font><font style="vertical-align: inherit;">controle deslizante, para que voc√™ possa acelerar o tempo.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(1f, 10f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> playSpeed = <span class="hljs-number"><span class="hljs-number">1f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5d/641/4e9/b5d6414e9cd53d7ac89c5c1b3699b806.png" width="320" height="38"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Velocidade do jogo. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se a pausa n√£o estiver ativada e o valor da pausa n√£o estiver atribu√≠do √† escala de tempo, ser√° igual √† velocidade do jogo. </font><font style="vertical-align: inherit;">Al√©m disso, ao remover uma pausa, usamos a velocidade do jogo em vez da unidade.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.Space)) { Time.timeScale = Time.timeScale &gt; pausedTimeScale ? pausedTimeScale : playSpeed; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Time.timeScale &gt; pausedTimeScale) { Time.timeScale = playSpeed; }</code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cen√°rios de loop </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em alguns cen√°rios, pode ser necess√°rio passar por todas as ondas v√°rias vezes. </font><font style="vertical-align: inherit;">√â poss√≠vel implementar o suporte para essa fun√ß√£o, possibilitando repetir os cen√°rios fazendo um loop por todas as ondas v√°rias vezes. </font><font style="vertical-align: inherit;">Voc√™ pode melhorar ainda mais essa fun√ß√£o, por exemplo, ativando a repeti√ß√£o apenas da √∫ltima onda, mas neste tutorial apenas repetiremos o script inteiro.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Avan√ßo c√≠clico nas ondas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione ao </font></font><code>GameScenario</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">controle deslizante de configura√ß√£o para definir o n√∫mero de ciclos, por padr√£o, atribua a ele um valor de 1. No m√≠nimo, fa√ßa zero e o script ser√° repetido indefinidamente. </font><font style="vertical-align: inherit;">Portanto, criaremos um cen√°rio de sobreviv√™ncia que n√£o pode ser derrotado, e o objetivo √© verificar quanto o jogador aguenta.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(0, 10)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cycles = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0c/5d0/9df/d0c5d09dfd50e0e088c1848aaa32d531.png" width="320" height="38"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cen√°rio de dois ciclos. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora ele </font></font><code>GameScenario.State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deve rastrear o n√∫mero do ciclo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cycle, index; EnemyWave.State wave; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameScenario scenario</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scenario = scenario; cycle = <span class="hljs-number"><span class="hljs-number">0</span></span>; index = <span class="hljs-number"><span class="hljs-number">0</span></span>; wave = scenario.waves[<span class="hljs-number"><span class="hljs-number">0</span></span>].Begin(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em </font></font><code>Progress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">executaremos ap√≥s a conclus√£o do incremento do ciclo e retornaremos </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apenas se um n√∫mero suficiente de ciclos tiver passado. </font><font style="vertical-align: inherit;">Caso contr√°rio, redefinimos o √≠ndice de ondas para zero e continuamos a se mover.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> deltaTime = wave.Progress(Time.deltaTime); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (deltaTime &gt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++index &gt;= scenario.waves.Length) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++cycle &gt;= scenario.cycles &amp;&amp; scenario.cycles &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } index = <span class="hljs-number"><span class="hljs-number">0</span></span>; } wave = scenario.waves[index].Begin(); deltaTime = wave.Progress(deltaTime); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Acelera√ß√£o </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se o jogador conseguiu derrotar o ciclo uma vez, ele ser√° capaz de derrot√°-lo novamente sem problemas. Para manter o cen√°rio complexo, precisamos aumentar a complexidade. A maneira mais f√°cil de fazer isso, reduzindo em ciclos subsequentes todas as pausas entre a cria√ß√£o de inimigos. Ent√£o os inimigos aparecer√£o mais rapidamente e inevitavelmente derrotar√£o o jogador no cen√°rio de sobreviv√™ncia. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione um </font></font><code>GameScenario</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">controle deslizante de configura√ß√£o para controlar a acelera√ß√£o por ciclo. Este valor √© adicionado √† escala de tempo ap√≥s cada ciclo apenas para reduzir as pausas. Por exemplo, com uma acelera√ß√£o de 0,5, o primeiro ciclo tem uma velocidade de pausa de √ó 1, o segundo ciclo tem uma velocidade de √ó 1,5, o terceiro √ó 2, o quarto √ó 2,5 e assim por diante.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cycleSpeedUp = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora voc√™ precisa adicionar a escala de tempo e a </font></font><code>GameScenario.State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sempre √© inicialmente igual a 1 e aumenta em um determinado valor de acelera√ß√£o ap√≥s cada ciclo. </font><font style="vertical-align: inherit;">Use-o para escalar </font></font><code>Time.deltaTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">antes de se mover ao longo da onda.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> timeScale; EnemyWave.State wave; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameScenario scenario</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scenario = scenario; cycle = <span class="hljs-number"><span class="hljs-number">0</span></span>; index = <span class="hljs-number"><span class="hljs-number">0</span></span>; timeScale = <span class="hljs-number"><span class="hljs-number">1f</span></span>; wave = scenario.waves[<span class="hljs-number"><span class="hljs-number">0</span></span>].Begin(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> deltaTime = wave.Progress(timeScale * Time.deltaTime); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (deltaTime &gt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++index &gt;= scenario.waves.Length) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++cycle &gt;= scenario.cycles &amp;&amp; scenario.cycles &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } index = <span class="hljs-number"><span class="hljs-number">0</span></span>; timeScale += scenario.cycleSpeedUp; } wave = scenario.waves[index].Begin(); deltaTime = wave.Progress(deltaTime); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qv/-d/3s/qv-d3srpikyuiorxx9vjk06wir8.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tr√™s ciclos com aumento da velocidade de cria√ß√£o do inimigo; </font><font style="vertical-align: inherit;">acelerado dez vezes. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deseja receber informa√ß√µes sobre o lan√ßamento de novos tutoriais? </font><font style="vertical-align: inherit;">Siga minha p√°gina no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patreon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Artigo PDF do </font></a></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reposit√≥rio</font></font></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt466855/">https://habr.com/ru/post/pt466855/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt466839/index.html">A hist√≥ria da cria√ß√£o do Norton Commander. Parte 1/3</a></li>
<li><a href="../pt466841/index.html">Por que uma almofada de aquecimento, se houver um laptop: o estudo da resist√™ncia t√©rmica em n√≠vel at√¥mico</a></li>
<li><a href="../pt466845/index.html">Entrevista reversa: que perguntas fazer √† empresa?</a></li>
<li><a href="../pt466849/index.html">noexcept-ctcheck ou algumas macros simples para ajudar o compilador a escrever c√≥digo noexcept</a></li>
<li><a href="../pt466851/index.html">Linha Agilex - 10nm Intel FPGA</a></li>
<li><a href="../pt466857/index.html">Execu√ß√£o de aplicativos em segundo plano no iOS 13</a></li>
<li><a href="../pt466859/index.html">Usando o servi√ßo AD Federation para autorizar usu√°rios da AWS com distribui√ß√£o de direitos</a></li>
<li><a href="../pt466861/index.html">Como escapar da realidade usando uma hackathon</a></li>
<li><a href="../pt466863/index.html">Configurando Ass√≠ntota</a></li>
<li><a href="../pt466865/index.html">Esperando o primeiro de novembro: proibi√ß√£o ou legaliza√ß√£o de criptomoedas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>