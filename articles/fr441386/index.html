<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∫ üßñüèΩ üéá Spring Data JPA: ce qui est bon et ce qui est mauvais üóø üíáüèª üï¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="B√©b√© est venu voir son p√®re 
 Et a demand√© au b√©b√© 
 - Ce qui est bon 
 et ce qui est mauvais 
 
 Vladimir Mayakovsky 


 Cet article concerne Spring ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Spring Data JPA: ce qui est bon et ce qui est mauvais</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441386/"><p> <em>B√©b√© est venu voir son p√®re</em> <em><br></em>  <em>Et a demand√© au b√©b√©</em> <em><br></em>  <em>- Ce qui est bon</em> <em><br></em>  <em>et ce qui est mauvais</em> <em><br></em> <br>  Vladimir Mayakovsky </p><br><p>  Cet article concerne Spring Data JPA, notamment dans le r√¢teau sous-marin que j'ai rencontr√© en chemin, et bien s√ªr un peu sur les performances. </p><a name="habracut"></a><br><p>  Les exemples d√©crits dans l'article peuvent √™tre ex√©cut√©s dans l'environnement de test, accessible par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©f√©rence</a> . </p><br><div class="spoiler">  <b class="spoiler_title">Remarque pour ceux qui ne sont pas encore pass√©s √† Spring Boot 2</b> <div class="spoiler_text"><p> Dans les versions de Spring Data JPA 2. *, l'interface principale pour travailler avec les r√©f√©rentiels, √† savoir <code>CrudRepository</code> , dont <code>JpaRepository</code> est h√©rit√©, a <code>JpaRepository</code> .  Dans les versions 1. * les principales m√©thodes ressemblaient √† ceci: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CrudRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ID</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findOne</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ID id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Iterable&lt;ID&gt; ids)</span></span></span></span>; }</code> </pre> <br><p>  Dans les nouvelles versions: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CrudRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ID</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">Optional&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ID id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAllById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Iterable&lt;ID&gt; ids)</span></span></span></span>; }</code> </pre> </div></div><br><p>  Commen√ßons donc. </p><br><h4 id="select-t-from-t-where-tid-in-">  s√©lectionnez t. * parmi t o√π t.id dans (...) </h4><br><p>  L'une des requ√™tes les plus courantes est une requ√™te de la forme ¬´s√©lectionner tous les enregistrements pour lesquels la cl√© appartient √† l'ensemble transmis¬ª.  Je suis s√ªr que presque tous ont √©crit ou vu quelque chose comme </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select ba from BankAccount ba where ba.user.id in :ids"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;BankAccount&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByUserIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ids"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> List&lt;Long&gt; ids)</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select ba from BankAccount ba where ba.user.id in :ids"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;BankAccount&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByUserIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ids"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Set&lt;Long&gt; ids)</span></span>;</code> </pre> <br><p>  Ceux-ci fonctionnent, les demandes appropri√©es, il n'y a pas de probl√®me de capture ou de performance, mais il y a un petit inconv√©nient compl√®tement invisible. </p><br><div class="spoiler">  <b class="spoiler_title">Avant d'ouvrir la doublure, essayez de penser par vous-m√™me.</b> <div class="spoiler_text"><p>  L'inconv√©nient est que l'interface est trop √©troite pour transmettre des cl√©s.  "Et alors?"  - dites-vous.  "Eh bien la liste, bien l'ensemble, je ne vois pas de probl√®me ici."  Cependant, si nous regardons les m√©thodes de l'interface racine qui prennent de nombreuses valeurs, alors partout nous voyons <code>Iterable</code> : </p><br><p>  "Et alors? Et je veux une liste. Pourquoi est-ce pire?" <br>  Pas pire, pr√©parez-vous simplement √† l'apparition d'un code similaire √† un niveau sup√©rieur dans votre application: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;BankAccount&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByUserId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Long&gt; userIds)</span></span></span><span class="hljs-function"> </span></span>{ Set&lt;Long&gt; ids = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;&gt;(userIds); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> repository.findByUserIds(ids); } <span class="hljs-comment"><span class="hljs-comment">// public List&lt;BankAccount&gt; findByUserIds(Set&lt;Long&gt; userIds) { List&lt;Long&gt; ids = new ArrayList&lt;&gt;(userIds); return repository.findByUserIds(ids); }</span></span></code> </pre> <br><p>  Ce code ne fait qu'inverser les collections.  Il peut s'av√©rer que l'argument de la m√©thode est une liste, et la m√©thode du r√©f√©rentiel accepte l'ensemble (ou vice versa), et il vous suffit de le r√©organiser pour passer la compilation.  Bien s√ªr, cela ne deviendra pas un probl√®me dans le contexte des frais g√©n√©raux pour la demande elle-m√™me, il s'agit davantage de gestes inutiles. </p><br><p>  Par cons√©quent, il est <code>Iterable</code> utiliser <code>Iterable</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select ba from BankAccount ba where ba.user.id in :ids"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;BankAccount&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByUserIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ids"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Iterable&lt;Long&gt; ids)</span></span>;</code> </pre> <br><p>  Z.Y.  Si nous parlons d'une m√©thode de <code>*RepositoryCustom</code> , alors il est logique d'utiliser <code>Collection</code> pour simplifier le calcul de la taille √† l'int√©rieur de l'impl√©mentation: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BankAccountRepositoryCustom</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anyMoneyAvailable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;Long&gt; accountIds)</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BankAccountRepositoryImpl</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anyMoneyAvailable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;Long&gt; accountIds)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ids.isEmpty()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">//... } }</span></span></code> </pre> </div></div><br><h4 id="lishniy-kod-nepovtoryayuschiesya-klyuchi">  Code suppl√©mentaire: cl√©s non dupliqu√©es </h4><br><p>  Dans la suite de la derni√®re section, je voudrais attirer l'attention sur une id√©e fausse commune: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select ba from BankAccount ba where ba.user.id in :ids"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;BankAccount&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByUserIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ids"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Set&lt;Long&gt; ids)</span></span>;</code> </pre> <br><p>  Autres manifestations de la m√™me erreur: </p><br><pre> <code class="java hljs">Set&lt;Long&gt; ids = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;&gt;(notUniqueIds); List&lt;BankAccount&gt; accounts = repository.findByUserIds(ids); List&lt;Long&gt; ids = ts.stream().map(T::id).distinct().collect(toList()); List&lt;BankAccount&gt; accounts = repository.findByUserIds(ids); Set&lt;Long&gt; ids = ts.stream().map(T::id).collect(toSet()); List&lt;BankAccount&gt; accounts = repository.findByUserIds(ids);</code> </pre> <br><p>  √Ä premi√®re vue, rien d'inhabituel, non? </p><br><div class="spoiler">  <b class="spoiler_title">Prenez votre temps, pensez par vous-m√™me;)</b> <div class="spoiler_text"><p>  Les requ√™tes HQL / JPQL de la forme <code>select t from t where t.field in ...</code> finira par devenir une requ√™te </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> b.* <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> BankAccount b <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> b.user_id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (?, ?, ?, ?, ?, ‚Ä¶)</code> </pre> <br><p>  qui retournera toujours la m√™me chose ind√©pendamment de la pr√©sence de r√©p√©titions dans l'argument.  Par cons√©quent, il n'est pas n√©cessaire de garantir l'unicit√© des cl√©s.  Il existe un cas particulier - Oracle, o√π le fait d'appuyer sur&gt; 1 000 cl√©s d'entr√©e entra√Æne une erreur.  Mais si vous essayez de r√©duire le nombre de cl√©s en excluant les r√©p√©titions, vous devriez plut√¥t r√©fl√©chir √† la raison de leur apparition.  L'erreur est probablement quelque part au-dessus. </p><br><p>  Donc, dans un bon code, utilisez <code>Iterable</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select ba from BankAccount ba where ba.user.id in :ids"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;BankAccount&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByUserIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ids"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Iterable&lt;Long&gt; ids)</span></span>;</code> </pre> </div></div><br><h4 id="samopis">  Samopis </h4><br><p>  Examinez attentivement ce code et trouvez ici trois d√©fauts et une erreur possible: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"from User u where u.id in :ids"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;User&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ids"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Iterable&lt;Long&gt; ids)</span></span>;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Pensez un peu plus</b> <div class="spoiler_text"><ul><li>  tout est d√©j√† impl√©ment√© dans <code>SimpleJpaRepository::findAllById</code> </li><li>  demande inactive lors du passage d'une liste vide (dans <code>SimpleJpaRepository::findAllById</code> il y a une v√©rification correspondante) </li><li>  toutes les requ√™tes d√©crites √† l'aide de <code>@Query</code> sont v√©rifi√©es au stade de l'√©l√©vation du contexte, ce qui prend du temps (contrairement √† <code>SimpleJpaRepository::findAllById</code> ) </li><li>  si Oracle est utilis√©, lorsque la collection de cl√©s est vide, nous obtenons l'erreur <code>ORA-00936: missing expression</code> (ce qui ne se produira pas lors de l'utilisation de <code>SimpleJpaRepository::findAllById</code> , voir point 2) </li></ul></div></div><br><h4 id="garri-potter-i-sostavnoy-klyuch">  Harry potter et cl√© compos√©e </h4><br><p>  Jetez un ≈ìil √† deux exemples et choisissez celui que vous pr√©f√©rez: </p><br><p>  Nombre de m√©thodes fois </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Embeddable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompositeKey</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ Long key1; Long key2; } <span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompositeKeyEntity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@EmbeddedId</span></span> CompositeKey key; }</code> </pre> <br><p>  M√©thode num√©ro deux </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Embeddable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompositeKey</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ Long key1; Long key2; } <span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@IdClass</span></span>(value = CompositeKey.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompositeKeyEntity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> Long key1; <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> Long key2; }</code> </pre> <br><p>  √Ä premi√®re vue, il n'y a aucune diff√©rence.  Essayez maintenant la premi√®re m√©thode et ex√©cutez un test simple: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//case for @EmbeddedId @Test public void findAll() { int size = entityWithCompositeKeyRepository.findAllById(compositeKeys).size(); assertEquals(size, 5); }</span></span></code> </pre> <br><p>  Dans le journal des requ√™tes (vous le gardez, non?) Nous verrons ceci: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> e.key1, e.key2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> CompositeKeyEntity e <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> e.key1 = ? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2 = ? <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> e.key1 = ? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2 = ? <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> e.key1 = ? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2 = ? <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> e.key1 = ? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2 = ? <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> e.key1 = ? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2 = ?</code> </pre> <br><p>  Maintenant, deuxi√®me exemple </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//case for @Id @Id @Test public void _findAll() { int size = anotherEntityWithCompositeKeyRepository.findAllById(compositeKeys).size(); assertEquals(size, 5); }</span></span></code> </pre> <br><p>  Le journal des requ√™tes est diff√©rent: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> e.key1, e.key2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> CompositeKeyEntity e <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> e.key1=? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2=? <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> e.key1, e.key2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> CompositeKeyEntity e <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> e.key1=? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2=? <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> e.key1, e.key2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> CompositeKeyEntity e <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> e.key1=? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2=? <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> e.key1, e.key2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> CompositeKeyEntity e <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> e.key1=? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2=? <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> e.key1, e.key2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> CompositeKeyEntity e <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> e.key1=? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2=?</code> </pre> <br><p>  C'est toute la diff√©rence: dans le premier cas, nous recevons toujours 1 demande, dans le second - n demandes. <br>  La raison de ce comportement r√©side dans <code>SimpleJpaRepository::findAllById</code> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// ... if (entityInfo.hasCompositeId()) { List&lt;T&gt; results = new ArrayList&lt;&gt;(); for (ID id : ids) { findById(id).ifPresent(results::add); } return results; } // ...</span></span></code> </pre> <br><p>  La m√©thode qui vous convient le mieux est de d√©terminer en fonction de l'importance du nombre de demandes. </p><br><h4 id="lishniy-crudrepositorysave">  Extra CrudRepository :: enregistrer </h4><br><p>  Souvent, dans le code, il existe un tel contre-motif: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BankAccount </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateRate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id, BigDecimal rate)</span></span></span><span class="hljs-function"> </span></span>{ BankAccount account = repo.findById(id).orElseThrow(NPE::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); account.setRate(rate); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> repo.save(account); }</code> </pre> <br><p>  Le lecteur est perplexe: o√π est l'anti-mod√®le?  Ce code semble tr√®s logique: nous obtenons l'entit√© - mise √† jour - sauvegarde.  Tout est comme dans les meilleures maisons de Saint-P√©tersbourg.  J'ose dire que l'appel de <code>CrudRepository::save</code> est superflu ici. </p><br><p>  Premi√®rement: la m√©thode <code>updateRate</code> transactionnelle, par cons√©quent, toutes les modifications dans l'entit√© g√©r√©e sont suivies par Hibernate et se transforment en demande lorsque <code>Session::flush</code> ex√©cut√©e, ce qui se produit dans ce code √† la fin de la m√©thode. </p><br><p>  Deuxi√®mement, <code>CrudRepository::save</code> un coup d'≈ìil √† la m√©thode <code>CrudRepository::save</code> .  Comme vous le savez, tous les r√©f√©rentiels sont bas√©s sur <code>SimpleJpaRepository</code> .  Voici l'impl√©mentation de <code>CrudRepository::save</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;S extends T&gt; <span class="hljs-function"><span class="hljs-function">S </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(S entity)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entityInformation.isNew(entity)) { em.persist(entity); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> entity; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> em.merge(entity); } }</code> </pre> <br><p>  Il y a une subtilit√© dont tout le monde ne se souvient pas: Hibernate fonctionne √† travers les √©v√©nements.  En d'autres termes, chaque action utilisateur g√©n√®re un √©v√©nement qui est mis en file d'attente et trait√© en tenant compte d'autres √©v√©nements dans la m√™me file d'attente.  Dans ce cas, un appel √† <code>EntityManager::merge</code> g√©n√®re un <code>MergeEvent</code> , qui est trait√© par d√©faut dans la <code>DefaultMergeEventListener::onMerge</code> .  Il contient une logique assez ramifi√©e mais simple pour chacun des √©tats de l'argument entit√©.  Dans notre cas, l'entit√© est obtenue √† partir du r√©f√©rentiel √† l'int√©rieur de la m√©thode transactionnelle et est √† l'√©tat PERSISTANT (c'est-√†-dire essentiellement contr√¥l√©e par le framework): </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">entityIsPersistent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MergeEvent event, Map copyCache)</span></span></span><span class="hljs-function"> </span></span>{ LOG.trace(<span class="hljs-string"><span class="hljs-string">"Ignoring persistent instance"</span></span>); Object entity = event.getEntity(); EventSource source = event.getSession(); EntityPersister persister = source.getEntityPersister(event.getEntityName(), entity); ((MergeContext)copyCache).put(entity, entity, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cascadeOnMerge(source, persister, entity, copyCache); <span class="hljs-comment"><span class="hljs-comment">//&lt;---- this.copyValues(persister, entity, entity, source, copyCache); //&lt;---- event.setResult(entity); }</span></span></code> </pre> <br><p>  Le diable est dans les d√©tails, √† savoir dans les m√©thodes <code>DefaultMergeEventListener::cascadeOnMerge</code> et <code>DefaultMergeEventListener::copyValues</code> .  √âcoutons le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">discours direct de Vlad Mikhalche</a> , l'un des principaux d√©veloppeurs d'Hibernate: </p><br><blockquote>  Dans l'appel de m√©thode copyValues, l'√©tat hydrat√© est √† nouveau copi√©, de sorte qu'un nouveau tableau est cr√©√© de mani√®re redondante, ce qui gaspille les cycles CPU.  Si l'entit√© a des associations enfants et que l'op√©ration de fusion est √©galement r√©percut√©e des entit√©s parent aux entit√©s enfant, la surcharge est encore plus importante car chaque entit√© enfant propage un √©v√©nement MergeEvent et le cycle se poursuit. </blockquote><p>  En d'autres termes, on fait du travail que vous ne pouvez pas faire.  En cons√©quence, notre code peut √™tre simplifi√© tout en am√©liorant ses performances: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BankAccount </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateRate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id, BigDecimal rate)</span></span></span><span class="hljs-function"> </span></span>{ BankAccount account = repo.findById(id).orElseThrow(NPE::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); account.setRate(rate); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> account; }</code> </pre> <br><p>  Bien s√ªr, il n'est pas pratique de garder cela √† l'esprit lors du d√©veloppement et de la relecture du code de quelqu'un d'autre, nous aimerions donc apporter des modifications au niveau de la structure filaire afin que la m√©thode <code>JpaRepository::save</code> perde ses propri√©t√©s nuisibles.  Est-ce possible? </p><br><div class="spoiler">  <b class="spoiler_title">Oui peut-√™tre</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// @Transactional public &lt;S extends T&gt; S save(S entity) { if (entityInformation.isNew(entity)) { em.persist(entity); return entity; } else { return em.merge(entity); } } // @Transactional public &lt;S extends T&gt; S save(S entity) { if (entityInformation.isNew(entity)) { em.persist(entity); return entity; } else if (!em.contains(entity)) { return em.merge(entity); } return entity; }</span></span></code> </pre> <br><p>  Ces changements ont en effet √©t√© op√©r√©s en d√©cembre 2017: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://jira.spring.io/browse/DATAJPA-931</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/spring-projects/spring-data-jpa/pull/237</a> </p></div></div><br><p>  Cependant, le lecteur averti a probablement d√©j√† senti que quelque chose n'allait pas.  En effet, ce changement ne cassera rien, mais seulement dans le cas simple o√π il n'y a pas d'entit√©s enfants: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BankAccount</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@Column</span></span> BigDecimal rate = BigDecimal.ZERO; }</code> </pre> <br><p>  Supposons maintenant que son propri√©taire soit li√© au compte: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BankAccount</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@Column</span></span> BigDecimal rate = BigDecimal.ZERO; <span class="hljs-meta"><span class="hljs-meta">@ManyToOne</span></span> <span class="hljs-meta"><span class="hljs-meta">@JoinColumn</span></span>(name = <span class="hljs-string"><span class="hljs-string">"user_id"</span></span>) User user; }</code> </pre> <br><p>  Il existe une m√©thode qui vous permet de d√©connecter l'utilisateur du compte et de transf√©rer ce dernier au nouvel utilisateur: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BankAccount </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">changeUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id, User newUser)</span></span></span><span class="hljs-function"> </span></span>{ BankAccount account = repo.findById(id).orElseThrow(NPE::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); account.setUser(newUser); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> repo.save(account); }</code> </pre> <br><p>  Que va-t-il se passer maintenant?  La v√©rification de <code>em.contains(entity)</code> renvoie true, ce qui signifie que <code>em.merge(entity)</code> ne sera pas appel√©.  Si la cl√© d'entit√© <code>User</code> est cr√©√©e sur la base de la s√©quence (l'un des cas les plus courants), elle ne sera pas cr√©√©e jusqu'√† ce que la transaction soit termin√©e (ou que <code>Session::flush</code> appel√©e manuellement), c'est-√†-dire que l'utilisateur sera √† l'√©tat D√âTACH√â et son entit√© parent ( compte) - √† l'√©tat PERSISTANT.  Dans certains cas, cela peut briser la logique d'application, ce qui s'est produit: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">02/03/2018 DATAJPA-931 interrompt la fusion avec RepositoryItemWriter</a> </p><br><p>  √Ä cet √©gard, la t√¢che <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Revert optimisations effectu√©es pour les entit√©s existantes dans CrudRepository :: save a √©t√© cr√©√©e</a> et les modifications ont √©t√© apport√©es: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Revert DATAJPA-931</a> . </p><br><h4 id="slepoy-crudrepositoryfindbyid">  Blind CrudRepository :: findById </h4><br><p>  Nous continuons √† consid√©rer le m√™me mod√®le de donn√©es: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> Long id; <span class="hljs-comment"><span class="hljs-comment">// ... } @Entity public class BankAccount { @Id Long id; @ManyToOne @JoinColumn(name = "user_id") User user; }</span></span></code> </pre> <br><p>  L'application a une m√©thode qui cr√©e un nouveau compte pour l'utilisateur sp√©cifi√©: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BankAccount </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newForUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long userId)</span></span></span><span class="hljs-function"> </span></span>{ BankAccount account = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BankAccount(); userRepository.findById(userId).ifPresent(account::setUser); <span class="hljs-comment"><span class="hljs-comment">//&lt;---- return accountRepository.save(account); }</span></span></code> </pre> <br><p>  Avec la version 2. * l'anti-mod√®le indiqu√© par la fl√®che n'est pas si frappant - il est plus clairement visible sur les anciennes versions: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BankAccount </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newForUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long userId)</span></span></span><span class="hljs-function"> </span></span>{ BankAccount account = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BankAccount(); account.setUser(userRepository.findOne(userId)); <span class="hljs-comment"><span class="hljs-comment">//&lt;---- return accountRepository.save(account); }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Si vous ne voyez pas la faille \ "√† l'oeil \", jetez un ≈ìil aux requ√™tes:</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> u.id, u.name <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> u <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> u.id = ? <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> hibernate_sequence <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> bank_account (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*‚Ä¶*/</span></span> user_id) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-comment"><span class="hljs-comment">/*‚Ä¶*/</span></span>)</code> </pre> </div></div><br><p>  La premi√®re demande, nous obtenons l'utilisateur par cl√©.  Ensuite, nous obtenons la cl√© du compte nouveau-n√© de la base de donn√©es et l'ins√©rons dans le tableau.  Et la seule chose que nous prenons √† l'utilisateur est la cl√©, que nous avons d√©j√† comme argument de m√©thode.  D'un autre c√¥t√©, <code>BankAccount</code> contient le champ "utilisateur" et nous ne pouvons pas le laisser vide (en tant que personnes d√©centes, nous d√©finissons une restriction dans le sch√©ma).  Les d√©veloppeurs exp√©riment√©s voient probablement d√©j√† un moyen <del>  et manger un poisson et monter √† cheval </del>  obtenir √† la fois l'utilisateur et la demande de ne pas: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BankAccount </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newForUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long userId)</span></span></span><span class="hljs-function"> </span></span>{ BankAccount account = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BankAccount(); account.setUser(userRepository.getOne(userId)); <span class="hljs-comment"><span class="hljs-comment">//&lt;---- return accountRepository.save(account); }</span></span></code> </pre> <br><p>  <code>JpaRepository::getOne</code> retourne un wrapper sur la cl√© qui a le m√™me type que "l'entit√©" vivante.  Ce code ne donne que deux requ√™tes: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> hibernate_sequence <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> bank_account (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*‚Ä¶*/</span></span> user_id) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-comment"><span class="hljs-comment">/*‚Ä¶*/</span></span>)</code> </pre> <br><p>  Lorsqu'une entit√© en cours de cr√©ation contient de nombreux champs avec une relation plusieurs √† un / un √† un, cette technique permet d'acc√©l√©rer l'enregistrement et de r√©duire la charge sur la base de donn√©es. </p><br><h4 id="ispolnenie-hql-zaprosov">  Ex√©cution de requ√™tes HQL </h4><br><p>  Il s'agit d'un sujet distinct et int√©ressant :).  Le mod√®le de domaine est le m√™me et il existe une telle demande: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select count(ba) "</span></span> + <span class="hljs-string"><span class="hljs-string">" from BankAccount ba "</span></span> + <span class="hljs-string"><span class="hljs-string">" join ba.user user "</span></span> + <span class="hljs-string"><span class="hljs-string">" where user.id = :id"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">countUserAccounts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"id"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Long id)</span></span>;</code> </pre> <br><p>  Consid√©rez le HQL "pur": </p><br><pre> <code class="plaintext hljs">select count(ba) from BankAccount ba join ba.user user where user.id = :id</code> </pre> <br><p>  Lors de son ex√©cution, la requ√™te SQL suivante sera cr√©√©e: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(ba.id) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bank_account ba <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> u <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ba.user_id = u.id <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> u.id = ?</code> </pre> <br><p>  Le probl√®me ici n'est pas imm√©diatement √©vident, m√™me par une vie sage et des d√©veloppeurs SQL bien compris: <code>inner join</code> par cl√© utilisateur exclura les comptes avec <code>user_id</code> manquant de l'√©chantillon (et dans le bon sens, l'insertion de ceux-ci devrait √™tre interdite au niveau du sch√©ma), ce qui signifie qu'il n'est pas <code>user_id</code> de rejoindre la table <code>user</code> du tout besoin de.  La demande peut √™tre simplifi√©e (et acc√©l√©r√©e): </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(ba.id) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bank_account ba <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> ba.user_id = ?</code> </pre> <br><p>  Il existe un moyen d'obtenir facilement ce comportement en c √† l'aide de HQL: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select count(ba) "</span></span> + <span class="hljs-string"><span class="hljs-string">" from BankAccount ba "</span></span> + <span class="hljs-string"><span class="hljs-string">" where ba.user.id = :id"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">countUserAccounts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"id"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Long id)</span></span>;</code> </pre> <br><p>  Cette m√©thode cr√©e une requ√™te ¬´all√©g√©e¬ª. </p><br><h4 id="annotaciya-query-protiv-metoda">  R√©sum√© de la requ√™te et de la m√©thode </h4><br><p>  L'une des principales caract√©ristiques de Spring Data est la possibilit√© de cr√©er une requ√™te √† partir du nom de la m√©thode, ce qui est tr√®s pratique, en particulier en combinaison avec le module compl√©mentaire intelligent d'IntelliJ IDEA.  La requ√™te d√©crite dans l'exemple pr√©c√©dent peut √™tre facilement r√©√©crite: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// @Query("select count(ba) " + " from BankAccount ba " + " where ba.user.id = :id") long countUserAccounts(@Param("id") Long id); // long countByUserAccount_Id(Long id);</span></span></code> </pre> <br><p>  Il semble √™tre plus simple, plus court et plus lisible, et surtout - vous n'avez pas besoin de regarder la demande elle-m√™me.  J'ai lu le nom de la m√©thode - et c'est d√©j√† clair ce qu'elle choisit et comment.  Mais le diable est ici dans les d√©tails.  Nous avons d√©j√† vu la derni√®re requ√™te pour la m√©thode marqu√©e avec <code>@Query</code> .  Que se passera-t-il dans le deuxi√®me cas? </p><br><div class="spoiler">  <b class="spoiler_title">Babah!</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(ba.id) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bank_account ba <span class="hljs-keyword"><span class="hljs-keyword">left</span></span> <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> // &lt;<span class="hljs-comment"><span class="hljs-comment">--- !!!!!!! user u on ba.user_id = u.id where u.id = ?</span></span></code> </pre> </div></div><br><p>  "Que diable!?"  - s'exclamera le d√©veloppeur.  Apr√®s tout, nous avons d√©j√† vu que <del>  violoniste </del>  <code>join</code> pas n√©cessaire. </p><br><p>  La raison est prosa√Øque: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JPADATAJPA-729 OUTER JOIN inutiles sont g√©n√©r√©s pour compter une seule table</a> </li><li><del>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DATAJPA-1238 Inutile LEFT OUTER JOIN inutile quand un WHERE aurait pu √™tre utilis√©</a> </del></li></ul><br><p>  Si vous n'avez pas encore mis √† niveau vers les versions corrig√©es et que rejoindre la table ralentit la demande ici et maintenant, alors ne d√©sesp√©rez pas: il y a deux fa√ßons de soulager la douleur: </p><br><ul><li><p>  une bonne fa√ßon est d'ajouter <code>optional = false</code> (si le circuit le permet): </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BankAccount</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@ManyToOne</span></span> <span class="hljs-meta"><span class="hljs-meta">@JoinColumn</span></span>(name = <span class="hljs-string"><span class="hljs-string">"user_id"</span></span>, optional = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) User user; }</code> </pre> <br></li><li><p>  La mani√®re la plus simple consiste √† ajouter une colonne du m√™me type que la cl√© d'entit√© <code>User</code> et √† l'utiliser dans des requ√™tes au lieu du champ <code>user</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BankAccount</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@ManyToOne</span></span> <span class="hljs-meta"><span class="hljs-meta">@JoinColumn</span></span>(name = <span class="hljs-string"><span class="hljs-string">"user_id"</span></span>) User user; <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(name = <span class="hljs-string"><span class="hljs-string">"user_id"</span></span>, insertable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, updatable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) Long userId; }</code> </pre> <br><p>  Maintenant, la m√©thode request-from-method sera plus agr√©able: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">countByUserId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id)</span></span></span></span>;</code> </pre> <br><p>  donne </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(ba.id) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bank_account ba <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> ba.user_id = ?</code> </pre> <br><p>  qu'avons-nous r√©alis√©. </p><br></li></ul><br><h4 id="ogranichenie-vyborki">  Limite d'√©chantillonnage </h4><br><p>  Pour nos besoins, nous devons limiter la s√©lection (par exemple, nous voulons renvoyer <code>Optional</code> partir de la m√©thode <code>*RepositoryCustom</code> ): </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> ba.* <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bank_account ba <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> ba.rate <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> ?</code> </pre> <br><p>  Maintenant Java: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Optional&lt;BankAccount&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findWithHighestRate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ String query = <span class="hljs-string"><span class="hljs-string">"select b from BankAccount b order by b.rate"</span></span>; BankAccount account = em .createQuery(query, BankAccount.class) .setFirstResult(<span class="hljs-number"><span class="hljs-number">0</span></span>) .setMaxResults(<span class="hljs-number"><span class="hljs-number">1</span></span>) .getSingleResult(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Optional.ofNullable(bankAccount); }</code> </pre> <br><p>  Le code sp√©cifi√© a une caract√©ristique d√©sagr√©able: dans le cas o√π la demande retourne une s√©lection vide, une exception sera lev√©e </p><br><pre> <code class="plaintext hljs">Caused by: javax.persistence.NoResultException: No entity found for query</code> </pre> <br><p>  Dans les projets que j'ai vus, cela a √©t√© r√©solu de deux mani√®res principales: </p><br><ul><li>  try-catch avec des variantes de la <code>Optonal.empty()</code> exception et le retour d' <code>Optonal.empty()</code> √† des m√©thodes plus avanc√©es, comme passer un lambda avec une requ√™te √† une m√©thode utilitaire </li><li>  aspect dans lequel les m√©thodes de r√©f√©rentiel sont renvoy√©es renvoy√©es <code>Optional</code> </li></ul><br><p>  Et tr√®s rarement, j'ai vu la bonne solution: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Optional&lt;BankAccount&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findWithHighestRate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ String query = <span class="hljs-string"><span class="hljs-string">"select b from BankAccount b order by b.rate"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> em.unwrap(Session.class) .createQuery(query, BankAccount.class) .setFirstResult(<span class="hljs-number"><span class="hljs-number">0</span></span>) .setMaxResults(<span class="hljs-number"><span class="hljs-number">1</span></span>) .uniqueResultOptional(); }</code> </pre> <br><p>  <code>EntityManager</code> fait partie de la norme JPA, tandis que <code>Session</code> appartient √† Hibernate et est √† mon humble avis un outil plus avanc√©, qui est souvent oubli√©. </p><br><h4 id="inogda-vrednoe-uluchshenie">  [Parfois] am√©lioration n√©faste </h4><br><p>  Lorsque vous avez besoin d'obtenir un petit champ √† partir d'une entit√© "√©paisse", nous faisons ceci: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select a.available from BankAccount a where a.id = :id"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findIfAvailable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"id"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Long id)</span></span>;</code> </pre> <br><p>  La demande vous permet d'obtenir un champ de type <code>boolean</code> sans charger l'entit√© enti√®re (avec l'ajout d'un cache de premier niveau, la v√©rification des modifications √† la fin de la session et d'autres d√©penses).  Parfois, cela non seulement n'am√©liore pas les performances, mais vice versa - il cr√©e des requ√™tes inutiles √† partir de z√©ro.  Imaginez un code qui effectue quelques v√©rifications: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkAccount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id)</span></span></span><span class="hljs-function"> </span></span>{ BankAccount acc = repository.findById(id).orElseThow(NPE::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... return repository.findIfAvailable(id); }</span></span></code> </pre> <br><p>  Ce code fait au moins 2 requ√™tes, bien que la seconde puisse √™tre √©vit√©e: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkAccount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id)</span></span></span><span class="hljs-function"> </span></span>{ BankAccount acc = repository.findById(id).orElseThow(NPE::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... return repository.findById(id) //    .map(BankAccount::isAvailable) .orElseThrow(IllegalStateException::new); }</span></span></code> </pre> <br><p>  La conclusion est simple: ne n√©gligez pas le cache du premier niveau, dans le cadre d'une transaction, seul le premier <code>JpaRepository::findById</code> fait r√©f√©rence √† la base de donn√©es, <code>JpaRepository::findById</code> cache du premier niveau est toujours <code>JpaRepository::findById</code> et li√© √† une session, qui est g√©n√©ralement li√©e √† la transaction en cours. </p><br><p>  Tests avec lesquels jouer (le lien vers le r√©f√©rentiel est donn√© au d√©but de l'article): </p><br><ul><li>  test d'interface √©troite: <code>InterfaceNarrowingTest</code> </li><li>  tester un exemple avec une cl√© composite: <code>EntityWithCompositeKeyRepositoryTest</code> </li><li>  tester l'exc√®s de <code>CrudRepository::save</code> : <code>ModifierTest.java</code> </li><li>  test aveugle <code>CrudRepository::findById</code> : <code>ChildServiceImplTest</code> </li><li>  test de <code>left join</code> inutile: <code>BankAccountControlRepositoryTest</code> </li></ul><br><p>  Le co√ªt d'un appel suppl√©mentaire √† <code>CrudRepository::save</code> peut √™tre calcul√© √† l'aide de <code>RedundantSaveBenchmark</code> .  Il est lanc√© √† l'aide de la classe <code>BenchmarkRunner</code> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr441386/">https://habr.com/ru/post/fr441386/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr441376/index.html">Au-del√† de la puret√©: ce qui peut et ce qui ne peut pas inverser la membrane d'osmose</a></li>
<li><a href="../fr441378/index.html">Chercheurs de Google: pour se prot√©ger contre Spectre, il faut changer l'architecture du processeur, les correctifs logiciels n'aideront pas</a></li>
<li><a href="../fr441380/index.html">7 points de croissance de conversion ou comment augmenter la cliquabilit√© des boutons</a></li>
<li><a href="../fr441382/index.html">Des scientifiques chinois ont d√©velopp√© un g√©n√©rateur pi√©zo√©lectrique pour stimulateur cardiaque</a></li>
<li><a href="../fr441384/index.html">Impression en masse sous Windows</a></li>
<li><a href="../fr441388/index.html">Rayures z√©br√©es - c'est une zone d'exclusion a√©rienne pour les moucherons</a></li>
<li><a href="../fr441390/index.html">Pas seulement un t√©l√©phone pliable: Samsung a mis √† jour toute sa gamme d'appareils portables</a></li>
<li><a href="../fr441392/index.html">Les fonctions CPU RDRAND et RDSEED sont d√©sormais disponibles</a></li>
<li><a href="../fr441394/index.html">Art ASCII "appliqu√©"</a></li>
<li><a href="../fr441398/index.html">Cruise ouvre le code source de Worldview</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>