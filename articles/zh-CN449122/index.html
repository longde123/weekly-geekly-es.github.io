<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👷🏼 🗃️ 😁 遗憾的是，在C ++中缺少一个成熟的static if或... 👨🏽‍🎤 👃🏼 💇🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="...如何根据模板参数的值用不同的内容填充模板类？ 


很久以来，考虑到C ++的经验，D语言就开始被制造为“正确的C ++”。 随着时间的流逝，D已变得比C ++复杂，表达能力更强的语言。 并且C ++已经开始监视D。例如，在我看来， if constexpr是直接从D借来的，则C ++ 17中...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>遗憾的是，在C ++中缺少一个成熟的static if或...</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449122/"><p> <strong>...如何根据模板参数的值用不同的内容填充模板类？</strong> </p><br><p>很久以来，考虑到C ++的经验，D语言就开始被制造为“正确的C ++”。 随着时间的流逝，D已变得比C ++复杂，表达能力更强的语言。 并且C ++已经开始监视D。例如，在我看来， <code>if constexpr</code>是直接从D借来的，则C ++ 17中<code>if constexpr</code>出现了，D的原型是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">D-shny static if</a> 。 </p><br><p> 不幸的是， <code>if constexpr</code> C ++中的<code>if constexpr</code>与D中的<code>static if</code>函数不具有相同的功能。这是有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">原因的</a> ，但是在某些情况下，您只能后悔<code>if constexpr</code> C ++中的<code>if constexpr</code>不允许您控制C +的内容+类。 我想谈谈其中一种情况。 </p><br><p> 我们将讨论如何制作一个模板类，其内容（即方法的组成和某些方法的逻辑）将根据传递给该模板类的参数而改变。 从现实生活中以开发<a href="">SObjectizer新版本</a>的经验<a href="">为例</a> 。 </p><br><h1 id="zadacha-kotoruyu-trebuetsya-reshit"> 要解决的任务 </h1><br><p> 需要创建用于存储消息对象的“智能指针”的精巧版本。 这样您就可以编写如下内容： </p><a name="habracut"></a><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>&lt;my_message&gt; msg{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> my_message{...} }; send(target, msg); send(another_target, msg);</code> </pre> <br><p> 这个<code>message_holder_t</code>类的技巧是要考虑三个重要因素。 </p><br><h2 id="ot-chego-otnasledovan-tip-soobscheniya"> 消息的类型是什么？ </h2><br><p> 参数化<code>message_holder_t</code>的消息类型分为两组。 第一组是从特殊基本类型<code>message_t</code>继承的消息。 例如： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">so5_message</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">message_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> b_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds c_; so5_message(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> b, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds c) : a_{a}, b_{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(b)}, c_{c} {} };</code> </pre> <br><p> 在这种情况下，自身内部的message_holder_t应该只包含一个指向此类型对象的指针。 相同的指针应在getter方法中返回。 也就是说，对于来自<code>message_t</code>的继承人<code>message_t</code>应该有类似以下内容： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">message_holder_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt;M&gt; m_msg; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> M * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_msg.get(); } };</code> </pre> <br><p> 第二组是不从<code>message_t</code>继承的任意用户类型的消息。 例如： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">user_message</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> b_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds c_; user_message(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> b, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds c) : a_{a}, b_{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(b)}, c_{c} {} };</code> </pre> <br><p>  SObjectizer中这些类型的实例不是自己发送的，而是封装在特殊的包装中，即<code>user_type_message_t&lt;M&gt;</code> ，该包装已从<code>message_t</code>继承。 因此，对于此类类型， <code>message_holder_t</code>必须在其中包含指向<code>user_type_message_t&lt;M&gt;</code>的指针，而getter方法必须返回指向M的指针： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">message_holder_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">user_type_message_t</span></span>&lt;M&gt;&gt; m_msg; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> M * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::addressof(m_msg-&gt;m_payload); } };</code> </pre> <br><h2 id="immutabelnost-ili-mutabelnost-soobscheniy"> 消息的抗扰性或可变性 </h2><br><p> 第二个因素是将消息分为不可变和可变的。 如果消息是不可变的（默认情况下是不可变的），则getter方法必须返回指向消息的常量指针。 如果是可变的，则获取器必须返回一个非恒定指针。 即 应该是这样的： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>&lt;so5_message&gt; msg1{...}; <span class="hljs-comment"><span class="hljs-comment">//  . const int a = msg1-&gt;a_; // OK. msg1-&gt;a_ = 0; //     ! message_holder_t&lt;mutable_msg&lt;user_message&gt;&gt; msg2{...}; //  . const int a = msg2-&gt;a_; // OK. msg2-&gt;a_ = 0; // OK.</span></span></code> </pre> <br><h2 id="shared_ptr-vs-unique_ptr">  shared_ptr和unique_ptr </h2><br><p> 第三个因素是<code>message_holder_t</code>作为智能指针的行为的逻辑。 一旦它应该表现得像<code>std::shared_ptr</code> ，即 您可以有多个message_holders引用同一个消息实例。 并且一旦它的行为就像<code>std::unique_ptr</code> ，即 只有一个message_holder实例可以引用一个消息实例。 </p><br><p> 默认情况下， <code>message_holder_t</code>的行为应取决于消息的可变性/不可变性。 即 对于不可变消息， <code>message_holder_t</code>行为应类似于<code>std::shared_ptr</code> ，对于可变<code>std::unique_ptr</code>如<code>std::unique_ptr</code> ： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>&lt;so5_message&gt; msg1{...}; <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>&lt;so5_message&gt; msg2 = msg; <span class="hljs-comment"><span class="hljs-comment">// OK. message_holder_t&lt;mutable_msg&lt;user_message&gt;&gt; msg3{...}; message_holder_t&lt;mutable_msg&lt;user_message&gt;&gt; msg4 = msg3; // !  ! message_holder_t&lt;mutable_msg&lt;user_message&gt;&gt; msg5 = std::move(msg3); // OK.</span></span></code> </pre> <br><p> 但是生活是一件复杂的事情，因此您还需要能够手动设置<code>message_holder_t</code>行为。 这样就可以使message_holder成为行为不变的消息，其行为类似于unique_ptr。 这样您就可以使message_holder用于行为类似于shared_ptr的可变消息： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> unique_so5_message = so_5::<span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>&lt; so5_message, so_5::<span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span>::unique&gt;; unique_so5_message msg1{...}; unique_so5_message msg2 = msg1; <span class="hljs-comment"><span class="hljs-comment">// !  ! unique_so5_message msg3 = std::move(msg); // OK,   msg3. using shared_user_messsage = so_5::message_holder_t&lt; so_5::mutable_msg&lt;user_message&gt;, so_5::message_ownership_t::shared&gt;; shared_user_message msg4{...}; shared_user_message msg5 = msg4; // OK.</span></span></code> </pre> <br><p> 因此，当<code>message_holder_t</code>像shared_ptr一样工作时，它应该具有通常的构造函数和赋值运算符集：复制和移动。 此外，必须有一个常量方法<code>make_reference</code> ，该方法返回存储在<code>message_holder_t</code>内部的指针的副本。 </p><br><p> 但是，当<code>message_holder_t</code>像unique_ptr一样工作时，则应禁止使用构造函数和复制运算符。 并且<code>make_reference</code>方法应该从<code>message_holder_t</code>对象<em>获取</em>指针：调用<code>make_reference</code>原始<code>message_holder_t</code>应该保持为空。 </p><br><h2 id="chut-bolee-formalno"> 正式一点 </h2><br><p> 因此，您需要创建一个模板类： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M, <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span> Ownership = <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span>::autodetected&gt; class <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span> {...};</code> </pre> <br><p> 其中： </p><br><ul><li> 应该将<code>intrusive_ptr_t&lt;M&gt;</code>或<code>intrusive_ptr&lt;user_type_message_t&lt;M&gt;&gt;</code>存储在内部，具体取决于M是否从<code>message_t</code>继承而来； </li><li>  getter方法必须根据消息的可变性/不可变性返回<code>const M*</code>或<code>M*</code> 。 </li><li> 应该有一组完整的构造函数和复制/移动运算符，或者只有一个构造函数和移动运算符 </li><li>  <code>make_reference()</code>方法应返回存储的intrusive_ptr的副本，或者应采用intrusive_ptr的值并将原始<code>message_holder_t</code>保留为空。 在第一种情况下， <code>make_reference()</code>必须为常量，在第二种方法-非常量方法中。 </li></ul><br><p> 列表中的最后两项是由Ownership参数确定的（如果所有权<code>autodetected</code>使用<code>autodetected</code>的话，还有消息的可变性）。 </p><br><h1 id="kak-eto-bylo-resheno"> 如何决定 </h1><br><p> 在本节中，我们将考虑构成最终解决方案的所有组件。 好吧，最终的解决方案本身。 将显示清除了所有令人分心细节的代码片段。 如果有人对真实代码感兴趣，那么可以<a href="">在此处查看</a> 。 </p><br><h2 id="disclaimer"> 免责声明 </h2><br><p> 下面显示的解决方案并不装作精美，理想或榜样。 在截止日期的压力下，可以在短时间内找到，实施，测试和记录该文档。 也许如果有更多的时间，并且有更多的人在寻找解决方案， <del> 年轻的 </del> 在现代C ++开发人员中明智且博学，它将变得更加紧凑，更简单和更易于理解。 但是，事实证明，它发生了……一般来说，“不要射击钢琴家”。 </p><br><h2 id="posledovatelnost-shagov-i-uzhe-gotovaya-shablonnaya-magiya"> 步骤顺序和现成的模板魔术 </h2><br><p> 因此，我们需要一个带有几组方法的类。 这些工具包中的物品必须来自某个地方。 从哪里来？ </p><br><p> 在D中，我们可以使用<code>static if</code>并根据不同条件定义类的不同部分。 在某些Ruby中，我们可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用include方法将方法混合到类中</a> 。 但是我们在C ++中，到目前为止，我们的可能性非常有限：我们可以直接在类内部定义方法/属性，也可以从某些基类继承该方法/属性。 </p><br><p> 我们不能根据某些条件在类内定义不同的方法/属性，因为  <code>if constexpr</code>不是D <code>static if</code> C ++ <code>static if</code> 。 因此，仅保留继承。 </p><br><blockquote>  <strong>更新。</strong> 正如评论中建议的那样，我在这里应该更仔细地讲。 由于C ++具有SFINAE，因此我们可以通过SFINAE启用/禁用类中各个方法的可见性（即达到类似于<code>static if</code>的效果）。 但是我认为这种方法有两个严重的缺点。 首先，如果这些方法不是1-2-3，而是4-5或更多，那么使用SFINAE格式化每个方法就很麻烦，这会影响代码的可读性。 其次，SFINAE无法帮助我们添加/删除类属性（字段）。 </blockquote><p> 在C ++中，我们可以定义几个基类，然后从这些基类继承<code>message_holder_t</code> 。 并且已经使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">std :: conditional</a>根据模板参数的值来选择一个或另一个基类。 </p><br><p> 但是诀窍在于，我们不仅需要一组基类，还需要一小部分继承链。 在开始时，将有一个类来确定在任何情况下都将需要的常规功能。 接下来是将确定“智能指针”行为逻辑的基类。 然后将有一个确定必要的获取方法的类。 按此顺序，我们将考虑实现的类。 </p><br><p>  SObjectizer已经具有现成的模板魔术<a href="">来</a>简化我们的任务，该魔术<a href="">可以确定是否从message_t继承消息</a> ，以及<a href="">检查消息可变性的方法</a> 。 因此，在实现中，我们将仅使用此现成的魔术，而不会深入研究其工作细节。 </p><br><h2 id="obschaya-baza-dlya-hraneniya-ukazatelya"> 通用指针存储库 </h2><br><p> 让我们从存储相应的intrusive_ptr的通用基本类型开始，还提供任何<code>message_holder_t</code>实现所需的通用方法集： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Payload, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Envelope &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">basic_message_holder_impl_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt; Envelope &gt; m_msg; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> payload_type = Payload; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> envelope_type = Envelope; <span class="hljs-keyword"><span class="hljs-keyword">basic_message_holder_impl_t</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">basic_message_holder_impl_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt; Envelope &gt; msg ) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : m_msg{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(msg) } {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ m_msg.reset(); } [[nodiscard]] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">empty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;( m_msg ); } [[nodiscard]] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;empty(); } [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;empty(); } };</code> </pre> <br><p> 该模板类具有两个参数。 第一个，有效载荷，设置吸气方法应使用的类型。 而第二个Envelope设置intrusive_ptr的类型。 如果消息类型是从<code>message_t</code>继承的<code>message_t</code>这两个参数将具有相同的值。 但是，如果消息不是从<code>message_t</code>继承的，则消息类型将用作有效负载，而<code>user_type_message_t&lt;Payload&gt;</code>将<code>user_type_message_t&lt;Payload&gt;</code>信封。 </p><br><p> 我认为基本上该课程的内容不会引起任何疑问。 但是，应分别注意两件事。 </p><br><p> 首先，指针本身，即  m_msg属性在protected部分中定义，以便类继承者可以访问它。 </p><br><p> 其次，对于此类，编译器本身会生成所有必需的构造函数和复制/移动运算符。 在这个级别的水平上，我们尚未禁止任何操作。 </p><br><h2 id="otdelnye-bazy-dlya-shared_ptr--i-unique_ptr-povedeniya">  shared_ptr和unique_ptr行为的单独基础 </h2><br><p> 因此，我们有一个存储指向消息的指针的类。 现在，我们可以定义其继承人，其继承人将表现为shared_ptr或unique_ptr。 </p><br><p> 让我们从shared_ptr行为的情况开始，因为 这是最少的代码： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Payload, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Envelope &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shared_message_holder_impl_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">basic_message_holder_impl_t</span></span>&lt;Payload, Envelope&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> direct_base_type = <span class="hljs-keyword"><span class="hljs-keyword">basic_message_holder_impl_t</span></span>&lt;Payload, Envelope&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> direct_base_type::direct_base_type; [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt; Envelope &gt; make_reference() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;m_msg; } };</code> </pre> <br><p> 没什么复杂的：从<code>basic_message_holder_impl_t</code>继承，继承其所有构造函数，并定义<code>make_reference()</code>的简单，无损实现。 </p><br><p> 对于unique_ptr行为，代码虽然没有什么复杂之处，但是代码更大： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Payload, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Envelope &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unique_message_holder_impl_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">basic_message_holder_impl_t</span></span>&lt;Payload, Envelope&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> direct_base_type = <span class="hljs-keyword"><span class="hljs-keyword">basic_message_holder_impl_t</span></span>&lt;Payload, Envelope&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> direct_base_type::direct_base_type; <span class="hljs-keyword"><span class="hljs-keyword">unique_message_holder_impl_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unique_message_holder_impl_t</span></span> &amp; ) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unique_message_holder_impl_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unique_message_holder_impl_t</span></span> &amp;&amp; ) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unique_message_holder_impl_t</span></span> &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unique_message_holder_impl_t</span></span> &amp; ) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unique_message_holder_impl_t</span></span> &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=( <span class="hljs-keyword"><span class="hljs-keyword">unique_message_holder_impl_t</span></span> &amp;&amp; ) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt; Envelope &gt; make_reference() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;m_msg) }; } };</code> </pre> <br><p> 同样，我们从<code>basic_message_holder_impl_t</code>继承并<code>basic_message_holder_impl_t</code>继承所需的构造函数（这是默认构造函数和初始化构造函数）。 但同时，我们根据unique_ptr逻辑定义构造函数和复制/移动运算符：我们禁止复制，而是实现移动。 </p><br><p> 我们<code>make_reference()</code>还有一个破坏性的<code>make_reference()</code>方法。 </p><br><p> 实际上，仅此而已。 仍然只有实现这两个基类之间的选择... </p><br><h3 id="vybor-mezhdu-shared_ptr--i-unique_ptr-povedeniem"> 在shared_ptr和unique_ptr行为之间进行选择 </h3><br><p> 要在shared_ptr和unique_ptr行为之间进行选择，您需要以下元函数（元函数，因为它“在编译时”与类型配合使用）： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Msg, <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span> Ownership &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">impl_selector</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( !is_signal&lt;Msg&gt;::value, <span class="hljs-string"><span class="hljs-string">"Signals can't be used with message_holder"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> P = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> message_payload_type&lt; Msg &gt;::payload_type; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> E = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> message_payload_type&lt; Msg &gt;::envelope_type; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">conditional_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span>::autodetected == Ownership, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">conditional_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">message_mutability_t</span></span>::immutable_message == message_mutability_traits&lt;Msg&gt;::mutability, <span class="hljs-keyword"><span class="hljs-keyword">shared_message_holder_impl_t</span></span>&lt;P, E&gt;, <span class="hljs-keyword"><span class="hljs-keyword">unique_message_holder_impl_t</span></span>&lt;P, E&gt; &gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">conditional_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span>::shared == Ownership, <span class="hljs-keyword"><span class="hljs-keyword">shared_message_holder_impl_t</span></span>&lt;P, E&gt;, <span class="hljs-keyword"><span class="hljs-keyword">unique_message_holder_impl_t</span></span>&lt;P, E&gt; &gt; &gt;; };</code> </pre> <br><p> 此元函数接受<code>message_holder_t</code>参数列表中的两个参数，结果（即，嵌套<code>type</code>的定义）“返回”应从其继承的类型。 即  <code>shared_message_holder_impl_t</code>或<code>unique_message_holder_impl_t</code> 。 </p><br><p> 在<code>impl_selector</code>的定义内<code>impl_selector</code>您可以看到上面提到的魔术痕迹，而我们没有涉及到它： <code>message_payload_type&lt;Msg&gt;::payload_type</code> ， <code>message_payload_type&lt;Msg&gt;::envelope_type</code> <code>message_mutability_traits&lt;Msg&gt;::mutability</code>和<code>message_mutability_traits&lt;Msg&gt;::mutability</code> 。 </p><br><p> 为了更轻松地使用<code>impl_selector</code> ，我们将为其定义一个较短的名称： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Msg, <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span> Ownership &gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">impl_selector_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> impl_selector&lt;Msg, Ownership&gt;::type;</code> </pre> <br><h2 id="baza-dlya-getter-ov"> 吸气剂的基础 </h2><br><p> 因此，我们已经有机会选择一个包含指针并定义“智能指针”行为的基础。 现在，我们需要为该基础提供getter方法。 为什么我们需要一个简单的类： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Return_Type &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">msg_accessors_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Base { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Base::Base; [[nodiscard]] <span class="hljs-function"><span class="hljs-function">Return_Type * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get_ptr( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;m_msg ); } [[nodiscard]] Return_Type &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> * () <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *get(); } [[nodiscard]] Return_Type * <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-&gt;() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get(); } };</code> </pre> <br><p> 这是一个依赖两个参数的模板类，但是它们的含义完全不同。 基本参数将是上面显示的<code>impl_selector</code>元函数的结果。 即 作为Base参数，设置要继承的基类。 </p><br><p> 重要的是要注意，如果继承来自<code>unique_message_holder_impl_t</code> ，禁止使用该构造函数和复制运算符，则编译器将无法生成<code>msg_accessors_t</code>的构造函数和复制运算符。 这就是我们所需要的。 </p><br><p>  return_Type参数将是消息的类型，getter将返回消息的指针/链接。 诀窍是，对于类型为<code>Msg</code>的不可变消息<code>Msg</code> Return_Type参数将设置为<code>const Msg</code> 。 对于类型为<code>Msg</code>的可变消息<code>Msg</code>参数Return_Type将具有值<code>Msg</code> 。 因此， <code>get()</code>方法将为不变消息返回<code>const Msg*</code> ，而对于可变消息仅返回<code>Msg*</code> 。 </p><br><p> 使用免费函数<code>get_ptr()</code>解决了使用未从<code>message_t</code>继承的消息的问题： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M &gt; <span class="hljs-function"><span class="hljs-function">M * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_ptr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">intrusive_ptr_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;M&gt; &amp; msg )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> msg.get(); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M &gt; <span class="hljs-function"><span class="hljs-function">M * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_ptr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">intrusive_ptr_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">user_type_message_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;M&gt; &gt; &amp; msg )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::addressof(msg-&gt;m_payload); }</code> </pre> <br><p> 即 如果消息不是从<code>message_t</code>继承并存储为<code>user_type_message_t&lt;Msg&gt;</code> ，则调用第二个重载。 而且如果它是继承的，那么第一个重载。 </p><br><h3 id="vybor-konkretnoy-bazy-dlya-getter-ov"> 为吸气剂选择特定的基础 </h3><br><p> 因此， <code>msg_accessors_t</code>模板需要两个参数。 第一个由<code>impl_selector</code>元函数计算。 但是为了从<code>msg_accessors_t</code>形成特定的基本类型，我们需要确定第二个参数的值。 为此，还需要一个元功能： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">message_mutability_t</span></span> Mutability, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">accessor_selector</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">conditional_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">message_mutability_t</span></span>::immutable_message == Mutability, <span class="hljs-keyword"><span class="hljs-keyword">msg_accessors_t</span></span>&lt;Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base::payload_type <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&gt;, <span class="hljs-keyword"><span class="hljs-keyword">msg_accessors_t</span></span>&lt;Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base::payload_type&gt; &gt;; };</code> </pre> <br><p> 您只能注意Return_Type参数的计算。  East const有用的少数情况之一；） </p><br><p> 好吧，为了提高以下代码的可读性，可以使用一个更紧凑的选项： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">message_mutability_t</span></span> Mutability, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base &gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">accessor_selector_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> accessor_selector&lt;Mutability, Base&gt;::type;</code> </pre> <br><h2 id="itogovyy-naslednik-message_holder_t"> 最后的后继message_holder_t </h2><br><p> 现在，您可以查看<code>message_holder_t</code>什么，对于实现所有这些基本类和元功能都是必需的（从实现中删除了构造存储在message_holder中的消息实例的方法的一部分）： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Msg, <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span> Ownership = <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span>::autodetected &gt; class <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> details::message_holder_details::<span class="hljs-keyword"><span class="hljs-keyword">accessor_selector_t</span></span>&lt; details::message_mutability_traits&lt;Msg&gt;::mutability, details::message_holder_details::<span class="hljs-keyword"><span class="hljs-keyword">impl_selector_t</span></span>&lt;Msg, Ownership&gt; &gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> base_type = details::message_holder_details::<span class="hljs-keyword"><span class="hljs-keyword">accessor_selector_t</span></span>&lt; details::message_mutability_traits&lt;Msg&gt;::mutability, details::message_holder_details::<span class="hljs-keyword"><span class="hljs-keyword">impl_selector_t</span></span>&lt;Msg, Ownership&gt; &gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> payload_type = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> base_type::payload_type; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> envelope_type = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> base_type::envelope_type; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> base_type::base_type; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">friend</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">message_holder_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">message_holder_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; b )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap; swap( a.message_reference(), b.message_reference() ); } };</code> </pre> <br><p> 实际上，我们上面分析的所有内容都是必需的，以便记录以下两个元函数的“调用”： </p><br><pre> <code class="cpp hljs">details::message_holder_details::<span class="hljs-keyword"><span class="hljs-keyword">accessor_selector_t</span></span>&lt; details::message_mutability_traits&lt;Msg&gt;::mutability, details::message_holder_details::<span class="hljs-keyword"><span class="hljs-keyword">impl_selector_t</span></span>&lt;Msg, Ownership&gt; &gt;</code> </pre> <br><p> 因为 这不是第一种选择，而是简化和减少代码的结果，我可以说紧凑的元函数形式可以大大减少代码量并提高其可理解性（如果通常在这里谈论可理解性）。 </p><br><h1 id="a-chto-bylo-by-esli-by"> 如果... </h1><br><p> 但是，如果在C ++中<code>if constexpr</code>和在D中一样强大，那么您可以编写如下代码： </p><br><div class="spoiler">  <b class="spoiler_title">假设版本，如果使用constexpr，则具有更高级的功能</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Msg, <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span> Ownership = <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span>::autodetected &gt; class <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">message_mutability_t</span></span> Mutability = details::message_mutability_traits&lt;Msg&gt;::mutability; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span> Actual_Ownership = (<span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span>::unique == Ownership || (<span class="hljs-keyword"><span class="hljs-keyword">message_mutability_t</span></span>::mutable_msg == Mutability &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span>::autodetected == Ownership)) ? <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span>::unique : <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span>::shared; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> payload_type = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> message_payload_type&lt; Msg &gt;::payload_type; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> envelope_type = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> message_payload_type&lt; Msg &gt;::envelope_type; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> getter_return_type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">conditional_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">message_mutability_t</span></span>::immutable_msg == Mutability, payload_type <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>, payload_type &gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt; envelope_type &gt; mf ) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : m_msg{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(mf) } {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">message_ownership_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">::unique == Actual_Ownership )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span> &amp; ) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span> &amp;&amp; ) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span> &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span> &amp; ) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span> &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=( <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span> &amp;&amp; ) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">friend</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">message_holder_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">message_holder_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; b )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap; swap( a.m_msg, b.m_msg ); } [[nodiscard]] <span class="hljs-function"><span class="hljs-function">getter_return_type * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get_const_ptr( m_msg ); } [[nodiscard]] getter_return_type &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> * () <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *get(); } [[nodiscard]] getter_return_type * <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-&gt;() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">message_ownership_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">::shared == Actual_Ownership)</span></span></span><span class="hljs-function"> </span></span>{ [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt; envelope_type &gt; make_reference() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_msg; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt; envelope_type &gt; make_reference() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(m_msg) }; } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt; envelope_type &gt; m_msg; };</code> </pre> </div></div><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对我来说，差异太惊人了。</font><font style="vertical-align: inherit;">而且它们也不赞成当前的C ++：（</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（上面以一个连续的“ footfoot”形式分解的C ++代码可以在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">看到</font><font style="vertical-align: inherit;">）。</font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顺便说一句，我并没有真正了解C ++未来版本的元编程和反射建议领域中正在发生的事情。</font><font style="vertical-align: inherit;">但是从我的记忆中，我会感觉到Sutter提出的元类不会大大简化这一特定任务。</font><font style="vertical-align: inherit;">据我了解，借助元类，可以编写一个类生成器</font></font><code>message_holder_t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这样的生成器可能写起来很简单，但是在这种特定情况下，这种方法不太可能比真正高级的方法更具表达性和可理解性</font></font><code>if constexpr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></p><br><h1 id="zaklyuchenie"> 结论 </h1><br><p>   ,         C++. ,     .  ,    ,          . </p><br><p>                ,           . </p><br><p>   ,   ,   ++   ,   .      ,    . , ,            .  ,    .   C++98/03        ,     C++11       . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN449122/">https://habr.com/ru/post/zh-CN449122/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN449110/index.html">修复了与无法在IMAP文件夹名称中使用西里尔字母有关的错误</a></li>
<li><a href="../zh-CN449112/index.html">我们已退休-我们讨论的是曾经“过时”的流行音频小工具</a></li>
<li><a href="../zh-CN449114/index.html">对λambda反应</a></li>
<li><a href="../zh-CN449118/index.html">克里姆林宫恶魔丸</a></li>
<li><a href="../zh-CN449120/index.html">留着胡子，戴着墨镜和外形：计算机视觉的困难情况</a></li>
<li><a href="../zh-CN449124/index.html">如此难以找到，容易错过且不可能发行</a></li>
<li><a href="../zh-CN449128/index.html">世界顶级游戏开发公司</a></li>
<li><a href="../zh-CN449132/index.html">适用于Android Studio的17个顶级插件</a></li>
<li><a href="../zh-CN449134/index.html">动物园afl</a></li>
<li><a href="../zh-CN449138/index.html">加密帽的5个理由 为什么IT人员不喜欢比特币</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>