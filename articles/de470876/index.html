<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📖 🤷🏾 🍮 Erstellen Sie mit Babel benutzerdefinierte JavaScript-Syntaxkonstrukte. Teil 1 🏅 ⚒️ 👐🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute veröffentlichen wir den ersten Teil der Übersetzung des Materials, der der Erstellung eigener Syntaxkonstrukte für JavaScript mit Babel gewidmet...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen Sie mit Babel benutzerdefinierte JavaScript-Syntaxkonstrukte. Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/470876/">  Heute veröffentlichen wir den ersten Teil der Übersetzung des Materials, der der Erstellung eigener Syntaxkonstrukte für JavaScript mit Babel gewidmet ist. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/af/mm/2j/afmm2jwbgwm7bzi3nwdf3namowg.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Rückblick</font> </h2><br>  Schauen wir uns zunächst an, was wir erreichen werden, wenn wir am Ende dieses Materials angelangt sind: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  '@@'   `foo`   function @@ foo(a, b, c) {   return a + b + c; } console.log(foo(1, 2)(3)); // 6</span></span></code> </pre> <br>  Wir werden die <code>@@</code> implementieren, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Currying-</a> Funktionen ermöglicht.  Diese Syntax ähnelt der zum Erstellen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Generatorfunktionen verwendeten</a> . In unserem Fall wird jedoch anstelle des Zeichens <code>*</code> eine Folge von <code>@@</code> Zeichen zwischen dem <code>function</code> und dem <code>function</code> <code>@@</code> .  Wenn Sie Funktionen deklarieren, können Sie daher eine Konstruktion der Formularfunktion <code>function @@ name(arg1, arg2)</code> . <br><br>  Im obigen Beispiel können Sie bei der Arbeit mit der Funktion <code>foo</code> deren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teilanwendung verwenden</a> .  Wenn Sie die Funktion <code>foo</code> indem Sie so viele Parameter übergeben, die geringer sind als die Anzahl der benötigten Argumente, wird eine neue Funktion zurückgegeben, die die verbleibenden Argumente annehmen kann: <br><br><pre> <code class="javascript hljs">foo(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 6 const bar = foo(1, 2); // (n) =&gt; 1 + 2 + n bar(3); // 6</span></span></code> </pre> <br>  Ich habe die Reihenfolge der <code>@@</code> Zeichen gewählt, da das <code>@</code> -Symbol nicht in Variablennamen verwendet werden kann.  Dies bedeutet, dass ein Konstrukt der Formularfunktion <code>function@@foo(){}</code> auch syntaktisch korrekt ist.  Außerdem wird der Operator <code>@</code> für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dekorationsfunktionen verwendet</a> , und ich wollte etwas völlig Neues verwenden.  Aus diesem Grund habe ich mich für die <code>@@</code> . <br><br>  Um unser Ziel zu erreichen, müssen wir folgende Aktionen ausführen: <br><br><ul><li>  Erstellen Sie eine Abzweigung des Babel-Parsers. </li><li>  Erstellen Sie Ihr eigenes Babel-Plugin für die Code-Transformation. </li></ul><br>  Sieht nach etwas Unmöglichem aus? <br>  Tatsächlich gibt es hier nichts Schreckliches. Wir werden alles gemeinsam im Detail analysieren.  Ich hoffe, wenn Sie dies lesen, werden Sie die Feinheiten von Babel meisterhaft beherrschen. <br><br><h2>  <font color="#3AC1EF">Eine Gabel erstellen Babel</font> </h2><br>  Gehen Sie zum Babel- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repository</a> auf GitHub und klicken Sie auf die Schaltfläche <code>Fork</code> , die sich oben links auf der Seite befindet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/adb/5d3/eff/adb5d3effaecdfaead72747dd75f6991.png"></div><br>  <i><font color="#999999">Erstellen einer Gabel von Babel ( <a href="">Bild in voller Größe</a> )</font></i> <br><br>  Übrigens, wenn Sie gerade zum ersten Mal die Gabelung des beliebten Open Source-Projekts erstellt haben - herzlichen Glückwunsch! <br><br>  Klonen Sie nun die Babel-Gabel auf Ihren Computer und <a href="">bereiten Sie sie für die Arbeit vor</a> . <br><br><pre> <code class="javascript hljs">$ git clone https:<span class="hljs-comment"><span class="hljs-comment">//github.com/tanhauhau/babel.git # set up $ cd babel $ make bootstrap $ make build</span></span></code> </pre> <br>  Lassen Sie mich nun kurz auf die Organisation des Babel-Repositorys eingehen. <br><br>  Babel verwendet ein Monorepository.  Alle Pakete (z. B. <code>@babel/core</code> , <code>@babel/parser</code> , <code>@babel/plugin-transform-react-jsx</code> usw.) befinden sich im Ordner <code>packages/</code> .  Es sieht so aus: <br><br><pre> <code class="javascript hljs">- doc - packages  - babel-core  - babel-parser  - babel-plugin-transform-react-jsx  - ... - Gulpfile.js - Makefile - ...</code> </pre> <br>  Ich stelle fest, dass Babel ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Makefile verwendet,</a> um Aufgaben zu automatisieren.  Beim <code>make build</code> eines Projekts mit dem <code>make build</code> wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gulp</a> als Task-Manager verwendet. <br><br><h2>  <font color="#3AC1EF">Code-Konvertierung in einen AST-Kurzkurs</font> </h2><br>  Wenn Sie mit Konzepten wie „Parser“ und „Abstract Syntax Tree“ (AST) nicht vertraut sind, empfehle ich Ihnen dringend, sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses</a> Material anzusehen, bevor Sie weiterlesen. <br><br>  Wenn Sie sehr kurz darüber sprechen, was beim Parsen (Parsen) des Codes passiert, erhalten Sie Folgendes: <br><br><ul><li>  Der als Zeichenfolge dargestellte Code ( <code>string</code> ) sieht aus wie eine lange Liste von Zeichen: <code>f, u, n, c, t, i, o, n, , @, @, f, ...</code> </li><li>  Zu Beginn führt Babel eine Code-Tokenisierung durch.  In diesem Schritt scannt Babel den Code und erstellt Token.  Zum Beispiel so etwas wie <code>function, @@, foo, (, a, ...</code> </li><li>  Dann werden die Token zum Parsen durch den Parser geleitet.  Hier erstellt Babel basierend auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spezifikation</a> der JavaScript-Sprache einen abstrakten Syntaxbaum. </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist eine</a> großartige Ressource für diejenigen, die mehr über Compiler erfahren möchten. <br><br>  Wenn Sie denken, dass der „Compiler“ etwas sehr Komplexes und Unverständliches ist, dann wissen Sie, dass in Wirklichkeit nicht alles so mysteriös ist.  Beim Kompilieren wird einfach der Code analysiert und auf seiner Grundlage ein neuer Code erstellt, den wir XXX nennen werden.  Der XXX-Code kann durch Maschinencode dargestellt werden (vielleicht taucht Maschinencode zuerst in den Köpfen der meisten von uns auf, wenn wir an den Compiler denken).  Dies kann JavaScript-Code sein, der mit älteren Browsern kompatibel ist.  Tatsächlich ist eine der Hauptfunktionen von Babel die Kompilierung von modernem JS-Code zu Code, der für veraltete Browser verständlich ist. <br><br><h2>  <font color="#3AC1EF">Entwickeln Sie Ihren eigenen Parser für Babel</font> </h2><br>  Wir werden im Ordner <code>packages/babel-parser/</code> : <br><br><pre> <code class="javascript hljs">- src/  - tokenizer/  - parser/  - plugins/    - jsx/    - typescript/    - flow/    - ... - test/</code> </pre> <br>  Wir haben bereits über Tokenisierung und Analyse gesprochen.  Sie finden den Code, der diese Prozesse implementiert, in Ordnern mit den entsprechenden Namen.  Die <code>plugins/</code> Ordner enthalten Plugins (Plug-Ins), die die Funktionen des Basisparsers erweitern und dem System Unterstützung für zusätzliche Syntaxen hinzufügen.  Genau so wird beispielsweise <code>flow</code> Unterstützung von <code>jsx</code> und <code>flow</code> implementiert. <br><br>  Lösen wir unser Problem mithilfe der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwicklungstechnologie durch Testen</a> (Test Driven Development, TDD).  Meiner Meinung nach ist es am einfachsten, zuerst einen Test zu schreiben und dann nach und nach am System diesen Test fehlerfrei auszuführen.  Dieser Ansatz eignet sich besonders gut, wenn Sie in einer unbekannten Codebasis arbeiten.  Mit TDD können Sie leicht nachvollziehen, wo Sie Änderungen am Code vornehmen müssen, um die beabsichtigte Funktionalität zu implementieren. <br><br><pre> <code class="javascript hljs">packages/babel-parser/test/curry-<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">js</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">import</span></span></span><span class="hljs-function"> </span></span>{ parse } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../lib'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getParser</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">code</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> parse(code, { <span class="hljs-attr"><span class="hljs-attr">sourceType</span></span>: <span class="hljs-string"><span class="hljs-string">'module'</span></span> }); } describe(<span class="hljs-string"><span class="hljs-string">'curry function syntax'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  it(<span class="hljs-string"><span class="hljs-string">'should parse'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{    expect(getParser(<span class="hljs-string"><span class="hljs-string">`function @@ foo() {}`</span></span>)()).toMatchSnapshot();  }); });</code> </pre> <br>  Sie können den Test für <code>babel-parser</code> folgendermaßen <code>TEST_ONLY=babel-parser TEST_GREP="curry function" make test-only</code> : <code>TEST_ONLY=babel-parser TEST_GREP="curry function" make test-only</code> .  Auf diese Weise können Sie die Fehler anzeigen: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">SyntaxError</span></span>: Unexpected token (<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">9</span></span>) at Parser.raise (packages/babel-parser/src/parser/location.js:<span class="hljs-number"><span class="hljs-number">39</span></span>:<span class="hljs-number"><span class="hljs-number">63</span></span>) at Parser.raise [<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> unexpected] (packages/babel-parser/src/parser/util.js:<span class="hljs-number"><span class="hljs-number">133</span></span>:<span class="hljs-number"><span class="hljs-number">16</span></span>) at Parser.unexpected [<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> parseIdentifierName] (packages/babel-parser/src/parser/expression.js:<span class="hljs-number"><span class="hljs-number">2090</span></span>:<span class="hljs-number"><span class="hljs-number">18</span></span>) at Parser.parseIdentifierName [<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> parseIdentifier] (packages/babel-parser/src/parser/expression.js:<span class="hljs-number"><span class="hljs-number">2052</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span>) at Parser.parseIdentifier (packages/babel-parser/src/parser/statement.js:<span class="hljs-number"><span class="hljs-number">1096</span></span>:<span class="hljs-number"><span class="hljs-number">52</span></span>)</code> </pre> <br>  Wenn Sie feststellen, dass das Anzeigen aller Tests zu lange dauert, können Sie, um den gewünschten Test auszuführen, <code>jest</code> direkt aufrufen: <br><br><pre> <code class="javascript hljs">BABEL_ENV=test node_modules/.bin/jest -u packages/babel-parser/test/curry-<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">js</span></span></span></span></code> </pre> <br>  Unser Parser entdeckte 2 <code>@</code> Token, scheinbar völlig unschuldig, wo sie nicht sein sollten. <br><br>  Woher wusste ich das?  Die Antwort auf diese Frage hilft uns, die Verwendung des Codeüberwachungsmodus zu finden, der mit dem <code>make watch</code> gestartet wird. <br><br>  Das Anzeigen des Aufrufstapels führt uns zu <a href="">packages / babel-parser / src /</a> <code>this.unexpected()</code> <a href="">/ expression.js</a> , wo die Ausnahme <code>this.unexpected()</code> ausgelöst wird. <br><br>  Fügen Sie dieser Datei einige Protokollierungsbefehle hinzu: <br><br><pre> <code class="javascript hljs">packages/babel-parser/src/parser/expression.js parseIdentifierName(pos: number, liberal?: boolean): string {  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.match(tt.name)) {    <span class="hljs-comment"><span class="hljs-comment">// ...  } else {    console.log(this.state.type); //      console.log(this.lookahead().type); //      throw this.unexpected();  } }</span></span></code> </pre> <br>  Wie Sie sehen können, sind beide Token <code>@</code> : <br><br><pre> <code class="javascript hljs">TokenType {  <span class="hljs-attr"><span class="hljs-attr">label</span></span>: <span class="hljs-string"><span class="hljs-string">'@'</span></span>,  <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br>  Wie habe ich herausgefunden, dass die Konstruktionen <code>this.state.type</code> und <code>this.lookahead().type</code> mir die aktuellen und nächsten Token geben? <br>  Ich werde darüber in dem Abschnitt dieses Materials <code>this.eat</code> , der den Funktionen <code>this.eat</code> , <code>this.match</code> und <code>this.next</code> . <br><br>  Bevor wir fortfahren, fassen wir zusammen: <br><br><ul><li>  Wir haben einen Test für <code>babel-parser</code> . </li><li>  Wir haben den Test nur mit <code>make test-only</code> . </li><li>  Wir haben den Code-Überwachungsmodus mit <code>make watch</code> . </li><li>  Wir haben den Status des Parsers <code>this.state.type</code> und Informationen zum Typ des aktuellen Tokens ( <code>this.state.type</code> ) in der Konsole <code>this.state.type</code> . </li></ul><br>  Und jetzt werden wir sicherstellen, dass 2 <code>@</code> -Zeichen nicht als separate Token wahrgenommen werden, sondern als neues <code>@</code> <code>@@</code> , das wir für Curry-Funktionen verwendet haben. <br><br><h2>  <font color="#3AC1EF">Neues Token: "@@"</font> </h2><br>  Schauen wir uns zunächst an, wo die Arten von Token bestimmt werden.  Dies ist die Datei <a href="">packages / babel-parser / src / tokenizer / types.js</a> . <br><br>  Hier finden Sie eine Liste der Token.  Fügen Sie hier die Definition des neuen <code>atat</code> Tokens hinzu: <br><br><pre> <code class="javascript hljs">packages/babel-parser/src/tokenizer/types.js <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> types: { [name: string]: TokenType } = {  <span class="hljs-comment"><span class="hljs-comment">// ...  at: new TokenType('@'),  atat: new TokenType('@@'), };</span></span></code> </pre> <br>  Suchen wir nun nach der Stelle im Code, an der beim Tokenisierungsprozess Token erstellt werden.  Wenn Sie die Reihenfolge der <code>tt.at</code> Zeichen in <code>babel-parser/src/tokenizer</code> <code>tt.at</code> <code>babel-parser/src/tokenizer</code> , gelangen Sie zur folgenden Datei: <a href="">packages / babel-parser / src / tokenizer / index.js</a> .  Im <code>babel-parser</code> werden Tokentypen als <code>tt</code> importiert. <br><br>  Wenn nun nach dem aktuellen <code>@</code> -Symbol ein weiteres <code>@</code> , erstellen <code>tt.atat</code> anstelle des <code>tt.at</code> Tokens ein neues Token <code>tt.atat</code> : <br><br><pre> <code class="javascript hljs">packages/babel-parser/src/tokenizer/index.js getTokenFromCode(code: number): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> {  <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (code) {    <span class="hljs-comment"><span class="hljs-comment">// ...    case charCodes.atSign:      //    -  `@`      if (this.input.charCodeAt(this.state.pos + 1) === charCodes.atSign) {        //  `tt.atat`  `tt.at`        this.finishOp(tt.atat, 2);      } else {        this.finishOp(tt.at, 1);      }      return;    // ...  } }</span></span></code> </pre> <br>  Wenn Sie den Test erneut ausführen, werden Sie feststellen, dass sich die Informationen zu den aktuellen und nächsten Token geändert haben: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   TokenType {  label: '@@',  // ... } //   TokenType {  label: 'name',  // ... }</span></span></code> </pre> <br>  Es sieht schon ziemlich gut aus.  Wir werden die Arbeit fortsetzen. <br><br><h2>  <font color="#3AC1EF">Neuer Parser</font> </h2><br>  Bevor Sie fortfahren, schauen Sie sich an, wie Generatorfunktionen in AST dargestellt werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ea/cc0/a9f/3eacc0a9fe1c5f780013f7d1d3d1ebe3.png"></div><br>  <i><font color="#999999">AST für Generatorfunktion ( <a href="">Bild in voller Größe</a> )</font></i> <br><br>  Wie Sie sehen können, gibt das Attribut <code>generator: true</code> der Entität <code>FunctionDeclaration</code> an, dass es sich um eine Generatorfunktion handelt. <br><br>  Wir können einen ähnlichen Ansatz verfolgen, um eine Funktion zu beschreiben, die das Curry unterstützt.  Wir können nämlich das Attribut <code>curry: true</code> zu <code>FunctionDeclaration</code> hinzufügen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a6/056/e68/3a6056e68a6cd80fc136c6e010444d0b.png"></div><br>  <i><font color="#999999">AST für die Curry-Funktion ( <a href="">Bild in voller Größe</a> )</font></i> <br><br>  Eigentlich haben wir jetzt einen Plan.  Beschäftigen wir uns mit seiner Implementierung. <br><br>  Wenn Sie im Code nach dem Wort <code>FunctionDeclaration</code> suchen, können Sie zur Funktion <code>parseFunction</code> , die in <a href="">packages / babel-parser / src / parser / statement.js</a> deklariert ist.  Hier finden Sie die Zeile, in der das <code>generator</code> ist.  Fügen Sie dem Code eine weitere Zeile hinzu: <br><br><pre> <code class="javascript hljs">packages/babel-parser/src/parser/statement.js <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatementParser</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExpressionParser</span></span></span><span class="hljs-class"> </span></span>{  <span class="hljs-comment"><span class="hljs-comment">// ...  parseFunction&lt;T: N.NormalFunction&gt;(    node: T,    statement?: number = FUNC_NO_FLAGS,    isAsync?: boolean = false  ): T {    // ...    node.generator = this.eat(tt.star);    node.curry = this.eat(tt.atat);  } }</span></span></code> </pre> <br>  Wenn wir den Test erneut durchführen, erwartet uns eine angenehme Überraschung.  Der Code wurde erfolgreich getestet! <br><br><pre> <code class="javascript hljs">PASS packages/babel-parser/test/curry-<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">js</span></span></span><span class="hljs-function">  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">curry</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">syntax</span></span></span><span class="hljs-function">    ✓ </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">should</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">12</span></span></span></span><span class="hljs-function"><span class="hljs-params">ms</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br>  Und das ist alles?  Was haben wir getan, um den Test auf wundersame Weise zu bestehen? <br><br>  Um dies herauszufinden, lassen Sie uns darüber sprechen, wie das Parsen funktioniert.  Ich hoffe, Sie werden im Verlauf dieses Gesprächs verstehen, wie die Zeile <code>node.curry = this.eat(tt.atat);</code>  . <br><br>  Fortsetzung folgt… <br><br>  <b>Liebe Leser!</b>  Benutzt du babel <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de470876/">https://habr.com/ru/post/de470876/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de470864/index.html">Über die Freuden des Wechsels zum Panel und nicht nur</a></li>
<li><a href="../de470868/index.html">Zeit bis zum ersten Byte: Was ist das und warum ist es wichtig?</a></li>
<li><a href="../de470870/index.html">Schriftarten vorladen</a></li>
<li><a href="../de470872/index.html">Leistungsmetriken für die Suche nach unglaublich schnellen Webanwendungen</a></li>
<li><a href="../de470874/index.html">Optimierung des Ladens von JavaScript auf Wikipedia</a></li>
<li><a href="../de470878/index.html">Erstellen Sie mit Babel benutzerdefinierte JavaScript-Syntaxkonstrukte. Teil 2</a></li>
<li><a href="../de470880/index.html">Spielmechanik. Abenteuer, das Konzept der Null und überzeugende Sprachtherapie</a></li>
<li><a href="../de470882/index.html">Warum hast du meine Maus oder ein Brettspiel als Modell für soziale Interaktion erwischt?</a></li>
<li><a href="../de470884/index.html">Schreiben und Lesen von Daten in der Bitcoin-Blockchain</a></li>
<li><a href="../de470888/index.html">Russische und internationale Gesetzgebung im Bereich des Schutzes personenbezogener Daten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>