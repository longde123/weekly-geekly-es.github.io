<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéóÔ∏è ‚ö°Ô∏è ü§∏üèæ Escribimos el cargador FPGA en LabVIEW. Parte 1 ü§ôüèΩ üë©üèø‚Äçüé§ ü•î</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La mayor√≠a de los programadores "normales", por decirlo suavemente, tienen una actitud ambigua hacia la tecnolog√≠a LabVIEW . Aqu√≠ puedes discutir dura...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escribimos el cargador FPGA en LabVIEW. Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427529/"><img src="https://habrastorage.org/webt/2m/nu/6l/2mnu6ljkhtj-pydr_chsebgpp_i.jpeg"><br><p><br>  La mayor√≠a de los programadores "normales", por decirlo suavemente, tienen una actitud ambigua hacia la tecnolog√≠a <strong>LabVIEW</strong> .  Aqu√≠ puedes discutir durante mucho tiempo y en vano.  La situaci√≥n se ve agravada por el hecho de que hay muchos ejemplos de programas de LabVIEW en la red, pero todos est√°n orientados hacia un principiante y se reducen a "oh, mira lo simple que es, conecta el giro al indicador, gira el mando, cambia el n√∫mero" o, en el mejor de los casos, al gr√°fico del ciclo. se muestra un n√∫mero aleatorio o seno, todo esto va acompa√±ado de una interfaz furiosa en forma de interruptores de palanca gigantes, botones giratorios e indicadores de marcaci√≥n.  Personalmente, este enfoque de simplificaci√≥n consciente me molesta.  En una breve serie de art√≠culos, intentar√© presentar al lector el proceso de desarrollo de software de aplicaci√≥n en LabVIEW.  Para no dedicar mucho tiempo al √°rea tem√°tica, utilizaremos el algoritmo detallado para cargar el archivo de configuraci√≥n al FPGA a trav√©s de FTDI en modo MPSSE ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">descargando la configuraci√≥n al FPGA a trav√©s de USB o desmontando FTDI MPSSE</a> ).  En este art√≠culo mostrar√© c√≥mo implementar el mismo cargador FPGA, pero en lenguaje LabVIEW. </p><a name="habracut"></a><br><p>  Como se mencion√≥ anteriormente, el algoritmo de carga FPGA en modo Serial Pasivo (SP) y el principio de operaci√≥n FTDI se describen bien en el art√≠culo anterior.  No me repetir√©  Creemos que el algoritmo se prueba y reconoce como apto.  Y s√≠, suponga que el lector est√° al menos superficialmente familiarizado con el concepto de LabVIEW y est√° bien versado en programaci√≥n cl√°sica. </p><br><p>  Aunque el proceso de creaci√≥n de un gestor de arranque no lleva mucho tiempo, la descripci√≥n del proceso no logr√≥ encajar en el volumen de un art√≠culo, por lo que habr√° una peque√±a serie.  Dado que la etapa de experimentos ya se ha completado, y conf√≠o en la operabilidad del algoritmo, me permitir√© comenzar el desarrollo desde la interfaz de usuario.  En el primer art√≠culo, crearemos la interfaz de usuario del cargador e implementaremos la estructura del programa.  En el segundo, a trav√©s del controlador FTDI dll, implementamos la carga del archivo * .rbf en el FPGA. </p><br><p>  Para la productividad de la conversaci√≥n, no es superfluo recordar la terminolog√≠a adoptada en LabVIEW.  En LabVIEW, el programa de aplicaci√≥n se llama Instrumento Virtual, tambi√©n conocido como VI, tambi√©n conocido como Instrumento Virtual o VI para abreviar.  El VP tiene dos "lados": el Panel frontal, donde se encuentran los controles e indicadores, y el diagrama de bloques (Diagrama de bloques), donde estos elementos est√°n interconectados y se implementan las funciones y los flujos de procesamiento de datos.  Como regla general, un VP tiene una estructura jer√°rquica; todos los VP en un VP de nivel superior generalmente se denominan subdispositivo o SubVI. </p><br><h2 id="interfeys-polzovatelya">  Interfaz de usuario </h2><br><p>  Nuestra aplicaci√≥n debe cargar el archivo de configuraci√≥n en el FPGA.  Al mismo tiempo, queremos decir que se pueden conectar varios FTDI a la computadora al mismo tiempo, y algunos de ellos se pueden usar potencialmente para configurar FPGA.  Sugiero elegir un dispositivo de la lista desplegable, seleccionando un archivo a trav√©s de un bot√≥n con una salida de ruta.  Para iniciar la descarga, agregue el bot√≥n "programa".  Un LED virtual indicar√° el estado de la operaci√≥n.  Inicie LabVIEW. </p><br><p>  Agregue los elementos necesarios al panel frontal (Panel frontal).  Usar√© el estilo "Plata" para el VP.  La siguiente figura muestra el resultado, todos los elementos en su estado original.  Por nombre, si es necesario, son bastante f√°ciles de encontrar en la paleta. </p><br><img src="https://habrastorage.org/webt/qq/os/bt/qqosbtkepb8n5fe2l3_qnz309q8.png"><br><p><br>  Editamos elementos: transferimos, estiramos, agregamos inscripciones, lo llevamos al formulario requerido.  Aqu√≠, de hecho, se requiere la mano del dise√±ador, pero como pude: </p><br><img src="https://habrastorage.org/webt/wd/sp/iz/wdspizcngovsuygvcmkofpnepjw.png"><br><p><br>  Y el diagrama de bloques: </p><br><img src="https://habrastorage.org/webt/l0/g_/hi/l0g_hij_xwkzm3n-sfrqe6pfypg.png"><br><p><br>  Llamo tu atenci√≥n.  Cada elemento tiene dos propiedades que determinan el nombre: etiqueta y t√≠tulo. </p><br><img src="https://habrastorage.org/webt/pi/xi/r9/pixir9kcyslk2iscflmbtfxtpmq.png"><br><p><br>  La primera propiedad establece el nombre del elemento, bajo este nombre se mostrar√° en el diagrama de bloques.  La etiqueta, a diferencia de Caption, no se puede cambiar durante la ejecuci√≥n del VI.  En relaci√≥n con esta funci√≥n, le recomiendo que oculte la Etiqueta en sus VIs en el panel frontal y muestre Subt√≠tulo.  Para Label, busque un nombre significativo, como una variable en un lenguaje de programaci√≥n cl√°sico, preferiblemente en un dise√±o latino.  Para Caption, presentaremos un nombre orientado a los humanos, puede ser bastante largo, incluir espacios y, si es necesario, en ruso.  Usando LabVIEW, puede personalizar la fuente de visualizaci√≥n para el T√≠tulo.  Debo decir que nadie nos obliga a jugar con Caption: cualquier inscripci√≥n se puede hacer directamente en <abbr title="Panel frontal">FP</abbr> en cualquier lugar libre. </p><br><p> Implementamos la operaci√≥n VP de acuerdo con el esquema cl√°sico: controlador de eventos y bucles While.  Agregue un bucle <code>While</code> (Programaci√≥n -&gt; Estructuras -&gt; Bucle While) al diagrama de bloques, y una estructura de controlador de eventos (Programaci√≥n -&gt; Estructuras -&gt; Estructura de eventos). </p><br><div class="spoiler">  <b class="spoiler_title">Breve ayuda sobre la estructura del evento</b> <div class="spoiler_text"><p>  La estructura espera a que ocurra el evento, luego se ejecuta el controlador correspondiente.  La estructura de eventos tiene uno o varios subdiagramas: controladores de eventos, los llamados casos, uno de los cuales se ejecuta cuando ocurre un evento.  Usando el terminal en la esquina superior izquierda, puede especificar el n√∫mero de milisegundos durante los cuales la estructura espera un evento.  Si durante este tiempo no se ha producido ning√∫n evento, se ejecutar√° el sub-diagrama "Tiempo de espera".  El valor predeterminado es menos 1, lo que significa que el tiempo de espera nunca caduca. </p><br><img src="https://habrastorage.org/webt/ol/qj/uo/olqjuooy0reae8un_fyw5bs2l78.png"><br><br><ol><li>  La etiqueta del selector de eventos indica qu√© eventos desencadenan el caso actual.  Para ver otros controladores, puede hacer clic en la flecha hacia abajo junto al nombre del evento. </li><li>  El terminal de <code>timeout</code> establece el n√∫mero de milisegundos para esperar un evento.  Si el valor es distinto de -1, se debe implementar el subdiagrama de tiempo de espera. </li><li>  Un terminal para ingresar eventos din√°micos.  Este terminal no se muestra por defecto.  Para mostrarlo, seleccione "Mostrar terminales de eventos din√°micos" en el men√∫ contextual. </li><li>  Nodo de datos del evento.  Cuando ocurre un evento, LabVIEW genera datos asociados con este evento.  Este nodo proporciona estos datos al controlador.  Puede usar el mouse para cambiar el tama√±o del nodo verticalmente y seleccionar los elementos necesarios.  Algunos datos, como <code>Type</code> y <code>Time</code> , son comunes a todos los eventos, otros, como <code>Char</code> y <code>VKey</code> , dependen del tipo de evento configurado. </li><li>  El nodo de filtro de eventos define datos de eventos que puede modificar antes de que la interfaz de usuario procese estos datos.  Este nodo se muestra solo en aquellos controladores en los que el filtrado est√° disponible.  Puede conectar y cambiar elementos del nodo de datos del evento al nodo del filtro de eventos.  Tambi√©n puede cambiar estos eventos conectando los nuevos valores a los terminales del nodo.  ¬øPuedo cancelar por completo la reacci√≥n de la interfaz al evento si env√≠o <code>true</code> al terminal <code>Discard?</code>  .  Si no conecta el valor al elemento de filtro, este elemento de datos permanece sin cambios. </li><li>  Al igual que la estructura <code>Case</code> , la estructura de eventos admite t√∫neles.  Si agrega un t√∫nel en un caso, se crear√° autom√°ticamente para cada controlador.  Sin embargo, de forma predeterminada no es necesario conectar los t√∫neles de salida de la estructura de eventos en cada controlador.  Todos los t√∫neles no conectados utilizan el valor predeterminado para el tipo de datos del t√∫nel.  Potencialmente, esto puede conducir a errores dif√≠ciles de detectar.  Puede regresar el modo en el que el t√∫nel debe estar conectado en todos los controladores, para esto, seleccione "Usar predeterminado si no est√° conectado" en el men√∫ contextual. </li></ol></div></div><br><p>  En primer lugar, nos ocuparemos de c√≥mo termina el ciclo y sale del programa.  La forma m√°s f√°cil es agregar un bot√≥n de detenci√≥n, que detendr√° el ciclo, pero, en mi opini√≥n, es habitual finalizar el programa con una cruz roja en la esquina superior de la ventana. <br>  Agregue el controlador apropiado a la <code>Event Structure</code> .  En el men√∫ contextual, seleccione "Agregar caso de evento".  Como origen del evento, seleccione "Este VI", el evento indicar√° "¬øCerrar panel?" </p><br><div class="spoiler">  <b class="spoiler_title">Editar eventos</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/bt/xo/qv/btxoqvdb2l67eohk78xrvwnhgcg.png"></a> <br>  <em>Imagen en la que se puede hacer clic</em> </p></div></div><br><p>  Tenga en cuenta que si selecciona "Cerrar panel" (sin una pregunta), este evento no tiene filtro, no se puede deshacer.  Y si tiene una pregunta, cuando hace clic en la cruz, podemos tomar el control e independientemente completar correctamente el programa.  En el "Panel Cerrar?"  a trav√©s del t√∫nel conectamos la constante booleana <code>true</code> con el terminal para detener el <code>while</code> .  Ingrese "¬øDescartar?"  Tambi√©n sirven <code>true</code> . </p><br><p>  Ahora no hay matices obvios: si el VI actual no se inicia en el entorno de LabVIEW, sino en forma de una aplicaci√≥n compilada, al hacer clic en la cruz no se cierra la ventana, sino que detiene la aplicaci√≥n, que no necesitamos.  Para resolver este problema, despu√©s de completar el ciclo principal, verificaremos si estamos en el entorno de desarrollo o en modo de programa, si todav√≠a estamos en modo de programa, finalizaremos la aplicaci√≥n.  Para comprender d√≥nde se ejecuta el VI actual, use el nodo de propiedades (Programaci√≥n -&gt; Control de aplicaciones -&gt; Nodo de propiedades).  Este nodo proporciona acceso a las propiedades de un objeto por referencia a este objeto.  En este caso, deber√≠amos obtener un enlace a toda la aplicaci√≥n como un todo.  Seleccione la constante de <code>VI Server Reference</code> de la misma paleta.  Despu√©s de establecer la constante en el diagrama de bloques, debe cambiar su tipo a <code>This Application</code> (bot√≥n izquierdo del mouse).  Conectamos el enlace resultante con el nodo de propiedad.  Seleccione la propiedad <code>Application:Kind Property</code> : devuelve el tipo del sistema LabVIEW en el que se ejecuta el VI actual.  Conectamos la salida de la propiedad a la Estructura del caso, agregamos el caso "Sistema de tiempo de ejecuci√≥n", donde finalizamos la aplicaci√≥n ( <code>Quit LabVIEW</code> ).  Para que este bloque se ejecute despu√©s del ciclo, y no antes, conectamos el <code>error in</code> terminal de entrada al ciclo a trav√©s del t√∫nel. </p><br><p> <a href=""><img width="720" src="https://habrastorage.org/webt/il/nm/ty/ilnmtyv89c3yv-nogcksavitbnu.png"></a> <br>  <em>Imagen en la que se puede hacer clic</em> </p><br><p>  Ahora, cuando inicie el programa, puede detenerlo haciendo clic en la cruz de la ventana.  El programa lanzado se ve as√≠: </p><br><img src="https://habrastorage.org/webt/pv/9e/za/pv9ezax9jrro78shza6coogtu_4.png"><br><p><br>  En mi opini√≥n, mucho superfluo.  Vaya a las propiedades de VI (Archivo -&gt; men√∫ de Propiedades de VI), seleccione la categor√≠a "Aspecto de la ventana", configure Personalizado. </p><br><p>  Apague la visualizaci√≥n del men√∫ (permanece en el modo de edici√≥n), apague la barra de desplazamiento, oculte la barra de herramientas cuando la aplicaci√≥n se est√© ejecutando (Mostrar barra de herramientas al ejecutar).  Prohibimos cambiar el tama√±o de la ventana, permitimos minimizar y minimizar la ventana.  Eso esta mejor: </p><br><img src="https://habrastorage.org/webt/a9/mg/u-/a9mgu-7km4wqkzj_rgdmc4mgfse.png"><br><p><br>  Por supuesto, valdr√≠a la pena eliminar la inscripci√≥n "National Instruments. LabVIEW Evaluation Software", pero todav√≠a no quiero comprar una licencia para una computadora en casa, soportaremos la inscripci√≥n y administraremos el per√≠odo de prueba de 45 d√≠as. </p><br><p>  Naturalmente, puede ajustar el color de fondo y cada elemento, elegir las fuentes, pero no soy dise√±ador, pero algo me dice que solo lo empeorar√©. </p><br><h2 id="spisok-priborov">  Lista de instrumentos </h2><br><p>  El VP debe ofrecer al usuario una lista de dispositivos conectados a la computadora que sean adecuados para el firmware FPGA para que el usuario pueda seleccionar el deseado.  En la biblioteca FTD2XX, las funciones <code>FT_CreateDeviceInfoList</code> y <code>FT_GetDeviceInfoDetail</code> est√°n destinadas para este prop√≥sito.  Como se discuti√≥ en un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo anterior</a> , las bibliotecas de controladores se pueden usar para usar la API FTD2XX.  LabVIEW tiene un mecanismo conveniente para interactuar con bibliotecas din√°micas: el nodo Nodo de funci√≥n de biblioteca de llamadas, puede encontrarlo en la paleta "Conectividad -&gt; Bibliotecas y ejecutables".  El nodo de llamada a la funci√≥n debe configurarse: primero, especifique la ruta a la dll (la pesta√±a "Funci√≥n"), despu√©s de lo cual el sistema escanea la biblioteca y ofrece seleccionar el nombre de la funci√≥n en la lista "Nombre de la funci√≥n" - seleccione <code>FT_CreateDeviceInfoList</code> , convenio de llamada - seleccione <strong>stdcall (WINAPI)</strong> .  En segundo lugar, en la pesta√±a "Par√°metros", debe ingresar una lista de par√°metros de funci√≥n, donde el primer elemento de la lista es el valor de retorno.  Aqu√≠ ser√≠a bueno tener en cuenta la documentaci√≥n de la API o el archivo de encabezado.  Cuando se configuran par√°metros en el √°rea "Prototipo de funci√≥n", se muestra el prototipo de la funci√≥n importada.  Cuando la firma de la documentaci√≥n coincida con el prototipo configurado, haga clic en Aceptar. </p><br><p>  Suponga que el escaneo se debe realizar una vez por segundo.  Colocamos el nodo de llamada en la estructura del controlador de eventos en la pesta√±a "Tiempo de espera", establecemos el tiempo de espera en 1000 ms.  Agregamos indicadores a los pines del nodo, y si todo se hace correctamente, al iniciar el VI, se debe mostrar el n√∫mero de dispositivos conectados con FTDI: </p><br><div class="spoiler">  <b class="spoiler_title">Panel frontal y diagrama de bloques</b> <div class="spoiler_text"><p> <a href=""><img width="720" src="https://habrastorage.org/webt/sc/pg/fr/scpgfrpwkg3gi5hepnez6b8l_nc.png"></a> <br>  <em>Imagen en la que se puede hacer clic</em> </p><br><img src="https://habrastorage.org/webt/v7/cy/fu/v7cyfuon36rdj3wxlwoaotzt_2c.png"></div></div><br><p>  Del mismo modo, cree un nodo para la funci√≥n <code>FT_GetDeviceInfoDetail</code> .  El prototipo de la funci√≥n es: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">FTD2XX_API FT_STATUS WINAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FT_GetDeviceInfoDetail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DWORD dwIndex, LPDWORD lpdwFlags, LPDWORD lpdwType, LPDWORD lpdwID, LPDWORD lpdwLocId, LPVOID lpSerialNumber, LPVOID lpDescription, FT_HAN</span></span></span></span></code> </pre> <br><p>  Al describir los par√°metros, debe tenerse en cuenta que <code>lpdwFlags</code> , <code>lpdwType</code> , <code>lpdwID</code> , <code>lpdwLocId</code> se pasan como punteros a <code>uint32</code> .  Los par√°metros <code>lpSerialNumber</code> y <code>lpDescription</code> son la esencia de las cadenas de bytes (matrices de caracteres con un terminador nulo).  Los par√°metros de este tipo en el nodo de llamada se pueden formatear de varias maneras, puede ingresarlos en una matriz de palabras de 8 bits, pero creo que es m√°s conveniente indicar de inmediato que se trata de una cadena y establecer el tama√±o esperado.  En este caso, la salida ser√° inmediatamente una l√≠nea de "laberinto" v√°lida y no se requerir√°n transformaciones adicionales. </p><br><img src="https://habrastorage.org/webt/zi/n8/8t/zin88t8hl5je5csuxcq7l_bbk9c.png"><br><p>  Funci√≥n de biblioteca de llamadas </p><br><p>  Esta funci√≥n devuelve informaci√≥n por el n√∫mero de serie <code>dwIndex</code> .  Si hay varios FTDI conectados a la computadora, para leer la informaci√≥n de cada convertidor, la funci√≥n debe llamarse en un bucle.  La funci√≥n previa <code>FT_CreateDeviceInfoList</code> nos dar√° el n√∫mero de iteraciones del bucle. </p><br><div class="spoiler">  <b class="spoiler_title">Panel frontal y diagrama de bloques</b> <div class="spoiler_text"><p> <a href=""><img width="720" src="https://habrastorage.org/webt/sr/2a/gq/sr2agqtusiwcn3tcttwqbncllgk.png"></a> <br>  <em>Imagen en la que se puede hacer clic</em> </p><br><img src="https://habrastorage.org/webt/t9/dg/tl/t9dgtlw3lapeklhbi4y3tzca0lm.png"></div></div><br><p>  Hay una caracter√≠stica desagradable: todos los puertos del nodo de llamada deben estar conectados al menos en un lado.  Por lo tanto, se hace un t√∫nel en el bucle para aquellos terminales de salida que no vamos a usar. </p><br><p>  <code>Types</code> matriz de <code>Types</code> contiene tipos de chips FTDI, los necesitamos para limitar la elecci√≥n solo a aquellos que admiten MPSSE y potencialmente pueden usarse para la programaci√≥n FPGA.  Sin embargo, operar con "n√∫meros m√°gicos" es inconveniente: propongo organizar los tipos de FTDI en forma de <code>enum</code> .  Adem√°s, dicha <code>enum</code> ya <code>enum</code> en el archivo de encabezado ftd2xx.h.  En LabVIEW, puede usar dos controles para crear una enumeraci√≥n: el Anillo de texto y la Enum.  Ambos contienen listas de cadenas con valores num√©ricos entre los que puede cambiar.  La principal diferencia es que "Enum" requiere que los valores num√©ricos sean n√∫meros enteros consecutivos, mientras que el "Anillo de texto" tiene m√°s libertad: puede especificar cualquier valor. </p><br><div class="spoiler">  <b class="spoiler_title">Enum.</b>  <b class="spoiler_title">Creaci√≥n</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/v9/ye/ik/v9yeik6iwgvetbpoa2wcf9b0kn8.png"><br><p>  <em>Ingresamos manualmente los valores, es una pena que no haya una funci√≥n para importar <code>enum</code> desde C</em> </p><br><img src="https://habrastorage.org/webt/en/jd/4r/enjd4rvd8snxw6fhtstrinlcvey.png"><br><p>  <em>En el panel frontal este indicador se ve as√≠</em> </p><br><img src="https://habrastorage.org/webt/yc/t6/er/yct6erqkpta8o-a4mnp7vfbty7w.png"><br><p>  <em>Seleccionar un valor haciendo clic izquierdo</em> </p></div></div><br><p>  Para vincular y sincronizar todas las instancias futuras de la lista creada, es conveniente utilizar el "Make Type Def".  (selecci√≥n a trav√©s del men√∫ contextual del elemento).  Como resultado, se crear√° un tipo de datos personalizado.  El nuevo tipo se coloca en un archivo separado con la extensi√≥n * .ctl.  La edici√≥n de este archivo modificar√° todas las instancias de este elemento.  Creo que no vale la pena explicar qu√© tan conveniente puede ser esto.  El acceso al archivo de definici√≥n se puede obtener desde el men√∫ contextual de la instancia seleccionando "Open Type Def", en el mismo men√∫ debe prestar atenci√≥n a los elementos "Actualizaci√≥n autom√°tica desde Type Def".  y "Desconectar del tipo Def". </p><br><p>  Cambiamos el indicador <code>Types</code> a una matriz de indicadores del <code>FTDI Type</code> y, como resultado, cuando se inicia el VI, se muestra el tipo del convertidor conectado: </p><br><img src="https://habrastorage.org/webt/zy/07/zy/zy07zy2phqs7mc_q8a4hur1hunw.png"><br><p>  <em>Tres dispositivos encontrados</em> </p><br><p>  Es f√°cil notar que la funcionalidad del c√≥digo resultante en el caso de "Tiempo de espera" est√° completa, por lo tanto, se puede mover a un SubVI separado.  Seleccione los elementos que queremos transferir al subdispositivo y seleccione "Crear SubVI" en el men√∫ principal Editar. </p><br><div class="spoiler">  <b class="spoiler_title">diagrama de bloques con subinstrumento creado</b> <div class="spoiler_text"><p>  Todos los indicadores permanecieron y se form√≥ un nuevo VI con un icono est√°ndar en lugar de los nodos de llamada. <br> <a href=""><img src="https://habrastorage.org/webt/wz/oo/ba/wzoobavcvisx9kmmntke3m_2pxe.png"></a> <br>  <em>Imagen en la que se puede hacer clic</em> </p></div></div><br><p>  Al hacer doble clic en el nuevo subVI se abrir√° su ventana de edici√≥n.  En primer lugar, lo guardamos y le damos un nombre significativo, por ejemplo, "FT_GetDeviceInfo".  Configurar terminales de E / S.  Para hacer esto, use el Panel de conectores: </p><br><img src="https://habrastorage.org/webt/1e/fs/gw/1efsgw6lcoaoauj-qguyus4fbn4.png"><br><p>  El panel es un conjunto de terminales correspondientes a los controles e indicadores VI. </p><br><p>  Si selecciona un terminal en el panel de conexi√≥n, se resalta el elemento correspondiente en el panel frontal.  Si selecciona un terminal vac√≠o y luego hace clic en un elemento en el panel frontal, el elemento se adjuntar√° al terminal, pero antes de eso no debe asignarse a otro terminal.  En el men√∫ contextual, puede desconectar individualmente o de una vez por todas las terminales de los elementos, puede cambiar el patr√≥n del panel como un todo. </p><br><p>  No me gusta c√≥mo se asignaron los terminales al crear el subVI actual, por lo que selecciono "Desconectar todos los terminales" y lo marco manualmente.  Recomiendo colocar los terminales de entrada a la izquierda y la salida a la derecha, la entrada opcional se puede colocar en la parte superior y la salida opcional en la parte inferior.  Esto asegurar√° una buena legibilidad del c√≥digo y un orden visual en el diagrama de bloques. </p><br><p>  Para controlar los errores, cree dos elementos adicionales, <code>Error in</code> y <code>Error out</code> .  El tema de control de errores de LabVIEW es muy extenso y va m√°s all√° del alcance de este art√≠culo, por lo que nos limitaremos a un m√≠nimo de explicaciones y nos adheriremos al principio de "haz lo que yo hago".  Entonces, creamos dos terminales para errores: entrada y salida. </p><br><div class="spoiler">  <b class="spoiler_title">Es conveniente crearlos usando el men√∫ contextual</b> <div class="spoiler_text"><p>  Haga clic derecho en la terminal de error de cualquier nodo: </p><br><img src="https://habrastorage.org/webt/ul/ew/re/ulewre7rct2swn34bhqejv3kg24.png"></div></div><br><p>  En LabVIEW, es costumbre colocar el terminal de entrada del error en el panel de conexi√≥n en la parte inferior izquierda, y el terminal de salida en la parte inferior derecha. </p><br><p>  Ser√° m√°s conveniente combinar la salida en una estructura.  Para la salida, haremos dos matrices: la primera matriz contendr√° todos los dispositivos FTDI encontrados, la segunda matriz contendr√° solo aquellos que pueden MPSSE y te√≥ricamente se pueden usar para configurar FPGA. </p><br><p>  El toque final al crear un subinstrumento es configurar el icono.  Al hacer doble clic en el icono en la esquina superior derecha de la ventana, se inicia el editor.  Estamos tratando de crear alg√∫n tipo de imagen significativa que nos permita interpretar sin ambig√ºedades el prop√≥sito del dispositivo en el diagrama de bloques. </p><br><div class="spoiler">  <b class="spoiler_title">FT_GetDeviceInfo.vi</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/l1/hy/sd/l1hysdhgshztti7xczw7tjmbex0.png"><br><p>  <em>Panel frontal</em> </p><br><img src="https://habrastorage.org/webt/a4/ba/5w/a4ba5wwquuv-coxuxpxzjo8xwio.png"><br><p>  <em>Diagrama de bloques</em> </p><br><p>  Y as√≠ es como se ve el caso de "Tiempo de espera" despu√©s de poner las cosas en orden: <br> <a href=""><img src="https://habrastorage.org/webt/ea/yu/6d/eayu6ddx32eq_easysclsqqp7pg.png"></a> <br>  <em>Imagen en la que se puede hacer clic</em> </p></div></div><br><p>  Hasta este punto, la lista desplegable con el nombre "Seleccionar un dispositivo" estaba vac√≠a, ahora tenemos los datos para completarla.  Creamos un nodo de propiedad para la lista con la propiedad "Cadenas []" (men√∫ contextual -&gt; Crear -&gt; Nodo de propiedad -&gt; Cadenas []).  Cualquier propiedad se puede escribir y leer; el modo actual se selecciona en el men√∫ contextual del Nodo de propiedad.  Al crear un nodo de forma predeterminada, las propiedades se configuran para leer.  Cambiar para escribir: "Cambiar para escribir". </p><br><p>  Desde el conjunto de estructuras, seleccione el conjunto con la descripci√≥n y alim√©ntelo a <code>Strings[]</code> .  Puede seleccionar una matriz usando el <code>For Loop</code> . </p><br><p>  Despu√©s de iniciar el VI, presionando el bot√≥n izquierdo en el elemento "Seleccionar un dispositivo", puede especificar el dispositivo para la configuraci√≥n.  En este caso, la lista de dispositivos se actualiza dos veces por segundo.  Por supuesto, ser√≠a posible actualizar la propiedad solo si la lista se actualiz√≥, pero hasta ahora esto resultar√° en un desorden innecesario del diagrama de bloques. </p><br><div class="spoiler">  <b class="spoiler_title">Que paso</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/_t/gh/i7/_tghi7fjgo0hhb6thtdcosvfp1m.png"><br><p>  <em>Panel frontal</em> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/x6/wo/3v/x6wo3v0sqbdvwzhksbg4kghoeho.png"></a> <br>  <em>Imagen en la que se puede hacer clic</em> </p><br><p>  Anteriormente, olvid√© mencionar una caracter√≠stica tan interesante, el bucle For no tiene que indicar el n√∫mero de iteraciones expl√≠citamente, es suficiente para crear un t√∫nel de entrada de la matriz y el bucle se ejecutar√° para cada elemento, este comportamiento se asemeja al <strong><code>foreach</code></strong> en C ++ 11.  Sin embargo, debe tener cuidado cuando llega m√°s de una matriz a la entrada del bucle. </p></div></div><br><p>  En la estructura del evento, agregue un controlador para presionar el bot√≥n "programa".  Si bien no tenemos un VI que sea responsable de cargar el archivo en el FPGA, crearemos un "stub" de subdispositivo.  Suponga que toma la ruta del archivo de configuraci√≥n y el descriptor FTDI como entrada, y de acuerdo con los resultados de la operaci√≥n, devuelve el estado del firmware: exitoso o no.  Y para que sea m√°s interesante probar la interfaz del programa, haremos que este estado sea aleatorio. </p><br><div class="spoiler">  <b class="spoiler_title">Stub FT_MPSSE_SP_FPGA.vi</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/gy/xl/qf/gyxlqf-hzbjik3667nmzga5bf6g.png"><br><p>  <em>Panel frontal</em> </p><br><img src="https://habrastorage.org/webt/f_/qz/kw/f_qzkwjrp7nqvo9yfgl0o9ovidw.png"><br><p>  <em>Diagrama de bloques</em> </p></div></div><br><p>  Pasaremos el descriptor FTDI a la entrada de c√≥digo auxiliar a trav√©s de la propiedad de lista (men√∫ contextual -&gt; Crear -&gt; Nodo de propiedad -&gt; Texto de anillo -&gt; Texto), para transferir la ruta del archivo al elemento "Ruta del archivo", crear una variable local (men√∫ contextual -&gt; Crear -&gt; Local Variable) y config√∫relo para leer (Cambiar para leer).  Y conecte la salida de estado directamente al indicador de <code>Status</code> .  El bot√≥n <code>Programm</code> se arrastra al controlador de eventos.  Es una buena pr√°ctica colocar elementos en los que el evento est√° configurado en controladores: ahora, al hacer doble clic en este elemento en el panel frontal, se mostrar√° no solo el elemento correspondiente en el diagrama de bloques, sino tambi√©n el controlador de eventos asociado con este elemento. </p><br><p>  Ahora, al presionar el bot√≥n "Programa", el indicador se vuelve verde (√©xito) o verde oscuro (no √©xito).  No muy claro.  En las propiedades del indicador, cambie el color "Desactivado" a rojo.  Eso es mejor  Si el indicador es verde, entonces podemos decir que el FPGA en el dispositivo seleccionado est√° configurado por un archivo, cuya ruta se indica en la ventana: </p><br><img src="https://habrastorage.org/webt/wl/le/re/wllerexz4zkxjzemfyspv_3yyoo.png"><br><p>  <em>Panel frontal</em> </p><br><p>  Pero esta declaraci√≥n se vuelve falsa si cambiamos el archivo o seleccionamos otro dispositivo.  Al mismo tiempo, no podemos colorear el indicador de rojo, porque no se produjo un error de programaci√≥n.  En el caso de un cambio de archivo o dispositivo, es conveniente enfatizar que el valor del indicador no es relevante: oscurecerlo.  Para esto, puede usar la propiedad de indicador <code>Disabled</code> .  Esta propiedad puede tomar tres valores: <code>Enabled</code> : visualizaci√≥n normal, el usuario puede controlar el objeto;  <code>Disabled</code> : el objeto se muestra en el panel frontal como de costumbre, pero el usuario no puede controlarlo;  <code>Disabled and Grayed Out</code> : el objeto se muestra oscurecido en el panel frontal y el usuario no puede controlarlo. </p><br><p>  Creamos controladores de eventos para la <code>Devices list</code> y la <code>File Path</code> , y en ellos oscurecemos el indicador de estado, y en el controlador asignamos el bot√≥n "Programa" a la propiedad <code>Enabled</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Que paso</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/59/xl/da/59xldabidafiphelnavil1h3iue.png"></a> <br>  <em>Manejador "Programm": cambio de valor.</em> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/i4/xm/sx/i4xmsxdxklfiusfqfamtyqxpoog.png"></a> <br>  <em>Controlador de lista de dispositivos: cambio de valor</em> </p><br><img src="https://habrastorage.org/webt/w3/58/dn/w358dn13xtxn61o6o5frte7-gsk.png"><br><p>  <em>As√≠ es como se ve el indicador oscuro</em> </p></div></div><br><p>  Hagamos que la b√∫squeda del archivo de configuraci√≥n sea conveniente para el usuario: configuraremos la ventana de vista del archivo.  Entramos en las propiedades del elemento <code>File Path</code> del <code>File Path</code> , en la pesta√±a "Opciones de exploraci√≥n", completamos Solicitud, Etiqueta de patr√≥n, especificamos el filtro de tipo de archivo (Patr√≥n) y el nombre del bot√≥n (Texto del bot√≥n). </p><br><div class="spoiler">  <b class="spoiler_title">Ventana de selecci√≥n de archivos</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/vf/i2/yc/vfi2ycpuj_lhydbcp1jebbjb0ni.png"><br><p>  <em>Solo se muestran los archivos rbf</em> </p><br><img src="https://habrastorage.org/webt/1-/w3/e8/1-w3e8dg3uauxccfq8-buzrs75y.png"></div></div><br><p>  La creaci√≥n de una interfaz de usuario puede considerarse completa. </p><br><img src="https://habrastorage.org/webt/tm/5w/oq/tm5woq3kwnfgmo38klp_5qxenug.png"><br><p>  <em>Ejecutando el gestor de arranque</em> </p><br><h2 id="s-chem-poznakomilis-segodnya">  ¬øQu√© conociste hoy? </h2><br><p>  En este art√≠culo, como ejemplo de crear una aplicaci√≥n funcionalmente completa con una interfaz minimalista, trat√© de mostrar varios enfoques para trabajar en LabVIEW. </p><br><p>  Como resultado, tocamos esos: </p><br><ul><li>  Establecer las propiedades del dispositivo virtual.       . </li><li>   :   . </li><li>    . </li><li>  . </li><li>    dll. </li><li>    . </li></ul><br><p>         API FTD2XX   MPSSE.     . </p><br><h2 id="materialy-po-teme">    </h2><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">     USB   FTDI MPSSE</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">labview_mpsse</a> .   . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">   </a> .    </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Software Application Development D2XX Programmer's Guide</a> .   API D2XX. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es427529/">https://habr.com/ru/post/es427529/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es427519/index.html">@Kubernetes Meetup en Mail.Ru Group: 29 de octubre y siempre</a></li>
<li><a href="../es427521/index.html">Breakthrough Prize 2019. Anunciados los ganadores del Premio de Ciencias Milner, Brin y Zuckerberg.</a></li>
<li><a href="../es427523/index.html">√âxito de cobertura</a></li>
<li><a href="../es427525/index.html">Intel Core 9th Gen en n√∫meros y puntos de referencia</a></li>
<li><a href="../es427527/index.html">10 trucos para tablero avanzado en Splunk. Parte 2</a></li>
<li><a href="../es427531/index.html">De Siberia a Chipre y viceversa: la historia de un emigrante fracasado</a></li>
<li><a href="../es427533/index.html">Relojes inteligentes que no requieren carga. ¬øHay muchos de ellos?</a></li>
<li><a href="../es427535/index.html">Lanzamos una elecci√≥n colectiva de soluciones.</a></li>
<li><a href="../es427537/index.html">C√≥mo convertirse en un gerente de producto exitoso: cursos en los que est√° capacitado en este momento</a></li>
<li><a href="../es427539/index.html">La √∫ltima vez en Europa marca la hora del invierno</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>