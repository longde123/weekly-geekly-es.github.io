<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüëß‚Äçüëß üìä üôÉ Crea un efecto de distribuci√≥n de color en Unity üôÜüèø ü¶ë üî≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este efecto fue inspirado por el episodio de Powerpuff Girls . Quer√≠a crear el efecto de la propagaci√≥n del color en un mundo en blanco y negro, pero ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Crea un efecto de distribuci√≥n de color en Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436456/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ia/i5/in/iai5inmdx06iz81yoz8pu_2oyui.gif"></div><br>  Este efecto fue inspirado por el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">episodio de Powerpuff Girls</a> .  Quer√≠a crear el efecto de la propagaci√≥n del color en un mundo en blanco y negro, pero <strong>implementarlo en las coordenadas del espacio mundial</strong> , para ver c√≥mo el <strong>color pinta los objetos</strong> , y no simplemente extenderse en la pantalla, como en una caricatura. <br><br>  Cre√© el efecto en el nuevo <strong>Lightweight Rendering Pipeline del</strong> motor de Unity, un ejemplo incorporado del Scriptable Rendering Pipeline pipeline.  Todos los conceptos se aplican a otras canalizaciones, pero algunas funciones o matrices incorporadas pueden tener nombres diferentes.  Tambi√©n utilic√© la nueva pila de procesamiento posterior, pero en el tutorial omitir√© una descripci√≥n detallada de su configuraci√≥n, porque se describe bastante bien en otros manuales, por ejemplo, en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este video</a> . <br><a name="habracut"></a><br><hr><br><h1>  El efecto del postprocesamiento en escala de grises </h1><br>  Solo como referencia, as√≠ es como se ve una escena sin efectos de procesamiento posterior. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43b/283/6ad/43b2836ad62ee59df7efdd98494d0140.png"></div><br>  Para este efecto, utilic√© el nuevo paquete Post-Processing de Unity 2018, que se puede descargar desde el administrador de paquetes.  Si no sabe c√≥mo usarlo, le recomiendo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este tutorial</a> . <br><br>  Escrib√≠ mi propio efecto extendiendo las clases PostProcessingEffectSettings y PostProcessEffectRenderer escritas en C #, cuyo c√≥digo fuente se puede ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> .  De hecho, no hice nada particularmente interesante con estos efectos en el lado de la CPU (en c√≥digo C #) excepto que agregu√© un grupo de propiedades generales al Inspector, por lo que no explicar√© c√≥mo hacerlo en el tutorial.  Espero que mi c√≥digo hable por s√≠ mismo. <br><br>  Pasemos al c√≥digo del sombreador y comencemos con el efecto de escala de grises.  En el tutorial, no modificaremos el archivo shaderlab, las estructuras de entrada y el sombreador de v√©rtices, por lo que puede ver su c√≥digo fuente <a href="">aqu√≠</a> .  En cambio, nos encargaremos del sombreador de fragmentos. <br><br>  Para convertir un color a una escala de grises, <strong>reducimos el valor de cada p√≠xel a un valor de luminancia</strong> que describa su <strong>brillo</strong> .  Esto se puede hacer tomando el producto escalar del <strong>valor de color de la textura de la c√°mara</strong> y el <strong>vector ponderado</strong> , que describe la contribuci√≥n de cada canal de color al brillo general del color. <br><br>  <strong>¬øPor qu√© utilizamos productos escalares?</strong>  No olvide que los productos escalares se calculan de la siguiente manera: <br><br> <code>dot(a, b) = a <sub>x</sub> * b <sub>x</sub> + a <sub>y</sub> * b <sub>y</sub> + a <sub>z</sub> * b <sub>z</sub></code> <br> <br>  En este caso, multiplicamos cada canal del <strong>valor de color</strong> por <strong>peso</strong> .  Luego agregamos estos productos para reducirlos a un solo valor escalar.  Cuando el color RGB tiene los mismos valores en los canales R, G y B, el color se vuelve gris. <br><br>  As√≠ es como se ve el c√≥digo del sombreador: <br><br><pre> <code class="cpp hljs">float4 fullColor = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.screenPos); float3 weight = float3(<span class="hljs-number"><span class="hljs-number">0.299</span></span>, <span class="hljs-number"><span class="hljs-number">0.587</span></span>, <span class="hljs-number"><span class="hljs-number">0.114</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> luminance = dot(fullColor.rgb, weight); float3 greyscale = luminance.xxx; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> float4(greyscale, <span class="hljs-number"><span class="hljs-number">1.0</span></span>);</code> </pre> <br>  Si el sombreador base est√° configurado correctamente, el efecto de postprocesamiento deber√≠a colorear toda la pantalla en escala de grises. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/596/217/fc5/596217fc5e9caed9176480f1f9eb2bb1.png"></div><br><hr><br><h1>  Representaci√≥n del efecto de color en el espacio mundial. </h1><br>  Como se trata de un efecto de procesamiento posterior, <strong>no tenemos informaci√≥n sobre la geometr√≠a de la</strong> escena en el sombreador de v√©rtices.  En la etapa de postprocesamiento, la √∫nica informaci√≥n que tenemos es la <strong>imagen renderizada por la c√°mara</strong> y el <strong>espacio de las coordenadas truncadas</strong> para muestrearla.  Sin embargo, queremos que el efecto de coloraci√≥n se extienda a trav√©s de los objetos, como si estuviera sucediendo en el mundo, y no solo en una pantalla plana. <br><br>  Para dibujar este efecto en la geometr√≠a de la escena, necesitamos las <strong>coordenadas del espacio mundial de</strong> cada p√≠xel.  Para pasar de las <strong>coordenadas del espacio de coordenadas truncadas</strong> a las <strong>coordenadas del espacio mundial</strong> , necesitamos realizar una <strong>transformaci√≥n del espacio de coordenadas</strong> . <br><br>  Por lo general, para pasar de un espacio de coordenadas a otro, se necesita una matriz que defina la transformaci√≥n del espacio de coordenadas A al espacio B. Para ir de A a B, multiplicamos el vector en el espacio de coordenadas A por esta matriz de transformaci√≥n.  En nuestro caso, realizaremos la siguiente transici√≥n: el <strong>espacio de coordenadas truncadas (espacio de clip)</strong> -&gt; <strong>ver espacio (ver espacio)</strong> -&gt; <strong>espacio mundial (espacio mundial)</strong> .  Es decir, necesitamos la matriz clip-to-view-space y la matriz view-to-world-space que proporciona Unity. <br><br>  Sin embargo, las <strong>coordenadas de Unity del espacio de coordenadas truncado no tienen un valor z</strong> que determine la profundidad del p√≠xel o la distancia a la c√°mara.  Necesitamos este valor para movernos desde el espacio de coordenadas truncadas al espacio de especies.  ¬°Comencemos con esto! <br><br><h2>  Obtener el valor del b√∫fer de profundidad </h2><br>  Si la canalizaci√≥n de representaci√≥n est√° habilitada, dibuja una textura en la <strong>ventana gr√°fica</strong> que almacena <strong>los valores z</strong> en una estructura llamada <strong>b√∫fer de profundidad</strong> .  ¬°Podemos muestrear este b√∫fer para obtener el <strong>valor z</strong> faltante <strong>de</strong> nuestro espacio de coordenadas de coordenadas truncadas! <br><br>  Primero, aseg√∫rese de que el <strong>b√∫fer de profundidad se</strong> renderice haciendo clic en la secci√≥n "Agregar datos adicionales" de la c√°mara en el Inspector y verificando que la casilla "Requiere textura de profundidad" est√© marcada.  Tambi√©n aseg√∫rese de que la opci√≥n Permitir MSAA est√© habilitada para la c√°mara.  No s√© por qu√© es necesario comprobar este efecto, pero lo es.  Si se dibuja el b√∫fer de profundidad, en el <strong>depurador de cuadros</strong> deber√≠a ver la etapa <strong>"Prepasar profundidad"</strong> . <br><br>  Cree una muestra _CameraDepthTexture en el <strong>archivo hlsl</strong> <br><br><pre> <code class="cpp hljs">TEXTURE2D_SAMPLER2D(_CameraDepthTexture, sampler_CameraDepthTexture);</code> </pre> <br>  Ahora escribamos la funci√≥n GetWorldFromViewPosition y por ahora la usaremos para verificar <strong>el b√∫fer de profundidad</strong> .  (M√°s tarde lo ampliaremos para obtener una posici√≥n en el mundo). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWorldFromViewPosition</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VertexOutput i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> z = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, sampler_CameraDepthTexture, i.screenPos).r; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> z.xxx; }</code> </pre> <br>  En el sombreador de fragmentos, dibuje el valor de la muestra de textura de profundidad. <br><br><pre> <code class="cpp hljs">float3 depth = GetWorldFromViewPosition(i); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> float4(depth, <span class="hljs-number"><span class="hljs-number">1.0</span></span>);</code> </pre> <br>  As√≠ son mis resultados cuando solo hay una llanura monta√±osa en la escena (apagu√© todos los √°rboles para simplificar a√∫n m√°s la prueba de los valores del espacio mundial).  Su resultado deber√≠a ser similar.  Los valores en blanco y negro describen la distancia desde la geometr√≠a a la c√°mara. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b10/6b6/5cc/b106b65cc3d1441aacd5042ee21b25a6.png"></div><br>  Estos son algunos pasos que puede seguir si encuentra problemas: <br><br><ul><li>  Aseg√∫rese de que la c√°mara tenga habilitada la representaci√≥n de profundidad. </li><li>  Aseg√∫rese de que la c√°mara tenga habilitado MSAA. </li><li>  Intente cambiar el plano cercano y lejano de la c√°mara. </li><li>  Aseg√∫rese de que los objetos que espera ver en el b√∫fer de profundidad usan un sombreador con un paso de profundidad.  Esto asegura que el objeto atrae al b√∫fer de profundidad.  Todos los sombreadores est√°ndar en LWRP hacen esto. </li></ul><br><h2>  Obteniendo valor en el espacio mundial </h2><br>  Ahora que tenemos toda la informaci√≥n necesaria para el <strong>espacio de coordenadas truncadas</strong> , transformemos al <strong>espacio de especies</strong> y luego al <strong>espacio mundial</strong> . <br><br>  Tenga en cuenta que las matrices de transformaci√≥n requeridas para estas operaciones ya est√°n en la biblioteca SRP.  Sin embargo, est√°n contenidos en la biblioteca C # del motor de Unity, por lo que los <a href="">insert√©</a> en el sombreador en la funci√≥n Render del script <a href="">ColorSpreadRenderer</a> : <br><br><pre> <code class="cpp hljs">sheet.properties.SetMatrix(<span class="hljs-string"><span class="hljs-string">"unity_ViewToWorldMatrix"</span></span>, context.camera.cameraToWorldMatrix); sheet.properties.SetMatrix(<span class="hljs-string"><span class="hljs-string">"unity_InverseProjectionMatrix"</span></span>, projectionMatrix.inverse);</code> </pre> <br>  Ahora ampliemos nuestra funci√≥n GetWorldFromViewPosition. <br><br>  Primero, necesitamos obtener la posici√≥n en la vista <strong>multiplicando la posici√≥n en el espacio de coordenadas truncado por la matriz de proyecci√≥n inversa</strong> .  Tambi√©n necesitamos hacer m√°s magia vud√∫ con una posici√≥n en la pantalla, que est√° relacionada con la forma en que Unity almacena su posici√≥n en el espacio de las coordenadas truncadas. <br><br>  Finalmente, podemos <strong>multiplicar la posici√≥n en la ventana gr√°fica por ViewToWorldMatrix</strong> para obtener la posici√≥n en el <strong>espacio mundial</strong> . <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWorldFromViewPosition</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VertexOutput i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    float z = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, sampler_CameraDepthTexture, i.screenPos).r; //      float4 result = mul(unity_InverseProjectionMatrix, float4(2*i.screenPos-1.0, z, 1.0)); float3 viewPos = result.xyz / result.w; //      float3 worldPos = mul(unity_ViewToWorldMatrix, float4(viewPos, 1.0)); return worldPos; }</span></span></code> </pre> <br>  Hagamos una comprobaci√≥n para asegurarnos de que las posiciones en el espacio global son correctas.  Para hacer esto, escrib√≠ un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sombreador</a> que devuelve solo la posici√≥n de un objeto en el <strong>espacio mundial</strong> ;  Este es un c√°lculo bastante simple basado en un sombreador regular, cuya exactitud se puede confiar.  Desactive el efecto del postprocesamiento y tome una captura de pantalla de este sombreador de prueba para el <strong>espacio mundial</strong> .  Mi despu√©s de aplicar el sombreador a la superficie de la tierra en la escena se ve as√≠: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a91/4f2/b78/a914f2b787501e385ef27746865429bd.png"></div><br>  (Tenga en cuenta que los valores en el espacio mundial son mucho mayores que 1.0, as√≠ que no se preocupe de que estos colores tengan sentido; en su lugar, aseg√∫rese de que los resultados sean los mismos para las respuestas "verdaderas" y "calculadas"). A continuaci√≥n, volvamos a la prueba el objeto es material ordinario (y no el material de prueba del espacio mundial) y luego vuelve a activar el efecto de procesamiento posterior.  Mis resultados se ven as√≠: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9e/deb/7ce/f9edeb7cea30fb33b72705a568264638.png"></div><br>  Esto es completamente similar al sombreador de prueba que escrib√≠, es decir, ¬°los c√°lculos del espacio mundial probablemente sean correctos! <br><br><h2>  Dibujando un c√≠rculo en el espacio mundial </h2><br>  Ahora que tenemos <strong>posiciones en el espacio mundial</strong> , ¬°podemos dibujar un c√≠rculo de color en la escena!  Necesitamos establecer el <strong>radio</strong> dentro del cual el efecto dibujar√° color.  Afuera, el efecto representar√° la imagen en escala de grises.  Para configurarlo, debe ajustar los valores para <strong>el radio del</strong> efecto ( <strong>_MaxSize</strong> ) y el centro del c√≠rculo (_Center).  Establec√≠ estos valores en la clase C # <a href="">ColorSpread</a> para que sean visibles en el inspector.  Expandamos nuestro sombreador de fragmentos forz√°ndolo <strong>a verificar si el p√≠xel actual est√° dentro del radio del c√≠rculo</strong> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Frag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VertexOutput i)</span></span></span><span class="hljs-function"> : SV_Target </span></span>{ float3 worldPos = GetWorldFromViewPosition(i); <span class="hljs-comment"><span class="hljs-comment">// ,      .  //   ,   ,  ,   float dist = distance(_Center, worldPos); float blend = dist &lt;= _MaxSize? 0 : 1; //   float4 fullColor = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.screenPos); //   float luminance = dot(fullColor.rgb, float3(0.2126729, 0.7151522, 0.0721750)); float3 greyscale = luminance.xxx; // ,       float3 color = (1-blend)*fullColor + blend*greyscale; return float4(color, 1.0); }</span></span></code> </pre> <br>  Finalmente, podemos dibujar el color en funci√≥n de si est√° dentro de un <strong>radio</strong> en el <strong>espacio mundial</strong> .  ¬°As√≠ es como se ve el efecto base! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/983/6be/fb0/9836befb050f5a354b1eb4e6faee50d5.png"></div><br><hr><br><h1>  Agregar efectos especiales </h1><br>  Ver√© un par de t√©cnicas m√°s utilizadas para hacer que el color se extienda por el suelo.  El efecto completo tiene mucho m√°s, pero el tutorial ya se ha vuelto demasiado grande, por lo que nos limitaremos a lo m√°s importante. <br><br><h2>  Animaci√≥n de ampliaci√≥n de c√≠rculo </h2><br>  Queremos que el efecto se extienda por todo el mundo, es decir, como si estuviera creciendo.  Para hacer esto, debe cambiar el <strong>radio</strong> dependiendo del tiempo. <br><br>  _StartTime indica la hora a la que el c√≠rculo deber√≠a comenzar a crecer.  En mi proyecto, utilic√© un script adicional que le permite hacer clic en cualquier lugar de la pantalla para iniciar el crecimiento del c√≠rculo;  en este caso, la hora de inicio es igual a la hora en que se hizo clic en el mouse. <br><br>  _GrowthSpeed ‚Äã‚Äãestablece la velocidad de aumentar el c√≠rculo. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//           float timeElapsed = _Time.y - _StartTime; float effectRadius = min(timeElapsed * _GrowthSpeed, _MaxSize); //  ,      effectRadius = clamp(effectRadius, 0, _MaxSize);</span></span></code> </pre> <br>  Tambi√©n necesitamos actualizar la verificaci√≥n de distancia para comparar la distancia actual con el <strong>radio</strong> creciente <strong>del efecto</strong> , y no con _MaxSize. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ,         //   ,   ,  ,   float dist = distance(_Center, worldPos); float blend = dist &lt;= effectRadius? 0 : 1; //     ...</span></span></code> </pre> <br>  As√≠ es como deber√≠a verse el resultado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecb/3bc/761/ecb3bc76112c56270745db56f2272e7c.gif"></div><br><h2>  Agregando al radio de ruido </h2><br>  Quer√≠a que el efecto fuera m√°s como una mancha de pintura, no solo un c√≠rculo creciente.  Para hacer esto, <strong>agreguemos ruido al radio del efecto</strong> para que la distribuci√≥n sea desigual. <br><br>  Primero necesitamos muestrear la textura en el <strong>espacio mundial</strong> .  Las coordenadas UV de i.screenPos se encuentran en el <strong>espacio de</strong> la <strong>pantalla</strong> , y si tomamos muestras en funci√≥n de ellas, la forma del efecto se mover√° con la c√°mara;  as√≠ que usemos las coordenadas en el <strong>espacio mundial</strong> .  <strong>Agregu√© el</strong> par√°metro <strong>_NoiseTexScale</strong> para controlar la <strong>escala de la muestra de textura de ruido</strong> , porque las coordenadas en el espacio mundial son bastante grandes. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//          float2 worldUV = worldPos.xz; worldUV *= _NoiseTexScale;</span></span></code> </pre> <br>  Ahora muestreemos la textura de ruido y agreguemos este valor al radio del efecto.  Us√© la escala _NoiseSize para tener m√°s control sobre el tama√±o del ruido. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     float noise = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, worldUV).r; effectRadius -= noise * _NoiseSize;</span></span></code> </pre> <br>  As√≠ es como se ven los resultados despu√©s de algunos ajustes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51f/b77/f57/51fb77f570eb4ba77fa4e8eaa8cadb20.gif"></div><br><hr><br><h1>  En conclusi√≥n </h1><br>  ¬°Puedes seguir las actualizaciones de los tutoriales en mi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Twitter</a> y en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Twitch</a> me paso codificando transmisiones!  (Adem√°s, transmito juegos de vez en cuando, as√≠ que no te sorprendas si me ves sentado en pijama y jugando Kingdom Hearts 3.) <br><br>  Agradecimientos <br><br><ul><li>  Todos los modelos de proyectos se toman en este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LowPoly Environment Pack</a> de la tienda Unity. </li><li>  <a href="">El efecto ScreenSpaceReflections del motor Unity</a> realmente me ayud√≥ a descubrir c√≥mo obtener una posici√≥n tridimensional en la ventana gr√°fica a partir de las coordenadas UV bidimensionales del espacio de la pantalla. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es436456/">https://habr.com/ru/post/es436456/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es436444/index.html">Despliegue invisible de una aplicaci√≥n monol√≠tica en producci√≥n en AWS. Experiencia personal</a></li>
<li><a href="../es436448/index.html">Revise el monitor IPS de 27 "Acer HA270bid: para la superaci√≥n personal</a></li>
<li><a href="../es436450/index.html">Telecontrol y control, libertad y gobierno. Conversaci√≥n con Staply</a></li>
<li><a href="../es436452/index.html">7 √°reas de desarrollo de Linux en 2019</a></li>
<li><a href="../es436454/index.html">Preguntas y respuestas de JavaScript</a></li>
<li><a href="../es436458/index.html">Progreso y exageraci√≥n en la investigaci√≥n ai</a></li>
<li><a href="../es436460/index.html">La elecci√≥n de tecnolog√≠a, arquitectura y dise√±o en proyectos de software, sin efectivo</a></li>
<li><a href="../es436464/index.html">2. An√°lisis de registro de punto de verificaci√≥n: SmartEvent</a></li>
<li><a href="../es436466/index.html">Electron: desarrollo de aplicaciones de escritorio usando HTML, CSS y JavaScript</a></li>
<li><a href="../es436468/index.html">Experimento legislativo con innovaci√≥n digital</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>