<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüåæ üò≥ üñäÔ∏è RayTracing compreens√≠vel em 256 linhas de C ++ üó£Ô∏è ‚ÅâÔ∏è üëçüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="RayTracing compreens√≠vel em 256 linhas de C ++ 


 Este √© outro cap√≠tulo do meu breve curso de palestras sobre computa√ß√£o gr√°fica . Desta vez, estamos...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RayTracing compreens√≠vel em 256 linhas de C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477244/"><h1 id="understandable-raytracing-in-256-lines-of-bare-c">  RayTracing compreens√≠vel em 256 linhas de C ++ </h1><br><p> Este √© outro cap√≠tulo do meu <a href="https://github.com/ssloy/tinyrenderer/wiki">breve curso de palestras sobre computa√ß√£o gr√°fica</a> .  Desta vez, estamos falando sobre o tra√ßado de raios.  Como sempre, tento evitar bibliotecas de terceiros, pois acredito que isso faz os alunos verificarem o que est√° acontecendo sob o cap√¥.  Verifique tamb√©m o <a href="https://github.com/ssloy/tinykaboom/wiki">projeto tinykaboom</a> . </p><br><p>  Existem muitos artigos sobre raytracing na web;  no entanto, o problema √© que quase todos mostram software acabado que pode ser bastante dif√≠cil de entender.  Tomemos, por exemplo, o famoso desafio do <a href="https://www.taylorpetrick.com/blog/post/business-rt">ray tracer de cart√µes de neg√≥cios</a> .  Produz programas muito impressionantes, mas √© muito dif√≠cil entender como isso funciona.  Em vez de mostrar que eu posso fazer renderiza√ß√µes, quero lhe contar em detalhes como voc√™ pode fazer isso sozinho. </p><br><p>  <i>Nota: N√£o faz sentido olhar apenas para o meu c√≥digo, nem ler este artigo com uma x√≠cara de ch√° na m√£o.</i>  <i>Este artigo foi projetado para voc√™ pegar o teclado e implementar seu pr√≥prio mecanismo de renderiza√ß√£o.</i>  <i>Certamente ser√° melhor que o meu.</i>  <i>No m√≠nimo, mude a linguagem de programa√ß√£o!</i> </p><br><p>  Portanto, o objetivo de hoje √© aprender a renderizar essas imagens: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/064/50f/65d/06450f65da7c0503838bc008dcaba6a3.jpg"><a name="habracut"></a><br><h1>  Etapa 1: gravar uma imagem no disco </h1><br><p>  N√£o quero me preocupar com gerenciadores de janelas, processamento de mouse / teclado e coisas assim.  O resultado do nosso programa ser√° uma imagem simples salva em disco.  Portanto, a primeira coisa que precisamos fazer √© salvar a imagem em disco.  <a href="https://github.com/ssloy/tinyraytracer/tree/bd36c9857305b3cbd06f5b768bb48a92df9ae68b">Aqui</a> voc√™ pode encontrar o c√≥digo que nos permite fazer isso.  Deixe-me listar o arquivo principal: </p><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;limits&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;vector&gt; #include "geometry.h" void render() { const int width = 1024; const int height = 768; std::vector&lt;Vec3f&gt; framebuffer(width*height); for (size_t j = 0; j&lt;height; j++) { for (size_t i = 0; i&lt;width; i++) { framebuffer[i+j*width] = Vec3f(j/float(height),i/float(width), 0); } } std::ofstream ofs; // save the framebuffer to file ofs.open("./out.ppm"); ofs &lt;&lt; "P6\n" &lt;&lt; width &lt;&lt; " " &lt;&lt; height &lt;&lt; "\n255\n"; for (size_t i = 0; i &lt; height*width; ++i) { for (size_t j = 0; j&lt;3; j++) { ofs &lt;&lt; (char)(255 * std::max(0.f, std::min(1.f, framebuffer[i][j]))); } } ofs.close(); } int main() { render(); return 0; }</span></span></span></span></code> </pre> <br><p>  Somente render () √© chamado na fun√ß√£o principal e nada mais.  O que h√° dentro da fun√ß√£o render ()?  Antes de tudo, defino o framebuffer como uma matriz unidimensional de valores Vec3f, esses s√£o vetores tridimensionais simples que nos fornecem valores (r, g, b) para cada pixel.  A classe de vetores reside no arquivo geometry.h, n√£o vou descrev√™-lo aqui: √© realmente uma manipula√ß√£o trivial de vetores bidimensionais e tridimensionais (adi√ß√£o, subtra√ß√£o, atribui√ß√£o, multiplica√ß√£o por um produto escalar e escalar). </p><br><p>  Eu salvo a imagem no <a href="https://en.wikipedia.org/wiki/Netpbm_format">formato ppm</a> .  √â a maneira mais f√°cil de salvar imagens, embora nem sempre seja a maneira mais conveniente de visualiz√°-las mais.  Se voc√™ deseja salvar em outros formatos, recomendo que voc√™ vincule uma biblioteca de terceiros, como <a href="https://github.com/nothings/stb">stb</a> .  Esta √© uma √≥tima biblioteca: voc√™ s√≥ precisa incluir um arquivo de cabe√ßalho stb_image_write.h no projeto e permitir√° salvar imagens nos formatos mais populares. </p><br><p>  <b>Aviso:</b> meu c√≥digo est√° cheio de bugs, eu os corrigo no upstream, mas as confirma√ß√µes mais antigas s√£o afetadas.  Verifique <a href="https://github.com/ssloy/tinyraycaster/issues/9">este problema</a> . </p><br><p>  Portanto, o objetivo desta etapa √© garantir que: a) crie uma imagem na mem√≥ria + atribua cores diferentes eb) salve o resultado no disco.  Ent√£o voc√™ pode v√™-lo em um software de terceiros.  Aqui est√° o resultado: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ec1/8d8/1f8/ec18d81f825957255d786b50c05c8c4b.jpg" alt="imagem"></p><br><h1>  Etapa 2, crucial: rastreamento de raios </h1><br><p>  Este √© o passo mais importante e dif√≠cil de toda a cadeia.  Quero definir uma esfera no meu c√≥digo e desenh√°-la sem ser obcecada por materiais ou ilumina√ß√£o.  √â assim que nosso resultado deve ser: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b02/143/d02/b02143d02d333d683313d209ec14eb25.jpg" alt="imagem"></p><br><p>  Por uma quest√£o de conveni√™ncia, tenho um commit por etapa no meu reposit√≥rio;  O Github facilita muito a visualiza√ß√£o das altera√ß√µes feitas.  <a href="https://github.com/ssloy/tinyraytracer/commit/5806eb45e93dab225ab335824cbc3f537d511b28">Aqui, por exemplo</a> , o que foi alterado pelo segundo commit. </p><br><p>  Para come√ßar, o que precisamos para representar a esfera na mem√≥ria do computador?  Quatro n√∫meros s√£o suficientes: um vetor tridimensional para o centro da esfera e um escalar que descreve o raio: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sphere</span></span></span><span class="hljs-class"> {</span></span> Vec3f center; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> radius; Sphere(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3f &amp;c, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> &amp;r) : center(c), radius(r) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ray_intersect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;t0)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ Vec3f L = center - orig; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> tca = L*dir; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d2 = L*L - tca*tca; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d2 &gt; radius*radius) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> thc = sqrtf(radius*radius - d2); t0 = tca - thc; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t1 = tca + thc; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t0 &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) t0 = t1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t0 &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } };</code> </pre> <br><p>  A √∫nica coisa n√£o trivial neste c√≥digo √© uma fun√ß√£o que permite verificar se um determinado raio (origin√°rio de orig na dire√ß√£o de dir) cruza com a nossa esfera.  Uma descri√ß√£o detalhada do algoritmo para a interse√ß√£o raio-esfera <a href="http://www.lighthouse3d.com/tutorials/maths/ray-sphere-intersection/">pode ser encontrada aqui</a> , eu recomendo que voc√™ fa√ßa isso e verifique meu c√≥digo. </p><br><p>  Como funciona o tra√ßado de raios?  √â bem simples.  Na primeira etapa, apenas preenchemos a imagem com um gradiente de cores: </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;height; j++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;width; i++) { framebuffer[i+j*width] = Vec3f(j/<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(height),i/<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(width), <span class="hljs-number"><span class="hljs-number">0</span></span>); } }</code> </pre> <br><p>  Agora, para cada pixel, formaremos um raio vindo da origem e passando por nosso pixel e, em seguida, verificar se esse raio se cruza com a esfera: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/66d/a0e/be3/66da0ebe356e82253f0492e6335f114e.svg"><br><p>  Se n√£o houver interse√ß√£o com a esfera, desenhamos o pixel com color1, caso contr√°rio com color2: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast_ray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Sphere &amp;sphere)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sphere_dist = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;::max(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!sphere.ray_intersect(orig, dir, sphere_dist)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vec3f(<span class="hljs-number"><span class="hljs-number">0.2</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, <span class="hljs-number"><span class="hljs-number">0.8</span></span>); <span class="hljs-comment"><span class="hljs-comment">// background color } return Vec3f(0.4, 0.4, 0.3); } void render(const Sphere &amp;sphere) { Ôøº [...] for (size_t j = 0; j&lt;height; j++) { for (size_t i = 0; i&lt;width; i++) { float x = (2*(i + 0.5)/(float)width - 1)*tan(fov/2.)*width/(float)height; float y = -(2*(j + 0.5)/(float)height - 1)*tan(fov/2.); Vec3f dir = Vec3f(x, y, -1).normalize(); framebuffer[i+j*width] = cast_ray(Vec3f(0,0,0), dir, sphere); } } Ôøº [...] }</span></span></code> </pre> <br><p>  Neste ponto, recomendo que voc√™ pegue um l√°pis e verifique no papel todos os c√°lculos (a interse√ß√£o raio-esfera e a varredura da imagem com os raios).  Por precau√ß√£o, nossa c√¢mera √© determinada pelas seguintes coisas: </p><br><ul><li>  largura da imagem </li><li>  altura da imagem </li><li>  √¢ngulo do campo de vis√£o </li><li>  localiza√ß√£o da c√¢mera, Vec3f (0.0.0) </li><li>  visualizar a dire√ß√£o, ao longo do eixo z, na dire√ß√£o do infinito negativo </li></ul><br><p>  Deixe-me ilustrar como calculamos a dire√ß√£o inicial do raio para tra√ßar.  No loop principal, temos esta f√≥rmula: </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = (<span class="hljs-number"><span class="hljs-number">2</span></span>*(i + <span class="hljs-number"><span class="hljs-number">0.5</span></span>)/(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)width - <span class="hljs-number"><span class="hljs-number">1</span></span>)*<span class="hljs-built_in"><span class="hljs-built_in">tan</span></span>(fov/<span class="hljs-number"><span class="hljs-number">2.</span></span>)*width/(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)height; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y = -(<span class="hljs-number"><span class="hljs-number">2</span></span>*(j + <span class="hljs-number"><span class="hljs-number">0.5</span></span>)/(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)height - <span class="hljs-number"><span class="hljs-number">1</span></span>)*<span class="hljs-built_in"><span class="hljs-built_in">tan</span></span>(fov/<span class="hljs-number"><span class="hljs-number">2.</span></span>);</code> </pre> <br><p>  De onde vem?  Bem simples.  Nossa c√¢mera √© colocada na origem e est√° voltada para a dire√ß√£o -z.  Deixe-me ilustrar as coisas: esta imagem mostra a c√¢mera de cima, o eixo y aponta para fora da tela: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e00/5c1/b99/e005c1b996cc7eb9978bc434f6773196.png" alt="imagem"></p><br><p>  Como eu disse, a c√¢mera √© colocada na origem e a cena √© projetada na tela que fica no plano z = -1.  O campo de vis√£o especifica qual setor do espa√ßo ser√° vis√≠vel na tela.  Em nossa imagem, a tela tem 16 pixels de largura;  voc√™ pode calcular seu comprimento em coordenadas mundiais?  √â bem simples: vamos nos concentrar no tri√¢ngulo formado pelas linhas tracejada vermelha, cinza e cinza.  √â f√°cil ver que o bronzeado (campo de vis√£o / 2) = (largura da tela) <em>0,5 / (dist√¢ncia da c√¢mera da tela).</em>  <em>Colocamos a tela a uma dist√¢ncia de 1 da c√¢mera, assim (largura da tela) = 2</em> tan (campo de vis√£o / 2). </p><br><p>  Agora, digamos que queremos converter um vetor no centro do 12¬∫ pixel da tela, ou seja, queremos calcular o vetor azul.  Como podemos fazer isso?  Qual √© a dist√¢ncia da esquerda da tela at√© a ponta do vetor azul?  Primeiro de tudo, s√£o 12 + 0,5 pixels.  Sabemos que 16 pixels da tela correspondem a 2 <em>unidades mundiais tan (fov / 2).</em>  <em>Assim, a ponta do vetor est√° localizada em (12 + 0,5) / 16</em> 2 <em>tan (fov / 2) unidades mundiais da borda esquerda ou √† dist√¢ncia de (12 + 0,5)</em> 2/16 * tan (fov / 2) - tan (fov / 2) a partir da interse√ß√£o entre a tela e o eixo -z.  Adicione a propor√ß√£o da tela aos c√°lculos e voc√™ encontrar√° exatamente as f√≥rmulas para a dire√ß√£o do raio. </p><br><h1>  Etapa 3: adicione mais esferas </h1><br><p>  A parte mais dif√≠cil acabou e agora nosso caminho est√° claro.  Se soubermos desenhar uma esfera, n√£o levaremos muito tempo para adicionar mais algumas.  <a href="https://github.com/ssloy/tinyraytracer/commit/c19c430151cb659372b4988876173b022164e371">Verifique as altera√ß√µes</a> no c√≥digo e esta √© a imagem resultante: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fc0/f37/6c9/fc0f376c9cb8971781f2a24065b47fa5.jpg" alt="imagem"></p><br><h1>  Etapa 4: ilumina√ß√£o </h1><br><p>  A imagem √© perfeita em todos os aspectos, exceto pela falta de luz.  Ao longo do restante do artigo, falaremos sobre ilumina√ß√£o.  Vamos adicionar algumas fontes de luz pontuais: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Light</span></span></span><span class="hljs-class"> {</span></span> Light(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3f &amp;p, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> &amp;i) : position(p), intensity(i) {} Vec3f position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> intensity; };</code> </pre> <br><p>  A computa√ß√£o da ilumina√ß√£o global real √© uma tarefa muito, muito dif√≠cil; portanto, como todos os outros, enganaremos os olhos desenhando resultados completamente n√£o f√≠sicos, mas visualmente plaus√≠veis.  Para come√ßar: por que est√° frio no inverno e quente no ver√£o?  Porque o aquecimento da superf√≠cie da Terra depende do √¢ngulo de incid√™ncia dos raios solares.  Quanto mais alto o sol nasce acima do horizonte, mais brilhante √© a superf√≠cie.  Por outro lado, quanto mais baixo estiver acima do horizonte, mais escuro ser√°.  E depois que o sol se p√µe no horizonte, os f√≥tons nem chegam a n√≥s. </p><br><p>  De volta √†s nossas esferas: emitimos um raio da c√¢mera (sem rela√ß√£o com f√≥tons!). Ele para em uma esfera.  Como sabemos a intensidade da ilumina√ß√£o do ponto de interse√ß√£o?  De fato, basta verificar o √¢ngulo entre um vetor normal neste ponto e o vetor que descreve uma dire√ß√£o da luz.  Quanto menor o √¢ngulo, melhor a superf√≠cie √© iluminada.  Lembre-se de que o produto escalar entre dois vetores aeb √© igual ao produto das normas dos vetores vezes o cosseno do √¢ngulo entre os vetores: a * b = | a |  | b |  cos (alfa (a, b)).  Se pegarmos vetores de comprimento unit√°rio, o produto escalar nos dar√° a intensidade da ilumina√ß√£o da superf√≠cie. </p><br><p>  Assim, na fun√ß√£o cast_ray, em vez de uma cor constante, retornaremos a cor levando em considera√ß√£o as fontes de luz: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast_ray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Sphere &amp;sphere)</span></span></span><span class="hljs-function"> </span></span>{ [...] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> diffuse_light_intensity = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;lights.size(); i++) { Vec3f light_dir = (lights[i].position - point).normalize(); diffuse_light_intensity += lights[i].intensity * <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(<span class="hljs-number"><span class="hljs-number">0.f</span></span>, light_dir*N); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> material.diffuse_color * diffuse_light_intensity; }</code> </pre> <br><p>  As modifica√ß√µes feitas na etapa anterior <a href="https://github.com/ssloy/tinyraytracer/commit/9a728fff2bbebb1eedd86e1ac89f657d43191609">est√£o dispon√≠veis aqui</a> , e aqui est√° o resultado: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/207/766/76d/20776676d3aff568b466807ef548ea5a.jpg" alt="imagem"></p><br><h1>  Etapa 5: ilumina√ß√£o especular </h1><br><p>  O truque do produto com pontos fornece uma boa aproxima√ß√£o da ilumina√ß√£o de superf√≠cies mate, na literatura √© chamada de ilumina√ß√£o difusa.  O que devemos fazer se queremos desenhar superf√≠cies brilhantes?  Quero tirar uma foto assim: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2d6/b39/c52/2d6b39c52aaa6a8c8667fd2df19f2e93.jpg" alt="imagem"></p><br><p>  Verifique <a href="https://github.com/ssloy/tinyraytracer/commit/f5ec45c2541feb86b6a30cc3bb04917d60d13e9b">quantas modifica√ß√µes</a> foram necess√°rias.  Em resumo, quanto mais brilhante a luz nas superf√≠cies brilhantes, menor o √¢ngulo entre a dire√ß√£o da vista e a dire√ß√£o da luz <i>refletida</i> . </p><br><p>  Esse truque com ilumina√ß√£o de superf√≠cies foscas e brilhantes √© conhecido como <a href="https://en.wikipedia.org/wiki/Phong_reflection_model">modelo de reflex√£o Phong</a> .  O wiki tem uma descri√ß√£o bastante detalhada desse modelo de ilumina√ß√£o.  Pode ser bom l√™-lo lado a lado com o c√≥digo fonte.  Aqui est√° a imagem principal para entender a m√°gica: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/881/d77/0ca/881d770ca8779cc876808a22c0fd8cce.png" alt="imagem"></p><br><h1>  Etapa 6: sombras </h1><br><p>  Por que temos a luz, mas sem sombras?  N√£o est√° tudo bem!  Quero esta foto: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e8f/fdd/04c/e8ffdd04c72dfc92f0845bb7b079faf7.jpg" alt="imagem"></p><br><p>  <a href="https://github.com/ssloy/tinyraytracer/commit/ef70d1356169dacb3183ad4fcb4c23f1d7003e1b">Apenas seis linhas de c√≥digo</a> nos permitem alcan√ßar isso: ao desenhar cada ponto, apenas garantimos que o segmento entre o ponto atual e a fonte de luz n√£o cruze os objetos de nossa cena.  Se houver uma interse√ß√£o, pularemos a fonte de luz atual.  H√° apenas uma pequena sutileza: eu perturbo o ponto movendo-o na dire√ß√£o normal: </p><br><pre> <code class="cpp hljs">Vec3f shadow_orig = light_dir*N &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? point - N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span> : point + N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span>;</code> </pre> <br><p>  Por que isso?  S√≥ que nosso ponto est√° na superf√≠cie do objeto e (exceto na quest√£o de erros num√©ricos) qualquer raio desse ponto cruzar√° o pr√≥prio objeto. </p><br><h1>  Etapa 7: reflex√µes </h1><br><p>  √â incr√≠vel, mas para adicionar reflex√µes √† nossa renderiza√ß√£o, precisamos apenas adicionar tr√™s linhas de c√≥digo: </p><br><pre> <code class="cpp hljs"> Vec3f reflect_dir = reflect(dir, N).normalize(); Vec3f reflect_orig = reflect_dir*N &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? point - N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span> : point + N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span>; <span class="hljs-comment"><span class="hljs-comment">// offset the original point to avoid occlusion by the object itself Vec3f reflect_color = cast_ray(reflect_orig, reflect_dir, spheres, lights, depth + 1);</span></span></code> </pre> <br><p>  <a href="https://github.com/ssloy/tinyraytracer/commit/c80479d1d22fe98f41b584972affeb43422a23a6">Veja voc√™ mesmo:</a> ao cruzar a esfera, apenas calculamos o raio refletido (com a ajuda da mesma fun√ß√£o que usamos para realces especulares!) E chamamos recursivamente a fun√ß√£o cast_ray na dire√ß√£o do raio refletido.  Certifique-se de jogar com <a href="">a profundidade da recurs√£o</a> , defino-a como 4, tente valores diferentes, come√ßando por 0, o que mudar√° na imagem?  Aqui est√° o meu resultado com reflex√µes e uma profundidade de recurs√£o de 4: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a9d/1c2/e6d/a9d1c2e6d428aaba07953cae3fa007ea.jpg" alt="imagem"></p><br><h1>  Etapa 8: refra√ß√µes </h1><br><p>  Se sabemos fazer reflex√µes, as <a href="https://github.com/ssloy/tinyraytracer/commit/b69793bf6e8be54973cad1b18185a67dbf11bad1">refra√ß√µes s√£o f√°ceis</a> .  Precisamos adicionar uma fun√ß√£o para calcular o raio refratado ( <a href="https://en.wikipedia.org/wiki/Snell%2527s_law">usando a lei de Snell</a> ) e mais tr√™s linhas de c√≥digo em nossa fun√ß√£o recursiva cast_ray.  Aqui est√° o resultado, onde a bola mais pr√≥xima √© "feita de vidro", ela reflete e refrata a luz ao mesmo tempo: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8c8/14a/56a/8c814a56aafc88609ebeb8c5a6f9a494.jpg" alt="imagem"></p><br><h1>  Steo 9: al√©m das esferas </h1><br><p>  At√© este momento, renderizamos apenas esferas porque √© um dos objetos matem√°ticos n√£o triviais mais simples.  Vamos adicionar um avi√£o.  O tabuleiro de xadrez √© uma escolha cl√°ssica.  Para esse fim, basta adicionar <a href="https://github.com/ssloy/tinyraytracer/commit/5e0da1f09fdbc585caa16df4c7b2f527d61536ef">uma d√∫zia de linhas</a> . </p><br><p>  E aqui est√° o resultado: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/d88/871/a50/d88871a5021eb69cc64c7b9a5915e855.jpg"><br><p>  Como prometido, o c√≥digo tem 256 linhas de c√≥digo, <a href="https://github.com/ssloy/tinyraytracer">verifique voc√™ mesmo</a> ! </p><br><h1>  Etapa 10: tarefa de casa </h1><br><p>  Percorremos um longo caminho: aprendemos como adicionar objetos a uma cena, como calcular uma ilumina√ß√£o bastante complicada.  Deixe-me deixar duas tarefas para voc√™ como li√ß√£o de casa.  Absolutamente todo o trabalho preparat√≥rio j√° foi realizado no ramo <a href="https://github.com/ssloy/tinyraytracer/tree/homework_assignment">homework_assignment</a> .  Cada tarefa exigir√° dez linhas de tops de c√≥digo. </p><br><h3>  Tarefa 1: mapa do ambiente </h3><br><p>  No momento, se o raio n√£o cruzar nenhum objeto, basta definir o pixel com a cor de fundo constante.  E por que, na verdade, √© constante?  Vamos tirar uma foto esf√©rica (arquivo <a href="">envmap.jpg</a> ) e us√°-la como pano de fundo!  Para facilitar a vida, vinculei nosso projeto √† biblioteca stb para a conveni√™ncia de trabalhar com o formato jpg.  Deveria nos dar uma imagem assim: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/3e0/531/fa9/3e0531fa9ee361de7580029e818bc5f5.jpg" alt="imagem"></p><br><h3>  Tarefa 2: Quack-Quack! </h3><br><p>  Podemos renderizar esferas e planos (veja o tabuleiro de damas).  Ent√£o, vamos desenhar malhas triangulares!  Eu escrevi um c√≥digo que permite ler um arquivo .obj e adicionei uma fun√ß√£o de interse√ß√£o raio-tri√¢ngulo a ele.  Agora, adicionar o pato √† nossa cena deve ser bastante trivial: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/064/50f/65d/06450f65da7c0503838bc008dcaba6a3.jpg" alt="imagem"></p><br><h1>  Conclus√£o </h1><br><p>  Meu principal objetivo √© mostrar projetos que s√£o interessantes (e f√°ceis!) Para programar.  Estou convencido de que, para se tornar um bom programador, √© preciso fazer muitos projetos paralelos.  N√£o conhe√ßo voc√™, mas pessoalmente n√£o me sinto atra√≠do pelo software de contabilidade e pelo jogo do ca√ßa-minas, mesmo que a complexidade do c√≥digo seja bastante compar√°vel. </p><br><p>  Poucas horas e duzentas e cinquenta linhas de c√≥digo nos d√£o um tra√ßador de raios.  <a href="https://github.com/ssloy/tinyrenderer/wiki">Quinhentas linhas</a> do rasterizador de software podem ser executadas em alguns dias.  Gr√°ficos √© muito legal para aprender a programa√ß√£o! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt477244/">https://habr.com/ru/post/pt477244/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt477230/index.html">A hist√≥ria do software educacional: os primeiros computadores pessoais, jogos e softwares educacionais para estudantes</a></li>
<li><a href="../pt477234/index.html">O rato que p√¥s fim aos irm√£os de arame</a></li>
<li><a href="../pt477236/index.html">Tribunal dos EUA permite que estados devolvam neutralidade da rede</a></li>
<li><a href="../pt477238/index.html">Plus to Karma: Para que criticam o estouro de pilha e por que muitos reclamam da toxicidade da comunidade</a></li>
<li><a href="../pt477242/index.html">Como escolhemos o ServiceDesk. Parte 3</a></li>
<li><a href="../pt477248/index.html">Minha primeira experi√™ncia na recupera√ß√£o de um banco de dados do Postgres ap√≥s uma falha (p√°gina inv√°lida no bloco 4123007 da relatton base / 16490)</a></li>
<li><a href="../pt477250/index.html">Ent√£o voc√™ deseja executar o Windows 10 em uma calculadora? Ok</a></li>
<li><a href="../pt477252/index.html">Como as incubadoras e aceleradoras de neg√≥cios se desenvolveram: do laborat√≥rio de Thomas Edison ao Y Combinator</a></li>
<li><a href="../pt477254/index.html">Autentica√ß√£o XSS, CSRF e Flash. Solu√ß√£o de problemas com o r0ot-mi Web - Client. Parte 2</a></li>
<li><a href="../pt477256/index.html">O primeiro lan√ßamento completo do OneWeb no ve√≠culo de lan√ßamento da Soyuz √© adiado no pr√≥ximo ano, bem como o lan√ßamento do ve√≠culo de lan√ßamento de Angara</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>