<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßú üåà üõéÔ∏è Otimiza√ß√£o de desempenho para aplicativos .NET (C #) üòã üîà ü§∞üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Existem muitos artigos com um t√≠tulo semelhante, ent√£o tentarei evitar t√≥picos comuns. Espero que at√© um desenvolvedor muito experiente encontre algo ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Otimiza√ß√£o de desempenho para aplicativos .NET (C #)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466931/"><img src="https://habrastorage.org/webt/gs/yu/jc/gsyujcvzccxootdcxkywpaida0k.jpeg" alt="imagem"><br><br>  Existem muitos artigos com um t√≠tulo semelhante, ent√£o tentarei evitar t√≥picos comuns.  Espero que at√© um desenvolvedor muito experiente encontre algo √∫til aqui.  Este artigo considerar√° apenas mecanismos e abordagens de otimiza√ß√£o simples que permitir√£o sua aplica√ß√£o com o m√≠nimo de esfor√ßo.  E essas altera√ß√µes n√£o aumentar√£o a entropia do seu c√≥digo.  O artigo n√£o prestar√° aten√ß√£o ao que e quando otimizar; este artigo √© mais sobre a abordagem para escrever c√≥digo em geral. <br><a name="habracut"></a><br><h4>  1. ToArray vs ToList </h4><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerable&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetItems</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _storage.Items.Where(...).ToList(); }</code> </pre> <br>  Concordo, um c√≥digo muito t√≠pico para projetos industriais.  Mas o que h√° de errado com ele?  A interface IEnumerable retorna uma cole√ß√£o que voc√™ pode "revisar"; essa interface n√£o implica que possamos adicionar / remover elementos.  Portanto, n√£o h√° necessidade de finalizar a express√£o LINQ convertendo para uma Lista (ToList).  Nesse caso, √© prefer√≠vel transmitir para Array (ToArray).  Como List √© um wrapper sobre Array e todos os recursos adicionais fornecidos por esse wrapper, cortamos a interface.  Uma matriz consome menos mem√≥ria e o acesso aos seus valores √© mais r√°pido.  Por conseguinte, por que pagar mais.  Por um lado, essa otimiza√ß√£o n√£o √© significativa, como se diz "otimiza√ß√£o em correspond√™ncias", mas isso n√£o √© totalmente verdade.  O fato √© que em um aplicativo t√≠pico no qual os servi√ßos retornam modelos para a camada de apresenta√ß√£o, pode haver uma infinidade de chamadas ToList.  No exemplo descrito acima, a interface IEnumerable √© introduzida apenas para fins ilustrativos.  Essa abordagem √© relevante para todos os casos em que voc√™ precisa retornar uma cole√ß√£o que n√£o ser√° alterada posteriormente. <br><br>  Prevejo um coment√°rio de que Matriz e Lista n√£o funcionar√£o de maneira equivalente no caso de acesso multiencadeado √† cole√ß√£o.  √â mesmo.  Mas se voc√™, como desenvolvedor, estiver considerando a possibilidade de acesso multiencadeado a uma cole√ß√£o com a possibilidade de alter√°-la, com um alto grau de probabilidade, nem a Matriz nem a Lista ser√£o adequadas. <br><br><h4>  2. O par√¢metro "caminho do arquivo" nem sempre √© a melhor op√ß√£o para o seu m√©todo </h4><br>  Ao desenvolver uma API, evite assinaturas de m√©todo que recebem um caminho de arquivo como entrada (para processamento posterior pelo seu m√©todo).  Em vez disso, forne√ßa a capacidade de transmitir uma matriz de bytes para a entrada ou, <b>como √∫ltimo recurso,</b> Stream.  O fato √© que, com o tempo, seu m√©todo pode ser aplicado n√£o apenas a um arquivo do disco, mas tamb√©m a um arquivo transferido pela rede, a um arquivo de um arquivo morto, a um arquivo de um banco de dados, a um arquivo cujo conte√∫do √© gerado dinamicamente na mem√≥ria etc. Fornecendo um m√©todo com o par√¢metro de entrada "caminho do arquivo", voc√™ obriga o usu√°rio da sua API a salvar os dados em disco antes de l√™-los novamente.  Essa opera√ß√£o sem sentido afeta criticamente o desempenho.  Uma unidade √© uma coisa extremamente lenta.  Por conveni√™ncia, voc√™ pode fornecer um m√©todo com um par√¢metro de entrada "caminho para um arquivo", mas sempre use um m√©todo p√∫blico sobrecarregado com uma matriz de bytes ou fluxo na entrada.  H√° um "marcador" que pode ajudar a encontrar opera√ß√µes extras de grava√ß√£o / leitura de disco, tente encontrar em seu projeto usando m√©todos padr√£o: <code>Path.GetTempPath()</code> e <code>Path.GetRandomFileName()</code> (do System.IO).  Com um alto grau de probabilidade, voc√™ encontrar√° uma solu√ß√£o alternativa para o problema acima ou similar. <br><br>  Um leitor atento e experiente perceber√° que, em alguns casos, gravar em disco pode, pelo contr√°rio, melhorar o desempenho, por exemplo, se estivermos lidando com arquivos muito grandes.  Isso √© verdade, deve ser levado em considera√ß√£o, mas presumo que essa seja uma situa√ß√£o muito rara com uma implementa√ß√£o espec√≠fica. <br><br><h4>  3. Evite usar threads como par√¢metros e o resultado de retorno de seus m√©todos </h4><br>  Qual √© o problema aqui ... quando obtemos um fluxo de alguma "caixa preta", devemos ter em mente seu estado.  I.e.  O fluxo est√° aberto?  Onde est√° o marcador de leitura / grava√ß√£o?  Seu estado pode mudar independentemente do nosso c√≥digo?  Se um fluxo √© declarado como uma classe base de fluxo, nem sequer temos informa√ß√µes sobre quais opera√ß√µes est√£o dispon√≠veis.  Tudo isso √© resolvido com verifica√ß√µes adicionais, c√≥digo e custos adicionais.  Al√©m disso, deparei-me repetidamente com uma situa√ß√£o em que, ao receber o Stream de algum m√©todo "obscuro", o desenvolvedor preferia jogar com seguran√ßa e "transferir" dados dele para um novo MemoryStream local completamente controlado.  Embora o fluxo de origem possa ser bastante seguro.  Talvez at√© isso j√° estivesse gentilmente preparado para a leitura do MemoryStream.  √Äs vezes, pode chegar ao ponto do absurdo - dentro de um m√©todo, uma matriz de bytes √© colocada em um MemoryStream, ent√£o esse MemoryStream √© retornado como resultado de um m√©todo declarado como um fluxo base.  L√° fora, esse fluxo se transforma em um novo MemoryStream e, em seguida, ToArray () retorna uma matriz de bytes, que originalmente t√≠nhamos.  Mais precisamente, ser√° sua pr√≥xima c√≥pia.  A ironia √© que, dentro e fora do nosso m√©todo, o c√≥digo est√° completamente correto.  Na minha opini√£o, este exemplo n√£o est√° fora de minha cabe√ßa, mas foi encontrado em algum lugar no c√≥digo comercial. <br><br>  Como resultado, se voc√™ tiver a capacidade de enviar / receber dados "limpos", n√£o use fluxos para isso - n√£o crie traps para aqueles que os usar√£o.  Se seu aplicativo j√° tiver fluxos de transfer√™ncia / retorno, analise seu uso com base no exposto acima. <br><br><h4>  4. Heran√ßa de enums </h4><br>  Essa otimiza√ß√£o √© comum, todo mundo sabe, at√© os alunos.  Mas, pela minha experi√™ncia, √© extremamente raramente usado.  Portanto, por padr√£o, o enum herda de int.  No entanto, ele pode ser herdado do byte, que cont√©m 256 valores (ou 8 valores "sinaliz√°veis").  Que quase sempre cobre a funcionalidade do enum "intermedi√°rio".  Uma altera√ß√£o m√≠nima no c√≥digo e todos os valores da sua enum ocupam menos mem√≥ria para sempre.  Abaixo est√° uma ilustra√ß√£o de uma refer√™ncia para preencher uma cole√ß√£o com valores de enumera√ß√£o herdados de int e byte. <br><br><img src="https://habrastorage.org/webt/e-/ir/q2/e-irq2g_r9iorxjbadfqyxuc9ei.png"><br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo de refer√™ncia</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CollectEnums</span></span> { [Params(<span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">10000</span></span>, <span class="hljs-number"><span class="hljs-number">100000</span></span>, <span class="hljs-number"><span class="hljs-number">1000000</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N; [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> EnumFromInt[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnumOfInt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { EnumFromInt[] results = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EnumFromInt[N]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; i++) { results[i] = EnumFromInt.Value1; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> results; } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> EnumFromByte[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnumOfByte</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { EnumFromByte[] results = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EnumFromByte[N]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; i++) { results[i] = EnumFromByte.Value1; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> results; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> EnumFromInt { Value1, Value2 } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> EnumFromByte: <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> { Value1, Value2 }</code> </pre> <br></div></div><br><h4>  5. Mais algumas palavras sobre as classes Matriz e Lista </h4><br>  Seguindo a l√≥gica, a itera√ß√£o em uma matriz √© sempre mais eficiente do que a itera√ß√£o em uma "planilha", pois uma "planilha" √© um inv√≥lucro em uma matriz.  Al√©m disso, seguindo a l√≥gica, "for" √© sempre mais r√°pido que "foreach", pois o "foreach" executa muitas das a√ß√µes exigidas pela implementa√ß√£o da interface IEnumerable.  Tudo √© l√≥gico aqui, mas errado!  Vamos dar uma olhada nos resultados do benchmark: <br><br><img src="https://habrastorage.org/webt/p7/7z/ih/p77zihj1drhzs84wcik9vtyq4qg.png"><br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo de refer√™ncia</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">IterationBenchmark</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; _list; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] _array; [Params(<span class="hljs-number"><span class="hljs-number">100000</span></span>, <span class="hljs-number"><span class="hljs-number">10000000</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N; [GlobalSetup] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Setup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MIN = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MAX = <span class="hljs-number"><span class="hljs-number">10</span></span>; Random rnd = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); _list = Enumerable.Repeat(<span class="hljs-number"><span class="hljs-number">0</span></span>, N).Select(i =&gt; rnd.Next(MIN, MAX)).ToList(); _array = _list.ToArray(); } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ForList</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; _list.Count; i++) { total += _list[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total; } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ForeachList</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _list) { total += i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total; } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ForeachArray</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _array) { total += i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total; } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ForArray</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; _array.Length; i++) { total += _array[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total; } }</code> </pre> <br></div></div><br>  O fato √© que, para iterar sobre uma matriz, "foreach" n√£o usa uma implementa√ß√£o IEnumerable.  Nesse caso em particular, a itera√ß√£o mais otimizada por √≠ndice √© executada, sem verificar fora dos limites da matriz, pois a constru√ß√£o "foreach" n√£o opera com √≠ndices, portanto, o desenvolvedor n√£o tem a op√ß√£o de "bagun√ßar" o c√≥digo.  Essa √© a exce√ß√£o √† regra.  Portanto, se em alguma se√ß√£o cr√≠tica do c√≥digo voc√™ substituiu o uso de "foreach" por "for" por uma quest√£o de otimiza√ß√£o, voc√™ deu um tiro no p√©.  Observe que isso √© relevante <b>apenas para matrizes</b> .  Existem v√°rias ramifica√ß√µes no StackOverflow em que esse recurso √© discutido. <br><br><h4>  6. A pesquisa em uma tabela de hash sempre se justifica? </h4><br>  Todo mundo sabe que tabelas de hash s√£o muito eficazes para pesquisar.  Mas eles costumam esquecer que o pre√ßo de uma pesquisa r√°pida √© uma adi√ß√£o lenta √† tabela de hash.  O que se segue disso?  Para que o uso da tabela de hash seja justificado, √© necess√°rio que o n√∫mero de elementos da tabela de hash seja pelo menos 8 (aproximadamente).  E para que o n√∫mero de opera√ß√µes de pesquisa fosse pelo menos uma ordem de magnitude maior que o n√∫mero de opera√ß√µes de adi√ß√£o.  Caso contr√°rio, use uma cole√ß√£o mais simples.  A qualidade da fun√ß√£o hash far√° seus pr√≥prios ajustes na efici√™ncia, mas o significado disso n√£o ser√° alterado.  Na minha pr√°tica, houve um caso em que o maior gargalo no c√≥digo carregado estava chamando o m√©todo Dictionary.Add ().  A chave era uma corda regular, de comprimento curto.  Lembrando disso e se tornou um gatilho para escrever este par√°grafo.  Para ilustrar, um exemplo de c√≥digo muito ruim: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNumber</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numberStr</span></span></span><span class="hljs-function">)</span></span> { Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; dictionary = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; { {<span class="hljs-string"><span class="hljs-string">"One"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Two"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Three"</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>} }; dictionary.TryGetValue(numberStr, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br>  Talvez algo semelhante ocorra no seu projeto? <br><br><h4>  7. M√©todos de incorpora√ß√£o </h4><br>  O c√≥digo √© dividido em m√©todos com mais freq√º√™ncia por 2 raz√µes.  Garanta a reutiliza√ß√£o e decomposi√ß√£o do c√≥digo quando uma tarefa estiver dividida em v√°rias subtarefas.  √â mais f√°cil para uma pessoa.  O embutimento √© o processo inverso de decomposi√ß√£o, ou seja,  o c√≥digo do m√©todo est√° incorporado no local em que o m√©todo deve ser chamado e, como resultado, economizamos na pilha de chamadas e na passagem de par√¢metros.  Eu n√£o recomendo empurrar tudo em um √∫nico m√©todo.  Mas esses m√©todos que poder√≠amos teoricamente "inline" podem ser marcados com o atributo correspondente: <br><br><pre> <code class="plaintext hljs">[MethodImpl(MethodImplOptions.AggressiveInlining)]</code> </pre> <br>  Este atributo informar√° ao sistema que esse m√©todo pode ser incorporado.  Isso n√£o significa que o m√©todo marcado com este atributo seja necessariamente interno.  Por exemplo, n√£o √© poss√≠vel incorporar m√©todos recursivos ou virtuais.  Tamb√©m √© importante notar que o mecanismo de incorpora√ß√£o √© extremamente "delicado".  Existem muitas outras raz√µes pelas quais o sistema se recusar√° a incorporar seu m√©todo.  No entanto, a equipe da Microsoft que trabalha no .NET Core est√° usando ativamente esse atributo.  O c√≥digo fonte do .NET Core tem muitos exemplos de seu uso. <br><br><h4>  8. Capacidade Estimada </h4><br>  Eu (e espero que a maioria dos desenvolvedores tamb√©m) tenha desenvolvido um reflexo: Inicializei a cole√ß√£o - pensei se √© poss√≠vel definir o Capacity para ela.  No entanto, o n√∫mero exato de elementos de cole√ß√£o nem sempre √© conhecido antecipadamente.  Mas esse n√£o √© um motivo para ignorar esse par√¢metro.  Por exemplo, se, falando sobre quantos itens haver√° em sua cole√ß√£o, voc√™ assume um "par de milhares" emba√ßado, esta √© uma ocasi√£o para definir a Capacidade como 1000. Uma pequena teoria, por exemplo, para Lista por padr√£o, Capacidade = 16, para que apenas alcan√ßar 1000, o sistema far√° 1008 (16 + 32 + 64 + 128 + 256 + 512) c√≥pias extras dos elementos e criar√° 7 matrizes tempor√°rias para serem tratadas na pr√≥xima chamada do GC.  I.e.  todo esse trabalho ser√° desperdi√ßado.  Al√©m disso, como Capacidade, ningu√©m pro√≠be usar a f√≥rmula.  Se o tamanho da sua cole√ß√£o for estimado em um ter√ßo da outra cole√ß√£o, voc√™ poder√° definir Capacity igual a otherCollection.Count / 3. Ao definir o Capacity, √© bom entender o alcance do tamanho poss√≠vel da cole√ß√£o e a proximidade com que seu valor √© distribu√≠do.  Sempre h√° uma chance de dano, mas se usada corretamente, uma capacidade estimada lhe dar√° uma boa vit√≥ria. <br><br><h4>  9. Sempre especifique seu c√≥digo. </h4><br>  Use ativamente (√† primeira vista, opcional) palavras-chave do C #, como: est√°tico, const, somente leitura, lacrado, abstrato etc.  Naturalmente, onde eles fazem sentido.  E aqui est√° a performance?  O fato √© que, quanto mais detalhado voc√™ descreve seu sistema para o compilador, mais otimizado √© o c√≥digo que ele pode gerar.  Um leitor atento e experiente pode perceber que, por exemplo, a palavra-chave selada n√£o afeta o desempenho.  Agora isso √© verdade, mas nas vers√µes futuras tudo pode mudar.  D√™ uma chance ao compilador e √† m√°quina virtual!  Receba um b√¥nus, identificando muitos erros de uso indevido do seu c√≥digo na fase de compila√ß√£o.  Regra geral: quanto mais claramente o sistema for descrito, mais otimizado ser√° o resultado.  Aparentemente, com as pessoas tamb√©m. <br><br><div class="spoiler">  <b class="spoiler_title">A hist√≥ria real confirma essa regra, mas se voc√™ ler a pregui√ßa, poder√° pular</b> <div class="spoiler_text">  Uma noite, enquanto envolvido em seu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">projeto de hobby</a> , ele se prop√¥s a aumentar o desempenho de uma se√ß√£o de c√≥digo acima de um determinado n√≠vel.  Mas este site era curto e havia poucas op√ß√µes para o que fazer com ele.  Eu encontrei na documenta√ß√£o que, come√ßando com a vers√£o C # 7.2, a palavra-chave ‚Äúreadonly‚Äù pode ser usada para estruturas.  E no meu caso, estruturas imut√°veis ‚Äã‚Äãforam usadas, adicionando uma √∫nica palavra "somente leitura" e consegui o que queria, mesmo com uma margem!  O sistema, sabendo que minhas estruturas n√£o devem ser alteradas, conseguiu gerar um c√≥digo melhor para o meu caso. <br></div></div><br><h4>  10. Se poss√≠vel, use uma vers√£o do .NET para todos os projetos de solu√ß√£o </h4><br>  Voc√™ deve se esfor√ßar para garantir que todos os assemblies no seu aplicativo perten√ßam √† mesma vers√£o do .NET.  Isso se aplica aos pacotes NuGet (editados em packages.config / json) e aos seus pr√≥prios assemblies (editados nas propriedades do projeto).  Isso economizar√° RAM e acelera o in√≠cio "frio", pois na mem√≥ria do seu aplicativo n√£o haver√° c√≥pias das mesmas bibliotecas para diferentes vers√µes do .NET.  Vale ressaltar que nem sempre, vers√µes diferentes do .NET geram c√≥pias na mem√≥ria.  Mas suponha que um aplicativo criado na mesma vers√£o do .NET seja sempre melhor.  Al√©m disso, isso elimina v√°rios problemas em potencial que est√£o fora do escopo deste artigo.  A consolida√ß√£o de vers√µes de todos os pacotes NuGet usados ‚Äã‚Äãtamb√©m contribuir√° para melhorar o desempenho do seu aplicativo. <br><br><h4>  Algumas ferramentas √∫teis </h4><br>  <b>O ILSpy</b> √© uma ferramenta gratuita que permite exibir o c√≥digo-fonte do assembly restaurado.  Se eu tiver uma pergunta sobre qual mecanismo .NET √© mais eficiente, primeiro abro o ILSpy (e n√£o o Google ou o StackOverflow) e j√° vejo como ele √© implementado.  Por exemplo, para descobrir o que √© melhor usado em termos de desempenho para o recebimento de dados via HTTP, a classe HttpWebRequest ou WebClient, basta ver sua implementa√ß√£o por meio do ILSpy.  Nesse caso espec√≠fico, o WebClient √© um inv√≥lucro do HttpWebRequest, respectivamente, a resposta √© √≥bvia.  Os c√≥digos-fonte .NET n√£o valem medo, s√£o escritos pelos mesmos programadores comuns. <br><br>  <b>BenchmarkDotNet</b> √© uma biblioteca gratuita de benchmarks.  Existe um StopWatch simples e intuitivo (do System.Diagnostics).  Mas √†s vezes n√£o √© suficiente.  Como, de uma maneira boa, √© necess√°rio levar em considera√ß√£o n√£o um √∫nico resultado, mas a m√©dia de v√°rias compara√ß√µes, √© melhor comparar sua mediana para minimizar a influ√™ncia do sistema operacional.  Al√©m disso, voc√™ precisa levar em considera√ß√£o a "partida a frio" e a quantidade de mem√≥ria alocada.  Para testes t√£o complexos, foi criado o BenchmarkDotNet.  √â essa biblioteca que os desenvolvedores do .NET Core usam em testes oficiais.  A biblioteca √© f√°cil de usar, mas se seus autores lerem repentinamente este post, d√™ uma oportunidade mais conveniente de influenciar a estrutura da tabela de resultados. <br><br>  <b>Os U2U Consult Performance Analyzers</b> s√£o um plug-in gratuito para o Visual Studio que fornece dicas sobre como melhorar o c√≥digo em termos de desempenho.  100% dependem dos conselhos deste analisador n√£o vale a pena.  Desde que me deparei com uma situa√ß√£o em que um conselho me surpreendeu um pouco e, depois de uma an√°lise detalhada, ele realmente se mostrou errado.  Infelizmente, este exemplo est√° perdido, ent√£o tome uma palavra.  No entanto, se voc√™ us√°-lo cuidadosamente, √© uma ferramenta muito √∫til.  Por exemplo, ele sugerir√° que, em vez de <code>myStr.Replace("*", "-")</code> mais eficiente usar <code>myStr.Replace('*', '-')</code> .  E as duas express√µes Where no LINQ s√£o melhor combinadas em uma.  Tudo isso √© "otimiza√ß√£o em correspond√™ncias", mas s√£o f√°ceis de aplicar e n√£o levam a um aumento no c√≥digo / complexidade. <br><br><h4>  Em conclus√£o </h4><br>  Se cada d√©cima pessoa que ler o artigo aplicar as abordagens acima em seu projeto atual (ou uma parte cr√≠tica dele) e tamb√©m aderir a essas abordagens no futuro, ent√£o juntos podemos salvar toda a floresta!  Forest ???  I.e.  os recursos poupados dos sistemas de computador, na forma de eletricidade obtida da queima de madeira, permanecer√£o sem uso.  Nesse caso, a ‚Äúfloresta‚Äù √© apenas algum tipo de equivalente.  Provavelmente saiu uma conclus√£o estranha, mas espero que voc√™ seja inspirado pelo pensamento. <br><br><h4>  Atualiza√ß√£o PS baseada em coment√°rios </h4><br>  A vantagem do ToArray sobre o ToList √© relevante para o .NET Core.  Mas se voc√™ usar o antigo .NET Framework, provavelmente ser√° prefer√≠vel o ToList.  O problema √© que, no .NET Framework, a chamada ToArray em si √© significativamente mais lenta que a chamada ToList.  E essas perdas podem n√£o ser compensadas por acessos mais r√°pidos a elementos e menos armazenamento em matriz.  Em geral, esse problema acabou sendo mais complicado, pois diferentes classes que implementam IEnumerable podem ter diferentes implementa√ß√µes de ToArray e ToList, com diferentes n√≠veis de efici√™ncia. <br><br>  Se a enumera√ß√£o herdada do byte for usada como membro de uma classe (estrutura) e n√£o separadamente, talvez n√£o haja economia de mem√≥ria.  Devido ao alinhamento da mem√≥ria ocupada de todos os membros da classe (estrutura).  Este ponto est√° ausente no artigo.  No entanto, o ganho potencial √© melhor do que a sua aus√™ncia, pois al√©m da mem√≥ria ocupada, tamb√©m s√£o utilizados enum's.  Portanto, o par√°grafo 4 ainda √© relevante, mas com esta importante reserva. <br><br>  Agrade√ßo ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">KvanTTT</a> e √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">epetrukhin</a> pelos coment√°rios construtivos sobre essas quest√µes. <br><br>  Al√©m disso, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Taritsyn</a> observou, a otimiza√ß√£o no est√°gio de compila√ß√£o JIT para a palavra-chave ‚Äúselada‚Äù ainda existe.  Mas isso apenas confirma todas as teses do par√°grafo 9. <br><br>  Parece que todos os coment√°rios construtivos foram levados em considera√ß√£o.  Estou muito satisfeito com esses coment√°rios.  Como eu, como autor, recebi um feedback e tamb√©m aprendi algo novo para mim. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt466931/">https://habr.com/ru/post/pt466931/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt466917/index.html">Quando o padr√£o HTTP n√£o √© suficiente. Confirma√ß√£o de micronauta</a></li>
<li><a href="../pt466921/index.html">5 problemas de qualquer empresa de servi√ßos e sua solu√ß√£o usando a plataforma de automa√ß√£o</a></li>
<li><a href="../pt466923/index.html">Como profissionais de TI em um banco estrangeiro para provar a origem dos fundos</a></li>
<li><a href="../pt466925/index.html">Como executar o VDS Hi-CPU para Bitrix, dispersar papagaios e n√£o quebrar</a></li>
<li><a href="../pt466929/index.html">Adicionar token de atualiza√ß√£o</a></li>
<li><a href="../pt466933/index.html">Como fazer amigos ind√∫stria e big data</a></li>
<li><a href="../pt466937/index.html">Como fazemos a Olimp√≠ada on-line totalmente russa em ingl√™s, matem√°tica e ci√™ncia da computa√ß√£o</a></li>
<li><a href="../pt466941/index.html">Por que o Windows l√™ um arquivo cem mil vezes para abrir um menu?</a></li>
<li><a href="../pt466949/index.html">Perspectivas para redes qu√¢nticas: quem se envolve nelas e por que</a></li>
<li><a href="../pt466955/index.html">Enigmas do curr√≠culo. Parte 3. O v√©u dos segredos removidos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>