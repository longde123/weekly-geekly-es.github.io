<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙍🏻 🤸🏽 ⛽️ Nous utilisons un commutateur sans fil 433 MHz pour contrôler le PC 🤥 🐓 🧝🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour Geektimes Habr. 

 Chez moi, plusieurs commutateurs sans fil à 433 MHz se sont accumulés à la maison, il est devenu intéressant de savoir s'il...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous utilisons un commutateur sans fil 433 MHz pour contrôler le PC</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414285/">  Bonjour <s>Geektimes</s> Habr. <br><br>  Chez moi, plusieurs commutateurs sans fil à 433 MHz se sont accumulés à la maison, il est devenu intéressant de savoir s'ils peuvent être utilisés pour n'importe quelle tâche, par exemple, pour contrôler un ordinateur ou pour intégrer une «maison intelligente» dans le système. <br><br>  Ces commutateurs sont pratiques pour leur faible coût et leur fonctionnement stable, ils ressemblent à ceci: <br><br><img src="https://habrastorage.org/webt/up/tt/p4/upttp4hzw_us_v2bb0kdliszify.jpeg"><br><br>  Comment cela fonctionne et ce qui peut être fait avec eux (les hussards se taisent :), détails sous la coupe. <a name="habracut"></a><br><br><h2>  Théorie </h2><br>  Je dois dire tout de suite comment fonctionne un tel interrupteur, je ne sais pas, bien que je suppose à ce sujet.  Vous devrez donc faire un peu de rétro-ingénierie. <br><br>  Tout d'abord, le signal doit être reçu, pour lequel nous utilisons le récepteur RTL-SDR déjà bien connu, souvent appelé simplement un «sifflet» pour les radio-amateurs.  Cet appareil, au prix de 10 $ seulement, vous permet de recevoir des signaux radio dans une plage d'environ 50 à 1250 MHz, pour nous ce dont nous avons besoin.  Le sujet est ancien, mais si quelqu'un ne l'a pas lu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lisez-le</a> . <br><br>  Nous prenons la première étape de l'analyse - nous examinons attentivement le commutateur.  Nous constatons qu'au dos du boîtier, il est écrit «Made in China» (qui aurait pensé?) Et, plus important encore, la fréquence 433 MHz est indiquée.  Vous pouvez maintenant connecter le récepteur SDR, démarrer SDR # et vous assurer que les données sont bien transmises. <br><br><img src="https://habrastorage.org/webt/qd/wd/hd/qdwdhdd9acsjgl1rp5cbobpb-qg.jpeg"><br><br>  La symétrie du signal sur le spectre suggère la présence d'une modulation AM.  À propos, un signal «étranger» plus faible est visible à droite - ils peuvent également être reçus et décodés, ils seront discutés plus en détail séparément.  Mais revenons au signal.  Nous l'enregistrons au format WAV habituel et appuyons sur les boutons de la télécommande - par exemple, j'ai appuyé sur les boutons ON et OFF sur le canal «1». <br><br>  Ouvrez le fichier son dans n'importe quel éditeur audio et utilisez un autre outil d'analyse professionnel, Paint, pour comparer les signaux.  Nous plaçons 2 signaux de différents boutons l'un au-dessus de l'autre pour voir la différence: <br><br><img src="https://habrastorage.org/webt/hy/s5/8c/hys58cp3y1f0dujky-3kzjxxb1y.png"><br><br>  Il est facile de voir que nous avons la séquence de bits habituelle, dont la différence est juste sur un bit, correspondant au bouton ON ou OFF.  Pendant que le bouton est enfoncé, l'interrupteur répète simplement cycliquement cette séquence sur l'air à une vitesse de 20 fois par seconde.  Bon marché et facile, même si une séquence est déformée pendant la transmission, l'autre sera acceptée. <br><br>  À partir de cela, en passant, une conclusion importante peut être tirée - les signaux de ces commutateurs (nous parlons de modèles bon marché) sont transmis «tels quels» sans aucune authentification, protection ou cryptage.  Un tel interrupteur ou une prise sans fil avec un tel interrupteur ne doit pas être utilisé pour certaines fonctions importantes, par exemple pour allumer des radiateurs puissants ou encore plus pour ouvrir la porte d'entrée ou le garage.  Ce n'est même pas une question de pirates (la chance que quelqu'un pirate ma maison sans fil, j'estime moins que la chance de tomber sur ma maison ISS), mais qu'un voisin peut accidentellement acheter le même commutateur, et les codes peuvent correspondre ( cependant sur l'interrupteur il y a un choix entre 4 canaux).  D'après mon expérience d'utilisation, 2-3 fois par an, le disjoncteur s'est déclenché «lui-même», soit un obstacle, soit un signal éloigné du même modèle a été réellement reçu. <br><br>  Bien sûr, cela ne s'applique pas aux systèmes plus complexes, tels que Lora ou Philips Hue, tout est correct avec le cryptage. <br><br>  Mais revenons à notre tâche.  Vous pouvez écrire un décodeur de tels signaux vous-même, mais heureusement, cela a déjà été fait avant nous, dans un projet appelé "rtl_433".  Le programme a été créé à l'origine pour Linux, la version Windows peut être téléchargée <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">à la</a> version Linux peut être téléchargée à partir de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> . <br><br>  Nous démarrons le programme à partir de la ligne de commande: "rtl_433.exe -F json" <br><br><img src="https://habrastorage.org/webt/op/en/qn/openqnlud5suc071yu4_ja_ro-a.png"><br><br>  Nous avons obtenu les données, il reste à écrire un programme pour leur traitement. <br><br><h2>  Raspberry pi </h2><br>  La première chose intéressante à considérer est le Raspberry Pi.  Pour installer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rtl_433</a> sur Raspbian, décompressez l' <a href="">archive</a> et exécutez les commandes suivantes. <br><br><pre><code class="bash hljs">sudo apt-get install libtool libusb-1.0.0-dev librtlsdr-dev rtl-sdr build-essential autoconf cmake pkg-config <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> rtl_433/ autoreconf --install ./configure make make install</code> </pre> <br>  La deuxième étape consiste à écrire un programme qui recevra ces données et, en fonction de celles-ci, à effectuer les actions nécessaires.  Le code Python est assez simple: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> __future__ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> print_function <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os, sys, io <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> subprocess print(<span class="hljs-string"><span class="hljs-string">"RTLSDR listening started"</span></span>) transmitter_name = <span class="hljs-string"><span class="hljs-string">"Waveman Switch Transmitter"</span></span> transmitter_channel = <span class="hljs-number"><span class="hljs-number">1</span></span> proc = subprocess.Popen([<span class="hljs-string"><span class="hljs-string">"rtl_433 -F json"</span></span>], stdout=subprocess.PIPE, shell=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: line = proc.stdout.readline().encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>,<span class="hljs-string"><span class="hljs-string">'ignore'</span></span>) proc.poll() data = json.loads(line) print(data) m,st,ch,btn= data[<span class="hljs-string"><span class="hljs-string">'model'</span></span>],data[<span class="hljs-string"><span class="hljs-string">'state'</span></span>],data[<span class="hljs-string"><span class="hljs-string">'channel'</span></span>],data[<span class="hljs-string"><span class="hljs-string">'button'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> m==transmitter_name <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ch==transmitter_channel <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> btn==<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> st==<span class="hljs-string"><span class="hljs-string">'on'</span></span>: print(<span class="hljs-string"><span class="hljs-string">"ON"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> m==transmitter_name <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ch==transmitter_channel <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> btn==<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> st==<span class="hljs-string"><span class="hljs-string">'off'</span></span>: print(<span class="hljs-string"><span class="hljs-string">"OFF"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyboardInterrupt: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">except</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> print(<span class="hljs-string"><span class="hljs-string">"RTLSDR listening done"</span></span>)</code> </pre> <br>  Pour exécuter le code, vous devez l'enregistrer dans un fichier (par exemple rtl_listen.py) et exécuter la commande "python rtl_listen.py". <br><br>  Comme vous pouvez le voir, le programme démarre le processus en utilisant subprocess.Popen et en lit les données.  Ensuite, tout est simple, le code est assez lisible et il ne sera pas difficile de faire des changements.  Dans cet exemple, lorsque le bouton «1» est enfoncé, le message print («ON») s'affiche, à la place, vous pouvez faire autre chose, par exemple, activer la broche GPIO, allumer le relais, envoyer des données au serveur, etc. Avant de l'utiliser, vous devrez le changer en même temps nom transmetteur_nom dans le nom du modèle de la console qui sera utilisé. <br><br>  Soit dit en passant, le récepteur RTL-SDR lui-même, par rapport au Raspberry Pi, ressemble à ceci: <br><br><img src="https://habrastorage.org/webt/ju/yp/eo/juypeoflpdtecvmhvtjpc4hrx2y.jpeg"><br><br><h2>  Windows </h2><br>  Malheureusement, sous Windows 10, le code ci-dessus ne fonctionnait pas.  Mais comme une recherche sur github l'a suggéré, la lecture asynchrone des données d'un flux distinct fonctionne.  Pourquoi, c'était trop paresseux pour le découvrir, je vais juste mettre le code de travail sous le spoiler. <br><br><div class="spoiler">  <b class="spoiler_title">Code source</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> __future__ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> print_function <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os, sys <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> subprocess <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> threading <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Queue <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsynchronousFileReader</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(threading.Thread)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Helper class to implement asynchronous reading def __init__(self, fd, queue): assert isinstance(queue, Queue.Queue) assert callable(fd.readline) threading.Thread.__init__(self) self._fd = fd self._queue = queue def run(self): # The body of the tread: read lines and put them on the queue. for line in iter(self._fd.readline, ''): self._queue.put(line) def eof(self): # Check whether there is no more content to expect return not self.is_alive() and self._queue.empty() def replace(string): while ' ' in string: string = string.replace(' ', ' ') return string def read_rtl_data(): process = subprocess.Popen(["rtl_433.exe", "-F", "json"], stdout=subprocess.PIPE, stderr=subprocess.PIPE) # Launch the asynchronous readers of stdout and stderr. stdout_queue = Queue.Queue() stdout_reader = AsynchronousFileReader(process.stdout, stdout_queue) stdout_reader.start() stderr_queue = Queue.Queue() stderr_reader = AsynchronousFileReader(process.stderr, stderr_queue) stderr_reader.start() transmitter_name = "Waveman Switch Transmitter" transmitter_channel = 1 # Check the queues if we received some output while not stdout_reader.eof() or not stderr_reader.eof(): # Show what we received from standard output. while not stdout_queue.empty(): line = stdout_queue.get() print("Line1:", repr(line)) data = json.loads(line) # print("Data:", repr(line)) m,st,ch,btn= data['model'],data['state'],data['channel'],data['button'] if m==transmitter_name and ch==transmitter_channel and btn==1 and st=='on': print("ON") elif m==transmitter_name and ch==transmitter_channel and btn==1 and st=='off': print("OFF") # Show what we received from standard error. while not stderr_queue.empty(): line = replace(stderr_queue.get()) print("Line2:", line) # Sleep a bit before asking the readers again. time.sleep(0.1) stdout_reader.join() stderr_reader.join() # Close subprocess' file descriptors. process.stdout.close() process.stderr.close() if __name__ == '__main__': print("RTLSDR listening started") read_rtl_data() print("RTLSDR listening done")</span></span></code> </pre><br></div></div><br>  Avec ce code, nous pouvons utiliser toutes les actions dans le gestionnaire, la logique est la même que dans le code du Raspberry Pi. <br><br>  <b>Exemple</b> : supposons que nous ayons un ordinateur dédié à un home cinéma et que nous voulions l'éteindre en appuyant sur le bouton de la télécommande.  Remplacez le code 'print ("OFF")' par <br><br><pre> <code class="python hljs"> os.system(<span class="hljs-string"><span class="hljs-string">'shutdown -s'</span></span>) sys.exit(<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Après quoi, l'ordinateur s'éteindra en appuyant sur le bouton approprié.  Bien sûr, en plus de «shutdown -s», vous pouvez utiliser n'importe quelle autre commande Windows, il suffit de considérer que les commandes seront envoyées à plusieurs reprises, tandis que le bouton de la télécommande est enfoncé, pour éviter une telle duplication, vous devez améliorer le code. <br><br><h2>  Conclusion </h2><br>  Comme vous pouvez le voir, tout est assez simple et il y a de la place pour l'expérimentation.  Enfin, un petit bonus pour ceux qui ont lu jusqu'ici.  À 433 MHz, il existe un grand nombre de périphériques différents que rtl_433 peut décoder, vous pouvez simplement laisser le programme fonctionner pendant plusieurs heures et voir ce qui «attrape».  Sous le spoiler, un exemple d'un tel journal, enregistré plus tôt: <br><br><div class="spoiler">  <b class="spoiler_title">Journal</b> <div class="spoiler_text"> <code>2018-01-10 21:15:17 : Prologue sensor : 5 : 15 <br> Channel: 1 <br> Battery: OK <br> Button: 0 <br> Temperature: 6.00 C <br> Humidity: 11 % <br> <br> 2018-01-10 21:15:28 : inFactory sensor <br> ID: 71 <br> Temperature: 6.67 °C <br> Humidity: 99 % <br> <br> 2018-01-10 21:16:07 : Toyota : TPMS : 61511475 : 60e5006b : CRC <br> <br> 2018-01-10 21:20:33 : Prologue sensor : 5 : 15 <br> Channel: 1 <br> Battery: OK <br> Button: 0 <br> Temperature: 6.00 C <br> Humidity: 11 % <br> : Waveman Switch Transmitter <br> id: A <br> channel: 2 <br> button: 1 <br> state: on <br> : Waveman Switch Transmitter <br> id: A <br> channel: 2 <br> button: 1 <br> state: on <br> : Waveman Switch Transmitter <br> id: A <br> channel: 2 <br> button: 1 <br> state: on <br> <br> 2018-01-10 21:21:21 : Akhan 100F14 remote keyless entry <br> ID (20bit): 0x41 <br> Data (4bit): 0x4 (Mute) <br> : Waveman Switch Transmitter <br> id: A <br> channel: 2 <br> button: 1 <br> state: off <br> <br> 2018-01-10 21:32:31 : Ford : TPMS : 00268b1f : a34a0e : CHECKSUM <br> 2018-01-10 21:32:32 : Ford : TPMS : 00268a5c : 9c440e : CHECKSUM <br> 2018-01-10 21:32:37 : Ford : TPMS : 016dbfce : 99430e : CHECKSUM <br> 2018-01-10 21:32:39 : Ford : TPMS : 002671a0 : 9c4a0e : CHECKSUM</code> <br> </div></div><br>  Il existe des données intéressantes, par exemple, la pression des pneus de la voiture d'un voisin (TPMS, système de surveillance de la pression des pneus), ou la température extérieure +6 du capteur de quelqu'un d'autre.  Cela permet par exemple d'afficher la température extérieure si les voisins ont accidentellement une station météo compatible avec ce protocole. <br><br>  Toutes les expériences réussies. <br><br>  <b>Avertissement</b> : De toute évidence, l'utilisation du SDR et du traitement numérique pour lire les signaux de modulation OOK est essentiellement un coup de feu sur des moineaux.  Peut-être que sur aliexpress, il existe des récepteurs standard pour 1-2 $ qui font la même chose, avec un coût inférieur et une consommation d'énergie inférieure.  Si quelqu'un connaît de tels modèles, écrivez dans les commentaires. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr414285/">https://habr.com/ru/post/fr414285/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr414273/index.html">Ce que vous devez savoir avant de développer un backtester pour une stratégie de trading: problèmes typiques, types de systèmes et leurs paramètres</a></li>
<li><a href="../fr414277/index.html">L'homme, son environnement et l'Internet des objets</a></li>
<li><a href="../fr414279/index.html">Vote des rapports lors de la huitième réunion de bricolage du groupe Mail.Ru (07.07.2018)</a></li>
<li><a href="../fr414281/index.html">Développement d'un compteur de vitesse de vélo basé sur un écran du Nokia 3310</a></li>
<li><a href="../fr414283/index.html">Comment distinguer la crypto-monnaie de la non-crypto-monnaie</a></li>
<li><a href="../fr414289/index.html">SpaceX a ouvert un poste d'ingénieur de fusée pour créer un BFR</a></li>
<li><a href="../fr414293/index.html">Le troisième ReactOS Hackfest annuel se tiendra du 14 au 21 août 2018 à Berlin</a></li>
<li><a href="../fr414295/index.html">«C'était possible»: des moyens inhabituels mais efficaces d'utiliser les technologies «audio»</a></li>
<li><a href="../fr414299/index.html">Upgrade roomba 780</a></li>
<li><a href="../fr414303/index.html">Le Royaume-Uni dépense 6 millions de livres sterling pour les scientifiques des données</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>