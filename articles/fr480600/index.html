<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧓🏻 🚺 🎾 Énumération plus rapide 👩🏽‍🌾 🐔 🔫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="tl; dr 
 github.com/QratorLabs/fastenum 


pip install fast-enum  
 Que sont les énumérations 
 (Si vous pensez le savoir, faites défiler la page jusq...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Énumération plus rapide</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/qrator/blog/480600/"><h4>  tl; dr </h4><br>  <a href="https://github.com/QratorLabs/fastenum">github.com/QratorLabs/fastenum</a> <br><pre><code class="bash hljs">pip install fast-enum</code> </pre> <br><h3>  Que sont les énumérations </h3><br>  (Si vous pensez le savoir, faites défiler la page jusqu'à la section «Enums dans la bibliothèque standard»). <br><br>  Imaginez que vous devez décrire un ensemble de tous les états possibles pour les entités de votre modèle de base de données.  Vous utiliserez probablement un tas de constantes définies comme des attributs au niveau du module: <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># /path/to/package/static.py: INITIAL = 0 PROCESSING = 1 PROCESSED = 2 DECLINED = 3 RETURNED = 4 ...</span></span></code> </pre> <br>  ... ou en tant qu'attributs de niveau classe définis dans leur propre classe: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyModelStates</span></span></span><span class="hljs-class">:</span></span> INITIAL = <span class="hljs-number"><span class="hljs-number">0</span></span> PROCESSING = <span class="hljs-number"><span class="hljs-number">1</span></span> PROCESSED = <span class="hljs-number"><span class="hljs-number">2</span></span> DECLINED = <span class="hljs-number"><span class="hljs-number">3</span></span> RETURNED = <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br>  Cela vous aide à vous référer à ces états par leurs noms mnémoniques, tandis qu'ils persistent dans votre stockage en tant que simples entiers.  Par cela, vous vous débarrassez des nombres magiques dispersés dans votre code et le rendez plus lisible et auto-descriptif. <br><br>  Mais, la constante au niveau du module et la classe avec les attributs statiques souffrent de la nature inhérente des objets python: ils sont tous mutables.  Vous pouvez accidentellement attribuer une valeur à votre constante au moment de l'exécution, et c'est un gâchis pour déboguer et restaurer vos entités cassées.  Ainsi, vous souhaiterez peut-être rendre votre ensemble de constantes immuable, ce qui signifie que le nombre de constantes déclarées et les valeurs auxquelles elles sont mappées ne doivent pas être modifiées au moment de l'exécution. <br><a name="habracut"></a><br>  Pour cela, vous pouvez essayer de les organiser en tuples nommés avec <code>namedtuple()</code> , par exemple: <br><pre> <code class="python hljs">MyModelStates = namedtuple(<span class="hljs-string"><span class="hljs-string">'MyModelStates'</span></span>, (<span class="hljs-string"><span class="hljs-string">'INITIAL'</span></span>, <span class="hljs-string"><span class="hljs-string">'PROCESSING'</span></span>, <span class="hljs-string"><span class="hljs-string">'PROCESSED'</span></span>, <span class="hljs-string"><span class="hljs-string">'DECLINED'</span></span>, <span class="hljs-string"><span class="hljs-string">'RETURNED'</span></span>)) EntityStates = MyModelStates(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>)</code> </pre> <br>  Cependant, cela ne semble toujours pas trop compréhensible: en plus de cela, les objets <code>namedtuple</code> ne sont pas vraiment extensibles.  Disons que vous avez une interface utilisateur qui affiche tous ces états.  Vous pouvez ensuite utiliser vos constantes basées sur un module, votre classe avec les attributs ou des tuples nommés pour les rendre (les deux derniers sont plus faciles à rendre pendant que nous y sommes).  Mais votre code ne fournit aucune possibilité de donner à l'utilisateur une description adéquate pour chaque état que vous avez défini.  De plus, si vous prévoyez d'implémenter la prise en charge multilingue et i18n dans votre interface utilisateur, vous constaterez que remplir toutes les traductions de ces descriptions devient une tâche incroyablement fastidieuse.  Les valeurs d'état correspondantes peuvent ne pas nécessairement avoir de descriptions correspondantes, ce qui signifie que vous ne pouvez pas simplement mapper tous vos états <code>INITIAL</code> sur la même description dans <code>gettext</code> .  Au lieu de cela, votre constante devient ceci: <br><pre> <code class="python hljs">INITIAL = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'My_MODEL_INITIAL_STATE'</span></span>)</code> </pre> <br>  Votre classe devient alors ceci: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyModelStates</span></span></span><span class="hljs-class">:</span></span> INITIAL = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'MY_MODEL_INITIAL_STATE'</span></span>)</code> </pre> <br>  Et enfin, votre <code>namedtuple</code> devient ceci: <br><pre> <code class="python hljs">EntityStates = MyModelStates((<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'MY_MODEL_INITIAL_STATE'</span></span>), ...)</code> </pre><br>  Eh bien, assez bien, il s'assure maintenant que la valeur de l'état et le talon de traduction sont mappés aux langues prises en charge par votre interface utilisateur.  Mais maintenant, vous remarquerez peut-être que le code qui utilise ces mappages est devenu un gâchis.  Chaque fois que vous essayez d'attribuer une valeur à votre entité, vous devez également ne pas oublier d'extraire la valeur à l'index 0 du mappage que vous utilisez: <br><br><pre> <code class="python hljs">my_entity.state = INITIAL[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre>  ou <pre> <code class="python hljs">my_entity.state = MyModelStates.INITIAL[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre>  ou <pre> <code class="python hljs">my_entity.state = EntityStates.INITIAL[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre> <br>  Et ainsi de suite.  Gardez à l'esprit que les deux premières approches utilisant des constantes et des attributs de classe, respectivement, souffrent toujours de mutabilité. <br><br><h4>  Et puis les énumérations arrivent sur scène </h4><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyEntityStates</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Enum)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, val, description)</span></span></span><span class="hljs-function">:</span></span> self.val = val self.description = description INITIAL = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'MY_MODEL_INITIAL_STATE'</span></span>) PROCESSING = (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'MY_MODEL_BEING_PROCESSED_STATE'</span></span>) PROCESSED = (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'MY_MODEL_PROCESSED_STATE'</span></span>) DECLINED = (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'MY_MODEL_DECLINED_STATE'</span></span>) RETURNED = (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'MY_MODEL_RETURNED_STATE'</span></span>)</code> </pre> <br>  Voilà.  Vous pouvez maintenant facilement parcourir l'énumération dans votre moteur de rendu (syntaxe Jinja2): <br><pre> <code class="python hljs">{% <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> MyEntityState %} &lt;option value=”{{ state.val }}”&gt;{{ _(state.description) }}&lt;/option&gt; {% endfor %}</code> </pre> <br>  L'énumération est immuable pour les deux ensembles de membres (vous ne pouvez pas définir un nouveau membre au moment de l'exécution, ni supprimer un membre déjà défini) et les valeurs de membre qu'ils conservent (vous ne pouvez pas réaffecter de valeurs d'attribut ou supprimer un attribut). <br><br>  Dans votre code, vous attribuez simplement des valeurs à vos entités comme ceci: <br><pre> <code class="python hljs">my_entity.state = MyEntityStates.INITIAL.val</code> </pre> <br>  Eh bien, assez clair.  Auto-descriptif.  Assez extensible.  C'est pour cela que nous utilisons Enums. <br><br><h3>  Pourquoi est-ce plus rapide? </h3><br>  Mais l'ENUM par défaut est plutôt lent, alors nous nous sommes demandé - pourrions-nous le rendre plus rapide? <br>  En fait, nous le pouvons.  A savoir, il est possible de le faire: <br><br><ul><li>  3 fois plus rapide sur l'accès des membres </li><li>  ~ 8,5 fois plus rapide sur l'accès aux attributs ( <code>name</code> , <code>value</code> ) </li><li>  3 fois plus rapide sur l'accès enum par valeur (appel sur la classe enum <code>MyEnum(value)</code> ) </li><li>  1,5 fois plus rapide sur l'accès enum par nom ( <code>MyEnum[name]</code> type <code>MyEnum[name]</code> ) </li></ul><br>  Les types et les objets sont dynamiques en Python.  Mais Python a les outils pour limiter la nature dynamique des objets.  Avec leur aide, on peut obtenir une amélioration significative des performances en utilisant <code>__slots__</code> ainsi qu'en évitant d'utiliser des descripteurs de données lorsque cela est possible sans croissance de complexité significative ou si vous pouvez bénéficier de la vitesse. <br><br><h4>  Machines à sous </h4><br>  Par exemple, on pourrait utiliser une déclaration de classe avec <code>__slots__</code> - dans ce cas, les instances de classe n'auraient qu'un ensemble restreint d'attributs: les attributs déclarés dans <code>__slots__</code> et tous les <code>__slots__</code> des classes parentes. <br><br><h4>  Descripteurs </h4><br>  Par défaut, l'interpréteur Python renvoie directement une valeur d'attribut d'un objet: <br><pre> <code class="python hljs">value = my_obj.attribute <span class="hljs-comment"><span class="hljs-comment"># this is a direct access to the attribute value by the pointer that the object holds for that attribute</span></span></code> </pre> <br>  Selon le modèle de données Python, si la valeur d'attribut d'un objet est elle-même un objet qui implémente le protocole de descripteur de données, cela signifie que lorsque vous essayez d'obtenir cette valeur, vous obtenez d'abord l'attribut en tant qu'objet, puis une méthode spéciale <code>__get__</code> est appelé sur cet attribut-objet en passant l'objet gardien lui-même comme argument: <br><pre> <code class="python hljs">obj_attribute = my_obj.attribute obj_attribute_value = obj_attribute.__get__(my_obj)</code> </pre> <br><h4>  Énumérations dans la bibliothèque standard </h4><br>  Au moins les attributs de <code>name</code> et de <code>value</code> de l'implémentation Enum standard sont déclarés en tant que <code>types.DynamicClassAttribute</code> .  Cela signifie que lorsque vous essayez d'obtenir le <code>name</code> (ou la <code>value</code> ) d'un membre, le flux est le suivant: <br><br><pre> <code class="python hljs">one_value = StdEnum.ONE.value <span class="hljs-comment"><span class="hljs-comment"># that is what you write in your code one_value_attribute = StdEnum.ONE.value one_value = one_value_attribute.__get__(StdEnum.ONE)</span></span></code> </pre> <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># and this is what really __get__ does (python 3.7 implementation): def __get__(self, instance, ownerclass=None): if instance is None: if self.__isabstractmethod__: return self raise AttributeError() elif self.fget is None: raise AttributeError("unreadable attribute") return self.fget(instance)</span></span></code> </pre> <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># since DynamicClassAttribute is a decorator on Enum methods `name` and `value` the final row of __get__() ends up with: @DynamicClassAttribute def name(self): """The name of the Enum member.""" return self._name_ @DynamicClassAttribute def value(self): """The value of the Enum member.""" return self._value_</span></span></code> </pre> <br>  Ainsi, le flux complet pourrait être représenté comme le pseudo-code suivant: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(enum_member, attrname)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># this is also a __dict__ lookup so hash + hashtable scan also occur return getattr(enum_member, f'_{attrnme}_') def get_name_value(enum_member): name_descriptor = get_descriptor(enum_member, 'name') if enum_member is None: if name_descriptor.__isabstractmethod__: return name_descriptor raise AttributeError() elif name_descriptor.fget is None: raise AttributeError("unreadable attribute") return get_func(enum_member, 'name')</span></span></code> </pre> <br>  Nous avons créé un script simple qui illustre la conclusion ci-dessus: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> enum <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Enum <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StdEnum</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Enum)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, value, description)</span></span></span><span class="hljs-function">:</span></span> self.v = value self.description = description A = <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'One'</span></span> B = <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'Two'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StdEnum.A.name <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pycallgraph <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PyCallGraph <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pycallgraph.output <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> GraphvizOutput graphviz = GraphvizOutput(output_file=<span class="hljs-string"><span class="hljs-string">'stdenum.png'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> PyCallGraph(output=graphviz): v = get_name()</code> </pre> <br>  Et après avoir exécuté le script, il a créé cette image pour nous: <br><img src="https://habrastorage.org/webt/op/ff/m7/opffm7k3v2rgako7xufgkgqtcek.png"><br><br>  Cela prouve que chaque fois que vous accédez au <code>name</code> et à la <code>value</code> attributs de stdlib enum, il appelle un descripteur.  Ce descripteur se termine à son tour par un appel à la propriété <code>def name(self)</code> de stdlib enum décorée avec le descripteur. <br><br>  Eh bien, vous pouvez comparer cela à notre FastEnum: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> fast_enum <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> FastEnum <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyNewEnum</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(metaclass=FastEnum)</span></span></span><span class="hljs-class">:</span></span> A = <span class="hljs-number"><span class="hljs-number">1</span></span> B = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MyNewEnum.A.name <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pycallgraph <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PyCallGraph <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pycallgraph.output <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> GraphvizOutput graphviz = GraphvizOutput(output_file=<span class="hljs-string"><span class="hljs-string">'fastenum.png'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> PyCallGraph(output=graphviz): v = get_name()</code> </pre> <br>  Qui sort cette image: <br><img src="https://habrastorage.org/webt/le/ck/td/lecktd3dtx71oi3dmlyax7qyogu.png"><br><br>  C'est ce qui se fait réellement dans l'implémentation Enum standard chaque fois que vous accédez aux attributs de <code>name</code> et de <code>value</code> de vos membres Enum.  Et c'est pourquoi notre implémentation est plus rapide. <br><br>  <b>L'implémentation de la classe Enum par la bibliothèque standard Python utilise des tonnes d'appels de protocole de descripteur.</b>  Lorsque nous avons essayé d'utiliser l'énumération standard dans nos projets, nous avons remarqué combien d'appels de protocole de descripteur pour les attributs de <code>name</code> et de <code>value</code> des membres <code>Enum</code> ont été invoqués.  Et parce que les énumérations étaient utilisées de manière excessive dans tout le code, les performances résultantes étaient médiocres. <br><br>  De plus, la classe d'énumération standard contient quelques attributs d'aide «protégés»: <br><ul><li>  <code>_member_names_</code> - une liste qui contient tous les noms des membres enum; </li><li>  <code>_member_map_</code> - un OrderedDict qui mappe le nom d'un membre enum au membre lui-même; </li><li>  <code>_value2member_map_</code> - un dictionnaire inversé qui mappe les valeurs des membres enum aux membres enum correspondants. </li></ul><br>  Les recherches de dictionnaire sont lentes car chacune mène à un calcul de hachage et à une recherche de table de hachage, ce qui rend ces structures de base non optimales pour la classe enum.  Même la récupération de membre elle-même (comme dans <code>StdEnum.MEMBER</code> ) est une recherche de dictionnaire. <br><br><h4>  Notre chemin </h4><br>  Lors du développement de notre implémentation Enum, nous avons gardé à l'esprit ces jolies énumérations en langage C et les magnifiques énumérations Java extensibles.  Les principales fonctionnalités que nous souhaitions dans notre implémentation: <br><br><ul><li>  un Enum doit être aussi statique que possible;  par «statique», nous voulons dire: si quelque chose pouvait être calculé une fois et au moment de la déclaration, il le devrait; </li><li>  une Enum ne peut pas être sous-classée (doit être une classe «finale») si une sous-classe définit de nouveaux membres enum - cela est vrai pour l'implémentation de bibliothèque standard, à l'exception que la sous-classe est interdite même si aucun nouveau membre n'est défini; </li><li>  un Enum devrait avoir de vastes possibilités d'extensions (attributs supplémentaires, méthodes, etc.). </li></ul><br>  La seule fois où nous utilisons des recherches de dictionnaire est dans une <code>value</code> mappage inversée vers un membre Enum.  Tous les autres calculs sont effectués une seule fois pendant la déclaration de classe (où les crochets de métaclasses sont utilisés pour personnaliser la création de type). <br>  Contrairement à l'implémentation de bibliothèque standard, nous traitons la première valeur après le signe <code>=</code> dans la déclaration de classe comme valeur membre: <br>  <code>A = 1, 'One'</code> dans la bibliothèque standard énumère le tuple entier <code>1, "One"</code> est traité comme une <code>value</code> <br>  <code>A: 'MyEnum' = 1, 'One'</code> dans notre implémentation, seul <code>1</code> est traité comme une <code>value</code> <br><br>  Une accélération supplémentaire est obtenue en utilisant <code>__slots__</code> chaque fois que possible.  Dans le modèle de données Python, les classes déclarées avec <code>__slots__</code> n'ont pas d'attribut <code>__dict__</code> qui contient des attributs d'instance (vous ne pouvez donc pas attribuer d'attribut non mentionné dans <code>__slots__</code> ).  De plus, les attributs définis dans <code>__slots__</code> accessibles avec des décalages constants au pointeur d'objet de niveau C.  Il s'agit d'un accès aux attributs à grande vitesse car il évite les calculs de hachage et les analyses de table de hachage. <br><br><h3>  Quels sont les avantages supplémentaires? </h3><br>  FastEnum n'est compatible avec aucune version de Python antérieure à 3.6, car il utilise de manière excessive le module de <code>typing</code> introduit dans Python 3.6;  On pourrait supposer que l'installation d'un module de <code>typing</code> rétroporté à partir de PyPI serait utile.  La réponse est non.  L'implémentation utilise PEP-484 pour certaines fonctions et méthodes et les arguments de type de valeur de retour, de sorte que toute version antérieure à Python 3.5 n'est pas prise en charge en raison d'une incompatibilité de syntaxe.  Mais là encore, la toute première ligne de code dans <code>__new__</code> de la métaclasse utilise la syntaxe PEP-526 pour les <code>__new__</code> de type variable.  Donc Python 3.5 ne fera pas non plus.  Il est possible de porter l'implémentation vers des versions plus anciennes, bien que nous, dans Qrator Labs, ayons tendance à utiliser l'indicateur de type chaque fois que cela est possible, car cela aide grandement à développer des projets complexes.  Et bon!  Vous ne voulez pas vous en tenir à n'importe quel python avant 3.6 car il n'y a pas d'incompatibilité en arrière avec votre code existant (en supposant que vous n'utilisez pas Python 2) bien que beaucoup de travail ait été fait en asyncio par rapport à 3.5. <br><br>  Cela, à son tour, rend inutiles les importations spéciales comme <code>auto</code> , contrairement à la bibliothèque standard.  Vous tapez-hint tous vos membres Enum avec votre nom de classe Enum, ne fournissant aucune valeur du tout - et la valeur serait générée automatiquement pour vous.  Bien que python 3.6 soit suffisant pour fonctionner avec FastEnum, soyez averti que l'ordre standard de garantie de déclaration du dictionnaire n'a été introduit que dans python 3.7.  Nous ne connaissons aucun appareil utile où l'ordre de valeur généré automatiquement est important (car nous supposons que la valeur générée elle-même n'est pas la valeur dont un programmeur se soucie).  Néanmoins, considérez-vous averti si vous restez avec python 3.6; <br><br>  Ceux qui ont besoin que leur énumération commence à 0 (zéro) au lieu de 1 par défaut peuvent le faire avec un attribut de déclaration d'énumération spécial <code>_ZERO_VALUED</code> , cet attribut est "effacé" de la classe Enum résultante; <br><br>  Il y a cependant quelques limitations: tous les noms de membres enum doivent être MAJUSCULÉS sinon ils ne seront pas récupérés par la métaclasse et ne seront pas traités comme des membres enum; <br><br>  Cependant, vous pouvez déclarer une classe de base pour vos énumérations (gardez à l'esprit que la classe de base peut utiliser la métaclasse enum elle-même, vous n'avez donc pas besoin de fournir de métaclasse à toutes les sous-classes): vous pouvez définir une logique commune (attributs et méthodes) dans ce mais ne peut pas définir de membres enum (de sorte que la classe ne sera pas "finalisée").  Vous pouvez ensuite sous-classer cette classe dans autant de déclarations d'énumération que vous le souhaitez et cela vous fournira toute la logique commune; <br><br>  Alias  Nous les expliquerons dans un sujet séparé (implémenté en 1.2.5) <br><br><h3>  Alias ​​et comment ils pourraient aider </h3><br>  Supposons que vous ayez du code qui utilise: <br><pre> <code class="python hljs">package_a.some_lib_enum.MyEnum</code> </pre> <br>  Et que MyEnum est déclaré comme ceci: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyEnum</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(metaclass=FastEnum)</span></span></span><span class="hljs-class">:</span></span> ONE: <span class="hljs-string"><span class="hljs-string">'MyEnum'</span></span> TWO: <span class="hljs-string"><span class="hljs-string">'MyEnum'</span></span></code> </pre> <br>  Maintenant, vous avez décidé de refactoriser et de déplacer votre énumération dans un autre package.  Vous créez quelque chose comme ceci: <br><pre> <code class="python hljs">package_b.some_lib_enum.MyMovedEnum</code> </pre> <br>  Où MyMovedEnum est déclaré comme ceci: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyMovedEnum</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(MyEnum)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre> <br>  Maintenant.  Vous êtes prêt à commencer l'étape de "dépréciation" pour tout le code qui utilise vos énumérations.  Vous détournez les utilisations directes de <code>MyEnum</code> pour utiliser <code>MyMovedEnum</code> (ce dernier a tous ses membres <code>MyEnum</code> dans <code>MyEnum</code> ).  Vous <code>MyEnum</code> dans vos documents de projet que <code>MyEnum</code> est obsolète et sera supprimé du code à un moment donné dans le futur.  Par exemple, dans la prochaine version.  Considérez que votre code enregistre vos objets avec des attributs enum en utilisant pickle.  À ce stade, vous utilisez <code>MyMovedEnum</code> dans votre code, mais en interne, tous vos membres enum sont toujours les instances <code>MyEnum</code> .  Votre prochaine étape serait d'échanger les déclarations de <code>MyEnum</code> et <code>MyMovedEnum</code> afin que <code>MyMovedEnum</code> ne soit plus une sous-classe de <code>MyEnum</code> et de déclarer tous ses membres lui-même;  <code>MyEnum</code> , d'autre part, ne déclarerait aucun membre mais deviendrait juste un alias (sous-classe) de <code>MyMovedEnum</code> . <br><br>  Et cela le conclut.  Au redémarrage de vos runtimes sur une étape de décapage, toutes vos valeurs d'énumération seront redirigées vers <code>MyMovedEnum</code> et seront reliées à cette nouvelle classe.  Au moment où vous êtes sûr que tous vos objets marinés ont été non (re) marinés avec cette structure d'organisation de classe, vous êtes libre de faire une nouvelle version, où précédemment marqué comme obsolète, votre <code>MyEnum</code> peut être déclaré obsolète et effacé de votre base de code. <br><br>  Nous vous encourageons à l'essayer!  <a href="https://github.com/QratorLabs/fastenum">github.com/QratorLabs/fastenum</a> , <a href="https://pypi.org/project/fast-enum/">pypi.org/project/fast-enum</a> .  Tous les crédits vont à l'auteur de <a href="https://habr.com/en/users/santjagocorkez/" class="user_link">FastEnum santjagocorkez</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr480600/">https://habr.com/ru/post/fr480600/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr480580/index.html">Donc, le système ne se déplace pas</a></li>
<li><a href="../fr480582/index.html">Security Week 51: vulnérabilités des processeurs iOS et Intel</a></li>
<li><a href="../fr480594/index.html">Avant et après: l'évolution visuelle des jeux vidéo célèbres</a></li>
<li><a href="../fr480596/index.html">Ce qui vous attend dans le système d'exploitation de réseau innovant ArubaOS-CX</a></li>
<li><a href="../fr480598/index.html">La base de toute programmation sur ... des puzzles</a></li>
<li><a href="../fr480606/index.html">Cinq autres idées sur la façon de mettre à niveau vos compétences en tant que développeur frontal (décembre 2019)</a></li>
<li><a href="../fr480608/index.html">Rust surpasse C ++ avec les résultats du jeu Benchmarks</a></li>
<li><a href="../fr480610/index.html">Vtables C ++. Partie 2 (héritage virtuel + code généré par le compilateur)</a></li>
<li><a href="../fr480612/index.html">Apportez ces modifications pour respecter les normes d'accessibilité de la conception Web.</a></li>
<li><a href="../fr480614/index.html">ENUM rapide</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>