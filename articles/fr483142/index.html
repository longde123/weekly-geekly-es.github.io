<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💮 🈵 🏒 Portage de Quake 3 sur Rust 🍲 👩🏾 🐳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Notre équipe Immunant aime Rust et travaille activement sur C2Rust, un cadre de migration qui prend en charge toute la routine de migration vers Rust....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Portage de Quake 3 sur Rust</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483142/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d2c/61d/a4f/d2c61da4f8dfcdfb39d9fbd7787070a4.png"></div><br>  Notre équipe Immunant aime Rust et travaille activement sur C2Rust, un cadre de migration qui prend en charge toute la routine de migration vers Rust.  Nous nous efforçons d'introduire automatiquement des améliorations de sécurité dans le code Rust converti et d'aider le programmeur à le faire lui-même lorsque le framework échoue.  Cependant, tout d'abord, nous devons créer un traducteur fiable qui permet aux utilisateurs de démarrer avec Rust.  Les tests sur les petits programmes CLI deviennent lentement obsolètes, nous avons donc décidé de transférer Quake 3. vers Rust. Après quelques jours, nous étions probablement les premiers à jouer à Quake3 sur Rust! <br><br><h2>  Préparation: Quake 3 sources </h2><br>  Après avoir étudié le code source du Quake 3 original et diverses fourches, nous nous sommes installés sur <a href="https://ioquake3.org/">ioquake3</a> .  Il s'agit d'un fork créé par la communauté de Quake 3, qui est toujours pris en charge et construit sur des plateformes modernes. <br><a name="habracut"></a><br>  Comme point de départ, nous avons décidé de nous assurer que nous pouvons assembler le projet dans sa forme originale: <br><br><pre><code class="bash hljs">$ make release</code> </pre> <br>  Lors de la construction d'ioquake3, plusieurs bibliothèques et fichiers exécutables sont créés: <br><br><pre> <code class="bash hljs">$ tree --prune -I missionpack -P <span class="hljs-string"><span class="hljs-string">"*.so|*x86_64"</span></span> . └── build └── debug-linux-x86_64 ├── baseq3 │ ├── cgamex86_64.so <span class="hljs-comment"><span class="hljs-comment"># client │ ├── qagamex86_64.so # game server │ └── uix86_64.so # ui ├── ioq3ded.x86_64 # dedicated server binary ├── ioquake3.x86_64 # main binary ├── renderer_opengl1_x86_64.so # opengl1 renderer └── renderer_opengl2_x86_64.so # opengl2 renderer</span></span></code> </pre> <br>  Parmi ces bibliothèques, l'interface utilisateur, les bibliothèques client et serveur peuvent être compilées soit en tant qu'assembly <a href="https://fabiensanglard.net/quake3/qvm.php">VM Quake</a> , soit en tant que bibliothèques partagées natives X86.  Dans notre projet, nous avons décidé d'utiliser des versions natives.  Traduire des machines virtuelles en Rust et utiliser des versions QVM serait beaucoup plus simple, mais nous voulions tester en profondeur C2Rust. <br><br>  Dans notre projet de transfert, nous nous sommes concentrés sur l'interface utilisateur, le jeu, le client, le moteur de rendu OpenGL1 et le principal exécutable.  Nous pourrions également traduire le moteur de rendu OpenGL2, mais nous avons décidé de l'ignorer car il utilise une quantité importante de <code>.glsl</code> shader <code>.glsl</code> , que le système de construction incorpore sous forme de littéraux de chaîne dans le code source C. Après la compilation, nous ajouterons la prise en charge des scripts de construction pour l'intégration Code GLSL en chaînes Rust, mais il n'y a toujours pas de bon moyen automatisé de transposer ces fichiers temporaires générés automatiquement.  Donc, à la place, nous venons de traduire la bibliothèque de rendu OpenGL1 et avons forcé le jeu à l'utiliser à la place du rendu par défaut.  De plus, nous avons décidé d'ignorer le serveur dédié et les fichiers de mission packagés, car ils ne seront pas difficiles à transférer et ils ne sont pas nécessaires pour notre démonstration. <br><br><h2>  Transposer le séisme 3 </h2><br>  Afin de conserver la structure de répertoires utilisée dans Quake 3 et de ne pas changer le code source, nous avions besoin d'obtenir exactement les mêmes fichiers binaires que dans l'assembly natif, c'est-à-dire quatre bibliothèques partagées et un exécutable. <br><br>  Étant donné que C2Rust crée les fichiers d'assemblage Cargo, chaque binaire nécessite sa propre caisse Rust avec le fichier <code>Cargo.toml</code> correspondant. <br><br>  Pour que C2Rust crée une caisse par fichier binaire de sortie, il aura également besoin d'une liste de fichiers binaires avec l'objet ou les fichiers source correspondants, ainsi qu'un appel de l'éditeur de liens utilisé pour créer chaque fichier binaire (utilisé pour déterminer d'autres détails, par exemple, les dépendances de bibliothèque). <br><br>  Cependant, nous avons rapidement rencontré une limitation causée par la façon dont C2Rust intercepte le processus de génération natif: C2Rust reçoit en entrée un fichier de <a href="https://sarcasm.github.io/notes/dev/compilation-database.html">base de données de compilation</a> qui contient une liste de commandes de compilation qui sont exécutées pendant la génération.  Cependant, cette base de données contient <strong>uniquement des</strong> commandes de compilation sans appels de l'éditeur de liens.  La plupart des outils créant cette base de données ont cette limitation intentionnelle, par exemple <code>cmake</code> avec <code>CMAKE_EXPORT_COMPILE_COMMANDS</code> , <code>bear</code> et <code>compiledb</code> .  D'après notre expérience, le seul outil qui inclut des commandes de <a href="https://github.com/Ericsson/codechecker/tree/master/analyzer/tools/build-logger"><code>build-logger</code></a> est le <a href="https://github.com/Ericsson/codechecker/tree/master/analyzer/tools/build-logger"><code>build-logger</code></a> créé par <code>CodeChecker</code> , que nous n'avons pas utilisé car nous ne l'avons appris qu'après avoir écrit nos propres wrappers (ils sont décrits ci-dessous).  Cela signifiait que pour compiler un programme C avec plusieurs fichiers binaires, nous ne pouvions pas utiliser le fichier <code>compile_commands.json</code> créé par l'un des outils courants. <br><br>  Par conséquent, nous avons écrit nos propres scripts de wrapper de <a href="https://github.com/immunant/c2rust/blob/master/scripts/cc-wrappers/cc">compilateur</a> et de <a href="https://github.com/immunant/c2rust/blob/master/scripts/cc-wrappers/ld">lieur</a> qui transfèrent tous les appels vers le compilateur et le lieur vers la base de données, puis les convertissons en <code>compile_commands.json</code> étendu.  Au lieu de l'assemblage habituel, utilisez une commande comme: <br><br><pre> <code class="bash hljs">$ make release</code> </pre> <br>  nous avons ajouté des wrappers pour intercepter l'assembly avec: <br><br><pre> <code class="bash hljs">$ make release CC=/path/to/C2Rust/scripts/cc-wrappers/cc</code> </pre> <br>  Les wrappers créent un répertoire de plusieurs fichiers JSON, un par appel.  Le deuxième <a href="https://github.com/immunant/c2rust/blob/master/scripts/convert_build_commands.py">script les</a> collecte tous dans un nouveau fichier <code>compile_commands.json</code> , qui contient à la fois les commandes de compilation et de compilation.  Ensuite, nous avons étendu C2Rust pour qu'il lise les commandes de construction de la base de données et crée une caisse séparée pour chaque binaire lié.  De plus, C2Rust lit désormais les dépendances de bibliothèque pour chaque fichier binaire et les ajoute automatiquement au fichier <code>build.rs</code> de la caisse correspondante. <br><br>  Pour améliorer la commodité, tous les fichiers binaires peuvent être collectés à la fois en les plaçant dans l' <a href="https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html">espace de travail</a> .  C2Rust crée le fichier d'espace de travail de niveau supérieur <code>Cargo.toml</code> , afin que nous puissions créer le projet avec la seule <code>cargo build</code> dans le <code>quake3-rs</code> : <br><br><pre> <code class="bash hljs">$ tree -L 1 . ├── Cargo.lock ├── Cargo.toml ├── cgamex86_64 ├── ioquake3 ├── qagamex86_64 ├── renderer_opengl1_x86_64 ├── rust-toolchain └── uix86_64 $ cargo build --release</code> </pre> <br><h2>  Élimine la rugosité </h2><br>  Lorsque nous avons essayé de compiler le code traduit pour la première fois, nous avons rencontré quelques problèmes avec les sources de Quake 3: il y avait des cas limites que C2Rust ne pouvait pas gérer (ni correctement, ni du tout en quelque sorte). <br><br><h3>  Pointeurs de tableau </h3><br>  Plusieurs emplacements dans le code source d'origine contiennent des expressions qui pointent vers l'élément suivant après le dernier élément du tableau.  Voici un exemple de code C simplifié: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *p; <span class="hljs-comment"><span class="hljs-comment">// ... if (p &gt;= &amp;array[1024]) { // error... }</span></span></code> </pre> <br>  La norme C (voir, par exemple, <a href="http://www.iso-9899.info/n1570.html">C11, Section 6.5.6</a> ) permet aux pointeurs vers un élément d'aller au-delà de la fin d'un tableau.  Cependant, Rust l'interdit, même si nous ne prenons que l'adresse de l'élément.  Nous avons trouvé des exemples d'un tel modèle dans la fonction <a href=""><code>AAS_TraceClientBBox</code></a> . <br><br>  Le compilateur Rust a également signalé un exemple similaire, mais en fait <a href=""><code>G_TryPushingEntity</code></a> dans <a href=""><code>G_TryPushingEntity</code></a> , où l'instruction conditionnelle est de la forme <code>&gt;</code> , pas <code>&gt;=</code> .  Un pointeur qui sort des limites est ensuite déréférencé après la construction conditionnelle, qui est un bogue de sécurité de la mémoire. <br><br>  Pour éviter ce problème à l'avenir, nous avons corrigé le transpileur C2Rust afin qu'il utilise l'arithmétique du pointeur pour calculer l'adresse d'un élément de tableau, plutôt que d'utiliser l'opération d'indexation du tableau.  Grâce à ce correctif, le code qui utilise le modèle similaire «adresse d'élément à la fin du tableau» est maintenant correctement traduit et exécuté sans modifications. <br><br><h3>  Éléments de tableau à longueur variable </h3><br>  Nous avons lancé le jeu pour tout tester et avons immédiatement eu la panique de Rust: <br><br><pre> <code class="cpp hljs">thread <span class="hljs-string"><span class="hljs-string">'main'</span></span> panicked at <span class="hljs-string"><span class="hljs-string">'index out of bounds: the len is 4 but the index is 4'</span></span>, quake3-client/src/cm_polylib.rs:<span class="hljs-number"><span class="hljs-number">973</span></span>:<span class="hljs-number"><span class="hljs-number">17</span></span></code> </pre> <br>  En <code>cm_polylib.c</code> un œil à <code>cm_polylib.c</code> , nous avons remarqué qu'il déréférence le champ <code>p</code> dans la structure suivante: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numpoints; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> p[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// variable sized } winding_t;</span></span></code> </pre> <br>  Le champ <code>p</code> dans la structure est une version du membre du tableau flexible qui n'est pas prise en charge par la norme C99, mais qui est toujours acceptée par <code>gcc</code> .  C2Rust reconnaît les éléments des tableaux de longueur variable avec la syntaxe C99 ( <code>vec3_t p[]</code> ) et implémente une <a href="">heuristique</a> simple pour identifier également les versions de ce modèle avant C99 (tableaux de tailles 0 et 1 à la fin des structures; nous avons également trouvé plusieurs exemples de ce type dans le code source ioquake3). <br><br>  <a href="https://github.com/immunant/ioq3/commit/ace1fae43e736613544c8d33cc69dee794f5124a">Changer</a> la structure ci-dessus en syntaxe C99 a éliminé la panique: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numpoints; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> p[]; <span class="hljs-comment"><span class="hljs-comment">// variable sized } winding_t;</span></span></code> </pre> <br>  Une tentative de corriger automatiquement ce modèle dans le cas général (avec des tailles de tableau différentes de 0 et 1) sera extrêmement difficile, car nous devrons faire la distinction entre les tableaux ordinaires et les éléments de tableaux de longueur variable de tailles arbitraires.  Par conséquent, nous vous recommandons plutôt de corriger manuellement le code C d'origine, comme nous l'avons fait avec ioquake3. <br><br><h3>  Opérandes liés dans le code assembleur en ligne </h3><br>  Une autre source de plantages était ce code assembleur C-assembler de l'en-tête système <code>/usr/include/bits/select.h</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta"># </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __FD_ZERO(fdsp) \ do { \ int __d0, __d1; \ __asm__ __volatile__ (</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cld; rep; "</span></span></span><span class="hljs-meta"> __FD_ZERO_STOS \ : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=c"</span></span></span><span class="hljs-meta"> (__d0), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=D"</span></span></span><span class="hljs-meta"> (__d1) \ : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"a"</span></span></span><span class="hljs-meta"> (0), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"0"</span></span></span><span class="hljs-meta"> (sizeof (fd_set) \ / sizeof (__fd_mask)), \ </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"1"</span></span></span><span class="hljs-meta"> (&amp;__FDS_BITS (fdsp)[0]) \ : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"memory"</span></span></span><span class="hljs-meta">); \ } while (0)</span></span></code> </pre> <br>  définir la version interne de la macro <code>__FD_ZERO</code> .  Cette définition soulève un cas limite rare d' <a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html">E / S d'opérandes liés</a> <code>gcc</code> : avec différentes tailles.  L'opérateur de sortie <code>"=D" (__d1)</code> lie le registre <code>edi</code> à la variable <code>__d1</code> tant que valeur 32 bits et <code>"1" (&amp;__FDS_BITS (fdsp)[0])</code> lie le même registre à l'adresse <code>fdsp-&gt;fds_bits</code> tant que pointeur 64 bits.  <code>gcc</code> et <code>clang</code> résolvent ce décalage.  en utilisant le registre <code>rdi</code> 64 bits et en tronquant sa valeur avant d'affecter la valeur <code>__d1</code> , et Rust utilise la sémantique LLVM par défaut, dans laquelle un tel cas reste indéfini.  Dans les versions de débogage (pas dans les versions de version, qui se comportaient bien), nous avons vu que les deux opérandes peuvent être affectés au registre <code>edi</code> , à cause de quoi le pointeur est tronqué à 32 bits avant le code assembleur intégré, ce qui provoque des échecs. <br><br>  Étant donné que <code>rustc</code> transmet le code assembleur Rust intégré à LLVM avec très peu de modifications, nous avons décidé de corriger ce cas particulier dans C2Rust.  Nous avons implémenté une nouvelle caisse <a href="https://github.com/immunant/c2rust/tree/master/c2rust-asm-casts"><code>c2rust-asm-casts</code></a> qui <a href="https://github.com/immunant/c2rust/tree/master/c2rust-asm-casts"><code>c2rust-asm-casts</code></a> ce problème grâce au système de type Rust utilisant des fonctions de <a href="">trait</a> et d'assistance qui développent et tronquent automatiquement les opérandes liés à une taille interne suffisamment grande pour contenir les deux opérandes.  Le code ci-dessus se traduit correctement comme suit: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> __d0: c_int = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> __d1: c_int = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Reference to the output value of the first operand let fresh5 = &amp;mut __d0; // The internal storage for the first tied operand let fresh6; // Reference to the output value of the second operand let fresh7 = &amp;mut __d1; // The internal storage for the second tied operand let fresh8; // Input value of the first operand let fresh9 = (::std::mem::size_of::&lt;fd_set&gt;() as c_ulong).wrapping_div(::std::mem::size_of::&lt;__fd_mask&gt;() as c_ulong); // Input value of the second operand let fresh10 = &amp;mut *fdset.__fds_bits.as_mut_ptr().offset(0) as *mut __fd_mask; asm!("cld; rep; stosq" : "={cx}" (fresh6), "={di}" (fresh8) : "{ax}" (0), // Cast the input operands into the internal storage type // with optional zero- or sign-extension "0" (AsmCast::cast_in(fresh5, fresh9)), "1" (AsmCast::cast_in(fresh7, fresh10)) : "memory" : "volatile"); // Cast the operands out (types are inferred) with truncation AsmCast::cast_out(fresh5, fresh9, fresh6); AsmCast::cast_out(fresh7, fresh10, fresh8);</span></span></code> </pre> <br>  Il convient de noter que ce code ne nécessite aucun type pour les valeurs d'entrée et de sortie dans l'assembly du code assembleur; lors de la résolution des conflits de types, comptez plutôt sur eux pour générer les types Rust (principalement les types <code>fresh6</code> et <code>fresh8</code> ). <br><br><h3>  Variables globales alignées </h3><br>  La dernière source de l'échec était la variable globale suivante stockant la constante SSE: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ssemask[<span class="hljs-number"><span class="hljs-number">16</span></span>] __attribute__((aligned(<span class="hljs-number"><span class="hljs-number">16</span></span>))) = { <span class="hljs-string"><span class="hljs-string">"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x00\x00\x00\x00"</span></span> };</code> </pre> <br>  Rust prend actuellement en charge l'attribut d'alignement pour les types de structure, mais pas pour les variables globales, c'est-à-dire  éléments <code>static</code> .  Nous avons envisagé des moyens de résoudre ce problème dans le cas général, soit dans Rust soit dans C2Rust, mais pour l'instant dans ioquake3, nous avons décidé de le corriger manuellement avec un court fichier de <a href="https://github.com/immunant/ioq3/blob/master/asm-snapvector.patch">patch</a> .  Ce fichier correctif remplace l'équivalent <code>ssemask</code> Rust <code>ssemask</code> suit: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[repr(C, align(16))]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SseMask</span></span></span></span>([<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>; <span class="hljs-number"><span class="hljs-number">16</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> ssemask: SseMask = SseMask([ <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, ]);</code> </pre> <br><h2>  Exécution de quake3-rs </h2><br>  Lorsque <code>cargo build --release</code> , des fichiers binaires sont créés, mais ils sont créés sous <code>target/release</code> avec une structure de répertoires que le binaire <code>ioquake3</code> ne reconnaît pas.  Nous avons écrit un <a href="">script</a> qui crée des liens symboliques dans le répertoire courant pour recréer la structure de répertoire correcte (y compris des liens vers des fichiers <code>.pk3</code> contenant des ressources de jeu): <br><br><pre> <code class="bash hljs">$ /path/to/make_quake3_rs_links.sh /path/to/quake3-rs/target/release /path/to/paks</code> </pre> <br>  Le chemin <code>/path/to/paks</code> doit pointer vers le répertoire contenant les fichiers <code>.pk3</code> . <br><br>  Lançons maintenant le jeu!  Nous devons passer <code>+set vm_game 0</code> , etc., nous chargeons donc ces modules en tant que bibliothèques partagées Rust, et non en tant qu'assemblage QVM, ainsi que <code>cl_renderer</code> pour utiliser le moteur de rendu OpenGL1. <br><br><pre> <code class="bash hljs">$ ./ioquake3 +<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> sv_pure 0 +<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> vm_game 0 +<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> vm_cgame 0 +<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> vm_ui 0 +<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> cl_renderer <span class="hljs-string"><span class="hljs-string">"opengl1"</span></span></code> </pre> <br>  Et ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/18e/fb3/94c/18efb394c9f33f6a1cbe78503a25bb4c.png"></div><br>  Nous avons lancé Quake3 sur Rust! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d2c/61d/a4f/d2c61da4f8dfcdfb39d9fbd7787070a4.png"></div><br>  Voici une vidéo de la façon dont nous transposons Quake 3, téléchargeons le jeu et jouons-en un peu: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/lQjvSJLDXW4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Vous pouvez étudier les <a href="https://github.com/immunant/ioq3/tree/transpiled/quake3-rs">sources transpilées</a> dans la branche <code>transpiled</code> de notre référentiel.  Il existe également une branche <code>refactored</code> contenant les mêmes <a href="https://github.com/immunant/ioq3/tree/refactored/quake3-rs">sources</a> avec plusieurs <a href="https://github.com/immunant/ioq3/blob/transpiled/refactor_commands.txt">commandes de refactorisation</a> pré-appliquées. <br><br><h2>  Comment transposer </h2><br>  Si vous voulez essayer de transposer Quake 3 et l'exécuter vous-même, notez que vous aurez besoin de vos propres ressources de jeu Quake 3 ou ressources de démonstration sur Internet.  Vous devrez également installer C2Rust (au moment de la rédaction, la version nocturne requise est <code>nightly-2019-12-05</code> , mais nous vous recommandons de consulter <a href="https://github.com/immunant/c2rust">le référentiel</a> C2Rust ou dans <a href="https://crates.io/crates/c2rust">crates.io</a> pour trouver la dernière version): <br><br><pre> <code class="bash hljs">$ cargo +nightly-2019-12-05 install c2rust</code> </pre> <br>  et des copies de nos référentiels C2Rust et ioquake3: <br><br><pre> <code class="bash hljs">$ git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> &lt;a href=<span class="hljs-string"><span class="hljs-string">"/cdn-cgi/l/email-protection"</span></span> class=<span class="hljs-string"><span class="hljs-string">"__cf_email__"</span></span> data-cfemail=<span class="hljs-string"><span class="hljs-string">"dcbbb5a89cbbb5a8b4a9bef2bfb3b1"</span></span>&gt;[email protected]&lt;/a&gt;:immunant/c2rust.git $ git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> &lt;a href=<span class="hljs-string"><span class="hljs-string">"/cdn-cgi/l/email-protection"</span></span> class=<span class="hljs-string"><span class="hljs-string">"__cf_email__"</span></span> data-cfemail=<span class="hljs-string"><span class="hljs-string">"dcbbb5a89cbbb5a8b4a9bef2bfb3b1"</span></span>&gt;[email protected]&lt;/a&gt;:immunant/ioq3.git</code> </pre> <br>  Au lieu d'installer <code>c2rust</code> à l'aide de la commande ci-dessus, vous pouvez créer C2Rust manuellement à l'aide de <code>cargo build --release</code> .  Dans tous les cas, le référentiel C2Rust sera toujours nécessaire, car il contient les scripts d'encapsulation du compilateur nécessaires pour transposer ioquake3. <br><br>  Nous avons publié un <a href="">script</a> qui transporte automatiquement le code C et applique le correctif <code>ssemask</code> .  Pour l'utiliser, exécutez la commande suivante à partir du niveau supérieur du référentiel <code>ioq3</code> : <br><br><pre> <code class="bash hljs">$ ./transpile.sh &lt;/path/to/C2Rust repository&gt; &lt;/path/to/c2rust binary&gt;</code> </pre> <br>  Cette commande doit créer un sous <code>quake3-rs</code> répertoire <code>quake3-rs</code> contenant du code Rust, pour lequel vous pouvez ensuite exécuter la <code>cargo build --release</code> et les étapes restantes décrites ci-dessus. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr483142/">https://habr.com/ru/post/fr483142/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr483130/index.html">Que faire si le code de la serrure de la valise est oublié?</a></li>
<li><a href="../fr483132/index.html">Conception et fabrication d'un télescope</a></li>
<li><a href="../fr483134/index.html">Test d'authentification à deux facteurs et solutions de contournement possibles</a></li>
<li><a href="../fr483136/index.html">Vérification du MacBook utilisé avant l'achat - liste de contrôle</a></li>
<li><a href="../fr483140/index.html">Des polygones dans un autre monde: l'Amiga 500</a></li>
<li><a href="../fr483144/index.html">Le scientifique He Jiankui est un héros, pas un criminel</a></li>
<li><a href="../fr483146/index.html">Conférence DEFCON 27. Outil de piratage WiFi sans fil Kraken</a></li>
<li><a href="../fr483148/index.html">Nous discutons de jumeaux numériques et de simulation avec le fondateur d'une société de conseil</a></li>
<li><a href="../fr483154/index.html">J'ai dépensé 40 000 $ et j'ai ruiné une excellente idée pour une startup</a></li>
<li><a href="../fr483156/index.html">Mettez le chat sur ses pieds</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>