<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚴🏻 🌿 👨🏾‍🏭 Cours MIT "Sécurité des systèmes informatiques". Conférence 3: Buffer Overflows: Exploits and Protection, Part 2 🕶️ 🧑🏿‍🤝‍🧑🏻 👨🏾‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Institut de technologie du Massachusetts. Cours magistral # 6.858. "Sécurité des systèmes informatiques." Nikolai Zeldovich, James Mickens. 2014 année...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cours MIT "Sécurité des systèmes informatiques". Conférence 3: Buffer Overflows: Exploits and Protection, Part 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/418093/"><h3>  Institut de technologie du Massachusetts.  Cours magistral # 6.858.  "Sécurité des systèmes informatiques."  Nikolai Zeldovich, James Mickens.  2014 année </h3><br>  Computer Systems Security est un cours sur le développement et la mise en œuvre de systèmes informatiques sécurisés.  Les conférences couvrent les modèles de menace, les attaques qui compromettent la sécurité et les techniques de sécurité basées sur des travaux scientifiques récents.  Les sujets incluent la sécurité du système d'exploitation (OS), les fonctionnalités, la gestion du flux d'informations, la sécurité des langues, les protocoles réseau, la sécurité matérielle et la sécurité des applications Web. <br><br>  Cours 1: «Introduction: modèles de menace» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3</a> <br>  Conférence 2: «Contrôle des attaques de pirates» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3</a> <br>  Conférence 3: «Débordements de tampon: exploits et protection» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3</a> <a name="habracut"></a><br><br>  Fait intéressant, un attaquant ne peut pas accéder à une adresse spécifique, malgré le fait que nous utilisons principalement des adresses codées en dur.  Ce qu'il fait s'appelle une «attaque en tas», et si vous êtes une mauvaise personne, ce sera assez amusant pour vous.  Avec une telle attaque, un pirate commence à allouer dynamiquement des tonnes de code shell et à le saisir simplement au hasard dans la mémoire.  Cela est particulièrement efficace si vous utilisez des langages dynamiques de haut niveau tels que JavaScript.  Ainsi, le lecteur de balises est dans une boucle étroite et génère simplement un grand nombre de lignes de code shell, puis en remplit un tas. <br><br>  L'attaquant ne peut pas déterminer l'emplacement exact des lignes, il sélectionne simplement 10 Mo de lignes de code shell et effectue un saut arbitraire.  Et s'il peut en quelque sorte contrôler l'un des pointeurs <b>ret</b> , il y a une chance qu'il "atterrisse" dans le code shell. <br><br><img src="https://habrastorage.org/webt/jl/7-/8x/jl7-8xckq3eq6z_wf2_m2alslzg.jpeg"><br><br>  Vous pouvez utiliser une astuce appelée <b>diapositive</b> <b>NOP, traîneau NOP</b> ou <b>rampe NOP</b> , où <b>NOP</b> correspond <b>à des instructions de non-opération</b> ou à des commandes vides et inactives.  Cela signifie que le flux d'exécution des commandes du processeur «glisse» vers sa destination finale souhaitée chaque fois que le programme se rend à l'adresse mémoire n'importe où sur la diapositive. <br><br>  Imaginez que si vous avez une ligne de code shell et que vous allez à un endroit aléatoire sur cette ligne, cela peut ne pas fonctionner, car cela ne vous permet pas de déployer l'attaque de la bonne manière. <br><br>  Mais peut-être que les choses que vous mettez dans le tas ne sont fondamentalement qu'une tonne de <b>NOP</b> , et à la toute fin, vous avez du code shell.  C'est en fait assez intelligent, car cela signifie que vous pouvez maintenant vous rendre au bon endroit où vous sautez.  Parce que si vous sautez dans l'un de ces <b>NOP</b> , cela se produit simplement «boum, boum, boum, boum, boum, boum, boum», puis vous entrez dans le code shell. <br><br>  Il semble que les gens viennent avec ça, ce que vous voyez probablement dans notre équipe.  Ils inventent quelque chose comme ça, et c'est le problème.  C'est donc une autre façon de contourner certaines choses aléatoires en rendant simplement robuste la randomisation de vos codes, si cela a du sens. <br><br>  Nous avons donc discuté de certains types d'aléatoire que vous pouvez utiliser.  Il y a des idées stupides qui ont également surgi chez les gens.  Alors maintenant, vous savez que lorsque vous souhaitez effectuer un appel système, par exemple, en utilisant la fonction <b>syscall libc</b> , vous passez essentiellement un numéro unique qui représente l'appel système que vous souhaitez effectuer.  Alors peut-être que la fonction <b>fork</b> est 7, <b>sleep</b> est 8, ou quelque chose comme ça. <br><br>  Cela signifie que si un attaquant peut trouver l'adresse de cette instruction <b>syscall</b> et y accéder d'une manière ou d'une autre, il ou elle peut en fait simplement remplacer le numéro d'appel système qu'il souhaite utiliser directement.  Vous pouvez imaginer que chaque fois que le programme s'exécute, vous créez en fait une affectation dynamique des numéros d' <b>appel système à des</b> <b>appels système</b> valides, afin de compliquer la capture de l'attaquant. <br><br><img src="https://habrastorage.org/webt/nq/l6/ob/nql6obzl82-6vvdgdkt6iuhzs8g.jpeg"><br><br>  Il y a même des suggestions avant-gardistes pour changer le matériel afin que l'équipement contienne la clé de cryptage <b>xor</b> , qui est utilisée pour les fonctions dynamiques <b>xor</b> .  Imaginez que chaque fois que vous compilez un programme, tous les codes d'instructions obtiennent une certaine clé <b>xor</b> .  Cette clé est stockée dans le registre de l'équipement lorsque vous téléchargez initialement le programme, et ensuite, chaque fois que vous exécutez l'instruction, l'équipement effectue automatiquement une ou plusieurs opérations avec elle avant de poursuivre avec cette instruction.  La bonne chose à propos de cette approche est que maintenant, même si un attaquant peut générer du code shell, il ne reconnaîtra pas cette clé.  Il lui sera donc très difficile de comprendre ce qui doit être exactement mis en mémoire. <br><br>  <b>Public:</b> mais s'il peut obtenir le code, il peut également utiliser <b>xor</b> pour <b>reconvertir</b> le code en instruction. <br><br>  <b>Professeur:</b> oui, c'est le problème canonique, non.  Ceci est quelque peu similaire à ce qui se passe lors des attaques <b>BROP</b> , lorsque nous semblons randomiser l'emplacement du code, mais l'attaquant peut le "sentir" et découvrir ce qui se passe.  On peut imaginer que, par exemple, si un attaquant connaît une sous-séquence de code qu'il s'attend à trouver dans un fichier binaire, il tentera d'utiliser l'opération <b>xor</b> pour ce fichier afin d'extraire la clé. <br><br>  Essentiellement, nous avons discuté de toutes sortes d'attaques de randomisation dont je voulais vous parler aujourd'hui.  Avant de passer à la programmation, il convient de discuter des méthodes de protection utilisées dans la pratique.  Il s'avère que <b>GCC</b> et Visual Studio incluent l'approche par <b>défaut des canaris de pile</b> .  Il s'agit d'une communauté très populaire et très célèbre.  Si vous regardez Linux et Windows, ils profitent également de choses comme la mémoire non exécutable et la randomisation de l'espace d'adressage.  Certes, le système <b>baggy bounds</b> n'est pas si populaire auprès d'eux, probablement en raison du coût de la mémoire, du processeur, des fausses alarmes, etc., dont nous avons déjà parlé.  Donc, fondamentalement, nous avons examiné comment les choses vont empêcher le problème de dépassement de tampon. <br><br>  Nous allons maintenant parler de <b>ROP</b> , programmation orientée inverse.  Aujourd'hui, je vous ai déjà dit ce que cela représente en termes de randomisation de l'espace d'adressage et d'empêcher l'exécution des données - c'est la lecture, l'écriture et l'exécution.  Ce sont en fait des choses très puissantes.  Parce que la randomisation empêche la possibilité pour un attaquant de comprendre où se trouvent nos adresses codées en dur.  Et la possibilité d'empêcher l'exécution de données garantit que même si vous placez le code shell sur la pile, un attaquant ne peut pas simplement y accéder et l'exécuter. <br><br>  Tout cela semble assez progressif, mais les pirates développent constamment des méthodes d'attaque contre de telles solutions de défense progressives. <br><br>  Alors, quelle est l'essence de la programmation inversée? <br><br>  Et si, au lieu de simplement créer du nouveau code lors d'une attaque, un attaquant pouvait combiner les morceaux de code existants puis les combiner de manière anormale?  Après tout, nous savons que le programme contient des tonnes de ce code. <br><br><img src="https://habrastorage.org/webt/fd/76/08/fd7608uferkfub0zyknpa6w1vfk.jpeg"><br><br>  Donc, heureusement ou malheureusement, tout dépend de quel côté vous êtes.  Si vous pouvez trouver des extraits de code intéressants et les combiner ensemble, vous pouvez obtenir quelque chose comme le langage <b>Turing</b> , où l'attaquant peut essentiellement faire ce qu'il veut. <br><br>  Regardons un exemple très simple qui vous semblera familier au début, mais qui se transformera rapidement en quelque chose de fou. <br><br>  Disons que nous avons le programme suivant.  Donc, ayons une sorte de fonction et, ce qui est pratique pour l'attaquant, voici cette belle <b>fonction shell run</b> .  Donc, ce n'est qu'un appel au système, il exécutera la commande <b>bin / bash</b> et cela se terminera.  Ensuite, nous avons un processus de débordement de tampon canonique ou, désolé, une fonction qui annoncera la création d'un tampon, puis utilisera l'une de ces fonctions dangereuses pour remplir le tampon d'octets. <br><br><img src="https://habrastorage.org/webt/7r/os/et/7rosetpoais8blpdvc_-7mfkg7u.jpeg"><br><br>  Donc, nous savons que le débordement de tampon se produit ici sans problème.  Mais ce qui est intéressant, c'est que nous avons cette <b>fonction run shell</b> , mais il est difficile d'y accéder de manière basée sur les débordements de tampon.  Comment un attaquant peut-il invoquer cette commande <b>run shell</b> ? <br><br>  Tout d'abord, l'attaquant peut démonter le programme, démarrer <b>GDB</b> , et trouver l'adresse de cette chose dans le fichier exécutable.  Vous connaissez probablement ces méthodes issues des travaux de laboratoire.  Ensuite, lors d'un débordement de tampon, un attaquant peut prendre cette adresse, la mettre dans le débordement de tampon généré, et vérifier que la fonction retourne au <b>shell d'exécution</b> . <br><br>  Pour que ce soit clair, je vais le dessiner.  Donc, vous avez une pile qui ressemble à ceci: en bas il y a un tampon débordé, au-dessus c'est un indicateur d'écart enregistré, au-dessus c'est l'adresse de retour pour <b>prosess_msg</b> .  En bas à gauche, nous avons un nouveau pointeur de pile qui lance la fonction, au-dessus un nouveau pointeur de rupture, puis le pointeur de pile qui sera utilisé, et encore plus haut est le pointeur de rupture de l'image précédente.  Tout semble assez familier. <br><br><img src="https://habrastorage.org/webt/qf/ee/vg/qfeevg9_wr3ctwybpgx8acjcpeq.jpeg"><br><br>  Comme je l'ai dit, pendant l'attaque, <b>GDB a été</b> utilisé pour savoir quelle est l'adresse du <b>shell d'exécution</b> .  Ainsi, lorsque le tampon déborde, nous pouvons simplement mettre l'adresse du <b>shell d'exécution</b> ici à droite.  Il s'agit en fait d'une extension assez simple de ce que nous savons déjà faire.  Essentiellement, cela signifie que si nous avons une commande qui lance le shell et si nous pouvons démonter le fichier binaire pour savoir où se trouve cette adresse, nous pouvons simplement la placer dans ce tableau de débordement situé au bas de la pile.  C'est assez simple. <br><br>  Donc, c'était un exemple extrêmement frivole, car le programmeur, pour une raison folle, a mis cette fonction ici, présentant ainsi à l'attaquant un véritable cadeau. <br>  Supposons maintenant qu'au lieu d'appeler cette chose <b>run_shell</b> , nous l'appellerons <b>run_boring</b> , puis il exécutera simplement la commande <b>/ bin / ls</b> .  Cependant, nous n'avons rien perdu, car nous aurons la chaîne <b>char * bash_path en haut</b> , qui nous indiquera le chemin vers ce <b>bin / bash</b> . <br><br><img src="https://habrastorage.org/webt/1d/u1/a2/1du1a2wtfwbzgtyul4bknzikpti.jpeg"><br><br>  Donc, la chose la plus intéressante à ce sujet est qu'un attaquant qui veut exécuter <b>ls</b> peut «analyser» le programme et trouver l'emplacement de <b>run_boring</b> , et ce n'est pas du tout amusant.  Mais en fait, nous avons une ligne en mémoire qui pointe vers le chemin du shell, en plus, nous savons quelque chose d'autre d'intéressant.  C'est que même si le programme n'appelle pas le système avec l'argument <b>/ bin / ls</b> , il fait quand même une sorte d'appel. <br><br>  Donc, nous savons que le système doit être en quelque sorte connecté à ce programme - <b>système («/ bin / ls»)</b> .  Par conséquent, nous pouvons utiliser ces deux opérations <b>void</b> pour réellement associer le système à cet <b>argument char * bash_path</b> .  La première chose que nous faisons est d'aller dans <b>GDB</b> et de découvrir où se trouve ce <b>système («/ bin / ls»)</b> dans l'image du processus binaire.  Donc, vous allez simplement dans <b>GDB</b> , tapez simplement <b>print_system</b> et obtenez des informations sur son décalage.  C'est assez simple, et vous pouvez faire de même pour <b>bash_path</b> .  Autrement dit, vous utilisez simplement <b>GDB</b> pour savoir où cette chose vit. <br><br>  Une fois que vous avez terminé, vous devez faire autre chose.  Parce que maintenant, nous devons vraiment comprendre comment invoquer le système en utilisant l'argument que nous avons choisi.  Et notre façon de procéder consiste essentiellement à falsifier la trame d'appel du système.  Si vous vous souvenez, une trame est ce que le compilateur et le matériel utilisent pour implémenter l'appel de pile. <br><br>  Nous voulons organiser sur la pile quelque chose comme ce que j'ai représenté sur cette figure.  En fait, nous allons simuler un système qui aurait dû être sur la pile, mais juste avant qu'il n'exécute réellement son code. <br><br>  Donc, nous avons ici l'argument du système, c'est la ligne que nous voulons exécuter.  En bas, nous avons une ligne où le système doit retourner lorsque la ligne avec l'argument est terminée.  Le système s'attend à ce que la pile ait cet aspect juste avant le début de l'exécution. <br><br><img src="https://habrastorage.org/webt/7r/ik/vp/7rikvpe59gsq0xdlubuhbew1juu.jpeg"><br><br>  Nous avions l'habitude de supposer qu'il n'y a pas d'arguments lorsque vous passez la fonction, mais maintenant, cela semble un peu différent.  Nous devons juste nous assurer que cet <b>argument</b> est dans le code de débordement que nous créons.  Nous devons juste nous assurer que cette fausse <b>trame d'appel</b> est dans ce tableau.  Ainsi, notre travail sera le suivant.  Rappelez-vous que le débordement de pile va de bas en haut. <br><br><img src="https://habrastorage.org/webt/kh/by/g7/khbyg7us4ir4ydv6ossc2-bbnd0.jpeg"><br><br>  Tout d'abord, nous allons mettre l'adresse système ici.  Et en plus, nous <b>placerons une adresse de retour indésirable</b> .  C'est l'endroit où le système reviendra une fois terminé.  Cette adresse sera un ensemble aléatoire d'octets.  Au-dessus, nous mettrons l'adresse <b>bash_path</b> .  Que se passe-t-il lorsque le tampon déborde maintenant? <br><br>  Après que <b>prosess_msg ait</b> atteint la ligne d'arrivée, il dira: "OK, c'est l'endroit où je devrais revenir"!  Le code système continue de fonctionner, il monte plus haut et voit le faux cadre d'appel que nous avons créé.  Pour le système, rien d'étourdissant ne se produira, il dira: "ouais, ça y est, l'argument que je veux exécuter est <b>bin / bash</b> ", il l'exécute, et c'est fait - l'attaquant a capturé le shell! <br><br>  Qu'avons-nous fait maintenant?  Nous avons profité de la connaissance de la <b>convention d'appel, de la convention d'appel</b> , comme plate-forme pour créer de faux cadres de pile ou de faux noms de cadre, je dirais.  En utilisant ces faux <b>cadres d'appel</b> , nous pouvons effectuer n'importe quelle fonction référencée et déjà définie par l'application. <br><br>  La prochaine question que nous devrions nous poser est: que faire si le programme n'a pas du tout cette ligne <b>char * bash_path</b> ?  Je note que cette ligne est presque toujours présente dans le programme.  Supposons cependant que nous vivions dans un monde inversé et qu'il ne soit toujours pas là.  Alors, que pourrions-nous faire pour mettre cette ligne dans un programme? <br><br>  La première chose que vous pouvez faire pour cela est de spécifier l'adresse correcte pour <b>bash_path</b> , en la plaçant plus haut, ici dans ce compartiment de notre pile, en y insérant trois éléments, chacun de 4 octets: <br><br>  <b>/ 0</b> <b><br></b>  <b>/ pat</b> <b><br></b>  <b>/ bin</b> <br><br><img src="https://habrastorage.org/webt/7y/ko/bo/7ykobou1yi5jzfppu2w0ok6b0zs.jpeg"><br><br>  Mais en tout cas, notre pointeur vient ici et - boum!  - La chose est faite.  De cette façon, vous pouvez maintenant appeler des arguments en les plaçant simplement dans votre code shell.  Terrifiant, non?  Et tout cela est construit avant une attaque <b>BROP</b> complète.  Mais avant de signaler une attaque <b>BROP</b> complète, vous devez comprendre comment vous enchaînez simplement les éléments déjà <b>contenus</b> dans le code.  Lorsque j'ai cette adresse de retour sous-évaluée ici, nous voulons simplement accéder au shell.  Mais si vous êtes un attaquant, vous pouvez diriger cette adresse de retour, ou cette adresse de retour, vers quelque chose qui pourrait vraiment être utilisé.  Et si vous faisiez cela, alors vous pourriez enchaîner plusieurs fonctions dans une rangée dans une rangée, plusieurs signes d'une fonction dans une rangée.  Il s'agit en effet d'une option très puissante. <br><br>  Parce que si nous définissons simplement l'adresse de retour pour le saut, le programme se bloque généralement, ce que nous ne voulons peut-être pas.  Par conséquent, il vaut la peine de lier certaines de ces choses ensemble afin de faire des choses plus intéressantes avec le programme. <br><br>  Supposons que notre objectif soit de vouloir appeler le système un nombre arbitraire de fois.  Nous ne voulons pas simplement le faire une fois, nous le ferons un nombre arbitraire de fois.  Alors, comment cela peut-il être fait? <br><br>  Pour ce faire, nous utilisons deux informations que nous savons déjà obtenir.  Nous savons comment obtenir l'adresse système - il vous suffit de regarder dans <b>GDB</b> et de la trouver là-bas.  Nous savons également comment trouver l'adresse de cette ligne, <b>bin / bash</b> .  Maintenant, pour lancer cette attaque en utilisant plusieurs appels au système, nous devons utiliser des gadgets.  Cela nous rapproche de ce qui se passe dans <b>BROP</b> . <br><br>  Il nous faut donc maintenant trouver l'adresse de ces deux opérations de code: <b>pop% eax</b> et <b>ret</b> .  Le premier supprime le haut de la pile et le place dans le registre <b>eax</b> , et le second le place dans le <b>pointeur d'</b> instruction <b>eip</b> .  C'est ce que nous appelons le gadget.  Il ressemble à un petit ensemble d'instructions d'assemblage qu'un attaquant peut utiliser pour construire des attaques plus ambitieuses. <br><br><img src="https://habrastorage.org/webt/r4/nw/c6/r4nwc61pbprp8gv2gof8kxdj0uw.jpeg"><br><br>  Ces gadgets sont des outils standard que les pirates utilisent pour trouver des choses comme des fichiers binaires.  Il est également facile de trouver l'un de ces gadgets, en supposant que vous ayez une copie du fichier binaire et que nous ne nous sommes pas souciés de la randomisation.  Ces choses sont très faciles à trouver, ainsi que très facile à trouver l'adresse du système et ainsi de suite. <br><br>  Donc, si nous avons l'un de ces gadgets, pourquoi pouvons-nous l'utiliser?  Bien sûr, faire le mal!  Pour ce faire, vous pouvez procéder comme suit. <br><br>  Supposons que nous modifions notre pile pour qu'elle ressemble à ceci, l'exploit, comme précédemment, est dirigé de bas en haut.  La première chose que nous faisons est de placer l'adresse système ici, et au-dessus, nous mettons l'adresse du gadget <b>pop / ret</b> .  Encore plus haut, nous mettons l'adresse de <b>bash_path</b> , puis répétons tout: par le haut, nous plaçons à nouveau l'adresse du système, l'adresse du gadget <b>pop / ret</b> et l'adresse de <b>bash_path</b> . <br><br><img src="https://habrastorage.org/webt/f6/ti/zh/f6tizhirkpxkzrwjeavzjc6uulc.jpeg"><br><br>  Que va-t-il se passer ici maintenant?  Ce sera un peu compliqué, donc les notes de cette conférence sont disponibles sur Internet, et pour l'instant vous pouvez simplement écouter ce qui se passe ici, mais quand j'ai compris cela pour la première fois, c'était comme comprendre que le Père Noël n'existait pas! <br><br>  Nous allons commencer à l'endroit où se trouve l'entrée d' <b>entrée</b> , revenir au système où l'instruction <b>ret</b> va supprimer l'élément de la pile à l'aide de la commande <b>pop</b> , donc maintenant le haut du pointeur de pile est ici.  Ainsi, nous supprimons l'élément à l'aide de <b>pop</b> , puis retournons la procédure <b>ret</b> , qui transfère le contrôle à l'adresse de retour sélectionnée dans la pile, et cette adresse de retour y est placée avec la commande <b>call</b> .  Donc, nous appelons à nouveau le système, et ce processus peut être répété encore et encore. <br><br><img src="https://habrastorage.org/webt/js/mz/oz/jsmzoz4p8_mrqlskie75rmdgcnu.jpeg"><br><br>  Il est clair que nous pouvons relier cette séquence pour effectuer un nombre arbitraire de choses.  Essentiellement, le noyau obtient ce qu'on appelle une programmation orientée inverse.  Veuillez noter que nous n'avons rien effectué sur cette pile.  Nous avons fait ce qui nous a permis d'empêcher l'exécution des données sans rien détruire.  Nous venons de faire un saut inattendu pour faire ce que nous voulons.  En fait, c'est très, très, très intelligent. <br><br>  Et ce qui est intéressant, c'est qu'à un haut niveau, nous avons identifié ce nouveau modèle informatique.  ,   ,     ,       .     ,  ,    .  , -       .     ,       ,   .          ,       .         .  ,        .  ,    ,     <b>stack canaries.</b> <br><br>   ,  «»  ,      .  ,  ,  «»    <b>ret address</b>   <b>saved %ebp</b> ,    -   ,   «».  ,        <b>ret</b> ,   ,       «»,  ,    - .    <b>stack canaries</b> . <br><br>  ,    «».         ,   . ,     «»? <br><br> ,    ,  ,      . <br> ,   ,  ,   «»  ,    «»  «». <br><br>  ,    ,  ,    «»     ,   ,    . <br>   ,    -  ,     «»         ,         .    ,   ?           ? <br>   ,       <b>fork</b>    .   , <b>fork</b>     .    ,   ,    ,      <b>fork</b> ,      ,  ,       ,       «»   .     ,       <b>stack canaries</b> . <br><br>       «»?      .  ,    ,     ,   «».  «»    .                . <br><br><img src="https://habrastorage.org/webt/ql/h1/ol/qlh1olpcbsug9nbtozpjevlll7u.jpeg"><br><br> ,    ,     –    ,      «».         , ,      0.    ,  «»,      .    ,  : <br><br> «,      «»!     ,      0.  «»!  1 –  «»,  2 –   . ,    2- .  ,     ,  «». <br><br><img src="https://habrastorage.org/webt/tx/xp/rc/txxprcve2i3lgkwslbdrluiv-sk.jpeg"><br><br>    ,   ,      ,     . <br><br>      «»,   ,    ,     .     ,          ,      «». <br><br> 57:10  <br><br> : <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cours MIT "Sécurité des systèmes informatiques".</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conférence 3: Buffer Overflows: Exploits and Protection, Part 3</font></font></a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/xSQxaie_h1o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La version complète du cours est disponible </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br>  Merci de rester avec nous.  Aimez-vous nos articles?  Vous voulez voir des matériaux plus intéressants?  Soutenez-nous en passant une commande ou en le recommandant à vos amis, une <b>réduction de 30% pour les utilisateurs Habr sur un analogue unique de serveurs d'entrée de gamme que nous avons inventés pour vous:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Toute la vérité sur VPS (KVM) E5-2650 v4 (6 cœurs) 10 Go DDR4 240 Go SSD 1 Gbps à partir de 20 $ ou comment diviser le serveur?</a>  (les options sont disponibles avec RAID1 et RAID10, jusqu'à 24 cœurs et jusqu'à 40 Go de DDR4). <br><br>  <b>Dell R730xd 2 fois moins cher?</b>  Nous avons seulement <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2 x Intel Dodeca-Core Xeon E5-2650v4 128 Go DDR4 6x480 Go SSD 1 Gbps 100 TV à partir de 249 $</a> aux Pays-Bas et aux États-Unis!</b>  Pour en savoir plus sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">création d'un bâtiment d'infrastructure.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">classe utilisant des serveurs Dell R730xd E5-2650 v4 coûtant 9 000 euros pour un sou?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr418093/">https://habr.com/ru/post/fr418093/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr418083/index.html">Serveur simple avec GraphQL au lieu de REST, implémentation en java</a></li>
<li><a href="../fr418085/index.html">Utilisation de promesses en JavaScript</a></li>
<li><a href="../fr418087/index.html">80% des caisses libre-service sont à risque</a></li>
<li><a href="../fr418089/index.html">Présentation de la fraiseuse CNC SolidCraft</a></li>
<li><a href="../fr418091/index.html">Liste d'articles et de littérature sur NAS</a></li>
<li><a href="../fr418095/index.html">À propos de l'appareil de fonctionnalité de test intégrée dans Rust (traduction)</a></li>
<li><a href="../fr418099/index.html">Cours MIT "Sécurité des systèmes informatiques". Conférence 3: Buffer Overflows: Exploits and Protection, Part 3</a></li>
<li><a href="../fr418101/index.html">Étymologie des termes informatiques</a></li>
<li><a href="../fr418103/index.html">Le chef de Roscosmos s'est souvenu de sa première fusée et a partagé ses plans pour l'avenir</a></li>
<li><a href="../fr418105/index.html">Pourquoi l'ouverture de YouTube dans Firefox ou Edge peut prendre 5 fois plus de temps que dans Google Chrome</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>