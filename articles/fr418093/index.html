<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸš´ğŸ» ğŸŒ¿ ğŸ‘¨ğŸ¾â€ğŸ­ Cours MIT "SÃ©curitÃ© des systÃ¨mes informatiques". ConfÃ©rence 3: Buffer Overflows: Exploits and Protection, Part 2 ğŸ•¶ï¸ ğŸ§‘ğŸ¿â€ğŸ¤â€ğŸ§‘ğŸ» ğŸ‘¨ğŸ¾â€âš–ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Institut de technologie du Massachusetts. Cours magistral # 6.858. "SÃ©curitÃ© des systÃ¨mes informatiques." Nikolai Zeldovich, James Mickens. 2014 annÃ©e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cours MIT "SÃ©curitÃ© des systÃ¨mes informatiques". ConfÃ©rence 3: Buffer Overflows: Exploits and Protection, Part 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/418093/"><h3>  Institut de technologie du Massachusetts.  Cours magistral # 6.858.  "SÃ©curitÃ© des systÃ¨mes informatiques."  Nikolai Zeldovich, James Mickens.  2014 annÃ©e </h3><br>  Computer Systems Security est un cours sur le dÃ©veloppement et la mise en Å“uvre de systÃ¨mes informatiques sÃ©curisÃ©s.  Les confÃ©rences couvrent les modÃ¨les de menace, les attaques qui compromettent la sÃ©curitÃ© et les techniques de sÃ©curitÃ© basÃ©es sur des travaux scientifiques rÃ©cents.  Les sujets incluent la sÃ©curitÃ© du systÃ¨me d'exploitation (OS), les fonctionnalitÃ©s, la gestion du flux d'informations, la sÃ©curitÃ© des langues, les protocoles rÃ©seau, la sÃ©curitÃ© matÃ©rielle et la sÃ©curitÃ© des applications Web. <br><br>  Cours 1: Â«Introduction: modÃ¨les de menaceÂ» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3</a> <br>  ConfÃ©rence 2: Â«ContrÃ´le des attaques de piratesÂ» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3</a> <br>  ConfÃ©rence 3: Â«DÃ©bordements de tampon: exploits et protectionÂ» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3</a> <a name="habracut"></a><br><br>  Fait intÃ©ressant, un attaquant ne peut pas accÃ©der Ã  une adresse spÃ©cifique, malgrÃ© le fait que nous utilisons principalement des adresses codÃ©es en dur.  Ce qu'il fait s'appelle une Â«attaque en tasÂ», et si vous Ãªtes une mauvaise personne, ce sera assez amusant pour vous.  Avec une telle attaque, un pirate commence Ã  allouer dynamiquement des tonnes de code shell et Ã  le saisir simplement au hasard dans la mÃ©moire.  Cela est particuliÃ¨rement efficace si vous utilisez des langages dynamiques de haut niveau tels que JavaScript.  Ainsi, le lecteur de balises est dans une boucle Ã©troite et gÃ©nÃ¨re simplement un grand nombre de lignes de code shell, puis en remplit un tas. <br><br>  L'attaquant ne peut pas dÃ©terminer l'emplacement exact des lignes, il sÃ©lectionne simplement 10 Mo de lignes de code shell et effectue un saut arbitraire.  Et s'il peut en quelque sorte contrÃ´ler l'un des pointeurs <b>ret</b> , il y a une chance qu'il "atterrisse" dans le code shell. <br><br><img src="https://habrastorage.org/webt/jl/7-/8x/jl7-8xckq3eq6z_wf2_m2alslzg.jpeg"><br><br>  Vous pouvez utiliser une astuce appelÃ©e <b>diapositive</b> <b>NOP, traÃ®neau NOP</b> ou <b>rampe NOP</b> , oÃ¹ <b>NOP</b> correspond <b>Ã  des instructions de non-opÃ©ration</b> ou Ã  des commandes vides et inactives.  Cela signifie que le flux d'exÃ©cution des commandes du processeur Â«glisseÂ» vers sa destination finale souhaitÃ©e chaque fois que le programme se rend Ã  l'adresse mÃ©moire n'importe oÃ¹ sur la diapositive. <br><br>  Imaginez que si vous avez une ligne de code shell et que vous allez Ã  un endroit alÃ©atoire sur cette ligne, cela peut ne pas fonctionner, car cela ne vous permet pas de dÃ©ployer l'attaque de la bonne maniÃ¨re. <br><br>  Mais peut-Ãªtre que les choses que vous mettez dans le tas ne sont fondamentalement qu'une tonne de <b>NOP</b> , et Ã  la toute fin, vous avez du code shell.  C'est en fait assez intelligent, car cela signifie que vous pouvez maintenant vous rendre au bon endroit oÃ¹ vous sautez.  Parce que si vous sautez dans l'un de ces <b>NOP</b> , cela se produit simplement Â«boum, boum, boum, boum, boum, boum, boumÂ», puis vous entrez dans le code shell. <br><br>  Il semble que les gens viennent avec Ã§a, ce que vous voyez probablement dans notre Ã©quipe.  Ils inventent quelque chose comme Ã§a, et c'est le problÃ¨me.  C'est donc une autre faÃ§on de contourner certaines choses alÃ©atoires en rendant simplement robuste la randomisation de vos codes, si cela a du sens. <br><br>  Nous avons donc discutÃ© de certains types d'alÃ©atoire que vous pouvez utiliser.  Il y a des idÃ©es stupides qui ont Ã©galement surgi chez les gens.  Alors maintenant, vous savez que lorsque vous souhaitez effectuer un appel systÃ¨me, par exemple, en utilisant la fonction <b>syscall libc</b> , vous passez essentiellement un numÃ©ro unique qui reprÃ©sente l'appel systÃ¨me que vous souhaitez effectuer.  Alors peut-Ãªtre que la fonction <b>fork</b> est 7, <b>sleep</b> est 8, ou quelque chose comme Ã§a. <br><br>  Cela signifie que si un attaquant peut trouver l'adresse de cette instruction <b>syscall</b> et y accÃ©der d'une maniÃ¨re ou d'une autre, il ou elle peut en fait simplement remplacer le numÃ©ro d'appel systÃ¨me qu'il souhaite utiliser directement.  Vous pouvez imaginer que chaque fois que le programme s'exÃ©cute, vous crÃ©ez en fait une affectation dynamique des numÃ©ros d' <b>appel systÃ¨me Ã  des</b> <b>appels systÃ¨me</b> valides, afin de compliquer la capture de l'attaquant. <br><br><img src="https://habrastorage.org/webt/nq/l6/ob/nql6obzl82-6vvdgdkt6iuhzs8g.jpeg"><br><br>  Il y a mÃªme des suggestions avant-gardistes pour changer le matÃ©riel afin que l'Ã©quipement contienne la clÃ© de cryptage <b>xor</b> , qui est utilisÃ©e pour les fonctions dynamiques <b>xor</b> .  Imaginez que chaque fois que vous compilez un programme, tous les codes d'instructions obtiennent une certaine clÃ© <b>xor</b> .  Cette clÃ© est stockÃ©e dans le registre de l'Ã©quipement lorsque vous tÃ©lÃ©chargez initialement le programme, et ensuite, chaque fois que vous exÃ©cutez l'instruction, l'Ã©quipement effectue automatiquement une ou plusieurs opÃ©rations avec elle avant de poursuivre avec cette instruction.  La bonne chose Ã  propos de cette approche est que maintenant, mÃªme si un attaquant peut gÃ©nÃ©rer du code shell, il ne reconnaÃ®tra pas cette clÃ©.  Il lui sera donc trÃ¨s difficile de comprendre ce qui doit Ãªtre exactement mis en mÃ©moire. <br><br>  <b>Public:</b> mais s'il peut obtenir le code, il peut Ã©galement utiliser <b>xor</b> pour <b>reconvertir</b> le code en instruction. <br><br>  <b>Professeur:</b> oui, c'est le problÃ¨me canonique, non.  Ceci est quelque peu similaire Ã  ce qui se passe lors des attaques <b>BROP</b> , lorsque nous semblons randomiser l'emplacement du code, mais l'attaquant peut le "sentir" et dÃ©couvrir ce qui se passe.  On peut imaginer que, par exemple, si un attaquant connaÃ®t une sous-sÃ©quence de code qu'il s'attend Ã  trouver dans un fichier binaire, il tentera d'utiliser l'opÃ©ration <b>xor</b> pour ce fichier afin d'extraire la clÃ©. <br><br>  Essentiellement, nous avons discutÃ© de toutes sortes d'attaques de randomisation dont je voulais vous parler aujourd'hui.  Avant de passer Ã  la programmation, il convient de discuter des mÃ©thodes de protection utilisÃ©es dans la pratique.  Il s'avÃ¨re que <b>GCC</b> et Visual Studio incluent l'approche par <b>dÃ©faut des canaris de pile</b> .  Il s'agit d'une communautÃ© trÃ¨s populaire et trÃ¨s cÃ©lÃ¨bre.  Si vous regardez Linux et Windows, ils profitent Ã©galement de choses comme la mÃ©moire non exÃ©cutable et la randomisation de l'espace d'adressage.  Certes, le systÃ¨me <b>baggy bounds</b> n'est pas si populaire auprÃ¨s d'eux, probablement en raison du coÃ»t de la mÃ©moire, du processeur, des fausses alarmes, etc., dont nous avons dÃ©jÃ  parlÃ©.  Donc, fondamentalement, nous avons examinÃ© comment les choses vont empÃªcher le problÃ¨me de dÃ©passement de tampon. <br><br>  Nous allons maintenant parler de <b>ROP</b> , programmation orientÃ©e inverse.  Aujourd'hui, je vous ai dÃ©jÃ  dit ce que cela reprÃ©sente en termes de randomisation de l'espace d'adressage et d'empÃªcher l'exÃ©cution des donnÃ©es - c'est la lecture, l'Ã©criture et l'exÃ©cution.  Ce sont en fait des choses trÃ¨s puissantes.  Parce que la randomisation empÃªche la possibilitÃ© pour un attaquant de comprendre oÃ¹ se trouvent nos adresses codÃ©es en dur.  Et la possibilitÃ© d'empÃªcher l'exÃ©cution de donnÃ©es garantit que mÃªme si vous placez le code shell sur la pile, un attaquant ne peut pas simplement y accÃ©der et l'exÃ©cuter. <br><br>  Tout cela semble assez progressif, mais les pirates dÃ©veloppent constamment des mÃ©thodes d'attaque contre de telles solutions de dÃ©fense progressives. <br><br>  Alors, quelle est l'essence de la programmation inversÃ©e? <br><br>  Et si, au lieu de simplement crÃ©er du nouveau code lors d'une attaque, un attaquant pouvait combiner les morceaux de code existants puis les combiner de maniÃ¨re anormale?  AprÃ¨s tout, nous savons que le programme contient des tonnes de ce code. <br><br><img src="https://habrastorage.org/webt/fd/76/08/fd7608uferkfub0zyknpa6w1vfk.jpeg"><br><br>  Donc, heureusement ou malheureusement, tout dÃ©pend de quel cÃ´tÃ© vous Ãªtes.  Si vous pouvez trouver des extraits de code intÃ©ressants et les combiner ensemble, vous pouvez obtenir quelque chose comme le langage <b>Turing</b> , oÃ¹ l'attaquant peut essentiellement faire ce qu'il veut. <br><br>  Regardons un exemple trÃ¨s simple qui vous semblera familier au dÃ©but, mais qui se transformera rapidement en quelque chose de fou. <br><br>  Disons que nous avons le programme suivant.  Donc, ayons une sorte de fonction et, ce qui est pratique pour l'attaquant, voici cette belle <b>fonction shell run</b> .  Donc, ce n'est qu'un appel au systÃ¨me, il exÃ©cutera la commande <b>bin / bash</b> et cela se terminera.  Ensuite, nous avons un processus de dÃ©bordement de tampon canonique ou, dÃ©solÃ©, une fonction qui annoncera la crÃ©ation d'un tampon, puis utilisera l'une de ces fonctions dangereuses pour remplir le tampon d'octets. <br><br><img src="https://habrastorage.org/webt/7r/os/et/7rosetpoais8blpdvc_-7mfkg7u.jpeg"><br><br>  Donc, nous savons que le dÃ©bordement de tampon se produit ici sans problÃ¨me.  Mais ce qui est intÃ©ressant, c'est que nous avons cette <b>fonction run shell</b> , mais il est difficile d'y accÃ©der de maniÃ¨re basÃ©e sur les dÃ©bordements de tampon.  Comment un attaquant peut-il invoquer cette commande <b>run shell</b> ? <br><br>  Tout d'abord, l'attaquant peut dÃ©monter le programme, dÃ©marrer <b>GDB</b> , et trouver l'adresse de cette chose dans le fichier exÃ©cutable.  Vous connaissez probablement ces mÃ©thodes issues des travaux de laboratoire.  Ensuite, lors d'un dÃ©bordement de tampon, un attaquant peut prendre cette adresse, la mettre dans le dÃ©bordement de tampon gÃ©nÃ©rÃ©, et vÃ©rifier que la fonction retourne au <b>shell d'exÃ©cution</b> . <br><br>  Pour que ce soit clair, je vais le dessiner.  Donc, vous avez une pile qui ressemble Ã  ceci: en bas il y a un tampon dÃ©bordÃ©, au-dessus c'est un indicateur d'Ã©cart enregistrÃ©, au-dessus c'est l'adresse de retour pour <b>prosess_msg</b> .  En bas Ã  gauche, nous avons un nouveau pointeur de pile qui lance la fonction, au-dessus un nouveau pointeur de rupture, puis le pointeur de pile qui sera utilisÃ©, et encore plus haut est le pointeur de rupture de l'image prÃ©cÃ©dente.  Tout semble assez familier. <br><br><img src="https://habrastorage.org/webt/qf/ee/vg/qfeevg9_wr3ctwybpgx8acjcpeq.jpeg"><br><br>  Comme je l'ai dit, pendant l'attaque, <b>GDB a Ã©tÃ©</b> utilisÃ© pour savoir quelle est l'adresse du <b>shell d'exÃ©cution</b> .  Ainsi, lorsque le tampon dÃ©borde, nous pouvons simplement mettre l'adresse du <b>shell d'exÃ©cution</b> ici Ã  droite.  Il s'agit en fait d'une extension assez simple de ce que nous savons dÃ©jÃ  faire.  Essentiellement, cela signifie que si nous avons une commande qui lance le shell et si nous pouvons dÃ©monter le fichier binaire pour savoir oÃ¹ se trouve cette adresse, nous pouvons simplement la placer dans ce tableau de dÃ©bordement situÃ© au bas de la pile.  C'est assez simple. <br><br>  Donc, c'Ã©tait un exemple extrÃªmement frivole, car le programmeur, pour une raison folle, a mis cette fonction ici, prÃ©sentant ainsi Ã  l'attaquant un vÃ©ritable cadeau. <br>  Supposons maintenant qu'au lieu d'appeler cette chose <b>run_shell</b> , nous l'appellerons <b>run_boring</b> , puis il exÃ©cutera simplement la commande <b>/ bin / ls</b> .  Cependant, nous n'avons rien perdu, car nous aurons la chaÃ®ne <b>char * bash_path en haut</b> , qui nous indiquera le chemin vers ce <b>bin / bash</b> . <br><br><img src="https://habrastorage.org/webt/1d/u1/a2/1du1a2wtfwbzgtyul4bknzikpti.jpeg"><br><br>  Donc, la chose la plus intÃ©ressante Ã  ce sujet est qu'un attaquant qui veut exÃ©cuter <b>ls</b> peut Â«analyserÂ» le programme et trouver l'emplacement de <b>run_boring</b> , et ce n'est pas du tout amusant.  Mais en fait, nous avons une ligne en mÃ©moire qui pointe vers le chemin du shell, en plus, nous savons quelque chose d'autre d'intÃ©ressant.  C'est que mÃªme si le programme n'appelle pas le systÃ¨me avec l'argument <b>/ bin / ls</b> , il fait quand mÃªme une sorte d'appel. <br><br>  Donc, nous savons que le systÃ¨me doit Ãªtre en quelque sorte connectÃ© Ã  ce programme - <b>systÃ¨me (Â«/ bin / lsÂ»)</b> .  Par consÃ©quent, nous pouvons utiliser ces deux opÃ©rations <b>void</b> pour rÃ©ellement associer le systÃ¨me Ã  cet <b>argument char * bash_path</b> .  La premiÃ¨re chose que nous faisons est d'aller dans <b>GDB</b> et de dÃ©couvrir oÃ¹ se trouve ce <b>systÃ¨me (Â«/ bin / lsÂ»)</b> dans l'image du processus binaire.  Donc, vous allez simplement dans <b>GDB</b> , tapez simplement <b>print_system</b> et obtenez des informations sur son dÃ©calage.  C'est assez simple, et vous pouvez faire de mÃªme pour <b>bash_path</b> .  Autrement dit, vous utilisez simplement <b>GDB</b> pour savoir oÃ¹ cette chose vit. <br><br>  Une fois que vous avez terminÃ©, vous devez faire autre chose.  Parce que maintenant, nous devons vraiment comprendre comment invoquer le systÃ¨me en utilisant l'argument que nous avons choisi.  Et notre faÃ§on de procÃ©der consiste essentiellement Ã  falsifier la trame d'appel du systÃ¨me.  Si vous vous souvenez, une trame est ce que le compilateur et le matÃ©riel utilisent pour implÃ©menter l'appel de pile. <br><br>  Nous voulons organiser sur la pile quelque chose comme ce que j'ai reprÃ©sentÃ© sur cette figure.  En fait, nous allons simuler un systÃ¨me qui aurait dÃ» Ãªtre sur la pile, mais juste avant qu'il n'exÃ©cute rÃ©ellement son code. <br><br>  Donc, nous avons ici l'argument du systÃ¨me, c'est la ligne que nous voulons exÃ©cuter.  En bas, nous avons une ligne oÃ¹ le systÃ¨me doit retourner lorsque la ligne avec l'argument est terminÃ©e.  Le systÃ¨me s'attend Ã  ce que la pile ait cet aspect juste avant le dÃ©but de l'exÃ©cution. <br><br><img src="https://habrastorage.org/webt/7r/ik/vp/7rikvpe59gsq0xdlubuhbew1juu.jpeg"><br><br>  Nous avions l'habitude de supposer qu'il n'y a pas d'arguments lorsque vous passez la fonction, mais maintenant, cela semble un peu diffÃ©rent.  Nous devons juste nous assurer que cet <b>argument</b> est dans le code de dÃ©bordement que nous crÃ©ons.  Nous devons juste nous assurer que cette fausse <b>trame d'appel</b> est dans ce tableau.  Ainsi, notre travail sera le suivant.  Rappelez-vous que le dÃ©bordement de pile va de bas en haut. <br><br><img src="https://habrastorage.org/webt/kh/by/g7/khbyg7us4ir4ydv6ossc2-bbnd0.jpeg"><br><br>  Tout d'abord, nous allons mettre l'adresse systÃ¨me ici.  Et en plus, nous <b>placerons une adresse de retour indÃ©sirable</b> .  C'est l'endroit oÃ¹ le systÃ¨me reviendra une fois terminÃ©.  Cette adresse sera un ensemble alÃ©atoire d'octets.  Au-dessus, nous mettrons l'adresse <b>bash_path</b> .  Que se passe-t-il lorsque le tampon dÃ©borde maintenant? <br><br>  AprÃ¨s que <b>prosess_msg ait</b> atteint la ligne d'arrivÃ©e, il dira: "OK, c'est l'endroit oÃ¹ je devrais revenir"!  Le code systÃ¨me continue de fonctionner, il monte plus haut et voit le faux cadre d'appel que nous avons crÃ©Ã©.  Pour le systÃ¨me, rien d'Ã©tourdissant ne se produira, il dira: "ouais, Ã§a y est, l'argument que je veux exÃ©cuter est <b>bin / bash</b> ", il l'exÃ©cute, et c'est fait - l'attaquant a capturÃ© le shell! <br><br>  Qu'avons-nous fait maintenant?  Nous avons profitÃ© de la connaissance de la <b>convention d'appel, de la convention d'appel</b> , comme plate-forme pour crÃ©er de faux cadres de pile ou de faux noms de cadre, je dirais.  En utilisant ces faux <b>cadres d'appel</b> , nous pouvons effectuer n'importe quelle fonction rÃ©fÃ©rencÃ©e et dÃ©jÃ  dÃ©finie par l'application. <br><br>  La prochaine question que nous devrions nous poser est: que faire si le programme n'a pas du tout cette ligne <b>char * bash_path</b> ?  Je note que cette ligne est presque toujours prÃ©sente dans le programme.  Supposons cependant que nous vivions dans un monde inversÃ© et qu'il ne soit toujours pas lÃ .  Alors, que pourrions-nous faire pour mettre cette ligne dans un programme? <br><br>  La premiÃ¨re chose que vous pouvez faire pour cela est de spÃ©cifier l'adresse correcte pour <b>bash_path</b> , en la plaÃ§ant plus haut, ici dans ce compartiment de notre pile, en y insÃ©rant trois Ã©lÃ©ments, chacun de 4 octets: <br><br>  <b>/ 0</b> <b><br></b>  <b>/ pat</b> <b><br></b>  <b>/ bin</b> <br><br><img src="https://habrastorage.org/webt/7y/ko/bo/7ykobou1yi5jzfppu2w0ok6b0zs.jpeg"><br><br>  Mais en tout cas, notre pointeur vient ici et - boum!  - La chose est faite.  De cette faÃ§on, vous pouvez maintenant appeler des arguments en les plaÃ§ant simplement dans votre code shell.  Terrifiant, non?  Et tout cela est construit avant une attaque <b>BROP</b> complÃ¨te.  Mais avant de signaler une attaque <b>BROP</b> complÃ¨te, vous devez comprendre comment vous enchaÃ®nez simplement les Ã©lÃ©ments dÃ©jÃ  <b>contenus</b> dans le code.  Lorsque j'ai cette adresse de retour sous-Ã©valuÃ©e ici, nous voulons simplement accÃ©der au shell.  Mais si vous Ãªtes un attaquant, vous pouvez diriger cette adresse de retour, ou cette adresse de retour, vers quelque chose qui pourrait vraiment Ãªtre utilisÃ©.  Et si vous faisiez cela, alors vous pourriez enchaÃ®ner plusieurs fonctions dans une rangÃ©e dans une rangÃ©e, plusieurs signes d'une fonction dans une rangÃ©e.  Il s'agit en effet d'une option trÃ¨s puissante. <br><br>  Parce que si nous dÃ©finissons simplement l'adresse de retour pour le saut, le programme se bloque gÃ©nÃ©ralement, ce que nous ne voulons peut-Ãªtre pas.  Par consÃ©quent, il vaut la peine de lier certaines de ces choses ensemble afin de faire des choses plus intÃ©ressantes avec le programme. <br><br>  Supposons que notre objectif soit de vouloir appeler le systÃ¨me un nombre arbitraire de fois.  Nous ne voulons pas simplement le faire une fois, nous le ferons un nombre arbitraire de fois.  Alors, comment cela peut-il Ãªtre fait? <br><br>  Pour ce faire, nous utilisons deux informations que nous savons dÃ©jÃ  obtenir.  Nous savons comment obtenir l'adresse systÃ¨me - il vous suffit de regarder dans <b>GDB</b> et de la trouver lÃ -bas.  Nous savons Ã©galement comment trouver l'adresse de cette ligne, <b>bin / bash</b> .  Maintenant, pour lancer cette attaque en utilisant plusieurs appels au systÃ¨me, nous devons utiliser des gadgets.  Cela nous rapproche de ce qui se passe dans <b>BROP</b> . <br><br>  Il nous faut donc maintenant trouver l'adresse de ces deux opÃ©rations de code: <b>pop% eax</b> et <b>ret</b> .  Le premier supprime le haut de la pile et le place dans le registre <b>eax</b> , et le second le place dans le <b>pointeur d'</b> instruction <b>eip</b> .  C'est ce que nous appelons le gadget.  Il ressemble Ã  un petit ensemble d'instructions d'assemblage qu'un attaquant peut utiliser pour construire des attaques plus ambitieuses. <br><br><img src="https://habrastorage.org/webt/r4/nw/c6/r4nwc61pbprp8gv2gof8kxdj0uw.jpeg"><br><br>  Ces gadgets sont des outils standard que les pirates utilisent pour trouver des choses comme des fichiers binaires.  Il est Ã©galement facile de trouver l'un de ces gadgets, en supposant que vous ayez une copie du fichier binaire et que nous ne nous sommes pas souciÃ©s de la randomisation.  Ces choses sont trÃ¨s faciles Ã  trouver, ainsi que trÃ¨s facile Ã  trouver l'adresse du systÃ¨me et ainsi de suite. <br><br>  Donc, si nous avons l'un de ces gadgets, pourquoi pouvons-nous l'utiliser?  Bien sÃ»r, faire le mal!  Pour ce faire, vous pouvez procÃ©der comme suit. <br><br>  Supposons que nous modifions notre pile pour qu'elle ressemble Ã  ceci, l'exploit, comme prÃ©cÃ©demment, est dirigÃ© de bas en haut.  La premiÃ¨re chose que nous faisons est de placer l'adresse systÃ¨me ici, et au-dessus, nous mettons l'adresse du gadget <b>pop / ret</b> .  Encore plus haut, nous mettons l'adresse de <b>bash_path</b> , puis rÃ©pÃ©tons tout: par le haut, nous plaÃ§ons Ã  nouveau l'adresse du systÃ¨me, l'adresse du gadget <b>pop / ret</b> et l'adresse de <b>bash_path</b> . <br><br><img src="https://habrastorage.org/webt/f6/ti/zh/f6tizhirkpxkzrwjeavzjc6uulc.jpeg"><br><br>  Que va-t-il se passer ici maintenant?  Ce sera un peu compliquÃ©, donc les notes de cette confÃ©rence sont disponibles sur Internet, et pour l'instant vous pouvez simplement Ã©couter ce qui se passe ici, mais quand j'ai compris cela pour la premiÃ¨re fois, c'Ã©tait comme comprendre que le PÃ¨re NoÃ«l n'existait pas! <br><br>  Nous allons commencer Ã  l'endroit oÃ¹ se trouve l'entrÃ©e d' <b>entrÃ©e</b> , revenir au systÃ¨me oÃ¹ l'instruction <b>ret</b> va supprimer l'Ã©lÃ©ment de la pile Ã  l'aide de la commande <b>pop</b> , donc maintenant le haut du pointeur de pile est ici.  Ainsi, nous supprimons l'Ã©lÃ©ment Ã  l'aide de <b>pop</b> , puis retournons la procÃ©dure <b>ret</b> , qui transfÃ¨re le contrÃ´le Ã  l'adresse de retour sÃ©lectionnÃ©e dans la pile, et cette adresse de retour y est placÃ©e avec la commande <b>call</b> .  Donc, nous appelons Ã  nouveau le systÃ¨me, et ce processus peut Ãªtre rÃ©pÃ©tÃ© encore et encore. <br><br><img src="https://habrastorage.org/webt/js/mz/oz/jsmzoz4p8_mrqlskie75rmdgcnu.jpeg"><br><br>  Il est clair que nous pouvons relier cette sÃ©quence pour effectuer un nombre arbitraire de choses.  Essentiellement, le noyau obtient ce qu'on appelle une programmation orientÃ©e inverse.  Veuillez noter que nous n'avons rien effectuÃ© sur cette pile.  Nous avons fait ce qui nous a permis d'empÃªcher l'exÃ©cution des donnÃ©es sans rien dÃ©truire.  Nous venons de faire un saut inattendu pour faire ce que nous voulons.  En fait, c'est trÃ¨s, trÃ¨s, trÃ¨s intelligent. <br><br>  Et ce qui est intÃ©ressant, c'est qu'Ã  un haut niveau, nous avons identifiÃ© ce nouveau modÃ¨le informatique.  ,   ,     ,       .     ,  ,    .  , -       .     ,       ,   .          ,       .         .  ,        .  ,    ,     <b>stack canaries.</b> <br><br>   ,  Â«Â»  ,      .  ,  ,  Â«Â»    <b>ret address</b>   <b>saved %ebp</b> ,    -   ,   Â«Â».  ,        <b>ret</b> ,   ,       Â«Â»,  ,    - .    <b>stack canaries</b> . <br><br>  ,    Â«Â».         ,   . ,     Â«Â»? <br><br> ,    ,  ,      . <br> ,   ,  ,   Â«Â»  ,    Â«Â»  Â«Â». <br><br>  ,    ,  ,    Â«Â»     ,   ,    . <br>   ,    -  ,     Â«Â»         ,         .    ,   ?           ? <br>   ,       <b>fork</b>    .   , <b>fork</b>     .    ,   ,    ,      <b>fork</b> ,      ,  ,       ,       Â«Â»   .     ,       <b>stack canaries</b> . <br><br>       Â«Â»?      .  ,    ,     ,   Â«Â».  Â«Â»    .                . <br><br><img src="https://habrastorage.org/webt/ql/h1/ol/qlh1olpcbsug9nbtozpjevlll7u.jpeg"><br><br> ,    ,     â€“    ,      Â«Â».         , ,      0.    ,  Â«Â»,      .    ,  : <br><br> Â«,      Â«Â»!     ,      0.  Â«Â»!  1 â€“  Â«Â»,  2 â€“   . ,    2- .  ,     ,  Â«Â». <br><br><img src="https://habrastorage.org/webt/tx/xp/rc/txxprcve2i3lgkwslbdrluiv-sk.jpeg"><br><br>    ,   ,      ,     . <br><br>      Â«Â»,   ,    ,     .     ,          ,      Â«Â». <br><br> 57:10  <br><br> : <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cours MIT "SÃ©curitÃ© des systÃ¨mes informatiques".</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConfÃ©rence 3: Buffer Overflows: Exploits and Protection, Part 3</font></font></a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/xSQxaie_h1o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La version complÃ¨te du cours est disponible </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br>  Merci de rester avec nous.  Aimez-vous nos articles?  Vous voulez voir des matÃ©riaux plus intÃ©ressants?  Soutenez-nous en passant une commande ou en le recommandant Ã  vos amis, une <b>rÃ©duction de 30% pour les utilisateurs Habr sur un analogue unique de serveurs d'entrÃ©e de gamme que nous avons inventÃ©s pour vous:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Toute la vÃ©ritÃ© sur VPS (KVM) E5-2650 v4 (6 cÅ“urs) 10 Go DDR4 240 Go SSD 1 Gbps Ã  partir de 20 $ ou comment diviser le serveur?</a>  (les options sont disponibles avec RAID1 et RAID10, jusqu'Ã  24 cÅ“urs et jusqu'Ã  40 Go de DDR4). <br><br>  <b>Dell R730xd 2 fois moins cher?</b>  Nous avons seulement <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2 x Intel Dodeca-Core Xeon E5-2650v4 128 Go DDR4 6x480 Go SSD 1 Gbps 100 TV Ã  partir de 249 $</a> aux Pays-Bas et aux Ã‰tats-Unis!</b>  Pour en savoir plus sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">crÃ©ation d'un bÃ¢timent d'infrastructure.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">classe utilisant des serveurs Dell R730xd E5-2650 v4 coÃ»tant 9 000 euros pour un sou?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr418093/">https://habr.com/ru/post/fr418093/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr418083/index.html">Serveur simple avec GraphQL au lieu de REST, implÃ©mentation en java</a></li>
<li><a href="../fr418085/index.html">Utilisation de promesses en JavaScript</a></li>
<li><a href="../fr418087/index.html">80% des caisses libre-service sont Ã  risque</a></li>
<li><a href="../fr418089/index.html">PrÃ©sentation de la fraiseuse CNC SolidCraft</a></li>
<li><a href="../fr418091/index.html">Liste d'articles et de littÃ©rature sur NAS</a></li>
<li><a href="../fr418095/index.html">Ã€ propos de l'appareil de fonctionnalitÃ© de test intÃ©grÃ©e dans Rust (traduction)</a></li>
<li><a href="../fr418099/index.html">Cours MIT "SÃ©curitÃ© des systÃ¨mes informatiques". ConfÃ©rence 3: Buffer Overflows: Exploits and Protection, Part 3</a></li>
<li><a href="../fr418101/index.html">Ã‰tymologie des termes informatiques</a></li>
<li><a href="../fr418103/index.html">Le chef de Roscosmos s'est souvenu de sa premiÃ¨re fusÃ©e et a partagÃ© ses plans pour l'avenir</a></li>
<li><a href="../fr418105/index.html">Pourquoi l'ouverture de YouTube dans Firefox ou Edge peut prendre 5 fois plus de temps que dans Google Chrome</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>