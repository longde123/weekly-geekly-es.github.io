<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐵 🚧 🎛️ Carte interactive pour une application Web en quelques heures ✊🏿 🎢 👐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans un article précédent, j'ai brièvement parlé des capacités de kepler.gl, le nouvel outil Open Source pour visualiser et analyser de grands ensembl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Carte interactive pour une application Web en quelques heures</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422759/"><p>  Dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article précédent,</a> j'ai brièvement parlé des capacités de kepler.gl, le nouvel outil Open Source pour visualiser et analyser de grands ensembles de données géographiques. </p><br><p><img src="https://habrastorage.org/webt/j7/wr/ug/j7wrugptpbwykcqm4quq-lrk72s.png" alt="Options pour les cartes créées avec kepler.gl"><br>  <em>Figure 1. Options pour les cartes créées à l'aide de kepler.gl (par Uber)</em> </p><br><p> Cette application Web vous permet de créer une carte interactive informative et, surtout, colorée basée sur des ensembles arbitraires de géodonnées en quelques minutes.  Cependant, la question se pose de savoir quoi en faire ensuite?  Comment partager les résultats avec des collègues, des amis ou des clients? </p><a name="habracut"></a><br><h3 id="sravnivaem-alternativnye-varianty">  Comparez les alternatives </h3><br><p>  Toute la «magie» de kepler.gl se produit sur le client, donc l'application ne propose que 2 façons de partager vos résultats avec les autres: </p><br><ul><li>  enregistrer la visualisation sous forme d'image statique (tout en perdant la capacité d'interagir avec la carte) </li><li>  exporter la configuration et les données créées sous forme de fichiers et les envoyer à toutes les parties intéressées avec des instructions sur le téléchargement des données reçues sur kepler.gl pour afficher la carte créée </li></ul><br><p>  Heureusement, kepler.gl n'est pas seulement un outil Web, mais aussi un composant React, avec lequel vous pouvez rapidement créer un site de démonstration avec vos visualisations ou les intégrer dans une application Web existante. </p><br><p>  <em><strong>Remarque</strong></em>  <em>Le traitement et l'agrégation des données à la volée, kepler.gl nécessitent souvent beaucoup de ressources.</em>  <em>Par conséquent, vous devez être particulièrement prudent lors de son intégration dans des applications conçues pour les mobiles.</em> </p><br><p>  Ce cas d'utilisation de kepler.gl permettra: </p><br><ul><li>  ne complique pas le processus de visualisation de la visualisation (il suffit d'envoyer un lien vers votre application) </li><li>  ne donne pas accès aux ensembles de données d'origine sous une forme explicite (comme requis par le cas de base 2) </li><li>  restreindre les formats accessibles aux utilisateurs pour interagir avec les visualisations (par exemple, interdire le réglage automatique des filtres ou des méthodes d'affichage des données) </li><li>  enregistrer tous les formats souhaités pour interagir avec la carte (info-bulle, zoom, changer de mode de carte, etc.) </li></ul><br><p>  La dernière des options envisagées nécessitera des efforts supplémentaires de la part du créateur de géo-visualisation et vous ne pourrez pas vous passer de programmation.  Cependant, comme vous le verrez bientôt, il n'est pas difficile de le mettre en œuvre de la même manière. </p><br><h3 id="sozdaem-demo-prilozhenie">  Créer une application de démonstration </h3><br><p>  Il est temps de passer de la théorie à la pratique.  Afin de vous présenter les étapes de base de l'intégration de kepler.gl dans votre code, j'ai réalisé une petite application de démonstration. </p><br><p>  Il permet à l'utilisateur de voir des informations sur les parkings payants de Moscou dans l'un des deux modes - général ou agrégé.  Dans le même temps, l'application permet uniquement de visualiser les visualisations que nous avons créées, de basculer entre elles et de travailler avec la carte en mode lecture seule.  Tout le code source et la version en direct sont disponibles sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> . </p><br><p><img src="https://habrastorage.org/webt/sh/hb/qa/shhbqaimmmrciwal58iquhxiy08.png" alt="Application de démonstration pour un parking payant à Moscou"><br>  <em>Figure 2. Deux modes d'affichage de carte fournis par l'application de démonstration</em> </p><br><p>  Pour créer cette démo, j'ai utilisé mon propre modèle de projet.  Cependant, si vous décidez de jouer avec kepler.gl vous-même, mais que vous n'avez toujours pas de préférences personnelles, je vous recommande d'utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">create-react-app</a> , ce qui réduira considérablement le temps <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nécessaire</a> pour créer les fondations de votre future application. </p><br><h3 id="dobavlyaem-keplergl-v-proekt">  Ajouter kepler.gl au projet </h3><br><p>  Kepler.gl est un composant React qui utilise Redux pour stocker et gérer son état.  Pour l'ajouter au projet, il suffit d'installer le paquet npm approprié: </p><br><pre><code class="bash hljs">npm install --save kepler.gl</code> </pre> <br><p>  Ce package npm comprend: </p><br><ul><li>  un ensemble de composants d'interface utilisateur et d'usines qui leur permettent d'être redéfinis avec leurs propres composants </li><li>  méthodes prédéfinies pour ajouter / modifier les données utilisées et comment les afficher </li><li>  Réducteur redux nécessaire à leur travail </li></ul><br><h3 id="nastraivaem-redux-hranilische-dlya-raboty-keplergl">  Configuration du stockage Redux pour kepler.gl </h3><br><p>  Kepler.gl utilise Redux pour gérer son état dans le processus de création et de mise à jour des cartes.  Par conséquent, avant d'utiliser le composant KeplerGl, nous devons ajouter le réducteur approprié au réducteur d'application. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { combineReducers } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'redux'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> keplerGlReducer <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'kepler.gl/reducers'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> appReducer <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./appReducer'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reducers = combineReducers({ <span class="hljs-attr"><span class="hljs-attr">keplerGl</span></span>: mapReducer, <span class="hljs-attr"><span class="hljs-attr">app</span></span>: appReducer, }); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> reducers;</code> </pre> <br><p>  Il est important de se rappeler que par défaut, le composant KeplerGl fournira à l'utilisateur toutes les options disponibles pour l'auto-édition, le téléchargement, la mise à jour et le filtrage des données.  Pour limiter l'ensemble des actions autorisées à l'utilisateur, vous devez transférer des informations sur le mode de carte (pour la lecture ou l'édition) et les contrôles de carte disponibles dans les paramètres d'état initial: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mapReducer = keplerGlReducer .initialState({ <span class="hljs-attr"><span class="hljs-attr">uiState</span></span>: { <span class="hljs-attr"><span class="hljs-attr">readOnly</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">mapControls</span></span>: { <span class="hljs-attr"><span class="hljs-attr">visibleLayers</span></span>: { <span class="hljs-attr"><span class="hljs-attr">show</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }, <span class="hljs-attr"><span class="hljs-attr">toggle3d</span></span>: { <span class="hljs-attr"><span class="hljs-attr">show</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }, <span class="hljs-attr"><span class="hljs-attr">splitMap</span></span>: { <span class="hljs-attr"><span class="hljs-attr">show</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-attr"><span class="hljs-attr">mapLegend</span></span>: { <span class="hljs-attr"><span class="hljs-attr">show</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">active</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> } } } });</code> </pre> <br><p>  Nous devrons également installer react <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">-palm</a> , que kepler.gl utilise pour contrôler les effets secondaires et ajouter taskMiddleware à partir de ce paquet npm au référentiel Redux de son application: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {createStore, applyMiddleware, compose} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'redux'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {taskMiddleware} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-palm'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> reducers <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./reducers'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> initialState = { }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> middlewares = [ taskMiddleware ]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> enhancers = [applyMiddleware(...middlewares)]; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> createStore( reducers, initialState, compose(...enhancers) );</code> </pre> <br><p>  <em><strong>Remarque</strong></em>  <em>Actuellement, l'équipe Uber Engineering travaille activement sur une nouvelle version de kepler.gl qui ne dépendra pas de react-palm.</em> </p><br><p>  Par défaut, kepler.gl s'attend à ce que son objet d'état soit situé au niveau supérieur de l'état de l'application entière et soit accessible par le nom keplerGl.  Si la configuration du référentiel Redux diffère de celle attendue, alors pour le bon fonctionnement du composant React correspondant, il suffit de spécifier l'emplacement de son état dans la hiérarchie à l'aide de la propriété getState. </p><br><h3 id="vstraivaem-react-komponent-keplergl">  Intégrer le composant KeplerGl React </h3><br><p>  Pour un rendu rapide des cartes avec un grand nombre d'éléments affichés (jusqu'à des millions de géo-points!) Kepler.gl utilise desk.gl - Framework WebGL pour la visualisation des données, et MapBox - Géo-plateforme Open Source, qui fournit une API pratique et de nombreuses possibilités pour personnaliser les cartes créées .  Par conséquent, l'un des paramètres requis transmis au composant KeplerGl est le jeton d'API pour accéder au service MapBox. </p><br><p>  Pour recevoir un token, vous devez vous inscrire sur le site <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.mapbox.com</a> .  MapBox offre un choix de plusieurs plans tarifaires différents, mais pour les petites applications, une version gratuite avec 50 000 vues par mois sera suffisante. </p><br><p>  Après avoir créé un compte, vous devez vous rendre dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la section des jetons</a> et générer une clé publique pour accéder au service. </p><br><p>  Définissez le jeton reçu sur la variable d'environnement appropriée: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> MapboxAccessToken=&lt;your_mapBox_token&gt;</code> </pre> <br><p>  Vous pouvez maintenant passer à la création d'un composant React pour afficher des informations sur les parkings payants.  Dans notre cas, ce sera juste un wrapper sur le composant KeplerGl, qui prend les dimensions de la carte comme paramètres: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> KeplerGl <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'kepler.gl'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mapboxAccessToken = process.env.MapboxAccessToken; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ParkingMap = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">KeplerGl</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"parking_map"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">mapboxApiAccessToken</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{mapboxAccessToken}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">props.width</span></span></span></span><span class="xml"><span class="hljs-tag"> } </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">height</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">props.height</span></span></span></span><span class="xml"><span class="hljs-tag"> } /&gt;</span></span></span><span class="xml"> ); export default ParkingMap;</span></span></code> </pre> <br><p>  Ajoutez ParkingMap à l'application.  À ce stade, au lieu des informations de stationnement, une carte est simplement affichée sans aucune information, car nous n'avons pas encore transmis les données sur la base desquelles nos visualisations sont construites. </p><br><h3 id="zagruzhaem-dannye-i-konfiguracii-karty">  Télécharger les configurations de données et de cartes </h3><br><p>  Pour afficher vos données sur la carte, vous devez transférer à KeplerGl l'ensemble de données sur la base duquel la carte sera créée et la configuration souhaitée de la visualisation finale.  Cela peut être fait en utilisant l'une des deux méthodes - addDataToMap ou updateVisData. </p><br><p>  La première méthode vous permet non seulement de télécharger le jeu de données nécessaire et de définir / mettre à jour complètement la configuration de l'instance correspondante du composant KeplerGl, y compris les paramètres de visualisation (visState) et la carte (mapState), ainsi que le style de la carte utilisée (mapStyle). </p><br><p>  AddDataToMap accepte un objet contenant les informations suivantes en tant que paramètre de la méthode: </p><br><ul><li>  jeux de données utilisés pour la visualisation du bâtiment </li><li>  paramètres de configuration supplémentaires (options) </li><li>  données de configuration, y compris mapState, mapStyle, visState <br><pre> <code class="javascript hljs">addDataToMap({ <span class="hljs-attr"><span class="hljs-attr">datasets</span></span>: { … } options: { … } config: { mapState { … }, mapStyle { … }, <span class="hljs-attr"><span class="hljs-attr">visState</span></span>: { … } } });</code> </pre> </li></ul><br><p>  <em><strong>Remarque</strong></em>  <em>Les données de l'objet de configuration ont toujours la priorité sur les paramètres passés dans l'objet options.</em> </p><br><p>  La méthode updateVisData permet de mettre à jour uniquement les ensembles de données utilisés sans modifier complètement la configuration du composant utilisé.  Comme paramètre, il, comme la première méthode, prend un objet qui contient des informations sur un nouvel ensemble ou des ensembles de données et le paramètre «options» pour mettre à jour certains paramètres d'affichage de la carte. </p><br><p>  <strong>Initialisation de la carte</strong> </p><br><p>  Ainsi, pour le chargement initial des données, nous avons besoin de la méthode addDataToMap.  Dans l'application de démonstration en cours de création, la base de données des parkings payants à Moscou est chargée lors du premier accès à l'application par une demande distincte.  Les données source résultantes doivent être préparées pour être téléchargées sur KeplerGl.  Pour cela, dans la plupart des cas, l'un des processeurs prédéfinis qui portent les données csv / json au format de données pris en charge par kepler.gl est suffisant. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadParkingData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">mapMode</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dispatch</span></span></span><span class="hljs-function">) =&gt;</span></span> { dispatch( requestParkingData() ); fetch(demoDataUrl) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> response.text()) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">source</span></span></span><span class="hljs-function"> =&gt;</span></span> { dispatch( getParkingData() ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = Processors.processCsvData(source); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> config = getMapConfig(mapMode); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> datasets = [{ info, data }]; dispatch( wrapTo(<span class="hljs-string"><span class="hljs-string">'parking_map'</span></span>, addDataToMap({ datasets, config }) )); }); }; }</code> </pre> <br><p>  <strong>Basculer entre les modes</strong> </p><br><p>  Pour basculer entre les modes d'affichage de la carte, nous devons définir une autre fonction d'action.  Étant donné que dans la version actuelle de KeplerGl, il n'y a pas de moyen facile de modifier uniquement la configuration de la carte sans affecter les données, la méthode addDataToMap sera également la méthode la plus appropriée pour basculer entre les modes: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toggleMapMode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">mode</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dispatch, getState</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> config = getMapConfig( mode ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> datasets = getDatasets(getState()); dispatch( wrapTo(<span class="hljs-string"><span class="hljs-string">'parking_map'</span></span>, addDataToMap({ datasets, config }) )); dispatch( setMapMode(mode) ); }; }</code> </pre> <br><p>  Le paramètre d'ensemble de données est requis. Par conséquent, chaque fois que nous basculons en mode d'affichage de carte, nous retransmettons l'ensemble de données d'origine chargé au démarrage de l'application.  Les informations de configuration de la carte seront mises à jour à chaque fois.  Dans cet article, je ne m'attarderai pas en détail sur la façon dont les méthodes d'assistance getMapConfig et getDatasets sont implémentées, dont vous pouvez vous familiariser avec le code source sur GitHub. </p><br><p>  <em><strong>Remarque</strong></em>  <em>Actuellement, l'API KeplerGl est très limitée et conçue pour les cas les plus élémentaires (ajout et mise à jour de données).</em>  <em>Dans le même temps, les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">développeurs</a> eux-mêmes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">reconnaissent</a> que la version actuelle ne fournit pas une méthode efficace pour mettre à jour uniquement les configurations ou pour les mises à jour des données en temps réel.</em>  <em>Cependant, n'oubliez pas que le projet est en cours de développement actif et qu'il y a de l'espoir pour une expansion rapide de sa fonctionnalité.</em> </p><br><h3 id="kastomiziruem-elementy-karty">  Personnaliser les éléments de la carte </h3><br><p>  KeplerGl comprend non seulement un conteneur avec géo-visualisation, mais aussi des contrôles de carte, une info-bulle, un panneau latéral pour gérer les données affichées, une boîte de dialogue pour charger les données au format csv, json ou geojson, etc.  Dans le même temps, chacun des composants répertoriés peut être facilement remplacé par sa propre version à l'aide du système d'injection de dépendance. </p><br><p>  Pour remplacer le composant de base par sa version personnalisée, il suffit: </p><br><ul><li>  importer la fabrique de composants par défaut </li><li>  définir une nouvelle usine renvoyant un composant personnalisé </li><li>  intégrer une nouvelle usine à l'aide de la méthode injectComponents </li></ul><br><p>  Dans l'application de démonstration que nous créons, nous ne voulons pas donner à l'utilisateur la possibilité de configurer indépendamment le mode d'affichage, de filtrer les données existantes ou de charger de nouvelles données. </p><br><p>  En théorie, pour cela, il suffit d'indiquer que le composant KeplerGl est en mode lecture seule, qui n'apparaissait que dans la version 0.0.27. Cependant, même dans cette version, tous les contrôles sont toujours affichés pour l'utilisateur pendant les premiers instants avant de charger la carte, puis ne se cachent que.  Pour éviter cela, nous pouvons remplacer explicitement les composants indésirables par un composant nul en utilisant la méthode injectComponents: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { injectComponents, ModalContainerFactory, SidePanelFactory, } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'kepler.gl/components'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// define null factory to don not render any unnecessary components const NullComponent = () =&gt; null; const nullComponentFactory = () =&gt; NullComponent; const KeplerGl = injectComponents([ [ModalContainerFactory, nullComponentFactory], [SidePanelFactory, nullComponentFactory], ]); export default KeplerGl;</span></span></code> </pre> <br><p>  De manière pratique, KeplerGl vous permet non seulement de remplacer des composants de base par des composants personnalisés, mais l'utilisation de la méthode withState vous permet d'ajouter des actions supplémentaires et des paramètres d'état pour les nouveaux composants. </p><br><h3 id="kak-ispolzovat-neskolko-kart-odnovremenno">  Comment utiliser plusieurs cartes à la fois </h3><br><p>  Si vous envisagez d'utiliser plusieurs composants KeplerGL différents dans la même application, chacun d'eux doit être défini dans les paramètres avec un identifiant unique nécessaire pour ajouter / mettre à jour les données et les configurations de chacune des cartes: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wrapToParking = wrapTo(<span class="hljs-string"><span class="hljs-string">' parking_map'</span></span>); dispatch( wrapToParking( addDataToMap({ datasets, config }) ));</code> </pre> <br><p>  Une alternative consiste à utiliser la fonction de connexion de Redux et la fonction forwardTo de kepler.gl.  Dans ce cas, il est assez simple pour la fonction de répartiteur correspondante de spécifier l'ID de la carte correspondante: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> KeplerGl <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'kepler.gl'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { forwardTo, toggleFullScreen } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'kepler.gl/actions'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {connect} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-redux'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MapContainer = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> ( &lt;div&gt; &lt;button onClick=() =&gt; props.keplerGlDispatch(toggleFullScreen())/&gt; &lt;KeplerGl id="foo" /&gt; &lt;/div&gt; ) const mapStateToProps = state =&gt; state const mapDispatchToProps = (dispatch, props) =&gt; ({ dispatch, keplerGlDispatch: forwardTo('foo', dispatch) });</code> </pre> <br><h3 id="zaklyuchenie">  Conclusion </h3><br><p>  KeplerGl vous permet d'ajouter des cartes interactives colorées à votre application Web React.  Grâce à l'utilisation du framework de composants desk.gl, il peut facilement afficher des millions de géo-points dans un format pratique pour les visualiser et les analyser. </p><br><p>  Les vastes possibilités de personnalisation non seulement des visualisations créées, mais aussi des styles de carte, ainsi que des formats d'interaction utilisateur, font de KeplerGl un outil très attrayant pour créer des visualisations cartographiques et des tableaux de bord complexes. </p><br><p>  Cependant, limité uniquement par les scénarios d'API de base, le traitement des données sur le client, ainsi que l'utilisation de MapBox sans la possibilité de sélectionner une autre source de carte, réduisent le nombre de projets pour lesquels cet outil peut être utilisé. </p><br><p>  Mais n'oubliez pas qu'aujourd'hui, le projet est encore très jeune et qu'il est en phase active de développement, de sorte que bon nombre de ces lacunes peuvent devenir sans objet dans un avenir proche. </p><br><h3 id="poleznye-ssylki">  Liens utiles </h3><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Code de démonstration complet</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article introductif sur Kepler.Gl sur Habr</a> </li><li>  <a href="">Dépôt Kepler.gl sur github</a> </li><li>  <a href="">La documentation officielle de kepler.gl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tutoriel Kepler.gl sur Vis.Academy [en]</a> </li></ol><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr422759/">https://habr.com/ru/post/fr422759/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr422747/index.html">Position de prise en charge officielle du cryptage fort de l'IEEE</a></li>
<li><a href="../fr422751/index.html">10 outils de diagnostic SSL / TLS gratuits pour les webmasters</a></li>
<li><a href="../fr422753/index.html">Comprendre les partitions dans PostgreSQL 9</a></li>
<li><a href="../fr422755/index.html">Le portefeuille protégera-t-il contre les affaissements cryptographiques?</a></li>
<li><a href="../fr422757/index.html">Pas de politique. Comment transformer durablement les manifestations de rue à l'aide d'une application mobile?</a></li>
<li><a href="../fr422761/index.html">Quatre façons de l'école d'analyse de données Yandex</a></li>
<li><a href="../fr422763/index.html">Événements numériques à Moscou du 10 au 16 septembre</a></li>
<li><a href="../fr422765/index.html">OpenID Connect 1.0 sur les doigts</a></li>
<li><a href="../fr422767/index.html">Conférence DEFCON 16. Fedor, InSecure.org Hacker. Analyse NMAP en ligne</a></li>
<li><a href="../fr422769/index.html">Les gagnants du Startup Battlefield TechCrunch Disrupt San Francisco 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>