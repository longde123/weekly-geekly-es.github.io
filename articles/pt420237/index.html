<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë¥üèø üë¨ ü§µüèæ Wrapper Qt em torno da estrutura gRPC em C ++ ü§πüèø üéà üë©üèø‚Äçüè´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° pessoal. Hoje, veremos como voc√™ pode vincular a estrutura gRPC em C ++ e a biblioteca Qt. O artigo fornece um c√≥digo que resume o uso de todos os...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wrapper Qt em torno da estrutura gRPC em C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420237/"><p>  Ol√° pessoal.  Hoje, veremos como voc√™ pode vincular a estrutura gRPC em C ++ e a biblioteca Qt.  O artigo fornece um c√≥digo que resume o uso de todos os quatro modos de intera√ß√£o no gRPC.  Al√©m disso, √© fornecido um c√≥digo que permite o uso de gRPC atrav√©s de sinais e slots Qt.  O artigo pode ser de interesse principalmente para desenvolvedores de Qt interessados ‚Äã‚Äãem usar o gRPC.  No entanto, uma generaliza√ß√£o dos quatro modos de opera√ß√£o do gRPC √© escrita em C ++ sem o uso do Qt, o que permitir√° que desenvolvedores n√£o relacionados ao Qt adaptem o c√≥digo.  Pe√ßo a todos os interessados ‚Äã‚Äãem gato. </p><a name="habracut"></a><br><h2>  Antecedentes </h2><br><p>  Cerca de seis meses atr√°s, dois projetos dependiam de mim, usando as partes cliente e servidor do gRPC.  Ambos os projetos ca√≠ram em produ√ß√£o.  Esses projetos foram escritos por desenvolvedores que j√° foram encerrados.  A √∫nica boa not√≠cia foi que participei ativamente da reda√ß√£o do servidor gRPC e do c√≥digo do cliente.  Mas isso foi cerca de um ano atr√°s.  Portanto, como sempre, tive que lidar com tudo do zero. </p><br><p>  O c√≥digo do servidor gRPC foi gravado com a expectativa de que ser√° gerado ainda mais pelo arquivo .proto.  O c√≥digo foi escrito bem.  No entanto, o servidor teve uma grande desvantagem: apenas um cliente p√¥de se conectar a ele. </p><br><p>  O cliente gRPC foi gravado simplesmente horr√≠vel. </p><br><p>  Eu descobri o c√≥digo de cliente e servidor gRPC apenas alguns dias depois.  E percebi que, se fizesse um projeto por algumas semanas, teria que lidar com o servidor e o cliente gRPC novamente. </p><br><p>  Foi ent√£o que decidi que era hora de escrever e depurar o cliente e o servidor gRPC para que: </p><br><ul><li><p>  Voc√™ pode dormir em paz √† noite; </p></li><li><p>  N√£o havia necessidade de lembrar como isso funciona toda vez que voc√™ precisa gravar um cliente ou servidor gRPC; </p></li><li><p>  Voc√™ pode usar o cliente e servidor gRPC gravados em outros projetos. </p></li></ul><br><p>  Ao escrever o c√≥digo, fui guiado pelos seguintes requisitos: </p><br><ul><li><p>  O cliente e o servidor gRPC podem operar usando os sinais e slots da biblioteca Qt de maneira natural; </p></li><li><p>  O c√≥digo do cliente e do servidor gRPC n√£o precisa ser corrigido ao alterar o arquivo .proto; </p></li><li><p>  O cliente gRPC deve poder informar ao c√≥digo do cliente o status da conex√£o com o servidor. </p></li></ul><br><p>  A estrutura do artigo √© a seguinte.  Primeiro, haver√° uma breve vis√£o geral dos resultados do trabalho com o c√≥digo do cliente e algumas explica√ß√µes para ele.  No final da revis√£o, um link para o reposit√≥rio.  Al√©m disso, haver√° coisas gerais sobre arquitetura.  Em seguida, uma descri√ß√£o do c√≥digo do servidor e do cliente (o que h√° sob o cap√¥) e uma conclus√£o. </p><br><h2>  Breve revis√£o </h2><br><p>  O arquivo pingproto.proto mais simples foi usado como um arquivo .proto, no qual foram definidas RPCs de todos os tipos de intera√ß√£o: </p><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">syntax</span></span> = <span class="hljs-string"><span class="hljs-string">"proto3"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">package</span></span> pingpong; <span class="hljs-attribute"><span class="hljs-attribute">service</span></span> ping { <span class="hljs-attribute"><span class="hljs-attribute">rpc</span></span> SayHello (PingRequest) returns (PingReply) {} <span class="hljs-attribute"><span class="hljs-attribute">rpc</span></span> GladToSeeMe(PingRequest) returns (stream PingReply){} <span class="hljs-attribute"><span class="hljs-attribute">rpc</span></span> GladToSeeYou(stream PingRequest) returns (PingReply){} <span class="hljs-attribute"><span class="hljs-attribute">rpc</span></span> BothGladToSee(stream PingRequest) returns (stream PingReply){} } <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> PingRequest { <span class="hljs-attribute"><span class="hljs-attribute">string</span></span> name = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">string</span></span> message = <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> PingReply { <span class="hljs-attribute"><span class="hljs-attribute">string</span></span> message = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><p>  O arquivo pingpong.proto repete o arquivo helloworld.proto do artigo sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">modos de gRPC ass√≠ncrono em C ++</a> para o nome exato. </p><br><p>  Como resultado, um servidor gravado pode ser usado assim: </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QObject { Q_OBJECT; QpingServerService pingservice; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: A() { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_ok; is_ok = connect(&amp;pingservice, SIGNAL(SayHelloRequest(SayHelloCallData*)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(onSayHello(SayHelloCallData*))); assert(is_ok); is_ok = connect(&amp;pingservice, SIGNAL(GladToSeeMeRequest(GladToSeeMeCallData*)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(onGladToSeeMe(GladToSeeMeCallData*))); assert(is_ok); is_ok = connect(&amp;pingservice, SIGNAL(GladToSeeYouRequest(GladToSeeYouCallData*)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(onGladToSeeYou(GladToSeeYouCallData*))); assert(is_ok); is_ok = connect(&amp;pingservice, SIGNAL(BothGladToSeeRequest(BothGladToSeeCallData*)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(onBothGladToSee(BothGladToSeeCallData*))); assert(is_ok); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> slots: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSayHello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SayHelloCallData* cd)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"["</span></span> &lt;&lt; cd-&gt;peer() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"][11]: request: "</span></span> &lt;&lt; cd-&gt;request.name() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; cd-&gt;reply.set_message(<span class="hljs-string"><span class="hljs-string">"hello "</span></span> + cd-&gt;request.name()); cd-&gt;Finish(); } <span class="hljs-comment"><span class="hljs-comment">//etc. };</span></span></code> </pre><br><p>  Quando um cliente chama RPC, o servidor gRPC notifica o c√≥digo do cliente (neste caso, classe A) com o sinal apropriado. </p><br><p>  O cliente gRPC pode ser usado assim: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> B : <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> QObject { Q_OBJECT QpingClientService pingPongSrv; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span>: B() { <span class="hljs-type"><span class="hljs-type">bool</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; c = <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(&amp;pingPongSrv, SIGNAL(SayHelloResponse(SayHelloCallData*)), this, SLOT(onSayHelloResponse(SayHelloCallData*))); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(c); c = <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(&amp;pingPongSrv, SIGNAL(GladToSeeMeResponse(GladToSeeMeCallData*)), this, SLOT(onGladToSeeMeResponse(GladToSeeMeCallData*))); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(c); c = <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(&amp;pingPongSrv, SIGNAL(GladToSeeYouResponse(GladToSeeYouCallData*)), this, SLOT(onGladToSeeYouResponse(GladToSeeYouCallData*))); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(c); c = <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(&amp;pingPongSrv, SIGNAL(BothGladToSeeResponse(BothGladToSeeCallData*)), this, SLOT(onBothGladToSeeResponse(BothGladToSeeCallData*))); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(c); c = <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(&amp;pingPongSrv, SIGNAL(channelStateChanged(<span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span>)), this, SLOT(onPingPongStateChanged(<span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span>))); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(c); } <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">usage</span></span>() { //Unary PingRequest request; request.set_name("user"); request.set_message("user"); pingPongSrv.SayHello(request); //<span class="hljs-keyword"><span class="hljs-keyword">Server</span></span> streaming PingRequest request2; request2.set_name("user"); pingPongSrv.GladToSeeMe(request2); //etc. } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> slots: <span class="hljs-type"><span class="hljs-type">void</span></span> SayHelloResponse(SayHelloCallData* response) { std::cout &lt;&lt; "[11]: reply: " &lt;&lt; response-&gt;reply.message() &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response-&gt;CouldBeDeleted()) <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> response; } //etc. };</code> </pre><br><p>  O cliente gRPC permite ligar diretamente para a RPC e assinar a resposta do servidor usando os sinais apropriados. </p><br><p>  O cliente gRPC tamb√©m possui um sinal: <br><br></p><pre> <code class="hljs objectivec">channelStateChanged(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>);</code> </pre><br>  que relata os status de conex√£o do servidor anteriores e atuais.  Todo o c√≥digo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">amostra</a> est√° no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">reposit√≥rio qgrpc</a> . <br><br><h2>  Como isso funciona </h2><br><p>  O princ√≠pio de incluir o cliente e o servidor gRPC no projeto √© mostrado na figura. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i3/h9/ad/i3h9ad3c3joddotb7akq1iagpnc.jpeg"></div><br><p>  No arquivo de projeto .pro, os arquivos .proto s√£o especificados, com base nos quais o gRPC funcionar√°.  O arquivo grpc.pri cont√©m comandos para gerar arquivos gRPC e QgRPC.  O compilador protoc gera arquivos gRPC [protofile] .grpc.pb.h e [protofile] .grpc.pb.cc.  [protofile] √© o nome do arquivo .proto passado para a entrada do compilador. </p><br><p>  A gera√ß√£o de arquivos QgRPC [protofile] .qgrpc. [Config] .h √© manipulada pelo script genQGrpc.py.  [config] √© "servidor" ou "cliente". <br><br>  Os arquivos QgRPC gerados cont√™m um wrapper Qt em torno das classes gRPC e chamadas com os sinais correspondentes.  Nos exemplos anteriores, as classes QpingServerService e QpingClientService s√£o declaradas respectivamente nos arquivos gerados pingpong.qgrpc.server.he pingpong.qgrpc.client.h.  Arquivos QgRPC gerados s√£o adicionados ao processamento moc. </p><br><p>  Nos arquivos QgRPC gerados, os arquivos QGrpc [config] .h est√£o inclu√≠dos, nos quais todo o trabalho principal ocorre.  Leia mais sobre isso abaixo. </p><br><p>  Para conectar toda essa constru√ß√£o ao projeto, voc√™ precisa incluir o arquivo grpc.pri no arquivo .pro do projeto e especificar tr√™s vari√°veis.  A vari√°vel GRPC define arquivos .proto que ser√£o transferidos para as entradas do compilador protoc e do script genQGrpc.py.  A vari√°vel QGRPC_CONFIG define o valor de configura√ß√£o dos arquivos QgRPC gerados e pode conter os valores "servidor" ou "cliente".  Voc√™ tamb√©m pode definir a vari√°vel opcional GRPC_VERSION para indicar a vers√£o do gRPC. </p><br><p>  Para obter mais informa√ß√µes sobre tudo o que foi dito, leia o arquivo grpc.pri e os arquivos de exemplo .pro. </p><br><h2>  Arquitetura do servidor </h2><br><p>  O diagrama de classes do servidor √© mostrado na figura. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nd/ec/ae/ndecaezqpvmh1kn9iviw6yuic9i.jpeg"></div><br><p>  As setas grossas mostram a hierarquia da heran√ßa de classe e as setas finas mostram a associa√ß√£o de membros e m√©todos nas classes.  Em geral, a classe Q [servicename] ServerService √© gerada para o servi√ßo, em que servicename √© o nome do servi√ßo declarado no arquivo .proto.  RPCCallData s√£o estruturas de controle geradas para cada RPC no servi√ßo.  No construtor da classe QpingServerService, a classe base QGrpcServerService √© inicializada com o servi√ßo ass√≠ncrono gRPC pingpong :: ping :: AsyncService.  Para iniciar o servi√ßo, voc√™ precisa chamar o m√©todo Start () com o endere√ßo e a porta na qual o servi√ßo ser√° executado.  A fun√ß√£o Start () implementa o procedimento padr√£o para iniciar um servi√ßo. </p><br><p>  No final da fun√ß√£o Start (), a fun√ß√£o virtual pura makeRequests () √© chamada, implementada na classe QpingServerService gerada: </p><br><pre> <code class="hljs xml">void makeRequests() { needAnotherCallData<span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">SayHello_RPCtypes</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">SayHelloCallData</span></span></span><span class="hljs-tag"> &gt;</span></span>(); needAnotherCallData<span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">GladToSeeMe_RPCtypes</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">GladToSeeMeCallData</span></span></span><span class="hljs-tag"> &gt;</span></span>(); needAnotherCallData<span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">GladToSeeYou_RPCtypes</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">GladToSeeYouCallData</span></span></span><span class="hljs-tag"> &gt;</span></span>(); needAnotherCallData<span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">BothGladToSee_RPCtypes</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">BothGladToSeeCallData</span></span></span><span class="hljs-tag"> &gt;</span></span>(); }</code> </pre><br><p>  O segundo par√¢metro de modelo da fun√ß√£o needAnotherCallData s√£o as estruturas RPCCallData geradas.  As mesmas estruturas s√£o os par√¢metros dos sinais na classe Qt gerada do servi√ßo. </p><br><p>  As estruturas RPCCallData geradas s√£o herdadas da classe ServerCallData.  Por sua vez, a classe ServerCallData √© herdada do respondente ServerResponder.  Assim, a cria√ß√£o de um objeto de estruturas coerentes leva √† cria√ß√£o de um objeto respondedor. </p><br><p>  O construtor da classe ServerCallData utiliza dois par√¢metros: signal_func e request_func.  signal_func √© um sinal gerado que √© chamado ap√≥s o recebimento de um tag da fila.  request_func √© uma fun√ß√£o que deve ser chamada ao criar um novo respondedor.  Por exemplo, nesse caso, pode ser a fun√ß√£o RequestSayHello ().  A chamada request_func ocorre na fun√ß√£o needAnotherCallData ().  Isso √© feito para que o gerenciamento dos respondentes (cria√ß√£o e exclus√£o) ocorra no servi√ßo. </p><br><p>  O c√≥digo da fun√ß√£o needAnotherCallData () consiste em criar um objeto de resposta e chamar uma fun√ß√£o que conecta o respondente a uma chamada RPC: </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RPCCallData</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RPCTypes</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">needAnotherCallData</span></span></span><span class="hljs-class">() {</span></span> RPCCallData* cd = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RPCCallData(); <span class="hljs-comment"><span class="hljs-comment">//... RequestRPC&lt;RPCTypes::kind, ...&gt; (service_, cd-&gt;request_func_, cd-&gt;responder, ..., (void*)cd); }</span></span></code> </pre><br><p>  As fun√ß√µes RequestRPC () s√£o fun√ß√µes de modelo para quatro tipos de intera√ß√£o.  Como resultado, chamar RequestRPC () se resume a uma chamada: </p><br><pre> <code class="hljs lisp">service_-&gt;(<span class="hljs-name"><span class="hljs-name">cd-&gt;request_func_</span></span>)(...,cd-&gt;responder, (<span class="hljs-name"><span class="hljs-name">void*</span></span>)cd)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br><p>  onde service_ √© o servi√ßo gRPC.  Nesse caso, √© pingpong :: ping :: AsyncService. </p><br><p>  Para verificar de forma s√≠ncrona ou ass√≠ncrona a fila de eventos, voc√™ deve chamar as fun√ß√µes CheckCQ () ou AsyncCheckCQ (), respectivamente.  O c√≥digo da fun√ß√£o CheckCQ () se resume a chamadas para o tag s√≠ncrono da fila e o processamento desse tag: </p><br><pre> <code class="hljs pgsql">virtual <span class="hljs-type"><span class="hljs-type">void</span></span> CheckCQ() override { <span class="hljs-type"><span class="hljs-type">void</span></span>* tag; <span class="hljs-type"><span class="hljs-type">bool</span></span> ok; server_cq_-&gt;Next(&amp;tag, &amp;ok); //tagActions_ <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!tag) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; AbstractCallData* cd = (AbstractCallData*)tag; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!started_.<span class="hljs-keyword"><span class="hljs-keyword">load</span></span>()) { destroyCallData(cd); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } cd-&gt;cqReaction(this, ok); }</code> </pre><br><p>  Depois de receber a tag da fila, a validade da tag e o in√≠cio do servidor s√£o verificados.  Se o servidor estiver desligado, a tag n√£o ser√° mais necess√°ria - ela poder√° ser exclu√≠da.  Depois disso, a fun√ß√£o cqReaction () definida na classe ServerCallData √© chamada: </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cqReaction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QGrpcServerService* service_, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ok)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!first_time_reaction_) { first_time_reaction_ = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; service_-&gt;needAnotherCallData&lt;RPC, RPCCallData&gt;(); } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> genRpcCallData = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;RPCCallData*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* tag = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*&gt;(genRpcCallData); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;CouldBeDeleted()) { service_-&gt;destroyCallData(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;processEvent(tag, ok)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">//call generated service signal with generated call data argument service_-&gt;(*signal_func_)(genRpcCallData); }</span></span></code> </pre><br><p>  O sinalizador first_time_reaction_ indica que voc√™ precisa criar um novo respondedor para o RPC chamado.  As fun√ß√µes CouldBeDeleted () e ProcessEvent () s√£o herdadas da classe de resposta ServerResponder correspondente.  A fun√ß√£o CouldBeDeleted () retorna um sinal de que o objeto respondedor pode ser exclu√≠do.  A fun√ß√£o processEvent () processa a tag e o sinalizador ok.  Assim, por exemplo, para um respondedor de tipo de fluxo de cliente, a fun√ß√£o se parece com: </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* tag, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ok</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;tag_ = tag; read_mode_ = ok; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br><p>  A fun√ß√£o ProcessEvent (), independentemente do tipo de resposta, sempre retorna true.  O valor de retorno dessa fun√ß√£o √© deixado para uma poss√≠vel extens√£o de funcionalidade e, teoricamente, para eliminar erros. </p><br><p>  Ap√≥s o processamento do evento, a chamada a seguir: <br><br></p><pre> <code class="hljs lisp">service_-&gt;(<span class="hljs-name"><span class="hljs-name">*signal_func_</span></span>)(<span class="hljs-name"><span class="hljs-name">genRpcCallData</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br><p>  A vari√°vel service_ √© uma inst√¢ncia do servi√ßo gerado, no nosso caso QpingServerService.  A vari√°vel signal_func_ √© um sinal de servi√ßo correspondente a um RPC espec√≠fico.  Por exemplo, SayHelloRequest ().  A vari√°vel genRpcCallData √© um objeto de resposta do tipo correspondente.  Do ponto de vista do c√≥digo de chamada, a vari√°vel genRpcCallData √© um objeto de uma das estruturas RPCCallData geradas. <br></p><br><h2>  Arquitetura do cliente </h2><br><p>  Sempre que poss√≠vel, os nomes das classes e fun√ß√µes do cliente correspondem aos nomes das classes e fun√ß√µes do servidor.  O diagrama de classes do cliente √© mostrado na figura. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4u/ak/xe/4uakxee1iettn1zm_7fooerdosc.jpeg"></div><br><p>  As setas grossas mostram a hierarquia da heran√ßa de classe e as setas finas mostram a associa√ß√£o de membros e m√©todos nas classes.  Em geral, para o servi√ßo, √© gerada a classe Q [servicename] ClientService, em que servicename √© o nome do servi√ßo declarado no arquivo .proto.  RPCCallData s√£o estruturas de controle geradas para cada RPC no servi√ßo.  Para chamar um RPC, a classe gerada fornece fun√ß√µes cujos nomes correspondem exatamente ao RPC declarado no arquivo .proto.  No nosso exemplo, no arquivo .proto RPC, SayHello () √© declarado como: <br><br></p><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">rpc </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SayHello</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PingRequest</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PingReply</span></span></span><span class="hljs-function">)</span></span> {}</code> </pre><br><p>  Na classe QpingClientService gerada, a fun√ß√£o RPC correspondente √© semelhante a esta: </p><br><pre> <code class="hljs vbscript">void SayHello(PingRequest <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!connected()) return; SayHelloCallData* <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SayHelloCallData; <span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;<span class="hljs-built_in"><span class="hljs-built_in">request</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;responder = stub_-&gt;AsyncSayHello(&amp;<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;context, <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>, &amp;cq_); <span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;responder-&gt;Finish(&amp;<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;reply, &amp;<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;status, (void*)<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>); }</code> </pre><br><p>  As estruturas RPCCallData geradas, como no caso do servidor, s√£o finalmente herdadas da classe ClientResponder.  Portanto, a cria√ß√£o de um objeto da estrutura gerada leva √† cria√ß√£o de um respondedor.  Ap√≥s criar o respondedor, o RPC √© chamado e o respondedor √© associado ao evento de recebimento de uma resposta do servidor.  Em termos de c√≥digo do cliente, uma chamada RPC √© assim: </p><br><pre> <code class="hljs vbscript">void ToSayHello() { PingRequest <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>.set_name(<span class="hljs-string"><span class="hljs-string">"user"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>.set_message(<span class="hljs-string"><span class="hljs-string">"user"</span></span>); pingPongSrv.SayHello(<span class="hljs-built_in"><span class="hljs-built_in">request</span></span>); }</code> </pre><br><p>  Diferentemente da classe de servidor QpingServerService gerada, a classe QpingClientService herda de duas classes de modelo: ConnectivityFeatures e MonitorFeatures. </p><br><p>  A classe ConnectivityFeatures √© respons√°vel pelo status da conex√£o do cliente com o servidor e fornece tr√™s fun√ß√µes para uso: grpc_connect (), grpc_disconnect (), grpc_reconnect ().  A fun√ß√£o grpc_disconnect () simplesmente remove todas as estruturas de dados respons√°veis ‚Äã‚Äãpela intera√ß√£o com o servidor.  A chamada para grpc_connect √© reduzida para chamadas para a fun√ß√£o grpc_connect_ (), que cria estruturas de dados de controle: </p><br><pre> <code class="hljs php">void grpc_connect_() { channel_ = grpc::CreateChannel(target_, creds_); stub_ = GRPCService::NewStub(channel_); channelFeatures_ = std::make_unique&lt;ChannelFeatures&gt;(channel_); channelFeatures_-&gt;checkChannelState(); }</code> </pre><br><p>  A classe ChannelFeatures monitora o status da comunica√ß√£o <em>channel_</em> channel com o servidor.  A classe ConnectivityFeatures encapsula um objeto da classe ChannelFeatures e implementa as fun√ß√µes abstratas channelState (), checkChannelState () e conectado () usando este objeto.  A fun√ß√£o channelState () retorna o √∫ltimo estado observado do canal de comunica√ß√£o com o servidor.  A fun√ß√£o checkChannelState (), de fato, retorna o estado atual do canal.  A fun√ß√£o connected () retorna o sinal do cliente se conectando ao servidor. <br></p><br><p>  A classe MonitorFeatures √© respons√°vel por receber e processar eventos do servidor e fornece a fun√ß√£o CheckCQ () para uso: </p><br><pre> <code class="hljs ruby">bool CheckCQ() { auto service<span class="hljs-number"><span class="hljs-number">_</span></span> = dynamic_cast&lt; SERVICE* &gt;(this); <span class="hljs-regexp"><span class="hljs-regexp">//connection</span></span> state auto old_state = conn<span class="hljs-number"><span class="hljs-number">_</span></span>-&gt;channelState(); auto new_state = conn<span class="hljs-number"><span class="hljs-number">_</span></span>-&gt;checkChannelState(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (old_state != new_state) service-&gt;*channelStateChangedSignal<span class="hljs-number"><span class="hljs-number">_</span></span>(old_state, new_state); <span class="hljs-regexp"><span class="hljs-regexp">//end</span></span> of connection state void* tag; bool ok = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; grpc::CompletionQueue::NextStatus st; st = cq<span class="hljs-number"><span class="hljs-number">_</span></span>.AsyncNext(&amp;tag, &amp;ok, deadlineFromMSec(<span class="hljs-number"><span class="hljs-number">100</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((st == grpc::CompletionQueue::SHUTDOWN) <span class="hljs-params"><span class="hljs-params">||</span></span> (st == grpc::CompletionQueue::TIMEOUT)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; (AbstractCallData&lt; SERVICE &gt;*)(tag)-&gt;cqActions(service<span class="hljs-number"><span class="hljs-number">_</span></span>, ok); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br><p>  A estrutura do c√≥digo √© a mesma do caso do servidor.  Diferentemente do servidor, um bloco de c√≥digo respons√°vel pelo processamento do estado atual √© adicionado ao cliente.  Se o estado do canal de comunica√ß√£o mudou, o sinal channelStateChangedSignal_ () √© chamado.  Em todos os servi√ßos gerados, este √© um sinal: <br><br></p><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">channelStateChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  Al√©m disso, ao contr√°rio do servidor, a fun√ß√£o AsyncNext () √© usada aqui em vez de Next ().  Isso foi feito por v√°rias raz√µes.  Primeiramente, ao usar o AsyncNext (), o c√≥digo do cliente pode aprender sobre a altera√ß√£o no estado do canal de comunica√ß√£o.  Em segundo lugar, ao usar AsyncNext (), √© poss√≠vel chamar v√°rios RPCs no c√≥digo do cliente v√°rias vezes.  O uso da fun√ß√£o Next () nesse caso bloquear√° o encadeamento at√© que um evento seja recebido da fila e, como resultado, perder√° os dois recursos descritos. <br><br><p>  Depois de receber o evento da fila, como no caso do servidor, a fun√ß√£o cqReaction (), definida na classe ClientCallData, √© chamada: </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cqActions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RPC::Service* service, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ok)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;RPCCallData*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* tag = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*&gt;(response); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;processEvent(tag, ok)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; service-&gt;*func_( response ); }</code> </pre><br><p>  Assim como no servidor, a fun√ß√£o processEvent () processa a tag e o sinalizador ok e sempre retorna true.  Como no caso do servidor, ap√≥s o processamento do evento, o sinal do servi√ßo gerado deve ser chamado.  No entanto, existem duas diferen√ßas significativas em rela√ß√£o √† fun√ß√£o do servidor com o mesmo nome.  A primeira diferen√ßa √© que os respondedores n√£o s√£o criados nessa fun√ß√£o.  A cria√ß√£o de respondedores, como mostrado acima, ocorre quando o RPC √© chamado.  A segunda diferen√ßa √© que os respondedores n√£o s√£o exclu√≠dos nesta fun√ß√£o.  A aus√™ncia da remo√ß√£o dos respondedores √© feita por dois motivos.  Primeiro, o c√≥digo do cliente pode usar ponteiros para gerar estruturas RPCCallData para seus pr√≥prios prop√≥sitos.  A exclus√£o de conte√∫do por esse ponteiro, oculta do c√≥digo do cliente, pode levar a conseq√º√™ncias desagrad√°veis.  Em segundo lugar, a remo√ß√£o do respondedor levar√° ao fato de que um sinal com dados n√£o ser√° gerado.  Portanto, o c√≥digo do cliente n√£o receber√° a √∫ltima mensagem do servidor.  Entre v√°rias alternativas para solucionar os problemas indicados, foi tomada a decis√£o de mudar a remo√ß√£o do respondedor (estruturas geradas) para o c√≥digo do cliente.  Portanto, as fun√ß√µes do manipulador de sinal (slots) devem conter o seguinte c√≥digo: </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResponseHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RPCCallData* response)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response-&gt;CouldBeDeleted()) <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> response; <span class="hljs-comment"><span class="hljs-comment">//process response }</span></span></code> </pre><br><p>  A aus√™ncia da remo√ß√£o do respondedor no c√≥digo do cliente levar√° n√£o apenas a um vazamento de mem√≥ria, mas tamb√©m a poss√≠veis problemas com o canal de comunica√ß√£o.  Manipuladores de sinais de todos os tipos de intera√ß√µes RPC s√£o implementados no c√≥digo de exemplo. </p><br><h2>  Conclus√£o </h2><br><p>  Concluindo, chamamos aten√ß√£o para dois pontos.  O primeiro ponto est√° relacionado √† chamada das fun√ß√µes CheckCQ () do cliente e servidor.  Eles funcionam, como mostrado acima, de acordo com um princ√≠pio: se houver um evento na fila, um sinal com a estrutura RPCCallData gerada correspondente ser√° "emitido".  Voc√™ pode chamar essa fun√ß√£o manualmente e verificar (no caso de um cliente) por um evento.  Mas, inicialmente, havia uma ideia de transferir toda a parte da rede associada ao gRPC para outro encadeamento.  Para esses prop√≥sitos, as classes auxiliares QGrpcSrvMonitor para o servidor gRPC e QGrpcCliServer para o cliente gRPC foram gravadas.  Ambas as classes funcionam com o mesmo princ√≠pio: elas criam um fluxo separado, colocam o servi√ßo gerado nesse fluxo e chamam periodicamente a fun√ß√£o CheckCQ () desse servi√ßo.  Portanto, ao usar as duas classes auxiliares, n√£o h√° necessidade de chamar fun√ß√µes CheckCQ () no c√≥digo do cliente.  Os sinais do servi√ßo gerado, neste caso, "v√™m" de outro fluxo.  Exemplos de cliente e servidor s√£o implementados usando essas classes auxiliares. </p><br><p>  O segundo ponto diz respeito √† maioria dos desenvolvedores que n√£o usam a biblioteca Qt em seus trabalhos.  As classes e macros Qt no QgRPC s√£o usadas apenas em dois locais: nos arquivos de servi√ßo gerados e nos arquivos que cont√™m classes auxiliares: QGrpcServerMonitor.he QGrpcClientMonitor.h.  Os arquivos restantes com a biblioteca Qt n√£o est√£o de forma alguma associados.  Foi planejado adicionar montagem usando cmake e remover algumas diretivas de Qt.  Em particular, a classe QObject e a macro Q_OBJECT.  Mas as m√£os simplesmente n√£o chegaram a isso.  Portanto, todas as sugest√µes s√£o bem-vindas. </p><br><p>  S√≥ isso.  Obrigado a todos! </p><br><h2>  Refer√™ncias </h2><br><ul><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Reposit√≥rio com C√≥digo QgRPC</a> </p></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GRPC ass√≠ncrono em C ++</a> </p></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt420237/">https://habr.com/ru/post/pt420237/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt420225/index.html">Melodia Algor√≠tmica Infinita Baseada em N√∫meros Primos</a></li>
<li><a href="../pt420227/index.html">Presidente turco anuncia proibi√ß√£o de importa√ß√£o de eletr√¥nicos nos EUA</a></li>
<li><a href="../pt420229/index.html">As crian√ßas das aldeias podem se tornar programadores se, nas proximidades, ensinarem apenas ferrovi√°rios. Conversa com o "C√≠rculo"</a></li>
<li><a href="../pt420233/index.html">UE4 Equipamento para Multiplayer # 5 | Transfer√™ncia de informa√ß√µes entre servidor e cliente</a></li>
<li><a href="../pt420235/index.html">Zenject: Como um cont√™iner de IoC pode matar a inje√ß√£o de depend√™ncia em seu projeto</a></li>
<li><a href="../pt420239/index.html">Desenvolvimento m√≥vel. Swift: o mist√©rio dos protocolos</a></li>
<li><a href="../pt420243/index.html">Filantropia inovadora: Projetos de inova√ß√£o humanit√°ria</a></li>
<li><a href="../pt420245/index.html">Como evitar a satura√ß√£o de mem√≥ria ao usar cole√ß√µes Java</a></li>
<li><a href="../pt420251/index.html">Apple afirma que o complexo da sede da empresa custa apenas US $ 200</a></li>
<li><a href="../pt420253/index.html">Como as APIs de bancos abertos est√£o mudando o mundo financeiro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>