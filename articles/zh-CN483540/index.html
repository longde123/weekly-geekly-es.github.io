<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎤 👩🏼‍🤝‍👨🏻 ♨️ ChaiScript-C ++脚本语言 👨‍🔧 👼🏿 🚵🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="当需要在C ++项目中嵌入脚本语言时，大多数人记得的第一件事就是Lua。 在本文中，我不会再谈论另一种同样便捷且易学的语言，称为ChaiScript。 



 简短介绍 
 当我观看语言的创建者之一Jason Turner的其中一场演讲时，我自己偶然发现了ChaiScript。 它引起了我的兴趣，...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ChaiScript-C ++脚本语言</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483540/"> 当需要在C ++项目中嵌入脚本语言时，大多数人记得的第一件事就是Lua。 在本文中，我不会再谈论另一种同样便捷且易学的语言，称为ChaiScript。 <br><br><img src="https://habrastorage.org/webt/zh/vl/py/zhvlpyg_87wuf7gg0alk-s7qeyo.png" alt="图片"><br><a name="habracut"></a><br><h4> 简短介绍 </h4><br> 当我观看语言的创建者之一Jason Turner的其中一场<a href="https://youtu.be/uzF4u9KgUWI">演讲</a>时，我自己偶然发现了ChaiScript。 它引起了我的兴趣，当需要在项目中选择脚本语言时，我决定-为什么不尝试ChaiScript？ 结果使我感到惊喜（我的个人经历将在本文结尾处写），但是，无论听起来多么奇怪，枢纽中都没有哪一篇文章以某种方式提到了这种语言，因此我决定写关于他的事会很高兴。 当然，该语言有<a href="">文档</a>和一个<a href="http://chaiscript.com/">官方网站</a> ，但是并非所有人都会从观察中阅读该语言，并且文章的格式更接近于许多人（包括我）。 <br><br> 首先，我们将讨论该语言的语法及其所有功能，然后讨论如何在您的C ++项目中实现该语言，最后，我会谈一些我的经验。 如果您的某些部分不感兴趣，或者您想以不同的顺序阅读文章，则可以使用目录： <br><br><ul><li>  <a href="https://habr.com/ru/post/483540/">ChaiScript语法</a> </li><li>  <a href="https://habr.com/ru/post/483540/">用C ++实现</a> </li><li>  <a href="https://habr.com/ru/post/483540/">个人经历</a> </li></ul><br><a name="syntax"></a><br><h2> 语言语法 </h2><br>  ChaiScript的语法与C ++和JS非常相似。 首先，它像绝大多数脚本语言一样是动态类型的，但是，与JavaScript不同，它具有严格的类型（没有<code>1 + "2"</code> ）。 还有一个内置的垃圾收集器，该语言是完全可解释的，允许您逐行执行代码，而无需编译为字节码。 它支持异常（此外，联合，允许您在脚本和C ++中捕获它们），lambda函数，运算符重载。 它对空格不敏感，允许您通过分号或python样式以单行形式编写，并用新行分隔表达式。 <br><br><h4> 原始类型 </h4><br> 默认情况下，ChaiScript将整数变量存储为int，实数作为double以及带有std :: string的字符串。 这样做主要是为了确保与调用代码的兼容性。 该语言甚至都有数字后缀，因此我们可以明确指出变量的类型： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/*   chaiscript    js    ,  var / auto `;`      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myInt = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">// int var myLongLong = 1ll // long long int var myFloating = 3.3 // double var myBoolean = false // bool var myString = "hello world!\n" // std::string</span></span></code> </pre><br> 更改变量的类型实际上是行不通的，很可能您需要为这些类型定义自己的`=`运算符，否则，您可能会抛出异常（稍后再讨论）或成为舍入的受害者，如下所示： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> integer = <span class="hljs-number"><span class="hljs-number">3</span></span> integer = <span class="hljs-number"><span class="hljs-number">5.433</span></span> print(integer) <span class="hljs-comment"><span class="hljs-comment">//  5    double    int! integer = true //   -   `=`  (int, bool)</span></span></code> </pre><br> 但是，您可以在不给变量赋值的情况下声明变量，在这种情况下，变量将包含一种未定义的变量，直到为其分配了值。 <br><br><h4> 内联容器 </h4><br> 该语言有两个容器-矢量和地图。 它们的工作方式与C ++中的类似物非常相似（分别为std :: vector和std :: map），但是它们不需要类型，因为它们可以存储任何类型。 可以像往常一样使用int进行索引，但是Map需要带有字符串的键。 显然是受python启发的，作者还添加了使用以下语法在代码中快速声明容器的功能： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = [ <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>u, <span class="hljs-number"><span class="hljs-number">4</span></span>ll, <span class="hljs-string"><span class="hljs-string">"16"</span></span>, <span class="hljs-string"><span class="hljs-string">`+`</span></span> ] <span class="hljs-comment"><span class="hljs-comment">//      var m = [ "key1" : 1, "key2": "Bob" ]; //    - var M = Map() //    var V = Vector() //    //        C++ : v.push_back(123) //    ,     v.push_back_ref(m); // m -   //      m["key"] = 3 //       (reference assignment): m["key"] := m //      </span></span></code> </pre><br> 除了迭代器外，这两个类几乎都完全重复了C ++中的对应类，因为除了它们之外，还有特殊的类Range和Const_Range。 顺便说一句，即使您通过=使用分配，所有容器也都通过引用传递，这对我来说很奇怪，因为对于所有其他类型，都会发生按值复制。 <br><br><h4> 条件构造 </h4><br> 条件和周期的几乎所有构造都可以用字面上的一个示例代码来描述： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-comment"><span class="hljs-comment">//  if-else if (a &gt; b) { print("a &gt; b") } else if (a == b){ print("a == b") } else { print("a &lt; b") } // switch -    if- //      //  break    ,    C++ var str = "hello" switch(str) { case("hi") { print("hi!"); break; } case("hello") { print("hello!" break; } case("bye") { print("bye-bye!") break; } default { print("what have you said?") } } var x = true //     ,       while (x) { print("x was true") x = false; } //    C.        ,    ,    ,    for (var i = 0; i &lt; 10; ++i) //   -,    { print(i); //  0 ... 9  10  } // ranged-for loop for(element : [1, 2, 3, 4, 5]) { puts(element) //   12345 } //  :   C++17 if-init statements: if(var x = get_value(); x &lt; 10) { print(x) // x     if }</span></span></code> </pre><br> 我认为熟悉C ++的人们没有发现任何新东西。 这并不奇怪，因为ChaiScript被定位为“学习者”学习的一种简便语言，因此借鉴了所有著名的古典设计。 如果您真的很喜欢auto的优点，作者决定甚至突出显示两个用于声明变量的关键字<code>var</code>和auto。 <br><br><h4> 执行上下文 </h4><br>  ChaiScript具有本地和全局上下文。 该代码从上到下逐行执行，但是可以在函数中取出并稍后调用（但不能更早！）。 默认情况下，从外部看不到在函数或条件/循环内部声明的变量，但是您可以使用<code>global</code>标识符而不是<code>var</code>更改此行为。 全局变量与普通变量的不同之处在于，首先，它们在局部上下文之外可见，其次，可以重新声明（如果在重新声明期间未设置该值，则它保持不变） <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     chaiscript def foo(x) { global G = 2 print(x) } foo(0) //  foo(x), G = 2 print(G) //  2 global G = 3 //  G = 3,   global -  !</span></span></code> </pre><br> 顺便说一句，如果您有一个变量，并且需要检查是否为其分配了值，请使用<code>is_var_undef</code>内置函数，如果未定义该变量，则该函数返回true。 <br><br><h4> 字符串插值 </h4><br> 可以使用<code>${object}</code>语法将<code>to_string()</code>了<code>to_string()</code>方法的基础对象或用户对象放入字符串中。 这样可以避免不必要的字符串连接，并且通常看起来更加整洁： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-comment"><span class="hljs-comment">//  sum of 3 + 4 = 7 print("sum of ${x} + ${y} = ${x + y}")</span></span></code> </pre><br>  Vector，Map，MapPair和所有原语也支持此功能。 向量以<code>[o1, o2, ...]</code>格式显示，映射为<code>[&lt;key1, val1&gt;, &lt;key2, val2&gt;, ...]</code>和MapPair： <code>&lt;key, val&gt;</code> 。 <br><br><h4> 功能及其细微差别 </h4><br>  ChaiScript函数是与其他所有对象一样的对象。 它们可以被捕获，分配给变量，嵌套在其他函数中并作为参数传递。 同样，对于它们，您可以指定输入值的类型（这是动态键入的语言所缺少的！），为此，您需要在声明函数参数之前指定类型。 如果在调用时可以将参数转换为指定的参数，则将根据C ++规则进行转换，否则将引发异常： <br><br><pre> <code class="javascript hljs">def adder(int x, int y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y } def adder(bool x, bool y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x || y } adder(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-comment"><span class="hljs-comment">// ,  3 adder(1.22, -3.7) // ,  1 + (-3) = 2 adder(true, true) // ,  true adder(true, 3) // ,    adder(bool, int)</span></span></code> </pre><br> 语言功能也可以设置呼叫条件（呼叫保护）。 如果不遵守，则会引发异常，否则将进行调用。 我还注意到，如果函数的末尾没有return语句，则将返回最后一个表达式。 小例程非常方便： <br><br><pre> <code class="javascript hljs">def div(x, y) : y != <span class="hljs-number"><span class="hljs-number">0</span></span> { x / y } <span class="hljs-comment"><span class="hljs-comment">//  `y`    -    `x`  `y` print(div(2, 0.5)) //  4.0 print(div(2, 0)) // , `y`  0!</span></span></code> </pre><br><h4> 类和Dynamic_Object </h4><br>  ChaiScript具有OOP的基础知识，如果您需要操作复杂的对象，这是绝对的优势。 该语言具有特殊类型-Dynamic_Object。 实际上，所有类和名称空间的实例都是具有预定义属性的Dynamic_Object。 动态对象允许您在脚本执行期间向其添加字段，然后访问它们： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = Dynamic_Object(); obj.x = <span class="hljs-number"><span class="hljs-number">3</span></span>; obj.f = fun(arg) { print(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x + arg); } <span class="hljs-comment"><span class="hljs-comment">//  obj   f (     `x` obj.f(-3); //  0</span></span></code> </pre><br> 类的定义非常简单。 可以将它们设置为字段，方法，构造函数。 从有趣的<code>set_explicit(object, value)</code>通过特殊功能<code>set_explicit(object, value)</code>可以通过在类声明后禁止添加新方法或属性来“固定”对象的字段（通常在构造函数中完成）： <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id; <span class="hljs-comment"><span class="hljs-comment">//  id def Widget() { this.id= 0 } //    def Widget(id) { this.id = id } //   1  def get_id() { id } //   } var w = Widget(10) print(w.get_id()) //  10 (w.id) print(w.get_id) //   10,        set_explicit(w, true) //    wx = 3 //      Widget   x</span></span></code> </pre><br> 重要的一点-实际上，类方法只是函数，其第一个参数是具有明确指定类型的类的对象。 因此，以下代码等效于向现有类添加方法： <br><br><pre> <code class="javascript hljs">def set_id(Widget w, id) { w.id = id } w.set_id(<span class="hljs-number"><span class="hljs-number">9</span></span>) <span class="hljs-comment"><span class="hljs-comment">// w.id = 9 set_id(w, 9) //  , w.id = 9</span></span></code> </pre><br> 熟悉C＃的任何人都可以痛苦地替换看起来像扩展方法的东西，并且会接近事实。 因此，使用该语言，您甚至可以为内置类（例如，字符串或int）添加新功能。 作者还提供了一种使运算符重载的棘手方法：要做到这一点，您需要用波浪号（`）包围运算符，如下例所示： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   +     Widget def `+`(Widget w1, Widget w2) { print("merging two widgets!") } var widget1 = Widget() var widget2 = Widget() widget1 + widget2 //      //        : var plus = `+` print(plus(1, 7)) //  8</span></span></code> </pre><br><h4> 命名空间 </h4><br> 说到ChaiScript中的名称空间，应该牢记这些本质上是始终在全局上下文中的类。 您可以使用<code>namespace(name)</code>函数创建它们，然后添加必要的函数和类。 默认情况下，没有该语言的库，但是您可以使用扩展来安装它们，我们将在稍后讨论。 通常，名称空间初始化可能看起来像这样： <br><br><pre> <code class="javascript hljs">namespace(<span class="hljs-string"><span class="hljs-string">"math"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//    math //   math.square = fun(x) { x * x } math.hypot_squared= fun(x, y) { math.square(x) + math.square(y) } print(math.square(4)) //  16 print(math.hypot_squared(3, 4)) //  25</span></span></code> </pre><br><h4>  Lambda表达式和其他功能 </h4><br>  ChaiScript中的Lambda表达式类似于我们从C ++知道的表达式。 他们使用<b>fun</b>关键字，它们还需要显式指定捕获的变量，但是它们始终通过引用来执行。 该语言还具有绑定函数，可让您将值绑定到函数参数： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> func_object = fun(x) { x * x } func_object(<span class="hljs-number"><span class="hljs-number">9</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  81 var name = "John" var greet = fun[name]() { "Hello, " + name } print(greet()) //  Hello, John name = "Bob" print(greet()) //  Hello, Bob var message = bind(fun(msg, name) { msg + " from " + name }, _, "ChaiScript"); print(message("Hello")) //  Hello from ChaiScript</span></span></code> </pre><br><h4> 例外情况 </h4><br> 在脚本执行过程中可能会发生异常。 它们可以在ChaiScript本身（我们将在这里讨论）和C ++中进行拦截。 语法与加号绝对相同，甚至可以抛出数字或字符串： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(x + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// x   } catch (e) { print("Error during evaluation")) } //   C++   ChaiScript //   Vector -   std::vector,    std::exception      try { var vec = [1, 2] var val = vec[3] //     } catch (e) { print("index out of range: " + e.what()); // e.what    ChaiScript } //  atch   guard     ,    `:` try { throw(5.2) } catch(e) : is_type(e, "int") { print("Int: ${e}"); //   `e`  int } catch(e) : is_type(e, "double") { print("Double: ${e}"); //  `e`  double }</span></span></code> </pre><br> 以一种好的方式，您应该定义异常类并将其抛出。 在第二部分中，我们将讨论如何在C ++中对其进行拦截。 对于解释器异常，ChaiScript抛出其异常，例如eval_error，bad_boxed_cast等。 <br><br><h4> 解释器常量 </h4><br> 令我惊讶的是，该语言竟然是某种编译器宏-它们只有4个，它们全部用于标识上下文，并且主要用于错误处理： <br><div class="scrollable-table"><table><tbody><tr><td>  __LINE__ </td><td> 当前行，如果未从文件执行代码，则为“ 1” </td></tr><tr><td>  __FILE__ </td><td> 当前文件，如果未从文件中调用代码，则为“ __EVAL__” </td></tr><tr><td>  __CLASS__ </td><td> 当前课程或“ NOT_IN_CLASS” </td></tr><tr><td>  __功能__ </td><td> 当前函数或“ NOT_IN_FUNCTION” </td></tr></tbody></table></div><br><h4> 错误陷阱 </h4><br> 如果尚未声明要调用的函数，则会引发异常。 如果这对您来说不可接受，则可以定义一个特殊函数<code>method_missing(object, func_name, params)</code> ，如果发生错误，将使用相应的参数调用该函数： <br><br><pre> <code class="javascript hljs">def method_missing(Widget w, string name, Vector v) { print(<span class="hljs-string"><span class="hljs-string">"widget method ${name} with params {v} was not found"</span></span>) } w = Widget() w.invoke_error(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  widget method invoke_error with params [1, 2, 3] was not found</span></span></code> </pre><br><h4> 内建功能 </h4><br>  ChaiScript定义了许多内置函数，在本文中，我想谈一谈特别有用的函数。 其中： <code>eval(str)</code> ， <code>eval_file(filename)</code> ， <code>to_json(object)</code> ， <code>from_json(str)</code> ： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(<span class="hljs-string"><span class="hljs-string">"x * y"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// res = 15,  eval     //     : //  eval_file eval_file("source.chai") //   use,  ,         use("source.chai") // to_json    Map    var w = Widget(0) var j = to_json(w) // j = "{ "id" : 0 }" // from_json    Map ( ,   ) var m = from_json(" { "x": 0, "y": 3, "z": 2 }") print(m) //  Map  [&lt;x, 0&gt;, &lt;y, 3&gt;, &lt;z, 2&gt;]</span></span></code> </pre><br><a name="cppchai"></a><br><h2> 用C ++实现 </h2><br><h4> 安装方式 </h4><br>  ChaiScript是一个基于C ++模板的仅标头库。 因此，对于安装，您只需要制作一个克隆<a href="https://github.com/ChaiScript/ChaiScript">存储库</a>或将所有来自<a href="https://github.com/ChaiScript/ChaiScript/tree/develop/include/chaiscript">此文件夹的文件</a>放入您的项目中。 由于根据IDE的不同，所有这些操作都有不同的方式，并且已经在论坛上进行了很长时间的详细描述，因此，我们假定您已成功连接该库，并编译了包含<code>#include &lt;chaiscript/chaiscript.hpp&gt;</code>的代码。 <br><br><h4>  C ++代码调用和脚本加载 </h4><br> 使用ChaiScript的最小示例代码如下所示。 我们在C ++中定义一个简单的函数，该函数采用std :: string并返回更改后的字符串，然后在ChaiScript对象中添加指向它的链接以进行调用。 编译可能要花费大量时间，但这主要是因为为编译器实例化大量模板并不容易： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include &lt;chaiscript/chaiscript.hpp&gt; std::string greet_name(const std::string&amp; name) { return "hello, " + name; } int main() { chaiscript::ChaiScript chai; //  chaiscript chai.add(chaiscript::fun(&amp;greet_name), "greet"); //    greet //  eval      chai.eval(R"( print(greet("John")); )"); }</span></span></span></span></code> </pre> <br> 希望您成功了，并且您看到了函数的结果。 我想立即注意一个细微差别-如果您将ChaiScript对象声明为静态对象，则会遇到令人不愉快的运行时错误。 这是因为该语言默认情况下支持多线程，并存储在其析构函数中访问的本地流变量。 但是，它们在调用静态实例的析构函数之前已被销毁，因此，我们遇到访问冲突或分段错误错误。 基于<a href="https://github.com/ChaiScript/ChaiScript/issues/338">github</a>上的<a href="https://github.com/ChaiScript/ChaiScript/issues/338">问题</a> ，最简单的解决方案是将<b><code>#define CHAISCRIPT_NO_THREADS</code></b>放在编译器设置中或在包含库文件之前，从而禁用多线程。 据我了解，无法修复此错误。 <br><br> 现在，我们将详细分析C ++和ChaiScript之间的交互作用。 该库定义了一个特殊的模板函数<code>fun</code> ，可以使用一个指向函数，函子或类变量的指针，然后返回一个存储状态的特殊对象。 例如，让我们用C ++代码定义Widget类，并尝试以不同的方式将其与ChaiScript关联： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Widget(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id) : Id(id) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Id; } }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Widget&amp; w)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"widget #"</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(w.GetId()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ chaiscript::ChaiScript chai; <span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">w</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//  Widget  C++  chai.add(chaiscript::fun([&amp;w] { return w; }), "get_widget"); //         chai.add(chaiscript::fun(ToString), "to_string"); //   chai.add(chaiscript::fun(&amp;Widget::GetId), "get_id"); //   //    ,   Widget    GetId,    to_string,    chai.eval(R"( var w = get_widget() print(w.get_id) //  2 print(w) //  widget #2 )"); }</span></span></code> </pre><br> 如您所见，ChaiScript在它未知的C ++类中可以完全平静地工作，并且可以调用其方法。 如果您在代码中的某个地方犯了一个错误，则脚本很可能会<code>error in function dispatch</code>抛出异常类型的异常，这一点都不重要。 但是，不仅可以导入函数，而且让我们看看如何使用该库向脚本添加变量。 为此，请更难选择任务-import std :: vector &lt;Widget&gt;。  <code>chaiscript::var</code>函数和<code>add_global</code>方法将帮助我们解决这一问题。 我们还将<code>Data</code> public字段添加到Widget中，以了解如何导入class字段： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Data = <span class="hljs-number"><span class="hljs-number">0</span></span>; Widget(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : Id(id) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Id; } }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Widget&amp; w)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"widget #"</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(w.GetId()) + <span class="hljs-string"><span class="hljs-string">" with data: "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(w.Data); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ chaiscript::ChaiScript chai; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Widget&gt; W; <span class="hljs-comment"><span class="hljs-comment">//    Widget W.emplace_back(1); W.emplace_back(2); W.emplace_back(3); chai.add(chaiscript::fund(ToString), "to_string"); chai.add(chaiscript::fun(&amp;Widget::Data), "data"); //     //     ChaiScript chai.add_global(chaiscript::var(std::ref(W)), "widgets"); //     std::ref chai.add(chaiscript::fun(&amp;std::vector&lt;Widget&gt;::size), "size"); //   // .        using IndexFuncType = Widget&amp; (std::vector&lt;Widget&gt;::*)(const size_t); chai.add(chaiscript::fun(IndexFuncType(&amp;std::vector&lt;Widget&gt;::operator[])), "[]"); chai.eval(R"( for(var i = 0; i &lt; vec.size; ++i) { vec[i].data = i * 2; print(vec[i]) } )"); }</span></span></code> </pre><br> 上面的代码显示： <b><code>widget #1 with data: 0</code> <code>widget #2 with data: 2</code> <code>widget #3 with data: 4</code> <code>widget #2 with data: 2</code> ， <code>widget #3 with data: 4</code></b> 。 我们在ChaiScript中添加了一个指向class字段的指针，并且由于该字段原来是原始类型，因此我们更改其值。 此外，还添加了几种方法来使用<code>std::vector</code> ，包括<code>operator[]</code> 。 那些熟悉STL的人知道<code>std::vector</code>两种索引方法-一种返回常量链接，另一种返回简单链接。 这就是为什么对于重载的函数，必须显式指示其类型-否则会引起歧义，并且编译器将引发错误。 <br><br> 该库提供了更多的添加对象的方法，但是它们几乎都是相同的，因此我看不到详细考虑它们的意义。 作为一个小提示，下面是下面的代码： <br><br><pre> <code class="cpp hljs">chai.add(chaiscript::var(x), <span class="hljs-string"><span class="hljs-string">"x"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// x   ChaiScript chai.add(chaiscript::var(std::ref(x), "x"); //  ,    C++  ChaiScript auto shared_x = std::make_shared&lt;int&gt;(5); chai.add(chaiscript::var(shared_x), "x"); // shared_ptr      C++  ChaiScript chai.add(chaiscript::const_var(x), "x"); //   ChaiScript    chai.add_global_const(chaiscript::const_var(x), "x"); // global const . ,  x   chai.add_global(chaiscript::var(x), "x"); // global , .  x   chai.set_global(chaiscript::var(x), "x"); //   global ,    const</span></span></code> </pre><br><h4> 使用STL容器 </h4><br> 如果要将包含<b>原始</b>类型的STL容器传递给ChaiScript，可以将模板容器实例化添加到脚本中，这样就不必为每种类型导入方法。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyVector = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;&gt;; MyVector V; V.emplace_back(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"John"</span></span>); V.emplace_back(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"Bob"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    - vector  pair chai.add(chaiscript::bootstrap::standard_library::vector_type&lt;MyVector&gt;("MyVec")); chai.add(chaiscript::bootstrap::standard_library::pair_type&lt;MyVector::value_type&gt;("MyVecData")); chai.add(chaiscript::var(std::ref(V)), "vec"); chai.eval(R"( for(var i = 0; i &lt; vec.size; ++i) { print(to_string(vec[i].first) + " " + vec[i].second) } )");</span></span></code> </pre> <br>       ChaiScript,     .  ,        STL-,       .   c <code>std::vector&lt;Widget&gt;</code> ,  , ,   ChaiScript        <code>vector_type</code> ,    Widget  . <br><br><h4> ++   ChaiScript </h4><br>            ChaiScript,      .  ,   .      Widget      WindowWidget,         ,       : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Widget(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id) : Id(id) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Id; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WindowWidget</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Widget { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; Size; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: WindowWidget(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height) : Widget(id), Size(width, height) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWidth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Size.first; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Size.second; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ chaiscript::ChaiScript chai; <span class="hljs-comment"><span class="hljs-comment">//   Widget    chai.add(chaiscript::user_type&lt;Widget&gt;(), "Widget"); chai.add(chaiscript::constructor&lt;Widget(int)&gt;(), "Widget"); //   WindowWidget    chai.add(chaiscript::user_type&lt;WindowWidget&gt;(), "WindowWidget"); chai.add(chaiscript::constructor&lt;WindowWidget(int, int, int)&gt;(), "WindowWidget"); // ,  Widget -    WindowWidget chai.add(chaiscript::base_class&lt;Widget, WindowWidget&gt;()); //   Widget  WindowWidget chai.add(chaiscript::fun(&amp;Widget::GetId), "get_id"); chai.add(chaiscript::fun(&amp;WindowWidget::GetWidth), "width"); chai.add(chaiscript::fun(&amp;WindowWidget::GetHeight), "height"); //  WindowWidget     chai.eval(R"( var window = WindowWidget(1, 800, 600) print("${window.width} * ${window.height}") print("widget.id is ${window.get_id}") )"); }</span></span></code> </pre><br>    ChaiScript  ,    C++  ,     .   -          (,      ),      ,          <code>std::vector&lt;Widget&gt;</code> . <br><br><h4>        </h4><br>              .     ChaiScript    ,   ,        : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">w</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; w.Data = <span class="hljs-number"><span class="hljs-number">4444</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  Widget w chai.add(chaiscript::fun(&amp;Widget::GetId, &amp;w), "widget_id"); chai.add(chaiscript::fun(&amp;Widget::Data, &amp;w), "widget_data"); chai.eval(R"( print(widget_id) print(widget_data) )");</span></span></code> </pre><br>     «»   C++  ChaiScript ( , vec3, complex, matrix)          .  ChaiScript      <code>type_conversion</code>   .     Complex    int  double    : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Complex</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Re, Im; Complex(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> re, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> im = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) : Re(re), Im(im) { } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ chaiscript::ChaiScript chai; <span class="hljs-comment"><span class="hljs-comment">//  Complex,   re, im,    `=` chai.add(chaiscript::user_type&lt;Complex&gt;(), "Complex"); chai.add(chaiscript::bootstrap::standard_library::assignable_type&lt;Complex&gt;("Complex")); chai.add(chaiscript::constructor&lt;Complex(float, float)&gt;(), "Complex"); chai.add(chaiscript::fun(&amp;Complex::Re), "re"); chai.add(chaiscript::fun(&amp;Complex::Im), "im"); //     double  int  Complex chai.add(chaiscript::type_conversion&lt;int, Complex&gt;()); chai.add(chaiscript::type_conversion&lt;double, Complex&gt;()); //     `+`    chai.eval(R"( def `+`(Complex c, x) { var res = Complex(0, 0) res.re = c.re + x.re res.im = c.im + x.im return res } var c = Complex(1, 2) c = c + 3 print("${c.re} + ${c.im}i") )"); // : `4 + 2i` }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，没有必要用C ++本身编写转换函数，只需将其导出到ChaiScript。</font><font style="vertical-align: inherit;">您可以添加转换，并且已经在脚本代码本身中描述了新功能。</font><font style="vertical-align: inherit;">如果两种类型的转换很简单，则可以将lambda作为参数传递给function </font></font><code>type_conversion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">投射时会被调用。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用类似的原理将Vector或Map ChaiScript转换为您的自定义类型。</font><font style="vertical-align: inherit;">为此，在库</font></font><code>vector_conversion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中</font><font style="vertical-align: inherit;">定义了</font></font><code>map_conversion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 解压缩ChaiScript返回值 </font></font></h4><br>  <code>eval</code>  <code>eval_file</code>         <code>Boxed_Value</code> .         C++,        ,     <code>boxed_cast&lt;T&gt;</code> .     ,   ,    <code>bad_boxed_cast</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//       double d = chai.eval&lt;double&gt;("5.3 + 2.1"); //     Boxed_Value,     auto v = chai.eval("5.3 + 2.1"); double d = chai.boxed_cast&lt;double&gt;(v);</span></span></code> </pre><br>      ChaiScript    shared_ptr,            .      shared_ptr    : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x = chai.eval&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;&gt;(<span class="hljs-string"><span class="hljs-string">"var x = 3.2"</span></span>);</code> </pre><br> ,        shared_ptr,     access violation  ,           . <br><br>     ,     ChaiScript     ,    ChaiScript.  ,      Complex           : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> printComplex = chai.eval&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(Complex)&gt;&gt;(<span class="hljs-string"><span class="hljs-string">R"( fun(Complex c) { print("${c.re} + ${c.im}i"); } )"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  ,   ,      C++ printComplex(Complex(2, 3)); //  chaiscript,  `2 + 3i`</span></span></code> </pre><br><h4>    ChaiScript </h4><br>        ,    .  <code>eval_error</code>    , <code>bad_boxed_cast</code> ,        <code>std::exception</code>   .        ,        ++: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyException</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Data; MyException(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> data) : <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception(<span class="hljs-string"><span class="hljs-string">"MyException"</span></span>), Data(data) { } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ chaiscript::ChaiScript chai; <span class="hljs-comment"><span class="hljs-comment">//      chaiscript chai.add(chaiscript::user_type&lt;MyException&gt;(), "MyException"); chai.add(chaiscript::constructor&lt;MyException(int)&gt;(), "MyException"); try { //          chai.eval("throw(MyException(11111))", chaiscript::exception_specification&lt;MyException, std::exception&gt;()); } catch (MyException&amp; e) { std::cerr &lt;&lt; e.Data; //   `11111` } catch (chaiscript::exception::eval_error&amp; e) { std::cerr &lt;&lt; e.pretty_print(); } catch(std::exception&amp; e) { std::cerr &lt;&lt; e.what(); } }</span></span></code> </pre><br>    ,       C++.   <code>pretty_print</code> ,  <code>eval_error</code>     ,    ,  ,  ,              . <br><br><h4>  ChaiScript </h4><br>  ,   ChaiScript       .  ,     , -,  .         -    <a href="https://github.com/ChaiScript/ChaiScript_Extras">ChaiScript Extras</a> ,      .     <b>math</b>   acos(x): <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;chaiscript/chaiscript.hpp&gt; #include &lt;chaiscript/extras/math.hpp&gt; int main() { chaiscript::ChaiScript chai; //   auto mathlib = chaiscript::extras::math::bootstrap(); chai.add(mathlib); std::cout &lt;&lt; chai.eval&lt;double&gt;("acos(0.5)"); // ~1.047 }</span></span></span></span></code> </pre><br>           .    ,       math     .  ,     C++    ,   ,      . <br><a name="myexp"></a><br><h2>   </h2><br>      3D-  OpenGL    ,          ,         .      <a href="https://github.com/MomoDeve/MSL"></a> , ,  , «    »,      . <br><br>      ,  ChaiScript      ,         Lua.      ,        ,       :  ,         C++  C,      -  C-style . ,        ,     . <br><br>        ,         .            ImGui,     chaiscript.               ,   : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      3D-: // rotation CHAI_IMPORT(&amp;GLInstance::RotateX, rotate_x); CHAI_IMPORT(&amp;GLInstance::RotateY, rotate_y); CHAI_IMPORT(&amp;GLInstance::RotateZ, rotate_z); // scale CHAI_IMPORT((GLInstance&amp;(GLInstance::*)(float))&amp;GLInstance::Scale, scale); CHAI_IMPORT((GLInstance&amp;(GLInstance::*)(float, float, float))&amp;GLInstance::Scale, scale); // translation CHAI_IMPORT(&amp;GLInstance::Translate, translate); CHAI_IMPORT(&amp;GLInstance::TranslateX, translate_x); CHAI_IMPORT(&amp;GLInstance::TranslateY, translate_y); CHAI_IMPORT(&amp;GLInstance::TranslateZ, translate_z); // hide / show CHAI_IMPORT(&amp;GLInstance::Hide, hide); CHAI_IMPORT(&amp;GLInstance::Show, show); // getters CHAI_IMPORT(&amp;GLInstance::GetTranslation, translation); CHAI_IMPORT(&amp;GLInstance::GetRotation, rotation); CHAI_IMPORT(&amp;GLInstance::GetScale, scale);</span></span></code> </pre><br>       ,      -,     .        : <br><br><img src="https://habrastorage.org/webt/rl/bo/td/rlbotdpcfl4pdpbplwxfrvsk73i.png" alt="图片"><br> <i>  chaiscript  ImGui:      </i> <br><br>     ,            . , Lua      ,       ,          (JIT     ),     ChaiScript    .      ,    ,      . <br><br>         .           C++ (  Lua   ),         ChaiScript    .         .    . <br><br><h4>   </h4><br><ul><li>   ChaiScript: <a href="http://chaiscript.com/">chaiscript.com</a> </li><li>      : <a href="">ChaiScript cheatsheet</a> </li><li>  : <a href="https://codedocs.xyz/ChaiScript/ChaiScript/">codedocs.xyz/ChaiScript/ChaiScript</a> </li><li>     ChaiScript: <a href="https://github.com/MomoDeve/MomoEngine">github.com/MomoDeve/MomoEngine</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN483540/">https://habr.com/ru/post/zh-CN483540/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN483528/index.html">REST API必须基于超文本</a></li>
<li><a href="../zh-CN483530/index.html">我们如何进行棋盘游戏。 为什么和为什么？</a></li>
<li><a href="../zh-CN483532/index.html">DefCon 27会议：创建电子徽章的幕后花絮 第一部分</a></li>
<li><a href="../zh-CN483536/index.html">微处理器和个人计算机的历史：1974年-1980年</a></li>
<li><a href="../zh-CN483538/index.html">通过FMC将10“ ER-TFT101-1显示器连接到STM32F429</a></li>
<li><a href="../zh-CN483542/index.html">电信摘要-有关提供商工作的材料</a></li>
<li><a href="../zh-CN483544/index.html">新数据驳斥了暗能量的关键假设</a></li>
<li><a href="../zh-CN483550/index.html">服务和IaaS开发：云，数据存储和1cloud Evolution的汇编</a></li>
<li><a href="../zh-CN483552/index.html">MVVM和适配器中的元素选择</a></li>
<li><a href="../zh-CN483554/index.html">20年代的新技术平台。 为什么我不同意扎克伯格</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>