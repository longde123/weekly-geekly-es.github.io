<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêö üëò üë®üèº‚Äçüéì Der Kampf um Ressourcen, Teil 6: cpuset oder Sharing ist nicht immer richtig üéè üëèüèæ üîº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn es um cgroups geht, stellen Red Hat-Benutzer h√§ufig die gleiche Frage: ‚ÄûIch habe eine Anwendung, die hinsichtlich Verz√∂gerungen sehr empfindlich ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Der Kampf um Ressourcen, Teil 6: cpuset oder Sharing ist nicht immer richtig</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/430748/">  Wenn es um cgroups geht, stellen Red Hat-Benutzer h√§ufig die gleiche Frage: ‚ÄûIch habe eine Anwendung, die hinsichtlich Verz√∂gerungen sehr empfindlich ist.  Ist es m√∂glich, cgroups zu verwenden, um diese Anwendung vom Rest zu isolieren, indem sie an bestimmte Prozessorkerne gebunden wird? ‚Äú <br><br><img src="https://habrastorage.org/webt/hj/ig/zd/hjigzdvn7vwbunpdkqiqjcdmqde.png" width="100%"><br><br>  Nat√ºrlich kannst du.  Andernfalls w√ºrden wir dieses Problem nicht als Thema des heutigen Artikels ausw√§hlen. <br><a name="habracut"></a><br>  In der Kindheit wurde uns oft gesagt, dass Teilen gut und richtig ist.  Im Gro√üen und Ganzen so wie es ist.  Es gibt jedoch Ausnahmen. <br><br>  Wie wir im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Beitrag dieser Serie geschrieben haben</a> , verh√§lt sich Red Hat Enterprise Linux 7 standardm√§√üig wie eine sph√§rische Gro√ümutter.  In dem Sinne, dass sie versucht, die Systemressourcen fair auf alle zu verteilen, die sie fragen.  Im wirklichen Leben haben Gro√üm√ºtter jedoch Haustiere, die mehr bekommen.  In sysadmin √ºbersetzt bedeutet dies, dass es Situationen gibt, in denen einige Anwendungen oder Dienste wichtiger sind als andere. Daher sollten sie alle m√∂gliche Aufmerksamkeit erhalten, damit sie so reaktionsschnell wie m√∂glich sind. <br><br>  Red Hat Enterprise Linux 7 f√ºhrt dies in zwei Schritten aus: <br><br><ol><li>  Wir isolieren einen Teil der Prozessorkerne, um sie auf die ausschlie√üliche Verwendung einer solchen Anwendung zu √ºbertragen. </li><li>  Wir erstellen Gruppengruppen und Einheitendateien, die diese Anwendung an isolierte Kernel binden. </li></ol><br><h3>  Ein kleiner Exkurs zu den Beispielen aus diesen Beitr√§gen </h3><br>  Hat Enterprise Linux 7.4 hat die Funktionsweise kurzlebiger Slices ge√§ndert, z. B. Benutzersitzungen.  Infolgedessen k√∂nnen sie die cgroup-Einstellungen nicht mehr im laufenden Betrieb √§ndern, dauerhafte √Ñnderungen an der Konfiguration vornehmen oder Drop-In-Dateien mit dem Befehl systemctl set-property erstellen.  Ja, es ist eine Schande, aber die Linux-Entwicklergemeinde hat dies entschieden.  Die gute Nachricht ist, dass diese √Ñnderungen den Service nicht beeinflusst haben.  Das hei√üt, wenn Anwendungen √ºber Einheitendateien gestartet und gestoppt werden (als D√§monen arbeiten), funktionieren alle unsere Beispiele.  Dar√ºber hinaus ist es weiterhin m√∂glich, eigene alte Gruppen mit alten Tools wie cgcreate und cgset zu erstellen und dann Benutzersitzungen und -prozesse in diese Gruppen zu platzieren, um CPU-B√§lle und andere Steuerelemente zu verwenden.  Im Leben √§ndert sich alles, so dass wir nur neue Techniken anpassen und erfinden k√∂nnen.  Und jetzt wenden wir uns dem heutigen Thema zu. <br><br><h3>  Separatismus mit Isolcpus aufbauen </h3><br>  Eine der wichtigsten Komponenten im Linux-Kernel ist der Prozessplaner.  Wenn etwas tiefer, dann ist ein Prozess ein ausf√ºhrbarer Code, der Teil einer Anwendung oder eines Dienstes ist.  Tats√§chlich besteht der Prozess aus einer Reihe von Anweisungen, die der Computer ausf√ºhrt, um diese oder jene Arbeit auszuf√ºhren, unabh√§ngig davon, ob Sie sich Dichtungen oder etwas Ernsthafteres ansehen. <br><br>  Diese Anweisungen werden vom Zentralprozessor, auch bekannt als CPU, verarbeitet.  Auf modernen Computern besteht die CPU normalerweise aus mehreren Prozessoren, die als Kerne bezeichnet werden. <br><br>  Standardm√§√üig betrachtet der Scheduler jeden Prozessorkern als eines der ausf√ºhrenden Module, denen er neue Prozesse zuweist, sobald sie angezeigt werden.  In diesem Fall versucht der Scheduler, die entstehenden Prozesse unter Ber√ºcksichtigung der Last mehr oder weniger gleichm√§√üig auf die Kerne zu verteilen.  Leider kann dem Scheduler nicht gesagt werden, dass dieser bestimmte Prozess letztendlich zu einer ganzen Gruppe von Prozessen f√ºhren wird, und diese Gruppe muss isoliert von anderen Prozessen ausgef√ºhrt werden, in dem Sinne, dass sie keine gemeinsamen Prozessorkerne haben sollten. <br><br>  Daher m√ºssen wir dem Planer irgendwie mitteilen, dass er einen Teil der Prozessorkerne nicht ber√ºhrt, dh ihnen keine Prozesse gibt, die getroffen werden.  Und dann werden wir selbst (oder mit Hilfe eines anderen Prozesses) die Prozesse erzwingen, die wir f√ºr notwendig halten, um vom Kernel-Scheduler isoliert zu sein.  Dies kann mit dem Parameter isolcpus in der Kernel-Boot-Zeile in der Grub-Konfigurationsdatei erfolgen.  Im folgenden Beispiel haben wir einen Computer mit vier Kerneln, auf dem sich zwei Grub-Dateien befinden: einer befindet sich in / etc / default und hei√üt grub.noiso (dies ist die Standardkonfigurationssicherung), und der zweite liegt dort und wird einfach grub genannt, damit es nahm grub2-mkconfig auf.  Diese zweite Datei wurde bearbeitet, um die Kernel 1-3 vom Prozessplaner zu isolieren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lx/ch/jj/lxchjjgcltehlxpbltbyfr5xark.png"></div><br>  WARNUNG: Unter Red Hat Enterprise Linux 7 m√ºssen Sie die Datei grub.conf im Ordner / boot niemals manuell √§ndern.  Nehmen Sie stattdessen die erforderlichen √Ñnderungen an / etc / default / grub vor und erstellen Sie die Datei grub.conf mit dem entsprechenden Dienstprogramm wie folgt neu: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w8/au/gp/w8augp_6vfuutouvjdv8imw5way.png"></div><br>  Bei Verwendung des Parameters isolcpus m√ºssen die freigegebenen Prozessorkerne durch Komma getrennt aufgelistet werden. Die Nummerierung beginnt bei 0. Nach dem Neustart des Systems verwendet der Prozessplaner diese Kerne nur f√ºr bestimmte Prozesse auf Systemebene, die auf jedem Kern vorhanden sein M√úSSEN.  Um zu √ºberpr√ºfen, ob unsere Methode funktioniert hat, starten wir mehrere Ladevorg√§nge und untersuchen dann das Laden jedes Kernels mit dem Befehl top. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/y_/0u/qh/y_0uqhre8j6tbm4mvaef0tdctms.png"></div><br>  Wie Sie sehen k√∂nnen, befanden sich alle Ladevorg√§nge auf CPU 0, anstatt gleichm√§√üig auf alle vier Kerne verteilt zu sein.  Also haben wir den Boot-Parameter korrekt registriert. <br><br><h3>  Binden Sie Prozesse mit cpuset an Kernel </h3><br>  Jetzt gehen wir zu Dingen √ºber <b>, die Sie besser nicht tun sollten, wenn Sie nicht verstehen, warum Sie dies tun, und die besser erst nach gr√ºndlichen Tests in der Produktion bereitgestellt werden k√∂nnen</b> . <br><br>  Wof√ºr sind diese Warnungen?  Zu der Tatsache, dass wir im Allgemeinen einfache Dinge mit dem libcgroup-Toolkit tun werden, √ºber das in einem fr√ºheren Beitrag geschrieben wurde.  Wenn Sie sich erinnern, ist dies nur eine Reihe von Befehlen zum Erstellen, √Ñndern und Zerst√∂ren von Gruppen.  Tats√§chlich sind sie Teil von Red Hat Enterprise Linux 6, k√∂nnen aber auch unter Red Hat Enterprise Linux 7 installiert werden, obwohl es m√∂glich ist, dass diese M√∂glichkeit in Zukunft verschwindet.  Erinnern Sie sich kurz an die wichtigsten Empfehlungen f√ºr die Verwendung von libcgroup: <br><br><ol><li>  Verwenden Sie systemd, um die cgroup-Controller zu steuern, die von systemd selbst gesteuert werden (dies sind die CPU, der Speicher und die Block-E / A.). </li><li>  Verwenden Sie libcgroup-Tools, um alle anderen cgroup-Controller zu verwalten. </li><li>  Seien Sie sehr vorsichtig mit den ungeplanten Folgen Ihrer Handlungen. </li></ol><br>  Mit dem cpuset-Konzept ist alles einfach - dies ist eine Liste von Prozessorkernen (Nummerierung, R√ºckruf, Beginn bei 0), die Aufgaben akzeptiert, die NUR auf diesen Kernen ausgef√ºhrt werden.  Dies sind die am h√§ufigsten verwendeten Prozessorkerne. Sie k√∂nnen entweder von einem Prozessplaner gesteuert werden (so wird das System standardm√§√üig konfiguriert) oder umgekehrt vom Planer isoliert werden (wie im obigen Beispiel). <br><br>  Lassen Sie uns anhand unseres Beispiels das Dateisystem Verzeichnis / sys / fs / cgroup auf dem System √ºberpr√ºfen.  Wie Sie sehen k√∂nnen, ist das Verzeichnis cpuset bereits vorhanden, da dieser Controller Teil des Kernels ist (obwohl er nicht unter der Kontrolle von systemd steht).  Es gibt jedoch noch keine cgroups, sodass nur die Standardeinstellungen in diesem Verzeichnis angezeigt werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yp/wy/md/ypwymdstnktxg_kjxosbhx1ilsa.png"></div><br>  √úberpr√ºfen Sie, ob das libcgroup-Toolkit auf unserem Computer installiert ist: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vn/rn/oh/vnrnoheqhc2xzziafvhnbfx1f2o.png"></div><br>  Wenn nicht installiert, kann dies einfach mit dem Befehl yum install libcgroup behoben werden, selbst ein Neustart ist nicht erforderlich. <br><br>  Erstellen Sie nun cpuset.  Zu diesem Zweck verwenden wir die folgenden Befehle, um eine neue cgroup f√ºr cpuset zu erstellen und deren Eigenschaften zu registrieren: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bx/mv/kn/bxmvknuvxcxadwvboxizn__0hcg.png"></div><br>  Der Befehl Cgcreate erstellt eine cgroup namens testset und platziert sie im cpuset-Controller.  Dann weisen wir diesem neuen cpuset den dritten Kern unserer VM zu und weisen ihm die NUMA-Zone 0 zu. Auch wenn Ihr System NUMA nicht verwendet (und unser System es einfach nicht verwendet), m√ºssen Sie die Zone trotzdem registrieren, andernfalls k√∂nnen Sie der cgroup-Gruppe keine Aufgaben zuweisen .  √úberpr√ºfen Sie nun, ob das Testset-Verzeichnis im Dateisystem erstellt wurde, und pr√ºfen Sie, was sich darin befindet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ts/uu/ow/tsuuowh_2c5fsqu3hulepjgwtb0.png"></div><br>  Wie Sie sehen k√∂nnen, sind unsere √Ñnderungen vorhanden, aber bisher wurde auf diesem cpuset kein Prozess ausgef√ºhrt.  Wie pflanzt man hier einen Prozess? <br><br>  Es gibt verschiedene M√∂glichkeiten, dies zu tun: <br><br><ul><li>  Sie k√∂nnen die PID eines vorhandenen Prozesses in die Aufgabendatei eingeben.  Es funktioniert, aber nicht sehr h√ºbsch. </li><li>  Sie k√∂nnen cgexec verwenden und die Gruppe angeben, wenn der Prozess startet.  Dies funktioniert, wenn die Anwendung kein Daemon ist.  Dar√ºber hinaus kann all dies wundersch√∂n im Anwendungsstart-Skript geschrieben werden. </li><li>  F√ºr eine Anwendung, die als Daemon ausgef√ºhrt wird, auf dem systemd ausgef√ºhrt wird, k√∂nnen Sie eine Servicedatei erstellen. </li></ul><br>  Sehen wir uns die Option cgexec an. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-w/ha/1y/-wha1yvoitn2e7-r_mlaqlunr-a.png"></div><br>  Wir haben foo.exe gestartet, es hat wiederum einen untergeordneten Prozess gestartet, der nur den Prozessor aktiv l√§dt.  Die Option --sticky im Befehl cgexec besagt, dass "jeder untergeordnete Prozess in derselben cgroup wie der √ºbergeordnete Prozess bleiben muss".  Dies ist also eine wichtige Option, an die man sich erinnern muss.  Jetzt sehen wir, dass sich in unserer Gruppe zwei Prozesse drehen, und wir kennen ihre PIDs.  Schauen Sie sich oben an: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tr/x5/83/trx583ix3zsq-c6gawy27bmxibq.png"></div><br>  Wie Sie sehen k√∂nnen, ist die CPU 3 jetzt in die Aug√§pfel geladen, und der Rest k√ºhlt ab. <br><br>  Und so sieht eine Einheitendatei aus, um dieselbe Anwendung wie ein systemd-Dienst auszuf√ºhren: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kx/wn/hv/kxwnhvb_6gwemks5fsoeoi37zpy.png"></div><br>  Die Unit-Datei enth√§lt drei ExecStartPre-Befehle, die die Einstellungen ausf√ºhren, die wir bereits mit unseren H√§nden vorgenommen haben.  Dann kommt der ExecStart-Befehl, der die Anwendung startet.  Wenn die Anwendung beendet wird, wird der Befehl ExecStopPost nach sich selbst bereinigt und cgroup entfernt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p2/wy/iw/p2wyiwogovccla42as0jpvwdemk.png"></div><br>  Wie Sie sehen k√∂nnen, haben wir im letzten Beispiel eine neue cgroup mit dem Namen set1 erstellt.  Wir haben dies getan, um zu zeigen, dass Sie mehrere aktive Gruppen haben k√∂nnen, die dieselbe CPU verwenden.  Wem es n√ºtzlich erscheinen mag, aber im Gegenteil, jemanden zu verwirren. <br><br>  Nun, funktioniert es?  Es scheint so! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pu/8x/7j/pu8x7jr-xhhtk6vayzkfqr0gcou.png"></div><br>  Und jetzt werden wir die Arbeit unseres Dienstes abschlie√üen und √ºberpr√ºfen, ob cgroup zerst√∂rt ist: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cd/qm/et/cdqmetsjwaodwhutwl5okmwob08.png"></div><br>  ACHTUNG: Mit cgcreate erstellte Gruppengruppen werden nach dem Neustart nicht gespeichert.  Daher muss die Erstellung solcher Gruppen in Startskripten und Einheitendateien vorgeschrieben werden. <br><br>  In Ihrem Arsenal gibt es jetzt noch ein paar weitere Tools f√ºr die Arbeit mit Gruppen.  Wir hoffen, dass sie n√ºtzlich sind! <br><br>  Weitere Beitr√§ge von cgroups aus unserer Resource Fight-Reihe finden Sie unter: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 4</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 5</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430748/">https://habr.com/ru/post/de430748/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430736/index.html">Entwickeln Sie Ihren Browser von Grund auf neu. Erster Teil: HTML</a></li>
<li><a href="../de430738/index.html">Sei ein Sicherheits-Ninja: geheime Ebene</a></li>
<li><a href="../de430740/index.html">Wie man K√ºhe mit Robotern melkt und ein industrielles Startup darauf macht. R-SEPT Entwicklungsgeschichte</a></li>
<li><a href="../de430742/index.html">Studentenolympiade "Ich bin ein Profi": Richtung "Programmierung und Informationstechnologie"</a></li>
<li><a href="../de430746/index.html">Warum Tesla-Batterien im Lufttaxi nicht funktionieren</a></li>
<li><a href="../de430750/index.html">Quantum Checkers - machen Checkers wieder gro√üartig</a></li>
<li><a href="../de430752/index.html">DEV Labs 2018. Online-Mitap f√ºr Webentwickler. 1. Dezember</a></li>
<li><a href="../de430754/index.html">F√ºgen Sie 2D-Sprites mithilfe von handgezeichneten normalen Karten Tiefe hinzu</a></li>
<li><a href="../de430756/index.html">Herstellung der WX-Maus im Nova Slider 600</a></li>
<li><a href="../de430762/index.html">So w√§hlen Sie eine USV aus, um die Kosten zu optimieren</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>