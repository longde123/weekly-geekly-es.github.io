<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐚 👘 👨🏼‍🎓 Der Kampf um Ressourcen, Teil 6: cpuset oder Sharing ist nicht immer richtig 🎏 👏🏾 🔼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn es um cgroups geht, stellen Red Hat-Benutzer häufig die gleiche Frage: „Ich habe eine Anwendung, die hinsichtlich Verzögerungen sehr empfindlich ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Der Kampf um Ressourcen, Teil 6: cpuset oder Sharing ist nicht immer richtig</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/430748/">  Wenn es um cgroups geht, stellen Red Hat-Benutzer häufig die gleiche Frage: „Ich habe eine Anwendung, die hinsichtlich Verzögerungen sehr empfindlich ist.  Ist es möglich, cgroups zu verwenden, um diese Anwendung vom Rest zu isolieren, indem sie an bestimmte Prozessorkerne gebunden wird? “ <br><br><img src="https://habrastorage.org/webt/hj/ig/zd/hjigzdvn7vwbunpdkqiqjcdmqde.png" width="100%"><br><br>  Natürlich kannst du.  Andernfalls würden wir dieses Problem nicht als Thema des heutigen Artikels auswählen. <br><a name="habracut"></a><br>  In der Kindheit wurde uns oft gesagt, dass Teilen gut und richtig ist.  Im Großen und Ganzen so wie es ist.  Es gibt jedoch Ausnahmen. <br><br>  Wie wir im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Beitrag dieser Serie geschrieben haben</a> , verhält sich Red Hat Enterprise Linux 7 standardmäßig wie eine sphärische Großmutter.  In dem Sinne, dass sie versucht, die Systemressourcen fair auf alle zu verteilen, die sie fragen.  Im wirklichen Leben haben Großmütter jedoch Haustiere, die mehr bekommen.  In sysadmin übersetzt bedeutet dies, dass es Situationen gibt, in denen einige Anwendungen oder Dienste wichtiger sind als andere. Daher sollten sie alle mögliche Aufmerksamkeit erhalten, damit sie so reaktionsschnell wie möglich sind. <br><br>  Red Hat Enterprise Linux 7 führt dies in zwei Schritten aus: <br><br><ol><li>  Wir isolieren einen Teil der Prozessorkerne, um sie auf die ausschließliche Verwendung einer solchen Anwendung zu übertragen. </li><li>  Wir erstellen Gruppengruppen und Einheitendateien, die diese Anwendung an isolierte Kernel binden. </li></ol><br><h3>  Ein kleiner Exkurs zu den Beispielen aus diesen Beiträgen </h3><br>  Hat Enterprise Linux 7.4 hat die Funktionsweise kurzlebiger Slices geändert, z. B. Benutzersitzungen.  Infolgedessen können sie die cgroup-Einstellungen nicht mehr im laufenden Betrieb ändern, dauerhafte Änderungen an der Konfiguration vornehmen oder Drop-In-Dateien mit dem Befehl systemctl set-property erstellen.  Ja, es ist eine Schande, aber die Linux-Entwicklergemeinde hat dies entschieden.  Die gute Nachricht ist, dass diese Änderungen den Service nicht beeinflusst haben.  Das heißt, wenn Anwendungen über Einheitendateien gestartet und gestoppt werden (als Dämonen arbeiten), funktionieren alle unsere Beispiele.  Darüber hinaus ist es weiterhin möglich, eigene alte Gruppen mit alten Tools wie cgcreate und cgset zu erstellen und dann Benutzersitzungen und -prozesse in diese Gruppen zu platzieren, um CPU-Bälle und andere Steuerelemente zu verwenden.  Im Leben ändert sich alles, so dass wir nur neue Techniken anpassen und erfinden können.  Und jetzt wenden wir uns dem heutigen Thema zu. <br><br><h3>  Separatismus mit Isolcpus aufbauen </h3><br>  Eine der wichtigsten Komponenten im Linux-Kernel ist der Prozessplaner.  Wenn etwas tiefer, dann ist ein Prozess ein ausführbarer Code, der Teil einer Anwendung oder eines Dienstes ist.  Tatsächlich besteht der Prozess aus einer Reihe von Anweisungen, die der Computer ausführt, um diese oder jene Arbeit auszuführen, unabhängig davon, ob Sie sich Dichtungen oder etwas Ernsthafteres ansehen. <br><br>  Diese Anweisungen werden vom Zentralprozessor, auch bekannt als CPU, verarbeitet.  Auf modernen Computern besteht die CPU normalerweise aus mehreren Prozessoren, die als Kerne bezeichnet werden. <br><br>  Standardmäßig betrachtet der Scheduler jeden Prozessorkern als eines der ausführenden Module, denen er neue Prozesse zuweist, sobald sie angezeigt werden.  In diesem Fall versucht der Scheduler, die entstehenden Prozesse unter Berücksichtigung der Last mehr oder weniger gleichmäßig auf die Kerne zu verteilen.  Leider kann dem Scheduler nicht gesagt werden, dass dieser bestimmte Prozess letztendlich zu einer ganzen Gruppe von Prozessen führen wird, und diese Gruppe muss isoliert von anderen Prozessen ausgeführt werden, in dem Sinne, dass sie keine gemeinsamen Prozessorkerne haben sollten. <br><br>  Daher müssen wir dem Planer irgendwie mitteilen, dass er einen Teil der Prozessorkerne nicht berührt, dh ihnen keine Prozesse gibt, die getroffen werden.  Und dann werden wir selbst (oder mit Hilfe eines anderen Prozesses) die Prozesse erzwingen, die wir für notwendig halten, um vom Kernel-Scheduler isoliert zu sein.  Dies kann mit dem Parameter isolcpus in der Kernel-Boot-Zeile in der Grub-Konfigurationsdatei erfolgen.  Im folgenden Beispiel haben wir einen Computer mit vier Kerneln, auf dem sich zwei Grub-Dateien befinden: einer befindet sich in / etc / default und heißt grub.noiso (dies ist die Standardkonfigurationssicherung), und der zweite liegt dort und wird einfach grub genannt, damit es nahm grub2-mkconfig auf.  Diese zweite Datei wurde bearbeitet, um die Kernel 1-3 vom Prozessplaner zu isolieren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lx/ch/jj/lxchjjgcltehlxpbltbyfr5xark.png"></div><br>  WARNUNG: Unter Red Hat Enterprise Linux 7 müssen Sie die Datei grub.conf im Ordner / boot niemals manuell ändern.  Nehmen Sie stattdessen die erforderlichen Änderungen an / etc / default / grub vor und erstellen Sie die Datei grub.conf mit dem entsprechenden Dienstprogramm wie folgt neu: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w8/au/gp/w8augp_6vfuutouvjdv8imw5way.png"></div><br>  Bei Verwendung des Parameters isolcpus müssen die freigegebenen Prozessorkerne durch Komma getrennt aufgelistet werden. Die Nummerierung beginnt bei 0. Nach dem Neustart des Systems verwendet der Prozessplaner diese Kerne nur für bestimmte Prozesse auf Systemebene, die auf jedem Kern vorhanden sein MÜSSEN.  Um zu überprüfen, ob unsere Methode funktioniert hat, starten wir mehrere Ladevorgänge und untersuchen dann das Laden jedes Kernels mit dem Befehl top. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/y_/0u/qh/y_0uqhre8j6tbm4mvaef0tdctms.png"></div><br>  Wie Sie sehen können, befanden sich alle Ladevorgänge auf CPU 0, anstatt gleichmäßig auf alle vier Kerne verteilt zu sein.  Also haben wir den Boot-Parameter korrekt registriert. <br><br><h3>  Binden Sie Prozesse mit cpuset an Kernel </h3><br>  Jetzt gehen wir zu Dingen über <b>, die Sie besser nicht tun sollten, wenn Sie nicht verstehen, warum Sie dies tun, und die besser erst nach gründlichen Tests in der Produktion bereitgestellt werden können</b> . <br><br>  Wofür sind diese Warnungen?  Zu der Tatsache, dass wir im Allgemeinen einfache Dinge mit dem libcgroup-Toolkit tun werden, über das in einem früheren Beitrag geschrieben wurde.  Wenn Sie sich erinnern, ist dies nur eine Reihe von Befehlen zum Erstellen, Ändern und Zerstören von Gruppen.  Tatsächlich sind sie Teil von Red Hat Enterprise Linux 6, können aber auch unter Red Hat Enterprise Linux 7 installiert werden, obwohl es möglich ist, dass diese Möglichkeit in Zukunft verschwindet.  Erinnern Sie sich kurz an die wichtigsten Empfehlungen für die Verwendung von libcgroup: <br><br><ol><li>  Verwenden Sie systemd, um die cgroup-Controller zu steuern, die von systemd selbst gesteuert werden (dies sind die CPU, der Speicher und die Block-E / A.). </li><li>  Verwenden Sie libcgroup-Tools, um alle anderen cgroup-Controller zu verwalten. </li><li>  Seien Sie sehr vorsichtig mit den ungeplanten Folgen Ihrer Handlungen. </li></ol><br>  Mit dem cpuset-Konzept ist alles einfach - dies ist eine Liste von Prozessorkernen (Nummerierung, Rückruf, Beginn bei 0), die Aufgaben akzeptiert, die NUR auf diesen Kernen ausgeführt werden.  Dies sind die am häufigsten verwendeten Prozessorkerne. Sie können entweder von einem Prozessplaner gesteuert werden (so wird das System standardmäßig konfiguriert) oder umgekehrt vom Planer isoliert werden (wie im obigen Beispiel). <br><br>  Lassen Sie uns anhand unseres Beispiels das Dateisystem Verzeichnis / sys / fs / cgroup auf dem System überprüfen.  Wie Sie sehen können, ist das Verzeichnis cpuset bereits vorhanden, da dieser Controller Teil des Kernels ist (obwohl er nicht unter der Kontrolle von systemd steht).  Es gibt jedoch noch keine cgroups, sodass nur die Standardeinstellungen in diesem Verzeichnis angezeigt werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yp/wy/md/ypwymdstnktxg_kjxosbhx1ilsa.png"></div><br>  Überprüfen Sie, ob das libcgroup-Toolkit auf unserem Computer installiert ist: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vn/rn/oh/vnrnoheqhc2xzziafvhnbfx1f2o.png"></div><br>  Wenn nicht installiert, kann dies einfach mit dem Befehl yum install libcgroup behoben werden, selbst ein Neustart ist nicht erforderlich. <br><br>  Erstellen Sie nun cpuset.  Zu diesem Zweck verwenden wir die folgenden Befehle, um eine neue cgroup für cpuset zu erstellen und deren Eigenschaften zu registrieren: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bx/mv/kn/bxmvknuvxcxadwvboxizn__0hcg.png"></div><br>  Der Befehl Cgcreate erstellt eine cgroup namens testset und platziert sie im cpuset-Controller.  Dann weisen wir diesem neuen cpuset den dritten Kern unserer VM zu und weisen ihm die NUMA-Zone 0 zu. Auch wenn Ihr System NUMA nicht verwendet (und unser System es einfach nicht verwendet), müssen Sie die Zone trotzdem registrieren, andernfalls können Sie der cgroup-Gruppe keine Aufgaben zuweisen .  Überprüfen Sie nun, ob das Testset-Verzeichnis im Dateisystem erstellt wurde, und prüfen Sie, was sich darin befindet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ts/uu/ow/tsuuowh_2c5fsqu3hulepjgwtb0.png"></div><br>  Wie Sie sehen können, sind unsere Änderungen vorhanden, aber bisher wurde auf diesem cpuset kein Prozess ausgeführt.  Wie pflanzt man hier einen Prozess? <br><br>  Es gibt verschiedene Möglichkeiten, dies zu tun: <br><br><ul><li>  Sie können die PID eines vorhandenen Prozesses in die Aufgabendatei eingeben.  Es funktioniert, aber nicht sehr hübsch. </li><li>  Sie können cgexec verwenden und die Gruppe angeben, wenn der Prozess startet.  Dies funktioniert, wenn die Anwendung kein Daemon ist.  Darüber hinaus kann all dies wunderschön im Anwendungsstart-Skript geschrieben werden. </li><li>  Für eine Anwendung, die als Daemon ausgeführt wird, auf dem systemd ausgeführt wird, können Sie eine Servicedatei erstellen. </li></ul><br>  Sehen wir uns die Option cgexec an. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-w/ha/1y/-wha1yvoitn2e7-r_mlaqlunr-a.png"></div><br>  Wir haben foo.exe gestartet, es hat wiederum einen untergeordneten Prozess gestartet, der nur den Prozessor aktiv lädt.  Die Option --sticky im Befehl cgexec besagt, dass "jeder untergeordnete Prozess in derselben cgroup wie der übergeordnete Prozess bleiben muss".  Dies ist also eine wichtige Option, an die man sich erinnern muss.  Jetzt sehen wir, dass sich in unserer Gruppe zwei Prozesse drehen, und wir kennen ihre PIDs.  Schauen Sie sich oben an: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tr/x5/83/trx583ix3zsq-c6gawy27bmxibq.png"></div><br>  Wie Sie sehen können, ist die CPU 3 jetzt in die Augäpfel geladen, und der Rest kühlt ab. <br><br>  Und so sieht eine Einheitendatei aus, um dieselbe Anwendung wie ein systemd-Dienst auszuführen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kx/wn/hv/kxwnhvb_6gwemks5fsoeoi37zpy.png"></div><br>  Die Unit-Datei enthält drei ExecStartPre-Befehle, die die Einstellungen ausführen, die wir bereits mit unseren Händen vorgenommen haben.  Dann kommt der ExecStart-Befehl, der die Anwendung startet.  Wenn die Anwendung beendet wird, wird der Befehl ExecStopPost nach sich selbst bereinigt und cgroup entfernt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p2/wy/iw/p2wyiwogovccla42as0jpvwdemk.png"></div><br>  Wie Sie sehen können, haben wir im letzten Beispiel eine neue cgroup mit dem Namen set1 erstellt.  Wir haben dies getan, um zu zeigen, dass Sie mehrere aktive Gruppen haben können, die dieselbe CPU verwenden.  Wem es nützlich erscheinen mag, aber im Gegenteil, jemanden zu verwirren. <br><br>  Nun, funktioniert es?  Es scheint so! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pu/8x/7j/pu8x7jr-xhhtk6vayzkfqr0gcou.png"></div><br>  Und jetzt werden wir die Arbeit unseres Dienstes abschließen und überprüfen, ob cgroup zerstört ist: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cd/qm/et/cdqmetsjwaodwhutwl5okmwob08.png"></div><br>  ACHTUNG: Mit cgcreate erstellte Gruppengruppen werden nach dem Neustart nicht gespeichert.  Daher muss die Erstellung solcher Gruppen in Startskripten und Einheitendateien vorgeschrieben werden. <br><br>  In Ihrem Arsenal gibt es jetzt noch ein paar weitere Tools für die Arbeit mit Gruppen.  Wir hoffen, dass sie nützlich sind! <br><br>  Weitere Beiträge von cgroups aus unserer Resource Fight-Reihe finden Sie unter: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 4</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 5</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430748/">https://habr.com/ru/post/de430748/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430736/index.html">Entwickeln Sie Ihren Browser von Grund auf neu. Erster Teil: HTML</a></li>
<li><a href="../de430738/index.html">Sei ein Sicherheits-Ninja: geheime Ebene</a></li>
<li><a href="../de430740/index.html">Wie man Kühe mit Robotern melkt und ein industrielles Startup darauf macht. R-SEPT Entwicklungsgeschichte</a></li>
<li><a href="../de430742/index.html">Studentenolympiade "Ich bin ein Profi": Richtung "Programmierung und Informationstechnologie"</a></li>
<li><a href="../de430746/index.html">Warum Tesla-Batterien im Lufttaxi nicht funktionieren</a></li>
<li><a href="../de430750/index.html">Quantum Checkers - machen Checkers wieder großartig</a></li>
<li><a href="../de430752/index.html">DEV Labs 2018. Online-Mitap für Webentwickler. 1. Dezember</a></li>
<li><a href="../de430754/index.html">Fügen Sie 2D-Sprites mithilfe von handgezeichneten normalen Karten Tiefe hinzu</a></li>
<li><a href="../de430756/index.html">Herstellung der WX-Maus im Nova Slider 600</a></li>
<li><a href="../de430762/index.html">So wählen Sie eine USV aus, um die Kosten zu optimieren</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>