<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêÅ üíÜüèΩ üçö Usando promessas em JavaScript ‚ÜòÔ∏è ü§æ üíπ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Periodicamente, publicamos materiais que de uma maneira ou de outra est√£o relacionados ao uso de promessas em JavaScript. 

 Aqui est√£o alguns deles. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Usando promessas em JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/418085/">  Periodicamente, publicamos materiais que de uma maneira ou de outra est√£o relacionados ao uso de promessas em JavaScript. <br><br><div class="spoiler">  <b class="spoiler_title">Aqui est√£o alguns deles.</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Promessas no ES6: padr√µes e antipadr√µes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">JavaScript: m√©todos de programa√ß√£o ass√≠ncronos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">JavaScript ES8 e transi√ß√£o para ass√≠ncrona / aguardar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ass√≠ncrono / aguardar: 6 raz√µes para esquecer promessas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Escape from Hell ass√≠ncrono / aguarde</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">JavaScript ES6: escreva menos - fa√ßa mais</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Guia de promessas para quem quer entender</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Design ass√≠ncrono / aguardado do JavaScript: pontos fortes, armadilhas e padr√µes de uso</a> </div></div><br>  Por que tanta aten√ß√£o est√° voltada para promessas?  Acreditamos que o ponto principal √© que essa tecnologia √© muito procurada e √© bastante dif√≠cil de entender. <br><br>  Portanto, se voc√™ deseja entender melhor as promessas, oferecemos uma tradu√ß√£o do pr√≥ximo artigo sobre este t√≥pico.  Seu autor diz que ele desenvolve Java e PHP nos √∫ltimos 10 anos, mas durante todo esse tempo ele procura com interesse o JavaScript.  Recentemente, ele decidiu se envolver seriamente em JS, e as promessas se tornaram o primeiro assunto que o interessou. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/s3/wz/42/s3wz42iyj1wjzrvjzsx6spduxeu.jpeg"></a> <br><br>  Acreditamos que este material ser√° interessante para desenvolvedores iniciantes que acham que, embora usem promessas, n√£o os entendem bem o suficiente.  √â poss√≠vel que a hist√≥ria de algu√©m que veja o JavaScript com uma nova apar√™ncia e queira explicar aos outros o que ele mesmo entendeu, n√£o acreditando que algumas coisas sejam compreens√≠veis para todos e sem explica√ß√£o, ajude os iniciantes a dominar os mecanismos do JavaScript. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">JavaScript atrav√©s dos olhos de um iniciante</font> </h2><br>  Quem come√ßa a escrever em JavaScript, pode sentir o que √© chamado de "fora de lugar".  Alguns dizem que JS √© uma linguagem de programa√ß√£o s√≠ncrona, outros dizem que √© ass√≠ncrona.  Um novato ouve sobre o c√≥digo que bloqueia o encadeamento principal e sobre o c√≥digo que n√£o o bloqueia, sobre padr√µes de design baseados em eventos, sobre o ciclo de vida de eventos, sobre a pilha de chamadas de fun√ß√£o, sobre a fila de eventos e sua ascens√£o, sobre polyfills.  Ele descobre que existem coisas como Babel, Angular, React, Vue e uma infinidade de outras bibliotecas.  Se voc√™ acabou de se reconhecer como um ‚Äúnovato‚Äù - n√£o se preocupe.  Voc√™ n√£o √© o primeiro nem o √∫ltimo.  Existe at√© um termo para isso - o chamado "fadiga do JavaScript".  Lucas F Costa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://twitter.com/housecor/status/888468139389861888%3Fref_src%3Dtwsrc%255Etfw%257Ctwcamp%255Etweetembed%257Ctwterm%255E888468139389861888%26ref_url%3D">falou</a> apropriadamente sobre esse assunto: "O <i>cansa√ßo do JavaScript √© algo que pode ser observado quando as pessoas usam ferramentas que n√£o precisam para resolver problemas que n√£o t√™m</i> ". <br><br>  Mas n√£o vamos falar sobre coisas tristes.  Portanto, o JavaScript √© uma linguagem de programa√ß√£o s√≠ncrona que, gra√ßas ao mecanismo de retorno de chamada, permite chamar fun√ß√µes da mesma maneira que nas linguagens ass√≠ncronas. <br><br><h2>  <font color="#3AC1EF">Uma hist√≥ria simples sobre promessas</font> </h2><br>  A palavra promessa se traduz em promessa.  Objetos de promessa na programa√ß√£o, que chamamos de "promessas", s√£o muito semelhantes √†s promessas usuais que as pessoas fazem umas √†s outras na vida real.  Ent√£o, vamos falar sobre essas promessas primeiro. <br><br>  Na Wikipedia, voc√™ pode encontrar a seguinte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">defini√ß√£o da</a> palavra "promessa": "obriga√ß√£o, o consentimento de algu√©m para cumprir algo ou, pelo contr√°rio, n√£o fazer".  No dicion√°rio de Ozhegov, "promessa" √© "um compromisso volunt√°rio de fazer alguma coisa". <br><br>  Ent√£o, o que sabemos sobre promessas? <br><br><ol><li>  Uma promessa lhe garante que algo ser√° feito.  N√£o importa quem faz exatamente isso: quem fez a promessa, ou outra pessoa, a pedido de quem fez a promessa.  Uma promessa d√° confian√ßa em algo, com base nessa confian√ßa, quem recebeu a promessa pode, por exemplo, fazer alguns planos. </li><li>  Uma promessa pode ser cumprida ou n√£o. </li><li>  Se a promessa for cumprida, ent√£o, como resultado, voc√™ espera que algo que possa ser usado no futuro realize quaisquer a√ß√µes ou implemente planos. </li><li>  Se a promessa n√£o for cumprida, voc√™ desejar√° descobrir por que quem a deu n√£o p√¥de cumpri-la.  Depois de descobrir o motivo do ocorrido e ter certeza de que a promessa n√£o foi cumprida, voc√™ pode pensar no que fazer a seguir ou em como lidar com a situa√ß√£o. </li><li>  Depois de lhe ter sido prometido algo, tudo o que voc√™ tem √© algum tipo de garantia.  Voc√™ n√£o pode tirar proveito do que lhe foi prometido imediatamente.  Voc√™ pode determinar por si mesmo o que precisa fazer se a promessa for cumprida (portanto, voc√™ receber√° a promessa) e o que precisa fazer se for quebrado (nesse caso, voc√™ sabe o motivo do que aconteceu e, portanto, pode pensar em um plano de a√ß√µes de backup). ) </li><li>  √â prov√°vel que a pessoa que fez a promessa simplesmente desapare√ßa.  Nesses casos, √© √∫til que a promessa esteja vinculada a algum tipo de prazo.  Por exemplo, se quem lhe deu a promessa n√£o aparecer em 10 dias, voc√™ pode assumir que ele teve alguns problemas e ele quebrou a promessa.  Como resultado, mesmo que quem fez a promessa cumpra em 15 dias, isso n√£o importa, ent√£o voc√™ j√° est√° agindo no plano alternativo, n√£o confiando na promessa. </li></ol><br>  Agora v√° para JavaScript. <br><br><h2>  <font color="#3AC1EF">Promessas de JavaScript</font> </h2><br>  Eu tenho uma regra: fazer JavaScript, eu sempre ler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a documenta√ß√£o</a> , que est√° dispon√≠vel no MDN.  Parece-me que esse recurso se compara favoravelmente com os outros na especificidade e clareza da apresenta√ß√£o.  Portanto, enquanto estudava as promessas, me familiarizei com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">material</a> relevante e experimentei o c√≥digo para me acostumar com as novas constru√ß√µes de sintaxe. <br><br>  Para entender as promessas, voc√™ precisa lidar com duas coisas principais.  A primeira √© a cria√ß√£o de promessas.  O segundo √© o processamento dos resultados retornados pelas promessas.  Embora a maior parte do c√≥digo que escrevemos tenha como objetivo trabalhar com promessas criadas, por exemplo, por certas bibliotecas, um entendimento completo dos mecanismos de trabalho das promessas ser√°, sem d√∫vida, √∫til.  Al√©m disso, para um programador que j√° tem alguma experi√™ncia, saber como criar promessas √© t√£o importante quanto saber trabalhar com elas. <br><br><h2>  <font color="#3AC1EF">Criar promessas</font> </h2><br>  Veja como as promessas s√£o criadas: <br><br><pre><code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( <span class="hljs-comment"><span class="hljs-comment">/* executor */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ ... } );</code> </pre> <br>  O construtor aceita uma fun√ß√£o que executa certas a√ß√µes, que chamamos de <code>executor</code> .  Essa fun√ß√£o usa dois par√¢metros - <code>resolve</code> e <code>reject</code> , que, por sua vez, tamb√©m s√£o fun√ß√µes.  As promessas geralmente s√£o usadas para executar opera√ß√µes ass√≠ncronas ou c√≥digos que podem bloquear o encadeamento principal, por exemplo, um que funcione com arquivos, faz chamadas de API, faz consultas de banco de dados, lida com E / S e assim por diante.  O in√≠cio dessas opera√ß√µes ass√≠ncronas √© realizado na fun√ß√£o <code>executor</code> .  Se a opera√ß√£o ass√≠ncrona for conclu√≠da com √™xito, o resultado esperado da promessa ser√° retornado chamando a fun√ß√£o de <code>resolve</code> .  A situa√ß√£o em que essa fun√ß√£o √© chamada √© determinada pelo criador da promessa.  Da mesma forma, quando ocorre um erro, as informa√ß√µes sobre o que aconteceu s√£o retornadas chamando a fun√ß√£o de <code>reject</code> . <br><br>  Agora que sabemos, em termos gerais, como criar promessas, criaremos uma promessa simples para entender melhor tudo. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> keepsHisWord; keepsHisWord = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (keepsHisWord) {   resolve(<span class="hljs-string"><span class="hljs-string">"The man likes to keep his word"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {   reject(<span class="hljs-string"><span class="hljs-string">"The man doesnt want to keep his word"</span></span>); } }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(promise1);</code> </pre> <br>  Aqui est√° o que esse c√≥digo produzir√°: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e2/f52/7a1/8e2f527a185616e8dbb6fa3433303d54.png"></div><br>  <i><font color="#999999">Promise possui um estado (PromiseStatus) e um valor (PromiseValue)</font></i> <br><br>  Como nossa promessa √© instantaneamente resolvida, n√£o podemos investigar seu estado inicial.  Portanto, vamos criar uma nova promessa, que, para resolu√ß√£o, precisa de algum tempo.  A maneira mais f√°cil de fazer isso √© usando a fun√ß√£o <code>setTimeout</code> . <br><br><pre> <code class="hljs javascript">promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   resolve({     <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">"The man likes to keep his word"</span></span>,     <span class="hljs-attr"><span class="hljs-attr">code</span></span>: <span class="hljs-string"><span class="hljs-string">"aManKeepsHisWord"</span></span>   }); }, <span class="hljs-number"><span class="hljs-number">10</span></span> * <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(promise2);</code> </pre> <br>  Nesse c√≥digo, √© criada uma promessa que certamente ser√° resolvida em 10 segundos.  Isso nos d√° a oportunidade de analisar o estado de uma promessa n√£o autorizada. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd4/828/13d/bd482813d5a8d53df3eb39b716b8c0b7.png"></div><br>  <i><font color="#999999">Promessa n√£o resolvida</font></i> <br><br>  Ap√≥s 10 segundos, a promessa ser√° resolvida.  Como resultado, o <code>PromiseStatus</code> e o <code>PromiseValue</code> ser√£o atualizados de acordo.  Como voc√™ pode ver, neste exemplo, alteramos a fun√ß√£o chamada quando a promessa foi resolvida com sucesso, agora ela retorna n√£o uma sequ√™ncia comum, mas um objeto.  Isso √© feito para demonstrar a capacidade de retornar estruturas de dados complexas usando a fun√ß√£o de <code>resolve</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/707/ff7/74a/707ff774ad727f4e41a247714182d7fd.png"></div><br>  <i><font color="#999999">Promessa resolvida ap√≥s 10 segundos e retornando um objeto</font></i> <br><br>  Vamos agora dar uma olhada na promessa, que decidimos n√£o permitir, mas rejeitar.  Para fazer isso, modificamos o c√≥digo que j√° foi usado no primeiro exemplo. <br><br><pre> <code class="hljs javascript">keepsHisWord = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; promise3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (keepsHisWord) {   resolve(<span class="hljs-string"><span class="hljs-string">"The man likes to keep his word"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {   reject(<span class="hljs-string"><span class="hljs-string">"The man doesn't want to keep his word"</span></span>); } }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(promise3);</code> </pre> <br>  Como n√£o lidamos com a situa√ß√£o de rejei√ß√£o da promessa, uma mensagem de erro ser√° exibida no console do navegador (o Google Chrome √© usado aqui).  Falaremos mais sobre isso abaixo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd1/cd1/aa6/bd1cd1aa66cdd5969cb7e8726236938d.png"></div><br>  <i><font color="#999999">Promessa rejeitada</font></i> <br><br>  Agora, analisando todos os tr√™s exemplos, podemos ver que tr√™s valores diferentes podem aparecer no <code>PromiseStatus</code> : <code>pending</code> (pendente), <code>resolved</code> (resolu√ß√£o bem-sucedida) e <code>rejected</code> (rejeitado).  Quando uma promessa √© criada, no <code>PromiseStatus</code> estar√° <code>pending</code> e no <code>PromiseValue</code> ser√° <code>undefined</code> .  Esses valores permanecer√£o at√© que a promessa seja resolvida ou rejeitada.  Quando uma promessa est√° em um estado <code>resolved</code> ou <code>rejected</code> , √© chamada de promessa <code>settled</code> .  Essa promessa passou de um estado de espera para um estado em que ele tem um estado <code>resolved</code> ou um estado <code>rejected</code> . <br><br>  Agora que aprendemos como as promessas s√£o criadas, podemos conversar sobre como processar o que elas retornam.  Para descobrir isso, precisamos entender a estrutura do objeto <code>Promise</code> . <br><br><h2>  <font color="#3AC1EF">Objeto Prometido</font> </h2><br>  De acordo com a documenta√ß√£o do MDN, um objeto <code>Promise</code> √© o resultado de uma conclus√£o bem-sucedida ou malsucedida de uma opera√ß√£o ass√≠ncrona. <br><br>  O objeto <code>Promise</code> possui m√©todos est√°ticos e m√©todos de prot√≥tipo do objeto.  Os m√©todos est√°ticos podem ser chamados sem criar uma inst√¢ncia do objeto e, para chamar os m√©todos de prot√≥tipo, voc√™ precisa de uma inst√¢ncia do objeto <code>Promise</code> .  Lembre-se de que os m√©todos est√°tico e regular retornam objetos <code>Promise</code> .  Isso facilita o trabalho. <br><br><h3>  <font color="#3AC1EF">Prometer m√©todos de prot√≥tipo de objeto</font> </h3><br>  Vamos falar primeiro sobre os m√©todos de prot√≥tipo do objeto <code>Promise</code> .  Existem tr√™s desses m√©todos.  N√£o esque√ßa que esses m√©todos podem ser chamados na inst√¢ncia do objeto <code>Promise</code> e que eles pr√≥prios retornam as promessas.  Gra√ßas a todos esses m√©todos, voc√™ pode atribuir manipuladores que respondem a altera√ß√µes no status das promessas.  Como j√° vimos, quando uma promessa √© criada, ela est√° em um estado <code>pending</code> .  Quando uma promessa √© transferida para um estado <code>resolved</code> ou <code>rejected</code> , pelo menos um dos seguintes m√©todos ser√° chamado: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Promise</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.prototype</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.catch</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">onRejected</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">Promise</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.prototype</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.then</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">onFulfilled</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">onRejected</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">Promise</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.prototype</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.finally</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">onFinally</span></span>)</code> </pre> <br>  Abaixo est√° um diagrama da opera√ß√£o da promessa e dos eventos que levam √† chamada dos <code>.catch</code> e <code>.catch</code> .  Como esses m√©todos retornam objetos <code>Promise</code> , suas chamadas podem ser encadeadas, isso tamb√©m √© refletido no diagrama.  Se a promessa usar o m√©todo <code>.finally</code> , ser√° chamada quando a promessa for movida para o estado <code>settled</code> , independentemente de a promessa ter sido resolvida ou rejeitada com √™xito. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c01/d3a/9bc/c01d3a9bce02c7b7a0a7373bba117a02.png"><br>  <i><font color="#999999">Esquema de trabalho Promis (imagem retirada <a href="">daqui</a> )</font></i> <br><br>  Aqui est√° uma pequena hist√≥ria.  Voc√™ √© estudante e pede √† sua m√£e que lhe compre um telefone celular.  Ela diz: "Se nossa economia for superior ao custo do telefone, eu o comprarei".  Agora reconte esta hist√≥ria em JavaScript. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> momsPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ momsSavings = <span class="hljs-number"><span class="hljs-number">20000</span></span>; priceOfPhone = <span class="hljs-number"><span class="hljs-number">60000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (momsSavings &gt; priceOfPhone) {   resolve({     <span class="hljs-attr"><span class="hljs-attr">brand</span></span>: <span class="hljs-string"><span class="hljs-string">"iphone"</span></span>,     <span class="hljs-attr"><span class="hljs-attr">model</span></span>: <span class="hljs-string"><span class="hljs-string">"6s"</span></span>   }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {   reject(<span class="hljs-string"><span class="hljs-string">"We donot have enough savings. Let us save some more money."</span></span>); } }); momsPromise.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Hurray I got this phone as a gift "</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(value)); }); momsPromise.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Mom coudn't buy me the phone because "</span></span>, reason); }); momsPromise.finally(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(   <span class="hljs-string"><span class="hljs-string">"Irrespecitve of whether my mom can buy me a phone or not, I still love her"</span></span> ); });</code> </pre> <br>  Aqui est√° o que esse c√≥digo produzir√°: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf0/cc9/be3/cf0cc9be3eff013549852e5a27b47823.png"></div><br>  <i><font color="#999999">Mam√£e n√£o cumpriu uma promessa</font></i> <br><br>  Se <code>momsSavings</code> o valor da vari√°vel <code>momsSavings</code> para 200.000, a m√£e poder√° comprar um presente para o filho.  Nesse caso, o c√≥digo acima produzir√° o seguinte. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf5/393/72a/cf539372a0dce219b10136e4b6280de8.png"></div><br>  <i><font color="#999999">Mam√£e manteve uma promessa</font></i> <br><br>  Agora vamos imaginar que o c√≥digo em quest√£o foi projetado como uma biblioteca e usamos essa biblioteca.  Vamos falar sobre o uso efetivo dos <code>.catch</code> e <code>.catch</code> . <br><br>  Como o m√©todo <code>onFulfilled</code> pode ser atribu√≠do tanto ao manipulador <code>onFulfilled</code> que √© chamado quando a promessa √© resolvida com √™xito quanto ao manipulador <code>onRejected</code> que √© chamado quando a promessa √© rejeitada, em vez de usar o m√©todo <code>.catch</code> e o m√©todo <code>.catch</code> , podemos obter o mesmo efeito com apenas um <code>.then</code> m√©todo.  Aqui est√° o que pode parecer: <br><br><pre> <code class="hljs lua">momsPromise.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span></span> {   console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Hurray I got this phone as a gift "</span></span>, JSON.stringify(value)); }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reason)</span></span></span></span> {   console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Mom coudn't buy me the phone because "</span></span>, reason); } );</code> </pre> <br>  Este √© um exemplo <code>.catch</code> , mas para impedir a legibilidade do c√≥digo, √© melhor usar os m√©todos <code>.catch</code> e <code>.catch</code> vez de um <code>.catch</code> universal. <br><br>  Para que esses exemplos sejam executados em um navegador e, especificamente, no Google Chrome, tentei evitar depend√™ncias externas.  Para entender melhor o que consideraremos mais adiante, vamos criar uma fun√ß√£o que retorna uma promessa, cuja resolu√ß√£o ou rejei√ß√£o ocorre aleatoriamente.  Isso nos permitir√° experimentar v√°rios cen√°rios de trabalho com promessas.  Para entender os recursos das fun√ß√µes ass√≠ncronas, definiremos atrasos aleat√≥rios em nossas promessas.  Como precisamos de n√∫meros aleat√≥rios, criamos uma fun√ß√£o que retorna um n√∫mero aleat√≥rio entre <code>x</code> e <code>y</code> .  Aqui est√° a fun√ß√£o. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> getRandomNumber(start = <span class="hljs-number"><span class="hljs-number">1</span></span>, end = <span class="hljs-number"><span class="hljs-number">10</span></span>) { //,      <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> &gt;=<span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parseInt(Math.random() * <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) % (<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>; }</code> </pre> <br>  Agora crie uma fun√ß√£o que retorne promessas.  <code>promiseTRRARNOSG</code> .  O nome dessa fun√ß√£o representa <code>promiseThatResolvesRandomlyAfterRandomNumnberOfSecondsGenerator</code> , ou seja, √© um gerador de promessas que s√£o resolvidas ou rejeitadas aleatoriamente ap√≥s um n√∫mero aleat√≥rio de segundos.  Essa fun√ß√£o criar√° uma promessa que ser√° permitida ou rejeitada ap√≥s um per√≠odo aleat√≥rio entre 2 e 10 segundos.  Para permitir ou rejeitar aleatoriamente uma promessa, obtemos um n√∫mero aleat√≥rio entre 1 e 10. Se esse n√∫mero for maior que 5, a promessa ser√° permitida; caso contr√°rio, ser√° rejeitada. <br><br><pre> <code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRandomNumber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(start = 1, end = 10)</span></span></span></span> { //,      start  <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> &gt;=<span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> &gt; start <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (parseInt(Math.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>() * <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) % (<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> - start + <span class="hljs-number"><span class="hljs-number">1</span></span>)) + start; } var promiseTRRARNOSG = (promiseThatResolvesRandomlyAfterRandomNumnberOfSecondsGenerator = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new Promise(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve, reject)</span></span></span></span> {   let randomNumberOfSeconds = getRandomNumber(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>);   setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {     let randomiseResolving = getRandomNumber(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>);     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (randomiseResolving &gt; <span class="hljs-number"><span class="hljs-number">5</span></span>) {       resolve({         randomNumberOfSeconds: randomNumberOfSeconds,         randomiseResolving: randomiseResolving       });     } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {       reject({         randomNumberOfSeconds: randomNumberOfSeconds,         randomiseResolving: randomiseResolving       });     }   }, randomNumberOfSeconds * <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); }); var testProimse = promiseTRRARNOSG(); testProimse.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span></span> { console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Value when promise is resolved : "</span></span>, value); }); testProimse.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reason)</span></span></span></span> { console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Reason when promise is rejected : "</span></span>, reason); }); //             ,    .     ,  - . <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">1</span></span>; i&lt;=<span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { let promise = promiseTRRARNOSG(); promise.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span></span> {   console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Value when promise is resolved : "</span></span>, value); }); promise.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reason)</span></span></span></span> {   console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Reason when promise is rejected : "</span></span>, reason); }); }</code> </pre> <br>  Execute esse c√≥digo no console do navegador para ver como se comportam as promessas permitidas e rejeitadas.  A seguir, falaremos sobre como voc√™ pode criar muitas promessas e verificar os resultados de sua implementa√ß√£o, usando outros mecanismos. <br><br><h3>  <font color="#3AC1EF">M√©todos est√°ticos de um objeto Promise</font> </h3><br>  Existem quatro m√©todos est√°ticos de um objeto <code>Promise</code> . <br><br>  Aqui est√£o dois m√©todos - <code>Promise.reject(reason)</code> e <code>Promise.resolve(value)</code> , que permitem criar, respectivamente, promessas rejeitadas e permitidas. <br><br>  Veja como trabalhar com o m√©todo <code>Promise.reject</code> , que cria promessas rejeitadas. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promise3 = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.reject(<span class="hljs-string"><span class="hljs-string">"Not interested"</span></span>); promise3.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"This will not run as it is a rejected promise. The resolved value is "</span></span>, value); }); promise3.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"This run as it is a rejected promise. The reason is "</span></span>, reason); });</code> </pre> <br>  Aqui est√° um exemplo usando o m√©todo <code>Promise.resolve</code> que cria promessas resolvidas com sucesso. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promise4 = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(<span class="hljs-number"><span class="hljs-number">1</span></span>); promise4.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"This will run as it is a resovled promise. The resolved value is "</span></span>, value); }); promise4.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"This will not run as it is a resolved promise"</span></span>, reason); });</code> </pre> <br>  Note-se que uma promessa pode ter v√°rios manipuladores.  Por exemplo, com base no exemplo anterior, voc√™ pode obter o c√≥digo mostrado abaixo. <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promise4 = Promise.resolve(<span class="hljs-number"><span class="hljs-number">1</span></span>); promise4.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ console.log("This will run as it is a resovled promise. The resolved value is ", value); }</span></span></span><span class="hljs-function">);</span></span> promise4.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ console.log("This will also run as multiple handlers can be added. Printing twice the resolved value which is ", value * 2); }</span></span></span><span class="hljs-function">);</span></span> promise4.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reason)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ console.log("This will not run as it is a resolved promise", reason); }</span></span></span><span class="hljs-function">);</span></span></code> </pre> <br>  Aqui est√° o que √© exibido no console do navegador: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/644/10b/6d3/64410b6d31e57ab7197e6af1453d9b93.png"></div><br>  <i><font color="#999999">Usando v√°rios .then ao trabalhar com o Promise</font></i> <br><br>  Os dois m√©todos a seguir, <code>Promise.all</code> e <code>Promise.race</code> , foram projetados para trabalhar com conjuntos de promessas.  Se, para resolver um determinado problema, for necess√°rio processar v√°rias promessas, √© mais conveniente coloc√°-las em uma matriz e executar as a√ß√µes necess√°rias com elas.  Para entender a ess√™ncia dos m√©todos aqui considerados, n√£o poderemos usar nossa fun√ß√£o conveniente <code>promiseTRRARNOSG</code> , j√° que o resultado de seu trabalho depende muito da vontade do caso.  Ser√° mais conveniente usar algo que produz promessas mais previs√≠veis, o que nos permitir√° entender seu comportamento.  Portanto, criaremos duas novas fun√ß√µes.  Um deles ( <code>promiseTRSANSG</code> ) criar√° promessas que s√£o resolvidas ap√≥s <code>n</code> segundos, o segundo ( <code>promiseTRJANSG</code> ) - promessas que s√£o rejeitadas ap√≥s <code>n</code> segundos. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promiseTRSANSG = (promiseThatResolvesAfterNSecondsGenerator = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> n = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{   setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{     resolve({       <span class="hljs-attr"><span class="hljs-attr">resolvedAfterNSeconds</span></span>: n     });   }, n * <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promiseTRJANSG = (promiseThatRejectsAfterNSecondsGenerator = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> n = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{   setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{     reject({       <span class="hljs-attr"><span class="hljs-attr">rejectedAfterNSeconds</span></span>: n     });   }, n * <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); });</code> </pre> <br>  Agora, usaremos essas fun√ß√µes para entender os recursos do m√©todo <code>Promise.all</code> . <br><br><h3>  <font color="#3AC1EF">‚ñç M√©todo Promise.all</font> </h3><br>  Na documenta√ß√£o do MDN, voc√™ pode descobrir que o <code>Promise.all(iterable)</code> retorna uma promessa que ser√° resolvida quando todas as promessas aprovadas como argumento <code>iterable</code> forem <code>iterable</code> ou quando esse argumento n√£o contiver promessas.  Essa promessa ser√° rejeitada se alguma das promessas transferidas for rejeitada. <br>  Vejamos alguns exemplos. <br><br><h4>  Exemplo No. 1 </h4><br>  Todas as promessas ser√£o permitidas aqui.  Este cen√°rio √© mais comum. <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesArray = []; promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">1</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handleAllPromises = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all(promisesArray); handleAllPromises.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"All the promises are resolved"</span></span>, values); }); handleAllPromises.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"One of the promises failed with the following reason"</span></span>, reason); });</code> </pre> <br>  Aqui est√° o que esse c√≥digo produzir√° para o console: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cfb/36f/112/cfb36f11242338d72c4541e53a8313f2.png"></div><br>  <i><font color="#999999">Todas as promessas permitidas</font></i> <br><br>  Ap√≥s analisar os resultados deste exemplo, duas observa√ß√µes importantes podem ser feitas. <br><br>  Primeiramente, a terceira promessa, cuja resolu√ß√£o leva 2 segundos, √© conclu√≠da antes da segunda, mas, como pode ser visto na sa√≠da gerada pelo c√≥digo, a ordem das promessas na matriz √© preservada. <br><br>  Em segundo lugar, o c√≥digo cont√©m um cron√¥metro usado para descobrir quanto tempo leva para executar a instru√ß√£o <code>Promise.all</code> . <br><br>  Se as promessas fossem executadas seq√ºencialmente, o tempo de execu√ß√£o desta instru√ß√£o seria de 7 segundos (1 + 4 + 2).  No entanto, o timer informa que toda a opera√ß√£o levou 4 segundos se arredondarmos o resultado.  Isso prova que todas as promessas s√£o executadas em paralelo. <br><br><h4>  Exemplo No. 2 </h4><br>  Agora considere a situa√ß√£o em que n√£o h√° promessas na matriz passada para Promise.all.  Acredito que este √© o caso de uso menos comum para esse recurso. <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesArray = []; promisesArray.push(<span class="hljs-number"><span class="hljs-number">1</span></span>); promisesArray.push(<span class="hljs-number"><span class="hljs-number">4</span></span>); promisesArray.push(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handleAllPromises = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all(promisesArray); handleAllPromises.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"All the promises are resolved"</span></span>, values); }); handleAllPromises.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"One of the promises failed with the following reason"</span></span>, reason); });</code> </pre> <br>  Aqui est√° a sa√≠da que esse c√≥digo ir√° gerar: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/24d/20c/e98/24d20ce98e2939d54fb40d7efe40a98d.png"></div><br>  <i><font color="#999999">Invoque Promise.all e passe uma matriz que n√£o contenha promessas para esse m√©todo</font></i> <br><br>  Como n√£o h√° promessas na matriz, <code>Promise.all</code> quase instantaneamente. <br><br><h4>  Exemplo No. 3 </h4><br>  Agora, vejamos o que acontece quando uma das promessas aprovadas para <code>Promise.all</code> √© rejeitada. <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesArray = []; promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">1</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">5</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">3</span></span>)); promisesArray.push(promiseTRJANSG(<span class="hljs-number"><span class="hljs-number">2</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handleAllPromises = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all(promisesArray); handleAllPromises.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"All the promises are resolved"</span></span>, values); }); handleAllPromises.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"One of the promises failed with the following reason "</span></span>, reason); });</code> </pre> <br>  Como voc√™ pode ver nos resultados da execu√ß√£o do c√≥digo mostrados abaixo, a execu√ß√£o do <code>Promise.all</code> para ap√≥s a primeira promessa rejeitada com a sa√≠da da mensagem que essa promessa fornece. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87a/b92/a32/87ab92a321b372cd6fe3abeba21f16a2.png"></div><br>  <i><font color="#999999">Execu√ß√£o para ap√≥s a primeira promessa rejeitada</font></i> <br><br><h3>  <font color="#3AC1EF">M√©todo Promise.race</font> </h3><br>  O MDN relata que o <code>Promise.race(iterable)</code> retorna uma promessa permitida ou rejeitada com um valor ou motivo de rejei√ß√£o ap√≥s uma das promessas transmitidas ser respectivamente permitida ou rejeitada. <br><br>  Vejamos exemplos de trabalho com <code>Promise.race</code> . <br><br><h4>  Exemplo No. 1 </h4><br>  Ele mostra o que acontece quando uma das promessas aprovadas no <code>Promise.race</code> √© resolvida antes de qualquer outra pessoa. <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesArray = []; promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">3</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">2</span></span>)); promisesArray.push(promiseTRJANSG(<span class="hljs-number"><span class="hljs-number">3</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesRace = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.race(promisesArray); promisesRace.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"The fasted promise resolved"</span></span>, values); }); promisesRace.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"The fastest promise rejected with the following reason "</span></span>, reason); });</code> </pre> <br>  √â isso que chega ao console depois de executar este exemplo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/010/151/044/0101510448b397d862e2e3a21edb4822.png"></div><br>  <i><font color="#999999">Promis, que resolveu mais rapidamente do que todos os outros</font></i> <br><br>  Todas as promessas aqui s√£o realizadas em paralelo.  A terceira promessa √© resolvida ap√≥s 2 segundos.  Assim que isso acontece, a promessa retornada pelo <code>Promise.race</code> √© resolvida. <br><br><h4>  Exemplo No. 2 </h4><br>  Agora considere a situa√ß√£o em que uma das promessas aprovadas para <code>Promise.race</code> √© rejeitada. <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesArray = []; promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">6</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">5</span></span>)); promisesArray.push(promiseTRJANSG(<span class="hljs-number"><span class="hljs-number">3</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesRace = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.race(promisesArray); promisesRace.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"The fasted promise resolved"</span></span>, values); }); promisesRace.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"The fastest promise rejected with the following reason "</span></span>, reason); });</code> </pre> <br>  Depois de executar este exemplo, o seguinte chegar√° ao console: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/063/6fe/351/0636fe351042cfb51428c33db5595b44.png"></div><br>  <i><font color="#999999">Promessa rejeitada antes de todos os outros</font></i> <br><br>  As promessas aqui, como nos exemplos anteriores, s√£o realizadas em paralelo.  A quarta promessa √© rejeitada ap√≥s 3 segundos.  Assim que isso acontece, a promessa retornada pelo <code>Promise.race</code> √© rejeitada. <br><br><h2>  <font color="#3AC1EF">Exemplo geral e experimentos</font> </h2><br>  Reuni todos os exemplos que consideramos neste material em um √∫nico local, o que tornar√° mais f√°cil experimentar com eles, para explorar v√°rios cen√°rios de trabalho com promessas.  Esse c√≥digo foi projetado para ser executado em um navegador; portanto, aqui n√£o usamos chamadas de API, n√£o acessamos opera√ß√µes de arquivos e n√£o trabalhamos com bancos de dados.  Embora tudo isso tenha aplica√ß√£o no desenvolvimento de projetos reais, acredito que trabalhar com esses mecanismos pode nos distrair do nosso principal objetivo - promessas.  E o uso de fun√ß√µes simples que simulam atrasos de tempo fornece resultados semelhantes e n√£o nos sobrecarrega com detalhes adicionais. <br><br>  Ao explorar esses exemplos, voc√™ pode experimentar o c√≥digo, os valores das vari√°veis ‚Äã‚Äãe estudar diferentes cen√°rios para o uso de promessas.  Em particular, voc√™ pode usar uma combina√ß√£o dos m√©todos promessaTRJANSG, promessaTRSANSG e promessaTRRARNOSG para simular v√°rios cen√°rios de uso de promessas, o que permitir√° que voc√™ os entenda melhor.  Al√©m disso, observe que o uso do comando <code>console.time</code> permite descobrir o tempo necess√°rio para executar um determinado trecho de c√≥digo e, por exemplo, descobrir se as promessas s√£o executadas em paralelo ou sequencialmente.  Aqui est√° um <a href="">link</a> para a p√°gina principal com o c√≥digo.  A prop√≥sito, se voc√™ quiser, d√™ uma olhada na biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bluebird</a> , que cont√©m alguns m√©todos interessantes para trabalhar com promessas. <br><br><h2>  <font color="#3AC1EF">Sum√°rio</font> </h2><br>  Ofere√ßo a voc√™ uma lista de regras √†s quais adiro ao trabalhar com promessas para us√°-las corretamente. <br><br><ol><li>  Use promessas em situa√ß√µes ao trabalhar com c√≥digo ass√≠ncrono ou de bloqueio. </li><li>  Para lidar com a situa√ß√£o de resolver com √™xito uma promessa, use o m√©todo <code>.then</code> ; nos casos em que a promessa for rejeitada, use <code>.catch</code> . </li><li>  Use os <code>.catch</code> e <code>.catch</code> em todas as promessas. </li><li>  -     ,    ,   <code>.finally</code> . </li><li>  ,  ,      ,   . </li><li>       ,     . </li><li>    <code>Promise</code> ,     ,    ,  . </li><li>  <code>Promise.all</code>         ,        . </li></ol><br> ,      ,      ,     . <br><br>  <b>Caros leitores!</b> ,       ,     ? <br><br><div class="spoiler"> <b class="spoiler_title">-   ,     </b> <div class="spoiler_text"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√≥digo promocional para um desconto de 10% em nossos servidores virtuais: </font><font style="vertical-align: inherit;">Use for health :)</font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/qk/au/oy/qkauoyb4porqes9wmm3jofcs3bg.png"></a> <br><br><font style="vertical-align: inherit;"></font></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt418085/">https://habr.com/ru/post/pt418085/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt418075/index.html">As 5 principais coisas que podem ser impressas em uma impressora 3D [v√≠deo]</a></li>
<li><a href="../pt418077/index.html">Acidentes de ‚Äún√£o assista‚Äù: uma justificativa estat√≠stica para o modo operacional de suporte t√©cnico 24/7</a></li>
<li><a href="../pt418079/index.html">As linguagens de programa√ß√£o mais populares - 2018</a></li>
<li><a href="../pt418081/index.html">Organiza√ß√£o de testes seguros na produ√ß√£o. Parte 1</a></li>
<li><a href="../pt418083/index.html">Servidor simples com GraphQL em vez de REST, implementa√ß√£o em java</a></li>
<li><a href="../pt418087/index.html">80% dos check-outs de autoatendimento est√£o em risco</a></li>
<li><a href="../pt418089/index.html">Vis√£o geral da fresadora CNC SolidCraft</a></li>
<li><a href="../pt418091/index.html">Lista de artigos e literatura sobre NAS</a></li>
<li><a href="../pt418093/index.html">Curso MIT "Seguran√ßa de sistemas de computadores". Aula 3: Estouros de Buffer: Explora√ß√µes e Prote√ß√£o, Parte 2</a></li>
<li><a href="../pt418095/index.html">Sobre o dispositivo da funcionalidade de teste integrada no Rust (tradu√ß√£o)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>