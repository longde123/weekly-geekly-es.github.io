<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçüîß üßùüèø üëàüèæ No√ß√µes b√°sicas de campo de dist√¢ncia assinado em 2D üë∑üèº üëÇüèº ‚óΩÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Embora as malhas sejam a maneira mais simples e vers√°til de renderizar, existem outras op√ß√µes para representar formas em 2D e 3D. Um m√©todo comumente ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>No√ß√µes b√°sicas de campo de dist√¢ncia assinado em 2D</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438316/">  Embora as malhas sejam a maneira mais simples e vers√°til de renderizar, existem outras op√ß√µes para representar formas em 2D e 3D.  Um m√©todo comumente usado s√£o os campos de dist√¢ncia assinada (SDF).  Os campos de dist√¢ncia assinados fornecem um tra√ßado de raio menos dispendioso, permitem que diferentes formas fluam entre si e economizam em texturas de baixa resolu√ß√£o para imagens de alta qualidade. <br><br>  Come√ßaremos gerando o sinal dos campos de dist√¢ncia usando fun√ß√µes em duas dimens√µes, mas depois continuaremos a ger√°-los em 3D.  Usarei as coordenadas do espa√ßo mundial para termos a menor depend√™ncia poss√≠vel de dimensionamento e coordenadas UV; portanto, se voc√™ n√£o entender como ele funciona, estude este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tutorial em uma sobreposi√ß√£o plana</a> , o que explica o que acontece. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/eb/w-/sj/ebw-sjziw5loorrc2yj1wsl1vyu.gif"></div><a name="habracut"></a><br><h2>  Prepara√ß√£o da funda√ß√£o </h2><br>  Vamos jogar fora temporariamente as propriedades do sombreador de sobreposi√ß√£o plana de base, porque, por enquanto, cuidaremos da base t√©cnica.  Em seguida, escrevemos a posi√ß√£o do v√©rtice no mundo diretamente na estrutura do fragmento, e n√£o o converteremos primeiro em UV.  No √∫ltimo est√°gio de prepara√ß√£o, escreveremos uma nova fun√ß√£o que calcula a cena e retorna a dist√¢ncia para a superf√≠cie mais pr√≥xima.  Ent√£o chamamos as fun√ß√µes e usamos o resultado como uma cor. <br><br><pre><code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Tutorial/034_2D_SDF_Basics"</span></span>{ SubShader{ <span class="hljs-comment"><span class="hljs-comment">//           Tags{ "RenderType"="Opaque" "Queue"="Geometry"} Pass{ CGPROGRAM #include "UnityCG.cginc" #pragma vertex vert #pragma fragment frag struct appdata{ float4 vertex : POSITION; }; struct v2f{ float4 position : SV_POSITION; float4 worldPos : TEXCOORD0; }; v2f vert(appdata v){ v2f o; //         o.position = UnityObjectToClipPos(v.vertex); //     o.worldPos = mul(unity_ObjectToWorld, v.vertex); return o; } float scene(float2 position) { //      return 0; } fixed4 frag(v2f i) : SV_TARGET{ float dist = scene(i.worldPos.xz); fixed4 col = fixed4(dist, dist, dist, 1); return col; } ENDCG } } FallBack "Standard" //fallback   ,       }</span></span></code> </pre> <br>  Escreverei todas as fun√ß√µes para os campos de dist√¢ncia assinados em um arquivo separado, para que possamos us√°-los repetidamente.  Para fazer isso, vou criar um novo arquivo.  N√£o adicionaremos nenhum mal a ele, depois o definiremos e concluiremos a prote√ß√£o condicional de inclus√£o, verificando primeiro se a vari√°vel de pr√©-processador est√° definida.  Se ainda n√£o estiver definido, n√≥s o definimos e conclu√≠mos a constru√ß√£o condicional if ap√≥s as fun√ß√µes que queremos incluir.  A vantagem disso √© que, se adicionarmos o arquivo duas vezes (por exemplo, se adicionarmos dois arquivos diferentes, cada um com as fun√ß√µes necess√°rias e os dois adicionarem o mesmo arquivo), isso quebrar√° o sombreador.  Se voc√™ tiver certeza de que isso nunca acontecer√°, n√£o poder√° executar esta verifica√ß√£o. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// in include file // include guards that keep the functions from being included more than once #ifndef SDF_2D #define SDF_2D // functions #endif</span></span></code> </pre> <br>  Se o arquivo de inclus√£o estiver localizado na mesma pasta que o shader principal, podemos simplesmente inclu√≠-lo usando a constru√ß√£o pragma. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// in main shader #include "2D_SDF.cginc"</span></span></code> </pre> <br>  Portanto, veremos apenas uma superf√≠cie preta na superf√≠cie renderizada, pronta para exibir a dist√¢ncia com um sinal nela. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/25b/a3a/188/25ba3a188962c645fc6a12cfb5aed751.png"></div><br><h2>  C√≠rculo </h2><br>  A fun√ß√£o mais simples do campo de dist√¢ncia sinalizada √© a fun√ß√£o de c√≠rculo.  A fun√ß√£o receber√° apenas a posi√ß√£o da amostra e o raio do c√≠rculo.  Come√ßamos obtendo o comprimento do vetor de posi√ß√£o da amostra.  Portanto, obtemos um ponto na posi√ß√£o (0, 0), que √© semelhante a um c√≠rculo com um raio de 0. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">circle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 samplePosition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length(samplePosition); }</code> </pre> <br>  Em seguida, voc√™ pode chamar a fun√ß√£o de c√≠rculo na fun√ß√£o de cena e retornar a dist√¢ncia que ela retorna. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 position)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDistance = circle(position, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sceneDistance; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/839/6a8/f87/8396a8f8780b6b30deb88d1009f6f5c7.png"></div><br>  Em seguida, adicionamos o raio aos c√°lculos.  Um aspecto importante das fun√ß√µes de dist√¢ncia assinada √© que, quando estamos dentro do objeto, obtemos uma dist√¢ncia negativa da superf√≠cie (√© isso que a palavra assinado significa no campo de dist√¢ncia assinada da express√£o).  Para aumentar o c√≠rculo para um raio, subtra√≠mos o raio do comprimento.  Assim, a superf√≠cie, que est√° em toda parte onde a fun√ß√£o retorna 0, se move para fora.  O que est√° em duas unidades da dist√¢ncia da superf√≠cie para um c√≠rculo com tamanho 0, √© apenas uma unidade de um c√≠rculo com raio de 1 e uma unidade dentro do c√≠rculo (o valor √© -1) para um c√≠rculo com raio de 3; <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">circle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 samplePosition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length(samplePosition) - radius; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7a/b83/57f/e7ab8357f4c844bc7bc58dfda6406d9d.png"></div><br>  Agora, a √∫nica coisa que n√£o podemos fazer √© mover o c√≠rculo do centro.  Para corrigir isso, voc√™ pode adicionar um novo argumento √† fun√ß√£o c√≠rculo para calcular a dist√¢ncia entre a posi√ß√£o da amostra e o centro do c√≠rculo e subtrair o raio desse valor para definir um c√≠rculo.  Ou, voc√™ pode redefinir a origem movendo o espa√ßo do ponto de amostra e, em seguida, obter um c√≠rculo nesse espa√ßo.  A segunda op√ß√£o parece muito mais complicada, mas como mover objetos √© uma opera√ß√£o que queremos usar para todas as figuras, √© muito mais universal e, portanto, explicarei. <br><br><h2>  Movendo </h2><br>  "Transforma√ß√£o do espa√ßo de um ponto" - soa muito pior do que realmente √©.  Isso significa que passamos o ponto para a fun√ß√£o, e a fun√ß√£o o altera para que ainda possamos us√°-lo no futuro.  No caso de uma transfer√™ncia, simplesmente subtra√≠mos o deslocamento do ponto.  A posi√ß√£o √© subtra√≠da quando queremos mover as formas na dire√ß√£o positiva, porque as formas que renderizamos no espa√ßo se movem na dire√ß√£o oposta √† movimenta√ß√£o do espa√ßo. <br><br>  Por exemplo, se queremos desenhar uma esfera na posi√ß√£o <code>(3, 4)</code> , precisamos alterar o espa√ßo para que <code>(3, 4)</code> transforme em <code>(0, 0)</code> , e para isso precisamos subtrair <code>(3, 4)</code> .  Agora, se desenharmos uma esfera em torno de um <i>novo</i> ponto de origem, ser√° um ponto <i>antigo</i> <code>(3, 4)</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// in sdf functions include file float2 translate(float2 samplePosition, float2 offset){ return samplePosition - offset; }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 position)</span></span></span><span class="hljs-function"> </span></span>{ float2 circlePosition = translate(position, float2(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDistance = circle(circlePosition, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sceneDistance; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e5/7ca/6cc/7e57ca6cc1b5953b03811fd2d48ac3f1.png"></div><br><h2>  Ret√¢ngulo </h2><br>  Outra forma simples √© um ret√¢ngulo.  Para come√ßar, consideramos os componentes separadamente.  Primeiro, obtemos a dist√¢ncia do centro, assumindo o valor absoluto.  Ent√£o, da mesma forma que um c√≠rculo, subtra√≠mos metade do tamanho (que basicamente se assemelha ao raio de um ret√¢ngulo).  Para apenas mostrar como ser√£o os resultados, retornaremos apenas um componente por enquanto. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rectangle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 samplePosition, float2 halfSize)</span></span></span></span>{ float2 componentWiseEdgeDistance = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(samplePosition) - halfSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> componentWiseEdgeDistance.x; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/14d/d5f/62a/14dd5f62af057366f38cdfaa2bc19315.png"></div><br>  Agora podemos obter uma vers√£o barata do ret√¢ngulo simplesmente retornando o maior componente 2. Isso funciona em muitos casos, mas n√£o corretamente, porque n√£o exibe a dist√¢ncia correta nos cantos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9c/b19/e06/a9cb19e061cb980c3fe8a2d533b2fbfb.png"></div><br>  Os valores corretos para o ret√¢ngulo fora da figura podem ser obtidos, primeiro levando o m√°ximo entre as dist√¢ncias at√© as arestas e 0, e depois o comprimento. <br><br>  Se n√£o limitarmos a dist√¢ncia abaixo de 0, simplesmente calculamos a dist√¢ncia at√© os cantos (onde as dist√¢ncias das arestas s√£o <code>(0, 0)</code> ), mas as coordenadas entre os cantos n√£o cair√£o abaixo de 0, portanto, toda a aresta ser√° usada.  A desvantagem disso √© que 0 √© usado como a dist√¢ncia da borda para todo o interior da figura. <br><br>  Para corrigir a dist√¢ncia 0 para toda a parte interna, √© necess√°rio gerar a dist√¢ncia interna, simplesmente usando a f√≥rmula de ret√¢ngulo barato (obtendo o valor m√°ximo do componente xey) e garantindo que nunca exceda 0, levando o valor m√≠nimo para 0. Em seguida, adicionamos a dist√¢ncia externa, que nunca √© menor que 0, e a dist√¢ncia interna, que nunca excede 0, e obtemos a fun√ß√£o de dist√¢ncia finalizada. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rectangle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 samplePosition, float2 halfSize)</span></span></span></span>{ float2 componentWiseEdgeDistance = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(samplePosition) - halfSize; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> outsideDistance = length(max(componentWiseEdgeDistance, <span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> insideDistance = min(max(componentWiseEdgeDistance.x, componentWiseEdgeDistance.y), <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> outsideDistance + insideDistance; }</code> </pre> <br>  Como j√° gravamos a fun√ß√£o de transfer√™ncia de forma universal, agora tamb√©m podemos us√°-la para mover seu centro para qualquer lugar. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 position)</span></span></span><span class="hljs-function"> </span></span>{ float2 circlePosition = translate(position, float2(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDistance = rectangle(circlePosition, float2(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sceneDistance; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc0/8eb/671/cc08eb671ae5314ae32d3a20cd685b4b.png"></div><br><h2>  Turn </h2><br>  Girar formas √© semelhante a movimento.  Antes de calcular a dist√¢ncia da figura, giramos as coordenadas na dire√ß√£o oposta.  Para simplificar o m√°ximo poss√≠vel a compreens√£o das rota√ß√µes, multiplicamos a rota√ß√£o por 2 * pi para obter o √¢ngulo em radianos.  Assim, passamos uma rota√ß√£o para a fun√ß√£o, em que 0,25 √© um quarto de volta, 0,5 √© meia volta e 1 √© uma volta completa (voc√™ pode realizar convers√µes de maneira diferente se lhe parecer mais natural).  Tamb√©m invertemos a rota√ß√£o, porque precisamos girar a posi√ß√£o na dire√ß√£o oposta √† rota√ß√£o da figura pelo mesmo motivo que ao mover. <br><br>  Para calcular as coordenadas giradas, primeiro calculamos o seno e o cosseno com base no √¢ngulo.  O Hlsl possui uma fun√ß√£o sincos que calcula esses dois valores mais rapidamente do que quando calculados separadamente. <br><br>  Ao construir um novo vetor para o componente x, pegamos o componente original x multiplicado pelo cosseno e o componente y multiplicado pelo seno.  Isso pode ser facilmente lembrado se voc√™ lembrar que o cosseno de 0 √© 1 e, quando girado por 0, queremos que o componente x do novo vetor seja exatamente o mesmo de antes (ou seja, multiplique por 1).  O componente y, que anteriormente apontou para cima, n√£o contribuiu para o componente x, gira para a direita e seus valores come√ßam em 0, inicialmente ficando maiores, ou seja, seu movimento √© completamente descrito por um seno. <br><br>  Para o componente y do novo vetor, multiplicamos o cosseno pelo componente y do vetor antigo e subtra√≠mos o seno multiplicado pelo componente antigo x.  Para entender por que subtra√≠mos, em vez de adicionar o seno, multiplicado pelo componente x, √© melhor imaginar como o vetor <code>(1, 0)</code> muda quando girado no sentido hor√°rio.  O componente y do resultado come√ßa em 0 e depois se torna menor que 0. Esse √© o oposto de como o seno se comporta, ent√£o trocamos de sinal. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rotate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 samplePosition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rotation)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> PI = <span class="hljs-number"><span class="hljs-number">3.14159</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> angle = rotation * PI * <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sine, cosine; sincos(angle, sine, cosine); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> float2(cosine * samplePosition.x + sine * samplePosition.y, cosine * samplePosition.y - sine * samplePosition.x); }</code> </pre> <br>  Agora que escrevemos o m√©todo de rota√ß√£o, podemos us√°-lo em combina√ß√£o com a transfer√™ncia para mover e girar a figura. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 position)</span></span></span><span class="hljs-function"> </span></span>{ float2 circlePosition = position; circlePosition = rotate(circlePosition, _Time.y); circlePosition = translate(circlePosition, float2(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDistance = rectangle(circlePosition, float2(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sceneDistance; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d46/99b/da0/d4699bda0f35c10163998bd22fac5eab.gif"></div><br>  Nesse caso, primeiro giramos o objeto em torno do centro de toda a cena, para que a rota√ß√£o tamb√©m afete a transfer√™ncia.  Para girar uma figura em rela√ß√£o ao seu pr√≥prio centro, primeiro √© necess√°rio mov√™-la e depois gir√°-la.  Devido a essa ordem alterada no momento da rota√ß√£o, o centro da figura se tornar√° o centro do sistema de coordenadas. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 position)</span></span></span><span class="hljs-function"> </span></span>{ float2 circlePosition = position; circlePosition = translate(circlePosition, float2(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); circlePosition = rotate(circlePosition, _Time.y); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDistance = rectangle(circlePosition, float2(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sceneDistance; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e5/3f3/12d/8e53f312d343fcbe95d000703001da3c.gif"></div><br><h2>  Dimensionamento </h2><br>  A escala funciona de maneira semelhante a outras maneiras de transformar formas.  Dividimos as coordenadas por escala, renderizando a figura no espa√ßo com uma escala reduzida e, no sistema de coordenadas base, elas se tornam maiores. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scale</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 samplePosition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> samplePosition / scale; }</code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 position)</span></span></span><span class="hljs-function"> </span></span>{ float2 circlePosition = position; circlePosition = translate(circlePosition, float2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); circlePosition = rotate(circlePosition, <span class="hljs-number"><span class="hljs-number">.125</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> pulseScale = <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(_Time.y * <span class="hljs-number"><span class="hljs-number">3.14</span></span>); circlePosition = scale(circlePosition, pulseScale); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDistance = rectangle(circlePosition, float2(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sceneDistance; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e66/043/a58/e66043a5877fbdcbcc38629d70334481.gif"></div><br>  Embora isso execute o dimensionamento corretamente, a dist√¢ncia tamb√©m √© dimensionada.  A principal vantagem do campo de dist√¢ncia assinada √© que sempre sabemos a dist√¢ncia da superf√≠cie mais pr√≥xima, mas diminuir o zoom destr√≥i completamente essa propriedade.  Isso pode ser facilmente corrigido multiplicando o campo de dist√¢ncia obtido a partir da fun√ß√£o de dist√¢ncia do sinal (no nosso caso, o <code>rectangle</code> ) pela escala.  Pela mesma raz√£o, n√£o podemos facilmente escalar desigualmente (com escalas diferentes para os eixos x e y). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 position)</span></span></span><span class="hljs-function"> </span></span>{ float2 circlePosition = position; circlePosition = translate(circlePosition, float2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); circlePosition = rotate(circlePosition, <span class="hljs-number"><span class="hljs-number">.125</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> pulseScale = <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(_Time.y * <span class="hljs-number"><span class="hljs-number">3.14</span></span>); circlePosition = scale(circlePosition, pulseScale); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDistance = rectangle(circlePosition, float2(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) * pulseScale; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sceneDistance; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/802/1bd/da1/8021bdda196f8300516f04cdf965c8af.gif"></div><br><h2>  Visualiza√ß√£o </h2><br>  Os campos de dist√¢ncia assinados podem ser usados ‚Äã‚Äãpara v√°rias coisas, como criar sombras, renderizar cenas 3D, f√≠sica e renderizar texto.  Mas ainda n√£o queremos aprofundar a complexidade, portanto, explicarei apenas duas t√©cnicas de visualiza√ß√£o.  A primeira √© uma forma clara com antialiasing, a segunda √© a renderiza√ß√£o de linhas, dependendo da dist√¢ncia. <br><br><h3>  Limpar formul√°rio </h3><br>  Este m√©todo √© semelhante ao que √© frequentemente usado ao renderizar texto, pois cria um formul√°rio claro.  Se queremos gerar um campo de dist√¢ncia n√£o a partir de uma fun√ß√£o, mas l√™-lo a partir de uma textura, isso nos permite usar texturas com uma resolu√ß√£o muito menor do que o habitual e obter bons resultados.  O TextMesh Pro usa essa t√©cnica para renderizar texto. <br><br>  Para aplicar essa t√©cnica, aproveitamos o fato de os dados nos campos de dist√¢ncia serem assinados e conhecemos o ponto de corte.  Come√ßamos calculando a dist√¢ncia que o campo de dist√¢ncia muda para o pr√≥ximo pixel.  Esse deve ser o mesmo valor que o comprimento da altera√ß√£o de coordenadas, mas √© mais f√°cil e confi√°vel calcular a dist√¢ncia com um sinal. <br><br>  Depois de receber a mudan√ßa de dist√¢ncia, podemos fazer um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">passo suave</a> da metade da mudan√ßa de dist√¢ncia para menos / mais metade da mudan√ßa de dist√¢ncia.  Isso far√° um recorte simples em torno de 0, mas com suaviza√ß√£o.  Ent√£o voc√™ pode usar esse valor suavizado para qualquer valor bin√°rio que precisarmos.  Neste exemplo, alterarei o sombreador para um sombreador de transpar√™ncia e o utilizarei para o canal alfa.  Eu passo suavemente de um valor positivo para um negativo porque queremos que o valor negativo do campo de dist√¢ncia seja vis√≠vel.  Se voc√™ n√£o entende bem como a renderiza√ß√£o em transpar√™ncia funciona aqui, recomendo a leitura do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">meu tutorial sobre</a> renderiza√ß√£o em transpar√™ncia. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//properties Properties{ _Color("Color", Color) = (1,1,1,1) }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in subshader outside of pass Tags{ "RenderType"="Transparent" "Queue"="Transparent"} Blend SrcAlpha OneMinusSrcAlpha ZWrite Off</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">fixed4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v2f i)</span></span></span><span class="hljs-function"> : SV_TARGET</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dist = scene(i.worldPos.xz); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distanceChange = fwidth(dist) * <span class="hljs-number"><span class="hljs-number">0.5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> antialiasedCutoff = smoothstep(distanceChange, -distanceChange, dist); fixed4 col = fixed4(_Color, antialiasedCutoff); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> col; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/86d/a08/e1c/86da08e1cfcb25212c6bf3c22dfa1dc8.gif"></div><br><h3>  Linhas de eleva√ß√£o </h3><br>  Outra t√©cnica comum para visualizar campos de dist√¢ncia √© exibir dist√¢ncias como linhas.  Em nossa implementa√ß√£o, adicionarei algumas linhas grossas e algumas finas entre elas.  Tamb√©m pintarei o interior e o exterior da figura em cores diferentes, para que voc√™ possa ver onde est√° o objeto. <br><br>  Come√ßaremos exibindo a diferen√ßa entre o interior e o exterior da figura.  Como as cores podem ser personalizadas no material, adicionaremos novas propriedades, bem como vari√°veis ‚Äã‚Äãde sombreamento para as cores internas e externas da figura. <br><br><pre> <code class="cpp hljs">Properties{ _InsideColor(<span class="hljs-string"><span class="hljs-string">"Inside Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _OutsideColor(<span class="hljs-string"><span class="hljs-string">"Outside Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) }</code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//global shader variables float4 _InsideColor; float4 _OutsideColor;</span></span></code> </pre> <br>  Em seguida, no shader de fragmento, verificamos onde o pixel est√° localizado, que renderizamos comparando a dist√¢ncia com o sinal com 0 usando a fun√ß√£o <code>step</code> .  Usamos essa vari√°vel para interpolar da cor interna para a externa e renderiz√°-la na tela. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">fixed4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v2f i)</span></span></span><span class="hljs-function"> : SV_TARGET</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dist = scene(i.worldPos.xz); fixed4 col = lerp(_InsideColor, _OutsideColor, step(<span class="hljs-number"><span class="hljs-number">0</span></span>, dist)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> col; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/989/13c/15b/98913c15b68cb3fcca4b6d1e4a3f70c0.gif"></div><br>  Para renderizar linhas, primeiro precisamos especificar com que freq√º√™ncia renderizamos as linhas e qual a espessura delas, definindo as propriedades e as vari√°veis ‚Äã‚Äãde sombreamento correspondentes. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Properties _LineDistance("Mayor Line Distance", Range(0, 2)) = 1 _LineThickness("Mayor Line Thickness", Range(0, 0.1)) = 0.05</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//shader variables float _LineDistance; float _LineThickness;</span></span></code> </pre> <br>  Ent√£o, para renderizar as linhas, come√ßaremos calculando a mudan√ßa na dist√¢ncia para que possamos us√°-la mais tarde para suavizar.  Tamb√©m j√° o dividimos por 2, porque mais tarde adicionamos metade e subtra√≠mos metade para cobrir a dist√¢ncia de mudan√ßa de 1 pixel. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distanceChange = fwidth(dist) * <span class="hljs-number"><span class="hljs-number">0.5</span></span>;</code> </pre> <br>  Ent√£o tomamos a dist√¢ncia e a transformamos para que ele tenha o mesmo comportamento em pontos de repeti√ß√£o.  Para fazer isso, primeiro dividimos pela dist√¢ncia entre as linhas, enquanto n√£o obteremos n√∫meros completos a cada primeiro passo, mas n√∫meros completos apenas com base na dist√¢ncia que definimos. <br><br>  Ent√£o adicionamos 0,5 ao n√∫mero, pegamos a parte fracion√°ria e subtra√≠mos 0,5 novamente.  A parte fracion√°ria e a subtra√ß√£o s√£o necess√°rias aqui para que a linha passe por zero no padr√£o de repeti√ß√£o.  Adicionamos 0,5 para obter a parte fracion√°ria, a fim de neutralizar subtra√ß√µes adicionais de 0,5 - o deslocamento levar√° ao fato de que os valores nos quais o gr√°fico √© 0 est√£o em 0, 1, 2 etc., e n√£o em 0,5, 1,5, etc. <br><br>  Os √∫ltimos passos para converter o valor - pegamos o valor absoluto e multiplicamos novamente pela dist√¢ncia entre as linhas.  O valor absoluto torna as √°reas antes e depois dos pontos da linha iguais, o que facilita a cria√ß√£o de recortes para as linhas.  A √∫ltima opera√ß√£o, na qual multiplicamos novamente o valor pela dist√¢ncia entre as linhas, √© necess√°ria para neutralizar a divis√£o no in√≠cio da equa√ß√£o, gra√ßas a ela, a altera√ß√£o no valor √© novamente a mesma do in√≠cio, e a altera√ß√£o calculada anteriormente na dist√¢ncia ainda est√° correta. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a89/db3/de9/a89db3de916eaf871c4525348272a635.png"></div><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> majorLineDistance = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(frac(dist / _LineDistance + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) - <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _LineDistance;</code> </pre> <br>  Agora que calculamos a dist√¢ncia das linhas com base na dist√¢ncia da figura, podemos desenhar as linhas.  Fazemos um passo suave da espessura da linha menos metade da altera√ß√£o na dist√¢ncia para espessura da linha mais metade da mudan√ßa na dist√¢ncia e usamos a dist√¢ncia da linha calculada como um valor para compara√ß√£o.  Depois de calcular esse valor, multiplicamos por cor para criar linhas pretas (voc√™ tamb√©m pode ler uma cor diferente se precisar de linhas coloridas). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">fixed4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v2f i)</span></span></span><span class="hljs-function"> : SV_TARGET</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dist = scene(i.worldPos.xz); fixed4 col = lerp(_InsideColor, _OutsideColor, step(<span class="hljs-number"><span class="hljs-number">0</span></span>, dist)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distanceChange = fwidth(dist) * <span class="hljs-number"><span class="hljs-number">0.5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> majorLineDistance = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(frac(dist / _LineDistance + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) - <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _LineDistance; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> majorLines = smoothstep(_LineThickness - distanceChange, _LineThickness + distanceChange, majorLineDistance); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> col * majorLines; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/890/6b1/452/8906b1452c9d7a05f39b5c3070f2c547.gif"></div><br>  Implementamos linhas finas entre as grossas da mesma maneira - adicionamos uma propriedade que determina quantas linhas finas devem existir entre as grossas e depois fazemos o que fizemos com as grossas, mas, devido √† dist√¢ncia entre as linhas finas, dividimos a dist√¢ncia entre as grossas pelo n√∫mero de linhas finas entre elas. eles.  Tamb√©m <code>IntRange</code> o n√∫mero de linhas finas <code>IntRange</code> , gra√ßas a isso, podemos apenas atribuir valores inteiros e n√£o obter linhas finas que n√£o <code>IntRange</code> grossas.  Depois de calcular as linhas finas, n√≥s as multiplicamos por cor da mesma maneira que as grossas. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//properties [IntRange]_SubLines("Lines between major lines", Range(1, 10)) = 4 _SubLineThickness("Thickness of inbetween lines", Range(0, 0.05)) = 0.01</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//shader variables float _SubLines; float _SubLineThickness;</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">fixed4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v2f i)</span></span></span><span class="hljs-function"> : SV_TARGET</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dist = scene(i.worldPos.xz); fixed4 col = lerp(_InsideColor, _OutsideColor, step(<span class="hljs-number"><span class="hljs-number">0</span></span>, dist)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distanceChange = fwidth(dist) * <span class="hljs-number"><span class="hljs-number">0.5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> majorLineDistance = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(frac(dist / _LineDistance + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) - <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _LineDistance; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> majorLines = smoothstep(_LineThickness - distanceChange, _LineThickness + distanceChange, majorLineDistance); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distanceBetweenSubLines = _LineDistance / _SubLines; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> subLineDistance = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(frac(dist / distanceBetweenSubLines + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) - <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * distanceBetweenSubLines; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> subLines = smoothstep(_SubLineThickness - distanceChange, _SubLineThickness + distanceChange, subLineDistance); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> col * majorLines * subLines; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e8c/664/bf0/e8c664bf0fb16337f77f242c4f3f5c01.gif"></div><br><h2>  C√≥digo fonte </h2><br><h3>  Recursos SDF 2D </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/034_2D_SDF/2D_SDF.cginc</a> </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> SDF_2D #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SDF_2D float2 rotate(float2 samplePosition, float rotation){ const float PI = 3.14159; float angle = rotation * PI * 2 * -1; float sine, cosine; sincos(angle, sine, cosine); return float2(cosine * samplePosition.x + sine * samplePosition.y, cosine * samplePosition.y - sine * samplePosition.x); } float2 translate(float2 samplePosition, float2 offset){ </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//move samplepoint in the opposite direction that we want to move shapes in return samplePosition - offset; } float2 scale(float2 samplePosition, float scale){ return samplePosition / scale; } float circle(float2 samplePosition, float radius){ //get distance from center and grow it according to radius return length(samplePosition) - radius; } float rectangle(float2 samplePosition, float2 halfSize){ float2 componentWiseEdgeDistance = abs(samplePosition) - halfSize; float outsideDistance = length(max(componentWiseEdgeDistance, 0)); float insideDistance = min(max(componentWiseEdgeDistance.x, componentWiseEdgeDistance.y), 0); return outsideDistance + insideDistance; } #endif</span></span></span></span></code> </pre> <br><h3>  Exemplo de c√≠rculo </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/034_2D_SDF/Circle.shader</a> </li></ul><br><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Tutorial/034_2D_SDF_Basics/Rectangle"</span></span>{ SubShader{ <span class="hljs-comment"><span class="hljs-comment">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry Tags{ "RenderType"="Opaque" "Queue"="Geometry"} Pass{ CGPROGRAM #include "UnityCG.cginc" #include "2D_SDF.cginc" #pragma vertex vert #pragma fragment frag struct appdata{ float4 vertex : POSITION; }; struct v2f{ float4 position : SV_POSITION; float4 worldPos : TEXCOORD0; }; v2f vert(appdata v){ v2f o; //calculate the position in clip space to render the object o.position = UnityObjectToClipPos(v.vertex); //calculate world position of vertex o.worldPos = mul(unity_ObjectToWorld, v.vertex); return o; } float scene(float2 position) { float2 circlePosition = position; circlePosition = rotate(circlePosition, _Time.y * 0.5); circlePosition = translate(circlePosition, float2(2, 0)); float sceneDistance = rectangle(circlePosition, float2(1, 2)); return sceneDistance; } fixed4 frag(v2f i) : SV_TARGET{ float dist = scene(i.worldPos.xz); fixed4 col = fixed4(dist, dist, dist, 1); return col; } ENDCG } } FallBack "Standard" //fallback adds a shadow pass so we get shadows on other objects }</span></span></code> </pre> <br><h3>  Exemplo de ret√¢ngulo </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/034_2D_SDF/Rectangle.shader</a> </li></ul><br><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Tutorial/034_2D_SDF_Basics/Rectangle"</span></span>{ SubShader{ <span class="hljs-comment"><span class="hljs-comment">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry Tags{ "RenderType"="Opaque" "Queue"="Geometry"} Pass{ CGPROGRAM #include "UnityCG.cginc" #include "2D_SDF.cginc" #pragma vertex vert #pragma fragment frag struct appdata{ float4 vertex : POSITION; }; struct v2f{ float4 position : SV_POSITION; float4 worldPos : TEXCOORD0; }; v2f vert(appdata v){ v2f o; //calculate the position in clip space to render the object o.position = UnityObjectToClipPos(v.vertex); //calculate world position of vertex o.worldPos = mul(unity_ObjectToWorld, v.vertex); return o; } float scene(float2 position) { float2 circlePosition = position; circlePosition = rotate(circlePosition, _Time.y * 0.5); circlePosition = translate(circlePosition, float2(2, 0)); float sceneDistance = rectangle(circlePosition, float2(1, 2)); return sceneDistance; } fixed4 frag(v2f i) : SV_TARGET{ float dist = scene(i.worldPos.xz); fixed4 col = fixed4(dist, dist, dist, 1); return col; } ENDCG } } FallBack "Standard" //fallback adds a shadow pass so we get shadows on other objects }</span></span></code> </pre> <br><h3>  Cutoff </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/034_2D_SDF/Cutoff.shader</a> </li></ul><br><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Tutorial/034_2D_SDF_Basics/Cutoff"</span></span>{ Properties{ _Color(<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) } SubShader{ Tags{ <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> <span class="hljs-string"><span class="hljs-string">"Queue"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span>} Blend SrcAlpha OneMinusSrcAlpha ZWrite Off Pass{ CGPROGRAM #include <span class="hljs-string"><span class="hljs-string">"UnityCG.cginc"</span></span> #include <span class="hljs-string"><span class="hljs-string">"2D_SDF.cginc"</span></span> #pragma vertex vert #pragma fragment frag struct appdata{ float4 vertex : POSITION; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v2f</span></span></span><span class="hljs-class">{</span></span> float4 position : SV_POSITION; float4 worldPos : TEXCOORD0; }; fixed3 _Color; <span class="hljs-function"><span class="hljs-function">v2f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(appdata v)</span></span></span></span>{ v2f o; <span class="hljs-comment"><span class="hljs-comment">//calculate the position in clip space to render the object o.position = UnityObjectToClipPos(v.vertex); //calculate world position of vertex o.worldPos = mul(unity_ObjectToWorld, v.vertex); return o; } float scene(float2 position) { float2 circlePosition = position; circlePosition = rotate(circlePosition, _Time.y * 0.5); circlePosition = translate(circlePosition, float2(2, 0)); float sceneDistance = rectangle(circlePosition, float2(1, 2)); return sceneDistance; } fixed4 frag(v2f i) : SV_TARGET{ float dist = scene(i.worldPos.xz); float distanceChange = fwidth(dist) * 0.5; float antialiasedCutoff = smoothstep(distanceChange, -distanceChange, dist); fixed4 col = fixed4(_Color, antialiasedCutoff); return col; } ENDCG } } FallBack "Standard" //fallback adds a shadow pass so we get shadows on other objects }</span></span></code> </pre> <br><h3>  Linhas de dist√¢ncia </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/034_2D_SDF/DistanceLines.shader</a> </li></ul><br><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Tutorial/034_2D_SDF_Basics/DistanceLines"</span></span>{ Properties{ _InsideColor(<span class="hljs-string"><span class="hljs-string">"Inside Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _OutsideColor(<span class="hljs-string"><span class="hljs-string">"Outside Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _LineDistance(<span class="hljs-string"><span class="hljs-string">"Mayor Line Distance"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) = <span class="hljs-number"><span class="hljs-number">1</span></span> _LineThickness(<span class="hljs-string"><span class="hljs-string">"Mayor Line Thickness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.05</span></span> [IntRange]_SubLines(<span class="hljs-string"><span class="hljs-string">"Lines between major lines"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)) = <span class="hljs-number"><span class="hljs-number">4</span></span> _SubLineThickness(<span class="hljs-string"><span class="hljs-string">"Thickness of inbetween lines"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.05</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.01</span></span> } SubShader{ <span class="hljs-comment"><span class="hljs-comment">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry Tags{ "RenderType"="Opaque" "Queue"="Geometry"} Pass{ CGPROGRAM #include "UnityCG.cginc" #include "2D_SDF.cginc" #pragma vertex vert #pragma fragment frag struct appdata{ float4 vertex : POSITION; }; struct v2f{ float4 position : SV_POSITION; float4 worldPos : TEXCOORD0; }; v2f vert(appdata v){ v2f o; //calculate the position in clip space to render the object o.position = UnityObjectToClipPos(v.vertex); //calculate world position of vertex o.worldPos = mul(unity_ObjectToWorld, v.vertex); return o; } float scene(float2 position) { float2 circlePosition = position; circlePosition = rotate(circlePosition, _Time.y * 0.2); circlePosition = translate(circlePosition, float2(2, 0)); float sceneDistance = rectangle(circlePosition, float2(1, 2)); return sceneDistance; } float4 _InsideColor; float4 _OutsideColor; float _LineDistance; float _LineThickness; float _SubLines; float _SubLineThickness; fixed4 frag(v2f i) : SV_TARGET{ float dist = scene(i.worldPos.xz); fixed4 col = lerp(_InsideColor, _OutsideColor, step(0, dist)); float distanceChange = fwidth(dist) * 0.5; float majorLineDistance = abs(frac(dist / _LineDistance + 0.5) - 0.5) * _LineDistance; float majorLines = smoothstep(_LineThickness - distanceChange, _LineThickness + distanceChange, majorLineDistance); float distanceBetweenSubLines = _LineDistance / _SubLines; float subLineDistance = abs(frac(dist / distanceBetweenSubLines + 0.5) - 0.5) * distanceBetweenSubLines; float subLines = smoothstep(_SubLineThickness - distanceChange, _SubLineThickness + distanceChange, subLineDistance); return col * majorLines * subLines; } ENDCG } } FallBack "Standard" //fallback adds a shadow pass so we get shadows on other objects }</span></span></code> </pre> <br>  Espero ter conseguido explicar o b√°sico dos campos de dist√¢ncia com um sinal e voc√™ j√° est√° aguardando alguns novos tutoriais nos quais falarei sobre outras maneiras de us√°-los. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt438316/">https://habr.com/ru/post/pt438316/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt438304/index.html">Subcontrata√ß√£o? Legal, voc√™ bate</a></li>
<li><a href="../pt438306/index.html">Radia√ß√£o: Laborat√≥rio radioqu√≠mico durante a semana</a></li>
<li><a href="../pt438310/index.html">Instagram usa aprendizado de m√°quina para remover seguidores falsos</a></li>
<li><a href="../pt438312/index.html">Automa√ß√£o de rede com Ansible: m√≥dulo de comando</a></li>
<li><a href="../pt438314/index.html">1. Check Point Maestro Hyperscale Network Security - uma nova plataforma de seguran√ßa escal√°vel</a></li>
<li><a href="../pt438318/index.html">Como dominar a sintaxe ass√≠ncrona / aguardar: um exemplo real</a></li>
<li><a href="../pt438320/index.html">Ensinar as crian√ßas a programar</a></li>
<li><a href="../pt438322/index.html">VSaaS 2025: tecnologia de CFTV do futuro</a></li>
<li><a href="../pt438326/index.html">5G na R√∫ssia: por que √© necess√°rio, quanto custa e quando aparecer√°? Brevemente sobre o principal</a></li>
<li><a href="../pt438328/index.html">Como inflou a bolha salarial para programadores?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>