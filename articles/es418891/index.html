<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßöüèΩ üë®‚ÄçüöÄ üë©üèª‚Äç‚öñÔ∏è Verificamos los c√≥digos fuente de Android usando PVS-Studio, o nadie es perfecto üë©üèø‚Äçü§ù‚Äçüë®üèæ ü¶ç üåµ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A. 
 El desarrollo de grandes proyectos complejos es imposible sin el uso de metodolog√≠as de programaci√≥n y herramientas para ayudar a controlar la ca...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verificamos los c√≥digos fuente de Android usando PVS-Studio, o nadie es perfecto</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/418891/">  A. <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d66/7b5/688/d667b56886adb4c140b623e5c14d4fd5.png" alt="Android y Unicorn PVS-Studio"></div><br>  El desarrollo de grandes proyectos complejos es imposible sin el uso de metodolog√≠as de programaci√≥n y herramientas para ayudar a controlar la calidad del c√≥digo.  En primer lugar, es un est√°ndar de codificaci√≥n competente, revisiones de c√≥digo, pruebas unitarias, analizadores de c√≥digo est√°tico y din√°mico.  Todo esto ayuda a identificar defectos en el c√≥digo en las primeras etapas de desarrollo.  Este art√≠culo demuestra las capacidades del analizador est√°tico PVS-Studio para detectar errores y vulnerabilidades potenciales en el c√≥digo del sistema operativo Android.  Esperamos que el art√≠culo atraiga a los lectores a la metodolog√≠a del an√°lisis de c√≥digo est√°tico y quieran implementarlo en el proceso de desarrollo de sus propios proyectos. <br><a name="habracut"></a><br><h2>  Introduccion </h2><br>  Ha pasado un a√±o desde la redacci√≥n de un gran <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo</a> sobre errores en el sistema operativo Tizen, y quer√≠a volver a realizar un estudio igualmente interesante de alg√∫n tipo de sistema operativo.  La elecci√≥n recay√≥ en Android. <br><br>  El c√≥digo del sistema operativo Android es de calidad, bien probado.  Durante el desarrollo, se utiliza al menos un analizador de c√≥digo est√°tico Coverity, como lo demuestran los comentarios de la forma: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Coverity: [FALSE-POSITIVE error] intended fall through */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Missing break statement between cases in switch statement */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* fall through */</span></span></code> </pre> <br>  En general, este es un proyecto interesante y de alta calidad, y encontrar errores en √©l es un desaf√≠o para nuestro analizador est√°tico PVS-Studio. <br><br>  Creo que solo por el volumen del art√≠culo, el lector comprende que el analizador PVS-Studio hizo un excelente trabajo y encontr√≥ muchos defectos en el c√≥digo de este sistema operativo. <br><br><h2>  Enumeraci√≥n de debilidad com√∫n </h2><br>  En el art√≠culo encontrar√° referencias a la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enumeraci√≥n de debilidad com√∫n</a> (CWE).  Perm√≠tanos explicar la raz√≥n para referirse a esta lista y por qu√© es importante desde el punto de vista de la seguridad. <br><br>  A menudo, la causa de las vulnerabilidades en los programas no es un conjunto complicado de circunstancias, sino un error de software banal.  Aqu√≠ ser√° apropiado citar esta cita de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">prqa.com</a> : <br><br>  El Instituto Nacional de Est√°ndares y Tecnolog√≠a (NIST) informa que el 64% de las vulnerabilidades de software provienen de errores de programaci√≥n y no de la falta de caracter√≠sticas de seguridad. <br><br>  Puede leer en el art√≠culo " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬øC√≥mo PVS-Studio puede ayudar a encontrar vulnerabilidades?</a> " Con algunos ejemplos de errores simples que condujeron a vulnerabilidades en proyectos como MySQL, iOS, NAS, illumos-gate. <br><br>  En consecuencia, se pueden eliminar muchas vulnerabilidades al detectar errores comunes a tiempo y corregirlos.  Y aqu√≠ la Enumeraci√≥n de Debilidad Com√∫n entra en escena. <br><br>  Los errores son diferentes, y no todos los errores son peligrosos desde el punto de vista de la seguridad.  Los errores que podr√≠an causar vulnerabilidades se recopilan en la enumeraci√≥n de debilidad com√∫n.  Esta lista se est√° actualizando y probablemente haya errores que pueden generar vulnerabilidades, pero a√∫n no se han incluido en esta lista. <br><br>  Sin embargo, si el error se clasifica seg√∫n el CWE, significa que es te√≥ricamente posible que pueda explotarse como una vulnerabilidad ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CVE</a> ).  S√≠, la probabilidad de esto es peque√±a.  Muy raramente, CWE se convierte en CVE.  Sin embargo, si desea proteger su c√≥digo de vulnerabilidades, debe, si es posible, encontrar tantos errores descritos en CWE como sea posible y solucionarlos. <br><br>  Esquem√°ticamente, la relaci√≥n entre PVS-Studio, errores, CWE y CVE se muestra en la figura: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/06f/5b9/142/06f5b9142918167cf4e0951f3affbaa6.png" alt="CWE, CVE, PVS-Studio"></div><br><br>  Algunos errores se clasifican como CWE.  PVS-Studio puede detectar muchos de estos errores, evitando as√≠ que algunos de estos defectos se conviertan en vulnerabilidades (CVE). <br><br>  Podemos decir que PVS-Studio identifica muchas vulnerabilidades potenciales antes de que causen da√±os.  Por lo tanto, PVS-Studio es una herramienta de prueba de seguridad de aplicaciones est√°ticas ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SAST</a> ). <br><br>  Ahora, creo, est√° claro por qu√©, al describir los errores, consider√© importante tener en cuenta c√≥mo se clasifican seg√∫n el CWE.  De esta manera, es m√°s f√°cil mostrar la importancia de usar un analizador de c√≥digo est√°tico en proyectos cr√≠ticos, con los que los sistemas operativos se relacionan claramente. <br><br><h2>  Verificaci√≥n de Android </h2><br>  Para analizar el proyecto, utilic√© el analizador PVS-Studio versi√≥n 6.24.  El analizador actualmente admite los siguientes lenguajes y compiladores: <br><br><ul><li>  Ventanas  Visual Studio 2010-2017 C, C ++, C ++ / CLI, C ++ / CX (WinRT), C # </li><li>  Ventanas  IAR Embedded Workbench, compilador C / C ++ para ARM C, C ++ </li><li>  Windows / Linux  Keil ¬µVision, DS-MDK, compilador ARM 5/6 C, C ++ </li><li>  Windows / Linux  Texas Instruments Code Composer Studio, Herramientas de generaci√≥n de c√≥digo ARM C, C ++ </li><li>  Windows / Linux / macOS.  Clang C, C ++ </li><li>  Linux / macOS.  CCG C, C ++ </li><li>  Ventanas  MinGW C, C ++ </li></ul><br>  Nota  Quiz√°s algunos de nuestros lectores se hayan perdido la noticia de que apoyamos el trabajo en el entorno macOS y les interesar√° esta publicaci√≥n: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Versi√≥n PVS-Studio para macOS: 64 debilidades en el n√∫cleo Apple XNU</a> ". <br><br>  El proceso de verificar el c√≥digo fuente de Android no fue un problema, por lo que no me detendr√© en √©l.  El problema, m√°s bien, era mi preocupaci√≥n por otras tareas, por lo que no encontr√© el tiempo y la energ√≠a para mirar el informe tan cuidadosamente como me gustar√≠a.  Sin embargo, incluso un vistazo r√°pido fue m√°s que suficiente para reunir una gran colecci√≥n de errores interesantes para un art√≠culo s√≥lido. <br><br>  Lo m√°s importante: les pido a los desarrolladores de Android que no solo corrijan los errores descritos en el art√≠culo, sino que tambi√©n realicen un an√°lisis independiente m√°s cuidadoso.  Mir√© el informe del analizador superficialmente y podr√≠a haber pasado por alto muchos errores graves. <br><br>  En la primera prueba, el analizador producir√° muchos falsos positivos, pero <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esto no es un problema</a> .  Nuestro equipo est√° listo para ayudar con las recomendaciones sobre la configuraci√≥n del analizador para reducir la cantidad de falsos positivos.  Tambi√©n estamos listos para proporcionar una clave de licencia por un mes o m√°s, si es necesario.  En general, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">escr√≠benos</a> , te ayudaremos y te lo diremos. <br><br>  Ahora veamos qu√© errores y vulnerabilidades potenciales logr√© encontrar.  Espero que disfrute lo que puede encontrar el analizador de c√≥digo est√°tico PVS-Studio.  Que tengas una buena lectura. <br><br><h2>  Comparaciones sin sentido </h2><br>  El analizador considera que las expresiones son anormales si siempre son verdaderas o falsas.  Dichas advertencias, de acuerdo con la enumeraci√≥n de debilidad com√∫n, se clasifican como: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CWE-570</a> : La expresi√≥n siempre es falsa </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CWE-571</a> : La expresi√≥n es siempre verdadera </li></ul><br>  El analizador genera muchas de estas advertencias y, desafortunadamente, la mayor√≠a de ellas son falsas para el c√≥digo de Android.  En este caso, el analizador no tiene la culpa.  Solo el c√≥digo est√° escrito as√≠. <br>  Lo demostrar√© con un simple ejemplo. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> GENERIC_TARGET const char alternative_config_path[] = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/data/nfc/"</span></span></span><span class="hljs-meta">; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> const char alternative_config_path[] = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta">; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> CNxpNfcConfig&amp; CNxpNfcConfig::GetInstance() { .... </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (alternative_config_path[0] != </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'\0'</span></span></span><span class="hljs-meta">) { .... }</span></span></code> </pre> <br>  Aqu√≠ el analizador genera una advertencia: V547 CWE-570 La expresi√≥n 'alternative_config_path [0]! =' \ 0 '' siempre es falsa.  phNxpConfig.cpp 401 <br><br>  El hecho es que la macro <i>GENERIC_TARGET</i> no est√° definida y, desde el punto de vista del analizador, el c√≥digo se ve as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> alternative_config_path[] = <span class="hljs-string"><span class="hljs-string">""</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (alternative_config_path[<span class="hljs-number"><span class="hljs-number">0</span></span>] != <span class="hljs-string"><span class="hljs-string">'\0'</span></span>) {</code> </pre> <br>  El analizador simplemente est√° obligado a emitir una advertencia, ya que la l√≠nea est√° vac√≠a y un terminal cero siempre se encuentra en el desplazamiento cero.  Por lo tanto, el analizador tiene formalmente raz√≥n al emitir una advertencia.  Sin embargo, desde un punto de vista pr√°ctico, no hay beneficio de esta advertencia. <br><br>  Desafortunadamente, nada se puede hacer con tales situaciones.  Tendremos que revisar sistem√°ticamente todas esas advertencias y marcar muchos lugares como falsos positivos para que el analizador ya no emita mensajes en estas l√≠neas.  Esto realmente debe hacerse porque, adem√°s de los mensajes sin sentido, se encontrar√°n muchos defectos reales. <br><br>  Admito honestamente que no estaba interesado en mirar cuidadosamente las advertencias de este tipo, y las revis√© superficialmente.  Sin embargo, incluso esto ser√° suficiente para mostrar que tales diagn√≥sticos son muy √∫tiles y encuentran errores interesantes. <br><br>  Quiero comenzar con la situaci√≥n cl√°sica cuando la funci√≥n de comparar dos objetos se implementa incorrectamente.  ¬øPor qu√© cl√°sico?  Este es un patr√≥n de error t√≠pico que encontramos constantemente en una variedad de proyectos.  Lo m√°s probable es que haya tres razones para que ocurra: <br><br><ol><li>  Las funciones de comparaci√≥n son simples y est√°n escritas "autom√°ticamente" y utilizando la tecnolog√≠a Copy-Paste.  Al escribir dicho c√≥digo, una persona no est√° atenta y a menudo comete errores tipogr√°ficos. </li><li>  Por lo general, la revisi√≥n de c√≥digo no se realiza para tales funciones, ya que es demasiado vago para considerar funciones simples y aburridas. </li><li>  Las pruebas unitarias generalmente no se realizan para tales funciones.  Porque la pereza.  Adem√°s, las funciones son simples y los programadores no piensan que sean posibles errores en ellas. </li></ol><br>  Estos pensamientos y ejemplos se describen con m√°s detalle en el art√≠culo "El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mal vive en las funciones de comparaci√≥n</a> ". <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isAudioPlaybackRateEqual</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AudioPlaybackRate &amp;pr1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AudioPlaybackRate &amp;pr2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">fabs</span></span>(pr1.mSpeed - pr2.mSpeed) &lt; AUDIO_TIMESTRETCH_SPEED_MIN_DELTA &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">fabs</span></span>(pr1.mPitch - pr2.mPitch) &lt; AUDIO_TIMESTRETCH_PITCH_MIN_DELTA &amp;&amp; pr2.mStretchMode == pr2.mStretchMode &amp;&amp; pr2.mFallbackMode == pr2.mFallbackMode; }</code> </pre> <br>  Entonces, ante nosotros est√° la funci√≥n cl√°sica de comparar dos objetos de tipo <i>AudioPlaybackRate</i> .  Y, como creo, el lector adivina que est√° mal.  El analizador PVS-Studio nota dos errores tipogr√°ficos de inmediato: <br><br><ul><li>  V501 CWE-571 Hay subexpresiones id√©nticas a la izquierda y a la derecha del operador '==': pr2.mStretchMode == pr2.mStretchMode AudioResamplerPublic.h 107 </li><li>  V501 CWE-571 Hay subexpresiones id√©nticas a la izquierda y a la derecha del operador '==': pr2.mFallbackMode == pr2.mFallbackMode AudioResamplerPublic.h 108 </li></ul><br>  El campo <i>pr2.mStretchMode</i> y el campo <i>pr2.mFallbackMode se</i> comparan entre s√≠.  Resulta que la funci√≥n no compara objetos con la suficiente precisi√≥n. <br><br>  La siguiente comparaci√≥n sin sentido vive en una funci√≥n que almacena informaci√≥n de huellas digitales en un archivo. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveFingerprint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">worker_thread_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* listener, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> idx)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ns = fwrite(&amp;listener-&gt;secureid[idx], <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>, fp); .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nf = fwrite(&amp;listener-&gt;fingerid[idx], <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>, fp); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ns != <span class="hljs-number"><span class="hljs-number">1</span></span> || ns !=<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// &lt;= ALOGW("Corrupt emulator fingerprints storage; " "could not save fingerprints"); fclose(fp); return; }</span></span></code> </pre> <br>  Dos diagn√≥sticos detectan una anomal√≠a en este c√≥digo a la vez: <br><br><ul><li>  V501 CWE-570 Hay subexpresiones id√©nticas a la izquierda y a la derecha de '||'  operador: ns! = 1 ||  ns! = 1 huella digital.c 126 </li><li>  V560 CWE-570 Una parte de la expresi√≥n condicional siempre es falsa: ns! = 1. fingerprint.c 126 </li></ul><br>  No se maneja la situaci√≥n cuando la segunda llamada a la funci√≥n <i>fwrite</i> no puede escribir datos en un archivo.  En otras palabras, el valor de la variable <i>nf</i> no <i>est√°</i> marcado.  La verificaci√≥n correcta deber√≠a verse as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ns != <span class="hljs-number"><span class="hljs-number">1</span></span> || nf != <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Pasamos al siguiente error asociado con el uso del operador <i>&amp;</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> O_RDONLY 00000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> O_WRONLY 00000001 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> O_RDWR 00000002 static ssize_t verity_read(fec_handle *f, ....) { .... </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* if we are in read-only mode and expect to read a zero block, skip reading and just return zeros */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (f-&gt;mode &amp; O_RDONLY &amp;&amp; expect_zeros) { memset(data, 0, FEC_BLOCKSIZE); goto valid; } .... }</span></span></code> </pre> <br>  Advertencia de PVS-Studio: V560 CWE-570 Una parte de la expresi√≥n condicional siempre es falsa: f-&gt; mode &amp; 00000000. fec_read.cpp 322 <br><br>  Tenga en cuenta que la constante <i>O_RDONLY</i> es cero.  Esto hace que la expresi√≥n <i>f-&gt; mode &amp; O_RDONLY no tenga</i> sentido, ya que siempre es 0. Resulta que la condici√≥n de la <i>declaraci√≥n if</i> nunca se cumple, y la declaraci√≥n-true es un c√≥digo muerto. <br><br>  La verificaci√≥n correcta deber√≠a ser as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f-&gt;mode == O_RDONLY &amp;&amp; expect_zeros) {</code> </pre> <br>  Ahora veamos un error tipogr√°fico cl√°sico cuando olvidamos escribir parte de la condici√≥n. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { .... CHANGE_DISPLAY_INFO = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>, .... }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> RotaryEncoderInputMapper::configure(<span class="hljs-keyword"><span class="hljs-keyword">nsecs_t</span></span> when, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> InputReaderConfiguration* config, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> changes) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!changes || (InputReaderConfiguration::CHANGE_DISPLAY_INFO)) { .... }</code> </pre> <br>  Advertencia de PVS-Studio: V768 CWE-571 La constante de enumeraci√≥n 'CHANGE_DISPLAY_INFO' se usa como una variable de tipo booleano.  InputReader.cpp 3016 <br><br>  La condici√≥n siempre es verdadera, ya que el operando <i>InputReaderConfiguration :: CHANGE_DISPLAY_INFO</i> es una constante igual a 4. <br><br>  Si observa c√≥mo se escribe el c√≥digo en el vecindario, queda claro que, de hecho, la condici√≥n deber√≠a ser as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!changes || (changes &amp; InputReaderConfiguration::CHANGE_DISPLAY_INFO)) {</code> </pre> <br>  La siguiente comparaci√≥n, que no tiene sentido, la conoc√≠ en el operador de bucle. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_printerAttributes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">ipp_t</span></span> *collection = ippGetCollection(attrptr, i); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = <span class="hljs-number"><span class="hljs-number">0</span></span>, attrptr = ippFirstAttribute(collection); (j &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) &amp;&amp; (attrptr != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); attrptr = ippNextAttribute(collection)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(<span class="hljs-string"><span class="hljs-string">"...."</span></span>, ippGetName(attrptr)) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ....TopMargin = ippGetInteger(attrptr, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(<span class="hljs-string"><span class="hljs-string">"...."</span></span>, ippGetName(attrptr)) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ....BottomMargin = ippGetInteger(attrptr, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(<span class="hljs-string"><span class="hljs-string">"...."</span></span>, ippGetName(attrptr)) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ....LeftMargin = ippGetInteger(attrptr, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(<span class="hljs-string"><span class="hljs-string">"...."</span></span>, ippGetName(attrptr)) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ....RightMargin = ippGetInteger(attrptr, <span class="hljs-number"><span class="hljs-number">0</span></span>); } } .... }</code> </pre> <br>  Advertencia de PVS-Studio: V560 CWE-571 Una parte de la expresi√≥n condicional siempre es verdadera: (j &lt;4).  ipphelper.c 926 <br><br>  Tenga en cuenta que el valor de la variable <i>j</i> no se incrementa en ninguna parte.  Esto significa que la subexpresi√≥n <i>(j &lt;4)</i> siempre <i>es</i> verdadera. <br><br>  El mayor n√∫mero de operaciones √∫tiles del analizador PVS-Studio, en relaci√≥n con las condiciones siempre verdaderas / falsas, se refiere al c√≥digo donde se verifica el resultado de crear objetos utilizando el <i>nuevo</i> operador.  En otras palabras, el analizador detecta el siguiente patr√≥n de c√≥digo: <br><br><pre> <code class="cpp hljs">T *p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR;</code> </pre> <br>  Tales controles no tienen sentido.  Si no fue posible asignar memoria para el objeto, se <i>genera</i> una excepci√≥n del tipo <i>std :: bad_alloc,</i> y simplemente no llegar√° a la comprobaci√≥n del valor del puntero. <br><br>  Nota  El <i>nuevo</i> operador puede devolver <i>nullptr</i> escribiendo <i>new (std :: nothrow) T.</i>  Sin embargo, esto no se aplica a los errores discutidos.  El analizador PVS-Studio tiene en cuenta <i>(std :: nothrow)</i> y no da una advertencia si el objeto se crea de esta manera. <br><br>  Puede parecer que tales errores son inofensivos.  Bueno, pi√©nselo, un cheque extra que nunca funciona.  De todos modos, se lanzar√° una excepci√≥n que se procesar√° en alguna parte.  Desafortunadamente, algunos desarrolladores colocan en la declaraci√≥n verdadera de las acciones de <i>declaraci√≥n if</i> que liberan recursos, etc.  Como este c√≥digo no se est√° ejecutando, puede provocar p√©rdidas de memoria y otros errores. <br><br>  Considere uno de estos casos que not√© en el c√≥digo de Android. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_apk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *target_package_name)</span></span></span><span class="hljs-function"> </span></span>{ .... FileMap *dataMap = zip-&gt;createEntryFileMap(entry); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dataMap == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { ALOGW(<span class="hljs-string"><span class="hljs-string">"%s: failed to create FileMap\n"</span></span>, __FUNCTION__); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[uncompLen]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">NULL</span></span> == buf) { ALOGW(<span class="hljs-string"><span class="hljs-string">"%s: failed to allocate %"</span></span> PRIu32 <span class="hljs-string"><span class="hljs-string">" byte\n"</span></span>, __FUNCTION__, uncompLen); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> dataMap; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } .... }</code> </pre> <br>  Advertencia de PVS-Studio: V668 CWE-570 No tiene sentido probar el puntero 'buf' contra nulo, ya que la memoria se asign√≥ utilizando el operador 'nuevo'.  La excepci√≥n se generar√° en caso de error de asignaci√≥n de memoria.  scan.cpp 213 <br><br>  Tenga en cuenta que si no es posible asignar un segundo bloque de memoria, el programador intenta liberar el primer bloque: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> dataMap;</code> </pre> <br>  Este c√≥digo nunca tendr√° control.  Este es un c√≥digo muerto.  Si se produce una excepci√≥n, se producir√° una p√©rdida de memoria. <br><br>  Escribir ese c√≥digo es fundamentalmente incorrecto.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Se</a> inventaron <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">punteros inteligentes</a> para tales casos. <br><br>  En total, el analizador PVS-Studio detect√≥ <b>176</b> lugares en el c√≥digo de Android donde se verifica el puntero despu√©s de crear objetos usando <i>nuevos</i> .  No entend√≠ lo peligroso que es cada uno de estos lugares y, por supuesto, no saturar√© el art√≠culo con todas estas advertencias.  Los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">interesados</a> pueden ver otras advertencias en el archivo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Android_V668.txt</a> . <br><br><h2>  Desreferenciar un puntero nulo </h2><br>  Anular la referencia a un puntero nulo conduce a un comportamiento indefinido del programa, por lo que es √∫til encontrar y corregir dichos lugares.  Dependiendo de la situaci√≥n, el analizador PVS-Studio puede clasificar estos errores de acuerdo con la Enumeraci√≥n de Debilidad Com√∫n de la siguiente manera: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CWE-119</a> : Restricci√≥n incorrecta de operaciones dentro de los l√≠mites de un b√∫fer de memoria </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CWE-476</a> : Desreferencia de puntero nulo </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CWE-628</a> : Llamada de funci√≥n con argumentos incorrectamente especificados </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CWE-690</a> : Valor de retorno sin marcar a la referencia de puntero NULL </li></ul><br>  A menudo encuentro tales errores en el c√≥digo responsable de manejar situaciones no est√°ndar o incorrectas.  Nadie prueba dicho c√≥digo, y el error puede vivir en √©l durante mucho tiempo.  Tal caso ser√° considerado ahora. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseEffect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xmlProxyLib == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { ALOGE(<span class="hljs-string"><span class="hljs-string">"effectProxy must contain a &lt;%s&gt;: %s"</span></span>, tag, dump(*xmlProxyLib)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } .... }</code> </pre> <br>  Advertencia de PVS-Studio: V522 CWE-476 Puede tener lugar la desreferenciaci√≥n del puntero nulo 'xmlProxyLib'.  EffectsConfig.cpp 205 <br><br>  Si el puntero <i>xmlProxyLib</i> es <i>nullptr</i> , entonces el programador muestra un mensaje de depuraci√≥n, para lo cual es necesario desreferenciar este puntero.  Ups ... <br><br>  Ahora considere una versi√≥n m√°s interesante del error. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">soinfo_unload_impl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(soinfo* root)</span></span></span><span class="hljs-function"> </span></span>{ .... soinfo* needed = find_library(si-&gt;get_primary_namespace(), library_name, RTLD_NOLOAD, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (needed != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= PRINT("warning: couldn't find %s needed by %s on unload.", library_name, si-&gt;get_realpath()); return; } else if (local_unload_list.contains(needed)) { return; } else if (needed-&gt;is_linked() &amp;&amp; // &lt;= needed-&gt;get_local_group_root() != root) { external_unload_list.push_back(needed); } else { unload_list.push_front(needed); } .... }</span></span></code> </pre> <br>  Advertencia de PVS-Studio: V522 CWE-476 Puede producirse una desreferenciaci√≥n del puntero nulo 'necesario'.  linker.cpp 1847 <br><br>  Si se <i>necesita</i> el puntero <i>! = Nullptr</i> , se emite una advertencia, que es un comportamiento muy sospechoso del programa.  Finalmente queda claro que el c√≥digo contiene un error si mira a continuaci√≥n y ve que cuando <i>sea ‚Äã‚Äãnecesario == nullptr</i> , el puntero nulo se desreferenciar√° en la expresi√≥n necesaria- <i>&gt; is_linked ()</i> . <br><br>  Lo m√°s probable es que los operadores! = Y == simplemente est√©n confundidos aqu√≠.  Si lo reemplaza, el c√≥digo de funci√≥n tiene sentido y el error desaparece. <br><br>  La mayor parte de las advertencias sobre la posible desreferenciaci√≥n de un puntero nulo se refiere a una situaci√≥n de la forma: <br><br><pre> <code class="cpp hljs">T *p = (T *) <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span> (N); *p = x;</code> </pre> <br>  Funciones como <i>malloc</i> , <i>strdup,</i> etc. pueden devolver <i>NULL</i> si no se puede asignar memoria.  Por lo tanto, no puede desreferenciar los punteros que devuelven estas funciones sin verificar primero el puntero. <br><br>  Hay muchos errores similares, por lo que solo dar√© dos fragmentos de c√≥digo simples: el primero con <br>  <i>Malloc</i> y el segundo con <i>strdup</i> . <br><br><pre> <code class="cpp hljs">DownmixerBufferProvider::DownmixerBufferProvider(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">effect_param_t</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> param = (<span class="hljs-keyword"><span class="hljs-keyword">effect_param_t</span></span> *) <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(downmixParamSize); param-&gt;psize = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">downmix_params_t</span></span>); .... }</code> </pre> <br>  Advertencia de PVS-Studio: V522 CWE-690 Puede haber una desreferenciaci√≥n de un puntero nulo potencial 'param'.  L√≠neas de verificaci√≥n: 245, 244. BufferProviders.cpp 245 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">descriptorClassToDot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* str)</span></span></span><span class="hljs-function"> </span></span>{ .... newStr = strdup(lastSlash); newStr[<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(lastSlash)<span class="hljs-number"><span class="hljs-number">-1</span></span>] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; .... }</code> </pre> <br>  Advertencia de PVS-Studio: V522 CWE-690 Puede haber una desreferenciaci√≥n de un puntero nulo potencial 'newStr'.  L√≠neas de verificaci√≥n: 203, 202. DexDump.cpp 203 <br><br>  Alguien puede decir que estos son errores menores.  Si no hay suficiente memoria, entonces el programa simplemente se bloquear√° al desreferenciar el puntero nulo, y esto es normal.  Como no hay memoria, no hay nada que intente de alguna manera manejar esta situaci√≥n. <br><br>  Tal persona est√° equivocada.  Los punteros deben ser revisados!  Examin√© este tema en detalle en el art√≠culo " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬øPor qu√© es importante verificar qu√© devolvi√≥ la funci√≥n malloc?</a> ".  Le recomiendo que lo lea a todos los que no lo hayan le√≠do. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/923/793/0c5/9237930c52039f4f7e0542bee775ce72.png" alt="malloc"></div><br><br>  En resumen, el peligro es que escribir en la memoria no necesariamente se produce cerca de la direcci√≥n cero.  Es posible escribir datos en alg√∫n lugar muy alejado de una p√°gina de memoria que no est√© protegida contra escritura y, por lo tanto, causar un error dif√≠cil de alcanzar, o en general este error puede usarse como una vulnerabilidad.  Veamos a qu√© me refiero con el ejemplo de la funci√≥n <i>check_size</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check_size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">radio_metadata_buffer_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **metadata_ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size_int)</span></span></span><span class="hljs-function"> </span></span>{ .... metadata = <span class="hljs-built_in"><span class="hljs-built_in">realloc</span></span>(metadata, new_size_int * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)); memmove( (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *)metadata + new_size_int - (metadata-&gt;count + <span class="hljs-number"><span class="hljs-number">1</span></span>), (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *)metadata + metadata-&gt;size_int - (metadata-&gt;count + <span class="hljs-number"><span class="hljs-number">1</span></span>), (metadata-&gt;count + <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)); .... }</code> </pre> <br>  Advertencia de PVS-Studio: V769 CWE-119 El puntero '(uint32_t *) metadata' en la expresi√≥n '(uint32_t *) metadata + new_size_int' podr√≠a ser nullptr.  En tal caso, el valor resultante no tendr√° sentido y no debe usarse.  Verifique las l√≠neas: 91, 89. radio_metadata.c 91 <br><br>  No entend√≠ la l√≥gica de la funci√≥n, pero esto no es necesario.  Lo principal es que se crea un nuevo b√∫fer y los datos se copian all√≠.  Si la funci√≥n <i>realloc</i> devuelve <i>NULL</i> , los datos se copiar√°n a la direcci√≥n ((uint32_t *) NULL + metadata-&gt; size_int - (metadata-&gt; count + 1)). <br><br>  Si el <i>valor de metadata-&gt; size_int es</i> grande, entonces las consecuencias ser√°n lamentables.  Resulta que los datos se escriben en una memoria aleatoria. <br><br>  Por cierto, hay otro tipo de anulaci√≥n de referencia de puntero nulo, que el analizador PVS-Studio clasifica no como CWE-690, sino como CWE-628 (argumento no v√°lido). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_tcp_ports</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *portstring, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *ports)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buffer; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *cp; buffer = strdup(portstring); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((cp = <span class="hljs-built_in"><span class="hljs-built_in">strchr</span></span>(buffer, <span class="hljs-string"><span class="hljs-string">':'</span></span>)) == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) .... }</code> </pre> <br>  Advertencia de PVS-Studio: V575 CWE-628 El puntero nulo potencial se pasa a la funci√≥n 'strchr'.  Inspecciona el primer argumento.  L√≠neas de verificaci√≥n: 47, 46. libxt_tcp.c 47 <br><br>  El hecho es que la desreferenciaci√≥n del puntero ocurrir√° cuando se <i>llame a la</i> funci√≥n <i>strchr</i> .  Por lo tanto, el analizador interpreta esta situaci√≥n como pasar un valor incorrecto a la funci√≥n. <br><br>  Las <b>194</b> advertencias restantes de este tipo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">figuran</a> en el archivo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Android_V522_V575.txt</a> . <br><br>  Por cierto, las advertencias discutidas anteriormente sobre la comprobaci√≥n del puntero despu√©s de llamar al <i>nuevo</i> operador dan un picante especial a todos estos errores.  Resulta que hay 195 llamadas a las <i>funciones</i> <i>malloc</i> / <i>realloc</i> / <i>strdup,</i> y as√≠ sucesivamente, cuando el puntero no est√° marcado.  Pero hay 176 lugares donde se marca el puntero despu√©s de llamar a <i>new</i> .  De acuerdo, un enfoque extra√±o! <br><br>  Al final, nos queda considerar las advertencias V595 y V1004, que tambi√©n est√°n asociadas con el uso de punteros nulos. <br><br>  V595 detecta situaciones en las que el puntero se desreferencia y luego se verifica.  Ejemplo sint√©tico: <br><br><pre> <code class="cpp hljs">p-&gt;foo(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!p) Error();</code> </pre> <br>  V1004 revela la situaci√≥n inversa cuando el puntero se verific√≥ primero y luego se olvid√≥ de hacerlo.  Ejemplo sint√©tico: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p) p-&gt;foo(); p-&gt;doo();</code> </pre> <br>  Veamos algunos fragmentos de c√≥digo de Android, donde hubo errores de este tipo.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Explicar especialmente sus caracter√≠sticas no son necesarias. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">PV_STATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RC_UpdateBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VideoEncData *video, Int currLayer, Int num_skip)</span></span></span><span class="hljs-function"> </span></span>{ rateControl *rc = video-&gt;rc[currLayer]; MultiPass *pMP = video-&gt;pMP[currLayer]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (video == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || rc == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || pMP == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PV_FAIL; .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia de PVS-Studio: V595 CWE-476 El puntero 'video' se utiliz√≥ antes de que se verificara contra nullptr. </font><font style="vertical-align: inherit;">Verifique las l√≠neas: 385, 388. rate_control.cpp 385</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resampler_reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct resampler_itfe *resampler)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resampler</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rsmp</span></span></span><span class="hljs-class"> = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resampler</span></span></span><span class="hljs-class"> *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resampler</span></span></span><span class="hljs-class">;</span></span> rsmp-&gt;frames_in = <span class="hljs-number"><span class="hljs-number">0</span></span>; rsmp-&gt;frames_rq = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rsmp != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> &amp;&amp; rsmp-&gt;speex_resampler != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { speex_resampler_reset_mem(rsmp-&gt;speex_resampler); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia de PVS-Studio: V595 CWE-476 El puntero 'rsmp' se utiliz√≥ antes de que se verificara contra nullptr. </font><font style="vertical-align: inherit;">Verifique las l√≠neas: 54, 57. resampler.c 54</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bta_gattc_disc_cmpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tBTA_GATTC_CLCB* p_clcb, UNUSED_ATTR tBTA_GATTC_DATA* p_data)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p_clcb-&gt;status != GATT_SUCCESS) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p_clcb-&gt;p_srcb) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;tBTA_GATTC_SERVICE&gt;().swap( p_clcb-&gt;p_srcb-&gt;srvc_cache); } bta_gattc_cache_reset(p_clcb-&gt;p_srcb-&gt;server_bda); } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia de PVS-Studio: V1004 CWE-476 El puntero 'p_clcb-&gt; p_srcb' se us√≥ de manera insegura despu√©s de que se verific√≥ contra nullptr. </font><font style="vertical-align: inherit;">Verifique las l√≠neas: 695, 701. bta_gattc_act.cc 701 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No es interesante considerar otras advertencias de este tipo. </font><font style="vertical-align: inherit;">Entre ellos hay errores y advertencias falsas que surgen debido a un c√≥digo mal o dif√≠cilmente escrito. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Escrib√≠ una docena de advertencias √∫tiles:</font></font><br><br><ul><li> V1004 CWE-476 The 'ain' pointer was used unsafely after it was verified against nullptr. Check lines: 101, 105. rsCpuIntrinsicBLAS.cpp 105 </li><li> V595 CWE-476 The 'outError' pointer was utilized before it was verified against nullptr. Check lines: 437, 450. Command.cpp 437 </li><li> V595 CWE-476 The 'out_last_reference' pointer was utilized before it was verified against nullptr. Check lines: 432, 436. AssetManager2.cpp 432 </li><li> V595 CWE-476 The 'set' pointer was utilized before it was verified against nullptr. Check lines: 4524, 4529. ResourceTypes.cpp 4524 </li><li> V595 CWE-476 The 'reply' pointer was utilized before it was verified against nullptr. Check lines: 126, 133. Binder.cpp 126 </li><li> V595 CWE-476 The 'video' pointer was utilized before it was verified against nullptr. Check lines: 532, 540. rate_control.cpp 532 </li><li> V595 CWE-476 The 'video' pointer was utilized before it was verified against nullptr. Check lines: 702, 711. rate_control.cpp 702 </li><li> V595 CWE-476 The 'pInfo' pointer was utilized before it was verified against nullptr. Check lines: 251, 254. ResolveInfo.cpp 251 </li><li> V595 CWE-476 The 'address' pointer was utilized before it was verified against nullptr. Check lines: 53, 55. DeviceHalHidl.cpp 53 </li><li> V595 CWE-476 The 'halAddress' pointer was utilized before it was verified against nullptr. Check lines: 55, 82. DeviceHalHidl.cpp 55 </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y luego me aburr√≠ y filtr√© advertencias de este tipo. Por lo tanto, ni siquiera s√© cu√°ntos errores reales ha detectado el analizador. Estas advertencias est√°n esperando a su h√©roe, que las estudiar√° cuidadosamente y har√° cambios en el c√≥digo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solo quiero llamar la atenci√≥n de mis nuevos lectores sobre errores de este tipo:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NJ_EXTERN NJ_INT16 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">njx_search_word</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(NJ_CLASS *iwnn, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... NJ_PREVIOUS_SELECTION_INFO *prev_info = &amp;(iwnn-&gt;previous_selection); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iwnn == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NJ_SET_ERR_VAL(NJ_FUNC_NJ_SEARCH_WORD, NJ_ERR_PARAM_ENV_NULL); } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia de PVS-Studio: V595 CWE-476 El puntero 'iwnn' se utiliz√≥ antes de que se verificara contra nullptr. </font><font style="vertical-align: inherit;">Verifique las l√≠neas: 686, 689. ndapi.c 686 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algunas personas piensan que no hay ning√∫n error aqu√≠, porque "no hay una desreferencia real del puntero". </font><font style="vertical-align: inherit;">La direcci√≥n de una variable inexistente simplemente se calcula. </font><font style="vertical-align: inherit;">Adem√°s, si el puntero </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iwnn es</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cero, la funci√≥n se cerrar√°. </font><font style="vertical-align: inherit;">Por lo tanto, no sucedi√≥ nada malo que previamente calcul√°ramos incorrectamente la direcci√≥n de un miembro de la clase. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No, no puedes hablar as√≠. </font><font style="vertical-align: inherit;">Este c√≥digo conduce a un comportamiento indefinido y, por lo tanto, no se puede escribir as√≠. </font><font style="vertical-align: inherit;">El comportamiento indefinido puede manifestarse, por ejemplo, de la siguiente manera:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El compilador ve el puntero desreferenciado: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iwnn-&gt; previous_selection</font></font></i> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No puede desreferenciar un puntero nulo, porque este es un comportamiento indefinido </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El compilador concluye que el puntero </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iwnn</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> siempre </font><i><font style="vertical-align: inherit;">es</font></i><font style="vertical-align: inherit;"> distinto de cero</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El compilador elimina la comprobaci√≥n adicional: if (iwnn == NULL) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eso es todo, ahora cuando se ejecuta el programa, la comprobaci√≥n del puntero nulo no se realiza y el trabajo comienza con el puntero incorrecto para el miembro de la clase </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este tema se describe con m√°s detalle en mi art√≠culo " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desreferenciar un puntero nulo conduce a un comportamiento indefinido</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ".</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Los datos privados no se borran en la memoria </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Considere un tipo grave de vulnerabilidad potencial que se clasifica seg√∫n la Enumeraci√≥n de debilidad com√∫n como </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-14</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Eliminaci√≥n del c√≥digo del compilador para borrar los buffers. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En resumen, la conclusi√≥n es esta: el compilador tiene el derecho de eliminar la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">llamada a la</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> funci√≥n </font><i><font style="vertical-align: inherit;">memset</font></i><font style="vertical-align: inherit;"> si despu√©s de eso el b√∫fer ya no se usa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando escribo sobre este tipo de vulnerabilidad, los comentarios necesariamente aparecen que esto es solo una falla en el compilador que debe corregirse. </font><font style="vertical-align: inherit;">No, esto no es un problema t√©cnico. </font><font style="vertical-align: inherit;">Y antes de objetar, lea los siguientes materiales:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roman Fomichev. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Limpie de forma segura los datos privados</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enumeraci√≥n de debilidad com√∫n. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-14</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Descripci√≥n del diagn√≥stico </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V597</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En general, todo es serio. </font><font style="vertical-align: inherit;">¬øHay alg√∫n error de este tipo en Android?</font></font> Por supuesto que lo hay.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generalmente son muchos donde hay: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prueba</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Volvamos al c√≥digo de Android y veamos el principio y el final de la funci√≥n </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FwdLockGlue_InitializeRoundKeys</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ya que el medio no es interesante para nosotros.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FwdLockGlue_InitializeRoundKeys</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> keyEncryptionKey[KEY_SIZE]; .... <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(keyEncryptionKey, <span class="hljs-number"><span class="hljs-number">0</span></span>, KEY_SIZE); <span class="hljs-comment"><span class="hljs-comment">// Zero out key data. }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia de PVS-Studio: V597 CWE-14 El compilador podr√≠a eliminar la llamada a la funci√≥n 'memset', que se utiliza para vaciar el b√∫fer 'keyEncryptionKey'. La funci√≥n memset_s () debe usarse para borrar los datos privados. FwdLockGlue.c 102 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matriz </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">keyEncryptionKey</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se crea en la pila y almacena informaci√≥n privada. Al final de la funci√≥n, quieren llenar esta matriz con ceros para que no llegue accidentalmente a donde no deber√≠a. C√≥mo la informaci√≥n puede llegar a donde no deber√≠a, el art√≠culo " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sobrescribir memoria, ¬øpor qu√©?</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " Lo </font><font style="vertical-align: inherit;">dir√° </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para llenar una matriz con informaci√≥n privada con ceros, se </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utiliza la</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> funci√≥n </font><i><font style="vertical-align: inherit;">memset</font></i><font style="vertical-align: inherit;"> . El comentario "Cero datos clave" confirma que entendemos todo correctamente.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El problema es que con una probabilidad muy alta, el compilador eliminar√° la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">llamada a la</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> funci√≥n </font><i><font style="vertical-align: inherit;">memset</font></i><font style="vertical-align: inherit;"> al crear la versi√≥n de lanzamiento </font><font style="vertical-align: inherit;">. Dado que el b√∫fer despu√©s de la llamada </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no se usa, la llamada de la funci√≥n </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset en</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s√≠ </font><font style="vertical-align: inherit;">es superflua desde el punto de vista del compilador. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√°s </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de 10</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> advertencias yo escribimos un archivo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android_V597.txt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hubo otro error en el que la memoria no se sobrescribe, aunque en este caso la funci√≥n </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no </font><font style="vertical-align: inherit;">tiene </font><font style="vertical-align: inherit;">nada que ver con eso.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SHA1Transform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> state[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span><span class="hljs-function"><span class="hljs-params">], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> buffer[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">64</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> a, b, c, d, e; .... <span class="hljs-comment"><span class="hljs-comment">/* Wipe variables */</span></span> a = b = c = d = e = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia de PVS-Studio: V1001 CWE-563 La variable 'a' se asigna pero no se usa hasta el final de la funci√≥n. </font><font style="vertical-align: inherit;">sha1.c 213 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio detect√≥ una anomal√≠a relacionada con el hecho de que despu√©s de asignar valores a las variables, ya no se usan. </font><font style="vertical-align: inherit;">El analizador clasific√≥ este defecto como </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-563</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Asignaci√≥n a variable sin uso. </font><font style="vertical-align: inherit;">Y, formalmente, tiene raz√≥n, aunque, de hecho, aqu√≠ estamos nuevamente tratando con CWE-14. </font><font style="vertical-align: inherit;">El compilador desechar√° estas tareas, ya que desde el punto de vista de C y C ++ son superfluas. </font><font style="vertical-align: inherit;">Como resultado, la pila retendr√° los valores antiguos de las variables </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que almacenan datos privados.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comportamiento no especificado / definido por la implementaci√≥n </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si bien no est√°s cansado, veamos un caso complejo que requerir√° una descripci√≥n completa de mi parte. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> GGLfixed; <span class="hljs-function"><span class="hljs-function">GGLfixed </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gglFastDivx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GGLfixed n, GGLfixed d)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((d&gt;&gt;<span class="hljs-number"><span class="hljs-number">24</span></span>) &amp;&amp; ((d&gt;&gt;<span class="hljs-number"><span class="hljs-number">24</span></span>)+<span class="hljs-number"><span class="hljs-number">1</span></span>)) { n &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; d &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gglMulx(n, gglRecip(d)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia de PVS-Studio: V793 Es extra√±o que el resultado de la declaraci√≥n '(d &gt;&gt; 24) + 1' sea parte de la condici√≥n. </font><font style="vertical-align: inherit;">Quiz√°s, esta declaraci√≥n deber√≠a haber sido comparada con otra cosa. </font><font style="vertical-align: inherit;">fixed.cpp 75 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El programador quer√≠a comprobar que los 8 bits de orden superior de la variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contienen unidades, pero no todos los bits a la vez. </font><font style="vertical-align: inherit;">En otras palabras, el programador quer√≠a verificar que cualquier valor que no sea 0x00 y 0xFF est√© en el byte alto.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se acerc√≥ a la soluci√≥n de este problema innecesariamente creativamente. Para empezar, verific√≥ que los bits m√°s significativos son distintos de cero escribiendo una expresi√≥n (d &gt;&gt; 24). Hay afirmaciones sobre esta expresi√≥n, pero es m√°s interesante analizar el lado derecho de la expresi√≥n: ((d &gt;&gt; 24) +1). El programador desplaza los ocho bits altos al byte bajo. Al mismo tiempo, calcula que el bit de signo m√°s significativo est√° duplicado en todos los dem√°s bits.</font></font> Es decir<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si la variable d es 0b11111111'00000000'00000000'00000000, entonces despu√©s del cambio obtenemos el valor 0b11111111'11111111'11111111'11111111. Agregando 1 al valor 0xFFFFFFFF de tipo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , el programador planea obtener 0. Es decir: -1 + 1 = 0. Por lo tanto, con la expresi√≥n ((d &gt;&gt; 24) +1), comprueba que no todos los ocho bits altos son iguales a 1. Entiendo que esto es bastante dif√≠cil, as√≠ que t√≥mate tu tiempo e intenta averiguar c√≥mo y qu√© funciona :). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora veamos qu√© est√° mal con este c√≥digo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al cambiar, el bit de signo m√°s significativo no necesariamente est√° "manchado". Esto es lo que dice el est√°ndar al respecto: ‚ÄúEl valor de E1 &gt;&gt; E2 es E1 posiciones de bit E2 desplazadas a la derecha. Si E1 tiene un tipo sin signo o si E1 tiene un tipo con signo y un valor no negativo, el valor del resultado es la parte integral del cociente de E1 / 2 ^ E2. Si E1 tiene un tipo con signo y un valor negativo, el valor resultante est√° definido por la implementaci√≥n ". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La √∫ltima oferta es importante para nosotros. Entonces, conocimos el comportamiento definido por la implementaci√≥n. El funcionamiento de este c√≥digo depende de la arquitectura del microprocesador y la implementaci√≥n del compilador. Despu√©s del cambio, los ceros pueden aparecer en los bits m√°s significativos, y luego la expresi√≥n ((d &gt;&gt; 24) +1) siempre ser√° diferente de 0, es decir. Siempre ser√° un verdadero valor.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De ah√≠ la conclusi√≥n: no es necesario ser sabio. </font><font style="vertical-align: inherit;">El c√≥digo ser√° m√°s confiable y comprensible si escribe, por ejemplo, as√≠:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">GGLfixed </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gglFastDivx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GGLfixed n, GGLfixed d)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> hibits = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>&gt;(d) &gt;&gt; <span class="hljs-number"><span class="hljs-number">24</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hibits != <span class="hljs-number"><span class="hljs-number">0x00</span></span> &amp;&amp; hibits != <span class="hljs-number"><span class="hljs-number">0xFF</span></span>) { n &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; d &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gglMulx(n, gglRecip(d)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Probablemente, suger√≠ que no es la opci√≥n ideal, pero en este c√≥digo no hay un comportamiento definido por la implementaci√≥n, y ser√° m√°s f√°cil para el lector comprender lo que se est√° comprobando. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Te mereces una taza de caf√© o t√©. </font><font style="vertical-align: inherit;">Distraer y continuar: estamos esperando un caso interesante de comportamiento no especificado.</font></font><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f53/1a9/86b/f531a986b1bca57105eddf63d12bd50b.png" alt="atencion"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la entrevista, como una de las primeras preguntas al solicitante, le pregunto lo siguiente: "¬øQu√© imprimir√° la funci√≥n </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printf</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y por qu√©?"</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d,%d"</span></span>, i++, i++)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La respuesta correcta: este es un comportamiento no especificado. </font><font style="vertical-align: inherit;">El procedimiento para calcular los argumentos reales cuando se llama a la funci√≥n no est√° definido. </font><font style="vertical-align: inherit;">Ocasionalmente, incluso demuestro que este c√≥digo, compilado con la ayuda de Visual C ++, muestra "6.5" en la pantalla, lo que confunde a los reci√©n llegados que son d√©biles en conocimiento y esp√≠ritu a un punto muerto :). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto puede parecer un problema descabellado. </font><font style="vertical-align: inherit;">Pero no, este c√≥digo se puede encontrar en aplicaciones serias, por ejemplo, en el c√≥digo de Android.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ComposerClient::CommandReader::parseSetLayerCursorPosition( <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> length) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (length != CommandWriterBase::kSetLayerCursorPositionLength) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> err = mHal.setLayerCursorPosition(mDisplay, mLayer, readSigned(), readSigned()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err != Error::NONE) { mWriter.setError(getCommandLoc(), err); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia de PVS-Studio: V681 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-758</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El est√°ndar de lenguaje no define un orden en el que se invocar√°n las funciones 'readSigned' durante la evaluaci√≥n de los argumentos. </font><font style="vertical-align: inherit;">ComposerClient.cpp 836 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estamos interesados ‚Äã‚Äãen esta l√≠nea de c√≥digo:</font></font><br><br><pre> <code class="cpp hljs">mHal.setLayerCursorPosition(...., readSigned(), readSigned());</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al llamar a la funci√≥n </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">readSigned</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">se leen dos valores. </font><font style="vertical-align: inherit;">Pero es imposible predecir en qu√© orden se leer√°n los valores. </font><font style="vertical-align: inherit;">Este es un caso cl√°sico de comportamiento no especificado.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beneficios de usar un analizador de c√≥digo est√°tico </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este art√≠culo completo populariza el an√°lisis de c√≥digo est√°tico en general y nuestra herramienta PVS-Studio en particular. </font><font style="vertical-align: inherit;">Sin embargo, algunos errores son perfectos para demostrar las posibilidades del an√°lisis est√°tico. </font><font style="vertical-align: inherit;">Son dif√≠ciles de identificar mediante revisiones de c√≥digo, y solo un programa no cansado los nota f√°cilmente. </font><font style="vertical-align: inherit;">Considere un par de tales casos.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span>&gt; kBootReasonMap = { .... {<span class="hljs-string"><span class="hljs-string">"watchdog_sdi_apps_reset"</span></span>, <span class="hljs-number"><span class="hljs-number">106</span></span>}, {<span class="hljs-string"><span class="hljs-string">"smpl"</span></span>, <span class="hljs-number"><span class="hljs-number">107</span></span>}, {<span class="hljs-string"><span class="hljs-string">"oem_modem_failed_to_powerup"</span></span>, <span class="hljs-number"><span class="hljs-number">108</span></span>}, {<span class="hljs-string"><span class="hljs-string">"reboot_normal"</span></span>, <span class="hljs-number"><span class="hljs-number">109</span></span>}, {<span class="hljs-string"><span class="hljs-string">"oem_lpass_cfg"</span></span>, <span class="hljs-number"><span class="hljs-number">110</span></span>}, <span class="hljs-comment"><span class="hljs-comment">// &lt;= {"oem_xpu_ns_error", 111}, // &lt;= {"power_key_press", 112}, {"hardware_reset", 113}, {"reboot_by_powerkey", 114}, {"reboot_verity", 115}, {"oem_rpm_undef_error", 116}, {"oem_crash_on_the_lk", 117}, {"oem_rpm_reset", 118}, {"oem_lpass_cfg", 119}, // &lt;= {"oem_xpu_ns_error", 120}, // &lt;= {"factory_cable", 121}, {"oem_ar6320_failed_to_powerup", 122}, {"watchdog_rpm_bite", 123}, {"power_on_cable", 124}, {"reboot_unknown", 125}, .... };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Advertencias de PVS-Studio: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V766 CWE-462 Ya se ha agregado un elemento con la misma clave '"oem_lpass_cfg"'. </font><font style="vertical-align: inherit;">bootstat.cpp 264</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V766 CWE-462 Ya se ha agregado un elemento con la misma clave '"oem_xpu_ns_error"'. </font><font style="vertical-align: inherit;">bootstat.cpp 265</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se insertan diferentes valores con las mismas claves en el </font><font style="vertical-align: inherit;">contenedor asociativo ordenado ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: map</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). En t√©rminos de enumeraci√≥n de debilidad com√∫n, este es el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-462</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : clave duplicada en la lista asociativa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El texto del programa se acorta y los errores est√°n marcados con comentarios, por lo que el error parece obvio, pero cuando solo lee este c√≥digo con los ojos, es muy dif√≠cil encontrar tales errores. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Considere otra pieza de c√≥digo que es muy dif√≠cil de leer, ya que es del mismo tipo y poco interesante.</font></font><br><br><pre> <code class="cpp hljs">MtpResponseCode MyMtpDatabase::getDevicePropertyValue(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MTP_TYPE_INT8: packet.putInt8(longValue); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MTP_TYPE_UINT8: packet.putUInt8(longValue); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MTP_TYPE_INT16: packet.putInt16(longValue); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MTP_TYPE_UINT16: packet.putUInt16(longValue); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MTP_TYPE_INT32: packet.putInt32(longValue); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MTP_TYPE_UINT32: packet.putUInt32(longValue); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MTP_TYPE_INT64: packet.putInt64(longValue); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MTP_TYPE_UINT64: packet.putUInt64(longValue); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MTP_TYPE_INT128: packet.putInt128(longValue); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MTP_TYPE_UINT128: packet.putInt128(longValue); <span class="hljs-comment"><span class="hljs-comment">// &lt;= break; .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia de PVS-Studio: V525 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-682</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El c√≥digo contiene la colecci√≥n de bloques similares. </font><font style="vertical-align: inherit;">Verifique los elementos 'putInt8', 'putUInt8', 'putInt16', 'putUInt16', 'putInt32', 'putUInt32', 'putInt64', 'putUInt64', 'putInt128', 'putInt128' en las l√≠neas 620, 623, 626, 629 , 632, 635, 638, 641, 644, 647. 620 android_mtp_MtpDatabase.cpp </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MTP_TYPE_UINT128</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tuvo que ser causada por una funci√≥n </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">putUInt128</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , no </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">putInt128</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y el √∫ltimo en esta secci√≥n es un gran ejemplo de Copiar-Pegar sin √©xito.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">btif_rc_upstreams_evt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> AVRC_PDU_REQUEST_CONTINUATION_RSP: { BTIF_TRACE_EVENT( <span class="hljs-string"><span class="hljs-string">"%s() REQUEST CONTINUATION: target_pdu: 0x%02d"</span></span>, __func__, pavrc_cmd-&gt;continu.target_pdu); tAVRC_RESPONSE avrc_rsp; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p_dev-&gt;rc_connected == TRUE) { <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;(avrc_rsp.continu), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(tAVRC_NEXT_RSP)); avrc_rsp.continu.opcode = opcode_from_pdu(AVRC_PDU_REQUEST_CONTINUATION_RSP); avrc_rsp.continu.pdu = AVRC_PDU_REQUEST_CONTINUATION_RSP; avrc_rsp.continu.status = AVRC_STS_NO_ERROR; avrc_rsp.continu.target_pdu = pavrc_cmd-&gt;continu.target_pdu; send_metamsg_rsp(p_dev, <span class="hljs-number"><span class="hljs-number">-1</span></span>, label, ctype, &amp;avrc_rsp); } } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> AVRC_PDU_ABORT_CONTINUATION_RSP: { BTIF_TRACE_EVENT( <span class="hljs-string"><span class="hljs-string">"%s() ABORT CONTINUATION: target_pdu: 0x%02d"</span></span>, __func__, pavrc_cmd-&gt;<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>.target_pdu); tAVRC_RESPONSE avrc_rsp; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p_dev-&gt;rc_connected == TRUE) { <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;(avrc_rsp.<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(tAVRC_NEXT_RSP)); avrc_rsp.<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>.opcode = opcode_from_pdu(AVRC_PDU_ABORT_CONTINUATION_RSP); avrc_rsp.<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>.pdu = AVRC_PDU_ABORT_CONTINUATION_RSP; avrc_rsp.<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>.status = AVRC_STS_NO_ERROR; avrc_rsp.<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>.target_pdu = pavrc_cmd-&gt;continu.target_pdu; send_metamsg_rsp(p_dev, <span class="hljs-number"><span class="hljs-number">-1</span></span>, label, ctype, &amp;avrc_rsp); } } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Antes de leer la advertencia del analizador y el texto adicional, sugiero buscar el error usted mismo. </font></font><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/83b/679/4ad/83b6794adb823b1fa52e18c91eff1ed2.png" alt="Imagen distractora, Java"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para no leer accidentalmente la respuesta de inmediato, aqu√≠ hay una imagen para que desv√≠e la atenci√≥n. </font><font style="vertical-align: inherit;">Si est√° interesado en lo que significa un huevo con la inscripci√≥n Java, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqu√≠ est√°</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces, espero que hayan disfrutado la b√∫squeda de errores tipogr√°ficos. </font><font style="vertical-align: inherit;">Ahora es el momento de avisar al analizador: V778 CWE-682 Se encontraron dos fragmentos de c√≥digo similares. </font><font style="vertical-align: inherit;">Quiz√°s, este es un error tipogr√°fico y se debe usar la variable 'abortar' en lugar de 'continuar'. </font><font style="vertical-align: inherit;">btif_rc.cc 1554 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aparentemente, el c√≥digo fue escrito usando el m√©todo Copiar-Pegar, y una persona, como siempre, no pudo estar atenta en el proceso de edici√≥n del fragmento de c√≥digo copiado. </font><font style="vertical-align: inherit;">Como resultado, al final, no reemplaz√≥ " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">continu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " con " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">abortar</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ".</font></font><br><br>  Es decir<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en el segundo bloque debe escribirse: </font></font><br><br><pre> <code class="cpp hljs">avrc_rsp.<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>.target_pdu = pavrc_cmd-&gt;<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>.target_pdu;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta situaci√≥n cae completamente bajo la definici√≥n de " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">efecto de √∫ltima l√≠nea</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ", ya que al final se cometi√≥ un error al reemplazar los nombres.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Facepalm </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un error muy divertido est√° relacionado con la conversi√≥n entre formatos de datos little-endian y big-endian (ver </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">orden de bytes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bswap32</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (((pData &amp; <span class="hljs-number"><span class="hljs-number">0xFF000000</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">24</span></span>) | ((pData &amp; <span class="hljs-number"><span class="hljs-number">0x00FF0000</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | ((pData &amp; <span class="hljs-number"><span class="hljs-number">0x0000FF00</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | ((pData &amp; <span class="hljs-number"><span class="hljs-number">0x000000FF</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">24</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ELFAttribute::merge(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> subsection_length = *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>*&gt;(subsection_data); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (llvm::sys::IsLittleEndianHost != m_Config.targets().isLittleEndian()) bswap32(subsection_length); .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia de PVS-Studio: V530 CWE-252 Se requiere utilizar el valor de retorno de la funci√≥n 'bswap32'. </font><font style="vertical-align: inherit;">ELFAttribute.cpp 84 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hay</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> quejas </font><i><font style="vertical-align: inherit;">sobre la</font></i><font style="vertical-align: inherit;"> funci√≥n </font><i><font style="vertical-align: inherit;">bswap32</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Pero se usa incorrectamente:</font></font><br><br><pre> <code class="cpp hljs">bswap32(subsection_length);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El autor sugiri√≥ que la variable se pasa a la funci√≥n por referencia y se cambia all√≠. </font><font style="vertical-align: inherit;">Sin embargo, debe usar el valor devuelto por la funci√≥n. </font><font style="vertical-align: inherit;">Como resultado, no se produce conversi√≥n de datos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El analizador identific√≥ este error como </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-252</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Valor de retorno no verificado. </font><font style="vertical-align: inherit;">Pero, de hecho, es m√°s apropiado llamar a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-198</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Uso de orden de bytes incorrecto aqu√≠. </font><font style="vertical-align: inherit;">Desafortunadamente, el analizador no puede entender cu√°l es el error desde un punto de vista de alto nivel. </font><font style="vertical-align: inherit;">Sin embargo, esto no le impide identificar este defecto grave en el c√≥digo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El c√≥digo correcto es:</font></font><br><br><pre> <code class="cpp hljs">subsection_length = bswap32(subsection_length);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hay tres lugares m√°s en el c√≥digo de Android con el mismo error: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V530 CWE-252 Se requiere utilizar el valor de retorno de la funci√≥n 'bswap32'. </font><font style="vertical-align: inherit;">ELFAttribute.cpp 218</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V530 CWE-252 Se requiere utilizar el valor de retorno de la funci√≥n 'bswap32'. </font><font style="vertical-align: inherit;">ELFAttribute.cpp 346</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V530 CWE-252 Se requiere utilizar el valor de retorno de la funci√≥n 'bswap32'. </font><font style="vertical-align: inherit;">ELFAttribute.cpp 352</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para evitar tales errores, se recomienda usar el atributo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[[nodiscard]]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Este atributo se usa para indicar que el valor de retorno de una funci√≥n debe usarse cuando se invoca. </font><font style="vertical-align: inherit;">Por lo tanto, si escribes as√≠:</font></font><br><br><pre> <code class="cpp hljs">[[nodiscard]] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bswap32</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData)</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entonces el error se detectar√≠a incluso en la etapa de compilaci√≥n del archivo. </font><font style="vertical-align: inherit;">Puede obtener m√°s informaci√≥n sobre algunos nuevos atributos √∫tiles del art√≠culo de mi colega " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 17</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ".</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C√≥digo inalcanzable </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la programaci√≥n y la teor√≠a del compilador, el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c√≥digo inalcanzable</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es la parte del c√≥digo del programa que no puede ejecutarse bajo ninguna circunstancia, ya que no es accesible en el gr√°fico de flujo de control. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desde el punto de vista de la Enumeraci√≥n de Debilidad Com√∫n, es </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-561</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : C√≥digo Muerto.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> sp&lt;IEffect&gt; createEffect(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pDesc == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> effect; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { *status = BAD_VALUE; } } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia de PVS-Studio: V779 CWE-561 C√≥digo inalcanzable detectado. </font><font style="vertical-align: inherit;">Es posible que haya un error presente. </font><font style="vertical-align: inherit;">IAudioFlinger.cpp 733 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">declaraci√≥n de devoluci√≥n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> debe ubicarse expl√≠citamente a continuaci√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otros errores de este tipo:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V779 CWE-561 C√≥digo inalcanzable detectado. </font><font style="vertical-align: inherit;">Es posible que haya un error presente. </font><font style="vertical-align: inherit;">bta_hf_client_main.cc 612</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V779 CWE-561 C√≥digo inalcanzable detectado. </font><font style="vertical-align: inherit;">Es posible que haya un error presente. </font><font style="vertical-align: inherit;">android_media_ImageReader.cpp 468</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V779 CWE-561 C√≥digo inalcanzable detectado. </font><font style="vertical-align: inherit;">Es posible que haya un error presente. </font><font style="vertical-align: inherit;">AMPEG4AudioAssembler.cpp 187</font></font></li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> romper </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interrupci√≥n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> olvidada </font><font style="vertical-align: inherit;">dentro del </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interruptor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es un error cl√°sico de los programadores C y C ++. </font><font style="vertical-align: inherit;">Para combatirlo, una anotaci√≥n √∫til apareci√≥ en C ++ 17 como </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[[fallthrough]]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Puede leer </font><font style="vertical-align: inherit;">m√°s sobre este error y </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[[fallthrough]]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en mi art√≠culo " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">break and fallthrough</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero mientras el mundo est√° lleno de c√≥digo antiguo donde </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[[fallthrough]]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no se usa, PVS-Studio es √∫til para usted. </font><font style="vertical-align: inherit;">Considere algunos errores encontrados en Android. </font><font style="vertical-align: inherit;">De acuerdo con la enumeraci√≥n de debilidad com√∫n, estos errores se clasifican como </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-484</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Declaraci√≥n de interrupci√≥n omitida en el interruptor.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> A2dpCodecConfigLdac::setCodecConfig(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> BTAV_A2DP_CODEC_SAMPLE_RATE_192000: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sampleRate &amp; A2DP_LDAC_SAMPLING_FREQ_192000) { result_config_cie.sampleRate = A2DP_LDAC_SAMPLING_FREQ_192000; codec_capability_.sample_rate = codec_user_config_.sample_rate; codec_config_.sample_rate = codec_user_config_.sample_rate; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> BTAV_A2DP_CODEC_SAMPLE_RATE_16000: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> BTAV_A2DP_CODEC_SAMPLE_RATE_24000: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> BTAV_A2DP_CODEC_SAMPLE_RATE_NONE: codec_capability_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE; codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia de PVS-Studio: V796 CWE-484 Es posible que falte la declaraci√≥n 'break' en la declaraci√≥n del interruptor. </font><font style="vertical-align: inherit;">a2dp_vendor_ldac.cc 912 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creo que el error no necesita explicaci√≥n. </font><font style="vertical-align: inherit;">Solo noto que a menudo se detecta una anomal√≠a en el c√≥digo de m√°s de una manera. </font><font style="vertical-align: inherit;">Por ejemplo, este error tambi√©n es detectado por las advertencias V519:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V519 CWE-563 La variable 'codec_capability_.sample_rate' recibe valores asignados dos veces sucesivamente. </font><font style="vertical-align: inherit;">Quiz√°s esto sea un error. </font><font style="vertical-align: inherit;">L√≠neas de verificaci√≥n: 910, 916. a2dp_vendor_ldac.cc 916</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V519 CWE-563 La variable 'codec_config_.sample_rate' tiene valores asignados dos veces sucesivamente. </font><font style="vertical-align: inherit;">Quiz√°s esto sea un error. </font><font style="vertical-align: inherit;">L√≠neas de verificaci√≥n: 911, 917. a2dp_vendor_ldac.cc 917</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Y un par de errores m√°s: </font></font><br><br><pre> <code class="cpp hljs">Return&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; EffectsFactory::getAllDescriptors(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (status) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> -ENOSYS: { <span class="hljs-comment"><span class="hljs-comment">// Effect list has changed. goto restart; } case -ENOENT: { // No more effects available. result.resize(i); } default: { result.resize(0); retval = Result::NOT_INITIALIZED; } } .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia de PVS-Studio: V796 CWE-484 Es posible que falte la declaraci√≥n 'break' en la declaraci√≥n del interruptor. </font><font style="vertical-align: inherit;">EffectsFactory.cpp 118</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reverb_getParameter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> REVERB_PARAM_REFLECTIONS_LEVEL: *(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> *)pValue = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> REVERB_PARAM_REFLECTIONS_DELAY: *(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *)pValue = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> REVERB_PARAM_REVERB_DELAY: *(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *)pValue = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia de PVS-Studio: V796 CWE-484 Es posible que falte la declaraci√≥n 'break' en la declaraci√≥n del interruptor. </font><font style="vertical-align: inherit;">EffectReverb.cpp 1847</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> SLresult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IAndroidConfiguration_GetConfiguration</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (IObjectToObjectID((thiz)-&gt;mThis)) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SL_OBJECTID_AUDIORECORDER: result = android_audioRecorder_getConfig( (CAudioRecorder *) thiz-&gt;mThis, configKey, pValueSize, pConfigValue); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SL_OBJECTID_AUDIOPLAYER: result = android_audioPlayer_getConfig( (CAudioPlayer *) thiz-&gt;mThis, configKey, pValueSize, pConfigValue); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: result = SL_RESULT_FEATURE_UNSUPPORTED; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia de PVS-Studio: V796 CWE-484 Es posible que falte la declaraci√≥n 'break' en la declaraci√≥n del interruptor. </font><font style="vertical-align: inherit;">IAndroidConfiguration.cpp 90</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gesti√≥n de memoria incorrecta </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠ he compilado errores relacionados con la gesti√≥n incorrecta de la memoria. </font><font style="vertical-align: inherit;">Dichas advertencias, de acuerdo con la enumeraci√≥n de debilidad com√∫n, se clasifican como:</font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-401</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Liberaci√≥n incorrecta de memoria antes de eliminar la √∫ltima referencia ('Fuga de memoria')</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-562</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Devoluci√≥n de direcci√≥n variable de pila</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-762</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Rutinas de administraci√≥n de memoria no coincidentes</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comencemos con funciones que devuelven una referencia a una variable ya destruida. </font></font><br><br><pre> <code class="cpp hljs">TransformIterator&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>++(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) { <span class="hljs-function"><span class="hljs-function">TransformIterator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; ++*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tmp; } TransformIterator&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>--(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) { <span class="hljs-function"><span class="hljs-function">TransformIterator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; --*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tmp; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Advertencias de PVS-Studio: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La funci√≥n V558 CWE-562 devuelve la referencia al objeto local temporal: tmp. </font><font style="vertical-align: inherit;">transform_iterator.h 77</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La funci√≥n V558 CWE-562 devuelve la referencia al objeto local temporal: tmp. </font><font style="vertical-align: inherit;">transform_iterator.h 92</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando las funciones finalizan su ejecuci√≥n, la variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tmp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se </font><font style="vertical-align: inherit;">destruye, ya que se cre√≥ en la pila. </font><font style="vertical-align: inherit;">En consecuencia, las funciones devuelven una referencia a un objeto ya destruido (inexistente). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La soluci√≥n correcta ser√≠a devolver un valor de:</font></font><br><br><pre> <code class="cpp hljs">TransformIterator <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>++(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) { <span class="hljs-function"><span class="hljs-function">TransformIterator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; ++*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tmp; } TransformIterator <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>--(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) { <span class="hljs-function"><span class="hljs-function">TransformIterator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; --*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tmp; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Considere un c√≥digo a√∫n m√°s triste que merece mucha atenci√≥n. </font></font><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/619/b25/299/619b2529917e9570454e60bf9c27c3f8.png" alt="C√≥digo peligroso"></div><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">register_socket_transport</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* serial, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> port, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> local)</span></span></span><span class="hljs-function"> </span></span>{ atransport* t = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> atransport(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!serial) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">32</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">snprintf</span></span>(buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(buf), <span class="hljs-string"><span class="hljs-string">"T-%p"</span></span>, t); serial = buf; } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia de PVS-Studio: V507 CWE-562 El puntero a la matriz local 'buf' se almacena fuera del alcance de esta matriz. Tal puntero se volver√° inv√°lido. transport.cpp 1030 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este es un c√≥digo peligroso. Si el valor real del argumento en </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">serie</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es NULL, se debe usar un b√∫fer temporal en la pila. Cuando el cuerpo de la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instrucci√≥n if</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> finaliza, la matriz </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">buf</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> deja de existir. El lugar donde se cre√≥ el b√∫fer se puede usar para almacenar otras variables creadas en la pila. Comenzar√° un desastre infernal en los datos, y las consecuencias de tal error est√°n mal predichas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los siguientes errores est√°n relacionados con m√©todos incompatibles para crear y destruir objetos.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SensorService::SensorEventConnection::reAllocateCacheLocked(....) { <span class="hljs-keyword"><span class="hljs-keyword">sensors_event_t</span></span> *eventCache_new; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> new_cache_size = computeMaxCacheSizeLocked(); eventCache_new = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sensors_event_t</span></span>[new_cache_size]; .... <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> mEventCache; mEventCache = eventCache_new; mCacheSize += count; mMaxCacheSize = new_cache_size; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia de PVS-Studio: V611 CWE-762 La memoria se asign√≥ usando el operador 'nuevo T []' pero se liber√≥ usando el operador 'borrar'. Considere inspeccionar este c√≥digo. Probablemente sea mejor usar 'delete [] mEventCache;'. Verifique las l√≠neas: 391, 384. SensorEventConnection.cpp 391 Aqu√≠ </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">todo es simple. El b√∫fer al que apunta un miembro de la clase </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mEventCache</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se asigna utilizando el </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nuevo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operador </font><i><font style="vertical-align: inherit;">[]</font></i><font style="vertical-align: inherit;"> . Y libere esta memoria utilizando el operador de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eliminaci√≥n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Esto es incorrecto y conduce a un comportamiento indefinido del programa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Error similar</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">aaudio_result_t</span></span> AAudioServiceEndpointCapture::open(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> mDistributionBuffer; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distributionBufferSizeBytes = getStreamInternal()-&gt;getFramesPerBurst() * getStreamInternal()-&gt;getBytesPerFrame(); mDistributionBuffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>[distributionBufferSizeBytes]; .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia de PVS-Studio: V611 CWE-762 La memoria se asign√≥ usando el operador 'nuevo T []' pero se liber√≥ usando el operador 'borrar'. </font><font style="vertical-align: inherit;">Considere inspeccionar este c√≥digo. </font><font style="vertical-align: inherit;">Probablemente sea mejor usar 'delete [] mDistributionBuffer;'. </font><font style="vertical-align: inherit;">AAudioServiceEndpointCapture.cpp 50 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creo que el error no requiere explicaci√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El siguiente caso es un poco m√°s interesante, pero la esencia del error es exactamente la misma.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HeifFrameInfo</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... mIccData.reset(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>[iccSize]); .... } .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>&gt; mIccData; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V554 CWE-762 Uso incorrecto de unique_ptr. </font></font> La memoria asignada con 'nuevo []' se limpiar√° con 'eliminar'.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HeifDecoderAPI.h 62 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De manera predeterminada, la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">clase de</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> puntero inteligente </font><i><font style="vertical-align: inherit;">std :: unique_ptr</font></i><font style="vertical-align: inherit;"> llama al operador de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eliminaci√≥n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para destruir un objeto </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sin embargo, en la funci√≥n </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">set</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , la </font><font style="vertical-align: inherit;">memoria se asigna usando el </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nuevo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operador </font><i><font style="vertical-align: inherit;">[]</font></i><font style="vertical-align: inherit;"> .</font></font><br><br>  La opci√≥n correcta: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>[]&gt; mIccData;</code> </pre> <br>  Otros errores: <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V554 CWE-762 Uso incorrecto de unique_ptr. </font></font> La memoria asignada con 'nuevo []' se limpiar√° con 'eliminar'.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atrace.cpp 949 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V554 CWE-762 Uso incorrecto de unique_ptr. </font></font> La memoria asignada con 'nuevo []' se limpiar√° con 'eliminar'.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atrace.cpp 950 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V554 CWE-762 Uso incorrecto de unique_ptr. </font></font> La memoria asignada con 'nuevo []' se limpiar√° con 'eliminar'.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> HeifDecoderImpl.cpp 102 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V554 CWE-762 Uso incorrecto de unique_ptr. </font></font> La memoria asignada con 'nuevo []' se limpiar√° con 'eliminar'.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> HeifDecoderImpl.cpp 166 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V554 CWE-762 Uso incorrecto de unique_ptr. </font></font> La memoria asignada con 'nuevo []' se limpiar√° con 'eliminar'.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ColorSpace.cpp 360 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los errores de p√©rdida de memoria completar√°n esta secci√≥n. </font><font style="vertical-align: inherit;">Una sorpresa desagradable es que hubo m√°s de 20 errores de este tipo. Me parece que estos pueden ser defectos muy dolorosos, que conducen a una disminuci√≥n gradual de la memoria libre durante el funcionamiento continuo prolongado del sistema operativo.</font></font><br><br><pre> <code class="cpp hljs">Asset* Asset::createFromUncompressedMap(FileMap* dataMap, AccessMode mode) { _FileAsset* pAsset; <span class="hljs-keyword"><span class="hljs-keyword">status_t</span></span> result; pAsset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> _FileAsset; result = pAsset-&gt;openChunk(dataMap); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result != NO_ERROR) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; pAsset-&gt;mAccessMode = mode; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pAsset; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Advertencia de PVS-Studio: V773 CWE-401 La funci√≥n se cerr√≥ sin soltar el puntero 'pAsset'. </font></font> Una p√©rdida de memoria es posible.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asset.cpp 296 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si no fue posible abrir un determinado fragmento, la funci√≥n se cierra sin destruir el objeto, cuyo puntero se almacena en la variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pAsset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Como resultado, se producir√° una p√©rdida de memoria. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otros errores son similares, por lo que no veo ninguna raz√≥n para considerarlos en el art√≠culo. </font><font style="vertical-align: inherit;">Los </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interesados</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pueden ver otras advertencias en el archivo: </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">Android_V773.txt</font></a><font style="vertical-align: inherit;"> .</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ir al extranjero una gran variedad </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay una gran cantidad de patrones err√≥neos que conducen al desbordamiento de la matriz. </font><font style="vertical-align: inherit;">En el caso de Android, detect√© solo un patr√≥n de error del siguiente tipo:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || i &gt; MAX) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; A[i] = x;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En C y C ++, las celdas de la matriz est√°n numeradas de 0, por lo que el √≠ndice m√°ximo de un elemento en la matriz debe ser uno menor que el tama√±o de la matriz en s√≠. </font><font style="vertical-align: inherit;">La verificaci√≥n correcta deber√≠a ser as√≠:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || i &gt;= MAX) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; A[i] = x;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El desbordamiento de una </font><font style="vertical-align: inherit;">matriz, de acuerdo con la Enumeraci√≥n de Debilidad Com√∫n, se clasifica como </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-119</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Restricci√≥n inadecuada de operaciones dentro de los l√≠mites de un buffer de memoria. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eche un vistazo a c√≥mo se ven estos errores en el c√≥digo de Android.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">btif_hf_cb_t</span></span> btif_hf_cb[BTA_AG_MAX_NUM_CLIENTS]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsSlcConnected</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RawAddress* bd_addr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!bd_addr) { LOG(WARNING) &lt;&lt; __func__ &lt;&lt; <span class="hljs-string"><span class="hljs-string">": bd_addr is null"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idx = btif_hf_idx_by_bdaddr(bd_addr); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idx &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || idx &gt; BTA_AG_MAX_NUM_CLIENTS) { LOG(WARNING) &lt;&lt; __func__ &lt;&lt; <span class="hljs-string"><span class="hljs-string">": invalid index "</span></span> &lt;&lt; idx &lt;&lt; <span class="hljs-string"><span class="hljs-string">" for "</span></span> &lt;&lt; *bd_addr; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> btif_hf_cb[idx].state == BTHF_CONNECTION_STATE_SLC_CONNECTED; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia de PVS-Studio: V557 CWE-119 Array overrun es posible. </font><font style="vertical-align: inherit;">El valor del √≠ndice 'idx' podr√≠a alcanzar 6. btif_hf.cc 277 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opci√≥n de verificaci√≥n correcta:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idx &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || idx &gt;= BTA_AG_MAX_NUM_CLIENTS) {</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exactamente los mismos errores se encontraron dos cosas m√°s: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V557 CWE-119 Arreglo de arrastre es posible. </font><font style="vertical-align: inherit;">El valor del √≠ndice 'idx' podr√≠a alcanzar 6. btif_hf.cc 869</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V557 CWE-119 Arreglo de arrastre es posible. </font><font style="vertical-align: inherit;">El valor del √≠ndice 'index' podr√≠a alcanzar 6. btif_rc.cc 374</font></font></li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ciclos rotos </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay muchas formas de escribir un ciclo de mal funcionamiento. </font><font style="vertical-align: inherit;">En el c√≥digo de Android, encontr√© errores que, de acuerdo con la enumeraci√≥n de debilidad com√∫n, se pueden clasificar como:</font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-20</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Validaci√≥n de entrada incorrecta</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-670</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Implementaci√≥n de flujo de control siempre incorrecta</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-691</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Gesti√≥n de flujo de control insuficiente</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-834</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : iteraci√≥n excesiva</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Al mismo tiempo, por supuesto, hay otras formas de "dispararle a su propia pierna" al escribir ciclos, pero esta vez no me conocieron. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **argv)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%s is already in *.base_fs format, just ..... "</span></span>, ....); rewind(blk_alloc_file); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((c = fgetc(blk_alloc_file)) != EOF) { fputc(c, base_fs_file); } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia de PVS-Studio: V739 CWE-20 EOF no debe compararse con un valor del tipo 'char'. El '(c = fgetc (blk_alloc_file))' deber√≠a ser del tipo 'int'. blk_alloc_to_base_fs.c 61 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El analizador detect√≥ que la constante </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EOF</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se </font><font style="vertical-align: inherit;">compara con una variable de tipo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">char</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Veamos por qu√© este c√≥digo es incorrecto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La funci√≥n </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fgetc</font></font></i></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> devuelve un valor </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a saber: puede devolver un n√∫mero de 0 a 255 o EOF (-1). El valor de lectura se coloca en una variable de tipo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">char</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Debido a esto, un car√°cter con un valor de 0xFF (255) se convierte en -1 y se interpreta exactamente de la misma manera que el final de un archivo (EOF).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debido a tales errores, los usuarios que utilizan c√≥digos ASCII extendidos a veces se encuentran con una situaci√≥n en la que los programas procesan incorrectamente uno de los caracteres de su alfabeto. Por ejemplo, la √∫ltima letra del alfabeto ruso codificada en Windows-1251 solo tiene el c√≥digo 0xFF y algunos programas la perciben como el final del archivo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En resumen, podemos decir que la condici√≥n para detener el ciclo est√° escrita incorrectamente. Para solucionar la situaci√≥n, la variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> debe ser de </font><font style="vertical-align: inherit;">tipo int. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Continuamos y consideramos errores m√°s familiares cuando utilizamos la declaraci√≥n </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">status_t</span></span> AudioPolicyManager::registerPolicyMixes(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; mixes.size(); i++) { .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; mHwModules.size(); j++) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= if (strcmp(AUDIO_HARDWARE_MODULE_ID_REMOTE_SUBMIX, mHwModules[j]-&gt;mName) == 0 &amp;&amp; mHwModules[j]-&gt;mHandle != 0) { rSubmixModule = mHwModules[j]; break; } .... } .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia de PVS-Studio: V534 CWE-691 Es probable que se est√© comparando una variable incorrecta dentro del operador 'for'. Considere revisar 'i'. AudioPolicyManager.cpp 2489 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debido a un error tipogr√°fico en un bucle anidado, la condici√≥n usa la variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , aunque debe usar la variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Como resultado, la variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j se</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> incrementa incontrolablemente, lo que con el tiempo llevar√° a que la matriz </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mHwModules se salga de los l√≠mites</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Lo que suceder√° despu√©s es imposible de predecir, ya que habr√° un comportamiento indefinido del programa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por cierto, este fragmento con un error se copi√≥ completamente a otra funci√≥n. Por lo tanto, el analizador encontr√≥ exactamente el mismo error aqu√≠: AudioPolicyManager.cpp 2586.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay 3 fragmentos de c√≥digo m√°s que son muy sospechosos para m√≠. </font><font style="vertical-align: inherit;">Sin embargo, no presumo decir que este c√≥digo es definitivamente err√≥neo, ya que all√≠ hay una l√≥gica compleja. </font><font style="vertical-align: inherit;">En cualquier caso, debo prestar atenci√≥n a este c√≥digo para que el autor lo revise. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El primer fragmento:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ce_t3t_handle_check_cmd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; p_cb-&gt;cur_cmd.num_blocks; i++) { .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; T3T_MSG_NDEF_ATTR_INFO_SIZE; i++) { checksum += p_temp[i]; } .... } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia de PVS-Studio: V535 CWE-691 La variable 'i' se est√° utilizando para este bucle y para el bucle externo. </font><font style="vertical-align: inherit;">Verifique las l√≠neas: 398, 452. ce_t3t.cc 452 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenga en cuenta que la variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i se</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> usa tanto para los ciclos externos como internos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dos disparadores m√°s similares del analizador:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V535 CWE-691 La variable 'xx' se est√° utilizando para este bucle y para el bucle externo. </font><font style="vertical-align: inherit;">Verifique las l√≠neas: 801, 807. sdp_db.cc 807</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V535 CWE-691 La variable 'xx' se est√° utilizando para este bucle y para el bucle externo. </font><font style="vertical-align: inherit;">L√≠neas de verificaci√≥n: 424, 438. nfa_hci_act.cc 438</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øA√∫n no est√°s cansado? </font><font style="vertical-align: inherit;">Sugiero pausar y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descargar PVS-Studio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para intentar verificar su proyecto.</font></font><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30b/8e3/d36/30b8e3d36a2b05111cee2b76d981d89f.png" alt="Prueba PVS-Studio"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ahora continuemos. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NFA_HCI_LAST_PROP_GATE 0xFF tNFA_HCI_DYN_GATE* nfa_hciu_alloc_gate(uint8_t gate_id, tNFA_HANDLE app_handle) { .... for (gate_id = NFA_HCI_FIRST_HOST_SPECIFIC_GENERIC_GATE; gate_id </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;= NFA_HCI_LAST_PROP_GATE; gate_id++) { if (gate_id == NFA_HCI_CONNECTIVITY_GATE) gate_id++; if (nfa_hciu_find_gate_by_gid(gate_id) == NULL) break; } if (gate_id &gt; NFA_HCI_LAST_PROP_GATE) { LOG(ERROR) &lt;&lt; StringPrintf( "nfa_hci_alloc_gate - no free Gate ID: %u " "App Handle: 0x%04x", gate_id, app_handle); return (NULL); } .... }</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia de PVS-Studio: V654 CWE-834 La condici√≥n 'gate_id &lt;= 0xFF' del bucle siempre es verdadera. </font><font style="vertical-align: inherit;">nfa_hci_utils.cc 248 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenga en cuenta lo siguiente:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La constante </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NFA_HCI_LAST_PROP_GATE</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es igual a 0xFF.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una variable de tipo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_t se</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> usa como </font><i><font style="vertical-align: inherit;">contador de bucles</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Por lo tanto, el rango de valores de esta variable es [0..0xFF].</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resulta que la condici√≥n </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gate_id &lt;= NFA_HCI_LAST_PROP_GATE</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> siempre </font><i><font style="vertical-align: inherit;">es</font></i><font style="vertical-align: inherit;"> verdadera y no puede detener la ejecuci√≥n del bucle. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El analizador clasific√≥ este error como CWE-834, pero tambi√©n se puede interpretar como CWE-571: La expresi√≥n es siempre verdadera. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El siguiente error en el bucle est√° relacionado con un comportamiento indefinido.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">status_t</span></span> SimpleDecodingSource::doRead(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> retries = <span class="hljs-number"><span class="hljs-number">0</span></span>; ++retries; ) { .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia de PVS-Studio: V654 CWE-834 La condici√≥n '++ reintentos' del bucle siempre es verdadera. </font><font style="vertical-align: inherit;">SimpleDecodingSource.cpp 226 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aparentemente, el programador quer√≠a que la variable de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reintentos</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tomara todos los valores posibles para la variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y solo entonces el ciclo finaliz√≥. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El ciclo deber√≠a detenerse cuando la expresi√≥n </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">++ reintenta</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es 0. Y esto solo es posible si la variable se desborda. </font><font style="vertical-align: inherit;">Como la variable es de tipo con signo, su desbordamiento conduce a un comportamiento indefinido. </font><font style="vertical-align: inherit;">Por lo tanto, este c√≥digo es incorrecto y puede tener consecuencias impredecibles. </font><font style="vertical-align: inherit;">Por ejemplo, el compilador tiene todo el derecho de eliminar el cheque y dejar solo instrucciones para incrementar el contador.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Y el √∫ltimo error en esta secci√≥n. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">status_t</span></span> Check(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; source) { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pass = <span class="hljs-number"><span class="hljs-number">1</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(rc) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: SLOGI(<span class="hljs-string"><span class="hljs-string">"Filesystem check completed OK"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: SLOGE(<span class="hljs-string"><span class="hljs-string">"Filesystem check failed (not a FAT filesystem)"</span></span>); errno = ENODATA; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pass++ &lt;= <span class="hljs-number"><span class="hljs-number">3</span></span>) { SLOGW(<span class="hljs-string"><span class="hljs-string">"Filesystem modified - rechecking (pass %d)"</span></span>, pass); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-comment"><span class="hljs-comment">// &lt;= } SLOGE("Failing check after too many rechecks"); errno = EIO; return -1; case 8: SLOGE("Filesystem check failed (no filesystem)"); errno = ENODATA; return -1; default: SLOGE("Filesystem check failed (unknown exit code %d)", rc); errno = EIO; return -1; } } while (0); // &lt;= return 0; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia de PVS-Studio: V696 CWE-670 El operador 'continuar' terminar√° el ciclo 'do {...} while (FALSE)' porque la condici√≥n siempre es falsa. </font><font style="vertical-align: inherit;">Verifique las l√≠neas: 105, 121. Vfat.cpp 105 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ante nosotros hay un bucle de la forma:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; .... } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para realizar iteraciones repetidas, el programador usa la instrucci√≥n </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">continue</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font> Esto esta mal.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La instrucci√≥n </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">continue</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no reanuda el ciclo de inmediato, sino que contin√∫a verificando la condici√≥n. </font><font style="vertical-align: inherit;">Como la condici√≥n siempre es falsa, en cualquier caso el ciclo se ejecutar√° solo una vez. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para corregir el error, el c√≥digo puede reescribirse, por ejemplo, as√≠:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reasignaci√≥n Variable </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">error</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> muy </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">com√∫n</font></a><font style="vertical-align: inherit;"> es reescribir en una variable antes de usar el valor anterior. </font><font style="vertical-align: inherit;">En la mayor√≠a de los casos, estos errores se producen debido a un error tipogr√°fico o un Copiar-Pegar sin √©xito. </font><font style="vertical-align: inherit;">Seg√∫n la enumeraci√≥n de debilidad com√∫n, tales errores se clasifican como </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-563</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Asignaci√≥n a variable sin uso. </font><font style="vertical-align: inherit;">No sin tales errores en Android.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">status_t</span></span> XMLNode::flatten_node(....) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;namespaceExt, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(namespaceExt)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mNamespacePrefix.size() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { namespaceExt.prefix.index = htodl(strings.offsetForString(mNamespacePrefix)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { namespaceExt.prefix.index = htodl((<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)<span class="hljs-number"><span class="hljs-number">-1</span></span>); } namespaceExt.prefix.index = htodl(strings.offsetForString(mNamespacePrefix)); namespaceExt.uri.index = htodl(strings.offsetForString(mNamespaceUri)); .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia de PVS-Studio: V519 CWE-563 La variable 'namespaceExt.prefix.index' recibe valores asignados dos veces sucesivamente. </font><font style="vertical-align: inherit;">Quiz√°s esto sea un error. </font><font style="vertical-align: inherit;">Verifique las l√≠neas: 1535, 1539. XMLNode.cpp 1539 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para resaltar la esencia del error, escribir√© un pseudoc√≥digo:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) X = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> X = <span class="hljs-number"><span class="hljs-number">2</span></span>; X = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Independientemente de la condici√≥n, a la variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (en el c√≥digo actual es </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">namespaceExt.prefix.index</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) siempre se le asignar√° un valor.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> AudioFlinger::RecordThread::threadLoop() { .... <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> framesToRead = mBufferSize / mFrameSize; framesToRead = min(mRsmpInFramesOA - rear, mRsmpInFramesP2 / <span class="hljs-number"><span class="hljs-number">2</span></span>); .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia de PVS-Studio: V519 CWE-563 A la variable 'framesToRead' se le asignan valores dos veces seguidas. </font><font style="vertical-align: inherit;">Quiz√°s esto sea un error. </font><font style="vertical-align: inherit;">Verifique las l√≠neas: 6341, 6342. Threads.cpp 6342 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No est√° claro por qu√© era necesario inicializar la variable al declarar, si luego se le escribe otro valor de inmediato. </font><font style="vertical-align: inherit;">Algo est√° mal aqu√≠.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SchedulingLatencyVisitorARM::VisitArrayGet(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index-&gt;IsConstant()) { last_visited_latency_ = kArmMemoryLoadLatency; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (has_intermediate_address) { } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { last_visited_internal_latency_ += kArmIntegerOpLatency; } last_visited_internal_latency_ = kArmMemoryLoadLatency; } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia de PVS-Studio: V519 CWE-563 La variable 'last_visited_internal_latency_' tiene valores asignados dos veces sucesivamente. </font><font style="vertical-align: inherit;">Quiz√°s esto sea un error. </font><font style="vertical-align: inherit;">Verifique las l√≠neas: 680, 682. Scheduler_arm.cc 682 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√≥digo muy extra√±o y sin sentido. </font><font style="vertical-align: inherit;">Me atrevo a sugerir que deber√≠a haber sido escrito:</font></font><br><br><pre> <code class="cpp hljs">last_visited_internal_latency_ += kArmMemoryLoadLatency;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Y el √∫ltimo error, que demuestra c√≥mo el analizador encuentra incansablemente los errores que probablemente se omitan incluso con una revisi√≥n cuidadosa del c√≥digo. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">multiprecision_fast_mod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* c, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> U; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> V; .... c[<span class="hljs-number"><span class="hljs-number">0</span></span>] += U; V = c[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt; U; c[<span class="hljs-number"><span class="hljs-number">1</span></span>] += V; V = c[<span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; V; c[<span class="hljs-number"><span class="hljs-number">2</span></span>] += V; <span class="hljs-comment"><span class="hljs-comment">// V = c[2] &lt; V; // &lt;= c[2] += U; // V = c[2] &lt; U; // &lt;= c[3] += V; V = c[3] &lt; V; c[4] += V; V = c[4] &lt; V; c[5] += V; V = c[5] &lt; V; .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia de PVS-Studio: V519 CWE-563 A la variable 'V' se le asignan valores dos veces seguidas. </font><font style="vertical-align: inherit;">Quiz√°s esto sea un error. </font><font style="vertical-align: inherit;">Verifique las l√≠neas: 307, 309. p_256_multprecision.cc 309 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El c√≥digo es tan "desgarrador" que no quiero entenderlo. </font><font style="vertical-align: inherit;">Esto es claramente visible: hay un error tipogr√°fico en el c√≥digo, que resalt√© con comentarios.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Otros errores </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay errores dispersos para los cuales no tiene sentido hacer cap√≠tulos separados. </font><font style="vertical-align: inherit;">Sin embargo, son tan interesantes e insidiosos como los considerados anteriormente. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operaciones prioritarias</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TagMonitor::parseTagsToMonitor(String8 tagNames) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; lock(mMonitorMutex); <span class="hljs-comment"><span class="hljs-comment">// Expand shorthands if (ssize_t idx = tagNames.find("3a") != -1) { ssize_t end = tagNames.find(",", idx); char* start = tagNames.lockBuffer(tagNames.size()); start[idx] = '\0'; .... } .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia de PVS-Studio: V593 CWE-783 Considere revisar la expresi√≥n del tipo 'A = B! = C'. La expresi√≥n se calcula de la siguiente manera: 'A = (B! = C)'. TagMonitor.cpp 50 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enumeraci√≥n de debilidad com√∫n: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-783</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Error l√≥gico de precedencia del operador. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El programador concibi√≥ lo siguiente. Se busca la subcadena "3a" y la </font><font style="vertical-align: inherit;">posici√≥n de esta subcadena se escribe en la </font><font style="vertical-align: inherit;">variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">idx</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Si se encuentra la subcadena (idx! = -1), el c√≥digo comienza a ejecutarse y utiliza el valor de la variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">idx</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desafortunadamente, el programador est√° confundido acerca de las prioridades de las operaciones. De hecho, el cheque funciona as√≠:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> idx = (tagNames.find(<span class="hljs-string"><span class="hljs-string">"3a"</span></span>) != <span class="hljs-number"><span class="hljs-number">-1</span></span>))</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primero, verifica si hay una subcadena "3a" en la cadena, y el resultado falso / verdadero se coloca en la variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">idx</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Como resultado, la variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">idx</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tiene el valor 0 o 1. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si la condici√≥n es verdadera (la variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">idx</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es 1), la l√≥gica que usa la variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">idx</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> comienza a ejecutarse </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Una variable siempre igual a 1 conducir√° a un comportamiento incorrecto del programa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede corregir el error si realiza la inicializaci√≥n de la variable desde la condici√≥n:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> idx = tagNames.find(<span class="hljs-string"><span class="hljs-string">"3a"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idx != <span class="hljs-number"><span class="hljs-number">-1</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La nueva versi√≥n de C ++ 17 tambi√©n te permite escribir: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> idx = tagNames.find(<span class="hljs-string"><span class="hljs-string">"3a"</span></span>); idx != <span class="hljs-number"><span class="hljs-number">-1</span></span>)</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Constructor inv√°lido</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HearingDevice</span></span></span><span class="hljs-class"> {</span></span> .... HearingDevice() { HearingDevice(RawAddress::kEmpty, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } .... };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia de PVS-Studio: V603 CWE-665 El objeto se cre√≥ pero no se est√° utilizando. Si desea llamar al constructor, debe usar 'this-&gt; HearingDevice :: HearingDevice (....)'. hear_aid.cc 176 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enumeraci√≥n de debilidad com√∫n: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-665</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Inicializaci√≥n incorrecta. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los programadores a menudo se equivocan cuando intentan llamar expl√≠citamente a un constructor para inicializar un objeto. Hay dos constructores en la clase. Para reducir el tama√±o del c√≥digo fuente, el programador decidi√≥ llamar a un constructor desde otro. Pero este c√≥digo no tiene nada de lo que el desarrollador espera. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo siguiente sucede. Se </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">crea</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> un nuevo objeto sin nombre de tipo </font><i><font style="vertical-align: inherit;">HearingDevice</font></i><font style="vertical-align: inherit;"> y luego se destruye. Como resultado, los campos de clase permanecen sin inicializar.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para corregir el error, puede usar el constructor delegante (esta caracter√≠stica apareci√≥ en C ++ 11). </font><font style="vertical-align: inherit;">El c√≥digo correcto es:</font></font><br><br><pre> <code class="cpp hljs">HearingDevice() : HearingDevice(RawAddress::kEmpty, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { }</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La funci√≥n no devuelve valor</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NET_RecvFrom</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> flags, struct sockaddr *from, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *fromlen)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">socklen_t</span></span> socklen = *fromlen; BLOCKING_IO_RETURN_INT( s, recvfrom(s, buf, len, flags, from, &amp;socklen) ); *fromlen = socklen; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia de PVS-Studio: V591 CWE-393 La funci√≥n no nula deber√≠a devolver un valor. </font><font style="vertical-align: inherit;">linux_close.cpp 139 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enumeraci√≥n de debilidad com√∫n: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-393</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : devoluci√≥n del c√≥digo de estado incorrecto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La funci√≥n devolver√° un valor aleatorio. </font><font style="vertical-align: inherit;">Otro error de este tipo: V591 CWE-393 La funci√≥n no nula deber√≠a devolver un valor. </font><font style="vertical-align: inherit;">linux_close.cpp 158 </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√°lculo de tama√±o de estructura incorrecto</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MtpFfsHandle::handleControlRequest(....) { .... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mtp_device_status</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">st</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">reinterpret_cast</span></span></span><span class="hljs-class">&lt;struct mtp_device_status*&gt;(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">buf</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">());</span></span> st-&gt;wLength = htole16(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(st)); .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia de PVS-Studio: V568 Es extra√±o que el operador 'sizeof ()' eval√∫e el tama√±o de un puntero a una clase, pero no el tama√±o del objeto de clase 'st'. </font><font style="vertical-align: inherit;">MtpFfsHandle.cpp 251 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estoy seguro de que </font><font style="vertical-align: inherit;">quer√≠an poner el tama√±o de la estructura, no el tama√±o del puntero </font><font style="vertical-align: inherit;">, en la variable miembro </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wLength</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Entonces el c√≥digo correcto deber√≠a ser as√≠:</font></font><br><br><pre> <code class="cpp hljs">st-&gt;wLength = htole16(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*st));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Respuestas similares del analizador: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V568 Es extra√±o que el operador 'sizeof ()' eval√∫e el tama√±o de un puntero a una clase, pero no el tama√±o del objeto de clase 'cacheinfo'. </font><font style="vertical-align: inherit;">NetlinkEvent.cpp 220</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V568 Es extra√±o que el operador 'sizeof ()' eval√∫e el tama√±o de un puntero a una clase, pero no el tama√±o del objeto de clase 'p√°gina-&gt; siguiente'. </font><font style="vertical-align: inherit;">linker_block_allocator.cpp 146</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V568 Es extra√±o que el argumento del operador sizeof () sea la expresi√≥n '&amp; session_id'. </font><font style="vertical-align: inherit;">referencia-ril.c 1775</font></font></li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operaciones de bits sin sentido</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EGL_CONTEXT_OPENGL_DEBUG_BIT_KHR 0x00000001 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EGL_CONTEXT_OPENGL_FORWARD_COMPATIBLE_BIT_KHR 0x00000002 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EGL_CONTEXT_OPENGL_ROBUST_ACCESS_BIT_KHR 0x00000004 EGLContext eglCreateContext(....) { .... case EGL_CONTEXT_FLAGS_KHR: </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((attrib_val | EGL_CONTEXT_OPENGL_DEBUG_BIT_KHR) || (attrib_val | EGL_CONTEXT_OPENGL_FORWARD_C....) || (attrib_val | EGL_CONTEXT_OPENGL_ROBUST_ACCESS_BIT_KHR)) { context_flags = attrib_val; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { RETURN_ERROR(EGL_NO_CONTEXT,EGL_BAD_ATTRIBUTE); } .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia de PVS-Studio: V617 CWE-480 Considere inspeccionar la condici√≥n. </font><font style="vertical-align: inherit;">El argumento '0x00000001' de '|' </font><font style="vertical-align: inherit;">La operaci√≥n bit a bit contiene un valor distinto de cero. </font><font style="vertical-align: inherit;">egl.cpp 1329 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enumeraci√≥n de debilidad com√∫n: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-480</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : uso de operador incorrecto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una expresi√≥n de la forma (A | 1) || </font><font style="vertical-align: inherit;">(A | 2) || </font><font style="vertical-align: inherit;">(A | 4) no tiene sentido, ya que el resultado siempre ser√° verdadero. </font><font style="vertical-align: inherit;">De hecho, debe usar el operador </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&amp;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y luego el c√≥digo tiene sentido:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((attrib_val &amp; EGL_CONTEXT_OPENGL_DEBUG_BIT_KHR) || (attrib_val &amp; EGL_CONTEXT_OPENGL_FORWARD_COMPATIBLE_BIT_KHR) || (attrib_val &amp; EGL_CONTEXT_OPENGL_ROBUST_ACCESS_BIT_KHR))</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Error similar: V617 CWE-480 Considere inspeccionar la condici√≥n. El argumento '0x00000001' de '|' La operaci√≥n bit a bit contiene un valor distinto de cero. egl.cpp 1338 </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cambio de bit incorrecto</font></font></b> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> AddressType&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegsInfo</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> saved_reg_map = <span class="hljs-number"><span class="hljs-number">0</span></span>; AddressType saved_regs[<span class="hljs-number"><span class="hljs-number">64</span></span>]; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> AddressType* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reg &gt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(saved_regs) / <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(AddressType)) { <span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>(); } saved_reg_map |= <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; reg; saved_regs[reg] = (*regs)[reg]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;(*regs)[reg]; } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia de PVS-Studio: V629 CWE-190 Considere inspeccionar la expresi√≥n '1 &lt;&lt; reg'. </font><font style="vertical-align: inherit;">Desplazamiento de bits del valor de 32 bits con una expansi√≥n posterior al tipo de 64 bits. </font><font style="vertical-align: inherit;">RegsInfo.h 47 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enumeraci√≥n de debilidad com√∫n: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-190</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Desbordamiento de enteros o envolvente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Con un desplazamiento de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 &lt;&lt; reg, el</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> valor de la variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reg se</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> encuentra en el rango [0..63]. </font><font style="vertical-align: inherit;">La expresi√≥n sirve para obtener diferentes grados de dos, comenzando desde 2 ^ 0 y terminando en 2 ^ 63. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El c√≥digo no funciona. </font><font style="vertical-align: inherit;">El hecho es que el literal num√©rico 1 tiene un tipo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int de</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 32 bits </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Por lo tanto, no funcionar√° obtener un valor mayor que 1 ^ 31. </font><font style="vertical-align: inherit;">Un cambio a un valor mayor conduce al desbordamiento de la variable y al surgimiento de un comportamiento indefinido.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El c√≥digo correcto es: </font></font><br><br><pre> <code class="cpp hljs">saved_reg_map |= <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; reg;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o: </font></font><br><br><pre> <code class="cpp hljs">saved_reg_map |= <span class="hljs-number"><span class="hljs-number">1U</span></span>LL &lt;&lt; reg;</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las cadenas se copian a s√≠ mismas.</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> PCLmGenerator::writeJobTicket() { <span class="hljs-comment"><span class="hljs-comment">// Write JobTicket char inputBin[256]; char outputBin[256]; if (!m_pPCLmSSettings) { return; } getInputBinString(m_pPCLmSSettings-&gt;userInputBin, &amp;inputBin[0]); getOutputBin(m_pPCLmSSettings-&gt;userOutputBin, &amp;outputBin[0]); strcpy(inputBin, inputBin); strcpy(outputBin, outputBin); .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Advertencias de PVS-Studio: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V549 CWE-688 El primer argumento de la funci√≥n 'strcpy' es igual al segundo argumento. </font><font style="vertical-align: inherit;">genPCLm.cpp 1181</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V549 CWE-688 El primer argumento de la funci√≥n 'strcpy' es igual al segundo argumento. </font><font style="vertical-align: inherit;">genPCLm.cpp 1182</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De acuerdo con la clasificaci√≥n de Enumeraci√≥n de debilidad com√∫n: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-688</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Llamada de funci√≥n con variable incorrecta o referencia como argumento. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las cadenas se copian por alguna raz√≥n. </font><font style="vertical-align: inherit;">Lo m√°s probable es que haya algunos errores tipogr√°ficos aqu√≠. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando una variable no inicializada</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mca_set_cfg_by_tbl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ tMCA_DCB* p_dcb; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tL2CAP_FCR_OPTS* p_opt; tMCA_FCS_OPT fcs = MCA_FCS_NONE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p_tbl-&gt;tcid == MCA_CTRL_TCID) { p_opt = &amp;mca_l2c_fcr_opts_def; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { p_dcb = mca_dcb_by_hdl(p_tbl-&gt;cb_idx); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p_dcb) { p_opt = &amp;p_dcb-&gt;p_chnl_cfg-&gt;fcr_opt; fcs = p_dcb-&gt;p_chnl_cfg-&gt;fcs; } } <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(p_cfg, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(tL2CAP_CFG_INFO)); p_cfg-&gt;mtu_present = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; p_cfg-&gt;mtu = p_tbl-&gt;my_mtu; p_cfg-&gt;fcr_present = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(&amp;p_cfg-&gt;fcr, p_opt, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(tL2CAP_FCR_OPTS)); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia de PVS-Studio: V614 CWE-824 Puntero potencialmente no inicializado 'p_opt' utilizado. Considere verificar el segundo argumento real de la funci√≥n 'memcpy'. mca_main.cc 252 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enumeraci√≥n de debilidad com√∫n: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-824</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Acceso del puntero no inicializado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p_tbl-&gt; tcid! = MCA_CTRL_TCID</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p_dcb == nullptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , entonces el puntero </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p_opt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> permanecer√° sin inicializar. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uso m√°s extra√±o de la variable no inicializada</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timespec</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">__time_t</span></span> tv_sec; <span class="hljs-comment"><span class="hljs-comment">/* Seconds. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tv_nsec; <span class="hljs-comment"><span class="hljs-comment">/* Nanoseconds. */</span></span> }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> timespec </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NsToTimespec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ns)</span></span></span><span class="hljs-function"> </span></span>{ timespec t; <span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> remainder; t.tv_sec = ns / kNanosPerSecond; remainder = ns % kNanosPerSecond; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (remainder &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { t.tv_nsec--; remainder += kNanosPerSecond; } t.tv_nsec = remainder; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia de PVS-Studio: V614 CWE-457 Variable no inicializada 't.tv_nsec' utilizada. </font><font style="vertical-align: inherit;">clock_ns.h 55 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enumeraci√≥n de debilidad com√∫n: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-457</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Uso de la variable no inicializada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el momento de disminuir la variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t.tv_nsec,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no est√° inicializada. </font><font style="vertical-align: inherit;">La variable se inicializa m√°s tarde: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t.tv_nsec = resto;</font></font></i>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algo aqu√≠ est√° claramente confundido. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sobreexpresi√≥n</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bta_dm_co_ble_io_req</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... *p_auth_req = bte_appl_cfg.ble_auth_req | (bte_appl_cfg.ble_auth_req &amp; <span class="hljs-number"><span class="hljs-number">0x04</span></span>) | ((*p_auth_req) &amp; <span class="hljs-number"><span class="hljs-number">0x04</span></span>); .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia de PVS-Studio: V578 Se detect√≥ una operaci√≥n bit a bit extra√±a. </font><font style="vertical-align: inherit;">Considera verificarlo. </font><font style="vertical-align: inherit;">bta_dm_co.cc 259 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta expresi√≥n es redundante. </font><font style="vertical-align: inherit;">Si elimina la subexpresi√≥n </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(bte_appl_cfg.ble_auth_req &amp; 0x04)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , el resultado de la expresi√≥n no cambiar√°. </font><font style="vertical-align: inherit;">Quiz√°s hay alg√∫n error tipogr√°fico aqu√≠. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manejar la fuga</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> RSReflectionCpp::genEncodedBitCode() { FILE *pfin = fopen(mBitCodeFilePath.c_str(), <span class="hljs-string"><span class="hljs-string">"rb"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pfin == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"Error: could not read file %s\n"</span></span>, mBitCodeFilePath.c_str()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> read_length; mOut.indent() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"static const unsigned char __txt[] ="</span></span>; mOut.startBlock(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((read_length = fread(buf, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(buf), pfin)) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { mOut.indent(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; read_length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf2[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">snprintf</span></span>(buf2, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(buf2), <span class="hljs-string"><span class="hljs-string">"0x%02x,"</span></span>, buf[i]); mOut &lt;&lt; buf2; } mOut &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; } mOut.endBlock(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); mOut &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Advertencia de PVS-Studio: V773 CWE-401 La funci√≥n se cerr√≥ sin liberar el controlador 'pfin'. </font></font> Una fuga de recursos es posible.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">slang_rs_reflection_cpp.cpp 448 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El analizador clasific√≥ este error seg√∫n la Enumeraci√≥n de debilidad com√∫n como: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-401</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Liberaci√≥n incorrecta de memoria antes de eliminar la √∫ltima referencia ('Fuga de memoria'). </font><font style="vertical-align: inherit;">Sin embargo, ser√≠a m√°s correcto aqu√≠ emitir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-775</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Falta la publicaci√≥n del descriptor de archivo o el identificador despu√©s de la vigencia de la vida √∫til. </font><font style="vertical-align: inherit;">Instruir√© a mis colegas para que corrijan este defecto en PVS-Studio. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mango del pfin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no se libera </font><i><font style="vertical-align: inherit;">en</font></i><font style="vertical-align: inherit;"> ning√∫n lado. </font><font style="vertical-align: inherit;">Simplemente olvid√© llamar a la funci√≥n </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fclose</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> al final </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Un error desagradable que puede agotar r√°pidamente todo el suministro de descriptores disponibles, despu√©s de lo cual ser√° imposible abrir nuevos archivos.</font></font><br><br><h2>  Conclusi√≥n </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como puede ver, incluso en un proyecto tan conocido y probado como Android, el analizador PVS-Studio encuentra f√°cilmente muchos errores y vulnerabilidades potenciales. </font><font style="vertical-align: inherit;">Para resumir qu√© debilidades (vulnerabilidades potenciales) se encontraron:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CWE-14: Eliminaci√≥n del compilador de c√≥digo para borrar buffers </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CWE-20: Validaci√≥n de entrada incorrecta </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CWE-119: Restricci√≥n incorrecta de operaciones dentro de los l√≠mites de un b√∫fer de memoria </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CWE-190: Desbordamiento de enteros o envolvente </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CWE-198: Uso de orden de bytes incorrecto </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CWE-393: Devoluci√≥n del c√≥digo de estado incorrecto </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CWE-401: Liberaci√≥n incorrecta de memoria antes de eliminar la √∫ltima referencia ('Fuga de memoria') </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CWE-457: Uso de variable no inicializada </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CWE-462: Clave duplicada en lista asociativa </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CWE-480: uso de operador incorrecto </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CWE-484: Declaraci√≥n de interrupci√≥n omitida en el interruptor </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CWE-561: C√≥digo muerto </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CWE-562: Devoluci√≥n de direcci√≥n variable de pila </font></font></li><li> CWE-563: Assignment to Variable without Use </li><li> CWE-570: Expression is Always False </li><li> CWE-571: Expression is Always True </li><li> CWE-476: NULL Pointer Dereference </li><li> CWE-628: Function Call with Incorrectly Specified Arguments </li><li> CWE-665: Improper Initialization </li><li> CWE-670: Always-Incorrect Control Flow Implementation </li><li> CWE-682: Incorrect Calculation </li><li> CWE-688: Function Call With Incorrect Variable or Reference as Argument </li><li> CWE-690: Unchecked Return Value to NULL Pointer Dereference </li><li> CWE-691: Insufficient Control Flow Management </li><li> CWE-758: Reliance on Undefined, Unspecified, or Implementation-Defined Behavior </li><li> CWE-762: Mismatched Memory Management Routines </li><li> CWE-775: Missing Release of File Descriptor or Handle after Effective Lifetime </li><li> CWE-783: Operator Precedence Logic Error </li><li> CWE-824: Access of Uninitialized Pointer </li><li> CWE-834: Excessive Iteration </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En total, describ√≠ 490 vulnerabilidades potenciales en el art√≠culo. </font><font style="vertical-align: inherit;">De hecho, el analizador puede identificar m√°s de ellos, pero, como escrib√≠ anteriormente, no encontr√© la fuerza para estudiar el informe con m√°s cuidado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El tama√±o de la base de c√≥digo probada es de aproximadamente 2,168,000 l√≠neas de c√≥digo en C y C ++. </font><font style="vertical-align: inherit;">De estos, el 14,4% son comentarios. </font><font style="vertical-align: inherit;">En total, obtenemos alrededor de 1,855,000 l√≠neas de c√≥digo limpio. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, tenemos 490 CWE para 1,855,000 l√≠neas de c√≥digo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resulta que el analizador PVS-Studio puede detectar m√°s de 1 debilidad (vulnerabilidad potencial) por cada 4000 l√≠neas de c√≥digo en un proyecto de Android. </font><font style="vertical-align: inherit;">Buen resultado para un analizador de c√≥digo, me alegro.</font></font><br><br>  Gracias por su atencion!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les deseo a todos un c√≥digo sin c√≥digo y propongo hacer lo siguiente: </font></font><br><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Descargue</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PVS-Studio y verifique el borrador de trabajo.</font></font></li><li>  :      : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">     </a> . </li><li> ,        : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">twitter</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RSS</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">vk.com</a> . </li></ol><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br>  Si desea compartir este art√≠culo con una audiencia de habla inglesa, utilice el enlace a la traducci√≥n: Andrey Karpov. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">We Checked the Android Source Codes by PVS-Studio or Nothing is Perfect</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es418891/">https://habr.com/ru/post/es418891/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es418879/index.html">M√©todo de prueba de intercambios de cifrado y billeteras de cifrado</a></li>
<li><a href="../es418883/index.html">GitLab en NAS</a></li>
<li><a href="../es418885/index.html">Crispr puede acelerar los procesos naturales y cambiar la forma en que se cultivan los alimentos.</a></li>
<li><a href="../es418887/index.html">¬øQu√© tan r√°pido se est√° expandiendo el universo?</a></li>
<li><a href="../es418889/index.html">Gu√≠a de prueba manual de aplicaciones: beneficios, pasos y metodolog√≠as</a></li>
<li><a href="../es418895/index.html">Aprende inteligencia artificial para jugar un juego</a></li>
<li><a href="../es418897/index.html">CRDT: tipos de datos replicados sin conflictos</a></li>
<li><a href="../es418899/index.html">Primeras impresiones y acciones despu√©s de actualizar MySQL de la versi√≥n 5.7 a 8.0.11</a></li>
<li><a href="../es418901/index.html">Los rusos ganaron la mayor√≠a de las medallas de oro en la Olimpiada Europea de Inform√°tica eJOI 2018</a></li>
<li><a href="../es418903/index.html">Cient√≠ficos: no hay suficiente CO‚ÇÇ en Marte para calentar la atm√≥sfera. La explosi√≥n del poste no ayudar√°</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>