<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßîüèΩ üßïüèø ‚õàÔ∏è Generaci√≥n efectiva de n√∫meros en un intervalo dado üêÇ üë∞üèΩ üéÖüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La gran mayor√≠a de mis publicaciones sobre generaci√≥n de n√∫meros aleatorios se ocuparon principalmente de las propiedades de varios esquemas de genera...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Generaci√≥n efectiva de n√∫meros en un intervalo dado</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455702/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21b/913/a41/21b913a412f4fcae1d02afabc90b236c.svg" alt="imagen"></div><br>  La gran mayor√≠a de mis publicaciones sobre generaci√≥n de n√∫meros aleatorios se ocuparon principalmente de las propiedades de varios esquemas de generaci√≥n.  Esto puede resultar inesperado, pero el rendimiento del algoritmo de aleatorizaci√≥n puede depender no del esquema de generaci√≥n elegido, sino de otros factores.  En esta publicaci√≥n (que me inspir√≥ un excelente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo de Daniel Lemyr</a> ), examinaremos las principales razones de la disminuci√≥n del rendimiento de generaci√≥n de n√∫meros aleatorios, que a menudo superan el rendimiento del motor PRN. <br><br>  Imagina esta situaci√≥n: <br><br>  Como tarea, Juan y Sasha implementan el mismo algoritmo aleatorio en C ++, que se ejecutar√° en la misma computadora de la universidad y con un conjunto de datos.  Su c√≥digo es casi id√©ntico y solo difiere en la generaci√≥n de n√∫meros aleatorios.  Juan tiene prisa por sus lecciones de m√∫sica, as√≠ que simplemente eligi√≥ el torbellino de Mersenne.  Sasha, por otro lado, pas√≥ unas horas extra investigando.  Sasha realiz√≥ puntos de referencia de varios de los PRNG m√°s r√°pidos, que recientemente aprendi√≥ de las redes sociales, y eligi√≥ el m√°s r√°pido.  En la reuni√≥n, Sasha estaba impaciente por alardear y le pregunt√≥ a Juan: "¬øQu√© sistema PRNG usaste?" <br><br>  "Personalmente, acabo de tomar el v√≥rtice de Mersenne, est√° integrado en el lenguaje y parece funcionar bastante bien". <br><br>  "¬°Ja!", Respondi√≥ Sasha.  ‚Äú <code>jsf32</code> .  ¬°Es mucho m√°s r√°pido que el viejo y lento torbellino de Mersenne!  ¬°Mi programa se ejecuta en 3 minutos y 15 segundos! " <br><br>  "Hmm, no est√° mal, pero el m√≠o puede hacerlo en menos de un minuto", dice Juan y se encoge de hombros.  ‚ÄúBueno, entonces tengo que ir al concierto.  ¬øVendr√°s conmigo? <br><br>  "No", responde Sasha.  "Yo ... eh ... necesito mirar mi c√≥digo de nuevo". <br><br>  Esta inc√≥moda situaci√≥n ficticia <em>no</em> es particularmente ficticia;  Se basa en resultados reales.  Si su algoritmo aleatorio no funciona tan r√°pido como nos gustar√≠a, y el cuello de botella parece ser la generaci√≥n de n√∫meros aleatorios, entonces, curiosamente, ¬°el problema puede no estar en el generador de n√∫meros aleatorios! <br><a name="habracut"></a><br><h3>  Introducci√≥n: n√∫meros aleatorios en la pr√°ctica </h3><br>  La mayor√≠a de los generadores de n√∫meros aleatorios modernos de alta calidad crean palabras de m√°quina llenas de bits aleatorios, es decir, generalmente generan n√∫meros en el intervalo [0..2 <sup>32</sup> ) o [0..2 <sup>64</sup> ).  Pero en muchos casos de uso, los usuarios necesitan n√∫meros en un cierto intervalo; por ejemplo, para lanzar un dado o elegir una carta de juego aleatoria, se necesitan n√∫meros en peque√±os intervalos constantes.  Sin embargo, muchos algoritmos, desde la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mezcla</a> y el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">muestreo de yacimientos</a> hasta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">los √°rboles de b√∫squeda binarios aleatorios,</a> requieren n√∫meros tomados de otros intervalos. <br><br><h3>  M√©todos </h3><br>  Veremos muchos m√©todos diferentes.  Para simplificar la discusi√≥n, en lugar de generar n√∫meros en el intervalo [ <em>i</em> .. <em>j</em> ) o [ <em>i</em> .. <em>j</em> ], generaremos n√∫meros en el intervalo [0 .. <em>k</em> ).  Teniendo tal esquema, podemos, por ejemplo, generar n√∫meros en el intervalo [ <em>i</em> .. <em>j</em> ) estableciendo <em>k</em> = <em>j</em> - <em>i</em> , generando un n√∫mero en el intervalo [0 .. <em>k</em> ), y luego a√±adi√©ndole <em>i</em> . <br><br><h4>  Herramientas integradas de C ++ </h4><br>  Muchos idiomas tienen herramientas integradas para obtener un n√∫mero aleatorio en un intervalo espec√≠fico.  Por ejemplo, para eliminar una carta de un mazo con 52 cartas en lenguajes de script como Perl y Python, podemos escribir <code>int(rand(52))</code> y <code>random.randint(0,52)</code> .  [Nota  Usuario de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">CryptoPirate</a> : <i>Me parece un error aqu√≠, en Python randint (a, b) genera n√∫meros de a a b, incluido b.</i>  <i>Y como hay 52 cartas en el mazo y la primera es "0", deber√≠a ser random.randint (0,51)</i> .] En C ++, podemos usar <code>uniform_int_distribution</code> misma <code>uniform_int_distribution</code> . <br><br>  El c√≥digo C ++ para implementar este enfoque es simple: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::uniform_int_distribution&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>&gt; dist(<span class="hljs-number"><span class="hljs-number">0</span></span>, range<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dist(rng); }</code> </pre> <br>  Por lo general, una de las t√©cnicas descritas a continuaci√≥n se usa en las herramientas integradas, pero la mayor√≠a de los usuarios simplemente usan estas herramientas, sin pensar en lo que est√° sucediendo "bajo el cap√≥", creyendo que estas herramientas est√°n dise√±adas correctamente y son bastante efectivas.  En C ++, las herramientas integradas son m√°s complejas porque deber√≠an poder trabajar con motores de generaci√≥n bastante arbitrarios: un generador que produce valores en el rango de -3 a 17 puede ser bastante v√°lido y puede usarse con <code>std::uniform_int_distribution</code> para crear n√∫meros en cualquier intervalo, por ejemplo [0..1000).  Es decir, las herramientas integradas de C ++ son demasiado complicadas para la mayor√≠a de los casos en los que se usan. <br><br><h4>  El resto cl√°sico de la divisi√≥n (sesgado) </h4><br>  Pasemos de un enfoque demasiado simplificado a uno demasiado simplista. <br><br>  Cuando estudi√© programaci√≥n, generamos n√∫meros en el intervalo (por ejemplo, para seleccionar una carta en un mazo de 52 cartas) usando el operador restante.  Para obtener el n√∫mero en el intervalo [0..52), escribimos <code>rand() % 52</code> . <br><br>  En C ++, este enfoque se puede implementar de la siguiente manera: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rng() % range; }</code> </pre> <br>  A pesar de la simplicidad de este enfoque, demuestra la raz√≥n por la que obtener n√∫meros en el intervalo correcto suele ser una tarea lenta: requiere divisi√≥n (para calcular el resto obtenido por el operador <code>%</code> ).  La divisi√≥n suele ser al menos un orden de magnitud m√°s lenta que otras operaciones aritm√©ticas, por lo que una sola operaci√≥n aritm√©tica lleva m√°s tiempo que todo el trabajo realizado por un PRNG r√°pido. <br><br>  Pero adem√°s de la baja velocidad, tambi√©n est√° <em>sesgada</em> .  Para comprender por qu√© <code>rand() % 52</code> devuelve n√∫meros sesgados, suponga que <code>rand()</code> crea n√∫meros en el intervalo [0..2 <sup>32</sup> ), y tenga en cuenta que 52 no divide 2 <sup>32 por</sup> completo, lo divide 82 595 524 veces con el resto 48. Es decir, si usamos <code>rand() % 52</code> , tendremos 82 595 525 formas de seleccionar las primeras 48 cartas del mazo y solo 82 595 524 formas de seleccionar las √∫ltimas cuatro cartas.  En otras palabras, hay un sesgo de 0.00000121% contra estas √∫ltimas cuatro cartas (¬°quiz√°s sean reyes!).  Cuando era estudiante y escrib√≠a la tarea de tirar dados o dibujar cartas, nadie se molestaba con distorsiones tan peque√±as, pero con un aumento en el intervalo, la distorsi√≥n crece linealmente.  Para un PRNG de 32 bits, un intervalo limitado de menos de 2 <sup>24</sup> tiene un sesgo de menos del 0,5%, pero por encima de 2 <sup>31 un</sup> sesgo del 50%: algunos n√∫meros regresar√°n el doble de veces que otros. <br><br>  En este art√≠culo, consideraremos principalmente t√©cnicas que usan estrategias para eliminar un error sistem√°tico, pero probablemente valga la pena decir que para un PRNG de 64 bits, el valor de sesgo en las aplicaciones normales probablemente sea insignificante. <br><br>  Otro problema puede ser que algunos generadores tienen bits bajos d√©biles.  Por ejemplo, las familias GPRS Xoroshiro + y Xoshiro + tienen bits bajos que no pasan las pruebas estad√≠sticas.  Cuando ejecutamos <code>% 52</code> (porque 52 es par), pasamos el bit de orden inferior directamente a la salida. <br><br><h4>  Multiplicar n√∫meros de coma flotante (sesgados) </h4><br>  Otra t√©cnica com√∫n es el uso de un PRNG que genera n√∫meros de coma flotante en el intervalo [0..1) con la conversi√≥n posterior de estos n√∫meros al intervalo deseado.  Este enfoque se usa en Perl, se <a href="">recomienda</a> usar <code>int(rand(10))</code> para generar un n√∫mero entero en el intervalo [0..10) generando un n√∫mero de punto flotante seguido de redondeo hacia abajo. <br><br>  En C ++, este enfoque se escribe as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bounded_rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">rng_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; rng, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> range)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> zeroone = <span class="hljs-number"><span class="hljs-number">0x1</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>p<span class="hljs-number"><span class="hljs-number">-32</span></span> * rng(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> range * zeroone; }</code> </pre> <br>  (Tenga en cuenta que <code>0x1.0p-32</code> es una constante binaria de coma flotante para 2 <sup>-32</sup> , que usamos para convertir un entero aleatorio en el intervalo [0..2 <sup>32</sup> ) para duplicar en el intervalo de la unidad;  en cambio, podemos realizar dicha conversi√≥n usando <code>ldexp(rng(), -32)</code> , pero cuando compar√© este enfoque, result√≥ ser mucho m√°s lento). <br><br>  Este enfoque es tan sesgado como el resto cl√°sico de la divisi√≥n, pero el sesgo parece diferente.  Por ejemplo, si tuvi√©ramos que seleccionar n√∫meros en el intervalo [0..52), los n√∫meros 0, 13, 26 y 39 ocurrir√≠an una vez con menos frecuencia que otros. <br><br>  Esta versi√≥n, cuando se generaliza a 64 bits, es a√∫n m√°s desagradable, ya que requiere un tipo de coma flotante cuya mantisa es de al menos 64 bits.  En m√°quinas x86 con Linux y macOS, podemos usar el <code>long double</code> para aprovechar la mayor precisi√≥n de los n√∫meros de coma flotante x86 que tienen una mantisa de 64 bits, pero el <code>long double</code> no se transfiere universalmente a todos los sistemas; en algunos sistemas, el <code>long double</code> equivalente al <code>double</code> . <br><br>  Hay un buen lado: este enfoque es m√°s r√°pido que las soluciones residuales para PRNG con bits bajos d√©biles. <br><br><h4>  Multiplicaci√≥n de enteros (sesgada) </h4><br>  El m√©todo de multiplicaci√≥n se puede adaptar a la aritm√©tica de punto fijo en lugar de flotante.  De hecho, simplemente multiplicamos constantemente por 2 <sup>32</sup> , <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> x = rng(); <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(x) * <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(range); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>; }</code> </pre> <br>  Puede parecer que esta versi√≥n requiere aritm√©tica de 64 bits, en los procesadores x86 un buen compilador compilar√° este c√≥digo en una instrucci√≥n <code>mult</code> 32 bits (que nos da dos valores de salida de 32 bits, uno de los cuales es el valor de retorno).  Se puede esperar que esta versi√≥n sea r√°pida, pero est√° sesgada exactamente como el m√©todo de multiplicar n√∫meros de coma flotante. <br><br><h4>  Divisi√≥n de ca√≠da (sin sesgo) </h4><br>  Podemos modificar el esquema de multiplicaci√≥n de coma flotante en un esquema basado en divisi√≥n.  En lugar de multiplicar <code>x * range / 2**32</code> calculamos <code>x / (2**32 / range)</code> .  Dado que estamos trabajando con aritm√©tica de enteros, el redondeo en esta versi√≥n se realizar√° de manera diferente y, a veces, generar√° valores fuera del intervalo deseado.  Si descartamos estos valores (por ejemplo, nos deshacemos de ellos y generamos nuevos valores), entonces como resultado obtenemos una t√©cnica sin distorsiones. <br><br>  Por ejemplo, en el caso de extraer una tarjeta usando un PRNG de 32 bits, podemos generar un n√∫mero de 32 bits y dividirlo por 2 32/52 = 82 595 524 para seleccionar una tarjeta.  Esta t√©cnica funciona si el valor aleatorio del PRNG de 32 bits es menor que 52 √ó 82595524 = 2 32/32 - 48. Si el valor aleatorio del PRNG es uno de los √∫ltimos 48 valores de la parte superior del intervalo del generador, entonces debe descartarlo y buscar otro. <br><br>  Nuestro c√≥digo para esta versi√≥n usa un truco para dividir 2 <sup>32</sup> por <code>range</code> sin usar matem√°ticas de 64 bits.  Para el c√°lculo directo de <code>2**32 / range</code> necesitamos representar el n√∫mero 2 <sup>32</sup> , que es demasiado grande (¬°por uno!) Para representar como un entero de 32 bits.  En cambio, tenemos en cuenta que para los enteros sin signo, el <code>range</code> operaci√≥n de negaci√≥n unaria calcula un valor positivo de 2 <sup>32</sup> - <code>range</code> ;  dividiendo este valor por <code>range</code> , obtenemos una respuesta menor a <code>2**32 / range</code> . <br><br>  Por lo tanto, el c√≥digo C ++ para generar n√∫meros usando divisi√≥n y soltar se ve as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-comment"><span class="hljs-comment">// calculates divisor = 2**32 / range uint32_t divisor = ((-range) / range) + 1; if (divisor == 0) // overflow, it's really 2**32 return 0; for (;;) { uint32_t val = rng() / divisor; if (val &lt; range) return val; } }</span></span></code> </pre> <br>  Por supuesto, este enfoque requiere dos operaciones lentas basadas en la divisi√≥n, que generalmente son m√°s lentas que otras operaciones aritm√©ticas, por lo que no debe esperar que sea r√°pido. <br><br><h4>  El resto de la divisi√≥n (doble) sin distorsiones - t√©cnica OpenBSD </h4><br>  Tambi√©n podemos adoptar el enfoque de ca√≠da para eliminar la distorsi√≥n en el m√©todo cl√°sico de resto de divisi√≥n.  En el ejemplo con naipes, nuevamente necesitamos soltar 48 valores.  En esta versi√≥n, en lugar de descartar los <em>√∫ltimos</em> 48 valores, (equivalentemente) descartamos los <em>primeros</em> 48 valores. <br><br>  Aqu√≠ est√° la implementaci√≥n de este enfoque en C ++: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-comment"><span class="hljs-comment">// calculates 2**32 % range uint32_t t = (-range) % range; for (;;) { uint32_t r = rng(); if (r &gt;= t) return r % range; } }</span></span></code> </pre> <br>  Esta t√©cnica elimina el sesgo, pero requiere dos operaciones de divisi√≥n que requieren mucho tiempo con el resto de cada valor de salida (y es posible que necesite un generador interno para crear varios n√∫meros).  Por lo tanto, se debe esperar que el m√©todo sea aproximadamente dos veces m√°s lento que el enfoque sesgado cl√°sico. <br><br>  <a href=""><code> arc4random_uniform</code> OpenBSD</a> (que tambi√©n se usa en OS X e iOS) usa esta estrategia. <br><br><h4>  Resto de divisi√≥n (simple) sin sesgo - metodolog√≠a Java </h4><br>  Java usa un enfoque diferente para generar un n√∫mero en un intervalo que usa solo una operaci√≥n de divisi√≥n restante, con la excepci√≥n de casos bastante raros de descartar el resultado.  C√≥digo: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bounded_rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rng_t&amp; rng, uint32_t range)</span></span></span><span class="hljs-function"> </span></span>{ uint32_t x, r; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { x = rng(); r = x % range; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (x - r &gt; (-range)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; }</code> </pre> <br>  Para entender por qu√© funciona esta opci√≥n, debe pensar un poco.  A diferencia de la versi√≥n anterior basada en residuos, que elimina el sesgo al eliminar parte de los valores m√°s bajos del motor de generaci√≥n interna, esta versi√≥n filtra los valores de la parte superior del intervalo del motor. <br><br><h4>  Multiplicaci√≥n de enteros sesgados - m√©todo de Lemira </h4><br>  De la misma manera que eliminamos el sesgo del resto del m√©todo de divisi√≥n, podemos eliminar el sesgo de la t√©cnica de multiplicaci√≥n de enteros.  Esta t√©cnica fue inventada por Lemyr. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> t = (-range) % range; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> x = rng(); <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(x) * <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(range); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> l = <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>(m); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (l &lt; t); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>; }</code> </pre> <br><h4>  Soltar m√°scara de bits (sin sesgo): t√©cnica de Apple </h4><br>  En nuestro √∫ltimo enfoque, la divisi√≥n y las operaciones restantes se eliminan por completo.  En cambio, utiliza una operaci√≥n de enmascaramiento simple para obtener un n√∫mero aleatorio en el intervalo [0..2 <sup><em>k</em></sup> ), donde <em>k</em> es el valor m√°s peque√±o, de modo que 2 <sup><em>k es</em></sup> mayor que el intervalo.  Si el valor es demasiado grande para nuestro intervalo, lo descartamos e intentamos obtener otro.  El c√≥digo se muestra a continuaci√≥n: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> mask = ~<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); --range; mask &gt;&gt;= __builtin_clz(range|<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { x = rng() &amp; mask; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (x &gt; range); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; }</code> </pre> <br>  Apple adopt√≥ este enfoque cuando (en el lanzamiento de macOS Sierra) realiz√≥ <a href="">su propia revisi√≥n</a> del c√≥digo <code>arc4random_uniform</code> . <br><br><h3>  T√©cnicas b√°sicas de evaluaci√≥n comparativa </h3><br>  Ahora tenemos varios enfoques que pueden evaluarse.  Desafortunadamente, cuando nos preocupan los costos de una operaci√≥n de divisi√≥n √∫nica, la evaluaci√≥n comparativa se convierte en algo no trivial.  Ning√∫n punto de referencia puede tener en cuenta todos los factores que afectan el campo de aplicaci√≥n, y no hay garant√≠a de que la mejor opci√≥n para su aplicaci√≥n sea la mejor para la m√≠a. <br><br>  Utilizamos tres puntos de referencia y probamos las t√©cnicas con muchos PRNG diferentes. <br><br><h4>  Benchmark Large-Shuffle </h4><br>  Probablemente el punto de referencia m√°s obvio es la mezcla.  En este punto de referencia, simulamos realizar mezclas a gran escala.  Para ordenar una matriz de tama√±o <em>N,</em> debemos generar n√∫meros en los intervalos [0 .. <em>N</em> ), [0 .. ( <em>N</em> -1)), ..., [0..1).  En este punto de referencia, asumiremos que <em>N</em> es el n√∫mero m√°ximo posible (para <code>uint32_t</code> es 2 <sup>32</sup> -1).  C√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0xffffffff</span></span>; i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; --i) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bval = bounded_rand(rng, i); assert(bval &lt; i); sum += bval; }</code> </pre> <br>  Tenga en cuenta que "usamos" cada n√∫mero agreg√°ndolo a la <code>sum</code> (para que no sea desechado por la optimizaci√≥n), pero no realizamos ninguna mezcla para centrarnos en la generaci√≥n de n√∫meros. <br><br>  Para probar la generaci√≥n de 64 bits, tenemos una prueba similar, pero no ser√° pr√°ctico realizar una prueba que corresponda a mezclar una matriz de 2 <sup>64-1</sup> en tama√±o (porque tomar√° muchos miles de a√±os completar este punto de referencia m√°s grande).  En cambio, cruzamos todo el intervalo de 64 bits, pero generamos el mismo n√∫mero de valores de salida que en la prueba de 32 bits.  C√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0xffffffff</span></span>; i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; --i) { <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> bound = (<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(i)&lt;&lt;<span class="hljs-number"><span class="hljs-number">32</span></span>) | i; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> bval = bounded_rand(rng, bound ); assert(bval &lt; bound); sum += bval; }</code> </pre> <br><h5>  Resultados del v√≥rtice de Mersenne </h5><br>  Los resultados que se muestran a continuaci√≥n demuestran el rendimiento de este punto de referencia para cada uno de los m√©todos que examinamos cuando usamos el v√≥rtice de Mersenne y probamos en el c√≥digo de 32 bits (usando <code>std::mt19937</code> de <code>libstdc++</code> ) y un c√≥digo similar de 64 bits (usando <code>std:mt19937_64</code> de <code>libstdc++</code> )  Los resultados son la media geom√©trica de 15 corridas con diferentes valores de semillas, que luego se normaliza para que el m√©todo cl√°sico de resto de divisi√≥n tenga un solo tiempo de corrida. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b9f/3eb/53f/b9f3eb53f894a14ac2698f44090b23a6.svg"></div><br>  Puede parecer que tenemos respuestas claras sobre el rendimiento: parece que puede construir t√©cnicas para su perfecci√≥n y preguntarse en qu√© estaban pensando los desarrolladores de <code>libstdc++</code> cuando escribieron una implementaci√≥n tan terrible para n√∫meros de 32 bits.  Pero, como suele ser el caso con la evaluaci√≥n comparativa, la situaci√≥n es m√°s complicada de lo que parece a partir de estos resultados.  En primer lugar, existe el riesgo de que los resultados puedan ser espec√≠ficos del v√≥rtice de Mersenne, por lo que ampliaremos los numerosos PRNG probados.  En segundo lugar, puede haber un problema sutil con el punto de referencia mismo.  Primero tratemos con la primera pregunta. <br><br><h5>  Resultados de diferentes PRNG </h5><br>  Probamos <code>arc4_rand32</code> 32 bits con <code>arc4_rand32</code> , <code>chacha8r</code> , <code>gjrand32</code> , <code>jsf32</code> , <code>mt19937</code> , <code>pcg32</code> , <code>pcg32_fast</code> , <code>sfc32</code> , <code>splitmix32</code> , <code>xoroshiro64+</code> , <code>xorshift*64/32</code> <code>xoshiro128+</code> , <code>xoshiro128+</code> y <code>xoshiro128**</code> , y <code>gjrand64</code> 64 bits <code>jsf64</code> , <code>mcg128</code> , <code>mcg128_fast</code> , <code>mt19937_64</code> , <code>pcg64</code> , <code>pcg64_fast</code> , <code>sfc64</code> , <code>splitmix64</code> , <code>xoroshiro128+</code> , <code>xorshift*128/64</code> <code>xoshiro256+</code> , <code>xoshiro256+</code> y <code>xoshiro256*</code> .  Estos kits nos dar√°n algunos PRN lentos y muchos muy r√°pidos. <br><br>  Aqu√≠ est√°n los resultados: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2dc/8c8/f1a/2dc8c8f1af9aa517a92260e7cbd3a73e.svg"></div><br>  Podemos ver las diferencias clave de los resultados con el v√≥rtice de Mersenne.  Los PRNG m√°s r√°pidos desplazan el equilibrio hacia el c√≥digo delimitador y, por lo tanto, la diferencia entre los diferentes enfoques se vuelve m√°s pronunciada, especialmente en el caso de los PRNR de 64 bits.  Con un conjunto m√°s amplio de <code>libstc++</code> implementaci√≥n de <code>libstc++</code> deja de parecer tan terrible. <br><br><h5>  Conclusiones </h5><br>  En este punto de referencia por un margen significativo, el enfoque basado en la multiplicaci√≥n con sesgo gana en velocidad.  Hay muchas situaciones en las que los l√≠mites ser√°n peque√±os en relaci√≥n con el tama√±o del PRNG, y el rendimiento es absolutamente cr√≠tico.  En tales situaciones, es poco probable que un ligero sesgo tenga un efecto notable, pero la velocidad PRNG s√≠ lo tendr√°.  Un ejemplo de ello es Quicksort con un punto de referencia aleatorio.  De los m√©todos sesgados, la t√©cnica de m√°scara de bits parece prometedora. <br><br>  Pero antes de llegar a conclusiones serias, debemos se√±alar el gran problema de este punto de referencia: la mayor parte del tiempo se gasta en l√≠mites muy altos, lo que probablemente da una importancia excesiva a los grandes intervalos.  Por lo tanto, debemos pasar al segundo punto de referencia. <br><br><h4>  Benchmark Small-Shuffle </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este punto de referencia es similar al anterior, pero realiza mucho menos "mezcla de matriz" (m√∫ltiple). </font><font style="vertical-align: inherit;">C√≥digo:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">0xffff</span></span>; ++j) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0xffff</span></span>; i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; --i) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bval = bounded_rand(rng, i); assert(bval &lt; i); sum += bval; } }</code> </pre> <br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Resultados del v√≥rtice de Mersenne </font></font></h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c5/d3b/4bd/6c5d3b4bdb5f2e45cd805a051d79ab9a.svg"></div><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Resultados de diferentes PRNG </font></font></h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45a/9ae/8c0/45a9ae8c040cb4d297fe82f00fa06e3c.svg"></div><br><h5>  Conclusiones </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Este punto de referencia evita demasiado √©nfasis en los l√≠mites grandes y refleja con mayor precisi√≥n los casos de uso del mundo real, pero ahora descarta por completo los l√≠mites grandes. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Punto de referencia para todos los intervalos </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este punto de referencia tiene como objetivo evitar las desventajas de los dos anteriores; </font><font style="vertical-align: inherit;">realiza pruebas en cada tama√±o de la potencia de dos para que cada tama√±o est√© presente, pero su influencia no se sobreestima.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bit = <span class="hljs-number"><span class="hljs-number">1</span></span>; bit != <span class="hljs-number"><span class="hljs-number">0</span></span>; bit &lt;&lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">0x1000000</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bound = bit | (i &amp; (bit - <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bval = bounded_rand(rng, bound); assert(bval &lt; bound); sum += bval; } }</code> </pre> <br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Resultados del v√≥rtice de Mersenne </font></font></h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f34/65c/447/f3465c447f9b19b430bb43533a655c2f.svg"></div><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Resultados de diferentes PRNG </font></font></h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64b/c58/2a2/64bc582a2fde24fd0faedbeaabb9f64c.svg"></div><br><h5>  Conclusiones </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muchos de nuestros hallazgos permanecen sin cambios. </font><font style="vertical-align: inherit;">El m√©todo de inclinaci√≥n es r√°pido si podemos soportar el error, y el esquema de m√°scara de bits parece ser una buena opci√≥n promedio. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podr√≠amos terminar esto si no quisi√©ramos volver atr√°s, echar un vistazo cr√≠tico a nuestro c√≥digo y realizar cambios en √©l.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hacer mejoras </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasta este punto, todos los m√©todos de eliminaci√≥n de sesgo requer√≠an el uso de una operaci√≥n adicional de divisi√≥n de divisi√≥n, raz√≥n por la cual se realizan mucho m√°s lentamente que los m√©todos de sesgo. </font><font style="vertical-align: inherit;">Ser√≠a √∫til si pudi√©ramos reducir esta ventaja.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ca√≠da basada en el umbral m√°s r√°pido </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algunos de nuestros algoritmos tienen c√≥digo que utiliza un valor umbral, por ejemplo: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-comment"><span class="hljs-comment">// calculates 2**32 % range uint32_t t = (-range) % range; for (;;) { uint32_t r = rng(); if (r &gt;= t) return r % range; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando es </font></font><code>range</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peque√±o en comparaci√≥n con el intervalo de salida PRNG, la mayor√≠a de las veces el n√∫mero ser√° </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mucho mayor que el</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> umbral. </font><font style="vertical-align: inherit;">Es decir, si podemos agregar una estimaci√≥n preliminar del umbral, que puede ser un poco m√°s, ahorraremos en la costosa operaci√≥n de tomar el resto de la divisi√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El siguiente c√≥digo maneja esta tarea:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> r = rng(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r &lt; range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> t = (-range) % range; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (r &lt; t) r = rng(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r % range; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este cambio puede aplicarse tanto a "Mod doble sin distorsiones" (ver arriba) como a "multiplicaci√≥n entera sin distorsiones". </font><font style="vertical-align: inherit;">La idea fue inventada por Lemir, quien la aplic√≥ al segundo m√©todo (pero no al primero).</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Resultados comparativos de gran tama√±o aleatorio </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta optimizaci√≥n conduce a una mejora significativa en los resultados del benchmark de 64 bits (en el que el mod es a√∫n m√°s lento), pero de hecho degrada ligeramente el rendimiento en el benchmark de 32 bits. </font><font style="vertical-align: inherit;">A pesar de las mejoras, el m√©todo de m√°scara de bits a√∫n gana.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb4/61d/b52/bb461db52be4a7d983dd7f97844179c0.svg"></div><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Resultados de referencia compactos peque√±os </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por otro lado, este cambio acelera significativamente el punto de referencia de shuffle peque√±o tanto para el m√©todo de multiplicaci√≥n de enteros como para el m√©todo del doble resto de divisi√≥n. </font><font style="vertical-align: inherit;">En ambos casos, su rendimiento se acerca m√°s a los resultados de las opciones sin distorsiones. </font><font style="vertical-align: inherit;">El rendimiento del m√©todo de doble residuo (OpenBSD) ahora es casi igual al rendimiento del m√©todo de un solo residuo (Java).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f07/2bd/fe2/f072bdfe2660cf0f8789b124a8f02646.svg"></div><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Resultados de referencia para todos los intervalos </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vemos una mejora similar en el punto de referencia para todos los intervalos. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/219/b1d/add/219b1daddfa6a55a2cb485b3ae774016.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parece que podemos anunciar un nuevo ganador universal: un m√©todo optimizado para multiplicar enteros Lemire sin sesgar. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Divisi√≥n resto optimizaci√≥n </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T√≠picamente, un c√°lculo </font></font><code>a % b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">requiere divisi√≥n, pero en situaciones donde el </font></font><code>a &lt; b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">resultado es simple </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y no se requiere divisi√≥n. </font><font style="vertical-align: inherit;">Y cuando </font></font><code>a/2 &lt; b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, el resultado es simple </font></font><code>a - b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Por lo tanto, en lugar de computar</font></font><br><br><pre> <code class="cpp hljs">a %= b;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> podemos cumplir </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt;= b) { a -= b; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt;= b) a %= b; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El costo de dividir es tan significativo que aumentar el costo de este c√≥digo m√°s complejo puede justificarse ahorrando tiempo debido a la falta de divisi√≥n. </font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Resultados comparativos de gran tama√±o aleatorio </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregar esta optimizaci√≥n mejora en gran medida los resultados del punto de referencia de reproducci√≥n aleatoria grande. </font><font style="vertical-align: inherit;">Esto es nuevamente m√°s notable en el c√≥digo de 64 bits, donde la operaci√≥n de tomar el resto es m√°s costosa. </font><font style="vertical-align: inherit;">El m√©todo de doble residuo (estilo OpenBSD) muestra versiones con optimizaciones para una sola operaci√≥n restante y para ambas.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c56/e1a/669/c56e1a669836477e46f870bd1bc7a6c9.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En este punto de referencia, la m√°scara de bits sigue siendo la ganadora, pero el l√≠mite entre esta y el enfoque de Lemira se ha reducido significativamente. </font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Resultados de referencia compactos peque√±os </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregar esta optimizaci√≥n no aumenta el rendimiento del punto de referencia de reproducci√≥n aleatoria peque√±a, por lo que la pregunta sigue siendo solo si agrega costos significativos. </font><font style="vertical-align: inherit;">En algunos casos, no; en otros, los costos aumentan ligeramente.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fa/4db/b65/6fa4dbb65b9a3f6c6f9e8ba4f7b455db.svg"></div><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Resultados de referencia para todos los intervalos </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En el punto de referencia para todos los intervalos, los cambios tambi√©n son peque√±os. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0e/ae7/758/e0eae77583cc457a9e923540ad954257.svg"></div><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bonificaci√≥n: resultados de comparaci√≥n de PRSP </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La raz√≥n principal para utilizar una gran cantidad de PRNG para probar esquemas num√©ricos a intervalos fue evitar la distorsi√≥n accidental de los resultados debido a las peculiaridades de la operaci√≥n de los esquemas PRNG individuales. </font><font style="vertical-align: inherit;">Pero podemos usar los mismos resultados de las pruebas internas para comparar los esquemas de generaci√≥n en s√≠.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PRNG con salida de 32 bits </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El siguiente gr√°fico muestra el rendimiento de diferentes esquemas de generaci√≥n de 32 bits, promediados para todos los m√©todos y quince ejecuciones, normalizados para el rendimiento del v√≥rtice Mersenne de 32 bits: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21b/913/a41/21b913a412f4fcae1d02afabc90b236c.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por un lado, me alegra ver que </font></font><code>pcg32_fast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es realmente r√°pido: fue derrotado solo por una versi√≥n peque√±a de Xoroshiro (que no pasa las pruebas estad√≠sticas). </font><font style="vertical-align: inherit;">Pero esto tambi√©n muestra por qu√© rara vez me molesto por el rendimiento de los PRSP modernos de alto rendimiento de prop√≥sito general: la diferencia entre los diferentes m√©todos es muy insignificante. </font><font style="vertical-align: inherit;">En particular, los cuatro circuitos m√°s r√°pidos difieren en rendimiento en menos del 5%, y creo que esto es simplemente causado por el "ruido".</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PRNG con la salida de n√∫meros de 64 bits </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El gr√°fico muestra el rendimiento de varios esquemas de generaci√≥n de 64 bits promediados entre todas las t√©cnicas y quince ejecuciones normalizadas para el rendimiento del v√≥rtice Mersenne de 32 bits. Puede parecer extra√±o que la normalizaci√≥n se realice utilizando el v√≥rtice Mersenne de 32 bits, pero esto nos permite ver los costos adicionales del uso de la generaci√≥n de 64 bits en los casos en que la generaci√≥n de 32 bits es suficiente.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/928/16c/b24/92816cb249e7f76c4ed4e11c65f67475.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estos resultados confirman que es </font></font><code>mcg128_fast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">incre√≠blemente r√°pido, pero las √∫ltimas cuatro t√©cnicas nuevamente difieren solo en un 5%, por lo que es dif√≠cil elegir entre los m√©todos m√°s r√°pidos. </font></font><code>pcg64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>pcg64_fast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">debe ser m√°s lento </font></font><code>mcg128_fast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, porque sus generadores b√°sicos son generadores congruentes lineales de 128 bits (LCG) y generadores congruentes multiplicativos de 128 bits (MCG, MCG). A pesar de que no son las t√©cnicas m√°s r√°pidas en este conjunto, siguen </font></font><code>pcg64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">siendo un 20% m√°s r√°pidas que el v√≥rtice Mersenne de 64 bits. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero quiz√°s lo m√°s importante, estos resultados tambi√©n muestran que si no necesita una salida de 64 bits, un PRNG de 64 bits suele ser m√°s lento que uno de 32 bits.</font></font><br><br><h3>  Conclusiones </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desde nuestros puntos de referencia, podemos ver que la transici√≥n de los PRNG utilizados de manera est√°ndar (por ejemplo, el v√≥rtice Mersenne de 32 bits) a PRNP m√°s r√°pidos redujo el tiempo de ejecuci√≥n de los puntos de referencia en un 45%. </font><font style="vertical-align: inherit;">Pero la transici√≥n del m√©todo est√°ndar de encontrar el n√∫mero en el intervalo a nuestro m√©todo m√°s r√°pido nos permiti√≥ reducir el tiempo de referencia en aproximadamente un 66%; </font><font style="vertical-align: inherit;">en otras palabras, hasta un tercio del tiempo original. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El m√©todo m√°s r√°pido (sin distorsiones) es el m√©todo Lemira (con mi optimizaci√≥n adicional). </font><font style="vertical-align: inherit;">Aqu√≠ esta:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> x = rng(); <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(x) * <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(range); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> l = <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>(m); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (l &lt; range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> t = -range; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t &gt;= range) { t -= range; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t &gt;= range) t %= range; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (l &lt; t) { x = rng(); m = <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(x) * <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(range); l = <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>(m); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El uso del m√©todo Lemira mejorar√° el rendimiento de la mayor√≠a de los algoritmos aleatorios m√°s que pasar de un motor de generaci√≥n r√°pida a uno m√°s r√°pido. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ap√©ndices: Notas de prueba </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El c√≥digo de todas las pruebas se publica en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . En total, prob√© 23 m√©todos para </font></font><code>bounded_rand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usar 26 PRN diferentes (13 PRN de 32 bits y 13 de 64 bits), en dos compiladores (GCC 8 y LLVM 6), que me dieron 26 * 23 * 2 = 1196 archivos ejecutables, cada uno de los cuales se realiz√≥ con las mismas 15 semillas, lo que da 1196 * 15 = 17,940 ejecuciones de prueba √∫nicas, en cada una de las cuales se combinan tres puntos de referencia. B√°sicamente, realic√© pruebas en una m√°quina de 48 n√∫cleos con cuatro procesadores Xeon E7-4830v3 de 2.1 GHz. Realizar un conjunto completo de pruebas tom√≥ un poco menos de un mes de tiempo de procesador. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al final, volvemos a la situaci√≥n desde la introducci√≥n del art√≠culo. Imagina que Sasha usaba </font></font><code>jsf32.STD-libc++</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y Juan ...</font></font><code>mt19937.BIASED_FP_MULT_SCALE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En el punto de referencia 3, este √∫ltimo lleva un 69,6% menos de tiempo. </font><font style="vertical-align: inherit;">Es decir, el tiempo de esta situaci√≥n ficticia se basa en datos de la realidad.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/455702/">https://habr.com/ru/post/455702/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../455692/index.html">ASZP: el restyling o el teatro comienzan con una percha</a></li>
<li><a href="../455694/index.html">Arquitectura de facturaci√≥n de la pr√≥xima generaci√≥n: transici√≥n a Tarantool</a></li>
<li><a href="../455696/index.html">El estado electr√≥nico del futuro. Parte 2</a></li>
<li><a href="../455698/index.html">El libro "C√≥mo funciona JavaScript"</a></li>
<li><a href="../455700/index.html">4 trucos que nos ayudaron a optimizar la interfaz</a></li>
<li><a href="../455710/index.html">¬øPor qu√© en Leroy Merlin necesitamos nuestro propio departamento de desarrollo ruso para 200 personas?</a></li>
<li><a href="../455714/index.html">Exporte autom√°ticamente Google Forms a Notion usando IFTTT y Django</a></li>
<li><a href="../455716/index.html">15 mejores pr√°cticas para implementar software de inteligencia empresarial</a></li>
<li><a href="../455720/index.html">C√≥mo construimos la interfaz de usuario para sistemas publicitarios</a></li>
<li><a href="../455722/index.html">Python consume mucha memoria o ¬øc√≥mo reducir el tama√±o de los objetos?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>