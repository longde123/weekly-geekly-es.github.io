<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§µüèª üëåüèª üñäÔ∏è Chat distribu√© sur Node.JS et Redis üöΩ üò¥ üêÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Une petite question / r√©ponse: 


 √Ä qui est-il destin√©? Les gens qui ont peu ou pas d'exp√©rience avec les syst√®mes distribu√©s et qui souhaitent voir ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Chat distribu√© sur Node.JS et Redis</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440546/"><p><img src="https://cs4.pikabu.ru/post_img/2015/10/04/5/1443945163_2102700146.jpg" alt="Le r√©sultat est une image de plaisanterie pour laver &quot;pigeon mail&quot;"></p><br><p>  Une petite question / r√©ponse: </p><br><p> <em>√Ä qui est-il destin√©?</em>  Les gens qui ont peu ou pas d'exp√©rience avec les syst√®mes distribu√©s et qui souhaitent voir comment ils peuvent √™tre construits, quels mod√®les et solutions existent. </p><br><p>  <em>Pourquoi √ßa?</em>  Lui-m√™me s'est int√©ress√© √† quoi et comment.  J'ai r√©cup√©r√© des informations de diff√©rentes sources, j'ai d√©cid√© de les publier sous une forme concentr√©e, car √† un moment j'aimerais moi-m√™me voir un tel travail.  En fait, ceci est une d√©claration textuelle de mes lancers et pens√©es personnels.  En outre, il y aura certainement de nombreuses corrections dans les commentaires de personnes bien inform√©es, et c'est en partie le but d'√©crire tout cela sous la forme d'un article. </p><br><h2 id="postanovka-zadachi">  √ânonc√© du probl√®me </h2><br><p>  Comment faire un chat?  Cela devrait √™tre une t√¢che insignifiante, probablement chaque deuxi√®me beckender scie le sien, tout comme les d√©veloppeurs de jeux fabriquent leurs tetris / serpents, etc. J'ai repris celui-ci, mais pour le rendre plus int√©ressant, il devrait √™tre pr√™t √† conqu√©rir le monde, afin qu'il puisse supporter des centaines de milliards utilisateurs actifs et en g√©n√©ral √©tait incroyablement cool.  Le besoin √©vident d'une architecture distribu√©e vient de cela, car il est irr√©aliste d'avoir la capacit√© actuelle de s'adapter √† tout le nombre imaginaire de clients sur une seule machine.  Au lieu de simplement m'asseoir et attendre l'apparition des ordinateurs quantiques, je me suis r√©solument mis √† √©tudier le sujet des syst√®mes distribu√©s. </p><br><p>  Il est √† noter qu'une r√©ponse rapide est tr√®s importante, le fameux temps r√©el, c'est un <strong>chat</strong> !  pas la livraison de courrier de pigeon. </p><br><p>  % <em>blague al√©atoire sur la poste russe</em> % </p><br><p>  Nous utiliserons Node.JS, il est id√©al pour le prototypage.  Pour les sockets, prenez Socket.IO.  √âcrivez sur TypeScript. </p><br><p>  Et alors que voulons-nous: </p><br><ol><li>  Pour que les utilisateurs puissent s‚Äôenvoyer des messages </li><li>  Savoir qui est en ligne / hors ligne </li></ol><br><p>  Comment le voulons-nous: </p><a name="habracut"></a><br><h2 id="singl-server">  Serveur unique </h2><br><p>  Il n'y a rien √† dire surtout, juste au code.  D√©clarez l'interface de message: </p><br><pre><code class="plaintext hljs">interface Message{ roomId: string,//    message: string,//    }</code> </pre> <br><p>  Sur le serveur: </p><br><pre> <code class="plaintext hljs">io.on('connection', sock=&gt;{ //    sock.on('join', (roomId:number)=&gt; sock.join(roomId)) //    //         sock.on('message', (data:Message)=&gt; io.to(data.roomId).emit('message', data)) })</code> </pre> <br><p>  Sur le client, quelque chose comme: </p><br><pre> <code class="plaintext hljs">sock.on('connect', ()=&gt; { const roomId = 'some room' //      sock.on('message', (data:Message)=&gt; console.log(`Message ${data.message} from ${data.roomId}`)) //   sock.emit('join', roomId) //    sock.emit('message', &lt;Message&gt;{roomId: roomId, message: 'Halo!'}) })</code> </pre> <br><p>  Vous pouvez travailler avec un statut en ligne comme celui-ci: </p><br><pre> <code class="plaintext hljs">io.on('connection', sock=&gt;{ //         // ,        - //      sock.on('auth', (uid:string)=&gt; sock.join(uid)) //,     , //          //   sock.on('isOnline', (uid:string, resp)=&gt; resp(io.sockets.clients(uid).length &gt; 0)) })</code> </pre> <br><p>  Et sur le client: </p><br><pre> <code class="plaintext hljs">sock.on('connect', ()=&gt; { const uid = 'im uid, rly' //  sock.emit('auth', uid) //     sock.emit('isOnline', uid, (isOnline:boolean)=&gt; console.log(`User online status is ${isOnline}`)) })</code> </pre> <br><blockquote>  Remarque: le code n'a pas fonctionn√©, j'√©cris de la m√©moire juste par exemple </blockquote><p>  Tout comme le bois de chauffage, nous faisons tourner la v√©ritable autorisation syudy, la gestion de la salle (historique des messages, ajout / suppression de participants) et le profit. </p><br><p>  MAIS!  Mais nous allons prendre le dessus sur la paix mondiale, ce qui signifie que ce n'est pas le moment de s'arr√™ter, nous allons rapidement de l'avant: </p><br><h2 id="nodejs-klaster">  Cluster Node.JS </h2><br><p>  Des exemples d'utilisation de Socket.IO sur de nombreux n≈ìuds sont disponibles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur le site officiel</a> .  Y compris il y a aussi un cluster Node.JS natif, qui m'a sembl√© inapplicable √† ma t√¢che: il nous permet d'√©tendre notre application sur toute la machine, MAIS pas au-del√† de sa port√©e, donc nous le manquons d√©finitivement.  Nous devons enfin d√©passer les limites d'une seule pi√®ce de fer! </p><br><h2 id="raspredelyay-i-velosiped">  Distribuer et faire du v√©lo </h2><br><p>  Comment faire  √âvidemment, vous devez en quelque sorte connecter nos instances, lanc√©es non seulement √† la maison dans le sous-sol, mais aussi dans le sous-sol voisin.  Ce qui nous vient √† l'esprit: nous cr√©ons une sorte de lien interm√©diaire qui servira de bus entre tous nos n≈ìuds: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549140775997.png" alt="1549140775997"></p><br><p>  Lorsqu'un n≈ìud veut envoyer un message √† un autre, il fait une demande √† Bus, et d√©j√†, √† son tour, il le transmet l√† o√π il est n√©cessaire, tout est simple.  Notre r√©seau est pr√™t! </p><br><p>  <strong>FIN.</strong> </p><br><p>  ... mais ce n'est pas si simple?) </p><br><p>  Avec cette approche, nous nous heurtons aux performances de cette liaison interm√©diaire, et en effet nous aimerions contacter directement les n≈ìuds n√©cessaires, car quoi de plus rapide qu'une communication directe?  Avan√ßons donc dans cette direction! </p><br><p>  De quoi a-t-on besoin en premier?  En fait, l√©gitimez une instance √† une autre.  Mais comment le premier apprend-il l'existence du second?  Mais nous voulons en avoir un nombre infini, augmenter / supprimer arbitrairement!  Nous avons besoin d'un serveur ma√Ætre dont l'adresse est connue pour √™tre connue, tout le monde s'y connecte, gr√¢ce √† quoi il conna√Æt tous les n≈ìuds existants du r√©seau et partage gentiment ces informations avec tout le monde. </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549048945334.png" alt="1549048945334"></p><br><p>  Le n≈ìud se l√®ve, informe le ma√Ætre de son r√©veil, il donne une liste des autres n≈ìuds actifs, on s'y connecte et c'est tout, le r√©seau est pr√™t.  Le ma√Ætre peut √™tre consul ou quelque chose comme √ßa, mais puisque nous faisons du v√©lo, le ma√Ætre doit √™tre autodidacte. </p><br><p>  Super, nous avons maintenant notre propre skynet!  Mais l'impl√©mentation actuelle du chat n'est plus adapt√©e.  Voyons en fait les exigences: </p><br><ol><li>  Lorsqu'un utilisateur envoie un message, nous devons savoir √† QUI il l'envoie, c'est-√†-dire avoir acc√®s aux participants dans la salle. </li><li>  Lorsque nous avons re√ßu les participants, nous devons leur transmettre des messages. </li><li>  Nous devons savoir quel utilisateur est en ligne maintenant. </li><li>  Pour plus de commodit√© - donnez aux utilisateurs la possibilit√© de s'abonner au statut en ligne des autres utilisateurs, afin qu'en temps r√©el, ils soient inform√©s de son changement </li></ol><br><p>  Traitons les utilisateurs.  Par exemple, vous pouvez faire savoir au ma√Ætre quel n≈ìud est connect√© √† quel n≈ìud.  La situation est la suivante: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549237952673.png" alt="1549237952673"></p><br><p>  Deux utilisateurs sont connect√©s √† diff√©rents n≈ìuds.  Le ma√Ætre le sait, les n≈ìuds savent ce que le ma√Ætre sait.  Lorsque UserB se connecte, Node2 notifie le ma√Ætre, qui "se souvient" que UserB est connect√© √† Node2.  Lorsque UserA souhaite envoyer un message UserB, vous obtenez l'image suivante: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549140491881.png" alt="1549140491881"></p><br><p>  En principe, tout fonctionne, mais je voudrais √©viter un aller-retour suppl√©mentaire sous forme d'interrogation du ma√Ætre, il serait plus √©conomique de contacter directement le bon noeud directement, car c'est pourquoi tout a commenc√©.  Cela peut √™tre fait s'ils disent √† tout le monde quels utilisateurs sont connect√©s √† eux, chacun d'eux devient un analogue autonome de l'assistant, et l'assistant lui-m√™me devient inutile, car la liste du rapport "Utilisateur =&gt; Noeud" est dupliqu√©e pour tout le monde.  Au d√©but d'un n≈ìud, il suffit de se connecter √† n'importe lequel d√©j√† en cours d'ex√©cution, de tirer sa liste pour vous et le tour est jou√©, il est √©galement pr√™t pour la bataille. </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549139768940.png" alt="1549139768940"></p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549139882747.png" alt="1549139882747"></p><br><p>  Mais comme compromis, nous obtenons une duplication de la liste, qui, bien que ce soit un rapport "id utilisateur -&gt; [connexions h√¥tes]", mais avec un nombre suffisant d'utilisateurs, il s'av√©rera √™tre assez volumineux en m√©moire.  Et en g√©n√©ral, le couper vous-m√™me - cela sent clairement l'industrie du v√©lo.  Plus il y a de code, plus il y a d'erreurs potentielles.  Peut-√™tre que nous gelons cette option et examinons ce qui est d√©j√† pr√™t: </p><br><h2 id="brokery-soobscheniy">  Courtiers de messages </h2><br><p>  L'entit√© qui impl√©mente le m√™me "Bus", le "lien interm√©diaire" mentionn√© ci-dessus.  Sa t√¢che est de recevoir et de d√©livrer des messages.  En tant qu'utilisateurs, nous pouvons nous y abonner et envoyer les n√¥tres.  Tout est simple. </p><br><p>  Il y a RabbitMQ et Kafka √©prouv√©s: ils font juste ce qu'ils d√©livrent des messages - c'est leur but, bourr√© de toutes les fonctionnalit√©s n√©cessaires au cou.  Dans leur monde, un message doit √™tre d√©livr√© quoi qu'il arrive. </p><br><p>  En m√™me temps, il y a Redis et son pub / sub - les m√™mes que les gars susmentionn√©s, mais plus de ch√™ne: il re√ßoit tout simplement b√™tement le message et le livre √† l'abonn√©, sans files d'attente et autres frais g√©n√©raux.  Il ne se soucie absolument pas des messages eux-m√™mes, ils dispara√Ætront, si l'abonn√© se bloque - il le jettera et en prendra un nouveau, comme s'ils jetteraient un poker chauff√© au rouge dans ses mains dont vous voulez vous d√©barrasser plus rapidement.  De plus, s'il tombe soudainement - tous les messages couleront avec lui.  En d'autres termes, il n'est pas question de garantie de livraison. </p><br><p>  ... et c'est ce dont vous avez besoin! </p><br><p>  Eh bien, vraiment, nous ne faisons que discuter.  Pas une sorte de service d'argent critique ou de centre de contr√¥le de vol spatial, mais ... juste une conversation.  Le risque est que Pete conditionnel une fois par an ne re√ßoive pas un message sur mille - il peut √™tre n√©glig√© si en retour nous obtenons une croissance de la productivit√© et en place avec lui le nombre d'utilisateurs pour les m√™mes jours, un √©change dans toute sa splendeur.  De plus, en m√™me temps, vous pouvez conserver un historique des messages dans une sorte de r√©f√©rentiel persistant, ce qui signifie que Petya verra toujours ce message manqu√© en rechargeant la page / l'application.  C'est pourquoi nous nous concentrerons sur Redis pub / sub, ou plut√¥t: regardez l'adaptateur existant pour SocketIO, qui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">est mentionn√© dans l'article du bureau.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">site</a> . </p><br><p>  Alors qu'est-ce que c'est? </p><br><h2 id="redis-adapter">  Adaptateur Redis </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/socketio/socket.io-redis</a> </p><br><p>  Avec son aide, une application ordinaire en quelques lignes et un minimum de gestes se transforme en un vrai chat distribu√©!  Mais comment?  <a href="">Si vous regardez √† l'int√©rieur</a> - il s'av√®re qu'il n'y a qu'un seul fichier par demi-cent lignes. </p><br><p>  Dans le cas o√π nous √©mettons un message </p><br><pre> <code class="plaintext hljs">io.emit("everyone", "hello")</code> </pre> <br><p>  il est pouss√© dans des radis, transmis √† toutes les autres instances de notre chat, qui √† son tour le d√©livre d√©j√† localement sur des sockets </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549232309776.png" alt="1549232309776"></p><br><p>  Le message sera distribu√© sur tous les n≈ìuds m√™me si nous √©mettons √† un utilisateur sp√©cifique.  C'est-√†-dire que chaque n≈ìud accepte tous les messages et comprend d√©j√† s'il en a besoin. </p><br><p>  De plus, il est impl√©ment√© un rpc simple (appelant des proc√©dures distantes), qui permet non seulement d'envoyer mais aussi de recevoir des r√©ponses.  Par exemple, vous pouvez contr√¥ler les prises √† distance, telles que "qui se trouve dans la pi√®ce sp√©cifi√©e", "ordonner √† la prise de rejoindre la pi√®ce", etc. </p><br><p>  Que peut-on faire avec √ßa?  Par exemple, utilisez l'ID utilisateur comme nom de chambre (id utilisateur == id salle).  Lors de l'autorisation, pour y connecter la prise, et quand nous voulons envoyer un message √† l'utilisateur - juste un casque dedans.  En outre, nous pouvons savoir si l'utilisateur est en ligne, en regardant simplement s'il y a des prises dans la pi√®ce sp√©cifi√©e. </p><br><p>  En principe, nous pouvons nous arr√™ter ici, mais comme toujours, cela ne nous suffit pas: </p><br><ol><li>  Col de bouteille dans une seule instance de radis </li><li>  Redondance, je souhaite que les n≈ìuds ne re√ßoivent que les messages dont ils ont besoin </li></ol><br><p>  Au d√©triment du paragraphe un, regardez une chose telle que: </p><br><h2 id="redis-cluster">  Cluster Redis </h2><br><p>  Il connecte plusieurs instances de radis, apr√®s quoi elles fonctionnent dans leur ensemble.  Mais comment fait-il?  Oui, comme √ßa: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549233023980.png" alt="1549233023980"></p><br><p>  ... et nous voyons que le message est dupliqu√© sur tous les membres du cluster.  Autrement dit, il n'est pas destin√© √† augmenter la productivit√©, mais √† accro√Ætre la fiabilit√©, ce qui est certainement bon et n√©cessaire, mais dans notre cas, il n'a pas de valeur et ne sauve en rien la situation avec un goulot d'√©tranglement, et en somme, c'est encore plus un gaspillage de ressources. </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549231953897.png" alt="1549231953897"></p><br><p>  Je suis d√©butant, je ne sais pas grand chose, parfois je dois retourner au pitchforking, ce que nous ferons.  Non, laissons le radis pour qu'il ne glisse pas du tout, mais vous devez penser √† quelque chose avec l'architecture car l'actuel n'est pas bon. </p><br><h2 id="povorot-ne-tuda">  Tournez dans le mauvais sens </h2><br><p>  De quoi avons-nous besoin?  Augmentez le d√©bit global.  Par exemple, essayons de g√©n√©rer stupidement une autre instance.  Imaginez que socket.io-redis puisse se connecter √† plusieurs, lors de l'envoi d'un message, il s√©lectionne au hasard et s'abonne √† tout.  Il se pr√©sente comme ceci: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549239818663.png" alt="1549239818663"></p><br><p>  Voila!  En g√©n√©ral, le probl√®me est r√©solu, les radis ne sont plus un goulot d'√©tranglement, vous pouvez g√©n√©rer un nombre illimit√© de copies!  Mais ils sont devenus des n≈ìuds.  Oui, oui, nos instances de chat dig√®rent toujours TOUS les messages auxquels ils n'√©taient pas destin√©s. </p><br><p>  Vous pouvez vice versa: souscrire √† un al√©atoire, ce qui r√©duira la charge sur les n≈ìuds, et poussera tout: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549239361416.png" alt="1549239361416"></p><br><p>  Nous voyons que c'est devenu l'inverse: les n≈ìuds sont plus calmes, mais la charge sur l'instance de radis a augment√©.  Ce n'est pas bon non plus.  Vous devez faire du v√©lo un peu. </p><br><p>  Afin de pomper notre syst√®me, nous laisserons le paquet socket.io-redis seul, bien qu'il soit cool, nous avons besoin de plus de libert√©.  Et donc, nous connectons le radis: </p><br><pre> <code class="plaintext hljs">//  : const pub = new RedisClient({host: 'localhost', port: 6379})//  const sub = new RedisClient({host: 'localhost', port: 6379})//   //    interface Message{ roomId: string,//    message: string,//    }</code> </pre> <br><p>  Configurez notre syst√®me de messagerie: </p><br><pre> <code class="plaintext hljs">//     sub.on('message', (channel:string, dataRaw:string)=&gt; { const data = &lt;Message&gt;JSON.parse(dataRaw) io.to(data.roomId).emit('message', data)) }) //   sub.subscribe("messagesChannel") //    sock.on('join', (roomId:number)=&gt; sock.join(roomId)) //   sock.on('message', (data:Message)=&gt; { //   pub.publish("messagesChannel", JSON.stringify(data)) })</code> </pre> <br><p>  Pour le moment, cela se passe comme dans socket.io-redis: on √©coute tous les messages.  Maintenant, nous allons le r√©parer. </p><br><p>  Nous organisons les abonnements comme suit: rappelez-vous le concept avec "id utilisateur == id salle", et lorsque l'utilisateur appara√Æt, nous nous abonnons √† la cha√Æne du m√™me nom dans le radis.  Ainsi, nos n≈ìuds ne recevront que des messages qui leur sont destin√©s, et n'√©couteront pas "l'ensemble de la diffusion". </p><br><pre> <code class="plaintext hljs">//     sub.on('message', (channel:string, message:string)=&gt; { io.to(channel).emit('message', message)) }) let UID:string|null = null; sock.on('auth', (uid:string)=&gt; { UID = uid //   -   //  UID  sub.subscribe(UID) //   sock.join(UID) }) sock.on('writeYourself', (message:string)=&gt; { //  ,        UID if (UID) pub.publish(UID, message) })</code> </pre> <br><p>  G√©nial, maintenant nous sommes s√ªrs que les n≈ìuds ne re√ßoivent que des messages qui leur sont destin√©s, rien de plus!  Il convient de noter, cependant, que les abonnements eux-m√™mes sont d√©sormais beaucoup, beaucoup plus importants, ce qui signifie qu'ils vont manger la m√©moire de yoy yoy, + plus d'op√©rations d'abonnement / d√©sabonnement, qui sont relativement co√ªteuses.  Mais en tout cas, cela nous donne une certaine souplesse, vous pouvez m√™me vous arr√™ter √† ce moment et revoir toutes les options pr√©c√©dentes, en tenant d√©j√† compte de notre nouvelle propri√©t√© de n≈ìuds sous la forme de messages de r√©ception plus s√©lectifs et chastes.  Par exemple, les n≈ìuds peuvent s'abonner √† l'une des instances de radis et, en poussant, envoyer un message √† toutes les instances: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1550174595491.png" alt="1550174595491"></p><br><p>  ... mais, quoi qu'on en dise, ils ne donnent toujours pas d'extensibilit√© infinie avec des frais g√©n√©raux raisonnables, vous devez donner naissance √† d'autres options.  √Ä un moment donn√©, le sch√©ma suivant m'est venu √† l'esprit: que faire si les instances de radis sont divis√©es en groupes, disons A et B, deux instances dans chacun.  Lors de l'abonnement, les n≈ìuds sont sign√©s par une instance de chaque groupe et, lors de l'envoi, ils envoient un message √† toutes les instances d'un m√™me groupe al√©atoire. </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1550174092066.png" alt="1550174092066"></p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1550174943313.png" alt="1550174943313"></p><br><p>  Ainsi, nous obtenons une structure d'exploitation avec un potentiel d'extensibilit√© infini en temps r√©el, la charge sur un n≈ìud individuel √† tout moment ne d√©pend pas de la taille du syst√®me, car: </p><br><ol><li>  La bande passante totale est divis√©e entre les groupes, c'est-√†-dire qu'avec une augmentation du nombre d'utilisateurs / activit√©, nous comparons simplement des groupes suppl√©mentaires. </li><li>  La gestion des utilisateurs (abonnements) est divis√©e au sein des groupes eux-m√™mes, c'est-√†-dire qu'en augmentant les utilisateurs / abonnements, nous augmentons simplement le nombre d'instances au sein des groupes. </li></ol><br><p>  ... et comme toujours, il y a un "MAIS": plus tout cela devient, plus les ressources sont n√©cessaires pour le gain suivant, il me semble un compromis exorbitant. </p><br><p>  En g√©n√©ral, si vous y r√©fl√©chissez, les bouchons mentionn√©s ci-dessus viennent de ne pas savoir quel utilisateur est sur quel n≈ìud.  Eh bien, en effet, si nous avions ces informations, nous pourrions pousser les messages l√† o√π ils en avaient besoin, sans r√©p√©tition inutile.  Qu'avons-nous essay√© de faire tout ce temps?  Ils ont essay√© de rendre le syst√®me √©volutif √† l'infini, sans disposer d'un m√©canisme d'adressage clair, qui s'est in√©vitablement heurt√© √† une impasse ou √† une redondance injustifi√©e.  Par exemple, vous pouvez rappeler l'assistant agissant comme un ¬´carnet d'adresses¬ª: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1550233610561.png" alt="1550233610561"></p><br><blockquote>  Quelque chose de similaire raconte ce mec: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/6G22a5Iooqk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></blockquote><p>  Pour obtenir la localisation de l'utilisateur, nous faisons un aller-retour suppl√©mentaire, ce qui est en principe OK, mais pas dans notre cas.  Il semble que nous creusons dans la mauvaise direction, nous avons besoin d'autre chose ... </p><br><h2 id="sila-hesha">  Force de hachage </h2><br><p>  Il existe une chose comme un hachage.  Il a une plage finie de valeurs.  Vous pouvez l'obtenir √† partir de toutes les donn√©es.  Mais que se passe-t-il si vous divisez cette plage entre les instances de radis?  Eh bien, nous prenons l'ID utilisateur, produisons un hachage, et en fonction de la plage dans laquelle il s'est av√©r√© √™tre abonn√© / pouss√© vers une instance sp√©cifique.  Autrement dit, nous ne savons pas √† l'avance o√π se trouve l'utilisateur, mais apr√®s l'avoir re√ßu, nous pouvons affirmer avec certitude qu'il s'agit de l'instance n, inf 100. Maintenant, la m√™me chose, mais avec le code: </p><br><pre> <code class="plaintext hljs">function hash(val:string):number{/**/}// -,   const clients:RedisClient[] = []//   const uid = "some uid"//  //,            //      const selectedClient = clients[hash(uid) % clients.length]</code> </pre> <br><p>  Voila!  Maintenant, nous ne d√©pendons pas du nombre d'instances du mot en g√©n√©ral, nous pouvons √©voluer autant que nous le voulons sans frais g√©n√©raux!  Eh bien, s√©rieusement, c'est une option brillante, dont le seul inconv√©nient est la n√©cessit√© de red√©marrer compl√®tement le syst√®me lors de la mise √† jour du nombre d'instances de radis.  Il existe un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">anneau standard et un anneau de partition</a> qui vous permettent de surmonter cela, mais ils ne sont pas applicables dans un syst√®me de messagerie.  Eh bien, vous pouvez faire la logique de la migration des abonnements entre les instances, mais cela co√ªte toujours un morceau de code suppl√©mentaire de taille incompr√©hensible, et comme nous le savons - plus de code, plus de bugs, nous n'en avons pas besoin, merci.  Et dans notre cas, le temps d'arr√™t est un compromis tout √† fait acceptable. </p><br><p>  Vous pouvez √©galement regarder RabbitMQ avec son <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plugin</a> , qui vous permet de faire la m√™me chose que nous, et + fournit la migration des abonnements (comme je l'ai dit ci-dessus - il est li√© avec des fonctionnalit√©s de la t√™te aux pieds).  En principe, vous pouvez le prendre et dormir paisiblement, mais si quelqu'un t√¢tonne dans son r√©glage afin d'amener le mode en temps r√©el, ne laissant qu'une fonctionnalit√© avec un anneau de hachage. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Inondation du r√©f√©rentiel sur github.</a> </p><br><p>  Il impl√©mente la version finale √† laquelle nous sommes arriv√©s.  De plus, il existe une logique suppl√©mentaire pour travailler avec des pi√®ces (dialogues). </p><br><p>  En g√©n√©ral, je suis satisfait et peut √™tre arrondi. </p><br><h2 id="itogo">  Total </h2><br><p>  Vous pouvez tout faire, mais les ressources existent, et elles sont limit√©es, vous devez donc vous tortiller. </p><br><p>  Nous avons commenc√© par ignorer compl√®tement comment les syst√®mes distribu√©s peuvent fonctionner selon des mod√®les concrets plus ou moins tangibles, et c'est bien. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr440546/">https://habr.com/ru/post/fr440546/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr440534/index.html">Traduction d'un vocabulaire politiquement correct de l'anglais vers le russe</a></li>
<li><a href="../fr440536/index.html">Comment Facebook Project Infer aide √† trouver des bogues dans les applications mobiles avant le d√©ploiement</a></li>
<li><a href="../fr440540/index.html">La capitalisation de Reddit a atteint 3 milliards de dollars apr√®s avoir attir√© des investissements de 300 millions de dollars</a></li>
<li><a href="../fr440542/index.html">Vuex - utilisation excessive de getters dans l'application. Erreur d'analyse</a></li>
<li><a href="../fr440544/index.html">La version exp√©rimentale de Blazor 0.8.0 est maintenant disponible</a></li>
<li><a href="../fr440548/index.html">"Vous ne pouvez pas simplement prendre et parall√©liser des sources de tension"</a></li>
<li><a href="../fr440550/index.html">Le triangle de couleur n'a pas deux, mais un coin</a></li>
<li><a href="../fr440552/index.html">Interrompre les fermetures et injecter l'injection de d√©pendance en JavaScript</a></li>
<li><a href="../fr440554/index.html">BEM pratique</a></li>
<li><a href="../fr440556/index.html">Apprentissage de la conception de diagrammes de relation d'entit√©</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>