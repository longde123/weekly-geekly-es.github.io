<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤵🏻 👌🏻 🖊️ Chat distribué sur Node.JS et Redis 🚽 😴 🐀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Une petite question / réponse: 


 À qui est-il destiné? Les gens qui ont peu ou pas d'expérience avec les systèmes distribués et qui souhaitent voir ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Chat distribué sur Node.JS et Redis</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440546/"><p><img src="https://cs4.pikabu.ru/post_img/2015/10/04/5/1443945163_2102700146.jpg" alt="Le résultat est une image de plaisanterie pour laver &quot;pigeon mail&quot;"></p><br><p>  Une petite question / réponse: </p><br><p> <em>À qui est-il destiné?</em>  Les gens qui ont peu ou pas d'expérience avec les systèmes distribués et qui souhaitent voir comment ils peuvent être construits, quels modèles et solutions existent. </p><br><p>  <em>Pourquoi ça?</em>  Lui-même s'est intéressé à quoi et comment.  J'ai récupéré des informations de différentes sources, j'ai décidé de les publier sous une forme concentrée, car à un moment j'aimerais moi-même voir un tel travail.  En fait, ceci est une déclaration textuelle de mes lancers et pensées personnels.  En outre, il y aura certainement de nombreuses corrections dans les commentaires de personnes bien informées, et c'est en partie le but d'écrire tout cela sous la forme d'un article. </p><br><h2 id="postanovka-zadachi">  Énoncé du problème </h2><br><p>  Comment faire un chat?  Cela devrait être une tâche insignifiante, probablement chaque deuxième beckender scie le sien, tout comme les développeurs de jeux fabriquent leurs tetris / serpents, etc. J'ai repris celui-ci, mais pour le rendre plus intéressant, il devrait être prêt à conquérir le monde, afin qu'il puisse supporter des centaines de milliards utilisateurs actifs et en général était incroyablement cool.  Le besoin évident d'une architecture distribuée vient de cela, car il est irréaliste d'avoir la capacité actuelle de s'adapter à tout le nombre imaginaire de clients sur une seule machine.  Au lieu de simplement m'asseoir et attendre l'apparition des ordinateurs quantiques, je me suis résolument mis à étudier le sujet des systèmes distribués. </p><br><p>  Il est à noter qu'une réponse rapide est très importante, le fameux temps réel, c'est un <strong>chat</strong> !  pas la livraison de courrier de pigeon. </p><br><p>  % <em>blague aléatoire sur la poste russe</em> % </p><br><p>  Nous utiliserons Node.JS, il est idéal pour le prototypage.  Pour les sockets, prenez Socket.IO.  Écrivez sur TypeScript. </p><br><p>  Et alors que voulons-nous: </p><br><ol><li>  Pour que les utilisateurs puissent s’envoyer des messages </li><li>  Savoir qui est en ligne / hors ligne </li></ol><br><p>  Comment le voulons-nous: </p><a name="habracut"></a><br><h2 id="singl-server">  Serveur unique </h2><br><p>  Il n'y a rien à dire surtout, juste au code.  Déclarez l'interface de message: </p><br><pre><code class="plaintext hljs">interface Message{ roomId: string,//    message: string,//    }</code> </pre> <br><p>  Sur le serveur: </p><br><pre> <code class="plaintext hljs">io.on('connection', sock=&gt;{ //    sock.on('join', (roomId:number)=&gt; sock.join(roomId)) //    //         sock.on('message', (data:Message)=&gt; io.to(data.roomId).emit('message', data)) })</code> </pre> <br><p>  Sur le client, quelque chose comme: </p><br><pre> <code class="plaintext hljs">sock.on('connect', ()=&gt; { const roomId = 'some room' //      sock.on('message', (data:Message)=&gt; console.log(`Message ${data.message} from ${data.roomId}`)) //   sock.emit('join', roomId) //    sock.emit('message', &lt;Message&gt;{roomId: roomId, message: 'Halo!'}) })</code> </pre> <br><p>  Vous pouvez travailler avec un statut en ligne comme celui-ci: </p><br><pre> <code class="plaintext hljs">io.on('connection', sock=&gt;{ //         // ,        - //      sock.on('auth', (uid:string)=&gt; sock.join(uid)) //,     , //          //   sock.on('isOnline', (uid:string, resp)=&gt; resp(io.sockets.clients(uid).length &gt; 0)) })</code> </pre> <br><p>  Et sur le client: </p><br><pre> <code class="plaintext hljs">sock.on('connect', ()=&gt; { const uid = 'im uid, rly' //  sock.emit('auth', uid) //     sock.emit('isOnline', uid, (isOnline:boolean)=&gt; console.log(`User online status is ${isOnline}`)) })</code> </pre> <br><blockquote>  Remarque: le code n'a pas fonctionné, j'écris de la mémoire juste par exemple </blockquote><p>  Tout comme le bois de chauffage, nous faisons tourner la véritable autorisation syudy, la gestion de la salle (historique des messages, ajout / suppression de participants) et le profit. </p><br><p>  MAIS!  Mais nous allons prendre le dessus sur la paix mondiale, ce qui signifie que ce n'est pas le moment de s'arrêter, nous allons rapidement de l'avant: </p><br><h2 id="nodejs-klaster">  Cluster Node.JS </h2><br><p>  Des exemples d'utilisation de Socket.IO sur de nombreux nœuds sont disponibles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur le site officiel</a> .  Y compris il y a aussi un cluster Node.JS natif, qui m'a semblé inapplicable à ma tâche: il nous permet d'étendre notre application sur toute la machine, MAIS pas au-delà de sa portée, donc nous le manquons définitivement.  Nous devons enfin dépasser les limites d'une seule pièce de fer! </p><br><h2 id="raspredelyay-i-velosiped">  Distribuer et faire du vélo </h2><br><p>  Comment faire  Évidemment, vous devez en quelque sorte connecter nos instances, lancées non seulement à la maison dans le sous-sol, mais aussi dans le sous-sol voisin.  Ce qui nous vient à l'esprit: nous créons une sorte de lien intermédiaire qui servira de bus entre tous nos nœuds: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549140775997.png" alt="1549140775997"></p><br><p>  Lorsqu'un nœud veut envoyer un message à un autre, il fait une demande à Bus, et déjà, à son tour, il le transmet là où il est nécessaire, tout est simple.  Notre réseau est prêt! </p><br><p>  <strong>FIN.</strong> </p><br><p>  ... mais ce n'est pas si simple?) </p><br><p>  Avec cette approche, nous nous heurtons aux performances de cette liaison intermédiaire, et en effet nous aimerions contacter directement les nœuds nécessaires, car quoi de plus rapide qu'une communication directe?  Avançons donc dans cette direction! </p><br><p>  De quoi a-t-on besoin en premier?  En fait, légitimez une instance à une autre.  Mais comment le premier apprend-il l'existence du second?  Mais nous voulons en avoir un nombre infini, augmenter / supprimer arbitrairement!  Nous avons besoin d'un serveur maître dont l'adresse est connue pour être connue, tout le monde s'y connecte, grâce à quoi il connaît tous les nœuds existants du réseau et partage gentiment ces informations avec tout le monde. </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549048945334.png" alt="1549048945334"></p><br><p>  Le nœud se lève, informe le maître de son réveil, il donne une liste des autres nœuds actifs, on s'y connecte et c'est tout, le réseau est prêt.  Le maître peut être consul ou quelque chose comme ça, mais puisque nous faisons du vélo, le maître doit être autodidacte. </p><br><p>  Super, nous avons maintenant notre propre skynet!  Mais l'implémentation actuelle du chat n'est plus adaptée.  Voyons en fait les exigences: </p><br><ol><li>  Lorsqu'un utilisateur envoie un message, nous devons savoir à QUI il l'envoie, c'est-à-dire avoir accès aux participants dans la salle. </li><li>  Lorsque nous avons reçu les participants, nous devons leur transmettre des messages. </li><li>  Nous devons savoir quel utilisateur est en ligne maintenant. </li><li>  Pour plus de commodité - donnez aux utilisateurs la possibilité de s'abonner au statut en ligne des autres utilisateurs, afin qu'en temps réel, ils soient informés de son changement </li></ol><br><p>  Traitons les utilisateurs.  Par exemple, vous pouvez faire savoir au maître quel nœud est connecté à quel nœud.  La situation est la suivante: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549237952673.png" alt="1549237952673"></p><br><p>  Deux utilisateurs sont connectés à différents nœuds.  Le maître le sait, les nœuds savent ce que le maître sait.  Lorsque UserB se connecte, Node2 notifie le maître, qui "se souvient" que UserB est connecté à Node2.  Lorsque UserA souhaite envoyer un message UserB, vous obtenez l'image suivante: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549140491881.png" alt="1549140491881"></p><br><p>  En principe, tout fonctionne, mais je voudrais éviter un aller-retour supplémentaire sous forme d'interrogation du maître, il serait plus économique de contacter directement le bon noeud directement, car c'est pourquoi tout a commencé.  Cela peut être fait s'ils disent à tout le monde quels utilisateurs sont connectés à eux, chacun d'eux devient un analogue autonome de l'assistant, et l'assistant lui-même devient inutile, car la liste du rapport "Utilisateur =&gt; Noeud" est dupliquée pour tout le monde.  Au début d'un nœud, il suffit de se connecter à n'importe lequel déjà en cours d'exécution, de tirer sa liste pour vous et le tour est joué, il est également prêt pour la bataille. </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549139768940.png" alt="1549139768940"></p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549139882747.png" alt="1549139882747"></p><br><p>  Mais comme compromis, nous obtenons une duplication de la liste, qui, bien que ce soit un rapport "id utilisateur -&gt; [connexions hôtes]", mais avec un nombre suffisant d'utilisateurs, il s'avérera être assez volumineux en mémoire.  Et en général, le couper vous-même - cela sent clairement l'industrie du vélo.  Plus il y a de code, plus il y a d'erreurs potentielles.  Peut-être que nous gelons cette option et examinons ce qui est déjà prêt: </p><br><h2 id="brokery-soobscheniy">  Courtiers de messages </h2><br><p>  L'entité qui implémente le même "Bus", le "lien intermédiaire" mentionné ci-dessus.  Sa tâche est de recevoir et de délivrer des messages.  En tant qu'utilisateurs, nous pouvons nous y abonner et envoyer les nôtres.  Tout est simple. </p><br><p>  Il y a RabbitMQ et Kafka éprouvés: ils font juste ce qu'ils délivrent des messages - c'est leur but, bourré de toutes les fonctionnalités nécessaires au cou.  Dans leur monde, un message doit être délivré quoi qu'il arrive. </p><br><p>  En même temps, il y a Redis et son pub / sub - les mêmes que les gars susmentionnés, mais plus de chêne: il reçoit tout simplement bêtement le message et le livre à l'abonné, sans files d'attente et autres frais généraux.  Il ne se soucie absolument pas des messages eux-mêmes, ils disparaîtront, si l'abonné se bloque - il le jettera et en prendra un nouveau, comme s'ils jetteraient un poker chauffé au rouge dans ses mains dont vous voulez vous débarrasser plus rapidement.  De plus, s'il tombe soudainement - tous les messages couleront avec lui.  En d'autres termes, il n'est pas question de garantie de livraison. </p><br><p>  ... et c'est ce dont vous avez besoin! </p><br><p>  Eh bien, vraiment, nous ne faisons que discuter.  Pas une sorte de service d'argent critique ou de centre de contrôle de vol spatial, mais ... juste une conversation.  Le risque est que Pete conditionnel une fois par an ne reçoive pas un message sur mille - il peut être négligé si en retour nous obtenons une croissance de la productivité et en place avec lui le nombre d'utilisateurs pour les mêmes jours, un échange dans toute sa splendeur.  De plus, en même temps, vous pouvez conserver un historique des messages dans une sorte de référentiel persistant, ce qui signifie que Petya verra toujours ce message manqué en rechargeant la page / l'application.  C'est pourquoi nous nous concentrerons sur Redis pub / sub, ou plutôt: regardez l'adaptateur existant pour SocketIO, qui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">est mentionné dans l'article du bureau.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">site</a> . </p><br><p>  Alors qu'est-ce que c'est? </p><br><h2 id="redis-adapter">  Adaptateur Redis </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/socketio/socket.io-redis</a> </p><br><p>  Avec son aide, une application ordinaire en quelques lignes et un minimum de gestes se transforme en un vrai chat distribué!  Mais comment?  <a href="">Si vous regardez à l'intérieur</a> - il s'avère qu'il n'y a qu'un seul fichier par demi-cent lignes. </p><br><p>  Dans le cas où nous émettons un message </p><br><pre> <code class="plaintext hljs">io.emit("everyone", "hello")</code> </pre> <br><p>  il est poussé dans des radis, transmis à toutes les autres instances de notre chat, qui à son tour le délivre déjà localement sur des sockets </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549232309776.png" alt="1549232309776"></p><br><p>  Le message sera distribué sur tous les nœuds même si nous émettons à un utilisateur spécifique.  C'est-à-dire que chaque nœud accepte tous les messages et comprend déjà s'il en a besoin. </p><br><p>  De plus, il est implémenté un rpc simple (appelant des procédures distantes), qui permet non seulement d'envoyer mais aussi de recevoir des réponses.  Par exemple, vous pouvez contrôler les prises à distance, telles que "qui se trouve dans la pièce spécifiée", "ordonner à la prise de rejoindre la pièce", etc. </p><br><p>  Que peut-on faire avec ça?  Par exemple, utilisez l'ID utilisateur comme nom de chambre (id utilisateur == id salle).  Lors de l'autorisation, pour y connecter la prise, et quand nous voulons envoyer un message à l'utilisateur - juste un casque dedans.  En outre, nous pouvons savoir si l'utilisateur est en ligne, en regardant simplement s'il y a des prises dans la pièce spécifiée. </p><br><p>  En principe, nous pouvons nous arrêter ici, mais comme toujours, cela ne nous suffit pas: </p><br><ol><li>  Col de bouteille dans une seule instance de radis </li><li>  Redondance, je souhaite que les nœuds ne reçoivent que les messages dont ils ont besoin </li></ol><br><p>  Au détriment du paragraphe un, regardez une chose telle que: </p><br><h2 id="redis-cluster">  Cluster Redis </h2><br><p>  Il connecte plusieurs instances de radis, après quoi elles fonctionnent dans leur ensemble.  Mais comment fait-il?  Oui, comme ça: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549233023980.png" alt="1549233023980"></p><br><p>  ... et nous voyons que le message est dupliqué sur tous les membres du cluster.  Autrement dit, il n'est pas destiné à augmenter la productivité, mais à accroître la fiabilité, ce qui est certainement bon et nécessaire, mais dans notre cas, il n'a pas de valeur et ne sauve en rien la situation avec un goulot d'étranglement, et en somme, c'est encore plus un gaspillage de ressources. </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549231953897.png" alt="1549231953897"></p><br><p>  Je suis débutant, je ne sais pas grand chose, parfois je dois retourner au pitchforking, ce que nous ferons.  Non, laissons le radis pour qu'il ne glisse pas du tout, mais vous devez penser à quelque chose avec l'architecture car l'actuel n'est pas bon. </p><br><h2 id="povorot-ne-tuda">  Tournez dans le mauvais sens </h2><br><p>  De quoi avons-nous besoin?  Augmentez le débit global.  Par exemple, essayons de générer stupidement une autre instance.  Imaginez que socket.io-redis puisse se connecter à plusieurs, lors de l'envoi d'un message, il sélectionne au hasard et s'abonne à tout.  Il se présente comme ceci: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549239818663.png" alt="1549239818663"></p><br><p>  Voila!  En général, le problème est résolu, les radis ne sont plus un goulot d'étranglement, vous pouvez générer un nombre illimité de copies!  Mais ils sont devenus des nœuds.  Oui, oui, nos instances de chat digèrent toujours TOUS les messages auxquels ils n'étaient pas destinés. </p><br><p>  Vous pouvez vice versa: souscrire à un aléatoire, ce qui réduira la charge sur les nœuds, et poussera tout: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549239361416.png" alt="1549239361416"></p><br><p>  Nous voyons que c'est devenu l'inverse: les nœuds sont plus calmes, mais la charge sur l'instance de radis a augmenté.  Ce n'est pas bon non plus.  Vous devez faire du vélo un peu. </p><br><p>  Afin de pomper notre système, nous laisserons le paquet socket.io-redis seul, bien qu'il soit cool, nous avons besoin de plus de liberté.  Et donc, nous connectons le radis: </p><br><pre> <code class="plaintext hljs">//  : const pub = new RedisClient({host: 'localhost', port: 6379})//  const sub = new RedisClient({host: 'localhost', port: 6379})//   //    interface Message{ roomId: string,//    message: string,//    }</code> </pre> <br><p>  Configurez notre système de messagerie: </p><br><pre> <code class="plaintext hljs">//     sub.on('message', (channel:string, dataRaw:string)=&gt; { const data = &lt;Message&gt;JSON.parse(dataRaw) io.to(data.roomId).emit('message', data)) }) //   sub.subscribe("messagesChannel") //    sock.on('join', (roomId:number)=&gt; sock.join(roomId)) //   sock.on('message', (data:Message)=&gt; { //   pub.publish("messagesChannel", JSON.stringify(data)) })</code> </pre> <br><p>  Pour le moment, cela se passe comme dans socket.io-redis: on écoute tous les messages.  Maintenant, nous allons le réparer. </p><br><p>  Nous organisons les abonnements comme suit: rappelez-vous le concept avec "id utilisateur == id salle", et lorsque l'utilisateur apparaît, nous nous abonnons à la chaîne du même nom dans le radis.  Ainsi, nos nœuds ne recevront que des messages qui leur sont destinés, et n'écouteront pas "l'ensemble de la diffusion". </p><br><pre> <code class="plaintext hljs">//     sub.on('message', (channel:string, message:string)=&gt; { io.to(channel).emit('message', message)) }) let UID:string|null = null; sock.on('auth', (uid:string)=&gt; { UID = uid //   -   //  UID  sub.subscribe(UID) //   sock.join(UID) }) sock.on('writeYourself', (message:string)=&gt; { //  ,        UID if (UID) pub.publish(UID, message) })</code> </pre> <br><p>  Génial, maintenant nous sommes sûrs que les nœuds ne reçoivent que des messages qui leur sont destinés, rien de plus!  Il convient de noter, cependant, que les abonnements eux-mêmes sont désormais beaucoup, beaucoup plus importants, ce qui signifie qu'ils vont manger la mémoire de yoy yoy, + plus d'opérations d'abonnement / désabonnement, qui sont relativement coûteuses.  Mais en tout cas, cela nous donne une certaine souplesse, vous pouvez même vous arrêter à ce moment et revoir toutes les options précédentes, en tenant déjà compte de notre nouvelle propriété de nœuds sous la forme de messages de réception plus sélectifs et chastes.  Par exemple, les nœuds peuvent s'abonner à l'une des instances de radis et, en poussant, envoyer un message à toutes les instances: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1550174595491.png" alt="1550174595491"></p><br><p>  ... mais, quoi qu'on en dise, ils ne donnent toujours pas d'extensibilité infinie avec des frais généraux raisonnables, vous devez donner naissance à d'autres options.  À un moment donné, le schéma suivant m'est venu à l'esprit: que faire si les instances de radis sont divisées en groupes, disons A et B, deux instances dans chacun.  Lors de l'abonnement, les nœuds sont signés par une instance de chaque groupe et, lors de l'envoi, ils envoient un message à toutes les instances d'un même groupe aléatoire. </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1550174092066.png" alt="1550174092066"></p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1550174943313.png" alt="1550174943313"></p><br><p>  Ainsi, nous obtenons une structure d'exploitation avec un potentiel d'extensibilité infini en temps réel, la charge sur un nœud individuel à tout moment ne dépend pas de la taille du système, car: </p><br><ol><li>  La bande passante totale est divisée entre les groupes, c'est-à-dire qu'avec une augmentation du nombre d'utilisateurs / activité, nous comparons simplement des groupes supplémentaires. </li><li>  La gestion des utilisateurs (abonnements) est divisée au sein des groupes eux-mêmes, c'est-à-dire qu'en augmentant les utilisateurs / abonnements, nous augmentons simplement le nombre d'instances au sein des groupes. </li></ol><br><p>  ... et comme toujours, il y a un "MAIS": plus tout cela devient, plus les ressources sont nécessaires pour le gain suivant, il me semble un compromis exorbitant. </p><br><p>  En général, si vous y réfléchissez, les bouchons mentionnés ci-dessus viennent de ne pas savoir quel utilisateur est sur quel nœud.  Eh bien, en effet, si nous avions ces informations, nous pourrions pousser les messages là où ils en avaient besoin, sans répétition inutile.  Qu'avons-nous essayé de faire tout ce temps?  Ils ont essayé de rendre le système évolutif à l'infini, sans disposer d'un mécanisme d'adressage clair, qui s'est inévitablement heurté à une impasse ou à une redondance injustifiée.  Par exemple, vous pouvez rappeler l'assistant agissant comme un «carnet d'adresses»: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1550233610561.png" alt="1550233610561"></p><br><blockquote>  Quelque chose de similaire raconte ce mec: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/6G22a5Iooqk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></blockquote><p>  Pour obtenir la localisation de l'utilisateur, nous faisons un aller-retour supplémentaire, ce qui est en principe OK, mais pas dans notre cas.  Il semble que nous creusons dans la mauvaise direction, nous avons besoin d'autre chose ... </p><br><h2 id="sila-hesha">  Force de hachage </h2><br><p>  Il existe une chose comme un hachage.  Il a une plage finie de valeurs.  Vous pouvez l'obtenir à partir de toutes les données.  Mais que se passe-t-il si vous divisez cette plage entre les instances de radis?  Eh bien, nous prenons l'ID utilisateur, produisons un hachage, et en fonction de la plage dans laquelle il s'est avéré être abonné / poussé vers une instance spécifique.  Autrement dit, nous ne savons pas à l'avance où se trouve l'utilisateur, mais après l'avoir reçu, nous pouvons affirmer avec certitude qu'il s'agit de l'instance n, inf 100. Maintenant, la même chose, mais avec le code: </p><br><pre> <code class="plaintext hljs">function hash(val:string):number{/**/}// -,   const clients:RedisClient[] = []//   const uid = "some uid"//  //,            //      const selectedClient = clients[hash(uid) % clients.length]</code> </pre> <br><p>  Voila!  Maintenant, nous ne dépendons pas du nombre d'instances du mot en général, nous pouvons évoluer autant que nous le voulons sans frais généraux!  Eh bien, sérieusement, c'est une option brillante, dont le seul inconvénient est la nécessité de redémarrer complètement le système lors de la mise à jour du nombre d'instances de radis.  Il existe un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">anneau standard et un anneau de partition</a> qui vous permettent de surmonter cela, mais ils ne sont pas applicables dans un système de messagerie.  Eh bien, vous pouvez faire la logique de la migration des abonnements entre les instances, mais cela coûte toujours un morceau de code supplémentaire de taille incompréhensible, et comme nous le savons - plus de code, plus de bugs, nous n'en avons pas besoin, merci.  Et dans notre cas, le temps d'arrêt est un compromis tout à fait acceptable. </p><br><p>  Vous pouvez également regarder RabbitMQ avec son <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plugin</a> , qui vous permet de faire la même chose que nous, et + fournit la migration des abonnements (comme je l'ai dit ci-dessus - il est lié avec des fonctionnalités de la tête aux pieds).  En principe, vous pouvez le prendre et dormir paisiblement, mais si quelqu'un tâtonne dans son réglage afin d'amener le mode en temps réel, ne laissant qu'une fonctionnalité avec un anneau de hachage. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Inondation du référentiel sur github.</a> </p><br><p>  Il implémente la version finale à laquelle nous sommes arrivés.  De plus, il existe une logique supplémentaire pour travailler avec des pièces (dialogues). </p><br><p>  En général, je suis satisfait et peut être arrondi. </p><br><h2 id="itogo">  Total </h2><br><p>  Vous pouvez tout faire, mais les ressources existent, et elles sont limitées, vous devez donc vous tortiller. </p><br><p>  Nous avons commencé par ignorer complètement comment les systèmes distribués peuvent fonctionner selon des modèles concrets plus ou moins tangibles, et c'est bien. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr440546/">https://habr.com/ru/post/fr440546/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr440534/index.html">Traduction d'un vocabulaire politiquement correct de l'anglais vers le russe</a></li>
<li><a href="../fr440536/index.html">Comment Facebook Project Infer aide à trouver des bogues dans les applications mobiles avant le déploiement</a></li>
<li><a href="../fr440540/index.html">La capitalisation de Reddit a atteint 3 milliards de dollars après avoir attiré des investissements de 300 millions de dollars</a></li>
<li><a href="../fr440542/index.html">Vuex - utilisation excessive de getters dans l'application. Erreur d'analyse</a></li>
<li><a href="../fr440544/index.html">La version expérimentale de Blazor 0.8.0 est maintenant disponible</a></li>
<li><a href="../fr440548/index.html">"Vous ne pouvez pas simplement prendre et paralléliser des sources de tension"</a></li>
<li><a href="../fr440550/index.html">Le triangle de couleur n'a pas deux, mais un coin</a></li>
<li><a href="../fr440552/index.html">Interrompre les fermetures et injecter l'injection de dépendance en JavaScript</a></li>
<li><a href="../fr440554/index.html">BEM pratique</a></li>
<li><a href="../fr440556/index.html">Apprentissage de la conception de diagrammes de relation d'entité</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>