<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçüíª üö© ü§∏üèº O grande üö∏ ü§¥üèª üëßüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nota Traducci√≥n abreviada, m√°s bien volver a contar en sus propias palabras. 
 UPD: como se se√±al√≥ en los comentarios, los ejemplos no son perfectos. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>O grande</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444594/">  <i><u>Nota</u></i>  <i>Traducci√≥n abreviada, m√°s bien volver a contar en sus propias palabras.</i> <i><br></i>  <i>UPD: como se se√±al√≥ en los comentarios, los ejemplos no son perfectos.</i>  <i>El autor no est√° buscando la mejor soluci√≥n al problema, su objetivo es explicar la complejidad de los algoritmos "en los dedos".</i> <br><br>  Se necesita una notaci√≥n O grande para describir la complejidad de los algoritmos.  Para esto, se utiliza el concepto de tiempo.  El tema es aterrador para muchos, los programadores evitan hablar sobre "el tiempo del orden N" es algo com√∫n. <br><br>  Si puede evaluar el c√≥digo en t√©rminos de Big O, lo m√°s probable es que se lo considere un "tipo inteligente".  Y lo m√°s probable es que pases por tu pr√≥xima entrevista.  No se detendr√° con la pregunta de si es posible reducir la complejidad de cualquier c√≥digo para n log n contra n ^ 2. <br><br><h2>  Estructuras de datos </h2><br>  La elecci√≥n de la estructura de datos depende de la tarea espec√≠fica: del tipo de datos y del algoritmo para su procesamiento.  Se cre√≥ una variedad de estructuras de datos (en .NET o Java o Elixir) para ciertos tipos de algoritmos. <br><br>  A menudo, al elegir una u otra estructura, simplemente copiamos la soluci√≥n generalmente aceptada.  En la mayor√≠a de los casos, esto es suficiente.  Pero, de hecho, sin comprender la complejidad de los algoritmos, no podemos hacer una elecci√≥n informada.  El tema de las estructuras de datos solo se puede pasar despu√©s de la complejidad de los algoritmos. <br><br>  Aqu√≠ usaremos solo matrices de n√∫meros (como en una entrevista).  Ejemplos de JavaScript. <br><a name="habracut"></a><br><h2>  Comencemos con el m√°s simple: O (1) </h2><br>  Tome una matriz de 5 n√∫meros: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nums = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>];</code> </pre> <br>  Suponga que necesita obtener el primer elemento.  Usamos el √≠ndice para esto: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nums = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> firstNumber = nums[<span class="hljs-number"><span class="hljs-number">0</span></span>];</code> </pre> <br>  ¬øQu√© tan complicado es este algoritmo?  Podemos decir: "nada complicado, simplemente tome el primer elemento de la matriz".  Esto es cierto, pero es m√°s correcto describir la complejidad a trav√©s del n√∫mero de operaciones realizadas para lograr el resultado, dependiendo de la entrada ( <i>operaciones de</i> entrada). <br><br>  En otras palabras: cu√°ntas operaciones aumentar√°n a medida que aumente el n√∫mero de par√°metros de entrada. <br><br>  En nuestro ejemplo, hay 5 par√°metros de entrada, porque hay 5 elementos en la matriz.  Para obtener el resultado, debe realizar una operaci√≥n (tomar un elemento por √≠ndice).  ¬øCu√°ntas operaciones ser√°n necesarias si hay 100 elementos en la matriz?  O 1000?  O 100.000?  De todos modos, solo se necesita una operaci√≥n. <br><br>  Es decir: "una operaci√≥n para todos los datos de entrada posibles" - O (1). <br><br>  O (1) puede leerse como "complejidad de orden 1" (orden 1) o "algoritmo se ejecuta en tiempo constante / constante" (tiempo constante). <br><br>  Ya has adivinado que los algoritmos O (1) son los m√°s eficientes. <br><br><h2>  Iteraciones y "tiempo de orden n": O (n) </h2><br>  Ahora busquemos la suma de los elementos de la matriz: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nums = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> num <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> nums){ sum += num; }</code> </pre> <br>  Nuevamente nos preguntamos: ¬øcu√°ntas operaciones de entrada necesitamos?  Aqu√≠ debe ordenar todos los elementos, es decir  operaci√≥n en cada elemento.  Cuanto m√°s grande es la matriz, m√°s operaciones. <br><br>  Uso de la notaci√≥n Big O: O (n), o "complejidad del orden n (orden n)".  Adem√°s, este tipo de algoritmo se llama "lineal" o que el algoritmo est√° "escalado linealmente". <br><br><h3>  An√°lisis </h3><br>  ¬øPodemos hacer la suma m√°s eficiente?  En general no.  ¬øY si sabemos que la matriz est√° garantizada para comenzar en 1, ordenada y no tiene huecos?  Entonces podemos aplicar la f√≥rmula S = n (n + 1) / 2 (donde n es el √∫ltimo elemento de la matriz): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sumContiguousArray = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ary</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//get the last item const lastItem = ary[ary.length - 1]; //Gauss's trick return lastItem * (lastItem + 1) / 2; } const nums = [1,2,3,4,5]; const sumOfArray = sumContiguousArray(nums);</span></span></code> </pre> <br>  Tal algoritmo es mucho m√°s eficiente que O (n), adem√°s, se ejecuta en "tiempo constante / constante", es decir  es O (1). <br><br>  De hecho, hay m√°s de una operaci√≥n: necesita obtener la longitud de la matriz, obtener el √∫ltimo elemento, realizar la multiplicaci√≥n y la divisi√≥n.  ¬øNo es eso O (3) o algo as√≠?  En la notaci√≥n Big O, el n√∫mero real de pasos no es importante, es importante que el algoritmo se ejecute en tiempo constante. <br><br>  Los algoritmos de tiempo constante son siempre O (1).  Lo mismo con los algoritmos lineales, de hecho, las operaciones pueden ser O (n + 5), en Big O la notaci√≥n es O (n). <br><br><h2>  No son las mejores soluciones: O (n ^ 2) </h2><br>  Escribamos una funci√≥n que verifique la matriz en busca de duplicados.  Soluci√≥n de bucle anidado: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hasDuplicates = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//loop the list, our O(n) op for (let i = 0; i &lt; nums.length; i++) { const thisNum = nums[i]; //loop the list again, the O(n^2) op for (let j = 0; j &lt; nums.length; j++) { //make sure we're not checking same number if (j !== i) { const otherNum = nums[j]; //if there's an equal value, return if (otherNum === thisNum) return true; } } } //if we're here, no dups return false; } const nums = [1, 2, 3, 4, 5, 5]; hasDuplicates(nums);//true</span></span></code> </pre> <br>  Ya sabemos que la iteraci√≥n de matriz es O (n).  Tenemos un bucle anidado, para cada elemento que iteramos nuevamente, es decir  O (n ^ 2) o "complejidad del orden n cuadrado". <br><br>  Los algoritmos con bucles anidados sobre la misma colecci√≥n son siempre O (n ^ 2). <br><br><h2>  "La complejidad del orden de log n": O (log n) </h2><br>  En el ejemplo anterior, un bucle anidado, por s√≠ solo (si no tiene en cuenta que est√° anidado), tiene complejidad O (n), porque  Es la enumeraci√≥n de los elementos de la matriz.  Este ciclo termina tan pronto como se encuentra el elemento deseado, es decir  de hecho, no todos los elementos ser√°n enumerados.  Pero la notaci√≥n Big O siempre considera el peor de los casos: el elemento que est√° buscando puede ser el √∫ltimo. <br><br>  Aqu√≠, un bucle anidado se usa para buscar un elemento dado en una matriz.  La b√∫squeda de un elemento en una matriz, bajo ciertas condiciones, se puede optimizar, hacerlo mejor que O lineal (n). <br><br>  Deje que se ordene la matriz.  Luego podemos usar el algoritmo de b√∫squeda binaria: dividir la matriz en dos mitades, descartar lo innecesario, dividir el resto nuevamente en dos partes, y as√≠ sucesivamente hasta encontrar el valor deseado.  Este tipo de algoritmo se llama divide y vencer√°s Divide y vencer√°s. <br><br><img src="https://habrastorage.org/webt/0p/b9/em/0pb9em6fqdkdj0dtknyxbt8kbvk.png" alt="b√∫squeda binaria"><br><br>  Este algoritmo se basa en un logaritmo. <br><br><h2>  Descripci√≥n r√°pida de los logaritmos </h2><br>  Considere un ejemplo, ¬øa qu√© ser√° igual x? <br><br>  x ^ 3 = 8 <br><br>  Necesitamos tomar la ra√≠z c√∫bica de 8, esto ser√° 2. Ahora m√°s dif√≠cil <br><br>  2 ^ x = 512 <br><br>  Usando el logaritmo, el problema se puede escribir como <br><br>  log2 (512) = x <br><br>  "El logaritmo de base 2 de 512 es x".  Presta atenci√≥n a la "base 2", es decir  pensamos en dos: cu√°ntas veces necesitas multiplicar 2 para obtener 512. <br><br>  En el algoritmo de b√∫squeda binaria, en cada paso dividimos la matriz en dos partes. <br><br>  <i><u>Mi adicion.</u></i>  <i>Es decir</i>  <i>en el peor de los casos, realizamos tantas operaciones como podemos dividir la matriz en dos partes.</i>  <i>Por ejemplo, ¬øcu√°ntas veces podemos dividir una matriz de 4 elementos en dos partes?</i>  <i>2 veces</i>  <i>¬øY una matriz de 8 elementos?</i>  <i>3 veces</i>  <i>Es decir</i>  <i>n√∫mero de divisiones / operaciones = log2 (n) (donde n es el n√∫mero de elementos en la matriz).</i> <i><br><br></i>  <i>Resulta que la dependencia del n√∫mero de operaciones en el n√∫mero de elementos de entrada se describe como log2 (n)</i> <i><br></i> <br><br>  Por lo tanto, utilizando la notaci√≥n Big O, el algoritmo de b√∫squeda binaria tiene complejidad O (log n). <br><br><h2>  Mejore O (n ^ 2) a O (n log n) </h2><br>  Volvamos a la tarea de verificar la matriz en busca de duplicados.  Realizamos iteraciones sobre todos los elementos de la matriz, y para cada elemento nuevamente iteramos.  Hicieron O (n) dentro de O (n), es decir  O (n * n) u O (n ^ 2). <br><br>  Podemos reemplazar el bucle anidado con una b√∫squeda binaria *.  Es decir  solo tenemos que pasar por todos los elementos de O (n), dentro hacemos O (log n).  Resulta O (n * log n) u O (n log n). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nums = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> searchFor = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">items, num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//use binary search! //if found, return the number. Otherwise... //return null. We'll do this in a later chapter. } const hasDuplicates = function (nums) { for (let num of nums) { //let's go through the list again and have a look //at all the other numbers so we can compare if (searchFor(nums, num)) { return true; } } //only arrive here if there are no dups return false; }</span></span></code> </pre> <br><br>  * ATENCI√ìN, para evitar la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">impresi√≥n</a> .  Usar la b√∫squeda binaria para verificar una matriz en busca de duplicados es una mala soluci√≥n.  Solo muestra c√≥mo, en t√©rminos de Big O, evaluar la complejidad del algoritmo que se muestra en la lista de c√≥digos anterior.  Un buen algoritmo o uno malo no es importante para este art√≠culo; la visibilidad es importante. <br><br><h2>  Pensando en t√©rminos de Big O </h2><br><ul><li>  Obtener el elemento de colecci√≥n es O (1).  Si se obtiene por √≠ndice en una matriz o por clave en un diccionario en notaci√≥n Big O, ser√° O (1) </li><li>  Iterando sobre una colecci√≥n es O (n) </li><li>  Los bucles anidados sobre la misma colecci√≥n son O (n ^ 2) </li><li>  Divide y vencer√°s siempre O (log n) </li><li>  Las iteraciones que usan Divide and Conquer son O (n log n) </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/444594/">https://habr.com/ru/post/444594/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444582/index.html">Optimizador de pol√≠ticas de seguridad NGFW de Palo Alto Networks</a></li>
<li><a href="../444584/index.html">Android ofrecer√° a los usuarios europeos un navegador y un motor de b√∫squeda de su elecci√≥n.</a></li>
<li><a href="../444586/index.html">Arquitectura rusa del segmento de Internet</a></li>
<li><a href="../444590/index.html">Filtraci√≥n de datos (que pudo haber ocurrido pero no ocurri√≥) de la compa√±√≠a de telemedicina</a></li>
<li><a href="../444592/index.html">El ej√©rcito de EE. UU. Planea usar un nuevo tipo de exoesqueleto</a></li>
<li><a href="../444596/index.html">Yoduro: Mozilla Interactive Science Editor</a></li>
<li><a href="../444598/index.html">El CD tiene 40 a√±os y est√° muerto (¬øverdad?)</a></li>
<li><a href="../444600/index.html">Revisi√≥n de 14 cms sin cabeza 2019</a></li>
<li><a href="../444602/index.html">Encapsulaci√≥n en C ++ y C</a></li>
<li><a href="../444610/index.html">Estad√≠sticas y monitoreo de scripts PHP en tiempo real. ClickHouse y Grafana van a ayudar a Pinba</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>