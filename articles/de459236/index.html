<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦑 🚲 🤾🏽 SQL: Arbeitszeit-Task-Lösung 👩‍💻 🥛 👩🏽‍✈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo, Radio SQL ist wieder auf Sendung! Heute haben wir eine Lösung für das Problem , das wir in unserer vorherigen Sendung übertragen haben, und hab...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>SQL: Arbeitszeit-Task-Lösung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/459236/"><p>  Hallo, Radio SQL ist wieder auf Sendung!  Heute haben wir eine Lösung für das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Problem</a> , das wir in unserer vorherigen Sendung übertragen haben, und haben versprochen, das nächste Mal auszumachen.  Und das nächste Mal ist gekommen. </p><br><p>  Die Aufgabe löste eine lebhafte Reaktion unter den Humanoiden der Milchstraße aus (und nicht überraschend mit ihrer Arbeitssklaverei, die sie immer noch zum Wohle der Zivilisation respektieren).  Leider wurde auf dem dritten Planeten der Start des Spectrum-RG-Weltraumobservatoriums Ende Juli 2019, der RC (Local Chronology), verschoben, mit deren Hilfe die Ausstrahlung dieser Sendung geplant war.  Ich musste nach alternativen Übertragungswegen suchen, was zu einer leichten Verzögerung des Signals führte.  Aber alles ist gut, das endet gut. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rc/a6/z4/rca6z4cduxlps2le_c4l_3rwnrg.png"></div><br><p>  Ich muss sofort sagen, dass es keine Magie in der Analyse der Aufgabe geben wird, es nicht notwendig ist, hier nach Enthüllungen zu suchen oder auf eine besonders effektive (oder besonders in einem anderen Sinne) Implementierung zu warten.  Dies ist nur eine Analyseaufgabe.  Darin können diejenigen, die nicht wissen, wie sie sich der Lösung solcher Probleme nähern sollen, sehen, wie sie gelöst werden können.  Außerdem gibt es hier nichts Schreckliches. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Lassen Sie mich Sie an den Zustand erinnern.</b> <div class="spoiler_text"><p>  Es gibt mehrere Zeitintervalle, die durch das Datum und die Uhrzeit des Beginns und Endes angegeben werden (ein Beispiel in der PostgreSQL-Syntax): </p><br><pre><code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> periods(id, start_time, stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-03-29 07:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-08 14:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-10 07:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-10 20:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>), (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-11 12:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-12 16:07:12'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>), (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'2018-12-28 12:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-01-16 16:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>) )</code> </pre> <br><p>  In einer SQL-Abfrage (c) muss die Dauer jedes Intervalls in Arbeitsstunden berechnet werden.  Wir glauben, dass wir wochentags von Montag bis Freitag arbeiten, die Arbeitszeiten sind immer von 10:00 bis 19:00 Uhr.  Darüber hinaus gibt es gemäß dem Produktionskalender der Russischen Föderation eine Reihe von offiziellen Feiertagen, die keine Arbeitstage sind, und einige der freien Tage sind im Gegenteil Arbeitstage, da dieselben Feiertage verschoben werden.  Eine Verkürzung der Vorferientage ist nicht erforderlich, wir halten sie für vollständig.  Da die Feiertage von Jahr zu Jahr variieren, dh durch explizite Auflistung festgelegt werden, beschränken wir uns auf Daten nur von 2018 und 2019.  Ich bin sicher, dass die Lösung bei Bedarf leicht ergänzt werden kann. </p><br><p>  Es ist erforderlich, eine Spalte mit der Dauer in Arbeitsstunden zu den Anfangsperioden von <em>Perioden</em> hinzuzufügen.  Hier ist das Ergebnis: </p><br><pre> <code class="pgsql hljs"> id | start_time | stop_time | work_hrs <span class="hljs-comment"><span class="hljs-comment">----+---------------------+---------------------+---------- 1 | 2019-03-29 07:00:00 | 2019-04-08 14:00:00 | 58:00:00 2 | 2019-04-10 07:00:00 | 2019-04-10 20:00:00 | 09:00:00 3 | 2019-04-11 12:00:00 | 2019-04-12 16:07:12 | 13:07:12 4 | 2018-12-28 12:00:00 | 2019-01-16 16:00:00 | 67:00:00</span></span></code> </pre> <br><p>  Wir überprüfen die Anfangsdaten nicht auf Richtigkeit, sondern berücksichtigen immer <em>start_time &lt;= stop_time</em> . </p><br><p>  Das Ende der Bedingung, das Original ist hier: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://habr.com/en/company/postgrespro/blog/448368/</a> . </p></div></div><br><p>  Die Aufgabe verleiht der Tatsache, dass ich bewusst eine gute Hälfte der Bedingung bewusst in beschreibender Form angegeben habe (wie dies im wirklichen Leben der Fall ist), eine leichte Pikantheit, wobei es im Ermessen der technischen Implementierung liegt, wie der Zeitplan festgelegt werden soll.  Dies erfordert zum einen einige architektonische Denkfähigkeiten.  Andererseits hätte das vorgefertigte Format dieses Zeitplans zu einer Verwendung der Vorlage geführt.  Und wenn Sie weglassen, werden Gedanken und Fantasien besser funktionieren.  Der Empfang hat sich voll ausgezahlt und mir ermöglicht, auch in den veröffentlichten Lösungen interessante Ansätze zu finden. </p><br><p>  Um das ursprüngliche Problem auf diese Weise zu lösen, müssen zwei Unteraufgaben gelöst werden: </p><br><ol><li>  Bestimmen Sie, wie Sie einen Arbeitsplan am kompaktesten festlegen können und ob dies für eine Lösung bequem ist. </li><li>  Berechnen Sie tatsächlich die Dauer jeder Quellperiode in Arbeitsstunden gemäß dem Arbeitsplan aus der vorherigen Unteraufgabe. </li></ol><br><p>  Und es ist besser, mit der zweiten zu beginnen, um zu verstehen, in welcher Form wir die erste lösen müssen.  Lösen Sie dann die erste und kehren Sie erneut zur zweiten zurück, um das Endergebnis zu erhalten. <br>  Wir werden das Ergebnis schrittweise mithilfe der CTE-Syntax erfassen, mit der wir alle erforderlichen Datenbeispiele in separate benannte Unterabfragen einfügen und dann alles miteinander verknüpfen können. </p><br><p>  Nun, lass uns gehen. </p><br><h3 id="poschitat-dlitelnost-v-rabochih-chasah">  Berechnen Sie die Dauer in Arbeitsstunden </h3><br><p>  Um die Dauer jeder Arbeitszeit in der Stirn zu berechnen, müssen Sie die Anfangszeit (grüne Farbe im Diagramm) mit den Intervallen kreuzen, die die Arbeitszeit beschreiben (orange).  Die Arbeitszeitintervalle sind montags von 10:00 bis 19:00 Uhr, dienstags von 10:00 bis 19:00 Uhr und so weiter.  Das Ergebnis wird blau angezeigt: </p><br><p><img src="https://habrastorage.org/webt/o4/yh/6_/o4yh6_ca7loarlvtghe572p6zdo.png" alt="Bild"></p><br><p>  Übrigens, um weniger verwirrt zu sein, werde ich die Anfangsperioden weiterhin als Anfangsperioden bezeichnen und Arbeitszeitintervalle aufrufen. </p><br><p>  Der Vorgang sollte für jede Anfangsperiode wiederholt werden.  Die Anfangsperioden für uns sind bereits auf der <em>Registerkarte Perioden (start_time, stop_time) festgelegt</em> . Wir werden die Arbeitszeiten in Form einer Tabelle darstellen, z. B. <em>Zeitplan (strat_time, stop_time)</em> , in der jeder Arbeitstag vorhanden ist.  Das Ergebnis ist ein vollständiges kartesisches Produkt aller anfänglichen Perioden und Intervalle der Arbeitszeit. </p><br><p>  Schnittpunkte können auf klassische Weise gezählt werden, wobei alle möglichen Optionen für Schnittintervalle berücksichtigt wurden - wir schneiden Grün mit Orange, das Ergebnis ist blau: </p><br><p><img src="https://habrastorage.org/webt/fx/aq/wo/fxaqwo7uud0kyzismeqn6cqeap0.png" alt="Bild"></p><br><p>  und jeweils den gewünschten Wert für den Anfang und das Ende des Ergebnisses nehmen: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> s.start_time, s.stop_time <span class="hljs-comment"><span class="hljs-comment">-- case #1 from periods p, schedule s where p.start_time &lt;= s.start_time and p.stop_time &gt; s.stop_time union all select p.start_time, s.stop_time -- case #2 from periods p, schedule s where p.start_time &gt;= s.start_time and p.stop_time &gt; s.stop_time and p.start_time &lt; s.stop_time union all select s.start_time, p.stop_time -- case #3 from periods p, schedule s where p.start_time &lt;= s.start_time and p.stop_time &lt; s.stop_time and p.stop_time &gt; s.start_time union all select p.start_time, p.stop_time -- case #4 from periods p, schedule s where p.start_time &gt;= s.start_time and p.stop_time &lt; s.stop_time</span></span></code> </pre> <br><p>  Da wir für jede Kreuzung nur eine von vier Optionen haben können, werden alle mit <em>union all</em> zu einer Anfrage zusammengefasst. </p><br><p>  Sie können dies auch tun, indem Sie den in PostgreSQL verfügbaren <em>tsrange-</em> Bereichstyp und die dafür bereits verfügbare Schnittmenge verwenden: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time) * <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods p, schedule s</code> </pre> <br><p>  Stimmen Sie zu, dass es ein bisschen einfacher ist.  Im Allgemeinen gibt es in PostgreSQL eine Menge solcher praktischen Kleinigkeiten, daher ist es sehr schön, Abfragen darüber zu schreiben. </p><br><h3 id="sgenerirovat-kalendar">  Kalender generieren </h3><br><p>  Nun zurück zur Unteraufgabe mit dem Arbeitszeitplan. </p><br><p>  Wir müssen den Arbeitsplan in Form von Arbeitszeitintervallen von 10:00 bis 19:00 für jeden Arbeitstag erhalten, so etwas wie einen <em>Zeitplan (start_time, stop_time)</em> .  Wie wir verstanden haben, wird es zweckmäßig sein, unser Problem zu lösen.  Im wirklichen Leben sollte ein solcher Zeitplan gedeckt werden, für zwei Jahre sind es nur etwa 500 Datensätze, aus praktischen Gründen müssen sogar zehn Jahre festgelegt werden - dies sind ein paar anderthalbtausend Datensätze, ein echter Müll für moderne Datenbanken.  Wir haben jedoch ein Problem, das in einer Anfrage gelöst werden kann, und die Auflistung der gesamten Tabelle ist nicht sehr praktisch.  Versuchen wir es kompakter zu implementieren. </p><br><p>  In jedem Fall benötigen wir Feiertage, um sie aus dem Basisplan zu entfernen, und hier ist nur die Auflistung geeignet: </p><br><pre> <code class="pgsql hljs"> dates_exclude(d) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>(<span class="hljs-string"><span class="hljs-string">'2018-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>), <span class="hljs-comment"><span class="hljs-comment">-- 2018 ('2018-01-02'::date), ('2018-01-03'::date), ('2018-01-04'::date), ('2018-01-05'::date), ('2018-01-08'::date), ('2018-02-23'::date), ('2018-03-08'::date), ('2018-03-09'::date), ('2018-05-01'::date), ('2018-05-02'::date), ('2018-05-09'::date), ('2018-06-11'::date), ('2018-06-12'::date), ('2018-11-05'::date), ('2018-12-31'::date), ('2019-01-01'::date), -- 2019 ('2019-01-02'::date), ('2019-01-03'::date), ('2019-01-04'::date), ('2019-01-07'::date), ('2019-01-08'::date), ('2019-03-08'::date), ('2019-05-01'::date), ('2019-05-02'::date), ('2019-05-03'::date), ('2019-05-09'::date), ('2019-05-10'::date), ('2019-06-12'::date), ('2019-11-04'::date) )</span></span></code> </pre> <br><p>  und zusätzliche Werktage, die hinzugefügt werden müssen: </p><br><pre> <code class="pgsql hljs"> dates_include(d) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> <span class="hljs-comment"><span class="hljs-comment">--  2018,  2019  ('2018-04-28'::date), ('2018-06-09'::date), ('2018-12-29'::date) )</span></span></code> </pre> <br><p>  Die Reihenfolge der Arbeitstage für zwei Jahre kann durch eine spezielle und sehr geeignete Funktion <em>generate_series () generiert</em> werden, die sofort Samstage und Sonntage auf dem Weg wirft: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series( <span class="hljs-string"><span class="hljs-string">'2018-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span> , <span class="hljs-string"><span class="hljs-string">'2020-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span> , <span class="hljs-string"><span class="hljs-string">'1 day'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> extract(<span class="hljs-type"><span class="hljs-type">dow</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> d) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-comment"><span class="hljs-comment">--    </span></span></code> </pre> <br><p>  Wir erhalten die Arbeitstage, indem wir alles miteinander verbinden: Wir generieren eine Folge aller Arbeitstage in zwei Jahren, fügen zusätzliche Arbeitstage aus <em>date_include hinzu</em> und entfernen alle zusätzlichen Tage aus <em>date_exclude</em> : </p><br><pre> <code class="pgsql hljs"> schedule_base <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series( <span class="hljs-string"><span class="hljs-string">'2018-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span> , <span class="hljs-string"><span class="hljs-string">'2020-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span> , <span class="hljs-string"><span class="hljs-string">'1 day'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> extract(<span class="hljs-type"><span class="hljs-type">dow</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> d) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-comment"><span class="hljs-comment">--     union select d from dates_include --     except select d from dates_exclude --     )</span></span></code> </pre> <br><p>  Und jetzt bekommen wir die Zeitintervalle, die wir brauchen: </p><br><pre> <code class="pgsql hljs"> schedule(start_time, stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d + <span class="hljs-string"><span class="hljs-string">'10:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span>, d + <span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> schedule_base )</code> </pre> <br><p>  Also haben wir den Zeitplan. </p><br><h3 id="sobiraem-vsyo-vmeste">  Alles zusammenfügen </h3><br><p>  Jetzt bekommen wir die Kreuzungen: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* , <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(p.start_time, p.stop_time) * <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wrkh <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods p <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> schedule s <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(p.start_time, p.stop_time) &amp;&amp; <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time)</code> </pre> <br><p>  Beachten Sie die <em>ON-</em> Verknüpfungsbedingung, sie stimmt nicht mit zwei entsprechenden Datensätzen aus den verknüpften Tabellen überein, es gibt keine solche Entsprechung, aber es wird eine Optimierung eingeführt, die die Arbeitszeitintervalle verkürzt, mit denen sich unsere Anfangsperiode nicht überschneidet.  Dies erfolgt mit dem Operator <em>&amp;&amp;</em> , der den Schnittpunkt der <em>Bereichsintervalle</em> überprüft.  Dadurch werden viele leere Kreuzungen entfernt, um den Augen nicht im Weg zu stehen. Auf der anderen Seite werden jedoch Informationen zu den Anfangsperioden entfernt, die vollständig außerhalb der Geschäftszeiten liegen.  Wir bewundern also, dass unser Ansatz funktioniert, und schreiben die Anfrage wie folgt um: </p><br><pre> <code class="pgsql hljs"> periods_wrk <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* , <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(p.start_time, p.stop_time) * <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wrkh <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods p , schedule s ) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> id, start_time, stop_time , sum(upper(wrkh)-lower(wrkh)) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods_wrk <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> id, start_time, stop_time</code> </pre> <br><p>  In <em>period_wrk</em> zerlegen <em>wir</em> jede <em>Quellperiode</em> in Arbeitsintervalle und betrachten dann ihre Gesamtdauer.  Das Ergebnis war ein vollständiges kartesisches Produkt aller Zeiträume und Intervalle, aber es ging kein einziger Zeitraum verloren. </p><br><p>  Alles, das Ergebnis wird empfangen.  Die <em>NULL-</em> Werte für leere Intervalle haben mir nicht gefallen. Lassen Sie die Abfrage ein Intervall mit der Länge Null besser anzeigen.  Wickeln Sie die Menge in <em>coalesce ()</em> : </p><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> id, start_time, stop_time , coalesce(sum(upper(wrkh)-lower(wrkh)), <span class="hljs-string"><span class="hljs-string">'0 sec'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods_wrk <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> id, start_time, stop_time</code> </pre> <br><p>  Alles zusammen ergibt das Endergebnis: </p><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> periods(id, start_time, stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-03-29 07:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-08 14:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>) , (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-10 07:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-10 20:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>) , (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-11 12:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-12 16:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>) , (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'2018-12-28 12:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-01-16 16:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>) ), dates_exclude(d) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>(<span class="hljs-string"><span class="hljs-string">'2018-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>), <span class="hljs-comment"><span class="hljs-comment">-- 2018 ('2018-01-02'::date), ('2018-01-03'::date), ('2018-01-04'::date), ('2018-01-05'::date), ('2018-01-08'::date), ('2018-02-23'::date), ('2018-03-08'::date), ('2018-03-09'::date), ('2018-05-01'::date), ('2018-05-02'::date), ('2018-05-09'::date), ('2018-06-11'::date), ('2018-06-12'::date), ('2018-11-05'::date), ('2018-12-31'::date), ('2019-01-01'::date), -- 2019 ('2019-01-02'::date), ('2019-01-03'::date), ('2019-01-04'::date), ('2019-01-07'::date), ('2019-01-08'::date), ('2019-03-08'::date), ('2019-05-01'::date), ('2019-05-02'::date), ('2019-05-03'::date), ('2019-05-09'::date), ('2019-05-10'::date), ('2019-06-12'::date), ('2019-11-04'::date) ), dates_include(start_time, stop_time) as ( values --  2018,  2019  ('2018-04-28 10:00:00'::timestamp, '2018-04-28 19:00:00'::timestamp), ('2018-06-09 10:00:00'::timestamp, '2018-06-09 19:00:00'::timestamp), ('2018-12-29 10:00:00'::timestamp, '2018-12-29 19:00:00'::timestamp) ) ), schedule_base(start_time, stop_time) as ( select d::timestamp + '10:00:00', d::timestamp + '19:00:00' from generate_series( (select min(start_time) from periods)::date::timestamp , (select max(stop_time) from periods)::date::timestamp , '1 day'::interval ) as days(d) where extract(dow from d) not in (0,6) ), schedule as ( select * from schedule_base where start_time::date not in (select d from dates_exclude) union select * from dates_include ), periods_wrk as ( select p.* , tsrange(p.start_time, p.stop_time) * tsrange(s.start_time, s.stop_time) as wrkh from periods p , schedule s ) select id, start_time, stop_time , sum(coalesce(upper(wrkh)-lower(wrkh), '0 sec'::interval)) from periods_wrk group by id, start_time, stop_time</span></span></code> </pre> <br><p>  Hurra! .. Dies könnte abgeschlossen sein, aber der Vollständigkeit halber werden wir einige verwandte Themen betrachten. </p><br><h3 id="dalneyshee-razvitie-temy">  Weiterentwicklung des Themas </h3><br><p>  Verkürzte Vorferientage, Mittagspausen, unterschiedliche Zeitpläne für verschiedene Wochentage ... Im Prinzip ist alles klar, Sie müssen die Definition des <em>Zeitplans</em> festlegen, geben Sie nur ein paar Beispiele. </p><br><p>  So können Sie je nach Wochentag unterschiedliche Start- und Endzeiten eines Arbeitstages einstellen: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d + <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> extract(<span class="hljs-type"><span class="hljs-type">dow</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> d) <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-string"><span class="hljs-string">'10:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-comment"><span class="hljs-comment">--  when 2 then '11:00:00'::time --  when 3 then '11:00:00'::time --  --        else '10:00:00'::time end , d + case extract(dow from d) --   19   when 5 then '14:00:00'::time --  else '19:00:00'::time end from schedule_base</span></span></code> </pre> <br><p>  Wenn Sie die Mittagspausen von 13:00 bis 14:00 Uhr berücksichtigen müssen, führen Sie anstelle eines Intervalls pro Tag zwei Schritte aus: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d + <span class="hljs-string"><span class="hljs-string">'10:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> , d + <span class="hljs-string"><span class="hljs-string">'13:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> schedule_base <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d + <span class="hljs-string"><span class="hljs-string">'14:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> , d + <span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> schedule_base</code> </pre> <br><p>  Gut und so weiter. </p><br><h3 id="proizvoditelnost">  Leistung </h3><br><p>  Ich werde ein paar Worte zur Leistung sagen, da es immer Fragen dazu gibt.  Ich werde noch nicht viel kauen, dies ist ein Abschnitt mit einem Sternchen. </p><br><p>  Im Allgemeinen ist eine vorzeitige Optimierung böse.  Nach meiner langjährigen Beobachtung ist die Lesbarkeit des Codes der wichtigste Vorteil.  Wenn der Code gut gelesen ist, ist es einfacher zu warten und zu entwickeln.  Gut lesbarer Code erfordert implizit sowohl eine gute Lösungsarchitektur, korrekte Kommentare als auch gute Variablennamen, Kompaktheit ohne Beeinträchtigung der Lesbarkeit usw., dh alles, wofür der Code als gut bezeichnet wird. </p><br><p>  Daher ist die Anfrage immer so lesbar wie möglich geschrieben, und wir beginnen genau dann mit der Optimierung, wenn sich herausstellt, dass die Leistung nicht ausreicht.  Darüber hinaus werden wir es genau dort optimieren, wo die Leistung nicht ausreicht und genau so weit, dass es ausreicht.  Wenn Sie Ihre eigene Zeit schätzen und etwas zu tun haben. </p><br><p>  Es ist jedoch richtig, keine unnötige Arbeit in der Anfrage zu leisten. Sie sollten immer versuchen, dies zu berücksichtigen. </p><br><p>  Auf dieser Grundlage werden wir sofort eine Optimierung in die Abfrage aufnehmen - lassen Sie jede Quellperiode nur mit den Arbeitszeitintervallen schneiden, mit denen sie gemeinsame Punkte hat (anstelle einer langen klassischen Bedingung an den Bereichsgrenzen ist es bequemer, den integrierten Operator <em>&amp;&amp;</em> für den Typ <em>tsrange zu</em> verwenden).  Diese Optimierung ist bereits in der Anfrage enthalten, hat jedoch dazu geführt, dass die anfänglichen Zeiträume, die vollständig außerhalb der Arbeitszeit lagen, aus den Ergebnissen verschwunden sind. </p><br><p>  Bringen Sie diese Optimierung zurück.  Verwenden Sie dazu <em>LEFT JOIN</em> , um alle Datensätze aus der <em>Periodentabelle zu</em> speichern.  Jetzt <em>sieht</em> die <em>Unterabfrage</em> period_wrk folgendermaßen aus: </p><br><pre> <code class="pgsql hljs">, periods_wrk <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* , <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(p.start_time, p.stop_time) * <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wrkh <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods p <span class="hljs-keyword"><span class="hljs-keyword">left join</span></span> schedule s <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(p.start_time, p.stop_time) &amp;&amp; <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time))</code> </pre> <br><p>  Die Analyse der Anfrage zeigt, dass sich die Zeit für die Testdaten um etwa die Hälfte verringert hat.  Da die Laufzeit davon abhängt, was der Server zur gleichen Zeit tat, nahm ich einige Messungen vor und gab ein „typisches“ Ergebnis, nicht das größte, nicht das kleinste, aus der Mitte. </p><br><p>  Alte Abfrage: </p><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyse</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> periods(id, start_time, stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( ... QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------------ HashAggregate (cost=334.42..338.39 rows=397 width=36) (actual time=10.724..10.731 rows=4 loops=1) ...</span></span></code> </pre> <br><p>  Neu: </p><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyse</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> periods(id, start_time, stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( ... QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------------ HashAggregate (cost=186.37..186.57 rows=20 width=36) (actual time=5.431..5.440 rows=4 loops=1) ...</span></span></code> </pre> <br><p>  Das Wichtigste ist jedoch, dass eine solche Anforderung auch besser skaliert wird und weniger Serverressourcen erfordert, da das gesamte kartesische Produkt sehr schnell wächst. </p><br><p>  Und hier würde ich mit Optimierungen aufhören.  Als ich dieses Problem für mich selbst löste, hatte ich selbst in einer viel schrecklicheren Form dieser Anfrage genug Leistung, aber es bestand wirklich kein Grund zur Optimierung.  Um einmal im Quartal einen Bericht über meine Daten zu erhalten, kann ich weitere zehn Sekunden warten.  Die zusätzliche Stunde, die für die Optimierung unter solchen Bedingungen aufgewendet wird, wird sich niemals auszahlen. </p><br><p>  Es stellt sich jedoch als uninteressant heraus. Lassen Sie uns noch darüber nachdenken, wie sich Ereignisse entwickeln könnten, wenn eine Optimierung der Ausführungszeit wirklich erforderlich wäre.  Zum Beispiel möchten wir diesen Parameter in Echtzeit für jeden unserer Datensätze in der Datenbank überwachen, dh für jedes Niesen wird eine solche Anforderung aufgerufen.  Nun, oder überlegen Sie sich Ihren eigenen Grund, warum Sie optimieren müssen. </p><br><p>  Das erste, was mir in den Sinn kommt, ist, einmal zu zählen und eine Tabelle mit Arbeitsintervallen in die Datenbank aufzunehmen.  Es kann Kontraindikationen geben: Wenn die Datenbank nicht geändert werden kann oder Schwierigkeiten bei der Unterstützung relevanter Daten in einer solchen Tabelle zu erwarten sind.  Dann müssen Sie die Generierung der Arbeitszeit „on the fly“ in der Anfrage selbst belassen, da dies keine sehr schwere Unterabfrage ist. </p><br><p>  Der nächste und leistungsstärkste (aber nicht immer anwendbare) Ansatz ist die algorithmische Optimierung.  Einige dieser Ansätze wurden bereits in den Kommentaren zum Artikel mit dem Zustand des Problems vorgestellt. </p><br><p>  Ich mag dieses am meisten.  Wenn Sie eine Tabelle mit allen (nicht nur Arbeitstagen) des Kalenders erstellen und die kumulierte Summe der Arbeitsstunden pro Tag aus einer bestimmten „Erschaffung der Welt“ berechnen, können Sie die Anzahl der Arbeitsstunden zwischen zwei Daten mit einer Subtraktionsoperation ermitteln.  Es bleibt nur, die Arbeitszeiten für den ersten und letzten Tag korrekt zu berücksichtigen - und Sie sind fertig.  Folgendes habe ich bei diesem Ansatz erreicht: </p><br><pre> <code class="pgsql hljs"> schedule_base(d, is_working) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-string"><span class="hljs-string">'2018-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d+<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> extract(<span class="hljs-type"><span class="hljs-type">dow</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> d+<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> d+<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">all</span></span>(<span class="hljs-string"><span class="hljs-string">'{2019-01-01,2019-01-02,2019-01-03,2019-01-04,2019-01-07,2019-01-08,2019-03-08,2019-05-01,2019-05-02,2019-05-03,2019-05-09,2019-05-10,2019-06-12,2019-11-04,2018-01-01,2018-01-02,2018-01-03,2018-01-04,2018-01-05,2018-01-08,2018-02-23,2018-03-08,2018-03-09,2018-04-30,2018-05-01,2018-05-02,2018-05-09,2018-06-11,2018-06-12,2018-11-05,2018-12-31}'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> d+<span class="hljs-number"><span class="hljs-number">1</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>(<span class="hljs-string"><span class="hljs-string">'{2018-04-28,2018-06-09,2018-12-29}'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> schedule_base <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> d &lt; <span class="hljs-string"><span class="hljs-string">'2020-01-01'</span></span> ), schedule(d, is_working, work_hours) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d, is_working , sum(is_working*<span class="hljs-string"><span class="hljs-string">'9 hours'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">over</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unbounded</span></span> <span class="hljs-keyword"><span class="hljs-keyword">preceding</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> schedule_base ) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* , s2.work_hours - s1.work_hours + (<span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> - least(greatest(p.start_time::<span class="hljs-type"><span class="hljs-type">time</span></span>, <span class="hljs-string"><span class="hljs-string">'10:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span>), <span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span>)) * s1.is_working - (<span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> - least(greatest(p.stop_time::<span class="hljs-type"><span class="hljs-type">time</span></span>, <span class="hljs-string"><span class="hljs-string">'10:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span>), <span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span>)) * s2.is_working <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wrk <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods p, schedule s1, schedule s2 <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> s1.d = p.start_time::<span class="hljs-type"><span class="hljs-type">date</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> s2.d = p.stop_time::<span class="hljs-type"><span class="hljs-type">date</span></span></code> </pre> <br><p>  Ich werde kurz erklären, was hier passiert.  In der Unterabfrage <em>Schedule_base</em> generieren wir alle Tage des Kalenders für zwei Jahre und bestimmen an jedem Tag das Vorzeichen, ob der Arbeitstag (= 1) oder nicht (= 0).  Darüber hinaus betrachten wir in der <em>Zeitplan-</em> Unterabfrage die Fensterfunktion als die kumulierte Gesamtzahl der Arbeitsstunden ab dem 01.01.2018.  Es wäre möglich, alles in einer Unterabfrage zu erledigen, aber es würde sich als umständlicher herausstellen, was die Lesbarkeit beeinträchtigen würde.  In der Hauptanfrage berücksichtigen wir dann die Differenz zwischen der Anzahl der Arbeitsstunden am Ende und am Anfang des Zeitraums und berücksichtigen, etwas blumig, die Arbeitszeit für den ersten und letzten Tag des Zeitraums.  Floridität ist mit der Verschiebung der Zeit vor dem Beginn des Arbeitstages auf den Beginn und der Zeit nach dem Ende des Arbeitstages auf das Ende verbunden.  Wenn der Teil der Anforderung mit <em>Shedule_Base</em> und <em>Zeitplan</em> in eine separate vorberechnete Tabelle entfernt wird (wie zuvor vorgeschlagen), wird die Anforderung zu einer völlig trivialen. </p><br><p>  Vergleichen wir die Ausführung an einer größeren Stichprobe, um die durchgeführte Optimierung besser darzustellen. Für vier Zeiträume ab der Aufgabenbedingung wird mehr Zeit für die Erstellung eines Arbeitsplans aufgewendet. </p><br><p>  Ich habe ungefähr dreitausend Perioden gebraucht.  Ich werde nur die oberste zusammenfassende Zeile in EXPLAIN geben, typische Werte sind wie folgt. </p><br><p>  Ursprüngliche Option: </p><br><pre> <code class="pgsql hljs">GroupAggregate (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">265790.95</span></span>.<span class="hljs-number"><span class="hljs-number">.296098</span></span><span class="hljs-number"><span class="hljs-number">.23</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">144320</span></span> width=<span class="hljs-number"><span class="hljs-number">36</span></span>) (actual <span class="hljs-type"><span class="hljs-type">time</span></span>=<span class="hljs-number"><span class="hljs-number">656.654</span></span>.<span class="hljs-number"><span class="hljs-number">.894</span></span><span class="hljs-number"><span class="hljs-number">.383</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">2898</span></span> loops=<span class="hljs-number"><span class="hljs-number">1</span></span>) ...</code> </pre> <br><p>  Optimiert: </p><br><pre> <code class="pgsql hljs">Hash <span class="hljs-keyword"><span class="hljs-keyword">Join</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">45.01</span></span>.<span class="hljs-number"><span class="hljs-number">.127</span></span><span class="hljs-number"><span class="hljs-number">.52</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">70</span></span> width=<span class="hljs-number"><span class="hljs-number">36</span></span>) (actual <span class="hljs-type"><span class="hljs-type">time</span></span>=<span class="hljs-number"><span class="hljs-number">1.620</span></span>.<span class="hljs-number"><span class="hljs-number">.5</span></span><span class="hljs-number"><span class="hljs-number">.385</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">2898</span></span> loops=<span class="hljs-number"><span class="hljs-number">1</span></span>) ...</code> </pre> <br><p>  Der Zeitgewinn betrug einige Größenordnungen.  Mit der Zunahme der Anzahl der Perioden und ihrer Länge in Jahren wird sich der Abstand nur vergrößern. </p><br><p>  Alles schien in Ordnung zu sein, aber warum habe ich nach einer solchen Optimierung die erste Version der Anfrage für mich belassen, bis ihre Leistung ausreichte?  Ja, da die optimierte Version zweifellos schneller ist, aber viel mehr Zeit benötigt, um zu verstehen, wie sie funktioniert, dh die Lesbarkeit hat sich verschlechtert.  Das heißt, wenn ich die Anfrage das nächste Mal unter meinen geänderten Bedingungen neu schreiben muss, muss ich (oder nicht ich) viel mehr Zeit damit verbringen, zu verstehen, wie die Anfrage funktioniert. </p><br><p>  Das ist alles für heute, halten Sie die Tentakel warm und ich verabschiede mich von Ihnen bis zur nächsten Veröffentlichung von Radio SQL. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459236/">https://habr.com/ru/post/de459236/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459224/index.html">Vom Makler zum Spieleentwickler 2. „Operation: Android“</a></li>
<li><a href="../de459226/index.html">"Fast-PoE und Perpetual-PoE - sind das neue Standards oder nicht?"</a></li>
<li><a href="../de459230/index.html">Eine Reise zum Call Center und Product Backlog mit den Augen des Entwicklers</a></li>
<li><a href="../de459232/index.html">Surround, Bite, Cut: Der neue Mini AI Cup # 4 Wettbewerb</a></li>
<li><a href="../de459234/index.html">Smem - Berichte zur Speicherzuordnung zwischen Prozessen und Benutzern unter Linux</a></li>
<li><a href="../de459238/index.html">Aus einer magischen mathematischen Funktion - eine Lösung, um sie alle zu regieren</a></li>
<li><a href="../de459240/index.html">10 Jahre in der IT mit Schizophrenie diagnostiziert, Überlebenstipps</a></li>
<li><a href="../de459242/index.html">Im Anschluss an die T + Conf 2019 Konferenz</a></li>
<li><a href="../de459244/index.html">Hinweise Produktmanager: Benutzerverhalten auf Spieleseiten im App Store. Wie lange dauert das Herunterladen eines Spiels?</a></li>
<li><a href="../de459246/index.html">Warum nimmt die Site-Conversion ab? Beispiele für 60 Design- und Usability-Fehler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>